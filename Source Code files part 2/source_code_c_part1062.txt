            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                        return FALSE;
                    }
                }
                continue;
            }

            if (!frs.Initialize(i, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frs.Read()) {
                if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                }
                continue;
            }

            // The following loop deletes all $INDEX_ALLOCATION attributes that
            // don't have a corresponding $INDEX_ROOT attribute.

            need_write = FALSE;

            for (j = 0; frs.QueryAttributeByOrdinal(&alloc_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ALLOCATION,
                                                    j); j++) {

                // Make sure that there's an index root of the same name
                // here.  Otherwise tube this attribute.

                if (frs.IsAttributePresent($INDEX_ROOT, alloc_attrib.GetName())) {
                    continue;
                }

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                ChkdskInfo->FilesWithIndices.SetFree(i, 1);

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_INDEX_ROOT,
                             "%I64x%W",
                             frs.QueryFileNumber().GetLargeInteger(),
                             alloc_attrib.GetName());

                Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                 "%d%W",
                        frs.QueryFileNumber().GetLowPart(),
                        alloc_attrib.GetName());
                DebugPrintTrace(("UNTFS: Index allocation without index root.\n"));

                need_write = TRUE;

                if (!alloc_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs.PurgeAttribute(alloc_attrib.QueryTypeCode(),
                                        alloc_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                // Because we deleted a $INDEX_ALLOCATION we need to
                // adjust j.

                j--;


                // If there's a $BITMAP then tube that also.

                if (!frs.QueryAttribute(&bitmap_attrib,
                                        &ErrorInAttribute,
                                        $BITMAP,
                                        alloc_attrib.GetName())) {

                    if (ErrorInAttribute) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    continue;
                }

                if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                        bitmap_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }


            // This loop goes through all of the $INDEX_ROOT attributes in
            // this FRS.

            for (j = 0; frs.QueryAttributeByOrdinal(&root_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ROOT,
                                                    j); j++) {

                // First find out if we have an INDEX_ALLOCATION here.

                alloc_present = frs.QueryAttribute(&alloc_attrib,
                                                   &ErrorInAttribute,
                                                   $INDEX_ALLOCATION,
                                                   root_attrib.GetName());

                if (!alloc_present && ErrorInAttribute) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                error_in_index = FALSE;

                if (!VerifyAndFixIndex(ChkdskInfo,
                                       &root_attrib,
                                       alloc_present ? &alloc_attrib : NULL,
                                       alloc_present ? &alloc_bitmap : NULL,
                                       frs.QueryFileNumber(),
                                       BadClusters,
                                       Mft,
                                       AttributeDefTable,
                                       &tube,
                                       &order,
                                       FixLevel, Message,
                                       &error_in_index)) {

                    return FALSE;
                }

                *DiskErrorsFound = *DiskErrorsFound || error_in_index;

                if (tube) {

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    need_write = TRUE;

                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_INDEX,
                            "%d%W",
                            frs.QueryFileNumber().GetLowPart(),
                            root_attrib.GetName());

                    if (!root_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                        !frs.PurgeAttribute(root_attrib.QueryTypeCode(),
                                            root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    // Adjust j because an $INDEX_ROOT has just been removed.

                    j--;

                    if (alloc_present) {

                        if (!alloc_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                            !frs.PurgeAttribute(alloc_attrib.QueryTypeCode(),
                                                alloc_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        if (frs.QueryAttribute(&bitmap_attrib,
                                               &ErrorInAttribute,
                                               $BITMAP,
                                               root_attrib.GetName())) {

                            if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                                !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                                    bitmap_attrib.GetName())) {

                                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                                return FALSE;
                            }
                        } else if (ErrorInAttribute) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    }

                    if (!index_name.Initialize(FileNameIndexNameData)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (index_name.Strcmp(root_attrib.GetName()) == 0) {
                        frs.ClearIndexPresent();
                        ChkdskInfo->FilesWhoNeedData.SetAllocated(i, 1);
                    }
                    ChkdskInfo->CountFilesWithIndices -= 1;
                    ChkdskInfo->FilesWithIndices.SetFree(i, 1);

                    continue;
                }

                if (root_attrib.IsStorageModified()) {

                    need_write = TRUE;

                    if (!root_attrib.InsertIntoFile(&frs,
                                                    Mft->GetVolumeBitmap())) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());
                    }
                }

                if (alloc_present && alloc_attrib.IsStorageModified()) {

                    need_write = TRUE;

                    if (!alloc_attrib.InsertIntoFile(&frs,
                                                     Mft->GetVolumeBitmap())) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());
                    }
                }

                if (alloc_present) {

                    BOOLEAN bitmap_present;
                    BOOLEAN bitmaps_equal;
                    BOOLEAN error;

                    // Make sure the bitmap is present and good.

                    complete_failure = FALSE;

                    bitmap_present = frs.QueryAttribute(&bitmap_attrib,
                                                        &ErrorInAttribute,
                                                        $BITMAP,
                                                        root_attrib.GetName());

                    if (bitmap_present) {
                        bitmaps_equal = AreBitmapsEqual(&bitmap_attrib,
                                                        &alloc_bitmap,
                                                        alloc_bitmap.QuerySize(),
                                                        Message,
                                                        &complete_failure);

                        //
                        // Make an exception here for cases where our internal bitmap
                        // is size zero but there is a positively-sized bitmap attribute,
                        // as long as the bitmap attribute's contents are zeroed.  The
                        // filesystem can leave the disk in this state after all the files
                        // are deleted from a large directory.
                        //

                        if (!bitmaps_equal && alloc_bitmap.QuerySize() == 0 &&
                            bitmap_attrib.QueryValueLength() > 0 &&
                            bitmap_attrib.IsAllocationZeroed()) {

                            bitmaps_equal = TRUE;
                        }
                    }


                    if (!bitmap_present || !bitmaps_equal) {

                        MSGID   msgid;

                        need_write = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        if (!bitmap_present) {
                            msgid = MSG_CHKLOG_NTFS_INDEX_BITMAP_MISSING;
                        } else {
                            DebugAssert(!bitmaps_equal);
                            msgid = MSG_CHKLOG_NTFS_INCORRECT_INDEX_BITMAP;
                        }
                        Message->LogMsg(msgid, "%I64x%W",
                                     frs.QueryFileNumber().GetLargeInteger(),
                                     root_attrib.GetName());

                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());

                        DebugPrintTrace(("UNTFS: Incorrect index bitmap.\n"));

                        if (complete_failure ||
                            !(bitmap_value = (PVOID)
                              alloc_bitmap.GetBitmapData(&bitmap_length)) ||
                            !bitmap_attrib.Initialize(_drive,
                                                      QueryClusterFactor(),
                                                      bitmap_value,
                                                      bitmap_length,
                                                      $BITMAP,
                                                      root_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        if (!bitmap_attrib.InsertIntoFile(&frs,
                                                          Mft->GetVolumeBitmap())) {

                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                        }
                    }
                } else {

                    // Since there's no allocation, make sure that there's
                    // no bitmap, either.
                    //

                    if (frs.QueryAttribute(&bitmap_attrib,
                                           &ErrorInAttribute,
                                           $BITMAP,
                                           root_attrib.GetName())) {

                        need_write = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        Message->LogMsg(MSG_CHKLOG_NTFS_EXTRA_INDEX_BITMAP,
                                     "%I64x%W",
                                     frs.QueryFileNumber().GetLargeInteger(),
                                     root_attrib.GetName());

                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                         frs.QueryFileNumber().GetLowPart(),
                                         root_attrib.GetName());

                        DebugPrintTrace(("UNTFS: no index allocation; removing bitmap.\n"));

                        if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                            !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                                bitmap_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    } else if (ErrorInAttribute) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                }

                // Don't go on to sort this, if you're in read/only
                // and it's corrupt.

                if ((error_in_index || need_write) && FixLevel == CheckOnly) {
                    continue;
                }


                // Now make sure that this is ordered.  The
                // Attribute Definition Table indicates whether indices
                // over this attribute can have duplicate entries.
                // Since this index has already passed through VerifyAndFixIndex,
                // the following operations are safe.
                //
                // Determine the indexed attribute type:
                //

                if ((frs.QueryFileNumber() != SECURITY_TABLE_NUMBER &&
                     frs.QueryFileNumber() != ChkdskInfo->QuotaFileNumber &&
                     frs.QueryFileNumber() != ChkdskInfo->ObjectIdFileNumber &&
                     frs.QueryFileNumber() != ChkdskInfo->ReparseFileNumber) ||
                    ChkdskInfo->major <= 1) {

                    index_root = (PINDEX_ROOT)root_attrib.GetResidentValue();
                    indexed_attribute_type = index_root->IndexedAttributeType;

                    AttributeDefTable->QueryIndex( indexed_attribute_type,
                                                   &attr_def_index );

                    duplicates_allowed =
                        0 != (AttributeDefTable->QueryFlags(attr_def_index) &
                            ATTRIBUTE_DEF_DUPLICATES_ALLOWED);

                } else
                    duplicates_allowed = FALSE;

                if (order > 0 ||
                    (order == 0 && !duplicates_allowed)) {

                    switch (frs.SortIndex(root_attrib.GetName(),
                                          Mft->GetVolumeBitmap(),
                                          duplicates_allowed,
                                          FixLevel == CheckOnly)) {
                        case NTFS_SORT_INDEX_WELL_ORDERED:
                            break;

                        case NTFS_SORT_INDEX_SORTED:
                        case NTFS_SORT_INDEX_BADLY_ORDERED:
                            *DiskErrorsFound = TRUE;
                            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                            Message->DisplayMsg(MSG_CHK_NTFS_BADLY_ORDERED_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                            need_write = TRUE;
                            break;

                        case NTFS_SORT_INDEX_NOT_FOUND:
                            DebugPrint("Index not found");

                            // Fall through.

                        case NTFS_SORT_ERROR:
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;

                        case NTFS_SORT_INSERT_FAILED:
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                            break;
                    }
                }

                // Update the chkdsk report.

                ChkdskReport->NumIndices += 1;

                if (alloc_present) {
                    ChkdskReport->BytesInIndices +=
                        alloc_attrib.QueryAllocatedLength();
                }

                if (frs.QueryFileNumber() == SECURITY_TABLE_NUMBER &&
                    ChkdskInfo->major >= 2) {
                    ChkdskInfo->FilesWhoNeedData.SetFree(SECURITY_TABLE_NUMBER, 1);
                } else if (frs.QueryFileNumber() == ChkdskInfo->QuotaFileNumber) {

                    DSTRING     IndexName;

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->QuotaFileNumber, 1);
                    if (!IndexName.Initialize(Userid2SidQuotaNameData)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (root_attrib.GetName()->Strcmp(&IndexName) == 0) {
                        switch (frs.VerifyAndFixQuotaDefaultId(Mft->GetVolumeBitmap(),
                                                             FixLevel == CheckOnly)) {
                          case NTFS_QUOTA_INDEX_FOUND:
                              break;

                          case NTFS_QUOTA_INDEX_INSERTED:
                          case NTFS_QUOTA_DEFAULT_ENTRY_MISSING:
                              *DiskErrorsFound = TRUE;
                              errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                              Message->DisplayMsg(MSG_CHK_NTFS_DEFAULT_QUOTA_ENTRY_MISSING,
                                               "%d%W",
                                      frs.QueryFileNumber().GetLowPart(),
                                      root_attrib.GetName());
                              need_write = TRUE;
                              break;

                          case NTFS_QUOTA_INDEX_NOT_FOUND:
                              // possibly quota disabled
                              break;

                          case NTFS_QUOTA_ERROR:
                              Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                              return FALSE;

                          case NTFS_QUOTA_INSERT_FAILED:
                              ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                              Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                               "%d%W",
                                      frs.QueryFileNumber().GetLowPart(),
                                      root_attrib.GetName());
                              break;
                        }
                    }

                } else if (frs.QueryFileNumber() == ChkdskInfo->ObjectIdFileNumber) {

                   // Now go through all of the index entries and make sure
                   // that they point somewhere decent.

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->ObjectIdFileNumber, 1);

                    if (!SkipEntriesScan) {
                        if (!index.Initialize(_drive, QueryClusterFactor(),
                                              Mft->GetVolumeBitmap(),
                                              Mft->GetUpcaseTable(),
                                              frs.QuerySize()/2,
                                              &frs,
                                              root_attrib.GetName())) {

                           Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                           return FALSE;
                        }

                        if (!ValidateEntriesInObjIdIndex(&index, &frs, ChkdskInfo,
                                                         &changes, Mft, FixLevel,
                                                         Message, DiskErrorsFound)) {
                           return FALSE;
                        }

                        if (changes) {
                            need_write = TRUE;
                        }
                    }

                } else if (frs.QueryFileNumber() == ChkdskInfo->ReparseFileNumber) {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->ReparseFileNumber, 1);

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInReparseIndex(&index, &frs, ChkdskInfo,
                                                       &changes, Mft, FixLevel,
                                                       Message, DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                        need_write = TRUE;
                    }

                } else {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInIndex(&index, &frs, ChkdskInfo,
                                                DirectoryDigraph,
                                                &percent_done, &num_file_names,
                                                &changes,
                                                Mft, SkipEntriesScan,
                                                SkipCycleScan,
                                                FixLevel, Message,
                                                DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                       if (FixLevel != CheckOnly && !index.Save(&frs)) {
                           Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                            "%d%W",
                                   frs.QueryFileNumber().GetLowPart(),
                                   index.GetName());
                           ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                       }
                       need_write = TRUE;
                    }

                    if (i == EXTEND_TABLE_NUMBER && ChkdskInfo->major >= 2) {
                        if (!ExtractExtendInfo(&index, ChkdskInfo, Message))
                            return FALSE;
                    }
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (need_write) {
                *DiskErrorsFound = TRUE;
            }

            if (need_write &&
                FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {

                DebugAbort("Can't write readable FRS");
                return FALSE;
            }
        }
    } else {    // Algorithm != 0

        BIG_INT         start_frs;
        BOOLEAN         out_of_memory;
        USHORT          passes;
        BIG_INT         increment, increment_fraction, remainder;

        DebugAssert(SkipEntriesScan == FALSE);

        ChkdskInfo->TotalNumFileNames += (ChkdskInfo->NumFiles/16 +
                                          ChkdskInfo->NumFiles*2 +
                                          (ChkdskInfo->NumFiles*Algorithm)/16);

        if (ChkdskInfo->CountFilesWithIndices != 0) {
            increment = ChkdskInfo->NumFiles / ChkdskInfo->CountFilesWithIndices;
            increment_fraction = ChkdskInfo->NumFiles -
                                 increment * ChkdskInfo->CountFilesWithIndices;
        } else {
            increment = 0;
            increment_fraction = 0;
        }
        remainder = 0;


#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
        time(&timel1);
        timestr = ctime(&timel1);
        timestr[strlen(timestr)-1] = 0;
        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                            "%s%s", "Banding before stage 1: ", timestr);
#endif
        for (i=0; i < ChkdskInfo->NumFiles; i++) {

            if ((i & 0xf) == 0)
                num_file_names += 1;

            new_percent = ((num_file_names * 100) / ChkdskInfo->TotalNumFileNames).GetLowPart();
            if (new_percent != percent_done) {
                percent_done = new_percent;
                if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                    return FALSE;
                }
            }

            if (ChkdskInfo->FilesWithIndices.IsFree(i, 1)) {
                continue;
            }

            remainder += increment_fraction;
            while (remainder >= ChkdskInfo->CountFilesWithIndices) {
                remainder -= ChkdskInfo->CountFilesWithIndices;
                num_file_names += 1;
            }
            num_file_names += increment;

            if (!frs.Initialize(i, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frs.Read()) {
                if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                }
                continue;
            }

            // The following loop deletes all $INDEX_ALLOCATION attributes that
            // don't have a corresponding $INDEX_ROOT attribute.

            need_write = FALSE;

            for (j = 0; frs.QueryAttributeByOrdinal(&alloc_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ALLOCATION,
                                                    j); j++) {

                // Make sure that there's an index root of the same name
                // here.  Otherwise tube this attribute.

                if (frs.IsAttributePresent($INDEX_ROOT, alloc_attrib.GetName())) {
                    continue;
                }

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                ChkdskInfo->FilesWithIndices.SetFree(i, 1);

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_INDEX_ROOT,
                                "%I64x%W",
                                frs.QueryFileNumber().GetLargeInteger(),
                                alloc_attrib.GetName());

                Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                    "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    alloc_attrib.GetName());
                DebugPrintTrace(("UNTFS: Index allocation without index root.\n"));

                need_write = TRUE;

                if (!alloc_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs.PurgeAttribute(alloc_attrib.QueryTypeCode(),
                                        alloc_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                // Because we deleted a $INDEX_ALLOCATION we need to
                // adjust j.

                j--;


                // If there's a $BITMAP then tube that also.

                if (!frs.QueryAttribute(&bitmap_attrib,
                                        &ErrorInAttribute,
                                        $BITMAP,
                                        alloc_attrib.GetName())) {

                    if (ErrorInAttribute) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    continue;
                }

                if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                        bitmap_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }


            // This loop goes through all of the $INDEX_ROOT attributes in
            // this FRS.

            for (j = 0; frs.QueryAttributeByOrdinal(&root_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ROOT,
                                                    j); j++) {

                // First find out if we have an INDEX_ALLOCATION here.

                alloc_present = frs.QueryAttribute(&alloc_attrib,
                                                   &ErrorInAttribute,
                                                   $INDEX_ALLOCATION,
                                                   root_attrib.GetName());

                if (!alloc_present && ErrorInAttribute) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                error_in_index = FALSE;

                if (!VerifyAndFixIndex(ChkdskInfo,
                                       &root_attrib,
                                       alloc_present ? &alloc_attrib : NULL,
                                       alloc_present ? &alloc_bitmap : NULL,
                                       frs.QueryFileNumber(),
                                       BadClusters,
                                       Mft,
                                       AttributeDefTable,
                                       &tube,
                                       &order,
                                       FixLevel, Message,
                                       &error_in_index)) {

                    return FALSE;
                }

                *DiskErrorsFound = *DiskErrorsFound || error_in_index;

                if (tube) {

                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                    need_write = TRUE;

                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_INDEX,
                                        "%d%W",
                                        frs.QueryFileNumber().GetLowPart(),
                                        root_attrib.GetName());

                    if (!root_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                        !frs.PurgeAttribute(root_attrib.QueryTypeCode(),
                                            root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    // Adjust j because an $INDEX_ROOT has just been removed.

                    j--;

                    if (alloc_present) {

                        if (!alloc_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                            !frs.PurgeAttribute(alloc_attrib.QueryTypeCode(),
                                                alloc_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        if (frs.QueryAttribute(&bitmap_attrib,
                                               &ErrorInAttribute,
                                               $BITMAP,
                                               root_attrib.GetName())) {

                            if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                                !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                                    bitmap_attrib.GetName())) {

                                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                                return FALSE;
                            }
                        } else if (ErrorInAttribute) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    }

                    if (!index_name.Initialize(FileNameIndexNameData)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (index_name.Strcmp(root_attrib.GetName()) == 0) {
                        frs.ClearIndexPresent();
                        ChkdskInfo->FilesWhoNeedData.SetAllocated(i, 1);
                    }
                    ChkdskInfo->CountFilesWithIndices -= 1;
                    ChkdskInfo->FilesWithIndices.SetFree(i, 1);

                    continue;
                }

                if (root_attrib.IsStorageModified()) {

                    need_write = TRUE;

                    if (!root_attrib.InsertIntoFile(&frs,
                                                    Mft->GetVolumeBitmap())) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());
                    }
                }

                if (alloc_present && alloc_attrib.IsStorageModified()) {

                    need_write = TRUE;

                    if (!alloc_attrib.InsertIntoFile(&frs,
                                                     Mft->GetVolumeBitmap())) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());
                    }
                }

                if (alloc_present) {

                    BOOLEAN bitmap_present;
                    BOOLEAN bitmaps_equal;
                    BOOLEAN error;

                    // Make sure the bitmap is present and good.

                    complete_failure = FALSE;

                    bitmap_present = frs.QueryAttribute(&bitmap_attrib,
                                                        &ErrorInAttribute,
                                                        $BITMAP,
                                                        root_attrib.GetName());

                    if (bitmap_present) {
                        bitmaps_equal = AreBitmapsEqual(&bitmap_attrib,
                                                        &alloc_bitmap,
                                                        alloc_bitmap.QuerySize(),
                                                        Message,
                                                        &complete_failure);

                        //
                        // Make an exception here for cases where our internal bitmap
                        // is size zero but there is a positively-sized bitmap attribute,
                        // as long as the bitmap attribute's contents are zeroed.  The
                        // filesystem can leave the disk in this state after all the files
                        // are deleted from a large directory.
                        //

                        if (!bitmaps_equal && alloc_bitmap.QuerySize() == 0 &&
                            bitmap_attrib.QueryValueLength() > 0 &&
                            bitmap_attrib.IsAllocationZeroed()) {

                            bitmaps_equal = TRUE;
                        }
                    }


                    if (!bitmap_present || !bitmaps_equal) {

                        MSGID   msgid;

                        need_write = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        if (!bitmap_present) {
                            msgid = MSG_CHKLOG_NTFS_INDEX_BITMAP_MISSING;
                        } else {
                            DebugAssert(!bitmaps_equal);
                            msgid = MSG_CHKLOG_NTFS_INCORRECT_INDEX_BITMAP;
                        }
                        Message->LogMsg(msgid, "%I64x%W",
                                     frs.QueryFileNumber().GetLargeInteger(),
                                     root_attrib.GetName());

                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                frs.QueryFileNumber().GetLowPart(),
                                root_attrib.GetName());

                        DebugPrintTrace(("UNTFS: Incorrect index bitmap.\n"));

                        if (complete_failure ||
                            !(bitmap_value = (PVOID)
                              alloc_bitmap.GetBitmapData(&bitmap_length)) ||
                            !bitmap_attrib.Initialize(_drive,
                                                      QueryClusterFactor(),
                                                      bitmap_value,
                                                      bitmap_length,
                                                      $BITMAP,
                                                      root_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        if (!bitmap_attrib.InsertIntoFile(&frs,
                                                          Mft->GetVolumeBitmap())) {

                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                        }
                    }
                } else {

                    // Since there's no allocation, make sure that there's
                    // no bitmap, either.
                    //

                    if (frs.QueryAttribute(&bitmap_attrib,
                                           &ErrorInAttribute,
                                           $BITMAP,
                                           root_attrib.GetName())) {

                        need_write = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        Message->LogMsg(MSG_CHKLOG_NTFS_EXTRA_INDEX_BITMAP,
                                     "%I64x%W",
                                     frs.QueryFileNumber().GetLargeInteger(),
                                     root_attrib.GetName());

                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                         frs.QueryFileNumber().GetLowPart(),
                                         root_attrib.GetName());

                        DebugPrintTrace(("UNTFS: no index allocation; removing bitmap.\n"));

                        if (!bitmap_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                            !frs.PurgeAttribute(bitmap_attrib.QueryTypeCode(),
                                                bitmap_attrib.GetName())) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    } else if (ErrorInAttribute) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                }

                // Don't go on to sort this, if you're in read/only
                // and it's corrupt.

                if ((error_in_index || need_write) && FixLevel == CheckOnly) {
                    continue;
                }


                // Now make sure that this is ordered.  The
                // Attribute Definition Table indicates whether indices
                // over this attribute can have duplicate entries.
                // Since this index has already passed through VerifyAndFixIndex,
                // the following operations are safe.
                //
                // Determine the indexed attribute type:
                //

                if ((frs.QueryFileNumber() != SECURITY_TABLE_NUMBER &&
                     frs.QueryFileNumber() != ChkdskInfo->QuotaFileNumber &&
                     frs.QueryFileNumber() != ChkdskInfo->ObjectIdFileNumber &&
                     frs.QueryFileNumber() != ChkdskInfo->ReparseFileNumber) ||
                    ChkdskInfo->major <= 1) {

                    index_root = (PINDEX_ROOT)root_attrib.GetResidentValue();
                    indexed_attribute_type = index_root->IndexedAttributeType;

                    AttributeDefTable->QueryIndex( indexed_attribute_type,
                                                   &attr_def_index );

                    duplicates_allowed =
                        0 != (AttributeDefTable->QueryFlags(attr_def_index) &
                            ATTRIBUTE_DEF_DUPLICATES_ALLOWED);

                } else
                    duplicates_allowed = FALSE;

                if (order > 0 ||
                    (order == 0 && !duplicates_allowed)) {

                    switch (frs.SortIndex(root_attrib.GetName(),
                                          Mft->GetVolumeBitmap(),
                                          duplicates_allowed,
                                          FixLevel == CheckOnly)) {
                        case NTFS_SORT_INDEX_WELL_ORDERED:
                            break;

                        case NTFS_SORT_INDEX_SORTED:
                        case NTFS_SORT_INDEX_BADLY_ORDERED:
                            *DiskErrorsFound = TRUE;
                            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                            Message->DisplayMsg(MSG_CHK_NTFS_BADLY_ORDERED_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                            need_write = TRUE;
                            break;

                        case NTFS_SORT_INDEX_NOT_FOUND:
                            DebugPrint("Index not found");

                            // Fall through.

                        case NTFS_SORT_ERROR:
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;

                        case NTFS_SORT_INSERT_FAILED:
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W",
                                    frs.QueryFileNumber().GetLowPart(),
                                    root_attrib.GetName());
                            break;
                    }
                }

                // Update the chkdsk report.

                ChkdskReport->NumIndices += 1;

                if (alloc_present) {
                    ChkdskReport->BytesInIndices +=
                        alloc_attrib.QueryAllocatedLength();
                }

                if (frs.QueryFileNumber() == SECURITY_TABLE_NUMBER &&
                    ChkdskInfo->major >= 2) {
                    ChkdskInfo->FilesWhoNeedData.SetFree(SECURITY_TABLE_NUMBER, 1);
                } else if (frs.QueryFileNumber() == ChkdskInfo->QuotaFileNumber) {

                    DSTRING     IndexName;

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->QuotaFileNumber, 1);
                    if (!IndexName.Initialize(Userid2SidQuotaNameData)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (root_attrib.GetName()->Strcmp(&IndexName) == 0) {
                        switch (frs.VerifyAndFixQuotaDefaultId(Mft->GetVolumeBitmap(),
                                                             FixLevel == CheckOnly)) {
                          case NTFS_QUOTA_INDEX_FOUND:
                              break;

                          case NTFS_QUOTA_INDEX_INSERTED:
                          case NTFS_QUOTA_DEFAULT_ENTRY_MISSING:
                              *DiskErrorsFound = TRUE;
                              errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                              Message->DisplayMsg(MSG_CHK_NTFS_DEFAULT_QUOTA_ENTRY_MISSING,
                                               "%d%W",
                                      frs.QueryFileNumber().GetLowPart(),
                                      root_attrib.GetName());
                              need_write = TRUE;
                              break;

                          case NTFS_QUOTA_INDEX_NOT_FOUND:
                              // possibly quota disabled
                              break;

                          case NTFS_QUOTA_ERROR:
                              Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                              return FALSE;

                          case NTFS_QUOTA_INSERT_FAILED:
                              ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                              Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                               "%d%W",
                                      frs.QueryFileNumber().GetLowPart(),
                                      root_attrib.GetName());
                              break;
                        }
                    }

                } else if (frs.QueryFileNumber() == ChkdskInfo->ObjectIdFileNumber) {

                   // Now go through all of the index entries and make sure
                   // that they point somewhere decent.

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->ObjectIdFileNumber, 1);

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                       Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                       return FALSE;
                    }

                    if (!ValidateEntriesInObjIdIndex(&index, &frs, ChkdskInfo,
                                                     &changes, Mft, FixLevel,
                                                     Message, DiskErrorsFound)) {
                       return FALSE;
                    }

                    if (changes) {
                        need_write = TRUE;
                    }

                } else if (frs.QueryFileNumber() == ChkdskInfo->ReparseFileNumber) {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    ChkdskInfo->FilesWhoNeedData.SetFree(ChkdskInfo->ReparseFileNumber, 1);

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInReparseIndex(&index, &frs, ChkdskInfo,
                                                       &changes, Mft, FixLevel,
                                                       Message, DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                        need_write = TRUE;
                    }
                } else if (frs.QueryFileNumber() == EXTEND_TABLE_NUMBER) {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          frs.QuerySize()/2,
                                          &frs,
                                          root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInIndex(&index, &frs, ChkdskInfo,
                                                DirectoryDigraph,
                                                &percent_done, &num_file_names,
                                                &changes,
                                                Mft, FALSE,
                                                SkipCycleScan,
                                                FixLevel, Message,
                                                DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                       if (FixLevel != CheckOnly && !index.Save(&frs)) {
                           Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                            "%d%W",
                                   frs.QueryFileNumber().GetLowPart(),
                                   index.GetName());
                           ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                       }
                       need_write = TRUE;
                    }

                    if (i == EXTEND_TABLE_NUMBER && ChkdskInfo->major >= 2) {
                        if (!ExtractExtendInfo(&index, ChkdskInfo, Message))
                            return FALSE;
                    }
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (need_write) {
                *DiskErrorsFound = TRUE;
            }

            if (need_write &&
                FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {

                DebugAbort("Can't write readable FRS");
                return FALSE;
            }
        }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
        time(&timel2);
        Message->Lock();
        Message->Set(MSG_CHK_NTFS_MESSAGE);
        timestr = ctime(&timel2);
        timestr[strlen(timestr)-1] = 0;
        Message->Display("%s%s", "Banding after stage 1: ", timestr);
        Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(timel2, timel1));
        Message->Unlock();
#endif
        start_frs = 0;

        if (!mft_info.Initialize(ChkdskInfo->NumFiles,
                                 Mft->GetUpcaseTable(),
                                 NTFS_SA::_MajorVersion,
                                 NTFS_SA::_MinorVersion,
                                 max_mem_use_for_mft_info.GetLargeInteger().QuadPart)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
        time(&timel1);
#endif
        for (passes=1; passes <= Algorithm; passes++) {

            if (!mft_info.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            for (i=start_frs.GetLowPart(); i < ChkdskInfo->NumFiles; i++) {

                new_percent = ((num_file_names*100) / ChkdskInfo->TotalNumFileNames).GetLowPart();
                if (new_percent != percent_done) {
                    percent_done = new_percent;
                    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                        return FALSE;
                    }
                }

                num_file_names += 1;

                if (i % MFT_READ_CHUNK_SIZE == 0) {
                    ULONG       remaining_frs;
                    ULONG       number_to_read;

                    remaining_frs = ChkdskInfo->NumFiles - i;
                    number_to_read = min(MFT_READ_CHUNK_SIZE, remaining_frs);

                    if (!frs.Initialize(i, number_to_read, Mft)) {
                        Message->Set(MSG_CHK_NO_MEMORY);
                        Message->Display();
                        return FALSE;
                    }
                }

                if (!frs.Initialize()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                if (!frs.ReadNext(i)) {
                    if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                        Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                    }
                    continue;
                }

                if (!frs.IsBase() || !frs.IsInUse()) {
                    continue;
                }

                files_with_too_many_filenames =
                    ChkdskInfo->FilesWithTooManyFileNames.DoesIntersectSet(i, 1);

                if (!files_with_too_many_filenames &&
                    !frs.VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                               ChkdskInfo,
                                               FixLevel,
                                               Message,
                                               DiskErrorsFound,
                                               FALSE)) {
                    return FALSE;
                }

                // After verifying the file names we know that this FRS is
                // not a candidate for a missing data attribute if it has
                // its index bit set.

                if (frs.IsIndexPresent()) {
                    ChkdskInfo->FilesWhoNeedData.SetFree(i, 1);
                }

                if (!mft_info.ExtractIndexEntryInfo(&frs,
                                                    Message,
                                                    files_with_too_many_filenames,
                                                    &out_of_memory)) {
                    if (out_of_memory) {
                        DebugAssert(passes < Algorithm);
                        DebugAssert(mft_info.QueryMinFileNumber() == start_frs);
                        start_frs = i;
                        DebugAssert(mft_info.QueryMaxFileNumber() == (i-1));
                        break;
                    }
                    return FALSE;
                }
            }
            mft_info.UpdateRange(i-1);

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
            time(&timel2);
            Message->Lock();
            Message->Set(MSG_CHK_NTFS_MESSAGE);
            timestr = ctime(&timel2);
            timestr[strlen(timestr)-1] = 0;
            Message->Display("%s%s", "Banding after stage 2: ", timestr);
            Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(timel2, timel1));
            Message->Unlock();
            time(&timel1);
#endif

            for (i = 0; i < ChkdskInfo->NumFiles; i++) {

                if ((i & 0xF) == 0) {
                    num_file_names += 1;
                }

                if (i == SECURITY_TABLE_NUMBER ||
                    i == EXTEND_TABLE_NUMBER ||
                    i == ChkdskInfo->QuotaFileNumber ||
                    i == ChkdskInfo->ObjectIdFileNumber ||
                    i == ChkdskInfo->ReparseFileNumber ||
                    ChkdskInfo->FilesWithIndices.IsFree(i, 1)) {

                    new_percent = ((num_file_names*100) / ChkdskInfo->TotalNumFileNames).GetLowPart();
                    if (new_percent != percent_done) {
                        percent_done = new_percent;
                        if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                            return FALSE;
                        }
                    }
                    continue;
                }

                if (!frs.Initialize(i, Mft)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (!frs.Read()) {
                    if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                        Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                    }
                    continue;
                }

                need_write = FALSE;

                // This loop goes through all of the $INDEX_ROOT attributes in
                // this FRS.

                for (j = 0; frs.QueryAttributeByOrdinal(&root_attrib,
                                                        &ErrorInAttribute,
                                                        $INDEX_ROOT,
                                                        j); j++) {

                    // Now go through all of the index entries and make sure
                    // that they point somewhere decent.

                    if (!index.Initialize(_drive, QueryClusterFactor(),
                                         Mft->GetVolumeBitmap(),
                                         Mft->GetUpcaseTable(),
                                         frs.QuerySize()/2,
                                         &frs,
                                         root_attrib.GetName())) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!ValidateEntriesInIndex(&index, &frs, ChkdskInfo,
                                                &mft_info,
                                                DirectoryDigraph,
                                                &percent_done, &num_file_names,
                                                &changes,
                                                Mft,
                                                SkipCycleScan,
                                                FixLevel, Message,
                                                DiskErrorsFound)) {
                        return FALSE;
                    }

                    if (changes) {
                        if (FixLevel != CheckOnly && !index.Save(&frs)) {
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                                "%d%W",
                                                frs.QueryFileNumber().GetLowPart(),
                                                index.GetName());
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                        }
                        need_write = TRUE;
                    }
                }

                if (ErrorInAttribute) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (need_write) {
                    *DiskErrorsFound = TRUE;
                }

                if (need_write &&
                    FixLevel != CheckOnly &&
                    !frs.Flush(Mft->GetVolumeBitmap())) {

                    DebugAbort("Can't write readable FRS");
                    return FALSE;
                }
            }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
            time(&timel2);
            Message->Lock();
            Message->Set(MSG_CHK_NTFS_MESSAGE);
            timestr = ctime(&timel2);
            timestr[strlen(timestr)-1] = 0;
            Message->Display("%s%s", "Banding after stage 3: ", timestr);
            Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(timel2, timel1));
            Message->Unlock();
#endif
        }

        DebugAssert(i == ChkdskInfo->NumFiles);
    }

    if (SkipEntriesScan && ChkdskInfo->IndexEntriesToCheckIsSet) {

        NUMBER_SET      parents;
        BIG_INT         parent;
        NTFS_ATTRIBUTE  attrib;

        for (i=0; i < ChkdskInfo->NumFiles; i++) {

            if (ChkdskInfo->IndexEntriesToCheck.IsFree(i, 1))
                continue;

            // remove all links pointing to child

            if (!SkipCycleScan && DirectoryDigraph->QueryParents(i, &parents)) {
                while (parents.QueryCardinality() != 0) {
                    parent = parents.QueryNumber(0);
                    DebugAssert(parent.GetHighPart() == 0);
                    if (!parents.Remove(parent)) {
                        DebugPrintTrace(("Unable to remove %d from the number set.\n", parent));
                        return FALSE;
                    }
                    if (!DirectoryDigraph->RemoveEdge(parent.GetLowPart(), i)) {
                        DebugPrintTrace(("Unable to remove an edge between %d and %d.\n",
                                         parent, i));
                        return FALSE;
                    }
                }
            }

            if (!frs.Initialize(i, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frs.Read()) {
                if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                }
                continue;
            }

            // restore the number of files names count for this frs

            ChkdskInfo->NumFileNames[i] = 0;

            for (j=0; frs.QueryAttributeByOrdinal(&attrib,
                                                  &ErrorInAttribute,
                                                  $FILE_NAME,
                                                  j); j++) {
                ChkdskInfo->NumFileNames[i]++;
            }

            // restore the reference count for this frs

            ChkdskInfo->ReferenceCount[i] = (SHORT)frs.QueryReferenceCount();
        }

        // now rescan all the indices and check only those questionable frs references

        ULONG       num_dirs_checked = 0;
        ULONG       num_dirs = max(1, ChkdskInfo->CountFilesWithIndices);

        for (i = 0; i < ChkdskInfo->NumFiles; i++) {

            new_percent = ((num_dirs_checked*10) / num_dirs) + 90;

            if (new_percent != percent_done) {
                percent_done = new_percent;
                if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                    return FALSE;
                }
            }

            if (ChkdskInfo->FilesWithIndices.IsFree(i, 1)) {
                continue;
            }

            num_dirs_checked += 1;

            if (i == ChkdskInfo->ObjectIdFileNumber ||
                i == ChkdskInfo->ReparseFileNumber ||
                i == ChkdskInfo->QuotaFileNumber ||
                i == SECURITY_TABLE_NUMBER)
                continue;

            if (!frs.Initialize(i, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frs.Read()) {
                if (!ChkdskInfo->BadFiles.DoesIntersectSet(i, 1)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS, "%d", i);
                }
                continue;
            }

            need_write = FALSE;

            for (j = 0; frs.QueryAttributeByOrdinal(&root_attrib,
                                                    &ErrorInAttribute,
                                                    $INDEX_ROOT,
                                                    j); j++) {

                if (!index.Initialize(_drive, QueryClusterFactor(),
                                      Mft->GetVolumeBitmap(),
                                      Mft->GetUpcaseTable(),
                                      frs.QuerySize()/2,
                                      &frs,
                                      root_attrib.GetName())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (!ValidateEntriesInIndex2(&index, &frs, ChkdskInfo,
                                             DirectoryDigraph, &changes,
                                             Mft, SkipCycleScan,
                                             FixLevel, Message,
                                             DiskErrorsFound)) {
                    return FALSE;
                }

                if (changes) {
                    if (FixLevel != CheckOnly && !index.Save(&frs)) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W",
                                         frs.QueryFileNumber().GetLowPart(),
                                         index.GetName());
                        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                    }
                    need_write = TRUE;
                }
            }

            if (ErrorInAttribute) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (need_write) {
                *DiskErrorsFound = TRUE;
            }

            if (need_write &&
                FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {

                DebugAbort("Can't write readable FRS");
                return FALSE;
            }
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }
    Message->DisplayMsg(MSG_CHK_NTFS_INDEX_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time2);
    Message->Lock();
    Message->Set(MSG_CHK_NTFS_MESSAGE);
    timestr = ctime(&timel2);
    timestr[strlen(timestr)-1] = 0;
    Message->Display("%s%s", "After stage 2: ", timestr);
    Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(time2, time1));
    Message->Unlock();
#endif

    // Now make sure all of the reference counts are good.

    for (i = 0; i < ChkdskInfo->NumFiles; i++) {

        if (!ChkdskInfo->ReferenceCount[i]) {
            continue;
        }

        FileSystemConsistencyErrorsFound = TRUE;

// Take out this message because it can be printed a billion times.
#if 0
        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS, "%d", i);
#endif

        if (!frs.Initialize(i, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            continue;
        }

        // If the reference count is being adjusted to zero then
        // it should be added to the list of files with no reference.
        // Otherwise if the reference is being adjusted to something
        // non-zero it must be taken out of the list.

        if (frs.QueryReferenceCount() == ChkdskInfo->ReferenceCount[i]) {
            if (!ChkdskInfo->FilesWithNoReferences.Add(i)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else {
            if (!ChkdskInfo->FilesWithNoReferences.Remove(i)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        frs.SetReferenceCount(frs.QueryReferenceCount() -
                              ChkdskInfo->ReferenceCount[i]);

        if (FixLevel != CheckOnly && !frs.Write()) {
            DebugAbort("can't write readable frs");
            return FALSE;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    if (FileSystemConsistencyErrorsFound) {
        if (ChkdskInfo->Verbose) {
            Message->DisplayMsg((FixLevel == CheckOnly) ?
                                MSG_NTFS_CHKDSK_ERRORS_DETECTED :
                                MSG_NTFS_CHKDSK_ERRORS_FIXED);
        } else {
            Message->LogMsg((FixLevel == CheckOnly) ?
                            MSG_NTFS_CHKDSK_ERRORS_DETECTED :
                            MSG_NTFS_CHKDSK_ERRORS_FIXED);
        }

        if (CHKDSK_EXIT_SUCCESS == ChkdskInfo->ExitStatus) {
            ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::VerifyAndFixIndex(
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PNTFS_ATTRIBUTE             RootIndex,
    IN OUT  PNTFS_ATTRIBUTE             IndexAllocation     OPTIONAL,
    OUT     PNTFS_BITMAP                AllocationBitmap    OPTIONAL,
    IN      VCN                         FileNumber,
    IN OUT  PNUMBER_SET                 BadClusters,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
       OUT  PBOOLEAN                    Tube,
       OUT  PLONG                       Order,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine verifies and fixes an index over an attribute.

    As it does this, it builds up an allocation bitmap which it
    returns in

Arguments:

    ChkdskInfo          - Supplies the chkdsk information
    RootIndex           - Supplies the root index attribute.
    IndexAllocation     - Supplies the index allocation attribute.
    AllocationBitmap    - Returns the allocation bitmap.
    FileNumber          - Supplies the frs number
    BadClusters         - Supplies the bad clusters list.
    Mft                 - Supplies a valid MFT.
    AttributeDefTable   - Supplies the attribute definition table.
    Tube                - Returns whether or not the index must be tubed.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have been
                            found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG               root_length;
    ULONG               num_bytes;
    PINDEX_ROOT         index_root;
    ULONG               attr_def_index;
    ULONG               flags;
    ULONG               bytes_per_buffer;
    ULONG               cluster_size;
    ULONG               clusters_per_index_buffer;
    PINDEX_HEADER       index_header;
    ULONG               index_block_length;
    BOOLEAN             changes;
    BOOLEAN             need_write = FALSE;
    DSTRING             index_name;
    INDEX_ENTRY_TYPE    index_entry_type;
    BOOLEAN             attribute_recovered = FALSE;
    PINDEX_ENTRY        first_leaf_index_entry;
    PINDEX_ENTRY        last_leaf_index_entry;


    *Tube = FALSE;

    root_length = RootIndex->QueryValueLength().GetLowPart();

    if (root_length < sizeof(INDEX_ROOT)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_LENGTH_TOO_SMALL,
                     "%W%x%x%I64x",
                     RootIndex->GetName(),
                     root_length,
                     sizeof(INDEX_ROOT),
                     FileNumber.GetLargeInteger());

        *Tube = TRUE;
        return TRUE;
    }

    if (!(index_root = (PINDEX_ROOT) MALLOC(root_length))) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!RootIndex->Read(index_root, 0, root_length, &num_bytes) ||
        num_bytes != root_length) {

        DebugAbort("Unreadable resident attribute");
        FREE(index_root);
        return FALSE;
    }


    if (index_root->IndexedAttributeType == $FILE_NAME) {

        // This index should be tubed if it indexes $FILE_NAME
        // but the index name is not $I30.

        if (!index_name.Initialize(FileNameIndexNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_NAME,
                         "%W%W%I64x",
                         RootIndex->GetName(),
                         &index_name,
                         FileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: index over file name is not $I30.\n"));
            FREE(index_root);
            *Tube = TRUE;
            return TRUE;
        }

        if (index_root->CollationRule != COLLATION_FILE_NAME) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                         "%W%I64x%x%x",
                         &index_name,
                         FileNumber.GetLargeInteger(),
                         index_root->CollationRule,
                         COLLATION_FILE_NAME
                         );

            index_root->CollationRule = COLLATION_FILE_NAME;
            Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                             "%W%d", &index_name, FileNumber.GetLowPart());
            need_write = TRUE;
        }

        index_entry_type = INDEX_ENTRY_WITH_FILE_NAME_TYPE;

    } else if (FileNumber == ChkdskInfo->ObjectIdFileNumber) {

        // This index should be tubed if it an object id
        // index but the index name is not ObjectIdIndexNameData

        if (!index_name.Initialize(ObjectIdIndexNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_NAME,
                         "%W%W%I64x",
                         RootIndex->GetName(),
                         &index_name,
                         FileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: index over object id is not %s.\n",
                        ObjectIdIndexNameData));
            FREE(index_root);
            *Tube = TRUE;
            return TRUE;
        }

        if (index_root->CollationRule != COLLATION_ULONGS) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                         "%W%I64x%x%x",
                         &index_name,
                         FileNumber.GetLargeInteger(),
                         index_root->CollationRule,
                         COLLATION_ULONGS
                         );

            index_root->CollationRule = COLLATION_ULONGS;
            Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                             "%W%d", &index_name, FileNumber.GetLowPart());
            need_write = TRUE;
        }

        if (index_root->IndexedAttributeType != 0) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ATTR_TYPE,
                         "%W%x%x%I64x",
                         &index_name,
                         index_root->IndexedAttributeType,
                         0,
                         FileNumber.GetLargeInteger());

            index_root->IndexedAttributeType = 0;
            DebugPrintTrace(("UNTFS: Fixing indexed attribute type for object id index\n"));
            need_write = TRUE;
        }

        index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_16;

    } else if (FileNumber == ChkdskInfo->QuotaFileNumber) {

        // This index should be tubed if it an quota index
        // but the index name is not Sid2UseridQuotaNameData
        // or Userid2SidQuotaNameData

        // Furthermore, if the index name is Sid2UseridQuotaNameData,
        // the collation rule value should be COLLATION_SID.  If
        // the index name is Userid2SidQuotaNameData, the collation
        // rule value should be COLLATION_ULONG.

        if (!index_name.Initialize(Sid2UseridQuotaNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name) == 0) {
            if (index_root->CollationRule != COLLATION_SID) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                             "%W%I64x%x%x",
                             &index_name,
                             FileNumber.GetLargeInteger(),
                             index_root->CollationRule,
                             COLLATION_SID
                             );

                index_root->CollationRule = COLLATION_SID;
                Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                                 "%W%d", &index_name, FileNumber.GetLowPart());
                need_write = TRUE;
            }
            index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE;
        } else {
            if (!index_name.Initialize(Userid2SidQuotaNameData)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (RootIndex->GetName()->Strcmp(&index_name) == 0) {
                if (index_root->CollationRule != COLLATION_ULONG) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                                 "%W%I64x%x%x",
                                 &index_name,
                                 FileNumber.GetLargeInteger(),
                                 index_root->CollationRule,
                                 COLLATION_ULONG
                                 );

                    index_root->CollationRule = COLLATION_ULONG;
                    Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                                     "%W%d", &index_name, FileNumber.GetLowPart());
                    need_write = TRUE;
                }
                index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_4;
            } else {
                Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_INDEX_NAME_FOR_QUOTA_FILE,
                             "%W%I64x",
                             RootIndex->GetName(),
                             FileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: index over quota is not %s or %s.\n",
                            Sid2UseridQuotaNameData,
                            Userid2SidQuotaNameData));
                FREE(index_root);
                *Tube = TRUE;
                return TRUE;
            }
        }

        if (index_root->IndexedAttributeType != 0) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ATTR_TYPE,
                         "%W%x%x%I64x",
                         &index_name,
                         index_root->IndexedAttributeType,
                         0,
                         FileNumber.GetLargeInteger());

            index_root->IndexedAttributeType = 0;
            DebugPrintTrace(("UNTFS: Fixing indexed attribute type for quota file index\n"));
            need_write = TRUE;
        }

    } else if (FileNumber == SECURITY_TABLE_NUMBER) {

        // This index should be tubed if it an security index
        // but the index name is not SecurityIdIndexNameData
        // or SecurityDescriptorHashIndexNameData.

        // Furthermore, if the index name is SecurityIdIndexNameData,
        // the collation rule value should be COLLATION_ULONG.  If
        // the index name is SecurityDescriptorHashIndexNameData,
        // the collation rule value should be COLLATION_SECURITY_HASH.

        if (!index_name.Initialize(SecurityIdIndexNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name) == 0) {
            if (index_root->CollationRule != COLLATION_ULONG) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                             "%W%I64x%x%x",
                             &index_name,
                             FileNumber.GetLargeInteger(),
                             index_root->CollationRule,
                             COLLATION_ULONG
                             );

                index_root->CollationRule = COLLATION_ULONG;
                Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                                 "%W%d", &index_name, FileNumber.GetLowPart());
                need_write = TRUE;
            }
            index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_4;
        } else {
            if (!index_name.Initialize(SecurityDescriptorHashIndexNameData)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (RootIndex->GetName()->Strcmp(&index_name) == 0) {
                if (index_root->CollationRule != COLLATION_SECURITY_HASH) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                                 "%W%I64x%x%x",
                                 &index_name,
                                 FileNumber.GetLargeInteger(),
                                 index_root->CollationRule,
                                 COLLATION_SECURITY_HASH
                                 );

                    index_root->CollationRule = COLLATION_SECURITY_HASH;
                    Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                                     "%W%d", &index_name, FileNumber.GetLowPart());
                    need_write = TRUE;
                }
                index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_8;
            } else {
                Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_INDEX_NAME_FOR_SECURITY_FILE,
                             "%W%I64x",
                             RootIndex->GetName(),
                             FileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: index over security is not %s or %s.\n",
                            SecurityIdIndexNameData,
                            SecurityDescriptorHashIndexNameData));
                FREE(index_root);
                *Tube = TRUE;
                return TRUE;
            }
        }

        if (index_root->IndexedAttributeType != 0) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ATTR_TYPE,
                         "%W%x%x%I64x",
                         &index_name,
                         index_root->IndexedAttributeType,
                         0,
                         FileNumber.GetLargeInteger());

            index_root->IndexedAttributeType = 0;
            DebugPrintTrace(("UNTFS: Fixing indexed attribute type for security file index\n"));
            need_write = TRUE;
        }

    } else if (FileNumber == ChkdskInfo->ReparseFileNumber) {

        // This index should be tubed if it a reparse point
        // index but the index name is not ReparseIndexNameData

        if (!index_name.Initialize(ReparseIndexNameData)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (RootIndex->GetName()->Strcmp(&index_name)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_NAME,
                         "%W%W%I64x",
                         RootIndex->GetName(),
                         &index_name,
                         FileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: index over reparse point is not %s.\n",
                             ReparseIndexNameData));
            FREE(index_root);
            *Tube = TRUE;
            return TRUE;
        }

        if (index_root->CollationRule != COLLATION_ULONGS) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_COLLATION_RULE,
                         "%W%I64x%x%x",
                         &index_name,
                         FileNumber.GetLargeInteger(),
                         index_root->CollationRule,
                         COLLATION_ULONGS
                         );

            index_root->CollationRule = COLLATION_ULONGS;
            Message->DisplayMsg(MSG_CHK_NTFS_FIXING_COLLATION_RULE,
                             "%W%d", &index_name, FileNumber.GetLowPart());
            need_write = TRUE;
        }

        if (index_root->IndexedAttributeType != 0) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ATTR_TYPE,
                         "%W%x%x%I64x",
                         &index_name,
                         index_root->IndexedAttributeType,
                         0,
                         FileNumber.GetLargeInteger());

            index_root->IndexedAttributeType = 0;
            DebugPrintTrace(("UNTFS: Fixing indexed attribute type for reparse point index\n"));
            need_write = TRUE;
        }

        index_entry_type = INDEX_ENTRY_WITH_DATA_TYPE_12;

    } else
        index_entry_type = INDEX_ENTRY_GENERIC_TYPE;

    if (FileNumber != ChkdskInfo->QuotaFileNumber &&
        FileNumber != ChkdskInfo->ObjectIdFileNumber &&
        FileNumber != ChkdskInfo->ReparseFileNumber &&
        FileNumber != SECURITY_TABLE_NUMBER) {

        // Make sure that the attribute that we're indexing over is
        // an indexable attribute.

        if (!AttributeDefTable->QueryIndex(
                index_root->IndexedAttributeType,
                &attr_def_index)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_INDEX_ATTR_TYPE,
                         "%W%x%I64x",
                         RootIndex->GetName(),
                         index_root->IndexedAttributeType,
                         FileNumber.GetLargeInteger());

            *Tube = TRUE;
            FREE(index_root);
            return TRUE;
        }

        flags = AttributeDefTable->QueryFlags(attr_def_index);

        if (!(flags & ATTRIBUTE_DEF_MUST_BE_INDEXED) &&
            !(flags & ATTRIBUTE_DEF_INDEXABLE)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_NON_INDEXABLE_INDEX_ATTR_TYPE,
                         "%W%x%I64x",
                         RootIndex->GetName(),
                         index_root->IndexedAttributeType,
                         FileNumber.GetLargeInteger());

            *Tube = TRUE;
            FREE(index_root);
            return TRUE;
        }
    }

    //
    // Check that the ClustersPerIndexBuffer is correct
    //

    bytes_per_buffer = index_root->BytesPerIndexBuffer;
    if (bytes_per_buffer == 0 ||
        (bytes_per_buffer & (bytes_per_buffer - 1)) ||
        bytes_per_buffer > SMALL_INDEX_BUFFER_SIZE) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_BYTES_PER_INDEX_BUFFER,
                     "%W%x%x%I64x",
                     RootIndex->GetName(),
                     bytes_per_buffer,
                     SMALL_INDEX_BUFFER_SIZE,
                     FileNumber.GetLargeInteger());

        index_root->BytesPerIndexBuffer = bytes_per_buffer = SMALL_INDEX_BUFFER_SIZE;
        need_write = TRUE;
    }
    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();
    DebugAssert(cluster_size != 0);

    if (cluster_size > bytes_per_buffer)
        clusters_per_index_buffer = bytes_per_buffer / NTFS_INDEX_BLOCK_SIZE;
    else
        clusters_per_index_buffer = bytes_per_buffer / cluster_size;

    if (index_root->ClustersPerIndexBuffer != clusters_per_index_buffer) {
        DebugAssert(clusters_per_index_buffer <= 0xFF);

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_CLUSTERS_PER_INDEX_BUFFER,
                     "%W%x%x%I64x",
                     RootIndex->GetName(),
                     index_root->ClustersPerIndexBuffer,
                     clusters_per_index_buffer,
                     FileNumber.GetLargeInteger());

        index_root->ClustersPerIndexBuffer = (UCHAR)clusters_per_index_buffer;
        need_write = TRUE;
    }

    // Check out the index allocation.  Recover it.  Make sure
    // that the size is a multiple of bytesperindexbuffer.
    //

    if (IndexAllocation) {

        BOOLEAN     error = FALSE;

        if (IndexAllocation->QueryValueLength() % bytes_per_buffer != 0) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ALLOC_VALUE_LENGTH,
                         "%W%I64x%x%I64x",
                         RootIndex->GetName(),
                         IndexAllocation->QueryValueLength().GetLargeInteger(),
                         bytes_per_buffer,
                         FileNumber.GetLargeInteger());
            error = TRUE;

        } else if (IndexAllocation->QueryAllocatedLength() % bytes_per_buffer != 0) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ALLOC_ALLOC_LENGTH,
                         "%W%I64x%x%I64x",
                         RootIndex->GetName(),
                         IndexAllocation->QueryAllocatedLength().GetLargeInteger(),
                         bytes_per_buffer,
                         FileNumber.GetLargeInteger());
            error = TRUE;
        }

        if (error) {

            Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                             "%d%W",
                             FileNumber.GetLowPart(),
                             RootIndex->GetName());
            DebugPrintTrace(("UNTFS: Index allocation has incorrect length.\n"));

            if (!IndexAllocation->Resize(
                    (IndexAllocation->QueryValueLength()/bytes_per_buffer)*
                    bytes_per_buffer,
                    Mft->GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(index_root);
                return FALSE;
            }
        }

        if (!AllocationBitmap->Initialize(
                IndexAllocation->QueryValueLength()/bytes_per_buffer,
                TRUE)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(index_root);
            return FALSE;
        }
    }

    first_leaf_index_entry = (PINDEX_ENTRY)MALLOC(bytes_per_buffer);
    last_leaf_index_entry = (PINDEX_ENTRY)MALLOC(bytes_per_buffer);

    if (first_leaf_index_entry == NULL ||
        last_leaf_index_entry == NULL) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        FREE(first_leaf_index_entry);
        FREE(last_leaf_index_entry);
        FREE(index_root);
        return FALSE;
    }

    index_header = &(index_root->IndexHeader);
    index_block_length = (ULONG)(((PCHAR) index_root + root_length) -
                                 ((PCHAR) index_header));

    if (!TraverseIndexTree(index_header, index_block_length,
                           IndexAllocation, AllocationBitmap,
                           bytes_per_buffer, Tube, &changes,
                           FileNumber, RootIndex->GetName(), index_entry_type,
                           &attribute_recovered, Mft, BadClusters,
                           first_leaf_index_entry, last_leaf_index_entry, Order,
                           index_root->CollationRule,
                           FixLevel, Message, DiskErrorsFound)) {
        FREE(first_leaf_index_entry);
        FREE(last_leaf_index_entry);
        FREE(index_root);
        return FALSE;
    }

    FREE(first_leaf_index_entry);
    FREE(last_leaf_index_entry);

    if (*Tube) {
        FREE(index_root);
        return TRUE;
    }

    if (changes || need_write) {

        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                         "%d%W",
                         FileNumber.GetLowPart(),
                         RootIndex->GetName());

        if (!RootIndex->Write(index_root, 0, root_length, &num_bytes, NULL) ||
            num_bytes != root_length) {

            DebugAbort("Unwriteable resident attribute");
            FREE(index_root);
            return FALSE;
        }
    }


    if (index_header->FirstFreeByte != index_header->BytesAvailable) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_ROOT_INDEX_HEADER,
                     "%W%x%x%I64x",
                     RootIndex->GetName(),
                     index_header->FirstFreeByte,
                     index_header->BytesAvailable,
                     FileNumber.GetLargeInteger());

        DebugPrintTrace(("UNTFS: Index root has FirstFreeByte != BytesAvailable\n"));

        index_header->BytesAvailable = index_header->FirstFreeByte;

        if (!RootIndex->Write(index_root, 0, root_length, &num_bytes, NULL) ||
            num_bytes != root_length) {

            DebugAbort("Unwriteable resident attribute");
            FREE(index_root);
            return FALSE;
        }

        if (!RootIndex->Resize(index_header->BytesAvailable +
                               sizeof(INDEX_ROOT) - sizeof(INDEX_HEADER),
                               Mft->GetVolumeBitmap()) ) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(index_root);
            return FALSE;
        }
    }


    FREE(index_root);

    return TRUE;
}


BOOLEAN
NTFS_SA::TraverseIndexTree(
    IN OUT  PINDEX_HEADER       IndexHeader,
    IN      ULONG               IndexLength,
    IN OUT  PNTFS_ATTRIBUTE     IndexAllocation     OPTIONAL,
    IN OUT  PNTFS_BITMAP        AllocationBitmap    OPTIONAL,
    IN      ULONG               BytesPerBlock,
    OUT     PBOOLEAN            Tube,
    OUT     PBOOLEAN            Changes,
    IN      VCN                 FileNumber,
    IN      PCWSTRING           AttributeName,
    IN      INDEX_ENTRY_TYPE    IndexEntryType,
    IN OUT  PBOOLEAN            AttributeRecovered,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      PNUMBER_SET         BadClusters,
       OUT  PINDEX_ENTRY        FirstLeafIndexEntry,
       OUT  PINDEX_ENTRY        LastLeafIndexEntry,
    IN OUT  PLONG               Order,
    IN      ULONG               CollationRule,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message,
    IN OUT  PBOOLEAN            DiskErrorsFound
    )
/*++

Routine Description:

    This routine traverses an index tree and verifies the entries while
    traversing.

Arguments:

    IndexHeader         - Supplies a pointer to the beginning of this index
                            block.
    IndexLength         - Supplies the length of this index block.
    IndexAllocation     - Supplies the index allocation attribute.
    AllocationBitmap    - Supplies the current in memory bitmap of used
                            index blocks.
    BytesPerBuffer      - Supplies the size of an index block within the
                            index allocation attribute.
    Tube                - Returns whether or not the whole index block
                            is invalid.
    Changes             - Returns whether or not changes were made to
                            the index block.
    FileNumber          - Supplies the frs number of the index to check.
    AttributeName       - Supplies the name of the index
    IndexEntryType      - Supplies the type of the index entry
    RecoveredAttribute  - Supplies whether or not RecoverAttribute has been called.
    Mft                 - Supplies a valid MFT.
    BadClusters         - Supplies the bad cluster list.
    FirstLeafIndexEntry - Returns the first leaf index entry below the current block
    LastLeafIndexEntry  - Returns the last leaf index entry below the current block
    Order               - Returns the sort order (-1, 0, 1) below the current block.
    CollationRule       - Supplies the rule used for collation.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PINDEX_ENTRY                p, pnext;
    PCHAR                       pend;
    ULONG                       first_free_byte;
    VCN                         down_pointer;
    ULONG                       clusters_per_block, cluster_size;
    PINDEX_ALLOCATION_BUFFER    down_block;
    PINDEX_HEADER               down_header;
    BOOLEAN                     tube, changes;
    ULONG                       num_bytes;
    UCHAR                       usa_check;
    BOOLEAN                     error;
    PINDEX_ENTRY                first_index_entry;
    PINDEX_ENTRY                last_index_entry;
    PINDEX_ENTRY                prev_index_entry = NULL;
    LONG                        order;


    *Tube = FALSE;
    *Changes = FALSE;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();
    clusters_per_block = (BytesPerBlock < cluster_size ?
                             BytesPerBlock / NTFS_INDEX_BLOCK_SIZE :
                             BytesPerBlock / cluster_size);

    // pend points past the end of the block.

    pend = (PCHAR) IndexHeader + IndexLength;


    // First make sure that the first entry is valid.

    if (sizeof(INDEX_HEADER) > IndexLength) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_LENGTH_TOO_SMALL,
                     "%W%x%x%I64x",
                     AttributeName,
                     IndexLength,
                     sizeof(INDEX_HEADER),
                     FileNumber.GetLargeInteger());

        *Tube = TRUE;
        return TRUE;
    }

    if (IndexHeader->FirstIndexEntry < sizeof(INDEX_HEADER)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_UNKNOWN_VCN_INDEX_ENTRY_OFFSET,
                     "%W%x%I64x",
                     AttributeName,
                     IndexHeader->FirstIndexEntry,
                     FileNumber.GetLargeInteger());

        *Tube = TRUE;
        return TRUE;
    }

    p = (PINDEX_ENTRY) ((PCHAR) IndexHeader + IndexHeader->FirstIndexEntry);

    if (pend < (PCHAR)p ||
        NTFS_INDEX_TREE::IsIndexEntryCorrupt(p,
                                             (ULONG)(pend - (PCHAR) p),
                                             Message,
                                             IndexEntryType)) {
        if (pend < (PCHAR)p) {
            Message->LogMsg(MSG_CHKLOG_NTFS_FIRST_INDEX_ENTRY_OFFSET_BEYOND_INDEX_LENGTH,
                         "%W%x%x%I64x",
                         AttributeName,
                         IndexHeader->FirstIndexEntry,
                         IndexLength,
                         FileNumber.GetLargeInteger());
        }

        *Tube = TRUE;
        return TRUE;
    }


    // Now make sure that the bytes available count is correct.

    if (IndexHeader->BytesAvailable != IndexLength) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_HEADER_BYTES_AVAILABLE,
                     "%W%x%x%I64x",
                     AttributeName,
                     IndexHeader->BytesAvailable,
                     IndexLength,
                     FileNumber.GetLargeInteger());

        *Changes = TRUE;
        IndexHeader->BytesAvailable = IndexLength;
        DebugPrintTrace(("UNTFS: Incorrect bytes available.\n"));
    }

    first_index_entry = (PINDEX_ENTRY)MALLOC(BytesPerBlock);
    last_index_entry = (PINDEX_ENTRY)MALLOC(BytesPerBlock);

    if (first_index_entry == NULL ||
        last_index_entry == NULL) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        FREE(first_index_entry);
        FREE(last_index_entry);
        return FALSE;
    }

    // Validate all of the entries in the tree.

    for (;;) {

        // If this has a VCN down pointer then recurse down the tree.

        if (p->Flags & INDEX_ENTRY_NODE) {

            down_pointer = GetDownpointer(p)/clusters_per_block;

            // Make sure that the index header is marked as a node.
            if (!(IndexHeader->Flags & INDEX_NODE)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_HEADER_NOT_MARKED_AS_INDEX_NODE,
                             "%W%I64x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             FileNumber.GetLargeInteger());

                *Changes = TRUE;
                IndexHeader->Flags |= INDEX_NODE;
            }


            if (!(down_block = (PINDEX_ALLOCATION_BUFFER)
                                MALLOC(BytesPerBlock))) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(first_index_entry);
                FREE(last_index_entry);
                return FALSE;
            }

            error = FALSE;

            if (GetDownpointer(p) % clusters_per_block != 0) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_DOWN_POINTER,
                             "%W%I64x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!AllocationBitmap) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_ALLOC_BITMAP,
                             "%W%I64x",
                             AttributeName,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!AllocationBitmap->IsFree(down_pointer, 1)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_DOWN_POINTER_ALREADY_IN_USE,
                             "%W%I64x%I64x",
                             AttributeName,
                             down_pointer.GetLargeInteger(),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!IndexAllocation) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_INDEX_ALLOC,
                             "%W%I64x",
                             AttributeName,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!IndexAllocation->Read(down_block,
                                              down_pointer*BytesPerBlock,
                                              BytesPerBlock,
                                              &num_bytes) &&
                       (*AttributeRecovered ||
                        ((*AttributeRecovered = TRUE) &&
                         !IndexAllocation->RecoverAttribute(Mft->GetVolumeBitmap(),
                                                            BadClusters)))) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_INDEX_BUFFER,
                             "%W%I64x%I64x",
                             AttributeName,
                             down_pointer.GetLargeInteger(),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (num_bytes != BytesPerBlock) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_INDEX_BUFFER,
                             "%W%I64x%I64x",
                             AttributeName,
                             down_pointer.GetLargeInteger(),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!(usa_check =
                           NTFS_SA::PostReadMultiSectorFixup(
                               down_block,
                               num_bytes,
                               IndexAllocation->GetDrive(),
                               down_block->IndexHeader.FirstFreeByte))) {

                error = TRUE;
            } else if (down_block->MultiSectorHeader.Signature[0] != 'I' ||
                       down_block->MultiSectorHeader.Signature[1] != 'N' ||
                       down_block->MultiSectorHeader.Signature[2] != 'D' ||
                       down_block->MultiSectorHeader.Signature[3] != 'X') {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_INDEX_BUFFER_MULTI_SECTOR_HEADER_SIGNATURE);
                Message->Log("%W%I64x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             FileNumber.GetLargeInteger());
                Message->DumpDataToLog(down_block, sizeof(MULTI_SECTOR_HEADER));
                Message->Unlock();

                error = TRUE;
            } else if (down_block->MultiSectorHeader.UpdateSequenceArrayOffset <
                       FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, UpdateSequenceArray)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_BUFFER_USA_OFFSET_BELOW_MINIMUM,
                             "%W%I64x%x%x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             down_block->MultiSectorHeader.UpdateSequenceArrayOffset,
                             FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, UpdateSequenceArray),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (down_block->ThisVcn != GetDownpointer(p)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_DOWN_BLOCK,
                             "%W%I64x%I64x%I64x",
                             AttributeName,
                             GetDownpointer(p),
                             down_block->ThisVcn.GetLargeInteger(),
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (num_bytes%SEQUENCE_NUMBER_STRIDE != 0) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ALLOC_SIZE,
                             "%W%I64x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             num_bytes,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (down_block->MultiSectorHeader.UpdateSequenceArrayOffset%
                       sizeof(UPDATE_SEQUENCE_NUMBER) != 0) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_BUFFER_USA_OFFSET,
                             "%W%I64x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             down_block->MultiSectorHeader.UpdateSequenceArrayOffset,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (down_block->MultiSectorHeader.UpdateSequenceArraySize !=
                       num_bytes/SEQUENCE_NUMBER_STRIDE + 1) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_BUFFER_USA_SIZE,
                             "%W%I64x%x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             down_block->MultiSectorHeader.UpdateSequenceArraySize,
                             num_bytes/SEQUENCE_NUMBER_STRIDE + 1,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (down_block->MultiSectorHeader.UpdateSequenceArrayOffset +
                       down_block->MultiSectorHeader.UpdateSequenceArraySize*
                       sizeof(UPDATE_SEQUENCE_NUMBER) >
                       down_block->IndexHeader.FirstIndexEntry +
                       FIELD_OFFSET(INDEX_ALLOCATION_BUFFER, IndexHeader)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_OFFSET,
                             "%W%I64x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             down_block->IndexHeader.FirstIndexEntry,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else if (!IsQuadAligned(down_block->IndexHeader.FirstIndexEntry)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_OFFSET,
                             "%W%I64x%x%I64x",
                             AttributeName,
                             down_block->ThisVcn.GetLargeInteger(),
                             down_block->IndexHeader.FirstIndexEntry,
                             FileNumber.GetLargeInteger());

                error = TRUE;
            } else {

                // Compare this block's LSN against the largest so far.

                if (down_block->Lsn > LargestLsnEncountered) {
                    LargestLsnEncountered = down_block->Lsn;
                }


                AllocationBitmap->SetAllocated(down_pointer, 1);

                down_header = &(down_block->IndexHeader);

                if (!TraverseIndexTree(down_header,
                                       BytesPerBlock -
                                            (ULONG)((PCHAR) down_header -
                                             (PCHAR) down_block),
                                       IndexAllocation, AllocationBitmap,
                                       BytesPerBlock, &tube, &changes,
                                       FileNumber, AttributeName, IndexEntryType,
                                       AttributeRecovered, Mft, BadClusters,
                                       first_index_entry, last_index_entry,
                                       Order, CollationRule,
                                       FixLevel, Message, DiskErrorsFound)) {

                    FREE(first_index_entry);
                    FREE(last_index_entry);
                    FREE(down_block);
                    return FALSE;
                }

                if (tube || changes ||
                    usa_check == UpdateSequenceArrayCheckValueMinorError) {

                    if (tube || changes) {
                        Message->DisplayMsg(MSG_CHK_NTFS_ERROR_IN_INDEX,
                                         "%d%W",
                                         FileNumber.GetLowPart(),
                                         AttributeName);
                        *DiskErrorsFound = TRUE;
                    } else {
                        DebugPrintTrace(("UNTFS: Quietly fix up check value in VCN %d of\n"
                                         "indexed frs %d\n",
                                         down_pointer.GetLowPart(),
                                         FileNumber.GetLowPart()));
                    }

                    if (tube) {
                        *Order = 1; // must go thru sort
                        *Changes = TRUE;
                        AllocationBitmap->SetFree(down_pointer, 1);
                        GetDownpointer(p) = INVALID_VCN;
                        DebugPrintTrace(("UNTFS: 1 Index down pointer being set to invalid.\n"));
                    }

                    NTFS_SA::PreWriteMultiSectorFixup(down_block,
                                                      BytesPerBlock);


                    if (FixLevel != CheckOnly &&
                        !IndexAllocation->Write(down_block,
                                                down_pointer*BytesPerBlock,
                                                BytesPerBlock,
                                                &num_bytes,
                                                NULL)) {

                        DebugAbort("Can't write what was read");
                        FREE(first_index_entry);
                        FREE(last_index_entry);
                        FREE(down_block);
                        return FALSE;
                    }

                    NTFS_SA::PostReadMultiSectorFixup(down_block,
                                                      BytesPerBlock,
                                                      NULL);
                }
            }

            if (error) {

                PINDEX_ALLOCATION_BUFFER pBuffer;

                pBuffer = CONTAINING_RECORD( IndexHeader, INDEX_ALLOCATION_BUFFER, IndexHeader );

                *Changes = TRUE;

                DebugPrintTrace(("UNTFS: 2 Index down pointer (0x%I64x) in Block 0x%I64x being set to invalid.\n",
                                 GetDownpointer(p), pBuffer->ThisVcn));
                GetDownpointer(p) = INVALID_VCN;

                *Order = 1;     // must go thru sort
            }

            FREE(down_block);

            if (prev_index_entry) {
                if (*Order <= 0) {
                    order = CompareNtfsIndexEntries(prev_index_entry,
                                                    (GetDownpointer(p) == INVALID_VCN) ? p : first_index_entry,
                                                    CollationRule,
                                                    Mft->GetUpcaseTable());
                    if (order >= 0)
                        *Order = order;
                }
            } else {
                if (GetDownpointer(p) == INVALID_VCN) {
                    memcpy(FirstLeafIndexEntry, p, p->Length);
                } else {
                    memcpy(FirstLeafIndexEntry, first_index_entry, first_index_entry->Length);
                }
            }

            if (p->Flags & INDEX_ENTRY_END) {
                if (GetDownpointer(p) == INVALID_VCN) {
                    memcpy(LastLeafIndexEntry, p, p->Length);
                } else {
                    memcpy(LastLeafIndexEntry, last_index_entry, last_index_entry->Length);
                }
            } else if (*Order <= 0) {
                if (GetDownpointer(p) != INVALID_VCN) {
                    order = CompareNtfsIndexEntries(last_index_entry,
                                                    p,
                                                    CollationRule,
                                                    Mft->GetUpcaseTable());
                    if (order >= 0)
                        *Order = order;
                }
            }

        } else {

            // Make sure that the index header has this marked as a leaf.  If the block
            // is not consistent then the Sort routine for indices will detect that they're
            // unsorted.

            if (IndexHeader->Flags & INDEX_NODE) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_HEADER_MARKED_AS_INDEX_NODE,
                             "%W%I64x",
                             AttributeName,
                             FileNumber.GetLargeInteger());

                *Changes = TRUE;
                IndexHeader->Flags &= ~INDEX_NODE;
            }

            if (prev_index_entry == NULL) {
                //
                // this should be the first leaf entry if there is
                // no previous entries and this is a leaf node.
                //
                memcpy(FirstLeafIndexEntry, p, p->Length);
            } else if (p->Flags & INDEX_ENTRY_END) {
                //
                // this should be the last leaf entry if it has the end flag
                //
                memcpy(LastLeafIndexEntry, prev_index_entry, prev_index_entry->Length);
            } else if (*Order <= 0) {
                order = CompareNtfsIndexEntries(prev_index_entry,
                                                p,
                                                CollationRule,
                                                Mft->GetUpcaseTable());
                if (order >= 0)
                    *Order = order;
            }
        }

        if (p->Flags & INDEX_ENTRY_END) {
            break;
        }

        // Make sure the next entry is not corrupt.  If it is then
        // truncate this one.  If we truncate a node, we have to
        // keep its downpointer.

        pnext = (PINDEX_ENTRY) ((PCHAR) p + p->Length);

        if (pend < (PCHAR) pnext ||
            NTFS_INDEX_TREE::IsIndexEntryCorrupt(pnext,
                                                 (ULONG)(pend - (PCHAR) pnext),
                                                 Message,
                                                 IndexEntryType)) {

            if (pend < (PCHAR)pnext) {
                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_LENGTH_BEYOND_INDEX_LENGTH,
                             "%W%x%x%I64x",
                             AttributeName,
                             p->Length,
                             pend-(PCHAR)p,
                             FileNumber.GetLargeInteger());
            }

            *Changes = TRUE;
            DebugPrintTrace(("UNTFS: Index entry is corrupt.\n"));
            if( p->Flags & INDEX_ENTRY_NODE ) {
                down_pointer = GetDownpointer(p);
            }

            memset(&(p->FileReference), 0, sizeof(FILE_REFERENCE));
            p->Length = NtfsIndexLeafEndEntrySize +
                        ((p->Flags & INDEX_ENTRY_NODE) ? sizeof(VCN) : 0);
            p->AttributeLength = 0;
            p->Flags |= INDEX_ENTRY_END;
            if( p->Flags & INDEX_ENTRY_NODE ) {
                GetDownpointer(p) = down_pointer;

                if (prev_index_entry == NULL) {
                    *Order = 1; // must go thru sort
                } else {
                    memcpy(LastLeafIndexEntry, last_index_entry, last_index_entry->Length);
                }

            } else {
                if (prev_index_entry == NULL) {
                    *Order = 1; // must go thru sort
                } else {
                    memcpy(LastLeafIndexEntry, prev_index_entry, prev_index_entry->Length);
                }
            }
            break;
        }

        prev_index_entry = p;
        p = pnext;
    }


    FREE(first_index_entry);
    FREE(last_index_entry);

    // Verify the first free byte.

    first_free_byte = (ULONG)((PCHAR) p - (PCHAR) IndexHeader) + p->Length;

    if (IndexHeader->FirstFreeByte != first_free_byte) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_HEADER_FIRST_FREE_BYTE,
                     "%W%x%x%I64x",
                     AttributeName,
                     IndexHeader->FirstFreeByte,
                     first_free_byte,
                     FileNumber.GetLargeInteger());

        DebugPrintTrace(("UNTFS: Index entry has invalid first free byte.\n"));
        *Changes = TRUE;
        IndexHeader->FirstFreeByte = first_free_byte;
    }

    return TRUE;
}


BOOLEAN
QueryFileNameFromIndex(
   IN PCFILE_NAME IndexValue,
   IN ULONG    ValueLength,
   OUT   PWSTRING FileName
   )
/*++

Routine Description:

   This routine returns a file name string for a given file name
   structure.

Arguments:

   IndexValue  - Supplies the file name structure.
   ValueLength - Supplies the number of bytes in the file name structure.
   FileName - Returns the file name string.

Return Value:

   FALSE - There is a corruption in the file name structure.
   TRUE  - Success.

--*/
{
    WSTR    string[256];
    UCHAR   i, len;

    if (sizeof(FILE_NAME) > ValueLength) {
        return FALSE;
    }

    len = IndexValue->FileNameLength;

    if (NtfsFileNameGetLength(IndexValue) > ValueLength) {
        return FALSE;
    }

    for (i = 0; i < len; i++) {
        string[i] = IndexValue->FileName[i];
    }
    string[i] = 0;

    return FileName->Initialize(string);
}

BOOLEAN
NTFS_SA::ValidateEntriesInIndex(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN      PNTFS_MFT_INFO              MftInfo,
    IN OUT  PDIGRAPH                    DirectoryDigraph,
    IN OUT  PULONG                      PercentDone,
    IN OUT  PBIG_INT                    NumFileNames,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      BOOLEAN                     SkipCycleScan,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given index
    and makes sure that they point to an appropriate attribute.  This
    verification will not be made if the index has index name "$I30".

    In either case the 'ChkdskInfo's ReferenceCount fields will be
    updated.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    MftInfo             - Supplies the current mft info.
    DirectoryDigraph    - Supplies the current directory digraph.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    SkipEntriesScan     - Supplies if index entries checking should be skipped.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    BOOLEAN                     file_name_index;
    DSTRING                     file_name_index_name;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    BOOLEAN                     invalid_entry_name;
    DSTRING                     entry_name;
    PFILE_NAME                  file_name;
    DUPLICATED_INFORMATION      actual_dupinfo;
    BOOLEAN                     dupinfo_match;
    PDUPLICATED_INFORMATION     p, q;
    BOOLEAN                     file_has_too_many_file_names;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    ULONG                       new_percent;
    PNTFS_FRS_INFO              pfrsInfo;
    USHORT                      index_into_file_name;
    UCHAR                       file_name_flags;

    *Changes = FALSE;

    if (!file_name_index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_name_index = !Index->GetName()->Strcmp(&file_name_index_name) &&
                      Index->QueryTypeCode() == $FILE_NAME;

    Index->ResetIterator();

    while (index_entry = Index->GetNext(&depth, &error)) {

        new_percent = ((*NumFileNames*100) / ChkdskInfo->TotalNumFileNames).GetLowPart();
        if (new_percent != *PercentDone) {
            *PercentDone = new_percent;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", *PercentDone)) {
                return FALSE;
            }
        }

        file_number.Set(index_entry->FileReference.LowPart,
                        (LONG) index_entry->FileReference.HighPart);

        need_delete = FALSE;

        if (file_number >= ChkdskInfo->NumFiles) {
            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_BEYOND_MFT,
                             "%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_BEYOND_MFT);
                Message->Log("%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog((PVOID)index_entry,
                                       max(min(0x100, index_entry->Length),
                                           sizeof(INDEX_ENTRY)));
                Message->Unlock();
            }
            need_delete = TRUE;
        } else if (!MftInfo->IsInRange(file_number)) {
            continue;
        }

        file_has_too_many_file_names = ChkdskInfo->
                FilesWithTooManyFileNames.DoesIntersectSet(file_number, 1);

        file_name = (PFILE_NAME) GetIndexEntryValue(index_entry);

        if (file_name_index &&
            !QueryFileNameFromIndex(file_name,
                                    index_entry->AttributeLength,
                                    &entry_name)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_FILE_NAME_IN_INDEX_ENTRY_VALUE);
            Message->Log("%I64x%W%x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         Index->GetName(),
                         index_entry->AttributeLength,
                         file_number.GetLargeInteger());
            Message->DumpDataToLog(file_name,
                                   max(min(0x100, index_entry->AttributeLength),
                                       sizeof(FILE_NAME)));
            Message->Unlock();

            need_delete = invalid_entry_name = TRUE;
        } else
            invalid_entry_name = FALSE;

        if (!need_delete) {

            if ((pfrsInfo = (PNTFS_FRS_INFO)MftInfo->QueryIndexEntryInfo(file_number)) == NULL) {
                if (file_name_index) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_FREE_OR_NON_BASE_FRS,
                                 "%I64x%W%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 &entry_name,
                                 file_number.GetLargeInteger());
                } else {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_FREE_OR_NON_BASE_FRS);
                    Message->Log("%I64x%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 file_number.GetLargeInteger());
                    Message->DumpDataToLog((PVOID)index_entry,
                                           max(min(0x100, index_entry->Length),
                                               sizeof(INDEX_ENTRY)));
                    Message->Unlock();
                }
                need_delete = TRUE;
            }
        }

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names &&
            !(file_name->ParentDirectory ==
              IndexFrs->QuerySegmentReference())) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                         "%I64x%W%I64x%W%I64x",
                         IndexFrs->QuerySegmentReference(),
                         Index->GetName(),
                         file_name->ParentDirectory,
                         &entry_name,
                         file_number.GetLargeInteger());
            need_delete = TRUE;
        }

        if (!need_delete &&
            !(NTFS_MFT_INFO::QuerySegmentReference(pfrsInfo) == index_entry->FileReference)) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_FILE_REF,
                             "%I64x%W%W%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             index_entry->FileReference,
                             NTFS_MFT_INFO::QuerySegmentReference(pfrsInfo));
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_UNNAMED_INDEX_ENTRY_FILE_REF);
                Message->Log("%I64x%W%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             index_entry->FileReference,
                             NTFS_MFT_INFO::QuerySegmentReference(pfrsInfo));
                Message->DumpDataToLog((PVOID)index_entry,
                                       max(min(0x100, index_entry->Length),
                                           sizeof(INDEX_ENTRY)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        // do we need to see if this is a file_name_index first?
        if (!need_delete &&
            !file_has_too_many_file_names &&
            NTFS_MFT_INFO::CompareFileName(pfrsInfo,
                                           index_entry->AttributeLength,
                                           file_name,
                                           &index_into_file_name) == 0) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_INDEX_ENTRY_VALUE_FILE_NAME,
                             "%I64x%W%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             file_number.GetLargeInteger());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_UNNAMED_INDEX_ENTRY_VALUE_FILE_NAME);
                Message->Log("%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog(file_name,
                                       max(min(0x100, index_entry->AttributeLength),
                                           sizeof(FILE_NAME)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        // Make sure that the duplicated information in the index
        // entry is correct, also check the back pointers, and
        // the flags.

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names) {

            file_name_flags = NTFS_MFT_INFO::QueryFlags(pfrsInfo, index_into_file_name);

            if (!NTFS_MFT_INFO::CompareDupInfo(pfrsInfo, file_name) ||
                file_name_flags != file_name->Flags) {

                // read in frs and fix the problem

                if (file_number == IndexFrs->QueryFileNumber()) {
                    pfrs = IndexFrs;
                } else {
                    if (!frs.Initialize(file_number, Mft)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    if (!frs.Read()) {
                        Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
                        return FALSE;
                    }

                    pfrs = &frs;
                }


                if (!pfrs->QueryDuplicatedInformation(&actual_dupinfo)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                p = &file_name->Info;
                q = &actual_dupinfo;
                dupinfo_match = TRUE;

                if (memcmp(p, q, sizeof(DUPLICATED_INFORMATION)) ||
                    file_name_flags != file_name->Flags) {

                    if (file_number >= FIRST_USER_FILE_NUMBER) {

                        if (p->CreationTime != q->CreationTime) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in creation time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->CreationTime, q->CreationTime));
                        }

                        if (p->LastModificationTime != q->LastModificationTime) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in last mod time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->LastModificationTime, q->LastModificationTime));
                        }

                        if (p->LastChangeTime != q->LastChangeTime) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in last change time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->LastChangeTime, q->LastChangeTime));
                        }

                        if (p->AllocatedLength != q->AllocatedLength) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in allocation length for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->AllocatedLength.GetLargeInteger(), q->AllocatedLength.GetLargeInteger()));
                        }

                        if (p->FileSize != q->FileSize) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in file size for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                             file_number.GetLargeInteger(),
                                             p->FileSize.GetLargeInteger(), q->FileSize.GetLargeInteger()));
                        }

                        if (p->FileAttributes != q->FileAttributes) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in file attributes for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->FileAttributes, q->FileAttributes));
                        }

                        if (ChkdskInfo->major >= 2 &&
                            q->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                            if (p->ReparsePointTag != q->ReparsePointTag) {
                                dupinfo_match = FALSE;
                                DebugPrintTrace(("UNTFS: Minor inconsistency in reparse point for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                                 file_number.GetLargeInteger(),
                                                 p->ReparsePointTag, q->ReparsePointTag));
                            }
                        } else {
                            if (p->PackedEaSize != q->PackedEaSize) {
                                dupinfo_match = FALSE;
                                DebugPrintTrace(("UNTFS: Minor inconsistency in packed ea size for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                                 file_number.GetLargeInteger(),
                                                 p->PackedEaSize, q->PackedEaSize));
                            }
                        }

                        if (file_name->Flags != file_name_flags) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in file name flags for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             file_name->Flags, file_name_flags));
                        }
                    } else {
                        dupinfo_match = FALSE;
                    }
                }

                if (!dupinfo_match) {

                    // Don't report duplicated information on system files.

                    if (file_number >= FIRST_USER_FILE_NUMBER) {
                        FileSystemConsistencyErrorsFound = TRUE;
                        if (CHKDSK_EXIT_SUCCESS == ChkdskInfo->ExitStatus) {
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
                        }
                    }

                    if (FixLevel != CheckOnly) {
                        *Changes = TRUE;
                    }


                    memcpy(&file_name->Info, &actual_dupinfo, sizeof(DUPLICATED_INFORMATION));
                    file_name->Flags = file_name_flags;

                    if (FixLevel != CheckOnly && !Index->WriteCurrentEntry()) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
                }
            }
        }

        if (need_delete) {

            *Changes = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (file_name_index && !invalid_entry_name) {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY,
                                 "%d%W%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName(),
                                 &entry_name);
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());
            }

            *DiskErrorsFound = TRUE;

            if (FixLevel != CheckOnly &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else if (file_number < ChkdskInfo->NumFiles) {
            ChkdskInfo->ReferenceCount[file_number.GetLowPart()]--;
            if (file_name_index) {

                ChkdskInfo->NumFileNames[file_number.GetLowPart()]--;
                *NumFileNames += 1;

                if (!SkipCycleScan &&
                    !DirectoryDigraph->AddEdge(IndexFrs->QueryFileNumber().
                                               GetLowPart(),
                                               file_number.GetLowPart())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

BOOLEAN
NTFS_SA::ValidateEntriesInIndex(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PDIGRAPH                    DirectoryDigraph,
    IN OUT  PULONG                      PercentDone,
    IN OUT  PBIG_INT                    NumFileNames,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      BOOLEAN                     SkipEntriesScan,
    IN      BOOLEAN                     SkipCycleScan,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given index
    and makes sure that they point to an appropriate attribute.  This
    verification will not be made if the index has index name "$I30".

    In either case the 'ChkdskInfo's ReferenceCount fields will be
    updated.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    DirectoryDigraph    - Supplies the current directory digraph.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    SkipEntriesScan     - Supplies if index entries checking should be skipped.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_INDEX_TREE             indexMark;
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    BOOLEAN                     file_name_index;
    DSTRING                     file_name_index_name;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    BOOLEAN                     invalid_entry_name;
    DSTRING                     entry_name;
    PFILE_NAME                  file_name, frs_file_name;
    DUPLICATED_INFORMATION      actual_dupinfo;
    BOOLEAN                     dupinfo_match;
    PDUPLICATED_INFORMATION     p, q;
    BOOLEAN                     file_has_too_many_file_names;
    TLINK                       frsDataRec;
    PVOID                       pNode;
    USHORT                      frsDataRecordCount;
    BOOLEAN                     read_failure = TRUE;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    ULONG                       new_percent;

    *Changes = FALSE;

    if (!file_name_index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_name_index = !Index->GetName()->Strcmp(&file_name_index_name) &&
                      Index->QueryTypeCode() == $FILE_NAME;

    Index->ResetIterator();

  ProcessNextBlock:

    new_percent = (((*NumFileNames)*90) / ChkdskInfo->TotalNumFileNames).GetLowPart();
    if (new_percent != *PercentDone) {
        *PercentDone = new_percent;
        if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", *PercentDone)) {
            return FALSE;
        }
    }

    indexMark.CopyIterator(Index);

    if (index_entry = Index->GetNext(&depth, &error)) {

        frsDataRec.Initialize(FRS_DATA_RECORD_MAX_SIZE);

        frsDataRec.GetNextDataSlot().Set(index_entry->FileReference.LowPart,
                                (LONG) index_entry->FileReference.HighPart);

    } else {

        UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);
        return TRUE;
    }

    while (index_entry = Index->GetNext(&depth, &error)) {

        frsDataRec.GetNextDataSlot().Set(index_entry->FileReference.LowPart,
                                (LONG) index_entry->FileReference.HighPart);

        if (frsDataRec.QueryMemberCount() >= FRS_DATA_RECORD_MAX_SIZE)
            break;

    }

    frsDataRecordCount = frsDataRec.QueryMemberCount();

    if (!SkipEntriesScan) {
        frsDataRec.Sort();

        if (!frs.Initialize((VCN)0, frsDataRecordCount, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        read_failure = !frs.ReadSet(&frsDataRec);
    }

    Index->CopyIterator(&indexMark);
    pNode = frsDataRec.GetFirst();

    while (frsDataRecordCount &&
           (index_entry = Index->GetNext(&depth, &error))) {

        file_number.Set(index_entry->FileReference.LowPart,
                        (LONG) index_entry->FileReference.HighPart);

        need_delete = FALSE;
        file_has_too_many_file_names = ChkdskInfo->
                FilesWithTooManyFileNames.DoesIntersectSet(file_number, 1);

        file_name = (PFILE_NAME) GetIndexEntryValue(index_entry);

        if (file_name_index &&
            !QueryFileNameFromIndex(file_name,
                                    index_entry->AttributeLength,
                                    &entry_name)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_FILE_NAME_IN_INDEX_ENTRY_VALUE);
            Message->Log("%I64x%W%x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         Index->GetName(),
                         index_entry->AttributeLength,
                         file_number.GetLargeInteger());
            Message->DumpDataToLog(file_name,
                                   max(min(0x100, index_entry->AttributeLength),
                                       sizeof(FILE_NAME)));
            Message->Unlock();

            need_delete = invalid_entry_name = TRUE;
        } else
            invalid_entry_name = FALSE;

        if (!need_delete &&
            file_name_index &&
            SkipEntriesScan &&
            ChkdskInfo->NumFileNames[file_number.GetLowPart()] == 0) {

            // keep track of this frs number and verify it later

            ChkdskInfo->IndexEntriesToCheck.SetAllocated(file_number, 1);
            ChkdskInfo->IndexEntriesToCheckIsSet = TRUE;
            frsDataRecordCount--;
            continue;
        }

        if (!need_delete && !SkipEntriesScan) {
            if (IndexFrs->QueryFileNumber() == file_number) {
                pfrs = IndexFrs;
                pNode = frsDataRec.GetNext(pNode);
            } else {
                if (!frs.Initialize()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                if (read_failure) {
                    frs.SetFrsData(file_number,
                                   (PFILE_RECORD_SEGMENT_HEADER)
                                   frsDataRec.GetBuffer(frsDataRec.GetSortedFirst()));
                    if (!frs.Read())
                        need_delete = TRUE;
                } else {
                    DebugAssert(file_number == frsDataRec.GetData(pNode));
                    frs.SetFrsData(frsDataRec.GetData(pNode),
                                   (PFILE_RECORD_SEGMENT_HEADER)
                                   frsDataRec.GetBuffer(pNode));
                    pNode = frsDataRec.GetNext(pNode);
                }

                if (!frs.IsInUse()) {

                    if (file_name_index) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_FREE_FRS,
                                     "%I64x%W%W%I64x",
                                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                                     Index->GetName(),
                                     &entry_name,
                                     file_number.GetLargeInteger());
                    } else {

                        Message->Lock();
                        Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_FREE_FRS);
                        Message->Log("%I64x%W%I64x",
                                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                                     Index->GetName(),
                                     file_number.GetLargeInteger());
                        Message->DumpDataToLog((PVOID)index_entry,
                                               max(min(0x100, index_entry->Length),
                                                   sizeof(INDEX_ENTRY)));
                        Message->Unlock();
                    }
                    need_delete = TRUE;
                }

                pfrs = &frs;
            }
        }
        frsDataRecordCount--;

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names &&
            !(file_name->ParentDirectory ==
              IndexFrs->QuerySegmentReference())) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                         "%I64x%W%I64x%W%I64x",
                         IndexFrs->QuerySegmentReference(),
                         Index->GetName(),
                         file_name->ParentDirectory,
                         &entry_name,
                         file_number.GetLargeInteger());
            need_delete = TRUE;
        }

        if (!SkipEntriesScan) {

            if (!need_delete && !pfrs->IsBase()) {

                if (file_name_index) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_NON_BASE_FRS,
                                 "%I64x%W%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 &entry_name,
                                 file_number.GetLargeInteger());
                } else {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_NON_BASE_FRS);
                    Message->Log("%I64x%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 file_number.GetLargeInteger());
                    Message->DumpDataToLog((PVOID)index_entry,
                                           max(min(0x100, index_entry->Length),
                                               sizeof(INDEX_ENTRY)));
                    Message->Unlock();
                }
                need_delete = TRUE;
            }

            if (!need_delete &&
                !(pfrs->QuerySegmentReference() == index_entry->FileReference)) {

                if (file_name_index) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_FILE_REF,
                                 "%I64x%W%W%I64x%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 &entry_name,
                                 index_entry->FileReference,
                                 pfrs->QuerySegmentReference());
                } else {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_INCORRECT_UNNAMED_INDEX_ENTRY_FILE_REF);
                    Message->Log("%I64x%W%I64x%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 index_entry->FileReference,
                                 pfrs->QuerySegmentReference());
                    Message->DumpDataToLog((PVOID)index_entry,
                                           max(min(0x100, index_entry->Length),
                                               sizeof(INDEX_ENTRY)));
                    Message->Unlock();
                }
                need_delete = TRUE;
            }

            if (!need_delete &&
                file_name_index &&
                !file_has_too_many_file_names &&
                !pfrs->VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                             ChkdskInfo,
                                             FixLevel, Message,
                                             DiskErrorsFound, FALSE)) {
                return FALSE;
            }

            // After verifying the file names we know that this FRS is
            // not a candidate for a missing data attribute if it has
            // its index bit set.

            if (!need_delete && pfrs->IsIndexPresent()) {
                ChkdskInfo->FilesWhoNeedData.SetFree(file_number, 1);
            }

            // do we need to see if this is a file_name_index first?
            if (!need_delete &&
                !file_has_too_many_file_names &&
                !pfrs->QueryResidentAttribute(&attribute, &error,
                                              Index->QueryTypeCode(),
                                              file_name,
                                              index_entry->AttributeLength,
                                              Index->QueryCollationRule())) {

                if (file_name_index) {

                    Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_INDEX_ENTRY_VALUE_FILE_NAME,
                                 "%I64x%W%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 &entry_name,
                                 file_number.GetLargeInteger());
                } else {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_UNNAMED_INDEX_ENTRY_VALUE_FILE_NAME);
                    Message->Log("%I64x%W%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 Index->GetName(),
                                 file_number.GetLargeInteger());
                    Message->DumpDataToLog(file_name,
                                           max(min(0x100, index_entry->AttributeLength),
                                               sizeof(FILE_NAME)));
                    Message->Unlock();
                }
                need_delete = TRUE;
            }
        }

        // Make sure that the duplicated information in the index
        // entry is correct, also check the back pointers, and
        // the flags.

        if (!need_delete &&
            !SkipEntriesScan &&
            file_name_index &&
            !file_has_too_many_file_names) {

            if (!pfrs->QueryDuplicatedInformation(&actual_dupinfo)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            frs_file_name = (PFILE_NAME) attribute.GetResidentValue();
            DebugAssert(frs_file_name);


            p = &file_name->Info;
            q = &actual_dupinfo;
            dupinfo_match = TRUE;

            if (memcmp(p, q, sizeof(DUPLICATED_INFORMATION)) ||
                frs_file_name->Flags != file_name->Flags) {

                if (file_number >= FIRST_USER_FILE_NUMBER) {

                    if (p->CreationTime != q->CreationTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in creation time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->CreationTime, q->CreationTime));
                    }

                    if (p->LastModificationTime != q->LastModificationTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in last mod time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->LastModificationTime, q->LastModificationTime));
                    }

                    if (p->LastChangeTime != q->LastChangeTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in last change time for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         p->LastChangeTime, q->LastChangeTime));
                    }

                    if (p->AllocatedLength != q->AllocatedLength) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in allocation length for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->AllocatedLength.GetLargeInteger(), q->AllocatedLength.GetLargeInteger()));
                    }

                    if (p->FileSize != q->FileSize) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file size for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->FileSize.GetLargeInteger(), q->FileSize.GetLargeInteger()));
                    }

                    if (p->FileAttributes != q->FileAttributes) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file attributes for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         p->FileAttributes, q->FileAttributes));
                    }

                    if (ChkdskInfo->major >= 2 &&
                        q->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                        if (p->ReparsePointTag != q->ReparsePointTag) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in reparse point for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->ReparsePointTag, q->ReparsePointTag));
                        }
                    } else {
                        if (p->PackedEaSize != q->PackedEaSize) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in packed ea size for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->PackedEaSize, q->PackedEaSize));
                        }
                    }

                    if (file_name->Flags != frs_file_name->Flags) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file name flags for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         file_name->Flags, frs_file_name->Flags));
                    }
                } else {
                    dupinfo_match = FALSE;
                }
            }

            if (!dupinfo_match) {

                // Don't report duplicated information on system files.

                if (file_number >= FIRST_USER_FILE_NUMBER) {
                    FileSystemConsistencyErrorsFound = TRUE;
                    if (CHKDSK_EXIT_SUCCESS == ChkdskInfo->ExitStatus) {
                        ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
                    }
                }


// Take out this message because it's annoying.
#if 0
                Message->DisplayMsg(MSG_CHK_NTFS_INACCURATE_DUPLICATED_INFORMATION,
                                 "%d", file_number.GetLowPart());
#endif

                if (FixLevel != CheckOnly) {
                    *Changes = TRUE;
                }

                memcpy(&file_name->Info, &actual_dupinfo,
                       sizeof(DUPLICATED_INFORMATION));
                file_name->Flags = frs_file_name->Flags;

                if (FixLevel != CheckOnly && !Index->WriteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }

            if (!(frs_file_name->ParentDirectory ==
                  file_name->ParentDirectory)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                             "%I64x%W%W%I64x%I64x",
                             IndexFrs->QuerySegmentReference(),
                             Index->GetName(),
                             &entry_name,
                             file_name->ParentDirectory,
                             file_number.GetLargeInteger());

                need_delete = TRUE;
            }
        }

        if (need_delete) {

            *Changes = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (file_name_index && !invalid_entry_name) {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY,
                                 "%d%W%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName(),
                                 &entry_name);
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());
            }

            *DiskErrorsFound = TRUE;

            if (FixLevel != CheckOnly &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else if (file_number < ChkdskInfo->NumFiles) {
            ChkdskInfo->ReferenceCount[file_number.GetLowPart()]--;
            if (file_name_index) {

                ChkdskInfo->NumFileNames[file_number.GetLowPart()]--;
                *NumFileNames += 1;

                if (!SkipCycleScan &&
                    !DirectoryDigraph->AddEdge(IndexFrs->QueryFileNumber().
                                               GetLowPart(),
                                               file_number.GetLowPart())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }
    }
    if (frsDataRecordCount == 0) {
        goto ProcessNextBlock;
    }

    DebugAssert(FALSE);
    return FALSE;
}

BOOLEAN
NTFS_SA::ValidateEntriesInIndex2(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PDIGRAPH                    DirectoryDigraph,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      BOOLEAN                     SkipCycleScan,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given index
    and makes sure that they point to an appropriate attribute.  This
    verification will not be made if the index has index name "$I30".

    In either case the 'ChkdskInfo's ReferenceCount fields will be
    updated.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    DirectoryDigraph    - Supplies the current directory digraph.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    BOOLEAN                     file_name_index;
    DSTRING                     file_name_index_name;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    BOOLEAN                     invalid_entry_name;
    DSTRING                     entry_name;
    PFILE_NAME                  file_name, frs_file_name;
    DUPLICATED_INFORMATION      actual_dupinfo;
    BOOLEAN                     dupinfo_match;
    PDUPLICATED_INFORMATION     p, q;
    BOOLEAN                     file_has_too_many_file_names;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    *Changes = FALSE;

    if (!file_name_index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_name_index = !Index->GetName()->Strcmp(&file_name_index_name) &&
                      Index->QueryTypeCode() == $FILE_NAME;

    Index->ResetIterator();

    while (index_entry = Index->GetNext(&depth, &error)) {

        file_number.Set(index_entry->FileReference.LowPart,
                        (LONG) index_entry->FileReference.HighPart);

        if (ChkdskInfo->IndexEntriesToCheck.IsFree(file_number, 1))
            continue;

        need_delete = FALSE;
        file_has_too_many_file_names = ChkdskInfo->
                FilesWithTooManyFileNames.DoesIntersectSet(file_number, 1);

        file_name = (PFILE_NAME) GetIndexEntryValue(index_entry);

        if (file_name_index &&
            !QueryFileNameFromIndex(file_name,
                                    index_entry->AttributeLength,
                                    &entry_name)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_FILE_NAME_IN_INDEX_ENTRY_VALUE);
            Message->Log("%I64x%W%x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         Index->GetName(),
                         index_entry->AttributeLength,
                         file_number.GetLargeInteger());
            Message->DumpDataToLog(file_name,
                                   max(min(0x100, index_entry->AttributeLength),
                                       sizeof(FILE_NAME)));
            Message->Unlock();

            need_delete = invalid_entry_name = TRUE;
        } else
            invalid_entry_name = FALSE;

        if (!need_delete) {
            if (IndexFrs->QueryFileNumber() == file_number) {
                pfrs = IndexFrs;
            } else {
                if (!frs.Initialize(file_number, Mft)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                if (!frs.Read()) {
                    need_delete = TRUE;
                } else if (!frs.IsInUse()) {

                    if (file_name_index) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_FREE_FRS,
                                     "%I64x%W%W%I64x",
                                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                                     Index->GetName(),
                                     &entry_name,
                                     file_number.GetLargeInteger());
                    } else {

                        Message->Lock();
                        Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_FREE_FRS);
                        Message->Log("%I64x%W%I64x",
                                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                                     Index->GetName(),
                                     file_number.GetLargeInteger());
                        Message->DumpDataToLog((PVOID)index_entry,
                                               max(min(0x100, index_entry->Length),
                                                   sizeof(INDEX_ENTRY)));
                        Message->Unlock();
                    }
                    need_delete = TRUE;
                }
                pfrs = &frs;
            }
        }

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names &&
            !(file_name->ParentDirectory ==
              IndexFrs->QuerySegmentReference())) {

            Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                         "%I64x%W%I64x%W%I64x",
                         IndexFrs->QuerySegmentReference(),
                         Index->GetName(),
                         file_name->ParentDirectory,
                         &entry_name,
                         file_number.GetLargeInteger());
            need_delete = TRUE;
        }

        if (!need_delete && !pfrs->IsBase()) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_POINTS_TO_NON_BASE_FRS,
                             "%I64x%W%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             file_number.GetLargeInteger());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_UNNAMED_INDEX_ENTRY_POINTS_TO_NON_BASE_FRS);
                Message->Log("%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog((PVOID)index_entry,
                                       max(min(0x100, index_entry->Length),
                                           sizeof(INDEX_ENTRY)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        if (!need_delete &&
            !(pfrs->QuerySegmentReference() == index_entry->FileReference)) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_FILE_REF,
                             "%I64x%W%W%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             index_entry->FileReference,
                             pfrs->QuerySegmentReference());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_UNNAMED_INDEX_ENTRY_FILE_REF);
                Message->Log("%I64x%W%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             index_entry->FileReference,
                             pfrs->QuerySegmentReference());
                Message->DumpDataToLog((PVOID)index_entry,
                                       max(min(0x100, index_entry->Length),
                                           sizeof(INDEX_ENTRY)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names &&
            !pfrs->VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                         ChkdskInfo,
                                         FixLevel, Message,
                                         DiskErrorsFound, FALSE)) {

            return FALSE;
        }

        // After verifying the file names we know that this FRS is
        // not a candidate for a missing data attribute if it has
        // its index bit set.

        if (!need_delete && pfrs->IsIndexPresent()) {
            ChkdskInfo->FilesWhoNeedData.SetFree(file_number, 1);
        }

        if (!need_delete &&
            !file_has_too_many_file_names &&
            !pfrs->QueryResidentAttribute(&attribute, &error,
                                          Index->QueryTypeCode(),
                                          file_name,
                                          index_entry->AttributeLength,
                                          Index->QueryCollationRule())) {

            if (file_name_index) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_INDEX_ENTRY_VALUE_FILE_NAME,
                             "%I64x%W%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             &entry_name,
                             file_number.GetLargeInteger());
            } else {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_UNABLE_TO_FIND_UNNAMED_INDEX_ENTRY_VALUE_FILE_NAME);
                Message->Log("%I64x%W%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             Index->GetName(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog(file_name,
                                       max(min(0x100, index_entry->AttributeLength),
                                           sizeof(FILE_NAME)));
                Message->Unlock();
            }
            need_delete = TRUE;
        }

        // Make sure that the duplicated information in the index
        // entry is correct, also check the back pointers, and
        // the flags.

        if (!need_delete &&
            file_name_index &&
            !file_has_too_many_file_names) {

            if (!pfrs->QueryDuplicatedInformation(&actual_dupinfo)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            frs_file_name = (PFILE_NAME) attribute.GetResidentValue();
            DebugAssert(frs_file_name);


            p = &file_name->Info;
            q = &actual_dupinfo;
            dupinfo_match = TRUE;

            if (memcmp(p, q, sizeof(DUPLICATED_INFORMATION)) ||
                frs_file_name->Flags != file_name->Flags) {

                if (file_number >= FIRST_USER_FILE_NUMBER) {

                    if (p->CreationTime != q->CreationTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in creation time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->CreationTime, q->CreationTime));
                    }

                    if (p->LastModificationTime != q->LastModificationTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in last mod time for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->LastModificationTime, q->LastModificationTime));
                    }

                    if (p->LastChangeTime != q->LastChangeTime) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in last change time for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         p->LastChangeTime, q->LastChangeTime));
                    }

                    if (p->AllocatedLength != q->AllocatedLength) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in allocation length for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->AllocatedLength.GetLargeInteger(), q->AllocatedLength.GetLargeInteger()));
                    }

                    if (p->FileSize != q->FileSize) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file size for file 0x%I64x, indx = 0x%I64x, frs = 0x%I64x\n",
                                         file_number.GetLargeInteger(),
                                         p->FileSize.GetLargeInteger(), q->FileSize.GetLargeInteger()));
                    }

                    if (p->FileAttributes != q->FileAttributes) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file attributes for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         p->FileAttributes, q->FileAttributes));
                    }

                    if (ChkdskInfo->major >= 2 &&
                        q->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                        if (p->ReparsePointTag != q->ReparsePointTag) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in reparse point for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->ReparsePointTag, q->ReparsePointTag));
                        }
                    } else {
                        if (p->PackedEaSize != q->PackedEaSize) {
                            dupinfo_match = FALSE;
                            DebugPrintTrace(("UNTFS: Minor inconsistency in packed ea size for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                             file_number.GetLargeInteger(),
                                             p->PackedEaSize, q->PackedEaSize));
                        }
                    }

                    if (file_name->Flags != frs_file_name->Flags) {
                        dupinfo_match = FALSE;
                        DebugPrintTrace(("UNTFS: Minor inconsistency in file name flags for file 0x%I64x, indx = 0x%x, frs = 0x%x\n",
                                         file_number.GetLargeInteger(),
                                         file_name->Flags, frs_file_name->Flags));
                    }
                } else {
                    dupinfo_match = FALSE;
                }
            }

            if (!dupinfo_match) {

                // Don't report duplicated information on system files.

                if (file_number >= FIRST_USER_FILE_NUMBER) {
                    FileSystemConsistencyErrorsFound = TRUE;
                    if (CHKDSK_EXIT_SUCCESS == ChkdskInfo->ExitStatus) {
                        ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
                    }
                }


// Take out this message because it's annoying.
#if 0
                Message->DisplayMsg(MSG_CHK_NTFS_INACCURATE_DUPLICATED_INFORMATION,
                                 "%d", file_number.GetLowPart());
#endif

                if (FixLevel != CheckOnly) {
                    *Changes = TRUE;
                }

                memcpy(&file_name->Info, &actual_dupinfo,
                       sizeof(DUPLICATED_INFORMATION));
                file_name->Flags = frs_file_name->Flags;

                if (FixLevel != CheckOnly && !Index->WriteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }

            if (!(frs_file_name->ParentDirectory ==
                  file_name->ParentDirectory)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_ENTRY_FILE_NAME_HAS_INCORRECT_PARENT,
                             "%I64x%W%W%I64x%I64x",
                             IndexFrs->QuerySegmentReference(),
                             Index->GetName(),
                             &entry_name,
                             file_name->ParentDirectory,
                             file_number.GetLargeInteger());

                need_delete = TRUE;
            }
        }

        if (need_delete) {

            *Changes = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (file_name_index && !invalid_entry_name) {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY,
                                 "%d%W%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName(),
                                 &entry_name);
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());
            }

            *DiskErrorsFound = TRUE;

            if (FixLevel != CheckOnly &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else if (file_number < ChkdskInfo->NumFiles) {
            ChkdskInfo->ReferenceCount[file_number.GetLowPart()]--;
            if (file_name_index) {

                ChkdskInfo->NumFileNames[file_number.GetLowPart()]--;

                if (!SkipCycleScan &&
                    !DirectoryDigraph->AddEdge(IndexFrs->QueryFileNumber().
                                               GetLowPart(),
                                               file_number.GetLowPart())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

BOOLEAN
NTFS_SA::ValidateEntriesInObjIdIndex(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given object id
    index and makes sure that they point to an appropriate file with
    the same object id.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    POBJID_INDEX_ENTRY_VALUE    objid_index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    DSTRING                     IndexName;
    NTFS_INDEX_TREE             IndexTree;
    BIG_INT                     i;
    PINDEX_ENTRY                NewEntry;
    NUMBER_SET                  DuplicateTest;
    BOOLEAN                     AlreadyExists;
    BOOLEAN                     need_save;
    OBJECT_ID                   ObjId;
    ULONG                       BytesRead;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    //
    // First make sure each entry in the index reference an unique frs
    //

    if (!DuplicateTest.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    *Changes = FALSE;
    need_save = FALSE;
    Index->ResetIterator();
    while (index_entry = Index->GetNext(&depth, &error)) {
        objid_index_entry = (POBJID_INDEX_ENTRY_VALUE) GetIndexEntryValue(index_entry);

        file_number.Set(objid_index_entry->SegmentReference.LowPart,
                        (LONG) objid_index_entry->SegmentReference.HighPart);

        if (DuplicateTest.CheckAndAdd(file_number, &AlreadyExists)) {
            if (AlreadyExists) {

               // another entry with same file number
               // so we remove this colliding entry

               *DiskErrorsFound = TRUE;
               errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

               Message->LogMsg(MSG_CHKLOG_NTFS_MULTIPLE_OBJID_INDEX_ENTRIES_WITH_SAME_FILE_NUMBER,
                            "%I64x%I64x",
                            IndexFrs->QueryFileNumber().GetLargeInteger(),
                            file_number.GetLargeInteger());

               Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                "%d%W",
                                IndexFrs->QueryFileNumber().GetLowPart(),
                                Index->GetName());

               if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                   !Index->DeleteCurrentEntry()) {
                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
               }
               need_save = TRUE;
            }
        } else {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    if (need_save && FixLevel != CheckOnly && !Index->Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         IndexFrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    DuplicateTest.RemoveAll();

    //
    // now make sure index entries point to an existing frs
    //

    need_save = FALSE;
    Index->ResetIterator();
    while (index_entry = Index->GetNext(&depth, &error)) {

        objid_index_entry = (POBJID_INDEX_ENTRY_VALUE) GetIndexEntryValue(index_entry);

        file_number.Set(objid_index_entry->SegmentReference.LowPart,
                        (LONG) objid_index_entry->SegmentReference.HighPart);

        need_delete = FALSE;

        if (ChkdskInfo->FilesWithObjectId.DoesIntersectSet(file_number, 1)) {

            // there is a corresponding file with an object id entry
            // check to make sure that the two object id's are equal

            ChkdskInfo->FilesWithObjectId.Remove(file_number, 1);

            if (IndexFrs->QueryFileNumber() == file_number) {
                pfrs = IndexFrs;
            } else {

                MSGID   msgid;

                if (!frs.Initialize(file_number, Mft)) {
                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
                }

                error = FALSE;
                if (!frs.Read()) {
                    msgid = MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_WITH_UNREADABLE_FRS;
                    error = TRUE;
                } else if (!frs.IsInUse()) {
                    msgid = MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_WITH_NOT_INUSE_FRS;
                    error = TRUE;
                } else if (!frs.IsBase()) {
                    msgid = MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_WITH_NON_BASE_FRS;
                    error = TRUE;
                }

                if (error) {
                   // something is not right
                   // the frs was readable & in use otherwise we wouldn't be here

                   *DiskErrorsFound = TRUE;
                   errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                   Message->LogMsg(msgid, "%I64x%I64x",
                                IndexFrs->QueryFileNumber().GetLargeInteger(),
                                file_number.GetLargeInteger());

                   Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                    "%d%W",
                                    IndexFrs->QueryFileNumber().GetLowPart(),
                                    Index->GetName());

                   if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                       !Index->DeleteCurrentEntry()) {
                       Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                       return FALSE;
                   }
                   need_save = TRUE;
                   continue;
                }
                pfrs = &frs;
            }

            if (!pfrs->QueryAttribute(&attribute, &error, $OBJECT_ID) ||
                !attribute.Read(&ObjId, 0, sizeof(ObjId), &BytesRead) ||
                BytesRead != sizeof(ObjId)) {
                // previously exists attribute does not exists anymore
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (memcmp(&(objid_index_entry->key),
                       &ObjId, sizeof(OBJECT_ID)) != 0) {

                // Assume the object id stored with the index is incorrect.
                // We cannot just overwrite the incorrect values and write
                // out the entry as that may change the ordering of the index.
                // So, we delete the entry and insert it back later on

                if (!ChkdskInfo->FilesWithObjectId.Add(file_number)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                *DiskErrorsFound = TRUE;
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_HAS_INCORRECT_OBJID);
                Message->Log("%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             file_number.GetLargeInteger());
                Message->DumpDataToLog(&(objid_index_entry->key), sizeof(OBJECT_ID));
                Message->Set(MSG_CHKLOG_NTFS_DIVIDER);
                Message->Log();
                Message->DumpDataToLog(&ObjId, sizeof(OBJECT_ID));
                Message->Unlock();

                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());

                if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                    !Index->DeleteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_save = TRUE;
                continue;
            }

            if (!(objid_index_entry->SegmentReference ==
                pfrs->QuerySegmentReference())) {
                // should correct index entry

                *DiskErrorsFound = TRUE;
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_HAS_INCORRECT_PARENT);
                Message->Log("%I64x%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             objid_index_entry->SegmentReference,
                             pfrs->QuerySegmentReference());
                Message->DumpDataToLog(&(objid_index_entry->key), sizeof(OBJECT_ID));
                Message->Unlock();

                Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());

                objid_index_entry->SegmentReference = pfrs->QuerySegmentReference();

                if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                    !Index->WriteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_save = TRUE;
            }
        } else {
            // the particular file does not have an object id entry
            // this index entry should be deleted

            *DiskErrorsFound = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            Message->LogMsg(MSG_CHKLOG_NTFS_OBJID_INDEX_ENTRY_WITH_NO_OBJID_FRS,
                         "%I64x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         file_number.GetLargeInteger());

            Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                             "%d%W",
                             IndexFrs->QueryFileNumber().GetLowPart(),
                             Index->GetName());

            if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            need_save = TRUE;
        }
    }

    if (need_save && FixLevel != CheckOnly && !Index->Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         pfrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    // Now loop thru the remainder of files with object id and insert
    // them into the object id index

    if (!IndexName.Initialize(ObjectIdIndexNameData) ||
        !IndexTree.Initialize( IndexFrs->GetDrive(),
                               QueryClusterFactor(),
                               Mft->GetVolumeBitmap(),
                               IndexFrs->GetUpcaseTable(),
                               IndexFrs->QuerySize()/2,
                               IndexFrs,
                               &IndexName ) ) {
        return FALSE;
    }
    if (!(NewEntry = (PINDEX_ENTRY)MALLOC(sizeof(INDEX_ENTRY) +
                                          sizeof(OBJID_INDEX_ENTRY_VALUE)))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    need_save = FALSE;
    i = 0;
    while (i < ChkdskInfo->FilesWithObjectId.QueryCardinality()) {
        file_number = ChkdskInfo->FilesWithObjectId.QueryNumber(i);
        ChkdskInfo->FilesWithObjectId.Remove(file_number);
        if (!frs.Initialize(file_number, Mft) ||
            !frs.Read() ||
            !frs.QueryAttribute(&attribute, &error, $OBJECT_ID) ||
            !attribute.Read(&ObjId, 0, sizeof(ObjId), &BytesRead) ||
            BytesRead != sizeof(ObjId)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(NewEntry);
            return FALSE;
        }

        memset((PVOID)NewEntry, 0, sizeof(INDEX_ENTRY) +
                                   sizeof(OBJID_INDEX_ENTRY_VALUE));
        NewEntry->DataOffset = sizeof(INDEX_ENTRY)+sizeof(OBJECT_ID);
        NewEntry->DataLength = sizeof(OBJID_INDEX_ENTRY_VALUE)-sizeof(OBJECT_ID);
        NewEntry->ReservedForZero = 0;
        NewEntry->Length = QuadAlign(sizeof(INDEX_ENTRY)+sizeof(OBJID_INDEX_ENTRY_VALUE));
        NewEntry->AttributeLength = sizeof(OBJECT_ID);
        NewEntry->Flags = 0;

        objid_index_entry = ((POBJID_INDEX_ENTRY_VALUE)GetIndexEntryValue(NewEntry));
        memcpy(&(objid_index_entry->key), &ObjId, sizeof(OBJECT_ID));
        objid_index_entry->SegmentReference = frs.QuerySegmentReference();
        memset(objid_index_entry->extraInfo, 0, sizeof(objid_index_entry->extraInfo));

        *DiskErrorsFound = TRUE;
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (FixLevel != CheckOnly && SET_TRUE(*Changes)) {

            BOOLEAN     duplicate;

            if (!IndexTree.InsertEntry( NewEntry, TRUE, &duplicate )) {
                //FREE(NewEntry);
                if (duplicate) {

                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_DUPLICATE_OBJID);
                    Message->Log("%I64x%I64x",
                                 IndexFrs->QueryFileNumber().GetLargeInteger(),
                                 file_number.GetLargeInteger());
                    Message->DumpDataToLog(&ObjId, sizeof(OBJECT_ID));
                    Message->Unlock();

                    Message->DisplayMsg(MSG_CHK_NTFS_DELETING_DUPLICATE_OBJID,
                                     "%d", file_number.GetLowPart());

                    if (!attribute.Resize(0, Mft->GetVolumeBitmap()) ||
                        !frs.PurgeAttribute(attribute.QueryTypeCode(),
                                                  attribute.GetName())) {
                        DebugPrintTrace(("UNTFS: Unable to purge object id attribute\n"));
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(NewEntry);
                        return FALSE;
                    }
                    if (!frs.Flush(Mft->GetVolumeBitmap())) {
                        DebugPrintTrace(("UNTFS: Unable to flush frs %d\n",
                                         frs.QueryFileNumber().GetLowPart()));
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(NewEntry);
                        return FALSE;
                    }
                } else {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_INSERT_INDEX_ENTRY);
                    FREE(NewEntry);
                    return FALSE;
                }
            } else {

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_OBJID_INDEX_ENTRY,
                             "%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             file_number.GetLargeInteger());

                Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());
                need_save = TRUE;
            }
        } else {
            Message->DisplayMsg(MSG_CHK_NTFS_MISSING_DUPLICATE_OBJID,
                             "%d", file_number.GetLowPart());
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    if (FixLevel == CheckOnly) {
        FREE(NewEntry);
        if (chkdskErrCouldNotFix)
            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
        return TRUE;
    }

    if (need_save && !IndexTree.Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         IndexFrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    FREE(NewEntry);

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
    return TRUE;
}

BOOLEAN
NTFS_SA::ValidateEntriesInReparseIndex(
    IN OUT  PNTFS_INDEX_TREE            Index,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   IndexFrs,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    OUT     PBOOLEAN                    Changes,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine goes through all of the entries in the given reparse point
    index and makes sure that they point to an appropriate file with
    the same tag.

Arguments:

    Index               - Supplies the index.
    IndexFrs            - Supplies the index frs.
    ChkdskInfo          - Supplies the current chkdsk information.
    Changes             - Returns whether or not changes were made.
    Mft                 - Supplies the master file table.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have
                            been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    frs;
    PCINDEX_ENTRY               index_entry;
    PREPARSE_INDEX_ENTRY_VALUE  reparse_index_entry;
    ULONG                       depth;
    BOOLEAN                     error;
    VCN                         file_number;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     need_delete;
    DSTRING                     IndexName;
    NTFS_INDEX_TREE             IndexTree;
    BIG_INT                     num_files;
    PINDEX_ENTRY                NewEntry;
    BOOLEAN                     need_save;
    REPARSE_DATA_BUFFER         reparse_point;
    ULONG                       BytesRead;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    NTFS_BITMAP                 filesWithReparsePoint;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time_t                      time1, time2;
    PCHAR                       timestr;
#endif

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time1);
    timestr = ctime(&time1);
    timestr[strlen(timestr)-1] = 0;
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE,
                        "%s%s", "ValidateEntriesInReparsePoint: ", timestr);
#endif

    *Changes = FALSE;

    num_files = ChkdskInfo->FilesWithReparsePoint.QuerySize();

    //
    // make a copy FilesWithReparsePoint
    //
    if (!filesWithReparsePoint.Initialize(num_files, FALSE)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    for (file_number = 0; file_number < num_files; file_number += 1) {

        if (ChkdskInfo->FilesWithReparsePoint.IsFree(file_number, 1))
            continue;
        else
            filesWithReparsePoint.SetAllocated(file_number, 1);
    }

    //
    // make sure index entries point to an existing frs
    //
    need_save = FALSE;
    Index->ResetIterator();
    while (index_entry = Index->GetNext(&depth, &error)) {

        reparse_index_entry = (PREPARSE_INDEX_ENTRY_VALUE) GetIndexEntryValue(index_entry);

        file_number.Set(reparse_index_entry->SegmentReference.LowPart,
                        (LONG)reparse_index_entry->SegmentReference.HighPart);

        need_delete = FALSE;

        if (!filesWithReparsePoint.IsFree(file_number, 1)) {

            // there is a corresponding file with a reparse point entry
            // check to make sure that the two tags are equal

            filesWithReparsePoint.SetFree(file_number, 1);

            if (IndexFrs->QueryFileNumber() == file_number) {
                pfrs = IndexFrs;
            } else {

                MSGID   msgid;

                if (!frs.Initialize(file_number, Mft)) {
                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
                }

                error = FALSE;
                if (!frs.Read()) {
                    msgid = MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_WITH_UNREADABLE_FRS;
                    error = TRUE;
                } else if (!frs.IsInUse()) {
                    msgid = MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_WITH_NOT_INUSE_FRS;
                    error = TRUE;
                } else if (!frs.IsBase()) {
                    msgid = MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_WITH_NON_BASE_FRS;
                    error = TRUE;
                }

                if (error) {

                   // something is not right
                   // the frs was readable & in use otherwise we wouldn't be here

                   *DiskErrorsFound = TRUE;
                   errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                   Message->LogMsg(msgid, "%I64x%I64x",
                                IndexFrs->QueryFileNumber().GetLargeInteger(),
                                file_number.GetLargeInteger());

                   Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                    "%d%W",
                                    IndexFrs->QueryFileNumber().GetLowPart(),
                                    Index->GetName());

                   if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                       !Index->DeleteCurrentEntry()) {
                       Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                       return FALSE;
                   }
                   need_save = TRUE;
                   continue;
                }
                pfrs = &frs;
            }

            if (!pfrs->QueryAttribute(&attribute, &error, $REPARSE_POINT) ||
                !attribute.Read(&reparse_point,
                                0,
                                FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                             GenericReparseBuffer.DataBuffer),
                                &BytesRead) ||
                BytesRead != FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                          GenericReparseBuffer.DataBuffer)) {
                // previously exists attribute does not exists anymore
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            error = FALSE;

            if (reparse_index_entry->Tag != reparse_point.ReparseTag) {

                Message->LogMsg(MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_HAS_INCORRECT_REPARSE_TAG,
                             "%I64x%x%x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             reparse_index_entry->Tag,
                             reparse_point.ReparseTag,
                             file_number.GetLargeInteger());
                error = TRUE;
            } else if (!(reparse_index_entry->SegmentReference ==
                         pfrs->QuerySegmentReference())) {

                Message->LogMsg(MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_HAS_INCORRECT_PARENT,
                             "%I64x%I64x%I64x",
                             IndexFrs->QueryFileNumber().GetLargeInteger(),
                             reparse_index_entry->SegmentReference,
                             pfrs->QuerySegmentReference(),
                             reparse_index_entry->Tag);
                error = TRUE;
            }

            if (error) {

                // Assume the reparse tag/SR stored with the index is incorrect.
                // We cannot just overwrite the incorrect values and write
                // out the entry as that may change the ordering of the index.
                // So, we delete the entry and insert it back later on

                filesWithReparsePoint.SetAllocated(file_number, 1);

                *DiskErrorsFound = TRUE;
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                                 "%d%W",
                                 IndexFrs->QueryFileNumber().GetLowPart(),
                                 Index->GetName());

                if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                    !Index->DeleteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_save = TRUE;
                continue;
            }
        } else {
            // the particular file does not have a reparse point entry
            // this index entry should be deleted

            *DiskErrorsFound = TRUE;
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            Message->LogMsg(MSG_CHKLOG_NTFS_REPARSE_INDEX_ENTRY_WITH_NO_REPARSE_FRS,
                         "%I64x%I64x",
                         IndexFrs->QueryFileNumber().GetLargeInteger(),
                         file_number.GetLargeInteger());

            Message->DisplayMsg(MSG_CHK_NTFS_DELETING_GENERIC_INDEX_ENTRY,
                             "%d%W",
                             IndexFrs->QueryFileNumber().GetLowPart(),
                             Index->GetName());

            if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
                !Index->DeleteCurrentEntry()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            need_save = TRUE;
        }
    }

    if (need_save && FixLevel != CheckOnly && !Index->Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         pfrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    // Now loop thru the remainder of files with reparse point and insert
    // them into the reparse index

    if (!IndexName.Initialize(ReparseIndexNameData) ||
        !IndexTree.Initialize( IndexFrs->GetDrive(),
                               QueryClusterFactor(),
                               Mft->GetVolumeBitmap(),
                               IndexFrs->GetUpcaseTable(),
                               IndexFrs->QuerySize()/2,
                               IndexFrs,
                               &IndexName ) ) {
        return FALSE;
    }
    if (!(NewEntry = (PINDEX_ENTRY)MALLOC(sizeof(INDEX_ENTRY) +
                                          sizeof(REPARSE_INDEX_ENTRY_VALUE)))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    need_save = FALSE;
    for (file_number = 0; file_number < num_files; file_number += 1) {

        if (filesWithReparsePoint.IsFree(file_number, 1))
            continue;

        if (!frs.Initialize(file_number, Mft) ||
            !frs.Read() ||
            !frs.QueryAttribute(&attribute, &error, $REPARSE_POINT) ||
            !attribute.Read(&reparse_point,
                            0,
                            FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                         GenericReparseBuffer.DataBuffer),
                            &BytesRead) ||
            BytesRead != FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                      GenericReparseBuffer.DataBuffer)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(NewEntry);
            return FALSE;
        }

        //
        // There is no data value.
        // The whole REPARSE_INDEX_ENTRY_VALUE is the index key
        //

        memset((PVOID)NewEntry, 0, sizeof(INDEX_ENTRY) +
                                   sizeof(REPARSE_INDEX_ENTRY_VALUE));
        NewEntry->DataOffset = sizeof(INDEX_ENTRY)+sizeof(REPARSE_INDEX_ENTRY_VALUE);
        NewEntry->DataLength = 0;
        NewEntry->ReservedForZero = 0;
        NewEntry->Length = QuadAlign(sizeof(INDEX_ENTRY)+sizeof(REPARSE_INDEX_ENTRY_VALUE));
        NewEntry->AttributeLength = sizeof(REPARSE_INDEX_ENTRY_VALUE);
        NewEntry->Flags = 0;

        reparse_index_entry = ((PREPARSE_INDEX_ENTRY_VALUE)GetIndexEntryValue(NewEntry));
        reparse_index_entry->Tag = reparse_point.ReparseTag;
        reparse_index_entry->SegmentReference = frs.QuerySegmentReference();

        *DiskErrorsFound = TRUE;
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_REPARSE_INDEX_ENTRY,
                     "%I64x%I64x",
                     IndexFrs->QueryFileNumber().GetLargeInteger(),
                     file_number.GetLargeInteger());

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                         "%d%W",
                         IndexFrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());

        if (FixLevel != CheckOnly && SET_TRUE(*Changes) &&
            !IndexTree.InsertEntry( NewEntry )) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_INSERT_INDEX_ENTRY);
            FREE(NewEntry);
            return FALSE;
        }
        need_save = TRUE;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    if (FixLevel == CheckOnly) {
        FREE(NewEntry);
        if (chkdskErrCouldNotFix)
            ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
        time(&time2);
        Message->Lock();
        Message->Set(MSG_CHK_NTFS_MESSAGE);
        timestr = ctime(&time2);
        timestr[strlen(timestr)-1] = 0;
        Message->Display("%s%s", "After ValidateEntriesInReparsePoint: ", timestr);
        Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(time2, time1));
        Message->Unlock();
#endif
        return TRUE;
    }

    if (need_save && !IndexTree.Save(IndexFrs)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                         "%d%W",
                         IndexFrs->QueryFileNumber().GetLowPart(),
                         Index->GetName());
        chkdskErrCouldNotFix = TRUE;
    }

    FREE(NewEntry);

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time2);
    Message->Lock();
    Message->Set(MSG_CHK_NTFS_MESSAGE);
    timestr = ctime(&time2);
    timestr[strlen(timestr)-1] = 0;
    Message->Display("%s%s", "After ValidateEntriesInReparsePoint: ", timestr);
    Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(time2, time1));
    Message->Unlock();
#endif

    return TRUE;
}

BOOLEAN
RemoveBadLink(
        OUT  PNUMBER_SET             Orphans,
    IN      ULONG                   ParentFileNumber,
    IN      ULONG                   ChildFileNumber,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine removes all file name links between the given
    parent in child.  Neither the directory entries nor the
    file names are preserved.

Arguments:

    ParentFileNumber    - Supplies the parent file number.
    ChildFileNumber     - Supplies the child file number.
    Mft                 - Supplies the master file table.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    parent_frs;
    NTFS_INDEX_TREE             index;
    NTFS_FILE_RECORD_SEGMENT    child_frs;
    PNTFS_FILE_RECORD_SEGMENT   pchild_frs;
    DSTRING                     index_name;
    BOOLEAN                     error;
    NTFS_ATTRIBUTE              attribute;
    ULONG                       i;
    PFILE_NAME                  file_name;
    ULONG                       attr_len;
    BOOLEAN                     success;

    if (ParentFileNumber == ROOT_FILE_NAME_INDEX_NUMBER &&
        ChildFileNumber == ROOT_FILE_NAME_INDEX_NUMBER) {

        return TRUE;
    }

    if (!parent_frs.Initialize(ParentFileNumber, Mft) ||
        !parent_frs.Read() ||
        !index_name.Initialize(FileNameIndexNameData) ||
        !index.Initialize(parent_frs.GetDrive(),
                          parent_frs.QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          parent_frs.QuerySize()/2,
                          &parent_frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ParentFileNumber == ChildFileNumber) {
        pchild_frs = &parent_frs;
    } else {

        pchild_frs = &child_frs;

        if (!pchild_frs->Initialize(ChildFileNumber, Mft) ||
            !pchild_frs->Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    i = 0;
    while (pchild_frs->QueryAttributeByOrdinal(&attribute, &error,
                                               $FILE_NAME, i)) {

        file_name = (PFILE_NAME) attribute.GetResidentValue();
        attr_len = attribute.QueryValueLength().GetLowPart();

        if (file_name->ParentDirectory.LowPart == ParentFileNumber) {

            if (!pchild_frs->DeleteResidentAttribute($FILE_NAME, NULL,
                        file_name, attr_len, &success) ||
                !success ||
                !index.DeleteEntry(attr_len, file_name, 0)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            i = 0;
        } else
            i++;
    }
    //
    // if nobody is referencing the child and the child is not the root,
    // then it becomes an orphan
    //
    if (pchild_frs->QueryReferenceCount() == 0 &&
        ChildFileNumber != ROOT_FILE_NAME_INDEX_NUMBER) {

        Message->LogMsg(MSG_CHKLOG_NTFS_ORPHAN_CREATED_ON_BREAKING_CYCLE,
                     "%x%x", ParentFileNumber, ChildFileNumber);

        Orphans->Add(ChildFileNumber);
    }

    if (error || FixLevel != CheckOnly) {
        if (error ||
            !index.Save(&parent_frs) ||
            !parent_frs.Flush(Mft->GetVolumeBitmap()) ||
            !pchild_frs->Flush(Mft->GetVolumeBitmap())) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::RecoverOrphans(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PDIGRAPH                DirectoryDigraph,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      BOOLEAN                 SkipCycleScan,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine recovers orphans into a subdirectory of the root
    subdirectory.  It also validates the existence of the file
    systems root directory which it expects to be supplied in the
    list of 'OrphanedDirectories'.

Arguments:

    ChkdskInfo          - Supplies the current chkdsk information.
    ChkdskReport        - Supplies the current chkdsk report to be updated
                            by this routine.
    DirectoryDigraph    - Supplies the directory digraph.
    Mft                 - Supplies the master file table.
    SkipCycleScan       - Supplies if cycles within directory tree should be checcked.
    FixLevel            - Supplies the fix up level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    LIST                        bad_links;
    PITERATOR                   bad_links_iter;
    PDIGRAPH_EDGE               p;
    NUMBER_SET                  parents_of_root;
    ULONG                       i, n;
    NTFS_FILE_RECORD_SEGMENT    root_frs;
    NTFS_INDEX_TREE             root_index;
    DSTRING                     index_name;
    NUMBER_SET                  orphans;
    PNUMBER_SET                 no_ref;
    ULONG                       cluster_size;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    // First make sure that the root directory is intact.

    if (!index_name.Initialize(FileNameIndexNameData) ||
        !root_frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, Mft) ||
        !root_frs.Read()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    BOOLEAN error = FALSE;

    if (!root_frs.IsIndexPresent()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_FILE_NAME_INDEX_PRESENT_BIT,
                     "%x", ROOT_FILE_NAME_INDEX_NUMBER);

        error = TRUE;
    } else if (!root_index.Initialize(_drive, QueryClusterFactor(),
                                      Mft->GetVolumeBitmap(),
                                      Mft->GetUpcaseTable(),
                                      root_frs.QuerySize()/2,
                                      &root_frs,
                                      &index_name)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_INVALID_ROOT_INDEX,
                     "%x%W", ROOT_FILE_NAME_INDEX_NUMBER, &index_name);

        error = TRUE;
    }

    if (error) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATING_ROOT_DIRECTORY);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (!root_index.Initialize($FILE_NAME,
               _drive, QueryClusterFactor(),
               Mft->GetVolumeBitmap(),
               Mft->GetUpcaseTable(),
               COLLATION_FILE_NAME,
               SMALL_INDEX_BUFFER_SIZE,
               root_frs.QuerySize()/2,
               &index_name)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        ChkdskReport->NumIndices += 1;

        if (FixLevel != CheckOnly &&
            (!root_index.Save(&root_frs) ||
             !root_frs.Flush(Mft->GetVolumeBitmap()))) {

            DebugAbort("can't write");
            return FALSE;
        }
    }


    // Compute the list of orphans.  This is to include files with
    // no references whatsoever.

    if (!orphans.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    for (i = 0; i < ChkdskInfo->NumFiles; i++) {
        if (ChkdskInfo->NumFileNames[i] && !orphans.Add(i)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    no_ref = &(ChkdskInfo->FilesWithNoReferences);
    if (!no_ref->Remove(0, FIRST_USER_FILE_NUMBER) ||
        !orphans.Add(no_ref)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (orphans.QueryCardinality() != 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_RECOVERING_ORPHANS);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        // Connect all possible orphans the easy way.  Adjust the
        // directory digraph accordingly.

        if (!ProperOrphanRecovery(&orphans, Mft, DirectoryDigraph,
                                  SkipCycleScan, ChkdskInfo, ChkdskReport,
                                  FixLevel, Message)) {
            return FALSE;
        }
    }


    // Construct a list with all of the links that introduce cycles
    // or point to the root.

    if (!SkipCycleScan) {

        if (!bad_links.Initialize() ||
            !DirectoryDigraph->EliminateCycles(&bad_links) ||
            !(bad_links_iter = bad_links.QueryIterator()) ||
            !DirectoryDigraph->QueryParents(ROOT_FILE_NAME_INDEX_NUMBER,
                                            &parents_of_root)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        n = parents_of_root.QueryCardinality().GetLowPart();
        for (i = 0; i < n; i++) {

            if (!(p = NEW DIGRAPH_EDGE)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            p->Parent = parents_of_root.QueryNumber(i).GetLowPart();
            p->Child = ROOT_FILE_NAME_INDEX_NUMBER;

            if (!bad_links.Put(p)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        bad_links_iter->Reset();
        while (p = (PDIGRAPH_EDGE) bad_links_iter->GetNext()) {

            // Ignore links from the root to itself.

            if (p->Parent == ROOT_FILE_NAME_INDEX_NUMBER &&
                p->Child == ROOT_FILE_NAME_INDEX_NUMBER) {

                continue;
            }

            Message->DisplayMsg(MSG_CHK_NTFS_CYCLES_IN_DIR_TREE,
                             "%d%d", p->Parent, p->Child);

            if (FixLevel == CheckOnly) {
                UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);
                return TRUE;
            }

            if (!RemoveBadLink(&orphans, p->Parent, p->Child,
                                        Mft, FixLevel, Message)) {
                return FALSE;
            }
        }

        DELETE(bad_links_iter);
        bad_links.DeleteAllMembers();
    }


    // Recover the remaining orphans.

    if (!root_frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, Mft) ||
        !root_frs.Read() ||
        !root_index.Initialize(_drive, QueryClusterFactor(),
                               Mft->GetVolumeBitmap(),
                               Mft->GetUpcaseTable(),
                               root_frs.QuerySize()/2,
                               &root_frs,
                               &index_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (orphans.QueryCardinality() != 0 &&
        !OldOrphanRecovery(&orphans, ChkdskInfo, ChkdskReport, &root_frs,
                           &root_index, Mft, FixLevel, Message)) {

        return FALSE;
    }

    if (FixLevel != CheckOnly) {

        if (!root_index.Save(&root_frs) ||
            !root_frs.Flush(Mft->GetVolumeBitmap())) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
            return FALSE;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
ConnectFile(
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   OrphanFile,
    IN OUT  PDIGRAPH                    DirectoryDigraph,
    OUT     PBOOLEAN                    Connected,
    IN      BOOLEAN                     RemoveCrookedLinks,
    IN      BOOLEAN                     SkipCycleScan,
    IN      PCNTFS_CHKDSK_INFO          ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This routine connects all possible file names contained in
    the orphan to their parents.  If any or all end up being
    connected before of after this call then *Connected will be
    set to TRUE.  If RemoveCrookedLinks is TRUE then this routine
    will delete any file names that cannot be connected to their
    parents.

Arguments:

    OrphanFile          - Supplies the file to connect.
    DirectoryDigraph    - Supplies the directory digraph for future
                            enhancements.
    Connected           - Returns whether or not the file could be
                            connected to at least one directory.
    RemoveCrookedLinks  - Supplies whether or not to remove file names
                            which cannot be connected to their parents.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    ChkdskInfo          - Supplies the current chkdsk information.
    ChkdskReport        - Supplies the current chkdsk report to be updated
                            by this routine.
    Mft                 - Supplies the master file table.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING                     index_name;
    NTFS_FILE_RECORD_SEGMENT    parent_file;
    PNTFS_FILE_RECORD_SEGMENT   pparent_file;
    NTFS_INDEX_TREE             parent_index;
    ULONG                       i;
    MFT_SEGMENT_REFERENCE       parent_seg_ref;
    VCN                         parent_file_number;
    DSTRING                     file_name_string;
    NTFS_ATTRIBUTE              file_name_attribute;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     error;
    PFILE_NAME                  file_name;
    MFT_SEGMENT_REFERENCE       seg_ref;
    BOOLEAN                     success;

    if (!index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // Iterate through all of the file name entries here.

    *Connected = FALSE;
    for (i = 0; OrphanFile->QueryAttributeByOrdinal(
                    &file_name_attribute, &error,
                    $FILE_NAME, i); i++) {

        file_name = (PFILE_NAME) file_name_attribute.GetResidentValue();
        DebugAssert(file_name);


        // Figure out who the claimed parent of the orphan is.

        parent_seg_ref = file_name->ParentDirectory;

        if (!file_name_string.Initialize(
                    file_name->FileName,
                    (ULONG) file_name->FileNameLength)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        parent_file_number.Set(parent_seg_ref.LowPart,
                               (LONG) parent_seg_ref.HighPart);

        if (parent_file_number == OrphanFile->QueryFileNumber()) {
            pparent_file = OrphanFile;
        } else {
            pparent_file = &parent_file;

            if (!pparent_file->Initialize(parent_file_number, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }


        // Determine whether or not the so-called parent is a real index.

        if ((pparent_file != OrphanFile && !pparent_file->Read()) ||
            !pparent_file->IsInUse() || !pparent_file->IsBase() ||
            (ChkdskInfo->major >= 2 && parent_file_number == EXTEND_TABLE_NUMBER) ||
            !(pparent_file->QuerySegmentReference() == parent_seg_ref) ||
            !pparent_file->QueryAttribute(&attribute, &error, $FILE_NAME) ||
            !parent_index.Initialize(OrphanFile->GetDrive(),
                                     OrphanFile->QueryClusterFactor(),
                                     Mft->GetVolumeBitmap(),
                                     pparent_file->GetUpcaseTable(),
                                     pparent_file->QuerySize()/2,
                                     pparent_file,
                                     &index_name) ||
            parent_index.QueryTypeCode() != $FILE_NAME) {

            if (RemoveCrookedLinks) {
                OrphanFile->DeleteResidentAttribute($FILE_NAME, NULL,
                        file_name,
                        file_name_attribute.QueryValueLength().GetLowPart(),
                        &success);

                OrphanFile->SetReferenceCount(
                        OrphanFile->QueryReferenceCount() + 1);

                i--;
            }

            continue;
        }


        // First make sure that the entry isn't already in there.

        if (parent_index.QueryFileReference(
                file_name_attribute.QueryValueLength().GetLowPart(),
                file_name, 0, &seg_ref, &error)) {

            // If the entry is there and points to this orphan
            // then the file is already connected.  Otherwise,
            // this file cannot be connected to the parent index
            // through this file name.  This file_name is then "crooked".

            if (seg_ref == OrphanFile->QuerySegmentReference()) {
                *Connected = TRUE;
            } else if (RemoveCrookedLinks) {

                OrphanFile->DeleteResidentAttribute($FILE_NAME, NULL,
                        file_name,
                        file_name_attribute.QueryValueLength().GetLowPart(),
                        &success);

                // Readjust the reference count post delete because
                // the file-name we deleted does not appear in any index.

                OrphanFile->SetReferenceCount(
                        OrphanFile->QueryReferenceCount() + 1);

                if (!OrphanFile->VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                                       ChkdskInfo,
                                                       FixLevel, Message) ||
                    !OrphanFile->Flush(Mft->GetVolumeBitmap(),
                                       &parent_index)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                i--;
            }

            continue;
        }


        // Now there is a parent directory so add this file name
        // into the index.

        Message->DisplayMsg(MSG_CHK_NTFS_RECOVERING_ORPHAN,
                            "%W%I64d%d", &file_name_string,
                            OrphanFile->QueryFileNumber().GetLargeInteger(),
                            pparent_file->QueryFileNumber().GetLowPart());

        if (FixLevel != CheckOnly) {

            BIG_INT         initial_size;
            BOOLEAN         error;
            NTFS_ATTRIBUTE  attrib;

            if (pparent_file->QueryAttribute(&attrib,
                                             &error,
                                             $INDEX_ALLOCATION,
                                             parent_index.GetName())) {
                initial_size = attrib.QueryAllocatedLength();
            } else if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            } else
                initial_size = 0;

            if (!parent_index.InsertEntry(
                    file_name_attribute.QueryValueLength().GetLowPart(),
                    file_name,
                    OrphanFile->QuerySegmentReference()) ||
                !OrphanFile->Flush(Mft->GetVolumeBitmap(),
                                   &parent_index) ||
                !parent_index.Save(pparent_file) ||
                !pparent_file->Flush(Mft->GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_RECOVER_ORPHAN);
            }

            if (pparent_file->QueryAttribute(&attrib,
                                             &error,
                                             $INDEX_ALLOCATION,
                                             parent_index.GetName())) {
                ChkdskReport->BytesInIndices +=
                    (attrib.QueryAllocatedLength() - initial_size);
            } else if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (!SkipCycleScan) {
            DirectoryDigraph->AddEdge(pparent_file->QueryFileNumber().GetLowPart(),
                                      OrphanFile->QueryFileNumber().GetLowPart());
        }

        OrphanFile->SetReferenceCount(OrphanFile->QueryReferenceCount() + 1);

        *Connected = TRUE;
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::ProperOrphanRecovery(
    IN OUT  PNUMBER_SET             Orphans,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PDIGRAPH                DirectoryDigraph,
    IN      BOOLEAN                 SkipCycleScan,
    IN      PCNTFS_CHKDSK_INFO      ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine attempts to recover the given orphans where they
    belong.  All properly recovered orphans will be deleted from the
    orphans list.

Arguments:

    Orphans             - Supplies the list of orphans.
    Mft                 - Supplies the master file table.
    DirectoryDigraph    - Supplies the directory digraph for future
                            enhancement.
    SkipCycleScan       - Supplies if cycles within directory tree should be checked.
    ChkdskInfo          - Supplies the current chkdsk information.
    ChkdskReport        - Supplies the current chkdsk report to be updated
                            by this routine.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    orphan_file;
    BIG_INT                     i;
    BOOLEAN                     connected;

    i = 0;
    while (i < Orphans->QueryCardinality()) {

        // First read in the orphaned file.

        if (!orphan_file.Initialize(Orphans->QueryNumber(i), Mft) ||
            !orphan_file.Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!orphan_file.VerifyAndFixFileNames(
                Mft->GetVolumeBitmap(), ChkdskInfo,
                FixLevel, Message)) {

            return FALSE;
        }

        if (!ConnectFile(&orphan_file, DirectoryDigraph,
                         &connected, FALSE, SkipCycleScan,
                         ChkdskInfo, ChkdskReport,
                         Mft, FixLevel, Message)) {

            return FALSE;
        }

        if (connected) {
            if (!Orphans->Remove(Orphans->QueryNumber(i))) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            // Go through the list of file names and delete those that
            // don't point anywhere.  Only do this one if in /F
            // mode.  Otherwise we see each orphan being recovered
            // twice.

            if (FixLevel != CheckOnly) {
                if (!ConnectFile(&orphan_file, DirectoryDigraph,
                                 &connected, TRUE, SkipCycleScan,
                                 ChkdskInfo, ChkdskReport,
                                 Mft, FixLevel, Message)) {

                    return FALSE;
                }
            }

        } else {
            i += 1;
        }

        if (FixLevel != CheckOnly &&
            !orphan_file.Flush(Mft->GetVolumeBitmap())) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_RECOVER_ORPHAN);
        }
    }

    return TRUE;
}


BOOLEAN
RecordParentPointers(
    IN      PCNUMBER_SET                Orphans,
    IN      PCNTFS_CHKDSK_INFO          ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    OUT     PDIGRAPH                    BackPointers
    )
/*++

Routine Description:

    This routine records the parent pointer information in the given
    digraph with (parent, source) edges.

Arguments:

    Orphans         - Supplies the list of orphans.
    ChkdskInfo      - Supplies the chkdsk information.
    Mft             - Supplies the MFT.
    BackPointers    - Returns the parent pointer relationships.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     error;
    ULONG                       i;
    PFILE_NAME                  file_name;
    ULONG                       parent_dir;
    ULONG                       file_number;

    if (!BackPointers->Initialize(ChkdskInfo->NumFiles)) {
        return FALSE;
    }

    for (i = 0; i < Orphans->QueryCardinality(); i++) {

        file_number = Orphans->QueryNumber(i).GetLowPart();

        if (!frs.Initialize(file_number, Mft) ||
            !frs.Read()) {
            return FALSE;
        }

        // Only consider one file name per file for this
        // analysis.  This is because we don't ever want
        // to have file in multiple found directories.

        if (frs.QueryAttribute(&attribute, &error, $FILE_NAME)) {

            file_name = (PFILE_NAME) attribute.GetResidentValue();

            parent_dir = file_name->ParentDirectory.LowPart;

            if (parent_dir < ChkdskInfo->NumFiles &&
                file_name->ParentDirectory.HighPart == 0 &&
                !BackPointers->AddEdge(parent_dir, file_number)) {
                return FALSE;
            }

        } else if (error) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
CreateNtfsDirectory(
    IN OUT  PNTFS_INDEX_TREE            CurrentIndex,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   CurrentDirFile,
    IN      PCWSTRING                   FileName,
    IN      ULONG                       FileAttributes,
    OUT     PNTFS_INDEX_TREE            SubDirIndex,
    OUT     PNTFS_FILE_RECORD_SEGMENT   SubDirFile,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    OUT     PBOOLEAN                    OutOfDisk
    )
/*++

Routine Description:

    This routine creates a new subdirectory for a directory.

Arguments:

    CurrentIndex    - Supplies the index in which to insert the
                        new subdirectory entry.
    CurrentDirFile  - Supplies the FRS for the above index.
    FileName        - Supplies the name of the new directory.
    FileAttributes  - Supplies the FILE_xxx flags which should be set in the
                      standard information of this file record segment.
    SubDirIndex     - Returns the index of the new subdirectory.
    SubDirFile      - Returns the FRS of the new subdirectory.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.
    OutOfDisk       - Returns whether this routine ran out of disk
                        space or not.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    VCN                     dir_file_number;
    STANDARD_INFORMATION    standard_info;
    FILE_NAME               file_name[2];
    ULONG                   file_name_size;
    DSTRING                 index_name;
    ULONG                   cluster_size;

    *OutOfDisk = FALSE;

    // Create a new file for this directory.

    if (!Mft->AllocateFileRecordSegment(&dir_file_number, FALSE)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
        *OutOfDisk = TRUE;
        return TRUE;
    }

    if (!SubDirFile->Initialize(dir_file_number, Mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_name->ParentDirectory = CurrentDirFile->QuerySegmentReference();
    file_name->FileNameLength = (UCHAR)FileName->QueryChCount();
    file_name->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
    FileName->QueryWSTR(0, TO_END, file_name->FileName,
                        sizeof(FILE_NAME)/sizeof(WCHAR));
    file_name_size = FIELD_OFFSET(FILE_NAME, FileName) +
                     FileName->QueryChCount()*sizeof(WCHAR);

    memset(&standard_info, 0, sizeof(STANDARD_INFORMATION));

    IFS_SYSTEM::QueryNtfsTime(&standard_info.CreationTime);

    standard_info.LastModificationTime =
    standard_info.LastChangeTime =
    standard_info.LastAccessTime = standard_info.CreationTime;
    standard_info.FileAttributes = FileAttributes;

    if (!SubDirFile->Create(&standard_info) ||
        !SubDirFile->AddFileNameAttribute(file_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    cluster_size = Mft->QueryClusterFactor() * Mft->QuerySectorSize();

    if (!index_name.Initialize(FileNameIndexNameData) ||
        !SubDirIndex->Initialize($FILE_NAME,
             SubDirFile->GetDrive(),
             SubDirFile->QueryClusterFactor(),
             Mft->GetVolumeBitmap(),
             Mft->GetUpcaseTable(),
             COLLATION_FILE_NAME,
             CurrentIndex->QueryBufferSize(),
             SubDirFile->QuerySize()/2,
             &index_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    // Insert the found file into the root index.

    if (FixLevel != CheckOnly &&
        !CurrentIndex->InsertEntry(file_name_size, file_name,
                                   SubDirFile->QuerySegmentReference())) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);

        Mft->GetMftBitmap()->SetFree(dir_file_number, 1);
        *OutOfDisk = TRUE;
        return TRUE;
    }

    SubDirFile->SetIndexPresent();

    return TRUE;
}


BOOLEAN
BuildOrphanSubDir(
    IN      ULONG                       DirNumber,
    IN      PCNTFS_CHKDSK_INFO          ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN      ULONG                       OldParentDir,
    IN OUT  PNUMBER_SET                 OrphansInDir,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN OUT  PNTFS_INDEX_TREE            FoundIndex,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   FoundFrs,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    OUT     PBOOLEAN                    OutOfDisk
    )
/*++

Routine Description:

    This routine build orphan directory 'dir<DirNumber>.chk' to
    contain the entries listed in 'OrphansInDir' and then puts
    that directory in given found directory.

Arguments:

    DirNumber       - Supplies the number of the directory to add.
    ChkdskInfo      - Supplies the current chkdsk information.
    ChkdskReport    - Supplies the current chkdsk report to be updated
                        by this routine.
    OldParentDir    - Supplies the old directory file number.
    OrphansInDir    - Supplies the file numbers of the orphans to
                        add to the new directory.  Returns those
                        orphans that were not recovered.
    Mft             - Supplies the MFT.
    FoundIndex      - Supplies the index of the found.XXX directory.
    FoundFrs        - Supplies the frs of found.XXX
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.
    OutOfDisk       - Indicates out of disk space.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    dir_file;
    NTFS_INDEX_TREE             dir_index;
    DSTRING                     dir_name;
    ULONG                       i, j, current_orphan;
    NTFS_FILE_RECORD_SEGMENT    orphan_file;
    CHAR                        buf[20];
    NTFS_ATTRIBUTE              attribute;
    BOOLEAN                     error;
    PFILE_NAME                  file_name;
    BOOLEAN                     success, connect;
    ULONG                       file_name_len;


    // First put together 'dir0000.chk' and add the entry to
    // found.000.

    sprintf(buf, "dir%04d.chk", DirNumber);
    if (!dir_name.Initialize(buf)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!CreateNtfsDirectory(FoundIndex, FoundFrs, &dir_name, 0, &dir_index,
                             &dir_file, Mft, FixLevel, Message, OutOfDisk)) {

        return FALSE;
    }

    if (*OutOfDisk == TRUE) {
        return TRUE;
    }

    ChkdskReport->NumIndices += 1;

    i = 0;
    while (i < OrphansInDir->QueryCardinality().GetLowPart()) {

        current_orphan = OrphansInDir->QueryNumber(i).GetLowPart();

        if (!orphan_file.Initialize(current_orphan, Mft) ||
            !orphan_file.Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // Go through all of the file names and tube those
        // that are not pointing to the old parent dir.  Otherwise
        // tweek the entry to point back to the new directory.

        connect = FALSE;
        j = 0;
        while (orphan_file.QueryAttributeByOrdinal(&attribute, &error,
                                                   $FILE_NAME, j)) {

            file_name = (PFILE_NAME) attribute.GetResidentValue();
            file_name_len = attribute.QueryValueLength().GetLowPart();

            if (file_name->ParentDirectory.LowPart == OldParentDir &&
                file_name->ParentDirectory.HighPart == 0) {

                if (!orphan_file.DeleteResidentAttribute(
                       $FILE_NAME, NULL, file_name, file_name_len, &success) ||
                   !success) {

                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
                }

                orphan_file.SetReferenceCount(
                       orphan_file.QueryReferenceCount() + 1);

                file_name->ParentDirectory = dir_file.QuerySegmentReference();

                if (!attribute.InsertIntoFile(&orphan_file,
                                              Mft->GetVolumeBitmap())) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                j = 0;  // reset ordinal as the insertion may have changed
                        // the ordering of the $FILE_NAME attributes

                if (FixLevel != CheckOnly) {
                    if (dir_index.InsertEntry(file_name_len, file_name,
                        orphan_file.QuerySegmentReference())) {

                        connect = TRUE;

                    } else {

                        // this one didn't connect, so destroy the
                        // file_name attribute.  Note that we have
                        // already adjusted the reference count so
                        // (unlike the parallel case in proper orphan
                        // recovery) we don't need to tweek it here.

                        orphan_file.DeleteResidentAttribute(
                            $FILE_NAME, NULL, file_name, file_name_len,
                            &success);
                    }

                } else {
                    connect = TRUE; // don't panic read-only chkdsk
                }
                continue;
            } else if (!(file_name->ParentDirectory ==
                        dir_file.QuerySegmentReference())) {
                if (!orphan_file.DeleteResidentAttribute(
                       $FILE_NAME, NULL, file_name, file_name_len, &success) ||
                   !success) {

                   Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                   return FALSE;
                }

                orphan_file.SetReferenceCount(
                       orphan_file.QueryReferenceCount() + 1);

                j = 0;
                continue;
            }
            j++;
        }

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!orphan_file.VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                               ChkdskInfo,
                                               FixLevel, Message,
                                               NULL, TRUE, TRUE)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (FixLevel != CheckOnly &&
            !orphan_file.Flush(Mft->GetVolumeBitmap(), &dir_index)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // If this one was connected then take it out of the list
        // of files that we're orphaned.  Otherwise just increment
        // the counter.

        if (connect) {
            if (!OrphansInDir->Remove(current_orphan)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        } else {
            i++;
        }
    }

    if (FixLevel != CheckOnly) {

        NTFS_ATTRIBUTE  attrib;
        BOOLEAN         error;

        if (!dir_index.Save(&dir_file) ||
            !dir_file.Flush(Mft->GetVolumeBitmap(), FoundIndex)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);

            *OutOfDisk = TRUE;

            return TRUE;
        }

        if (dir_file.QueryAttribute(&attrib,
                                    &error,
                                    $INDEX_ALLOCATION,
                                    dir_index.GetName())) {
            ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::OldOrphanRecovery(
    IN OUT  PNUMBER_SET                 Orphans,
    IN      PCNTFS_CHKDSK_INFO          ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   RootFrs,
    IN OUT  PNTFS_INDEX_TREE            RootIndex,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This routine recovers all of the orphans in the given list
    into a found.xxx directory.

Arguments:

    Orphans     - Supplies the list of orphans.
    ChkdskInfo  - Supplies the current chkdsk information.
    ChkdskReport- Supplies the current chkdsk report to be updated
                    by this routine.
    RootFrs     - Supplies the root FRS.
    RootIndex   - Supplies the root index.
    Mft         - Supplies the master file table.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    FILE_NAME                   found_name[2];
    ULONG                       found_name_size;
    MFT_SEGMENT_REFERENCE       ref;
    BOOLEAN                     error;
    NTFS_FILE_RECORD_SEGMENT    found_directory;
    ULONG                       i;
    NTFS_INDEX_TREE             found_index;
    NTFS_FILE_RECORD_SEGMENT    orphan_file;
    DSTRING                     index_name;
    FILE_NAME                   orphan_file_name[2];
    ULONG                       next_dir_num;
    ULONG                       next_file_num;
    VCN                         file_number;
    DIGRAPH                     back_pointers;
    NUMBER_SET                  dir_candidates;
    NUMBER_SET                  orphans_in_dir;
    ULONG                       dir_num;
    DSTRING                     lost_and_found;
    BOOLEAN                     out_of_disk;
    CHAR                        buf[20];


    // Create the FOUND.XXX directory.

    for (i = 0; i < 1000; i++) {
        found_name->Flags = FILE_NAME_DOS | FILE_NAME_NTFS;
        found_name->ParentDirectory = RootFrs->QuerySegmentReference();
        found_name->FileName[0] = 'f';
        found_name->FileName[1] = 'o';
        found_name->FileName[2] = 'u';
        found_name->FileName[3] = 'n';
        found_name->FileName[4] = 'd';
        found_name->FileName[5] = '.';
        found_name->FileName[6] = USHORT(i/100 + '0');
        found_name->FileName[7] = USHORT((i/10)%10 + '0');
        found_name->FileName[8] = USHORT(i%10 + '0');
        found_name->FileNameLength = 9;

        found_name_size = NtfsFileNameGetLength(found_name);

        if (!RootIndex->QueryFileReference(found_name_size, found_name, 0,
                                           &ref, &error) && !error) {
            break;
        }
    }

    if (i == 1000) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
        return TRUE;
    }

    sprintf(buf, "found.%03d", i);
    if (!lost_and_found.Initialize(buf)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!CreateNtfsDirectory(RootIndex, RootFrs, &lost_and_found,
                             FAT_DIRENT_ATTR_HIDDEN | FAT_DIRENT_ATTR_SYSTEM,
                             &found_index, &found_directory, Mft, FixLevel,
                             Message, &out_of_disk)) {
        return FALSE;
    }

    if (out_of_disk) {
        return TRUE;
    }

    ChkdskReport->NumIndices += 1;

    // Record the parent pointer relationship of the orphans in a
    // digraph and then extract those parents who have more than
    // one child.

    if (!RecordParentPointers(Orphans, ChkdskInfo, Mft, &back_pointers) ||
        !back_pointers.QueryParentsWithChildren(&dir_candidates, 2)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // Remove the root directory from consideration.  Since the
    // root directory exists any legitimate orphans should have
    // been properly recovered.  If a bunch point to the root
    // but couldn't be put into the root the just put them in
    // found.XXX, not a subdir thereof.

    dir_candidates.Remove(ROOT_FILE_NAME_INDEX_NUMBER);


    // Using the information just attained, put together some nice
    // found subdirectories for orphans with common parents.

    for (i = 0; i < dir_candidates.QueryCardinality(); i++) {

        dir_num = dir_candidates.QueryNumber(i).GetLowPart();

        if (!back_pointers.QueryChildren(dir_num, &orphans_in_dir) ||
            !Orphans->Remove(&orphans_in_dir)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!BuildOrphanSubDir(i, ChkdskInfo, ChkdskReport,
                               dir_num, &orphans_in_dir, Mft,
                               &found_index, &found_directory,
                               FixLevel, Message, &out_of_disk)) {
            return FALSE;
        }

        // Add back those orphans that were not recovered.

        if (!Orphans->Add(&orphans_in_dir)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (out_of_disk) {
            return TRUE;
        }
    }


    // Now go through all of the orphans that remain.

    for (next_dir_num = i, next_file_num = 0;
         Orphans->QueryCardinality() != 0 &&
         next_dir_num < 10000 && next_file_num < 10000;
         Orphans->Remove(file_number)) {

        file_number = Orphans->QueryNumber(0);

        if (!orphan_file.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!orphan_file.Read()) {
           continue;
        }

        if (!orphan_file.VerifyAndFixFileNames(Mft->GetVolumeBitmap(),
                                               ChkdskInfo,
                                               FixLevel, Message)) {

            return FALSE;
        }

        // Delete all file name attributes on this file and set
        // the current reference count to 0.

        while (orphan_file.IsAttributePresent($FILE_NAME)) {
            if (!orphan_file.PurgeAttribute($FILE_NAME)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        orphan_file.SetReferenceCount(0);

        if (orphan_file.QueryFileNumber() >= FIRST_USER_FILE_NUMBER) {

            // Put a new file name attribute on the orphan in
            // order to link it to the found directory.

            orphan_file_name->ParentDirectory =
                    found_directory.QuerySegmentReference();
            orphan_file_name->Flags = FILE_NAME_DOS | FILE_NAME_NTFS;

            if (orphan_file.IsIndexPresent()) {
                orphan_file_name->FileName[0] = 'd';
                orphan_file_name->FileName[1] = 'i';
                orphan_file_name->FileName[2] = 'r';
                orphan_file_name->FileName[3] = USHORT(next_dir_num/1000 + '0');
                orphan_file_name->FileName[4] = USHORT((next_dir_num/100)%10 + '0');
                orphan_file_name->FileName[5] = USHORT((next_dir_num/10)%10 + '0');
                orphan_file_name->FileName[6] = USHORT(next_dir_num%10 + '0');
                orphan_file_name->FileName[7] = '.';
                orphan_file_name->FileName[8] = 'c';
                orphan_file_name->FileName[9] = 'h';
                orphan_file_name->FileName[10] = 'k';
                orphan_file_name->FileNameLength = 11;
                next_dir_num++;
            } else {
                orphan_file_name->FileName[0] = 'f';
                orphan_file_name->FileName[1] = 'i';
                orphan_file_name->FileName[2] = 'l';
                orphan_file_name->FileName[3] = 'e';
                orphan_file_name->FileName[4] = USHORT(next_file_num/1000 + '0');
                orphan_file_name->FileName[5] = USHORT((next_file_num/100)%10 + '0');
                orphan_file_name->FileName[6] = USHORT((next_file_num/10)%10 + '0');
                orphan_file_name->FileName[7] = USHORT(next_file_num%10 + '0');
                orphan_file_name->FileName[8] = '.';
                orphan_file_name->FileName[9] = 'c';
                orphan_file_name->FileName[10] = 'h';
                orphan_file_name->FileName[11] = 'k';
                orphan_file_name->FileNameLength = 12;
                next_file_num++;
            }

            if (!orphan_file.AddFileNameAttribute(orphan_file_name)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
                return TRUE;
            }

            if (FixLevel != CheckOnly &&
                !found_index.InsertEntry(
                        NtfsFileNameGetLength(orphan_file_name),
                        orphan_file_name,
                        orphan_file.QuerySegmentReference())) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
                return TRUE;
            }
        }

        // Write out the newly found orphan.

        if (FixLevel != CheckOnly &&
            !orphan_file.Flush(Mft->GetVolumeBitmap(), &found_index)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);
            return FALSE;
        }
    }


    if (next_dir_num == 10000 || next_file_num == 10000) {
        Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_ORPHANS);
    }


    // Flush out the found.

    if (FixLevel != CheckOnly) {

        NTFS_ATTRIBUTE  attrib;
        BOOLEAN         error;

        if (!found_index.Save(&found_directory) ||
            !found_directory.Flush(Mft->GetVolumeBitmap(), RootIndex)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_ORPHANS);

            return TRUE;
        }

        if (found_directory.QueryAttribute(&attrib,
                                           &error,
                                           $INDEX_ALLOCATION,
                                           found_index.GetName())) {
            ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
ExtractExtendInfo(
    IN OUT  PNTFS_INDEX_TREE    Index,
    IN OUT  PNTFS_CHKDSK_INFO   ChkdskInfo,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine extracts the frs numbers for each of the corresponding
    files in the \$Extend directory.  It ignores file name that it does
    not recognize.

Arguments:

    Index       - Supplies the index to the $Extend directory.
    ChkdskInfo  - Supplies the current chkdsk information.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DSTRING                     entry_name;
    PFILE_NAME                  file_name;
    DSTRING                     extend_filename;
    FSTRING                     expected_extend_filename;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    BOOLEAN                     error;

    Index->ResetIterator();
    while (index_entry = Index->GetNext(&depth, &error)) {
        file_name = (PFILE_NAME) GetIndexEntryValue(index_entry);
        expected_extend_filename.Initialize(LQuotaFileName);
        if (!extend_filename.Initialize(NtfsFileNameGetName(file_name),
                                        file_name->FileNameLength)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (extend_filename.Strcmp(&expected_extend_filename) == 0) {
            if (ChkdskInfo->QuotaFileNumber.GetLowPart() ||
                ChkdskInfo->QuotaFileNumber.GetHighPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_MULTIPLE_QUOTA_FILE);
            } else {
                ChkdskInfo->QuotaFileNumber.Set(
                    index_entry->FileReference.LowPart,
                    (LONG) index_entry->FileReference.HighPart);
            }
            continue;
        }
        expected_extend_filename.Initialize(LObjectIdFileName);
        if (!extend_filename.Initialize(NtfsFileNameGetName(file_name),
                                        file_name->FileNameLength)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (extend_filename.Strcmp(&expected_extend_filename) == 0) {
            if (ChkdskInfo->ObjectIdFileNumber.GetLowPart() ||
                ChkdskInfo->ObjectIdFileNumber.GetHighPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_MULTIPLE_OBJECTID_FILE);
            } else {
                ChkdskInfo->ObjectIdFileNumber.Set(
                    index_entry->FileReference.LowPart,
                    (LONG) index_entry->FileReference.HighPart);
            }
            continue;
        }
        expected_extend_filename.Initialize(LUsnJournalFileName);
        if (!extend_filename.Initialize(NtfsFileNameGetName(file_name),
                                        file_name->FileNameLength)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (extend_filename.Strcmp(&expected_extend_filename) == 0) {
            if (ChkdskInfo->UsnJournalFileNumber.GetLowPart() ||
                ChkdskInfo->UsnJournalFileNumber.GetHighPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_MULTIPLE_USNJRNL_FILE);
            } else {
                ChkdskInfo->UsnJournalFileNumber.Set(
                    index_entry->FileReference.LowPart,
                    (LONG) index_entry->FileReference.HighPart);
            }
            continue;
        }
        expected_extend_filename.Initialize(LReparseFileName);
        if (!extend_filename.Initialize(NtfsFileNameGetName(file_name),
                                        file_name->FileNameLength)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (extend_filename.Strcmp(&expected_extend_filename) == 0) {
            if (ChkdskInfo->ReparseFileNumber.GetLowPart() ||
                ChkdskInfo->ReparseFileNumber.GetHighPart()) {
                Message->DisplayMsg(MSG_CHK_NTFS_MULTIPLE_REPARSE_FILE);
            } else {
                ChkdskInfo->ReparseFileNumber.Set(
                    index_entry->FileReference.LowPart,
                    (LONG) index_entry->FileReference.HighPart);
            }
            continue;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\largemcb.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    LargeMcb.c

Abstract:

    The MCB routines provide support for maintaining an in-memory copy of
    the retrieval mapping information for a file.  The general idea is to
    have the file system lookup the retrieval mapping for a VBN once from
    the disk, add the mapping to the MCB structure, and then utilize the
    MCB to retrieve the mapping for subsequent accesses to the file.  A
    variable of type MCB is used to store the mapping information.

    The routines provided here allow the user to incrementally store some
    or all of the retrieval mapping for a file and to do so in any order.
    That is, the mapping can be inserted to the MCB structure all at once
    starting from the beginning and working to the end of the file, or it
    can be randomly scattered throughout the file.

    The package identifies each contiguous run of sectors mapping VBNs
    and LBNs indenpendent of the order they are added to the MCB
    structure.  For example a user can define a mapping between VBN
    sector 0 and LBN sector 107, and between VBN sector 2 and LBN sector
    109.  The mapping now contains two runs each one sector in length.
    Now if the user adds an additional mapping between VBN sector 1 and
    LBN sector 106 the MCB structure will contain only one run 3 sectors
    in length.

    Concurrent access to the MCB structure is control by this package.

    The following routines are provided by this package:

      o  FsRtlInitializeMcb - Initialize a new MCB structure.  There
         should be one MCB for every opened file.  Each MCB structure
         must be initialized before it can be used by the system.

      o  FsRtlUninitializeMcb - Uninitialize an MCB structure.  This call
         is used to cleanup any anciallary structures allocated and
         maintained by the MCB.  After being uninitialized the MCB must
         again be initialized before it can be used by the system.

      o  FsRtlAddMcbEntry - This routine adds a new range of mappings
         between LBNs and VBNs to the MCB structure.

      o  FsRtlRemoveMcbEntry - This routines removes an existing range of
         mappings between LBNs and VBNs from the MCB structure.

      o  FsRtlLookupMcbEntry - This routine returns the LBN mapped to by
         a VBN, and indicates, in sectors, the length of the run.

      o  FsRtlLookupLastMcbEntry - This routine returns the mapping for
         the largest VBN stored in the structure.

      o  FsRtlNumberOfRunsInMcb - This routine tells the caller total
         number of discontiguous sectors runs stored in the MCB
         structure.

      o  FsRtlGetNextMcbEntry - This routine returns the the caller the
         starting VBN and LBN of a given run stored in the MCB structure.

Author:

    Gary Kimura     [GaryKi]    5-Feb-1990

Revision History:

--*/

#include "FsRtlP.h"

//
//  Trace level for the module
//

#define Dbg                              (0x80000000)


//
//  Retrieval mapping data structures.  The following two structure together
//  are used to map a Vbn to an Lbn.  It is layed out as follows:
//
//
//  MCB:
//      +----------------+----------------+
//      |    PairCount   |MaximumPairCount|
//      +----------------+----------------+
//      |     Mapping    |    PoolType    |
//      +----------------+----------------+
//
//
//  MAPPING:
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     | : 0
//      +----------------+----------------+
//      |                                 |
//      /                                 /
//      /                                 /
//      |                                 |
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     | : PairCount
//      +----------------+----------------+
//      |                                 |
//      /                                 /
//      /                                 /
//      |                                 |
//      +----------------+----------------+
//      |       Lbn      |    NextVbn     |
//      +----------------+----------------+
//
//                                          : MaximumPairCount
//
//  The pairs from 0 to PairCount - 1 are valid.  Given an index between
//  0 and PairCount - 1 (inclusive) it represents the following Vbn
//  to Lbn mapping information
//
//
//                     { if Index == 0 then 0
//      StartingVbn   {
//                     { if Index <> 0 then NextVbn[i-1]
//
//
//      EndingVbn      = NextVbn[i] - 1
//
//
//      StartingLbn    = Lbn[i]
//
//
//  To compute the mapping of a Vbn to an Lbn the following algorithm
//  is used
//
//      1. search through the pairs until we find the slot "i" that contains
//         the Vbn we after.  Report an error if none if found.
//
//      2. Lbn = StartingLbn + (Vbn - StartingVbn);
//
//  A hole in the allocation (i.e., a sparse allocation) is represented by
//  an Lbn value of -1 (note that is is different than Mcb.c).
//

#define UNUSED_LBN                       ((LBN64)-1)

typedef struct _MAPPING {
    VBN     NextVbn;
    LBN64   Lbn;
} MAPPING;
typedef MAPPING *PMAPPING;

typedef struct _NONOPAQUE_MCB {
    PFAST_MUTEX FastMutex;
    ULONG MaximumPairCount;
    ULONG PairCount;
    POOL_TYPE PoolType;
    PMAPPING Mapping;
} NONOPAQUE_MCB;
typedef NONOPAQUE_MCB *PNONOPAQUE_MCB;

C_ASSERT(sizeof(LARGE_MCB) >= sizeof(NONOPAQUE_MCB));

//
//  A macro to return the size, in bytes, of a retrieval mapping structure
//

#define SizeOfMapping(MCB) ((sizeof(MAPPING) * (MCB)->MaximumPairCount))

//
//  The parts of a run can be computed as follows:
//
//
//                StartingVbn(MCB,I)           Mapping[I].NextVbn
//                       |                             |
//                       V                             V
//
//        Run-(I-1)---+ +---------Run-(I)-----------+ +---Run-(I+1)
//
//                       A                         A
//                       |                         |
//                 Mapping[I].Lbn            EndingLbn(MCB,I)
//

#define PreviousEndingVbn(MCB,I) (                      \
    (VBN)((I) == 0 ? 0xffffffff : EndingVbn(MCB,(I)-1)) \
)

#define StartingVbn(MCB,I) (                                \
    (VBN)((I) == 0 ? 0 : (((MCB)->Mapping))[(I)-1].NextVbn) \
)

#define EndingVbn(MCB,I) (                     \
    (VBN)((((MCB)->Mapping)[(I)].NextVbn) - 1) \
)

#define NextStartingVbn(MCB,I) (                                \
    (VBN)((I) >= (MCB)->PairCount ? 0 : StartingVbn(MCB,(I)+1)) \
)




#define PreviousEndingLbn(MCB,I) (                      \
    ((I) == 0 ? UNUSED_LBN : EndingLbn(MCB,(I)-1)) \
)

#define StartingLbn(MCB,I) (         \
    (((MCB)->Mapping)[(I)].Lbn) \
)

#define EndingLbn(MCB,I) (                                       \
    (StartingLbn(MCB,I) == UNUSED_LBN ?                     \
          UNUSED_LBN :                                           \
          ((MCB)->Mapping[(I)].Lbn +                             \
           (MCB)->Mapping[(I)].NextVbn - StartingVbn(MCB,I) - 1) \
         )                                                       \
)

#define NextStartingLbn(MCB,I) (                                             \
    ((I) >= (MCB)->PairCount - 1 ? UNUSED_LBN : StartingLbn(MCB,(I)+1)) \
)

#if 0
LBN
NextStartingLbn(
    PNONOPAQUE_MCB Mcb,
    ULONG I
    )
{
    if ( I >= Mcb->PairCount - 1 ) {
        return (LBN)UNUSED_LBN;
        }
    else {
        return StartingLbn(Mcb,I+1);
        }
}
#endif

#define SectorsWithinRun(MCB,I) (                      \
    (ULONG)(EndingVbn(MCB,I) - StartingVbn(MCB,I) + 1) \
)

VOID
FsRtlRemoveMcbEntryPrivate (
    IN PNONOPAQUE_MCB OpaqueMcb,
    IN ULONG Vbn,
    IN ULONG SectorCount
    );

//
//  A private routine to search a mapping structure for a Vbn
//

BOOLEAN
FsRtlFindLargeIndex (
    IN PNONOPAQUE_MCB Mcb,
    IN VBN Vbn,
    OUT PULONG Index
    );

VOID
FsRtlAddLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToAddIndex,
    IN ULONG AmountToAdd
    );

VOID
FsRtlRemoveLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToRemoveIndex,
    IN ULONG AmountToRemove
    );

//
//  Some private routines to handle common allocations.
//

PVOID
FsRtlAllocateFirstMapping (
    );

VOID
FsRtlFreeFirstMapping (
    IN PVOID Mapping
    );

PFAST_MUTEX
FsRtlAllocateFastMutex (
    );

VOID
FsRtlFreeFastMutex (
    IN PFAST_MUTEX FastMutex
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlInitializeMcb)
#pragma alloc_text(PAGE, FsRtlUninitializeMcb)
#endif


//
//  Define a small cache of free mapping pairs structures and also the
//  initial size of the mapping pair
//

#define INITIAL_MAXIMUM_PAIR_COUNT       (15)

//
//  Some globals used with the first mapping allocation
//

#define FREE_FIRST_MAPPING_ARRAY_SIZE    (16)

PVOID FsRtlFreeFirstMappingArray[FREE_FIRST_MAPPING_ARRAY_SIZE];

UCHAR FsRtlFreeFirstMappingSize = 0;

ULONG FsRtlNetFirstMapping = 0;

//
//  Some globals used with the FastMutex allocation
//

#define FREE_FAST_MUTEX_ARRAY_SIZE      (16)

PFAST_MUTEX FsRtlFreeFastMutexArray[FREE_FAST_MUTEX_ARRAY_SIZE];

UCHAR FsRtlFreeFastMutexSize = 0;

ULONG FsRtlNetFastMutex = 0;

#if 0

//
//  The following few routines define the small mcb package which is
//  implemented behind everyones back as large mcbs.  The only funny
//  thing we really need to do here is to make sure that unused Lbns
//  get returned as 0 and not -1.  This is the result of an historical
//  difference between the original Mcb and LargeMcb packages.
//

VOID
FsRtlInitializeMcb (
    IN PMCB Mcb,
    IN POOL_TYPE PoolType
    )
{
    PAGED_CODE();

    FsRtlInitializeLargeMcb( (PLARGE_MCB)Mcb,
                             PoolType );

    return;
}

VOID
FsRtlUninitializeMcb (
    IN PMCB Mcb
    )

{
    PAGED_CODE();

    FsRtlUninitializeLargeMcb( (PLARGE_MCB)Mcb );

    return;
}

VOID
FsRtlTruncateMcb (
    IN PMCB Mcb,
    IN VBN Vbn
    )
{
   PAGED_CODE();

   FsRtlTruncateLargeMcb( (PLARGE_MCB)Mcb,
                          (LONGLONG)(Vbn) );

   return;
}

BOOLEAN
FsRtlAddMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    IN LBN Lbn,
    IN ULONG SectorCount
    )

{
    PAGED_CODE();

    return FsRtlAddLargeMcbEntry( (PLARGE_MCB)Mcb,
                                  (LONGLONG)(Vbn),
                                  (LONGLONG)(Lbn),
                                  (LONGLONG)(SectorCount) );
}

VOID
FsRtlRemoveMcbEntry (
    IN PMCB OpaqueMcb,
    IN VBN Vbn,
    IN ULONG SectorCount
    )

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlRemoveMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        FsRtlRemoveMcbEntryPrivate( Mcb,
                                    Vbn,
                                    SectorCount );

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlRemoveMcbEntry -> VOID\n", 0 );
    }

    return;
}

BOOLEAN
FsRtlLookupMcbEntry (
    IN PMCB Mcb,
    IN VBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount OPTIONAL,
    OUT PULONG Index OPTIONAL
    )

{
    BOOLEAN Results;
    LONGLONG LiLbn;
    LONGLONG LiSectorCount;

    Results = FsRtlLookupLargeMcbEntry( (PLARGE_MCB)Mcb,
                                        (LONGLONG)(Vbn),
                                        &LiLbn,
                                        ARGUMENT_PRESENT(SectorCount) ? &LiSectorCount : NULL,
                                        NULL,
                                        NULL,
                                        Index );

    *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));

    if (ARGUMENT_PRESENT(SectorCount)) { *SectorCount = ((ULONG)LiSectorCount); }

    return Results;
}

BOOLEAN
FsRtlLookupLastMcbEntry (
    IN PMCB Mcb,
    OUT PVBN Vbn,
    OUT PLBN Lbn
    )

{
    BOOLEAN Results;
    LONGLONG LiVbn;
    LONGLONG LiLbn;

    PAGED_CODE();

    Results = FsRtlLookupLastLargeMcbEntry( (PLARGE_MCB)Mcb,
                                            &LiVbn,
                                            &LiLbn );

    *Vbn = ((ULONG)LiVbn);
    *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));

    return Results;
}

ULONG
FsRtlNumberOfRunsInMcb (
    IN PMCB Mcb
    )

{
    PAGED_CODE();

    return FsRtlNumberOfRunsInLargeMcb( (PLARGE_MCB)Mcb );
}

BOOLEAN
FsRtlGetNextMcbEntry (
    IN PMCB Mcb,
    IN ULONG RunIndex,
    OUT PVBN Vbn,
    OUT PLBN Lbn,
    OUT PULONG SectorCount
    )

{
    BOOLEAN Results;
    LONGLONG LiVbn;
    LONGLONG LiLbn;
    LONGLONG LiSectorCount;

    PAGED_CODE();

    Results = FsRtlGetNextLargeMcbEntry( (PLARGE_MCB)Mcb,
                                         RunIndex,
                                         &LiVbn,
                                         &LiLbn,
                                         &LiSectorCount );

    *Vbn = ((ULONG)LiVbn);
    *Lbn = (((ULONG)LiLbn) == -1 ? 0 : ((ULONG)LiLbn));
    *SectorCount = ((ULONG)LiSectorCount);

    return Results;
}
#endif


VOID
FsRtlInitializeLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This routine initializes a new Mcb structure.  The caller must
    supply the memory for the Mcb structure.  This call must precede all
    other calls that set/query the Mcb structure.

    If pool is not available this routine will raise a status value
    indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to initialize.

    PoolType - Supplies the pool type to use when allocating additional
        internal Mcb memory.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    DebugTrace(+1, Dbg, "FsRtlInitializeLargeMcb, Mcb = %08lx\n", Mcb );

    //
    //  Preset the following fields to null so we know to deallocate them
    //  during an abnormal termination
    //

    Mcb->FastMutex = NULL;
    Mcb->Mapping = NULL;

    try {

        //
        //  Initialize the fields in the Mcb
        //

        Mcb->FastMutex = FsRtlAllocateFastMutex();

        ExInitializeFastMutex( Mcb->FastMutex );

        Mcb->PairCount = 0;
        Mcb->PoolType = PoolType;

        //
        //  Allocate a new buffer an initial size is one that will hold
        //  16 runs
        //

        if (PoolType == PagedPool) {

            Mcb->Mapping = FsRtlAllocateFirstMapping();

        } else {

            Mcb->Mapping = FsRtlAllocatePool( Mcb->PoolType, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );
        }

        //**** RtlZeroMemory( Mcb->Mapping, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );

        Mcb->MaximumPairCount = INITIAL_MAXIMUM_PAIR_COUNT;

    } finally {

        //
        //  If this is an abnormal termination then we need to deallocate
        //  the FastMutex and/or mapping.
        //

        if (AbnormalTermination()) {

            if (Mcb->FastMutex != NULL) { FsRtlFreeFastMutex( Mcb->FastMutex ); }
        }

        DebugTrace(-1, Dbg, "FsRtlInitializeLargeMcb -> VOID\n", 0 );
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
FsRtlUninitializeLargeMcb (
    IN PLARGE_MCB OpaqueMcb
    )

/*++

Routine Description:

    This routine uninitializes an Mcb structure.  After calling this routine
    the input Mcb structure must be re-initialized before being used again.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to uninitialize.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    DebugTrace(+1, Dbg, "FsRtlUninitializeLargeMcb, Mcb = %08lx\n", Mcb );

    //
    //  Protect against some user calling us to uninitialize an mcb twice
    //

    if (Mcb->FastMutex == NULL) {

        ASSERTMSG("Being called to uninitialize an Mcb that is already Uninitialized ", FALSE);

        return;
    }

    //
    //  Deallocate the FastMutex and mapping buffer
    //

    FsRtlFreeFastMutex( Mcb->FastMutex );

    Mcb->FastMutex = NULL;

    if ((Mcb->PoolType == PagedPool) && (Mcb->MaximumPairCount == INITIAL_MAXIMUM_PAIR_COUNT)) {

        FsRtlFreeFirstMapping( Mcb->Mapping );

    } else {

        ExFreePool( Mcb->Mapping );
    }

    //
    //  Now zero our all of the fields in the Mcb
    //

    //**** Mcb->MaximumPairCount = 0;
    //**** Mcb->PairCount = 0;
    //**** Mcb->Mapping = NULL;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlUninitializeLargeMcb -> VOID\n", 0 );

    return;
}


VOID
FsRtlTruncateLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn
    )

/*++

Routine Description:

    This routine truncates an Mcb structure to the specified Vbn.
    After calling this routine the Mcb will only contain mappings
    up to and not including the input vbn.

Arguments:

    OpaqueMcb - Supplies a pointer to the Mcb structure to truncate.

    LargeVbn - Specifies the last Vbn at which is no longer to be
      mapped.

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                 ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0x7FFFFFFF) &&
                                                  (((ULONG)LargeVbn) == 0xFFFFFFFF))));

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlTruncateLargeMcb, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Do a quick test to see if we are truncating the entire Mcb.
        //

        if (Vbn == 0) {

            Mcb->PairCount = 0;

        } else if (Mcb->PairCount > 0) {

            //
            //  Now if the pair count is greater than zero then we will
            //  call the remove mcb entry routine to actually do the truncation
            //  for us.
            //

            FsRtlRemoveMcbEntryPrivate( Mcb, Vbn, 0xffffffff - Vbn );
        }

        //
        //  Now see if we can shrink the allocation for the mapping pairs.
        //  We'll shrink the mapping pair buffer if the new pair count will
        //  fit within a quarter of the current maximum pair count and the
        //  current maximum is greater than the initial pair count.
        //

        if ((Mcb->PairCount < (Mcb->MaximumPairCount / 4)) &&
            (Mcb->MaximumPairCount > INITIAL_MAXIMUM_PAIR_COUNT)) {

            ULONG NewMax;
            PMAPPING Mapping;

            //
            //  We need to allocate a new mapping so compute a new maximum pair
            //  count.  We'll allocate double the current pair count, but never
            //  less than the initial pair count.
            //

            NewMax = Mcb->PairCount * 2;
            if (NewMax < INITIAL_MAXIMUM_PAIR_COUNT) { NewMax = INITIAL_MAXIMUM_PAIR_COUNT; }

            Mapping = ExAllocatePool( Mcb->PoolType, sizeof(MAPPING) * NewMax );

            //
            //  Now check if we really got a new buffer
            //

            if (Mapping != NULL) {

                //
                //  Now copy over the old mapping to the new buffer
                //

                RtlCopyMemory( Mapping, Mcb->Mapping, sizeof(MAPPING) * Mcb->PairCount );

                //
                //  Deallocate the old buffer
                //

                ExFreePool( Mcb->Mapping );

                //
                //  And set up the new buffer in the Mcb
                //

                Mcb->Mapping = Mapping;
                Mcb->MaximumPairCount = NewMax;
            }
        }

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FsRtlTruncateLargeMcb -> VOID\n", 0 );

    return;
}


BOOLEAN
FsRtlAddLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeLbn,
    IN LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine is used to add a new mapping of VBNs to LBNs to an existing
    Mcb. The information added will map

        Vbn to Lbn,

        Vbn+1 to Lbn+1,...

        Vbn+(SectorCount-1) to Lbn+(SectorCount-1).

    The mapping for the VBNs must not already exist in the Mcb.  If the
    mapping continues a previous run, then this routine will actually coalesce
    them into 1 run.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

    An input Lbn value of zero is illegal (i.e., the Mcb structure will never
    map a Vbn to a zero Lbn value).

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn of the new mapping run to add to the Mcb.

    Lbn - Supplies the starting Lbn of the new mapping run to add to the Mcb.

    SectorCount - Supplies the size of the new mapping run (in sectors).

Return Value:

    BOOLEAN - TRUE if the mapping was added successfully (i.e., the new
        Vbns did not collide with existing Vbns), and FALSE otherwise.  If
        FALSE is returned then the Mcb is not changed.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    LBN64 Lbn = (LargeLbn);
    ULONG SectorCount = ((ULONG)LargeSectorCount);

    ULONG Index;

    VBN LastVbn;

    BOOLEAN Result;

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);
    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeSectorCount)->HighPart == 0);

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlAddLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " Lbn         = %I64x\n", Lbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        if (FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            ULONG EndVbn = Vbn + SectorCount - 1;
            ULONG EndIndex;

            //
            //  First check the case where we are adding to an existing mcb run
            //  and if so then we will modify the insertion to complete the run
            //
            //      --ExistingRun--|      ==becomes==>  --ExistingRun--|
            //              |--NewRun--|                               |---|
            //
            //      --ExistingRun----|    ==becomes==> a noop
            //          |--NewRun--|
            //

            if (StartingLbn(Mcb, Index) != UNUSED_LBN) {

                //
                //  Assert that the Lbn's line up between the new and existing run
                //

                ASSERT(Lbn == (StartingLbn(Mcb, Index) + (Vbn - StartingVbn(Mcb, Index))));

                //
                //  Check if the new run is contained in the existing run
                //

                if (EndVbn <= EndingVbn(Mcb, Index)) {

                    //
                    //  Do nothing because the run is contained within the existing run
                    //

                    try_return(Result = TRUE);
                }

                //
                //  Otherwise we will simply trim off the request for the new run
                //  to not overlap with the existing run
                //

                Vbn = NextStartingVbn(Mcb, Index);
                Lbn = EndingLbn(Mcb, Index) + 1;

                ASSERT(EndVbn >= Vbn);

                SectorCount = EndVbn - Vbn + 1;

            //
            //  At this point the new run start in a hole, now check that if
            //  crosses into a non hole and if so then adjust new run to fit
            //  in the hole
            //
            //
            //            |--ExistingRun--  ==becomes==>        |--ExistingRun--
            //      |--NewRun--|                          |--New|
            //

            } else if (FsRtlFindLargeIndex(Mcb, EndVbn, &EndIndex) && (Index == (EndIndex-1))) {

                //
                //  Assert that the Lbn's line up in the overlap
                //

                ASSERT( StartingLbn(Mcb, EndIndex) == Lbn + (StartingVbn(Mcb, EndIndex) - Vbn) );

                //
                //  Truncate the sector count to go up to but not include
                //  the existing run
                //

                SectorCount = StartingVbn(Mcb, EndIndex) - Vbn;
            }
        }

        //
        //  Find the index for the starting Vbn of our new run, if there isn't
        //  a hole found then index will be set to paircount.
        //

        if (((Index = Mcb->PairCount) == 0) ||
            (PreviousEndingVbn(Mcb,Index)+1 <= Vbn) ||
            !FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            //
            //  We didn't find a mapping, therefore this new mapping must
            //  go on at the end of the current mapping.
            //
            //  See if we can just grow the last mapping in the current mcb.
            //  We can grow the last entry if (1) the Vbns follow on, and (2)
            //  the Lbns follow on.  We can only grow the last mapping if the
            //  index is not 0.
            //

            if ((Index != 0) &&
                (PreviousEndingVbn(Mcb,Index) + 1 == Vbn) &&
                (PreviousEndingLbn(Mcb,Index) + 1 == Lbn)) {

                //
                //      --LastRun--|---NewRun--|
                //

                //
                //  Extend the last run in the mcb
                //

                DebugTrace( 0, Dbg, "Continuing last run\n", 0);

                (Mcb->Mapping)[Mcb->PairCount-1].NextVbn += SectorCount;

                try_return (Result = TRUE);
            }

            //
            //  We couldn't grow the last mapping, now check to see if
            //  this is a continuation of the last Vbn (i.e., there isn't
            //  going to be a hole in the mapping).  Or if this is the first
            //  run in the mapping
            //

            if ((Vbn == 0) ||
                (PreviousEndingVbn(Mcb,Index) + 1 == Vbn)) {

                //
                //      --LastRun--||---NewRun--|
                //
                //      0:|--NewRun--|
                //

                //
                //  We only need to add one more run to the mcb, so make sure
                //  there is enough room for one.
                //

                DebugTrace( 0, Dbg, "Adding new contiguous last run\n", 0);

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Add the new mapping
                //

                (Mcb->Mapping)[Index].Lbn = Lbn;
                (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                try_return (Result = TRUE);
            }

            //
            //  If we reach this point then there is going to be a hole in the
            //  mapping. and the mapping gets appended to the end of the current
            //  allocation.  So need to make room for two more runs in the mcb.
            //

            //
            //      --LastRun--|   hole   |---NewRun--|
            //
            //      0:  hole  |--NewRun--|
            //

            DebugTrace( 0, Dbg, "Adding new noncontiguous last run\n", 0);

            FsRtlAddLargeEntry( Mcb, Index, 2 );

            //
            //  Add the hole
            //

            (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
            (Mcb->Mapping)[Index].NextVbn = Vbn;

            //
            //  Add the new mapping
            //

            (Mcb->Mapping)[Index+1].Lbn = Lbn;
            (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

            try_return (Result = TRUE);
        }

        //
        //  We found an index for the Vbn therefore we must be trying
        //  to fill up a hole in the mcb.  So first we need to check to make
        //  sure there really is a hole to be filled
        //

        LastVbn = Vbn + SectorCount - 1;

        if ((StartingLbn(Mcb,Index) == UNUSED_LBN) &&
            (StartingVbn(Mcb,Index) <= Vbn) && (LastVbn <= EndingVbn(Mcb,Index))) {

            //
            //  The mapping fits in this hole, but now here are the following
            //  cases we must consider for the new mapping
            //

            if ((StartingVbn(Mcb,Index) < Vbn) && (LastVbn < EndingVbn(Mcb,Index))) {

                //  Leaves a hole are both ends
                //
                //  --PreviousRun--|  hole  |--NewRun--|  hole  |--FollowingRun--
                //
                //  0:  hole  |--NewRun--|  hole  |--FollowingRun--
                //

                DebugTrace( 0, Dbg, "Hole at both ends\n", 0);

                //
                //  Make room for two more entries.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 2 );

                //
                //  Add the first hole
                //

                (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
                (Mcb->Mapping)[Index].NextVbn = Vbn;

                //
                //  Add the new mapping
                //

                (Mcb->Mapping)[Index+1].Lbn = Lbn;
                (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

                //
                //  The second hole is already set up by the add entry call, because
                //  that call just shift over the original hole to that slot
                //

                try_return (Result = TRUE);
            }

            if ((StartingVbn(Mcb,Index) == Vbn) && (LastVbn < EndingVbn(Mcb,Index))) {

                if (PreviousEndingLbn(Mcb,Index) + 1 == Lbn) {

                    //
                    //  Leaves a hole at the rear, and continues the earlier run
                    //
                    //  --PreviousRun--|--NewRun--|  hole  |--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at rear and continue\n", 0);

                    //
                    //  We just need to extend the previous run
                    //

                    (Mcb->Mapping)[Index-1].NextVbn += SectorCount;

                    try_return (Result = TRUE);

                } else {

                    //
                    //  Leaves a hole at the rear, and does not continue the
                    //  earlier run.  As occurs if index is zero.
                    //
                    //  --PreviousRun--||--NewRun--|  hole  |--FollowingRun--
                    //
                    //  0:|--NewRun--|  hole  |--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at rear and not continue\n", 0);

                    //
                    //  Make room for one more entry.  The NextVbn field of the
                    //  one we're shifting remains valid.
                    //

                    FsRtlAddLargeEntry( Mcb, Index, 1 );

                    //
                    //  Add the new mapping
                    //

                    (Mcb->Mapping)[Index].Lbn = Lbn;
                    (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                    //
                    //  The hole is already set up by the add entry call, because
                    //  that call just shift over the original hole to that slot
                    //

                    try_return (Result = TRUE);
                }
            }

            if ((StartingVbn(Mcb,Index) < Vbn) && (LastVbn == EndingVbn(Mcb,Index))) {

                if (NextStartingLbn(Mcb,Index) == Lbn + SectorCount) {

                    //
                    //  Leaves a hole at the front, and continues the following run
                    //
                    //  --PreviousRun--|  hole  |--NewRun--|--FollowingRun--
                    //
                    //  0:  hole  |--NewRun--|--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at front and continue\n", 0);

                    //
                    //  We just need to extend the following run
                    //

                    (Mcb->Mapping)[Index].NextVbn = Vbn;
                    (Mcb->Mapping)[Index+1].Lbn = Lbn;

                    try_return (Result = TRUE);

                } else {

                    //
                    //  Leaves a hole at the front, and does not continue the following
                    //  run
                    //
                    //  --PreviousRun--|  hole  |--NewRun--||--FollowingRun--
                    //
                    //  0:  hole  |--NewRun--||--FollowingRun--
                    //

                    DebugTrace( 0, Dbg, "Hole at front and not continue\n", 0);

                    //
                    //  Make room for one more entry.  The NextVbn field of the
                    //  one we're shifting remains valid.
                    //

                    FsRtlAddLargeEntry( Mcb, Index, 1 );

                    //
                    //  Add the hole
                    //

                    (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
                    (Mcb->Mapping)[Index].NextVbn = Vbn;

                    //
                    //  Add the new mapping
                    //

                    (Mcb->Mapping)[Index+1].Lbn = Lbn;

                    try_return (Result = TRUE);
                }

            }

            if ((PreviousEndingLbn(Mcb,Index) + 1 == Lbn) &&
                (NextStartingLbn(Mcb,Index) == Lbn + SectorCount)) {

                //
                //  Leaves no holes, and continues both runs
                //
                //  --PreviousRun--|--NewRun--|--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues both runs\n", 0);

                //
                //  We need to collapse the current index and the following index
                //  but first we copy the NextVbn of the follwing run into
                //  the NextVbn field of the previous run to so it all becomes
                //  one run
                //

                (Mcb->Mapping)[Index-1].NextVbn = (Mcb->Mapping)[Index+1].NextVbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 2 );

                try_return (Result = TRUE);
            }

            if (NextStartingLbn(Mcb,Index) == Lbn + SectorCount) {

                //
                //  Leaves no holes, and continues only following run
                //
                //  --PreviousRun--||--NewRun--|--FollowingRun--
                //
                //  0:|--NewRun--|--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues following\n", 0);

                //
                //  This index is going away so we need to stretch the
                //  following run to meet up with the previous run
                //

                (Mcb->Mapping)[Index+1].Lbn = Lbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

                try_return (Result = TRUE);
            }

            if (PreviousEndingLbn(Mcb,Index) + 1 == Lbn) {

                //
                //  Leaves no holes, and continues only earlier run
                //
                //  --PreviousRun--|--NewRun--||--FollowingRun--
                //

                DebugTrace( 0, Dbg, "No holes, and continues earlier\n", 0);

                //
                //  This index is going away so we need to stretch the
                //  previous run to meet up with the following run
                //

                (Mcb->Mapping)[Index-1].NextVbn = (Mcb->Mapping)[Index].NextVbn;

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

                try_return (Result = TRUE);
            }

            //
            //  Leaves no holes, and continues neither run
            //
            //      --PreviousRun--||--NewRun--||--FollowingRun--
            //
            //      0:|--NewRun--||--FollowingRun--
            //

            DebugTrace( 0, Dbg, "No holes, and continues none\n", 0);

            (Mcb->Mapping)[Index].Lbn = Lbn;

            try_return (Result = TRUE);
        }

        //
        //  We tried to overwrite an existing mapping so we'll have to
        //  tell our caller that it's not possible
        //

        Result = FALSE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlAddLargeMcbEntry -> %08lx\n", Result );
    }

    return Result;
}


VOID
FsRtlRemoveLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine removes a mapping of VBNs to LBNs from an Mcb.  The mappings
    removed are for

        Vbn,

        Vbn+1, to

        Vbn+(SectorCount-1).

    The operation works even if the mapping for a Vbn in the specified range
    does not already exist in the Mcb.  If the specified range of Vbn includes
    the last mapped Vbn in the Mcb then the Mcb mapping shrinks accordingly.

    If pool is not available to store the information this routine will raise
    a status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb from which to remove the mapping.

    Vbn - Supplies the starting Vbn of the mappings to remove.

    SectorCount - Supplies the size of the mappings to remove (in sectors).

Return Value:

    None.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    ULONG SectorCount = ((ULONG)LargeSectorCount);

    PAGED_CODE();

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);

    DebugTrace(+1, Dbg, "FsRtlRemoveLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn         = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " SectorCount = %08lx\n", SectorCount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        FsRtlRemoveMcbEntryPrivate( Mcb, Vbn, SectorCount );

    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlRemoveLargeMcbEntry -> VOID\n", 0 );
    }

    return;
}


BOOLEAN
FsRtlLookupLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn OPTIONAL,
    OUT PLONGLONG LargeSectorCount OPTIONAL,
    OUT PLONGLONG LargeStartingLbn OPTIONAL,
    OUT PLONGLONG LargeCountFromStartingLbn OPTIONAL,
    OUT PULONG Index OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the mapping of a Vbn to an Lbn from an Mcb.
    It indicates if the mapping exists and the size of the run.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Supplies the Vbn to lookup.

    Lbn - Receives the Lbn corresponding to the Vbn.  A value of -1 is
        returned if the Vbn does not have a corresponding Lbn.

    SectorCount - Receives the number of sectors that map from the Vbn to
        contiguous Lbn values beginning with the input Vbn.

    Index - Receives the index of the run found.

Return Value:

    BOOLEAN - TRUE if the Vbn is within the range of VBNs mapped by the
        MCB (even if it corresponds to a hole in the mapping), and FALSE
        if the Vbn is beyond the range of the MCB's mapping.

        For example, if an MCB has a mapping for VBNs 5 and 7 but not for
        6, then a lookup on Vbn 5 or 7 will yield a non zero Lbn and a sector
        count of 1.  A lookup for Vbn 6 will return TRUE with an Lbn value of
        0, and lookup for Vbn 8 or above will return FALSE.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    ULONG LocalIndex;

    ASSERTMSG("LargeInteger not supported yet ", ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0) ||
                                                 ((((PLARGE_INTEGER)&LargeVbn)->HighPart == 0x7FFFFFFF) &&
                                                  (((ULONG)LargeVbn) == 0xFFFFFFFF))));

    DebugTrace(+1, Dbg, "FsRtlLookupLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, "  LargeVbn.LowPart = %08lx\n", LargeVbn.LowPart );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        if (!FsRtlFindLargeIndex(Mcb, ((ULONG)LargeVbn), &LocalIndex)) {

            try_return (Result = FALSE);
        }

        //
        //  Compute the lbn for corresponding to the vbn, the value is the
        //  starting lbn of the run plus the number of sectors offset into the
        //  run.  But if it's a hole then the sector Lbn is zero.
        //

        if (ARGUMENT_PRESENT(LargeLbn)) {

            if (StartingLbn(Mcb,LocalIndex) == UNUSED_LBN) {

                *(LargeLbn) = UNUSED_LBN;

            } else {

                *(LargeLbn) = StartingLbn(Mcb,LocalIndex) + (((ULONG)LargeVbn) - StartingVbn(Mcb,LocalIndex));
            }
        }

        //
        //  If there sector count argument is present then we'll return the number
        //  of sectors remaing in the run.
        //

        if (ARGUMENT_PRESENT(LargeSectorCount)) {

            *((PULONG)LargeSectorCount) = EndingVbn(Mcb,LocalIndex) - ((ULONG)LargeVbn) + 1;
        }

        //
        //  Compute the starting lbn for corresponding to the start of the run, the value is the
        //  starting lbn of the run.  But if it's a hole then the sector Lbn is zero.
        //

        if (ARGUMENT_PRESENT(LargeStartingLbn)) {

            if (StartingLbn(Mcb,LocalIndex) == UNUSED_LBN) {

                *(LargeStartingLbn) = UNUSED_LBN;

            } else {

                *(LargeStartingLbn) = StartingLbn(Mcb,LocalIndex);
            }
        }

        //
        //  If there sector count argument is present then we'll return the number
        //  of sectors in the run.
        //

        if (ARGUMENT_PRESENT(LargeCountFromStartingLbn)) {

            *((PULONG)LargeCountFromStartingLbn) = EndingVbn(Mcb,LocalIndex) - StartingVbn(Mcb,LocalIndex) + 1;
        }

        //
        //  If the caller want to know the Index number, fill it in.
        //

        if (ARGUMENT_PRESENT(Index)) {

            *Index = LocalIndex;
        }

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlLookupLargeMcbEntry -> %08lx\n", Result );
    }

    if (ARGUMENT_PRESENT(LargeSectorCount)) {
        ((PLARGE_INTEGER)LargeSectorCount)->HighPart = 0;
    }

    if (ARGUMENT_PRESENT(LargeCountFromStartingLbn)) {
        ((PLARGE_INTEGER)LargeCountFromStartingLbn)->HighPart = 0;
    }

    return Result;
}


BOOLEAN
FsRtlLookupLastLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    OUT PLONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn
    )

/*++

Routine Description:

    This routine retrieves the last Vbn to Lbn mapping stored in the Mcb.
    It returns the mapping for the last sector or the last run in the
    Mcb.  The results of this function is useful when extending an existing
    file and needing to a hint on where to try and allocate sectors on the
    disk.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    Vbn - Receives the last Vbn value mapped.

    Lbn - Receives the Lbn corresponding to the Vbn.

Return Value:

    BOOLEAN - TRUE if there is a mapping within the Mcb and FALSE otherwise
        (i.e., the Mcb does not contain any mapping).

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlLookupLastLargeMcbEntry, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Check to make sure there is at least one run in the mcb
        //

        if (Mcb->PairCount <= 0) {

            try_return (Result = FALSE);
        }

        //
        //  Return the last mapping of the last run
        //

        *(LargeLbn) = EndingLbn(Mcb,Mcb->PairCount-1);
        *((PULONG)LargeVbn) = EndingVbn(Mcb,Mcb->PairCount-1);

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlLookupLastLargeMcbEntry -> %08lx\n", Result );
    }

    ((PLARGE_INTEGER)LargeVbn)->HighPart = (*((PULONG)LargeVbn) == 0xffffffff ? 0xffffffff : 0);

    return Result;
}


ULONG
FsRtlNumberOfRunsInLargeMcb (
    IN PLARGE_MCB OpaqueMcb
    )

/*++

Routine Description:

    This routine returns to the its caller the number of distinct runs
    mapped by an Mcb.  Holes (i.e., Vbns that map to Lbn=UNUSED_LBN) are counted
    as runs.  For example, an Mcb containing a mapping for only Vbns 0 and 3
    will have 3 runs, one for the first mapped sector, a second for the
    hole covering Vbns 1 and 2, and a third for Vbn 3.

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

Return Value:

    ULONG - Returns the number of distinct runs mapped by the input Mcb.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    ULONG Count;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlNumberOfRunsInLargeMcb, Mcb = %08lx\n", Mcb );

    ExAcquireFastMutex( Mcb->FastMutex );

    Count = Mcb->PairCount;

    ExReleaseFastMutex( Mcb->FastMutex );

    DebugTrace(-1, Dbg, "FsRtlNumberOfRunsInLargeMcb -> %08lx\n", Count );

    return Count;
}


BOOLEAN
FsRtlGetNextLargeMcbEntry (
    IN PLARGE_MCB OpaqueMcb,
    IN ULONG RunIndex,
    OUT PLONGLONG LargeVbn,
    OUT PLONGLONG LargeLbn,
    OUT PLONGLONG LargeSectorCount
    )

/*++

Routine Description:

    This routine returns to its caller the Vbn, Lbn, and SectorCount for
    distinct runs mapped by an Mcb.  Holes are counted as runs.  For example,
    to construct to print out all of the runs in a a file is:

//. .   for (i = 0; FsRtlGetNextLargeMcbEntry(Mcb,i,&Vbn,&Lbn,&Count); i++) {
//
//. .       // print out vbn, lbn, and count
//
//. .       }

Arguments:

    OpaqueMcb - Supplies the Mcb being examined.

    RunIndex - Supplies the index of the run (zero based) to return to the
        caller.

    Vbn - Receives the starting Vbn of the returned run, or zero if the
        run does not exist.

    Lbn - Recieves the starting Lbn of the returned run, or zero if the
        run does not exist.

    SectorCount - Receives the number of sectors within the returned run,
        or zero if the run does not exist.

Return Value:

    BOOLEAN - TRUE if the specified run (i.e., RunIndex) exists in the Mcb,
        and FALSE otherwise.  If FALSE is returned then the Vbn, Lbn, and
        SectorCount parameters receive zero.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    BOOLEAN Result;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlGetNextLargeMcbEntry, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " RunIndex = %08lx\n", RunIndex );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  Make sure the run index is within range
        //

        if (RunIndex >= Mcb->PairCount) {

            try_return (Result = FALSE);
        }

        //
        //  Set the return variables
        //

        *((PULONG)LargeVbn) = StartingVbn(Mcb,RunIndex);
        *(LargeLbn) = StartingLbn(Mcb,RunIndex);
        *((PULONG)LargeSectorCount) = SectorsWithinRun(Mcb,RunIndex);

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlGetNextLargeMcbEntry -> %08lx\n", Result );
    }

    ((PLARGE_INTEGER)LargeVbn)->HighPart = (*((PULONG)LargeVbn) == 0xffffffff ? 0xffffffff : 0);
    ((PLARGE_INTEGER)LargeSectorCount)->HighPart = 0;

    return Result;
}


BOOLEAN
FsRtlSplitLargeMcb (
    IN PLARGE_MCB OpaqueMcb,
    IN LONGLONG LargeVbn,
    IN LONGLONG LargeAmount
    )

/*++

Routine Description:

    This routine is used to create a hole within an MCB, by shifting the
    mapping of Vbns.  All mappings above the input vbn are shifted by the
    amount specified and while keeping their current lbn value.  Pictorially
    we have as input the following MCB

        VBN :       LargeVbn-1 LargeVbn         N
            +-----------------+------------------+
        LBN :             X        Y

    And after the split we have

        VBN :       LargeVbn-1               LargeVbn+Amount    N+Amount
            +-----------------+.............+---------------------------+
        LBN :             X      UnusedLbn       Y

    When doing the split we have a few cases to consider.  They are:

    1. The input Vbn is beyond the last run.  In this case this operation
       is a noop.

    2. The input Vbn is within or adjacent to a existing run of unused Lbns.
       In this case we simply need to extend the size of the existing hole
       and shift succeeding runs.

    3. The input Vbn is between two existing runs, including the an input vbn
       value of zero.  In this case we need to add a new entry for the hole
       and shift succeeding runs.

    4. The input Vbn is within an existing run.  In this case we need to add
       two new entries to contain the split run and the hole.

    If pool is not available to store the information this routine will raise a
    status value indicating insufficient resources.

Arguments:

    OpaqueMcb - Supplies the Mcb in which to add the new mapping.

    Vbn - Supplies the starting Vbn that is to be shifted.

    Amount - Supplies the amount to shift by.

Return Value:

    BOOLEAN - TRUE if the mapping was successfully shifted, and FALSE otherwise.
        If FALSE is returned then the Mcb is not changed.

--*/

{
    PNONOPAQUE_MCB Mcb = (PNONOPAQUE_MCB)OpaqueMcb;

    VBN Vbn = ((ULONG)LargeVbn);
    ULONG Amount = ((ULONG)LargeAmount);

    ULONG Index;

    BOOLEAN Result;

    ULONG i;

    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeVbn)->HighPart == 0);
    ASSERTMSG("LargeInteger not supported yet ", ((PLARGE_INTEGER)&LargeAmount)->HighPart == 0);

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FsRtlSplitLargeMcb, Mcb = %08lx\n", Mcb );
    DebugTrace( 0, Dbg, " Vbn    = %08lx\n", Vbn );
    DebugTrace( 0, Dbg, " Amount = %08lx\n", Amount );

    ExAcquireFastMutex( Mcb->FastMutex );

    try {

        //
        //  First lookup the index for the entry that we are going to split.
        //  If we can't find the entry then there is nothing to split.  This
        //  takes care of the case where the input vbn is beyond the last run
        //  in the mcb
        //

        if (!FsRtlFindLargeIndex( Mcb, Vbn, &Index)) {

            try_return(Result = FALSE);
        }

        //
        //  Now check if the input Vbn is within a hole
        //

        if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

            //
            //  Before: --PreviousRun--||--IndexHole--||--FollowingRun--
            //  After:  --PreviousRun--||----IndexHole----||--FollowingRun--
            //
            //      In this case the vbn is somewhere within the hole and we
            //      simply need to added the amount of each existing run
            //      beyond the hole.
            //

            //
            //  In this case there is really nothing to do here because the
            //  ending code will already shift the runs by proper amount
            //  starting at index
            //

            NOTHING;

        //
        //  Now check if the input vbn is between a hole and an existing run.
        //

        } else if ((StartingVbn(Mcb,Index) == Vbn) && (Index != 0) && (PreviousEndingLbn(Mcb,Index) == UNUSED_LBN)) {

            //
            //  Before: --Hole--||--IndexRun--
            //  After:  --Hole------||--IndexRun--
            //
            //      In this case the vbn points to the start of the existing
            //      run and we need to do the split between the hole and the
            //      existing run by simply adding the amount to each existing
            //      run beyond the hole.
            //

            //
            //  In this case we need to decement the index by 1 and then
            //  fall to the bottom code which will do the shifting for us
            //

            Index -= 1;

        //
        //  Now check if the input vbn is between two existing runs
        //

        } else if (StartingVbn(Mcb,Index) == Vbn) {

            //
            //  Before: --PreviousRun--||--IndexRun--
            //  After:  --PreviousRun--||--NewHole--||--IndexRun--
            //
            //  Before: 0:|--IndexRun--
            //  After:  0:|--NewHole--||--IndexRun--
            //
            //      In this case the vbn points to the start of an existing
            //      run and the preceeding is either a real run or the start
            //      of mapping pairs We simply add a new entry for the hole
            //      and shift succeeding runs.
            //

            FsRtlAddLargeEntry( Mcb, Index, 1 );

            (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
            (Mcb->Mapping)[Index].NextVbn = Vbn + Amount;

            Index += 1;

        //
        //  Otherwise the input vbn is inside an existing run
        //

        } else {

            //
            //  Before: --IndexRun--
            //  After:  --SplitRun--||--NewHole--||--SplitRun--
            //
            //      In this case the vbn points within an existing run
            //      we need to add two new extries for hole and split
            //      run and shift succeeding runs
            //

            FsRtlAddLargeEntry( Mcb, Index, 2 );

            (Mcb->Mapping)[Index].Lbn = (Mcb->Mapping)[Index+2].Lbn;
            (Mcb->Mapping)[Index].NextVbn = Vbn;

            (Mcb->Mapping)[Index+1].Lbn = UNUSED_LBN;
            (Mcb->Mapping)[Index+1].NextVbn = Vbn + Amount;

            (Mcb->Mapping)[Index+2].Lbn = (Mcb->Mapping)[Index+2].Lbn +
                                          StartingVbn(Mcb, Index+1) -
                                          StartingVbn(Mcb, Index);

            Index += 2;

        }

        //
        //  At this point we have completed most of the work we now need to
        //  shift existing runs from the index to the end of the mappings
        //  by the specified amount
        //

        for (i = Index; i < Mcb->PairCount; i += 1) {

            (Mcb->Mapping)[i].NextVbn += Amount;
        }

        Result = TRUE;

    try_exit: NOTHING;
    } finally {

        ExReleaseFastMutex( Mcb->FastMutex );

        DebugTrace(-1, Dbg, "FsRtlSplitLargeMcb -> %08lx\n", Result );
    }

    return Result;
}


//
//  Private support routine
//

VOID
FsRtlRemoveMcbEntryPrivate (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG Vbn,
    IN ULONG SectorCount
    )

/*++

Routine Description:

    This is the work routine for remove large mcb entry.  It does the work
    without taking out the mcb FastMutex.

Arguments:

    Mcb - Supplies the Mcb from which to remove the mapping.

    Vbn - Supplies the starting Vbn of the mappings to remove.

    SectorCount - Supplies the size of the mappings to remove (in sectors).

Return Value:

    None.

--*/

{
    ULONG Index;

    PAGED_CODE();

    //
    //  Do a quick test to see if we are wiping out the entire MCB.
    //

    if ((Vbn == 0) && (Mcb->PairCount > 0) && (SectorCount >= Mcb->Mapping[Mcb->PairCount-1].NextVbn)) {

        Mcb->PairCount = 0;

        return;
    }

    //
    //  While there is some more mapping to remove we'll continue
    //  with our main loop
    //

    while (SectorCount > 0) {

        //
        //  Locate the mapping for the vbn
        //

        if (!FsRtlFindLargeIndex(Mcb, Vbn, &Index)) {

            DebugTrace( 0, Dbg, "FsRtlRemoveLargeMcbEntry, Cannot remove an unmapped Vbn = %08lx\n", Vbn );

            return;
        }

        //
        //  Now that we some something to remove the following cases must
        //  be considered
        //

        if ((StartingVbn(Mcb,Index) == Vbn) &&
            (EndingVbn(Mcb,Index) < Vbn + SectorCount)) {

            ULONG i;

            //
            //  Removes the entire run
            //

            //
            //  Update the amount to remove
            //

            i = SectorsWithinRun(Mcb,Index);
            Vbn += i;
            SectorCount -= i;

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            //
            //  Test for last run
            //

            } else if (Index == Mcb->PairCount - 1) {

                if ((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) ||
                    (Index == 0)) {

                    //
                    //  Previous is not hole, index is last run
                    //
                    //  --Previous--|  Hole
                    //
                    //  0:  Hole
                    //

                    DebugTrace( 0, Dbg, "Entire run, Previous not hole, index is last run\n", 0);

                    //
                    //  Just remove this entry
                    //

                    FsRtlRemoveLargeEntry( Mcb, Index, 1);

                } else {

                    //
                    //  Previous is hole, index is last run
                    //
                    //  --Hole--|  Hole
                    //

                    DebugTrace( 0, Dbg, "Entire run, Previous hole, index is last run\n", 0);

                    //
                    //  Just remove this entry, and preceding entry
                    //

                    FsRtlRemoveLargeEntry( Mcb, Index-1, 2);
                }

            } else if (((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) &&
                       (NextStartingLbn(Mcb,Index) != UNUSED_LBN)) {

                //
                //  Previous and following are not holes
                //
                //  --Previous--|  Hole  |--Following--
                //
                //  0:  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous & Following not holes\n", 0);

                //
                //  Make this index a hole
                //

                (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;

            } else if (((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) &&
                       (NextStartingLbn(Mcb,Index) == UNUSED_LBN)) {

                //
                //  Following is hole
                //
                //  --Previous--|  Hole  |--Hole--
                //
                //  0:  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "Entire run, Following is hole\n", 0);

                //
                //  Simply remove this entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index, 1 );

            } else if ((PreviousEndingLbn(Mcb,Index) == UNUSED_LBN) &&
                       (NextStartingLbn(Mcb,Index) != UNUSED_LBN)) {

                //
                //  Previous is hole
                //
                //  --Hole--|  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous is hole\n", 0);

                //
                //  Mark current entry a hole
                //

                (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;

                //
                //  Remove previous entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index - 1, 1 );

            } else {

                //
                //  Previous and following are holes
                //
                //  --Hole--|  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "Entire run, Previous & following are holes\n", 0);

                //
                //  Remove previous and this entry
                //

                FsRtlRemoveLargeEntry( Mcb, Index - 1, 2 );
            }

        } else if (StartingVbn(Mcb,Index) == Vbn) {

            //
            //  Removes first part of run
            //

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else if ((PreviousEndingLbn(Mcb,Index) != UNUSED_LBN) || (Index == 0)) {

                //
                //  Previous is not hole
                //
                //  --Previous--|  Hole  |--Index--||--Following--
                //
                //  0:  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "1st part, Previous is not hole\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 1 );

                //
                //  Set the hole
                //

                (Mcb->Mapping)[Index].Lbn = UNUSED_LBN;
                (Mcb->Mapping)[Index].NextVbn = Vbn + SectorCount;

                //
                //  Set the new Lbn for the remaining run
                //

                (Mcb->Mapping)[Index+1].Lbn += SectorCount;

            } else {

                //
                //  Previous is hole
                //
                //  --Hole--|  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "1st part, Previous is hole\n", 0);

                //
                //  Expand the preceding hole
                //

                (Mcb->Mapping)[Index-1].NextVbn += SectorCount;

                //
                //  Set the new Lbn for the remaining run
                //

                (Mcb->Mapping)[Index].Lbn += SectorCount;
            }

            //
            //  Update the amount to remove
            //

            Vbn += SectorCount;
            SectorCount = 0;

        } else if (EndingVbn(Mcb,Index) < Vbn + SectorCount) {

            ULONG AmountToRemove;

            AmountToRemove = EndingVbn(Mcb,Index) - Vbn + 1;

            //
            //  Removes last part of run
            //

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else if (Index == Mcb->PairCount - 1) {

                //
                //  Index is last run
                //
                //  --Previous--||--Index--|  Hole
                //
                //  0:|--Index--|  Hole
                //

                DebugTrace( 0, Dbg, "last part, Index is last run\n", 0);

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;

            } else if (NextStartingLbn(Mcb,Index) == UNUSED_LBN) {

                //
                //  Following is hole
                //
                //  --Previous--||--Index--|  Hole  |--Hole--
                //
                //  0:|--Index--|  Hole  |--Hole--
                //

                DebugTrace( 0, Dbg, "last part, Following is hole\n", 0);

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;

            } else {

                //
                //  Following is not hole
                //
                //  --Previous--||--Index--|  Hole  |--Following--
                //
                //
                //  0:|--Index--|  Hole  |--Following--
                //

                DebugTrace( 0, Dbg, "last part, Following is not hole\n", 0);

                //
                //  Make room for one more entry.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index+1, 1 );

                //
                //  Set the new hole
                //

                (Mcb->Mapping)[Index+1].Lbn = UNUSED_LBN;
                (Mcb->Mapping)[Index+1].NextVbn = (Mcb->Mapping)[Index].NextVbn;

                //
                //  Shrink back the size of the current index
                //

                (Mcb->Mapping)[Index].NextVbn -= AmountToRemove;
            }

            //
            //  Update amount to remove
            //

            Vbn += AmountToRemove;
            SectorCount -= AmountToRemove;

        } else {

            //
            //  If already a hole then leave it alone
            //

            if (StartingLbn(Mcb,Index) == UNUSED_LBN) {

                NOTHING;

            } else {

                //
                //  Remove middle of run
                //
                //  --Previous--||--Index--|  Hole  |--Index--||--Following--
                //
                //  0:|--Index--|  Hole  |--Index--||--Following--
                //

                DebugTrace( 0, Dbg, "Middle of run\n", 0);

                //
                //  Make room for two more entries.  The NextVbn field of the
                //  one we're shifting remains valid.
                //

                FsRtlAddLargeEntry( Mcb, Index, 2 );

                //
                //  Set up the first remaining run
                //

                (Mcb->Mapping)[Index].Lbn = (Mcb->Mapping)[Index+2].Lbn;
                (Mcb->Mapping)[Index].NextVbn = Vbn;

                //
                //  Set up the hole
                //

                (Mcb->Mapping)[Index+1].Lbn = UNUSED_LBN;
                (Mcb->Mapping)[Index+1].NextVbn = Vbn + SectorCount;

                //
                //  Set up the second remaining run
                //

                (Mcb->Mapping)[Index+2].Lbn += SectorsWithinRun(Mcb,Index) +
                                               SectorsWithinRun(Mcb,Index+1);
            }

            //
            //  Update amount to remove
            //

            Vbn += SectorCount;
            SectorCount = 0;
        }
    }

    return;
}


//
//  Private routine
//

BOOLEAN
FsRtlFindLargeIndex (
    IN  PNONOPAQUE_MCB Mcb,
    IN  VBN Vbn,
    OUT PULONG Index
    )

/*++

Routine Description:

    This is a private routine that locates a mapping for a Vbn
    in a given mapping array

Arguments:

    Mcb - Supplies the mapping array to examine

    Vbn - Supplies the Vbn to look up

    Index - Receives the index within the mapping array of the mapping
        containing the Vbn.  If none if found then the index is set to
        PairCount.

Return Value:

    BOOLEAN - TRUE if Vbn is found and FALSE otherwise

--*/

{
    LONG MinIndex;
    LONG MaxIndex;
    LONG MidIndex;

    //
    //  We'll just do a binary search for the mapping entry.  Min and max
    //  are our search boundaries
    //

    MinIndex = 0;
    MaxIndex = Mcb->PairCount - 1;

    while (MinIndex <= MaxIndex) {

        //
        //  Compute the middle index to look at
        //

        MidIndex = ((MaxIndex + MinIndex) / 2);

        //
        //  check if the Vbn is less than the mapping at the mid index
        //

        if (Vbn < StartingVbn(Mcb, MidIndex)) {

            //
            //  Vbn is less than the middle index so we need to drop
            //  the max down
            //

            MaxIndex = MidIndex - 1;

        //
        //  check if the Vbn is greater than the mapping at the mid index
        //

        } else if (Vbn > EndingVbn(Mcb, MidIndex)) {

            //
            //  Vbn is greater than the middle index so we need to bring
            //  up the min
            //

            MinIndex = MidIndex + 1;

        //
        //  Otherwise we've found the index containing the Vbn so set the
        //  index and return TRUE.
        //

        } else {

            *Index = MidIndex;

            return TRUE;
        }
    }

    //
    //  A match wasn't found so set index to PairCount and return FALSE
    //

    *Index = Mcb->PairCount;

    return FALSE;
}


//
//  Private Routine
//

VOID
FsRtlAddLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToAddIndex,
    IN ULONG AmountToAdd
    )

/*++

Routine Description:

    This routine takes a current Mcb and detemines if there is enough
    room to add the new mapping entries.  If there is not enough room
    it reallocates a new mcb buffer and copies over the current mapping.
    If also will spread out the current mappings to leave the specified
    index slots in the mapping unfilled.  For example, if WhereToAddIndex
    is equal to the current pair count then we don't need to make a hole
    in the mapping, but if the index is less than the current pair count
    then we'll need to slide some of the mappings down to make room
    at the specified index.

Arguments:

    Mcb - Supplies the mcb being checked and modified

    WhereToAddIndex - Supplies the index of where the additional entries
        need to be made

    AmountToAdd - Supplies the number of additional entries needed in the
        mcb

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check to see if the current buffer is large enough to hold
    //  the additional entries
    //

    if (Mcb->PairCount + AmountToAdd > Mcb->MaximumPairCount) {

        ULONG NewMax;
        PMAPPING Mapping;

        //
        //  We need to allocate a new mapping so compute a new maximum pair
        //  count.  We'll only be asked to grow by at most 2 at a time, so
        //  doubling will definitely make us large enough for the new amount.
        //  But we won't double without bounds we'll stop doubling if the
        //  pair count gets too high.
        //

        if (Mcb->MaximumPairCount < 2048) {

            NewMax = Mcb->MaximumPairCount * 2;

        } else {

            NewMax = Mcb->MaximumPairCount + 2048;
        }

        Mapping = FsRtlAllocatePool( Mcb->PoolType, sizeof(MAPPING)*NewMax );

        //**** RtlZeroMemory( Mapping, sizeof(MAPPING) * NewMax );

        //
        //  Now copy over the old mapping to the new buffer
        //

        RtlCopyMemory( Mapping, Mcb->Mapping, sizeof(MAPPING) * Mcb->PairCount );

        //
        //  Deallocate the old buffer
        //

        if ((Mcb->PoolType == PagedPool) && (Mcb->MaximumPairCount == INITIAL_MAXIMUM_PAIR_COUNT)) {

            { PVOID t = Mcb->Mapping; FsRtlFreeFirstMapping( t ); }

        } else {

            ExFreePool( Mcb->Mapping );
        }

        //
        //  And set up the new buffer in the Mcb
        //

        Mcb->Mapping = Mapping;
        Mcb->MaximumPairCount = NewMax;
    }

    //
    //  Now see if we need to shift some entries over according to the
    //  WhereToAddIndex value
    //

    if (WhereToAddIndex < Mcb->PairCount) {

        RtlMoveMemory( &((Mcb->Mapping)[WhereToAddIndex + AmountToAdd]),
                      &((Mcb->Mapping)[WhereToAddIndex]),
                      (Mcb->PairCount - WhereToAddIndex) * sizeof(MAPPING) );
    }

    //
    //  Now zero out the new additions
    //

    //**** RtlZeroMemory( &((Mcb->Mapping)[WhereToAddIndex]), sizeof(MAPPING) * AmountToAdd );

    //
    //  Now increment the PairCount
    //

    Mcb->PairCount += AmountToAdd;

    //
    //  And return to our caller
    //

    return;
}


//
//  Private Routine
//

VOID
FsRtlRemoveLargeEntry (
    IN PNONOPAQUE_MCB Mcb,
    IN ULONG WhereToRemoveIndex,
    IN ULONG AmountToRemove
    )

/*++

Routine Description:

    This routine takes a current Mcb and removes one or more entries.

Arguments:

    Mcb - Supplies the mcb being checked and modified

    WhereToRemoveIndex - Supplies the index of the entries to remove

    AmountToRemove - Supplies the number of entries to remove

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Check to see if we need to shift everything down because the
    //  entries to remove do not include the last entry in the mcb
    //

    if (WhereToRemoveIndex + AmountToRemove < Mcb->PairCount) {

        RtlMoveMemory( &((Mcb->Mapping)[WhereToRemoveIndex]),
                      &((Mcb->Mapping)[WhereToRemoveIndex + AmountToRemove]),
                      (Mcb->PairCount - (WhereToRemoveIndex + AmountToRemove))
                                                           * sizeof(MAPPING) );
    }

    //
    //  Now zero out the entries beyond the part we just shifted down
    //

    //**** RtlZeroMemory( &((Mcb->Mapping)[Mcb->PairCount - AmountToRemove]), AmountToRemove * sizeof(MAPPING) );

    //
    //  Now decrement the PairCount
    //

    Mcb->PairCount -= AmountToRemove;

    //
    //  And return to our caller
    //

    return;
}


//
//  Private Routine
//

PVOID
FsRtlAllocateFirstMapping(
    )

/*++

Routine Description:

    This routine will if possible allocate the first mapping from either
    a zone, a recent deallocated mapping, or pool.

Arguments:

Return Value:

    The mapping.

--*/

{
    KIRQL _SavedIrql;
    PVOID Mapping;

    ExAcquireSpinLock( &FsRtlStrucSupSpinLock, &_SavedIrql );

    FsRtlNetFirstMapping += 1;

    if (FsRtlFreeFirstMappingSize > 0) {
        Mapping = FsRtlFreeFirstMappingArray[--FsRtlFreeFirstMappingSize];
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
    } else {
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
        Mapping = FsRtlAllocatePool( PagedPool, sizeof(MAPPING) * INITIAL_MAXIMUM_PAIR_COUNT );
    }

    return Mapping;
}


//
//  Private Routine
//

VOID
FsRtlFreeFirstMapping(
    IN PVOID Mapping
    )

/*++

Routine Description:

    This routine will if possible allocate the first mapping from either
    a zone, a recent deallocated mapping, or pool.

Arguments:

    Mapping - The mapping to either free to zone, put on the recent
        deallocated list or free to pool.

Return Value:

    The mapping.

--*/

{
    KIRQL _SavedIrql;

    ExAcquireSpinLock( &FsRtlStrucSupSpinLock, &_SavedIrql );

    FsRtlNetFirstMapping -= 1;

    if (FsRtlFreeFirstMappingSize < FREE_FIRST_MAPPING_ARRAY_SIZE) {
        FsRtlFreeFirstMappingArray[FsRtlFreeFirstMappingSize++] = Mapping;
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
    } else {
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
        ExFreePool( Mapping );
    }
}


//
//  Private Routine
//

PFAST_MUTEX
FsRtlAllocateFastMutex(
    )

/*++

Routine Description:

    This routine will if possible allocate the FastMutex from either
    a zone, a recent deallocated FastMutex, or pool.

Arguments:

Return Value:

    The FastMutex.

--*/

{
    KIRQL _SavedIrql;
    PFAST_MUTEX FastMutex;

    ExAcquireSpinLock( &FsRtlStrucSupSpinLock, &_SavedIrql );

    FsRtlNetFastMutex += 1;

    if (!ExIsFullZone(&FsRtlFastMutexZone)) {
        FastMutex = ExAllocateFromZone(&FsRtlFastMutexZone);
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );

    } else if (FsRtlFreeFastMutexSize > 0) {
        FastMutex = FsRtlFreeFastMutexArray[--FsRtlFreeFastMutexSize];
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );

    } else {
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
        FastMutex = FsRtlAllocatePool( NonPagedPool, sizeof(FAST_MUTEX) );
    }

    return FastMutex;
}


//
//  Private Routine
//

VOID
FsRtlFreeFastMutex (
    IN PFAST_MUTEX FastMutex
    )

/*++

Routine Description:

    This routine will if possible allocate the FastMutex from either
    a zone, a recent deallocated FastMutexs, or pool.

Arguments:

    Mapping - The FastMutex to either free to zone, put on the recent
        deallocated list or free to pool.

Return Value:

    The mapping.

--*/

{
    KIRQL _SavedIrql;

    ExAcquireSpinLock( &FsRtlStrucSupSpinLock, &_SavedIrql );

    FsRtlNetFastMutex -= 1;

    if (ExIsObjectInFirstZoneSegment(&FsRtlFastMutexZone, FastMutex)) {
        ExFreeToZone(&FsRtlFastMutexZone, FastMutex);
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );

    } else if (FsRtlFreeFastMutexSize < FREE_FAST_MUTEX_ARRAY_SIZE) {
        FsRtlFreeFastMutexArray[FsRtlFreeFastMutexSize++] = FastMutex;
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );

    } else {
        ExReleaseSpinLock( &FsRtlStrucSupSpinLock, _SavedIrql );
        ExFreePool( FastMutex );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\indxtree.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    indxtree.cxx

Abstract:

    This module contains the member function definitions for the
    NTFS_INDEX_TREE class, which models index trees on an NTFS
    volume.

    An NTFS Index Tree consists of an index root and a set of
    index buffers.  The index root is stored as the value of
    an INDEX_ROOT attribute; the index buffers are part of the
    value of an INDEX_ALLOCATION attribute.

Author:

    Bill McJohn (billmc) 19-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"

#include "attrib.hxx"
#include "frs.hxx"
#include "indxtree.hxx"
#include "indxbuff.hxx"
#include "indxroot.hxx"
#include "ntfsbit.hxx"
#include "upcase.hxx"
#include "message.hxx"
#include "rtmsg.h"

CONST USHORT IndexEntryAttributeLength[] = { 4, 8, 12, 16 };

LONG
CompareNtfsFileNames(
    IN PCFILE_NAME          Name1,
    IN PCFILE_NAME          Name2,
    IN PNTFS_UPCASE_TABLE   UpcaseTable
    )
/*++

Routine Description:

    This method compares two FILE_NAME structures according to the
    COLLATION_FILE_NAME collation rule.

Arguments:

    Name1       --  Supplies the first name to compare.
    Name2       --  Supplies the second name to compare.
    UpcaseTable --  Supplies the volume upcase table.

Returns:

    <0 if Name1 is less than Name2
    =0 if Name1 is equal to Name2
    >0 if Name1 is greater than Name2.

--*/
{
    LONG Result;

    Result = NtfsUpcaseCompare( NtfsFileNameGetName( Name1 ),
                                Name1->FileNameLength,
                                NtfsFileNameGetName( Name2 ),
                                Name2->FileNameLength,
                                UpcaseTable,
                                TRUE );

    return Result;
}

LONG
NtfsCollate(
    IN PCVOID               Value1,
    IN ULONG                Length1,
    IN PCVOID               Value2,
    IN ULONG                Length2,
    IN COLLATION_RULE       CollationRule,
    IN PNTFS_UPCASE_TABLE   UpcaseTable
    )
/*++

Routine Description:

    This function compares two values according to an NTFS
    collation rule.

Arguments:

    Value1          --  Supplies the first value.
    Length1         --  Supplies the length of the first value.
    Value2          --  Supplies the second value.
    Length2         --  Supplies the length of the second value.
    CollationRule   --  Supplies the rule used for collation.
    UpcaseTable     --  Supplies the volume upcase table.  (May be NULL
                        if the collatio rule is not COLLATION_FILE_NAME).

Return Value:

    <0 if Entry1 is less than Entry2 by CollationRule
     0 if Entry1 is equal to Entry2 by CollationRule
    >0 if Entry1 is greater than Entry2 by CollationRule

Notes:

    The upcase table is only required for comparing file names.

    If two values are compared according to an unsupported collation
    rule, they are always treated as equal.

--*/
{
    LONG result;

    switch( CollationRule ) {

    case COLLATION_BINARY :

        // Binary collation of the values.
        //
        result = memcmp( Value1,
                         Value2,
                         MIN( Length1, Length2 ) );

        if( result != 0 ) {

            return result;

        } else {

            return( Length1 - Length2 );
        }

    case COLLATION_FILE_NAME :

        return CompareNtfsFileNames( (PFILE_NAME)Value1,
                                     (PFILE_NAME)Value2,
                                     UpcaseTable );


    case COLLATION_UNICODE_STRING :

        // unsupported collation rule.
        //
        return 0;

    case COLLATION_ULONG:

        // Unsigned long collation

        DebugAssert(Length1 == sizeof(ULONG));
        DebugAssert(Length1 == sizeof(ULONG));

        if (*(ULONG*)Value1 < *(ULONG *)Value2)
            return -1;
        else if (*(ULONG*)Value1 > *(ULONG *)Value2)
            return 1;
        else
            return 0;

    case COLLATION_SID:

        // SecurityId collation

        result = memcmp(&Length1, &Length2, sizeof(Length1));
        if (result != 0)
            return result;

        result = memcmp( Value1, Value2, Length1 );
        return result;

    case COLLATION_SECURITY_HASH: {

        // Security Hash (Hash key and SecurityId) Collation

        PSECURITY_HASH_KEY HashKey1 = (PSECURITY_HASH_KEY)Value1;
        PSECURITY_HASH_KEY HashKey2 = (PSECURITY_HASH_KEY)Value2;

        DebugAssert(Length1 == sizeof(SECURITY_HASH_KEY));
        DebugAssert(Length2 == sizeof(SECURITY_HASH_KEY));

        if (HashKey1->Hash < HashKey2->Hash)
            return -1;
        else if (HashKey1->Hash > HashKey2->Hash)
            return 1;
        else if (HashKey1->SecurityId < HashKey2->SecurityId)
            return -1;
        else if (HashKey1->SecurityId > HashKey2->SecurityId)
            return 1;
        else
            return 0;
    }

    case COLLATION_ULONGS: {
        PULONG pu1, pu2;
        ULONG count;

        result = 0;

        DebugAssert( (Length1 & 3) == 0 );
        DebugAssert( (Length2 & 3) == 0 );

        count = Length1;
        if (count != Length2) {
           result = -1;
           if (count > Length2) {
               count = Length2;
               result = 1;
           }
        }

        pu1 = (PULONG)Value1;
        pu2 = (PULONG)Value2;

        while (count > 0) {
           if (*pu1 > *pu2) {
               return 1;
           } else if (*(pu1++) < *(pu2++)) {
               return -1;
           }
           count -= 4;
        }
        return result;
    }

    default:

        DebugAbort( "Unsupported collation rule.\n" );
        return 0;
    }
}




LONG
CompareNtfsIndexEntries(
    IN PCINDEX_ENTRY    Entry1,
    IN PCINDEX_ENTRY    Entry2,
    IN COLLATION_RULE   CollationRule,
    IN PNTFS_UPCASE_TABLE UpcaseTable
    )
/*++

Routine Description:

    This global function is used to compare index entries.

Arguments:

    Entry1          --  Supplies the first entry to compare.
    Entry2          --  Supplies the second entry to compare.
    CollationRule   --  Supplies the rule used for collation.
    UpcaseTable     --  Supplies the volume upcase table.

Return Value:

    <0 if Entry1 is less than Entry2 by CollationRule
     0 if Entry1 is equal to Entry2 by CollationRule
    >0 if Entry1 is greater than Entry2 by CollationRule

Notes:

    The upcase table is only required for comparing file names.

--*/
{
    return NtfsCollate( GetIndexEntryValue( Entry1 ),
                        Entry1->AttributeLength,
                        GetIndexEntryValue( Entry2 ),
                        Entry2->AttributeLength,
                        CollationRule,
                        UpcaseTable );
}



DEFINE_EXPORTED_CONSTRUCTOR( NTFS_INDEX_TREE, OBJECT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_INDEX_TREE::~NTFS_INDEX_TREE(
    )
{
    Destroy();
}

VOID
NTFS_INDEX_TREE::Construct(
    )
/*++

Routine Description:

    Worker function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Drive = NULL;
    _ClusterFactor = 0;
    _ClustersPerBuffer = 0;
    _BufferSize = 0;
    _VolumeBitmap = NULL;
    _UpcaseTable = NULL;
    _AllocationAttribute = NULL;
    _IndexAllocationBitmap = NULL;
    _IndexRoot = NULL;
    _Name = NULL;

    _IteratorState = INDEX_ITERATOR_RESET;
    _CurrentEntry = NULL;
    _CurrentBuffer = NULL;
    _CurrentKey = NULL;
    _CurrentKeyLength = 0;
}

VOID
NTFS_INDEX_TREE::Destroy(
    )
/*++

Routine Description:

    This method cleans up an NTFS_INDEX_TREE object in preparation
    for destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Drive = NULL;
    _ClustersPerBuffer = 0;
    _BufferSize = 0;
    _VolumeBitmap = NULL;
    _UpcaseTable = NULL;

    DELETE( _AllocationAttribute );
    DELETE( _IndexAllocationBitmap );
    DELETE( _IndexRoot );
    DELETE( _Name );

    _IteratorState = INDEX_ITERATOR_RESET;

    _CurrentEntry = NULL;
    DELETE( _CurrentBuffer );
    FREE( _CurrentKey );

    _CurrentKeyLength = 0;
}



UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::Initialize(
    IN OUT PLOG_IO_DP_DRIVE             Drive,
    IN     ULONG                        ClusterFactor,
    IN OUT PNTFS_BITMAP                 VolumeBitmap,
    IN     PNTFS_UPCASE_TABLE           UpcaseTable,
    IN     ULONG                        MaximumRootSize,
    IN     PNTFS_FILE_RECORD_SEGMENT    SourceFrs,
    IN     PCWSTRING                    IndexName
    )
/*++

Routine Description:

    This method initializes an NTFS_INDEX_TREE based on
    attributes queried from a File Record Segment.

Arguments:

    Drive               --  supplies the drive on which the
                                index resides.
    ClusterFactor       --  supplies the cluster factor for the drive.
    VolumeBitmap        --  supplies the volume bitmap.
    MaximumRootSize     --  supplies the maximum length of the index root
    SourceFrs           --  supplies the File Record Segment that contains
                            this index.
    UpcaseTable         --  supplies the volume upcase table.
    IndexName           --  supplies the name for this index.  (May be NULL,
                            in which case the index has no name.)

Return Value:

    TRUE upon successful completion.

Notes:

    SourceFrs must have an $INDEX_ROOT attribute, or this method will
    fail.

    The index tree does not remember what File Record Segment it came
    from; it only uses the FRS as a place to get the index root and
    index allocation attributes.

    The volume upcase table is only required if the indexed attribute
    type code is $FILE_NAME.

--*/
{
    NTFS_ATTRIBUTE RootAttribute;
    NTFS_ATTRIBUTE BitmapAttribute;

    BIG_INT ValueLength;
    ULONG NumberOfBuffers;
    BOOLEAN Error;

    Destroy();

    DebugAssert(0 != ClusterFactor);

    if( !SourceFrs->QueryAttribute( &RootAttribute,
                                    &Error,
                                    $INDEX_ROOT,
                                    IndexName ) ||
        (_IndexRoot = NEW NTFS_INDEX_ROOT) == NULL ||
        !_IndexRoot->Initialize( &RootAttribute,
                                 UpcaseTable,
                                 MaximumRootSize ) ) {

        Destroy();
        return FALSE;
    }

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;
    _ClustersPerBuffer = _IndexRoot->QueryClustersPerBuffer();
    _BufferSize = _IndexRoot->QueryBufferSize();
    _VolumeBitmap = VolumeBitmap;
    _UpcaseTable = UpcaseTable;

    DebugAssert(0 != _BufferSize);

    if( RootAttribute.GetName() != NULL &&
        ( (_Name = NEW DSTRING) == NULL ||
          !_Name->Initialize( RootAttribute.GetName() ) ) ) {

        Destroy();
        return FALSE;
    }

    _IndexedAttributeType = _IndexRoot->QueryIndexedAttributeType();
    _CollationRule = _IndexRoot->QueryCollationRule();

    if( SourceFrs->IsAttributePresent( $INDEX_ALLOCATION, IndexName ) ) {

        if( (_AllocationAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
            !SourceFrs->QueryAttribute( _AllocationAttribute,
                                        &Error,
                                        $INDEX_ALLOCATION,
                                        IndexName ) ) {

            Destroy();
            return FALSE;
        }

        // Set (ie. initialize and read) the bitmap associated with
        // the index allocation attribute.  Note that the bitmap
        // attribute's value may be larger than necessary to cover
        // the allocation attribute because the bitmap attribute's
        // value always grows in increments of eight bytes.  However,
        // at this point, we don't care, since we only worry about
        // that when we grow the bitmap.

        _AllocationAttribute->QueryValueLength( &ValueLength );

        DebugAssert( ValueLength % _BufferSize == 0 );

        NumberOfBuffers = ValueLength.GetLowPart()/_BufferSize;


        if( (_IndexAllocationBitmap = NEW NTFS_BITMAP) == NULL ||
            !_IndexAllocationBitmap->Initialize( NumberOfBuffers, TRUE ) ||
            !SourceFrs->QueryAttribute( &BitmapAttribute,
                                        &Error,
                                        $BITMAP,
                                        IndexName ) ||
            !_IndexAllocationBitmap->Read( &BitmapAttribute ) ) {

            Destroy();
            return FALSE;
        }
    }

    // Set up the buffer to support iteration.  This buffer must be
    // big enough to hold the largest key value.  The size of an
    // index allocation buffer will suffice.

    _IteratorState = INDEX_ITERATOR_RESET;
    _CurrentKeyMaxLength = _BufferSize;

    if( (_CurrentKey = MALLOC( _CurrentKeyMaxLength )) == NULL ) {

        Destroy();
        return FALSE;
    }

    _CurrentKeyLength = 0;

    if( !_CurrentEntryTrail.Initialize() ) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::Initialize(
    IN      ATTRIBUTE_TYPE_CODE IndexedAttributeType,
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN      ULONG               ClusterFactor,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable,
    IN      COLLATION_RULE      CollationRule,
    IN      ULONG               BufferSize,
    IN      ULONG               MaximumRootSize,
    IN      PCWSTRING           IndexName
    )
/*++

Routine Description:

    This method initializes an NTFS_INDEX_TREE based on its basic
    information.  It is used when creating an index.

Arguments:

    Drive                   --  supplies the drive on which the
                                index resides.
    VolumeBitmap            --  supplies the volume bitmap
    UpcaseTable             --  supplies the volume upcase table.
    IndexedAttributeType    --  supplies the attribute type code of the
                                attribute which is used as the key for
                                this index.
    CollationRule           --  supplies the collation rule for this index.
    BufferSize              --  supplies the size of each Index Buffer in this index.
    MaximumRootSize         --  supplies the maximum length of the index root
    IndexName               --  supplies the name of this index.  (May be
                                NULL, in which case the index has no name.)

Return Value:

    TRUE upon successful completion.

    The volume upcase table is only required if the indexed attribute
    type code is $FILE_NAME.

--*/
{
    ULONG   ClusterSize;

    Destroy();

    DebugAssert(0 != ClusterFactor);
    DebugPtrAssert(Drive);

    _Drive = Drive;
    _BufferSize = BufferSize;
    _VolumeBitmap = VolumeBitmap;
    _UpcaseTable = UpcaseTable;
    _ClusterFactor = ClusterFactor;

    ClusterSize = Drive->QuerySectorSize()*ClusterFactor;

    DebugAssert(ClusterSize <= 64 * 1024);

    _ClustersPerBuffer = BufferSize / ((BufferSize < ClusterSize) ?
                                       NTFS_INDEX_BLOCK_SIZE : ClusterSize);

    if( IndexName != NULL &&
        ( (_Name = NEW DSTRING) == NULL ||
          !_Name->Initialize( IndexName ) ) ) {

        Destroy();
        return FALSE;
    }

    _IndexedAttributeType = IndexedAttributeType;
    _CollationRule = CollationRule;

    _AllocationAttribute = NULL;
    _IndexAllocationBitmap = NULL;

    if( (_IndexRoot = NEW NTFS_INDEX_ROOT) == NULL ||
        !_IndexRoot->Initialize( IndexedAttributeType,
                                 CollationRule,
                                 UpcaseTable,
                                 _ClustersPerBuffer,
                                 BufferSize,
                                 MaximumRootSize ) ) {

        Destroy();
        return FALSE;
    }


    // Set up the buffer to support iteration.  This buffer must be
    // big enough to hold the largest key value.  The size of an
    // index allocation buffer will suffice.

    _IteratorState = INDEX_ITERATOR_RESET;
    _CurrentKeyMaxLength = BufferSize;

    if( (_CurrentKey = MALLOC( _CurrentKeyMaxLength )) == NULL ) {

        Destroy();
        return FALSE;
    }

    _CurrentKeyLength = 0;

    if( !_CurrentEntryTrail.Initialize() ) {

        Destroy();
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::QueryFileReference(
    IN  ULONG                   KeyLength,
    IN  PVOID                   Key,
    IN  ULONG                   Ordinal,
    OUT PMFT_SEGMENT_REFERENCE  SegmentReference,
    OUT PBOOLEAN                Error
    )
/*++

Routine Description:

    This method determines the file which contains the specified
    value of the indexed attribute.

Arguments:

    KeyLength           --  supplies the length of the search key value.
    Key                 --  supplies the search key value.
    Ordinal             --  supplies a zero-based ordinal indicating
                            which matching entry to return (zero indicates
                            return the first matching entry).
    SegmentReference    --  receives a segment reference to the Base File
                            Record Segment of the file which contains the
                            supplied value of the indexed attribute.
    Error               --  receives an indication of whether an
                            error (e.g. out of memory) occurred.

Return Value:

    TRUE upon successful completion.  In this case, the state of
    *Error is undefined.

    If the method fails because of a resource problem, it returns FALSE
    and sets *Error to TRUE.  If it fails because the index
    is invalid or because the search value is not in the index, then
    it returns FALSE and sets *Error to TRUE.  In either case,
    the contents of SegmentReference are undefined.

--*/
{
    INTSTACK ParentTrail;
    PNTFS_INDEX_BUFFER ContainingBuffer = NULL;
    PINDEX_ENTRY FoundEntry;
    BOOLEAN Result;

    if( FindEntry( KeyLength,
                   Key,
                   Ordinal,
                   &FoundEntry,
                   &ContainingBuffer,
                   &ParentTrail ) ) {

        memcpy( SegmentReference,
                &FoundEntry->FileReference,
                sizeof( MFT_SEGMENT_REFERENCE ) );

        *Error = FALSE;
        Result = TRUE;

    } else {

        *Error = (FoundEntry == NULL);
        Result = FALSE;
    }

    if( ContainingBuffer != NULL ) {

        DELETE( ContainingBuffer );
    }

    return Result;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::QueryEntry(
    IN  ULONG               KeyLength,
    IN  PVOID               Key,
    IN  ULONG               Ordinal,
         OUT PINDEX_ENTRY*               FoundEntry,
    OUT PNTFS_INDEX_BUFFER* ContainingBuffer,
    OUT PBOOLEAN            Error
    )
/*++

Routine Description:

    This method returns the index entry that matches the given key.

Arguments:

    KeyLength           --  supplies the length of the search key value.
    Key                 --  supplies the search key value.
    Ordinal             --  supplies a zero-based ordinal indicating
                            which matching entry to return (zero indicates
                            return the first matching entry).
    FoundEntry          --  Receives a pointer to the located entry
                            (NULL indicates error).
    Error               --  receives an indication of whether an
                            error (e.g. out of memory) occurred.

Return Value:

    TRUE upon successful completion.  In this case, the state of
    *Error is undefined.

    If the method fails because of a resource problem, it returns FALSE
    and sets *Error to TRUE.  If it fails because the index
    is invalid or because the search value is not in the index, then
    it returns FALSE and sets *Error to TRUE.  In either case,
    the contents of SegmentReference are undefined.

--*/
{
    INTSTACK ParentTrail;
    BOOLEAN Result;

    if( FindEntry( KeyLength,
                   Key,
                   Ordinal,
                   FoundEntry,
                   ContainingBuffer,
                   &ParentTrail ) ) {

        *Error = FALSE;
        Result = TRUE;

    } else {

        *Error = (FoundEntry == NULL);
        Result = FALSE;
    }

    return Result;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::InsertEntry(
    IN  ULONG                   KeyLength,
    IN  PVOID                   KeyValue,
    IN  MFT_SEGMENT_REFERENCE   FileReference,
    IN  BOOLEAN                 NoDuplicates
    )
/*++

Routine Description:

    This method inserts a new entry into the index given its
    value and segment reference.

Arguments:

    KeyLength           --  supplies the length of the key, in bytes.
    KeyValue            --  supplies the key value.
    SegmentReference    --  supplies the segment reference to the file
                            which contains the indexed attribute with
                            this key value.
    NoDuplicates        --  Supplies a flag which, if TRUE, indicates
                            that InsertEntry should fail if a matching
                            entry is already present in the index.

Return Value:

    TRUE upon successful completion.

--*/
{
    PINDEX_ENTRY NewEntry;
    USHORT EntryLength;
    BOOLEAN Result;

    // Compute the length of the new entry:

    EntryLength = (USHORT)QuadAlign( sizeof(INDEX_ENTRY) + KeyLength );

    if( (NewEntry = (PINDEX_ENTRY)MALLOC( EntryLength )) == NULL ) {

        return FALSE;
    }

    memset( NewEntry, 0, EntryLength );

    NewEntry->FileReference = FileReference;
    NewEntry->Length = EntryLength;
    NewEntry->AttributeLength = (USHORT) KeyLength;
    NewEntry->Flags = 0;

    memcpy( (PBYTE)NewEntry + sizeof( INDEX_HEADER ),
            KeyValue,
            KeyLength );

    Result = InsertEntry( NewEntry, NoDuplicates );

    FREE( NewEntry );

    return Result;
}


BOOLEAN
NTFS_INDEX_TREE::InsertEntry(
    IN  PCINDEX_ENTRY   NewEntry,
    IN  BOOLEAN         NoDuplicates,
    IN  PBOOLEAN        Duplicate
    )
/*++

Routine Description:

    This method adds an entry to the index.

Arguments:

    NewEntry            -- supplies the new entry to add to the index.
    NoDuplicates        --  Supplies a flag which, if TRUE, indicates
                            that InsertEntry should fail if a matching
                            entry is already present in the index.

Return Value:

    TRUE upon successful completion.

--*/
{
    INTSTACK ParentTrail;

    PNTFS_INDEX_BUFFER ContainingBuffer;
    PINDEX_ENTRY FoundEntry;
    ULONG Ordinal;
    BOOLEAN Found;
    BOOLEAN Result;
    BOOLEAN dup;

    if (Duplicate == NULL)
        Duplicate = &dup;

    // First, find the spot in the tree where we want to insert the
    // new entry.
    //
    // If the client does not allow duplicates, search for the first
    // matching entry--if we find a match, refuse the insert; if we
    // don't, FindEntry will find the insertion point for us.
    //
    // If the client does allow duplicates, call FindEntry with
    // a value INDEX_SKIP, which indicates all matching entries
    // should be skipped.  Thus, the new entry will be inserted
    // after all matching entries.
    //
    Ordinal = NoDuplicates ? 0 : (INDEX_SKIP);

    Found = FindEntry( NewEntry->AttributeLength,
                       GetIndexEntryValue( NewEntry ),
                       Ordinal,
                       &FoundEntry,
                       &ContainingBuffer,
                       &ParentTrail );

    *Duplicate = Found;

    if( Found && NoDuplicates ) {

        // A matching entry already exists, and the client wants
        // to fail in that case.  So fail.
        //

        if ( ContainingBuffer )
            DELETE( ContainingBuffer );

        return FALSE;
    }

    DebugAssert( !Found );

    // Since no matching entry was found, FindEntry will
    // return a leaf entry as its insertion point.  This
    // makes this  code a lot easier, since we only need
    // to handle inserting a new leaf.
    //
    if( FoundEntry == NULL ) {

        // An error occurred trying to insert the entry.

        return FALSE;
    }

    if( ContainingBuffer == NULL ) {

        // The root is also a leaf (see comment above), so we'll
        // insert the new entry into it.

        return( InsertIntoRoot( NewEntry, FoundEntry ) );

    } else {

        // We've found a leaf buffer, so we'll insert the new
        // entry into it.

        Result = InsertIntoBuffer( ContainingBuffer,
                                   &ParentTrail,
                                   NewEntry,
                                   FoundEntry );

        DELETE( ContainingBuffer );
        return Result;
    }
}



BOOLEAN
NTFS_INDEX_TREE::DeleteEntry(
    IN  ULONG   KeyLength,
    IN  PVOID   Key,
    IN  ULONG   Ordinal
    )
/*++

Routine Description:

    This method deletes an entry from the index.

Arguments:

    KeyLength           --  supplies the length of the search key value.
    Key                 --  supplies the search key value.
    Ordinal             --  supplies a zero-based ordinal indicating
                            which matching entry to delete (zero indicates
                            return the first matching entry).

Return Value:

    TRUE upon successful completion.

    If no matching entry is found, this method returns TRUE (without
    changing the index in any way).  However, if an error occurs while
    searching for matching entries, then the method returns FALSE.

--*/
{
    PNTFS_INDEX_BUFFER ContainingBuffer = NULL;
    PINDEX_ENTRY FoundEntry;
    BOOLEAN Result;
    INTSTACK ParentTrail;

    // Locate the entry to remove.

    if( !FindEntry( KeyLength,
                    Key,
                    Ordinal,
                    &FoundEntry,
                    &ContainingBuffer,
                    &ParentTrail ) ) {

        // There is no matching entry in the tree, so we don't have
        // to bother.  If no error occurred, return TRUE; otherwise,
        // return FALSE.

        DELETE( ContainingBuffer );
        return( FoundEntry != NULL );
    }

    // Call the common delete helper--this will remove the target
    // entry and, if necessary, find a replacement for it.

    Result = RemoveEntry( FoundEntry,
                          ContainingBuffer,
                          &ParentTrail );

    DELETE( ContainingBuffer );
    return Result;
}


UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::Save(
    IN OUT PNTFS_FILE_RECORD_SEGMENT TargetFrs
    )
/*++

Routine Description:

    This method saves the index.  The root is saved as an INDEX_ROOT
    attribute in the target File Record Segment; the index allocation
    (if any) is saved as an INDEX_ALLOCATION attribute.

Arguments:

    TargetFrs   --  supplies the File Record Segment in which to save
                    the index.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE RootAttribute;
    NTFS_ATTRIBUTE BitmapAttribute;

    BOOLEAN Error;

    DebugAssert( ( _IndexAllocationBitmap == NULL &&
                 _AllocationAttribute == NULL ) ||
               ( _IndexAllocationBitmap != NULL &&
                 _AllocationAttribute != NULL ) );



    // Fetch or create attributes for the Index Root and (if necessary)
    // the allocation bitmap.  If either is to be newly created, make
    // it resident with zero length (since writing it it resize it
    // appropriately).

    if( !TargetFrs->QueryAttribute( &RootAttribute,
                                    &Error,
                                    $INDEX_ROOT,
                                    _Name ) &&
        ( Error ||
          !RootAttribute.Initialize( _Drive,
                                       _ClusterFactor,
                                       NULL,
                                       0,
                                       $INDEX_ROOT,
                                       _Name ) ) ) {

        return FALSE;
    }

    if( _IndexAllocationBitmap != NULL &&
        !TargetFrs->QueryAttribute( &BitmapAttribute,
                                    &Error,
                                    $BITMAP,
                                    _Name ) &&
        ( Error ||
          !BitmapAttribute.Initialize( _Drive,
                                       _ClusterFactor,
                                       NULL,
                                       0,
                                       $BITMAP,
                                       _Name ))) {

        return FALSE;
    }

    // If this tree does not have an allocation attribute, purge
    // any existing stale allocation & bitmap attributes.
    //
    if( _AllocationAttribute == NULL &&
        (!TargetFrs->PurgeAttribute( $INDEX_ALLOCATION, _Name ) ||
         !TargetFrs->PurgeAttribute( $BITMAP, _Name )) ) {

        return FALSE;
    }


    // Now save the attributes that describe this tree.
    //
    if( !_IndexRoot->Write( &RootAttribute ) ||
        !RootAttribute.InsertIntoFile( TargetFrs, _VolumeBitmap ) ) {

        return FALSE;
    }


    if( _AllocationAttribute == NULL ) {
        return TRUE;
    }

    if( !_IndexAllocationBitmap->Write( &BitmapAttribute, _VolumeBitmap )) {
        DebugPrint("UNTFS: Could not write index allocation bitmap\n");
        return FALSE;
    }

    if( !BitmapAttribute.InsertIntoFile( TargetFrs, _VolumeBitmap )) {

        DebugPrint("UNTFS: Could not insert bitmap attribute\n");

        //  Try a second time after making sure the attribute is non-resident.
        //

        if( !BitmapAttribute.MakeNonresident( _VolumeBitmap ) ||
            !BitmapAttribute.InsertIntoFile( TargetFrs, _VolumeBitmap )) {

            DebugPrint("UNTFS: Still could not insert bitmap attr.\n");
            return FALSE;
        }
    }

    if( !_AllocationAttribute->InsertIntoFile( TargetFrs, _VolumeBitmap )) {

        DebugPrintTrace(("UNTFS: Could not insert allocation attribute\n"));
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_INDEX_TREE::IsBadlyOrdered(
    OUT PBOOLEAN    Error,
    IN  BOOLEAN     DuplicatesAllowed
    )
/*++

Routine Description:

    This method traverses the index tree to determine whether it
    is badly-ordered.  A tree is well-ordered if it entries are
    in correct lexical order, all leaves appear at the same depth,
    and the tree has no empty leaf index allocation buffers.

Arguments:

    Error             --  Receives TRUE if this method fails because of
                          an error.
    DuplicatesAllowed --  Supplies a flag which indicates, if TRUE,
                          that this index may have duplicate entries.
                          Otherwise, if duplicate entries exist, the
                          tree is badly ordered.

Return Value:

    TRUE if the tree is found to be badly ordered.  (In this case,
    *Error should be ignored.)

    If this method returns FALSE and *Error is FALSE, then the tree
    is well-ordered.  If *Error is TRUE, this method was unable to
    determine whether the tree is well-ordered.

--*/
{
    BOOLEAN LeafFound, Result, FirstEntry, PreviousWasNode;
    ULONG LeafDepth, CurrentDepth;
    PINDEX_ENTRY PreviousEntry;
    PINDEX_ENTRY CurrentEntry;

    DebugAssert( Error );

    // Allocate a buffer to hold the previous entry:

    if( (PreviousEntry =
            (PINDEX_ENTRY)MALLOC( QueryMaximumEntrySize() )) == NULL ) {

        *Error = TRUE;
        return FALSE;
    }

    ResetIterator();

    FirstEntry = TRUE;
    PreviousWasNode = FALSE;
    LeafFound = FALSE;
    Result = FALSE;
    *Error = FALSE;

    while( (CurrentEntry = (PINDEX_ENTRY)GetNext( &CurrentDepth, Error, FALSE )) != NULL &&
           !*Error &&
           !Result ) {

        // Compare the current entry to the previous entry.  If duplicates
        // are not allowed, the currrent entry must be strictly greater
        // than the previous; otherwise, it must be greater than or equal
        // to the previous.
        //
        if( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

            if( FirstEntry ) {

                // This entry is the first in the index; don't compare
                // it to the previous entry.
                //
                FirstEntry = FALSE;

            } else if ( (!DuplicatesAllowed &&
                         CompareNtfsIndexEntries( CurrentEntry,
                                                  PreviousEntry,
                                                  _CollationRule,
                                                  _UpcaseTable ) <= 0 ) ||
                        (DuplicatesAllowed &&
                         CompareNtfsIndexEntries( CurrentEntry,
                                                  PreviousEntry,
                                                  _CollationRule,
                                                  _UpcaseTable ) < 0 ) ) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_ORDER);
                    msg->Log("%x%x", PreviousEntry->Length, CurrentEntry->Length);
                    msg->DumpDataToLog(PreviousEntry, min(0x100, PreviousEntry->Length));
                    msg->Set(MSG_CHKLOG_NTFS_DIVIDER);
                    msg->Log();
                    msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                    msg->Unlock();
                }

                // The tree is badly ordered.
                //
                Result = TRUE;
                break;
            }

        } else if( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ) {

            // This is an end leaf entry.  If it's the first
            // entry in the tree and not in the root, then
            // it's in an empty index allocation buffer, which
            // means the tree is badly ordered.  Similarly, if
            // the previous entry was a node, then this entry is
            // in an empty index allocation block, which means
            // the tree is badly ordered.
            //

            if( FirstEntry && CurrentDepth != 0 ) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_FIRST_INDEX_ENTRY_IS_LEAF_BUT_NOT_AT_ROOT);
                    msg->Log("%x", CurrentEntry->Length);
                    msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                    msg->Unlock();
                }

                Result = TRUE;
                break;
            }

            if( PreviousWasNode ) {

                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_EMPTY_INDEX_BUFFER);
                    msg->Log("%x", CurrentEntry->Length);
                    msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                    msg->Unlock();
                }

                Result = TRUE;
                break;
            }
        }

        if( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ) {

            // This is a leaf.  See if it's at the same depth as
            // the other leaves we've seen so far.
            //
            if( !LeafFound ) {

                // This is the first leaf.  Record its depth.
                //


                LeafFound = TRUE;
                LeafDepth = CurrentDepth;

            } else {

                if( CurrentDepth != LeafDepth ) {

                    // The leaves are not all at the same depth,
                    // which means this tree is badly ordered.
                    //
                    PMESSAGE msg = _Drive->GetMessage();

                    if (msg) {
                        msg->Lock();
                        msg->Set(MSG_CHKLOG_NTFS_LEAF_DEPTH_NOT_THE_SAME);
                        msg->Log("%x%x%x", LeafDepth, CurrentDepth, CurrentEntry->Length);
                        msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                        msg->Unlock();
                    }

                    Result = TRUE;
                    break;
                }
            }

            PreviousWasNode = FALSE;

        } else if( GetDownpointer(CurrentEntry) == INVALID_VCN ) {

            // This entry has an invalid downpointer, so the
            // index is badly ordered.
            //
            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->Lock();
                msg->Set(MSG_CHKLOG_NTFS_INVALID_DOWN_POINTER);
                msg->Log("%x", CurrentEntry->Length);
                msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                msg->Unlock();
            }

            Result = TRUE;
            break;

        } else {

            // Remember that we just saw a node entry.
            //
            PreviousWasNode = TRUE;
        }

        // If the current entry isn't an END entry, copy it
        // into the previous entry buffer:
        //
        if( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

            if( CurrentEntry->Length > QueryMaximumEntrySize() ) {

                // This entry is impossibly large, which means that the
                // index is corrupt.
                //
                PMESSAGE msg = _Drive->GetMessage();

                if (msg) {
                    msg->Lock();
                    msg->Set(MSG_CHKLOG_NTFS_INDEX_ENTRY_LENGTH_TOO_LARGE);
                    msg->Log("%x%x",
                             CurrentEntry->Length,
                             QueryMaximumEntrySize());
                    msg->DumpDataToLog(CurrentEntry, min(0x100, CurrentEntry->Length));
                    msg->Unlock();
                }

                *Error = TRUE;
                Result = FALSE;

            } else {

                memcpy( (PVOID) PreviousEntry,
                        (PVOID) CurrentEntry,
                        CurrentEntry->Length );
            }
        }
    }

    FREE( PreviousEntry );
    return Result;
}



VOID
NTFS_INDEX_TREE::FreeAllocation(
    )
/*++

Routine Description:

    This method frees the disk space associated with this index's
    Allocation Attribute.

Arguments:

    None.

Return Value:

    None.

Notes:

    This method may leave the tree in a corrupt state, since it
    truncates the allocation attribute to zero without cleaning
    up downpointers in the root.  Use with care.

--*/
{
    if( _AllocationAttribute != NULL ) {

        _AllocationAttribute->Resize( 0, _VolumeBitmap );
    }
}


BOOLEAN
NTFS_INDEX_TREE::UpdateFileName(
    IN PCFILE_NAME      Name,
    IN FILE_REFERENCE   FileReference
    )
/*++

Routine Description:

    This method updates the duplicated information in a file name
    index entry.

Arguments:

    Name            --  Supplies the file name structure with the new
                        duplicated information.
    FileReference   --  Supplies the file reference for the file to
                        which this name belongs.  (Note that this is
                        the base FRS for that file, not necessarily the
                        exact FRS that contains the name.)

Return Value:

    TRUE upon successful completion.

Notes:

    This operation is meaningless on an index that is not constructed
    over the $FILE_NAME attribute.

--*/
{
    INTSTACK ParentTrail;
    PINDEX_ENTRY FoundEntry;
    PNTFS_INDEX_BUFFER ContainingBuffer = NULL;
    PFILE_NAME TargetName;
    BOOLEAN Result;

    DebugPtrAssert( Name );

    if( QueryIndexedAttributeType() != $FILE_NAME ||
        QueryCollationRule() != COLLATION_FILE_NAME ) {

        DebugAbort( "Updating file name in an index that isn't over $FILE_NAME.\n" );
        return FALSE;
    }

    // OK, find the entry that corresponds to the input.  Note that the
    // collation rule for File Names ignores everything but the actual
    // file name portion of the key value.

    if( !FindEntry( NtfsFileNameGetLength( Name ),
                    (PVOID)Name,
                    0,
                    &FoundEntry,
                    &ContainingBuffer,
                    &ParentTrail ) ) {

        // If FoundEntry is NULL, FindEntry failed because of an error;
        // otherwise, there is no matching entry in the index, which
        // means there's nothing to update.
        //

        DebugPrint( "UpdateFileName--index entry not found.\n" );
        Result = ( FoundEntry != NULL );

    } else {

        // We've found an entry.  As an extra sanity check, make sure
        // that the file reference for the found entry is the same as
        // the input file reference.

        if( memcmp( &(FoundEntry->FileReference),
                    &(FileReference),
                    sizeof( FILE_REFERENCE ) ) != 0 ) {

            DebugPrint( "File references don't match in UpdateFileName.\n" );
            Result = TRUE;

        } else {

            // Copy the duplicated information and update the file-name bits.
            //
            TargetName = (PFILE_NAME)(GetIndexEntryValue(FoundEntry));
            TargetName->Info = Name->Info;
            TargetName->Flags = Name->Flags;

            if( ContainingBuffer != NULL ) {

                // This entry is in a buffer, so we have to write the
                // buffer while we've still got it.
                //
                Result = ContainingBuffer->Write( _AllocationAttribute );

            } else {

                // This entry is in the root, so we're done.
                //
                Result = TRUE;
            }
        }
    }

    DELETE( ContainingBuffer );
    return Result;
}


BOOLEAN
NTFS_INDEX_TREE::IsIndexEntryCorrupt(
    IN     PCINDEX_ENTRY       IndexEntry,
    IN     ULONG               MaximumLength,
    IN OUT PMESSAGE            Message,
    IN     INDEX_ENTRY_TYPE    IndexEntryType
    )
{
    ULONG   len;

    if (sizeof(INDEX_ENTRY) > MaximumLength) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_LENGTH,
                         "%x%x",
                         -1,
                         MaximumLength);
        }
        return TRUE;
    }

    if (IndexEntry->Length != QuadAlign(IndexEntry->Length) ||
        IndexEntry->Length > MaximumLength) {

        if (Message) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_LENGTH,
                         "%x%x",
                         IndexEntry->Length,
                         MaximumLength);
        }
        return TRUE;
    }

    len = ((IndexEntry->Flags & INDEX_ENTRY_NODE) ? sizeof(VCN) : 0) +
          ((IndexEntry->Flags & INDEX_ENTRY_END) ? 0 : IndexEntry->AttributeLength) +
          sizeof(INDEX_ENTRY);

    DebugAssert(INDEX_ENTRY_WITH_DATA_TYPE_4 == 0 &&
                INDEX_ENTRY_WITH_DATA_TYPE_8 == 1 &&
                INDEX_ENTRY_WITH_DATA_TYPE_12 == 2 &&
                INDEX_ENTRY_WITH_DATA_TYPE_16 == 3);

    switch (IndexEntryType) {
        case INDEX_ENTRY_WITH_DATA_TYPE_4:
        case INDEX_ENTRY_WITH_DATA_TYPE_8:
        case INDEX_ENTRY_WITH_DATA_TYPE_12:
        case INDEX_ENTRY_WITH_DATA_TYPE_16:
            if (!(IndexEntry->Flags & INDEX_ENTRY_END) &&
                IndexEntry->AttributeLength != IndexEntryAttributeLength[IndexEntryType]) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_ATTR_LENGTH,
                                 "%x%x%x",
                                 IndexEntryType,
                                 IndexEntry->AttributeLength,
                                 IndexEntryAttributeLength[IndexEntryType]);
                }

                return TRUE;
            }

            // fall through

        case INDEX_ENTRY_WITH_DATA_TYPE:
            if (QuadAlign(IndexEntry->DataOffset + IndexEntry->DataLength) >
                IndexEntry->Length) {

                if (Message) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_INDEX_ENTRY_DATA_LENGTH,
                                 "%x%x%x",
                                 IndexEntry->DataOffset,
                                 IndexEntry->DataLength,
                                 IndexEntry->Length);
                }

                return TRUE;
            }

            len += IndexEntry->DataLength;

            // fall through

        case INDEX_ENTRY_WITH_FILE_NAME_TYPE:
            if (IndexEntry->Length != QuadAlign(len)) {

                if (Message) {
                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_MISALIGNED_INDEX_ENTRY_LENGTH);
                    Message->Log("%x", IndexEntryType);
                    Message->DumpDataToLog((PVOID)IndexEntry, sizeof(IndexEntry));
                    Message->Unlock();
                }

                return TRUE;
            } else
                return FALSE;
    }

    if (QuadAlign(len) > IndexEntry->Length) {

        if (Message) {
            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_INDEX_ENTRY_LENGTH_TOO_SMALL);
            Message->Log("%x", IndexEntryType);
            Message->DumpDataToLog((PVOID)IndexEntry, sizeof(IndexEntry));
            Message->Unlock();
        }

        return TRUE;
    } else
        return FALSE;
}


BOOLEAN
NTFS_INDEX_TREE::ResetLsns(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This method sets the LSN for each in-use index allocation
    block in the index tree to zero.

Arguments:

    Message --  Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_INDEX_BUFFER CurrentBuffer;
    ULONG i, num_buffers, cluster_size;

    cluster_size = _ClusterFactor * _Drive->QuerySectorSize();

    if( _AllocationAttribute == NULL ) {

        // This tree has no index allocation buffers--there's
        // nothing to do.
        //
        return TRUE;
    }

    num_buffers = (_AllocationAttribute->QueryValueLength()/_BufferSize).GetLowPart();

    for( i = 0; i < num_buffers; i++ ) {

        VCN current_vcn;

        // Skip unused buffers.
        //
        if( _IndexAllocationBitmap->IsFree( i, 1 ) ) {

            continue;
        }

        // If we have a positive number for _ClustersPerBuffer, we want to
        // use that to compute the VCN (this is a backward compatibility mode).
        // More recently formatted filesystems will have 0 for _ClustersPerBuffer
        // and the VCN will be the block number (512-byte blocks), regardless of
        // how many clusters are in each buffer.
        //

        if (0 == _ClustersPerBuffer) {
            current_vcn = i * (_BufferSize / 512);
        } else {
            current_vcn = i * _ClustersPerBuffer;
        }

        // Initialize the buffer, read it, set its LSN, and write it.
        //
        if( !CurrentBuffer.Initialize( _Drive,
                                       current_vcn,
                                       cluster_size,
                                       _ClustersPerBuffer,
                                       _BufferSize,
                                       _CollationRule,
                                       _UpcaseTable )   ||
            !CurrentBuffer.Read( _AllocationAttribute ) ||
            !CurrentBuffer.SetLsn( 0 )                  ||
            !CurrentBuffer.Write( _AllocationAttribute ) ) {

            Message->DisplayMsg( MSG_CHK_NO_MEMORY );
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_INDEX_TREE::FindHighestLsn(
    IN OUT  PMESSAGE    Message,
    OUT     PLSN        HighestLsn
    ) CONST
/*++

Routine Description:

    This method finds the highest LSN for any index block
    associated with this index.

Arguments:

    Message --  Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_INDEX_BUFFER CurrentBuffer;
    BIG_INT BigZero;
    ULONG i, cluster_size, num_buffers;

    cluster_size = _ClusterFactor * _Drive->QuerySectorSize();

    BigZero = 0;
    *HighestLsn = BigZero.GetLargeInteger();

    if( _AllocationAttribute == NULL ) {

        // This tree has no index allocation buffers--there's
        // nothing to do.
        //
        return TRUE;
    }

    num_buffers = (_AllocationAttribute->QueryValueLength()/_BufferSize).GetLowPart();

    for( i = 0; i < num_buffers; i++ ) {

        VCN current_vcn;

        // Skip unused buffers.
        //
        if( _IndexAllocationBitmap->IsFree( i, 1 ) ) {

            continue;
        }

        if (0 == _ClustersPerBuffer) {
            current_vcn = i * (_BufferSize / 512);
        } else {
            current_vcn = i * _ClustersPerBuffer;
        }

        // Initialize and read the buffer
        //
        if( !CurrentBuffer.Initialize( _Drive,
                                       current_vcn,
                                       cluster_size,
                                       _ClustersPerBuffer,
                                       _BufferSize,
                                       _CollationRule,
                                       _UpcaseTable )   ||
            !CurrentBuffer.Read( _AllocationAttribute ) ) {

            Message->DisplayMsg( MSG_CHK_NO_MEMORY );
            return FALSE;
        }

        if( CurrentBuffer.QueryLsn() > *HighestLsn ) {

            *HighestLsn = CurrentBuffer.QueryLsn();
        }
    }

    return TRUE;
}



BOOLEAN
NTFS_INDEX_TREE::FindEntry(
    IN  ULONG               KeyLength,
    IN  PVOID               KeyValue,
    IN  ULONG               Ordinal,
    OUT PINDEX_ENTRY*       FoundEntry,
    OUT PNTFS_INDEX_BUFFER* ContainingBuffer,
    OUT PINTSTACK           ParentTrail
    )
/*++

Routine Description:

    This method locates an entry (based on its key value) in
    the index tree.  If no matching entry is found, it locates
    the first leaf entry which is greater than the search value
    (i.e. the point at which the search value would be inserted
    into the tree).

Arguments:

    KeyLength           --  supplies the length, in bytes, of the
                            search value
    KeyValue            --  supplies the search value
    Ordinal             --  supplies the (zero-based) ordinal of the
                            matching entry to return.  (zero returns
                            the first matching value).

                            Note that a value of INDEX_SKIP skips
                            all matching entries.

    FoundEntry          --  Receives a pointer to the located entry
                            (NULL indicates error).
    ContainingBuffer    --  Receives a pointer to the index buffer
                            containing the returned entry (NULL if the
                            entry is in the root).
    ParentTrail         --  Receives the parent trail of ContainingBuffer
                            (ie. the VCNs of that buffer's ancestors).
                            If the entry is in the root, this object
                            may be left uninitialized.

Return Value:

    TRUE If a matching entry is found.

    FALSE if no matching entry was found.  If no error occurred, then
    *FoundEntry will point at the place in the tree where the search
    value would be inserted.

    If the method fails due to error, it returns FALSE and sets
    *FoundEntry to NULL.

    Note that if FindEntry does not find a matching entry, it will
    always return a leaf entry.

--*/
{
    PINDEX_ENTRY SearchEntry;
    VCN CurrentBufferVcn;
    PNTFS_INDEX_BUFFER CurrentBuffer;
    BOOLEAN Finished = FALSE;
    BOOLEAN Result = FALSE;
    USHORT SearchEntryLength;

    // Rig up an index-entry to pass to the index root and buffers:

    SearchEntryLength = (USHORT)QuadAlign( sizeof( INDEX_ENTRY ) + KeyLength );

    if( (SearchEntry = (PINDEX_ENTRY)MALLOC( SearchEntryLength )) == NULL ) {

        // Return the error.

        *FoundEntry = NULL;
        return FALSE;

    }

    SearchEntry->Length = SearchEntryLength;
    SearchEntry->AttributeLength = (USHORT)KeyLength;

    memcpy( GetIndexEntryValue( SearchEntry ),
            KeyValue,
            KeyLength );


    // See if the entry we want is in the index root:

    if( _IndexRoot->FindEntry( SearchEntry,
                               &Ordinal,
                               FoundEntry ) ) {

        // The desired entry is in the root.  *FoundEntry has been set
        // by the Index Root; fill in the other return parameters

        *ContainingBuffer = NULL;
        Result = TRUE;

    } else if ( *FoundEntry == NULL ) {

        // An error occurred trying to find the entry.

        *ContainingBuffer = NULL;
        Result = FALSE;

    } else if( !((*FoundEntry)->Flags & INDEX_ENTRY_NODE) ||
               GetDownpointer( *FoundEntry ) == INVALID_VCN ) {

        // The entry we want isn't in the root, and the root is a leaf,
        // so it's not in the tree.  Return the entry we did find, and
        // return 'not found' to the client.

        *ContainingBuffer = NULL;
        Result = FALSE;

    } else {

        // We didn't find the entry we want in the index root, and
        // the root is not a leaf, so we'll start looking through the
        // index allocation buffers.

        // First, we have to allocate an index allocation buffer
        // for our search.  If all goes well, we'll return this
        // buffer to the client.  Initialize the parent trail, but
        // leave it empty (indicating that we're at the root).

        if( !ParentTrail->Initialize() ||
            (CurrentBuffer = NEW NTFS_INDEX_BUFFER) == NULL ) {

            *FoundEntry = NULL;
        }

        if (_AllocationAttribute == NULL) {

            PMESSAGE msg = _Drive->GetMessage();

            if (msg) {
                msg->LogMsg(MSG_CHKLOG_NTFS_INDEX_ALLOC_DOES_NOT_EXIST);
            }

            *FoundEntry = NULL;
        }

        while( *FoundEntry != NULL && !Finished ) {

            DebugAssert( ((*FoundEntry)->Flags & INDEX_ENTRY_NODE) &&
                       GetDownpointer( *FoundEntry ) != INVALID_VCN );

            CurrentBufferVcn = GetDownpointer( *FoundEntry );

            if( !CurrentBuffer->Initialize( _Drive,
                                            CurrentBufferVcn,
                                            _ClusterFactor * _Drive->QuerySectorSize(),
                                            _ClustersPerBuffer,
                                            _BufferSize,
                                            _CollationRule,
                                            _UpcaseTable ) ||
                !CurrentBuffer->Read( _AllocationAttribute ) ) {

                *FoundEntry = NULL;

            } else if( CurrentBuffer->FindEntry( SearchEntry,
                                                 &Ordinal,
                                                 FoundEntry ) ) {

                // We found the entry we want.

                Finished = TRUE;
                Result = TRUE;

            } else if ( *FoundEntry != NULL &&
                        (!((*FoundEntry)->Flags & INDEX_ENTRY_NODE) ||
                         GetDownpointer( *FoundEntry ) == INVALID_VCN) ) {

                // This buffer is a leaf, so the entry we want isn't
                // to be found.  Instead, we'll return this entry, along
                // with a result of FALSE to indicate 'not found'.

                Finished = TRUE;
                Result = FALSE;

            } else {

                // We have to recurse down another level in the tree.
                // Add the current buffer's VCN to the parent trail.

                if( !ParentTrail->Push( CurrentBufferVcn ) ) {

                    // Error.  Drop out of the loop and into the error
                    // handling.

                    *FoundEntry = NULL;
                }
            }
        }

        if( *FoundEntry == NULL ) {

            // We're returning an error, so we have to clean up.

            DELETE( CurrentBuffer );
            CurrentBuffer = NULL;
            *ContainingBuffer = NULL;
            Result = FALSE;

        } else {

            // We're returning an entry--either the one the client
            // wants or the next leaf.  Either way, it's contained
            // in the current buffer, so we need to return that, too.

            *ContainingBuffer = CurrentBuffer;
        }
    }

    FREE( SearchEntry );

    return Result;
}

BOOLEAN
NTFS_INDEX_TREE::RemoveEntry(
    IN PINDEX_ENTRY         EntryToRemove,
    IN PNTFS_INDEX_BUFFER   ContainingBuffer,
    IN PINTSTACK            ParentTrail
    )
/*++

Routine Description:

    This method removes an entry from the tree.

Arguments:

    EntryToRemove       --  Supplies a pointer to the entry to be removed.
    ContainingBuffer    --  Supplies the buffer which contains this entry.
                            NULL if the entry is in the root.
    ParentTrail         --  Supplies the trail of ancestors of
                            ContainingBuffer, back to the root.
                            If ContainingBuffer is NULL, this object
                            may be uninitialized.

Return Value:

    TRUE upon successful completion.

Notes:

    If the removed entry does not have a downpointer, it is sufficient
    to simply rip it out.  If it does, we have to find a replacement
    for it.

--*/
{
    NTFS_INDEX_BUFFER CurrentBuffer;
    PINDEX_ENTRY ReplacementEntry, Successor;
    BOOLEAN Result, Error;


    BOOLEAN EmptyLeaf = FALSE;
    VCN EmptyLeafVcn;

    DebugAssert( !(EntryToRemove->Flags & INDEX_ENTRY_END ) );

    if( ContainingBuffer == NULL ) {

        // The entry we wish to delete is in the root.

        if( !(EntryToRemove->Flags & INDEX_ENTRY_NODE) ||
            GetDownpointer( EntryToRemove ) == INVALID_VCN ) {

            // It's a leaf entry, so we can just yank it.
            //
            _IndexRoot->RemoveEntry( EntryToRemove );
            Result = TRUE;

        } else {

            // Since the entry we want to remove has a downpointer,
            // we have to find a replacement for it.
            //
            // Allocate a buffer for the replacement entry.
            //
            if( (ReplacementEntry = (PINDEX_ENTRY)
                                    MALLOC( QueryMaximumEntrySize() ))
                == NULL ) {

                return FALSE;
            }

            Successor = GetNextEntry( EntryToRemove );

            if( QueryReplacementEntry( Successor,
                                       ReplacementEntry,
                                       &Error,
                                       &EmptyLeaf,
                                       &EmptyLeafVcn ) ) {

                // We've got a replacement.  It inherits the deleted
                // entry's downpointer.  Then we remove the deleted entry
                // and insert the replacement.

                // Note that QueryReplacementEntry always returns a
                // node entry (ie. INDEX_ENTRY_NODE is set in the flags
                // and the size includes the Downpointer VCN.)

                GetDownpointer( ReplacementEntry ) =
                                    GetDownpointer( EntryToRemove );

                _IndexRoot->RemoveEntry( EntryToRemove );

                Result = InsertIntoRoot( ReplacementEntry,
                                         EntryToRemove );

            } else if ( !Error ) {

                // There is no replacement for the current entry.
                // This means that the subtree rooted at its successor
                // is empty, and can be deleted, which in turn means
                // that the successor can just inherit the deleted
                // entry's downpointer.

                FreeChildren( Successor );

                GetDownpointer( Successor ) = GetDownpointer( EntryToRemove );

                _IndexRoot->RemoveEntry( EntryToRemove );

                Result = TRUE;

            } else {

                // an error has occurred.
                //
                Result = FALSE;
            }

            FREE( ReplacementEntry );
        }

    } else if( !(EntryToRemove->Flags & INDEX_ENTRY_NODE) ||
               GetDownpointer( EntryToRemove ) == INVALID_VCN ) {

        // The entry we wish to delete is a leaf, so we
        // can just yank it.
        //

        ContainingBuffer->RemoveEntry( EntryToRemove );
        Result = ContainingBuffer->Write( _AllocationAttribute );

        // Check to see if removing that entry made the leaf
        // empty.
        //
        if( ContainingBuffer->IsLeaf() && ContainingBuffer->IsEmpty() ) {

            EmptyLeaf = TRUE;
            EmptyLeafVcn = ContainingBuffer->QueryVcn();
        }

    } else {

        // The entry we wish to delete is in a node buffer, so we
        // have to find a replacement for it.
        //
        // Allocate a buffer for the replacement entry.

        if( (ReplacementEntry = (PINDEX_ENTRY)
                                MALLOC( QueryMaximumEntrySize() ))
            == NULL ) {

            return FALSE;
        }

        Successor = GetNextEntry( EntryToRemove );

        if( QueryReplacementEntry( Successor,
                                   ReplacementEntry,
                                   &Error,
                                   &EmptyLeaf,
                                   &EmptyLeafVcn ) ) {

            // We've got a replacement.  It inherits the deleted
            // entry's downpointer.  Then we remove the deleted entry
            // and insert the replacement.

            // Note that QueryReplacementEntry always returns a
            // node entry (ie. INDEX_ENTRY_NODE is set in the flags
            // and the size includes the Downpointer VCN.

            GetDownpointer( ReplacementEntry ) =
                                GetDownpointer( EntryToRemove );

            ContainingBuffer->RemoveEntry( EntryToRemove );

            // Note that InsertIntoBuffer will write ContainingBuffer.
            //
            Result = InsertIntoBuffer( ContainingBuffer,
                                       ParentTrail,
                                       ReplacementEntry,
                                       EntryToRemove );

        } else if ( !Error ) {

            // There is no replacement for the current entry.
            // This means that the subtree rooted at its successor
            // is empty, and can be deleted, which in turn means
            // that the successor can just inherit the deleted
            // entry's downpointer.

            FreeChildren( Successor );

            GetDownpointer( Successor ) = GetDownpointer( EntryToRemove );

            ContainingBuffer->RemoveEntry( EntryToRemove );

            Result = ContainingBuffer->Write( _AllocationAttribute );

        } else {

            // an error has occurred.

            Result = FALSE;
        }

        FREE( ReplacementEntry );
    }

    // If we have successfully deleted an entry, we must check
    // to see if we've created an empty leaf allocation buffer.
    // Note that this will collapse the tree, if appropriate.
    //
    if( EmptyLeaf ) {

        if (!FixupEmptyLeaf( EmptyLeafVcn ))
            Result = FALSE;
    }

    return Result;
}



BOOLEAN
NTFS_INDEX_TREE::QueryReplacementEntry(
    IN  PINDEX_ENTRY        Successor,
    OUT PINDEX_ENTRY        ReplacementEntry,
    OUT PBOOLEAN            Error,
    OUT PBOOLEAN            EmptyLeaf,
    OUT PVCN                EmptyLeafVcn
    )
/*++

Routine Description:

    This private method finds a replacement entry for a deleted
    entry, removes it from its current location in the tree, and
    copies it into the supplied replacement entry buffer.

Arguments:

    Successor           --  supplies the entry following the entry to be
                            replaced.
    ReplacementEntry    --  receives the replacement entry.
    Error               --  receives TRUE if an error occurs.
    EmptyLeaf           --  receives TRUE if this method creates an
                            empty leaf allocation block.  Undefined if
                            the method returns FALSE.
    EmptyLeafVcn        --  receives the VCN of the empty leaf if
                            *EmptyLeaf is set to TRUE.  Undefined if
                            the method returns FALSE.

Return Value:

    TRUE if a replacement entry was found without error.  FALSE if no
    replacement was found or if an error occurred.  (If an error is
    encountered, *Error is set to TRUE.)

Notes:

    The replacement entry is the first entry in the subtree rooted at
    Successor.  It is copied into the replacement buffer and then
    removed from its current location.

    This method assumes that Successor is an entry in a node block
    (which may be the index root), and that the tree is valid and
    consistent.

    If a replacement entry is returned, it will be a node entry (i.e.
    its length will be adjusted, if necessary, to include a downpointer).

    The ReplacementEntry buffer must be big enough to hold any index
    entry from this tree.

--*/
{
    PNTFS_INDEX_BUFFER CurrentBuffer;
    PNTFS_INDEX_BUFFER CandidateBuffer;
    VCN CurrentVcn;
    PINDEX_ENTRY CurrentEntry;
    PINDEX_ENTRY CandidateEntry;
    BOOLEAN LeafFound = FALSE;

    CandidateBuffer = NULL;
    CandidateEntry = NULL;
    *Error = FALSE;

    CurrentVcn = GetDownpointer( Successor );

    while( !*Error && !LeafFound ) {

        if( (CurrentBuffer = NEW NTFS_INDEX_BUFFER) == NULL ||
            !CurrentBuffer->Initialize( _Drive,
                                        CurrentVcn,
                                        _ClusterFactor * _Drive->QuerySectorSize(),
                                        _ClustersPerBuffer,
                                        _BufferSize,
                                        _CollationRule,
                                        _UpcaseTable ) ||
            !CurrentBuffer->Read( _AllocationAttribute ) ) {

            // An error has occurred.

            DELETE( CandidateBuffer );
            DELETE( CurrentBuffer );
            *Error = TRUE;
            return FALSE;
        }

        CurrentEntry = CurrentBuffer->GetFirstEntry();

        if( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
            GetDownpointer( CurrentEntry ) == INVALID_VCN ) {

            // This buffer is a leaf, so we will terminate the
            // search on this iteration.

            LeafFound = TRUE;

        } else {

            // This buffer is a node, so we're interested in
            // the child of its first entry.  We need to grab
            // this information before we throw the current
            // buffer out.

            CurrentVcn = GetDownpointer( CurrentEntry );
        }

        if( !(CurrentEntry->Flags & INDEX_ENTRY_END ) ) {

            // This buffer is non-empty, so its first entry
            // could be used as the replacement entry.

            DELETE( CandidateBuffer );
            CandidateBuffer = CurrentBuffer;
            CurrentBuffer = NULL;

        } else {

            // This buffer is empty, so all we want from it is
            // the downpointer (if any) from its first entry,
            // and that we've already got.

            DELETE( CurrentBuffer );
        }
    }

    DebugAssert( CurrentBuffer == NULL );

    if( CandidateBuffer == NULL ) {

        *Error = FALSE;
        return FALSE;

    } else {

        CandidateEntry = CandidateBuffer->GetFirstEntry();

        DebugAssert( !(CandidateEntry->Flags & INDEX_ENTRY_END) );

        // Copy the candidate entry into the replacement entry
        // buffer.

        memcpy( ReplacementEntry,
                CandidateEntry,
                CandidateEntry->Length );

        if( !(CandidateEntry->Flags & INDEX_ENTRY_NODE ) ||
            GetDownpointer( CandidateEntry ) == INVALID_VCN ) {

            // The replacement entry we found doesn't have a downpointer;
            // increase its size to hold one.

            ReplacementEntry->Length += sizeof( VCN );
            ReplacementEntry->Flags |= INDEX_ENTRY_NODE;

        } else {

            // The replacement entry we found was a node entry, which
            // means that all its child buffers are empty.  Return them
            // to the free pool.

            FreeChildren( CandidateEntry );
        }

        // Expunge the replacement entry from its former location,
        // and then write that buffer.
        //
        CandidateBuffer->RemoveEntry( CandidateEntry );
        CandidateBuffer->Write( _AllocationAttribute );

        // Check to see if this action created an empty leaf.
        //
        if( CandidateBuffer->IsLeaf() && CandidateBuffer->IsEmpty() ) {

            *EmptyLeaf = TRUE;
            *EmptyLeafVcn = CandidateBuffer->QueryVcn();

        } else {

            *EmptyLeaf = FALSE;
        }

        // All's well that ends well.

        DELETE(CandidateBuffer);

        return TRUE;
    }
}


BOOLEAN
NTFS_INDEX_TREE::FixupEmptyLeaf(
    IN VCN  EmptyLeafVcn
    )
/*++

Routine Description:

    This method tidies up the tree if an empty leaf allocation
    buffer has been created.

Arguments:

    EmptyLeafVcn    --  supplies the VCN of the empty leaf.

Return Value:

    TRUE upon successful completion.

--*/
{
    INTSTACK ParentTrail;
    NTFS_INDEX_BUFFER CurrentBuffer;
    VCN CurrentVcn, ChildVcn;
    BIG_INT AllocationValueLength;
    BOOLEAN Error = FALSE;
    BOOLEAN Result, IsRoot;
    PINDEX_ENTRY CurrentEntry, PreviousEntry, MovedEntry;
    ULONG i, NumberOfBuffers;

    // Find the buffer in question, and construct its parent trail.
    // If the buffer isn't in the tree, don't worry about it.
    //
    if( !ParentTrail.Initialize() ) {

        return FALSE;
    }

    if( !FindBuffer( EmptyLeafVcn,
                     NULL,
                     &CurrentBuffer,
                     &ParentTrail,
                     &Error ) ) {

        return !Error;
    }

    DebugAssert( CurrentBuffer.QueryVcn() == EmptyLeafVcn );

    if( !CurrentBuffer.IsEmpty() || !CurrentBuffer.IsLeaf() ) {

        // This buffer is not an empty leaf, so there's nothing
        // to do.
        //
        return TRUE;
    }

    // Crawl up the parent trail until we find a non-empty node.
    //
    ChildVcn = CurrentBuffer.QueryVcn();

    while( ParentTrail.QuerySize() != 0 && CurrentBuffer.IsEmpty() ) {

        ChildVcn = CurrentBuffer.QueryVcn();

        if (ChildVcn != INVALID_VCN) {
            FreeIndexBuffer(ChildVcn);
        }

        CurrentVcn = ParentTrail.Look();
        ParentTrail.Pop();

        if( !CurrentBuffer.Initialize( _Drive,
                                       CurrentVcn,
                                       _ClusterFactor * _Drive->QuerySectorSize(),
                                       _ClustersPerBuffer,
                                       _BufferSize,
                                       _CollationRule,
                                       _UpcaseTable ) ||
            !CurrentBuffer.Read( _AllocationAttribute ) ) {

            return FALSE;
        }
    }

    IsRoot = (CurrentBuffer.IsEmpty() && ParentTrail.QuerySize() == 0);
    if (IsRoot)
        ChildVcn = CurrentBuffer.QueryVcn();

    CurrentEntry = IsRoot ? _IndexRoot->GetFirstEntry() :
                            CurrentBuffer.GetFirstEntry();
    PreviousEntry = NULL;

    if( IsRoot && (CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        // This tree needs to be collapsed down to an
        // empty root.  Recreate the index root as an
        // empty leaf and free all the bits in the index
        // allocation bitmap.
        //
        _IndexRoot->Recreate( TRUE, 0 );

        _AllocationAttribute->QueryValueLength( &AllocationValueLength );

        NumberOfBuffers = AllocationValueLength.GetLowPart()/_BufferSize;

        for( i = 0; i < NumberOfBuffers; i++ ) {

            if (0 == _ClustersPerBuffer) {
                FreeIndexBuffer( i * (_BufferSize / 512) );
            } else {
                FreeIndexBuffer( i * _ClustersPerBuffer );
            }
        }

        return TRUE;
    }

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) &&
           ( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
             GetDownpointer( CurrentEntry ) != ChildVcn ) ) {

        PreviousEntry = CurrentEntry;
        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    if( GetDownpointer( CurrentEntry ) != ChildVcn ) {

        // Didn't find the parent entry, although this
        // buffer is in the parent trail.  Something is
        // corrupt.
        //
        return FALSE;
    }

    if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

        // Since we can't remove the end entry, we'll remove
        // its predecessor instead.  This means we have to
        // transfer the predecessor's downpointer to the end
        // entry.  (Note that this index block is not empty,
        // so the predecessor must exist.)
        //
        if( PreviousEntry == NULL ) {

            //
            // The CurrentBuffer is not empty so there must be a previous entry
            // If CurrentBuffer is empty, then this must be the root.  If it is
            // the root and it is empty, it would have been intercepted by the
            // empty root check earlier.  So, if it gets here, something is
            // wrong.

            return FALSE;
        }

        if( PreviousEntry->Flags & INDEX_ENTRY_NODE ) {

            GetDownpointer( CurrentEntry ) = GetDownpointer( PreviousEntry );

        } else {

            GetDownpointer( CurrentEntry ) = INVALID_VCN;
        }

        CurrentEntry = PreviousEntry;
    }

    // Copy the current entry into a temporary buffer
    // (stripping off its down-pointer, if any) and
    // delete it from the current buffer or root, as
    // appropriate.
    //
    MovedEntry = (PINDEX_ENTRY)MALLOC( CurrentEntry->Length );

    if( MovedEntry == NULL ) {

        return FALSE;
    }

    memcpy( MovedEntry,
            CurrentEntry,
            CurrentEntry->Length );

    if( MovedEntry->Flags & INDEX_ENTRY_NODE ) {

        if (ChildVcn != INVALID_VCN)
            FreeIndexBuffer( ChildVcn );

        MovedEntry->Flags &= ~INDEX_ENTRY_NODE;
        MovedEntry->Length -= sizeof( VCN );
    }

    if( IsRoot ) {

        _IndexRoot->RemoveEntry( CurrentEntry );

    } else {

        CurrentBuffer.RemoveEntry( CurrentEntry );
        CurrentBuffer.Write( _AllocationAttribute );
    }

    // Re-insert the entry into the tree.
    //
    Result = InsertEntry( MovedEntry, FALSE );

    FREE( MovedEntry );

    return Result;
}


BOOLEAN
NTFS_INDEX_TREE::FindBuffer(
    IN      VCN                 BufferVcn,
    IN      PNTFS_INDEX_BUFFER  ParentBuffer,
    OUT     PNTFS_INDEX_BUFFER  FoundBuffer,
    IN OUT  PINTSTACK           ParentTrail,
    OUT     PBOOLEAN            Error
    )
/*++

Routine Description:

    This method locates a buffer in the tree.

Arguments:

    BufferVcn       --  supplies the VCN of the desired buffer.
    ParentBuffer    --  supplies the buffer at which to begin the search.
                        If this parameter is NULL, the search starts
                        at the root.
    FoundBuffer     --  receives the buffer.
    ParentTrail     --  supplies the parent trail to ParentBuffer
                        (not including ParentBuffer itself).  Receives
                        the trail to the found buffer.  If the buffer
                        is not found, this object is restored to its
                        original state.
    Error           --  receives TRUE if the method fails because
                        of an error.  Undefined if the method succeeds.

Return Value:

    TRUE upon successful completion.  FoundBuffer is initialized to
    the desired buffer and read, and ParentTrail contains the trail
    to this buffer.

--*/
{
    NTFS_INDEX_BUFFER ChildBuffer;
    PINDEX_ENTRY CurrentEntry;
    BOOLEAN IsRoot;

    IsRoot = ( ParentBuffer == NULL );

    // Spin through the entries in this block to see if one of
    // them is the parent of the buffer we want.
    //
    CurrentEntry = IsRoot ? _IndexRoot->GetFirstEntry() :
                            ParentBuffer->GetFirstEntry();

    while( ( !(CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
             GetDownpointer( CurrentEntry ) != BufferVcn ) &&
           !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    if( (CurrentEntry->Flags & INDEX_ENTRY_NODE) &&
        GetDownpointer( CurrentEntry ) == BufferVcn ) {

        // We've found the one we want.  Add the current buffer (if any)
        // to the parent trail, initialize and read the child buffer,
        // and return.
        //
        if( !IsRoot && !ParentTrail->Push( ParentBuffer->QueryVcn() ) ) {

            *Error = TRUE;
            return FALSE;
        }

        if( !FoundBuffer->Initialize( _Drive,
                                      GetDownpointer( CurrentEntry ),
                                      _ClusterFactor * _Drive->QuerySectorSize(),
                                      _ClustersPerBuffer,
                                      _BufferSize,
                                      _CollationRule,
                                      _UpcaseTable ) ||
            !FoundBuffer->Read( _AllocationAttribute ) ) {

            *Error = TRUE;
            return FALSE;
        }

        DebugAssert( BufferVcn == FoundBuffer->QueryVcn() );
        return TRUE;
    }

    // This block is not the immediate parent of our desired
    // buffer.  Recurse into its children.
    //
    if( !IsRoot && !ParentTrail->Push( ParentBuffer->QueryVcn() ) ) {

        *Error = TRUE;
        return FALSE;
    }

    CurrentEntry = IsRoot ? _IndexRoot->GetFirstEntry() :
                            ParentBuffer->GetFirstEntry();

    while( TRUE ) {

        if( CurrentEntry->Flags & INDEX_ENTRY_NODE ) {

            // Initialize and read the child buffer and
            // recurse into it.
            //
            if( !ChildBuffer.Initialize(_Drive,
                                        GetDownpointer( CurrentEntry ),
                                        _ClusterFactor * _Drive->QuerySectorSize(),
                                        _ClustersPerBuffer,
                                        _BufferSize,
                                        _CollationRule,
                                        _UpcaseTable ) ||
                 !ChildBuffer.Read( _AllocationAttribute ) ) {

                *Error = TRUE;
                return FALSE;
            }

            if( FindBuffer( BufferVcn,
                            &ChildBuffer,
                            FoundBuffer,
                            ParentTrail,
                            Error ) ) {

                // Found it in this subtree.
                //
                return TRUE;

            } else if ( *Error ) {

                return FALSE;
            }
        }

        if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

            break;
        }

        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    // This block is not an ancestor of the desired buffer.
    // Remove it from the parent trail (if it's a buffer ) and
    // report its failure.
    //
    if( !IsRoot ) {

        DebugAssert( ParentBuffer->QueryVcn() == ParentTrail->Look() );
        ParentTrail->Pop();
    }

    return FALSE;
}


BOOLEAN
NTFS_INDEX_TREE::InsertIntoRoot(
    PCINDEX_ENTRY   NewEntry,
    PINDEX_ENTRY    InsertionPoint
    )
/*++

Routine Description:

    This method attempts to insert an entry into the Index Root
    attribute.  If necessary, it will twiddle the index b-tree.

Arguments:

    NewEntry        --  supplies the new index entry
    InsertionPoint  --  supplies a pointer to the point in the root
                        where the entry should be inserted, if known.
                        This must be a pointer that was returned by a
                        call to _IndexRoot->FindEntry (with no intervening
                        inserts or deletes).  This parameter may be NULL.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_INDEX_BUFFER NewBuffer;
    INTSTACK ParentTrail;
    VCN NewBufferVcn;
    ULONG BytesToMove;
    PINDEX_ENTRY CurrentEntry;

    // Try the easy case--NTFS_INDEX_ROOT::InsertEntry will succeed
    // if there's room in the root for the new entry.

    if( _IndexRoot->InsertEntry( NewEntry, InsertionPoint ) ) {

        return TRUE;
    }

    //  We didn't get away with the easy case.  Instead, we have to
    //  push the entries that are currently in the index root down
    //  into an index allocation buffer.  Here's the plan:
    //
    //      If we don't have an allocation attribute, create one.
    //      Allocate a new index buffer.
    //      Create it as an empty buffer.  If the root is currently
    //          a leaf, this new buffer becomes a leaf; if not, not.
    //      Move all the index entries that are in the root to the
    //          new buffer
    //      Recreate the root as an empty node, and set the downpointer
    //          of its END entry to point at the new buffer.

    if( _AllocationAttribute == NULL &&
        !CreateAllocationAttribute() ) {

        // Can't create an allocation attribute.
        return FALSE;
    }


    // Allocate and initialize the new buffer.  Postpone creating it
    // until we know what to give it as an end-entry downpointer

    if( !AllocateIndexBuffer( &NewBufferVcn ) ) {

        return FALSE;
    }

    if( !NewBuffer.Initialize( _Drive,
                               NewBufferVcn,
                               _ClusterFactor * _Drive->QuerySectorSize(),
                               _ClustersPerBuffer,
                               _BufferSize,
                               _CollationRule,
                               _UpcaseTable ) ) {

        FreeIndexBuffer( NewBufferVcn );
    }


    // Now copy all the non-end entries from the index root to
    // the new buffer.

    BytesToMove = 0;

    CurrentEntry = _IndexRoot->GetFirstEntry();

    while( !(CurrentEntry->Flags & INDEX_ENTRY_END) ) {

        BytesToMove += CurrentEntry->Length;
        CurrentEntry = GetNextEntry( CurrentEntry );
    }

    // OK, now we can create the new buffer and copy the entries into
    // it.

    if( CurrentEntry->Flags & INDEX_ENTRY_NODE &&
        GetDownpointer( CurrentEntry ) != INVALID_VCN ) {

        // Give the new buffer's end entry the downpointer from the
        // root's end entry.

        NewBuffer.Create( FALSE, GetDownpointer( CurrentEntry ) );

    } else {

        // The new buffer is a leaf.

        NewBuffer.Create( TRUE, 0 );
    }

    NewBuffer.InsertClump( BytesToMove,
                           _IndexRoot->GetFirstEntry() );

    NewBuffer.Write( _AllocationAttribute );


    // Recreate the index root as an empty node.  This will wipe out the
    // old end entry, which is OK.  (If it had a downpointer, we passed
    // that value to the new buffer's end entry; if not, then it didn't
    // have any interesting information.)

    _IndexRoot->Recreate( FALSE, NewBufferVcn );

    // Set up an empty stack for the parent trail (since the new
    // buffer's parent is the root) and insert the new entry into
    // the new leaf buffer.

    return( ParentTrail.Initialize() &&
            InsertIntoBuffer( &NewBuffer, &ParentTrail, NewEntry ) );
}


BOOLEAN
NTFS_INDEX_TREE::InsertIntoBuffer(
    IN OUT PNTFS_INDEX_BUFFER  TargetBuffer,
    IN OUT PINTSTACK           ParentTrail,
    IN     PCINDEX_ENTRY       NewEntry,
    IN     PINDEX_ENTRY        InsertionPoint
    )
/*++

Routine Description:

    This method attempts to insert an entry into an Index
    Allocation Buffer.  If necessary, it will split the buffer.

Arguments:

    TargetBuffer    --  supplies the buffer that will receive the
                        new entry.
    ParentTrail     --  supplies the parent trail (ie. stack of VCNs
                        of all buffers between here and root) of the
                        target buffer.  If this stack is empty, then
                        the parent of the buffer is the root.
    NewEntry        --  supplies the new index entry
    InsertionPoint  --  supplies a pointer to the point in the root
                        where the entry should be inserted, if known.
                        This must be a pointer that was returned by a
                        call to TargetBuffer->FindEntry (with no
                        intervening inserts or deletes).  This parameter
                        may be NULL.

Return Value:

    TRUE upon successful completion.

Notes:

    This method may consume ParentTrail.  The client should not rely
    on the state of ParentTrail after this method returns.

--*/
{
    PINDEX_ENTRY PromotionBuffer;
    PINDEX_ENTRY SplitPoint;
    NTFS_INDEX_BUFFER NewBuffer, ParentBuffer;
    VCN NewBufferVcn, ParentVcn;
    ULONG BytesToCopy, BytesToRemove;
    BOOLEAN Result;
    int CompareResult;

    // Try the easy way first--NTFS_INDEX_BUFFER will succeed if
    // there's enough room in the buffer to accept this entry.

    if( TargetBuffer->InsertEntry( NewEntry, InsertionPoint ) ) {

        return( TargetBuffer->Write( _AllocationAttribute ) );
    }

    //  We didn't get away with the easy case; instead, we have to
    //  split this index buffer.

    //  Allocate a new index allocation buffer.

    if( !AllocateIndexBuffer( &NewBufferVcn ) ) {

        return FALSE;
    }

    if( !NewBuffer.Initialize( _Drive,
                               NewBufferVcn,
                               _ClusterFactor * _Drive->QuerySectorSize(),
                               _ClustersPerBuffer,
                               _BufferSize,
                               _CollationRule,
                               _UpcaseTable ) ) {

        FreeIndexBuffer( NewBufferVcn );
        return FALSE;
    }

    // Find the split point in the buffer we want to split.  This
    // entry will be promoted into the parent; the entries after it
    // stay in this buffer, while the entries before it go into the
    // new buffer.  The new buffer will become the child of the promoted
    // entry.

    SplitPoint = TargetBuffer->FindSplitPoint();

    PromotionBuffer = (PINDEX_ENTRY)MALLOC( TargetBuffer->QuerySize() );

    if( PromotionBuffer == NULL ) {

        FreeIndexBuffer( NewBufferVcn );
        return FALSE;
    }

    memcpy( PromotionBuffer,
            SplitPoint,
            SplitPoint->Length );

    if( TargetBuffer->IsLeaf() ) {

        PromotionBuffer->Flags |= INDEX_ENTRY_NODE;
        PromotionBuffer->Length += sizeof(VCN);
        NewBuffer.Create( TRUE, 0 );

    } else {

        NewBuffer.Create( FALSE, GetDownpointer(PromotionBuffer) );
    }

    GetDownpointer( PromotionBuffer ) = NewBufferVcn;


    // OK, copy all the entries before the split point into the
    // new buffer.

    BytesToCopy = (ULONG)((PBYTE)SplitPoint - (PBYTE)(TargetBuffer->GetFirstEntry()));

    NewBuffer.InsertClump( BytesToCopy, TargetBuffer->GetFirstEntry() );


    //  Now shift the remaining entries down, and adjust the target
    //  buffer's FirstFreeByte field by the number of bytes we moved
    //  to the new buffer.

    BytesToRemove = BytesToCopy + SplitPoint->Length;

    TargetBuffer->RemoveClump( BytesToRemove );


    // Now we decide which buffer gets the new entry, and insert it.
    // If it's less than the promoted entry, it goes in the new buffer;
    // otherwise, it goes in the original buffer.

    CompareResult = CompareNtfsIndexEntries( NewEntry,
                                             PromotionBuffer,
                                             _CollationRule,
                                             _UpcaseTable );

    //
    // Either of the buffer should now be large enough for the new entry
    //

    if( CompareResult < 0 ) {

        if (!NewBuffer.InsertEntry( NewEntry )) {
            FREE(PromotionBuffer);
            DebugAbort("Unable to insert the new entry into the new buffer.\n");
            return FALSE;
        }

    } else {

        if (!TargetBuffer->InsertEntry( NewEntry )) {
            FREE(PromotionBuffer);
            DebugAbort("Unable to insert the new entry into the target buffer.\n");
            return FALSE;
        }
    }

    if (!TargetBuffer->Write( _AllocationAttribute ) ||
        !NewBuffer.Write( _AllocationAttribute )) {
        FREE(PromotionBuffer);
        DebugAbort("Unable to write out the contents of the buffers\n");
        return FALSE;
    }

    // OK, we've finished splitting everybody, so we are ready to
    // insert the promoted entry into the parent.

    if( ParentTrail->QuerySize() == 0 ) {

        // The parent of the target buffer is the root.

        Result = InsertIntoRoot( PromotionBuffer );

    } else {

        // The target buffer's parent is another buffer, and its
        // VCN is on top of the ParentTrail stack.  Get that VCN,
        // and then pop the stack so we can pass it to the parent
        // buffer.  (Popping it makes it the parent trail of the
        // parent buffer.)

        ParentVcn = ParentTrail->Look();
        ParentTrail->Pop();

        Result = ( ParentBuffer.Initialize( _Drive,
                                            ParentVcn,
                                            _ClusterFactor * _Drive->QuerySectorSize(),
                                            _ClustersPerBuffer,
                                            _BufferSize,
                                            _CollationRule,
                                            _UpcaseTable ) &&
                   ParentBuffer.Read( _AllocationAttribute ) &&
                   InsertIntoBuffer( &ParentBuffer,
                                     ParentTrail,
                                     PromotionBuffer ) );
    }

    FREE( PromotionBuffer );
    return Result;
}




BOOLEAN
NTFS_INDEX_TREE::AllocateIndexBuffer(
    OUT PVCN    NewBufferVcn
    )
/*++

Routine Description:

    This method allocates an index allocation buffer from the index
    allocation attribute.  It first checks the bitmap, to see if any
    are free; if there are none free in the bitmap, it adds a new
    index buffer to the end of the allocation attribute.

Arguments:

    NewBuffer   -- receives the VCN of the new buffer.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT ValueLength;
    VCN NewBufferNumber;
    ULONG NumberOfBuffers;


    DebugPtrAssert( _AllocationAttribute != NULL &&
                  _IndexAllocationBitmap != NULL );

    _AllocationAttribute->QueryValueLength( &ValueLength );

    DebugAssert( ValueLength % _BufferSize == 0 );

    NumberOfBuffers = ValueLength.GetLowPart()/_BufferSize;

    // First, check the bitmap.  Allocate as close to the beginning
    // as possible (hence use 0 for the NearHere parameter).

    if( _IndexAllocationBitmap->AllocateClusters( 0,
                                                  1,
                                                  &NewBufferNumber ) ) {

        //  Found a free one in the bitmap--return it.

        DebugPrint( "Buffer allocated from index allocation bitmap.\n" );

        if (0 == _ClustersPerBuffer) {
            *NewBufferVcn = NewBufferNumber * (_BufferSize / 512) ;
        } else {
            *NewBufferVcn = NewBufferNumber * _ClustersPerBuffer;
        }
        return TRUE;
    }


    //  There are no free buffers in the index allocation attribute,
    //  so I have to add one.

    NewBufferNumber = NumberOfBuffers;
    NumberOfBuffers += 1;

    //  Grow the allocation attribute by one buffer:

    if( !_AllocationAttribute->Resize( ValueLength + _BufferSize, _VolumeBitmap ) ) {

        return FALSE;
    }


    //  Grow the index allocation bitmap (if necessary) to cover the
    //  current size of the index allocation attributes.

    if( !_IndexAllocationBitmap->Resize( NumberOfBuffers ) ) {

        //  Couldn't resize the bitmap--truncate the allocation attribute
        //  back to its original size and return failure.

        _AllocationAttribute->Resize( ValueLength, _VolumeBitmap );
        return FALSE;
    }

    //  Mark the new buffer as allocated and return it.

    _IndexAllocationBitmap->SetAllocated( NewBufferNumber, 1 );

    if (0 == _ClustersPerBuffer) {

        // The buffers are indexed by their block offset, where each block
        // in the allocation is 512 bytes.
        //

        *NewBufferVcn = NewBufferNumber * (_BufferSize / NTFS_INDEX_BLOCK_SIZE);

    } else {
        *NewBufferVcn = NewBufferNumber * _ClustersPerBuffer;
    }

    return TRUE;
}



VOID
NTFS_INDEX_TREE::FreeIndexBuffer(
    IN VCN BufferVcn
    )
/*++

Routine Description:

    This method adds a buffer, identified by VCN, to the free
    buffer list.

Arguments:

    BufferVcn   --  supplies the VCN of the buffer to free.

Return Value:

    None.

--*/
{
    if (0 == _ClustersPerBuffer) {
        _IndexAllocationBitmap->SetFree( BufferVcn, _BufferSize/512 );
    } else {
        _IndexAllocationBitmap->SetFree( BufferVcn/_ClustersPerBuffer, 1 );
    }
}



VOID
NTFS_INDEX_TREE::FreeChildren(
    IN PINDEX_ENTRY IndexEntry
    )
/*++

Routine Description:

Arguments:

    IndexEntry  -- supplies the entry whose children are to be marked as
                   free.

Return Value:

    None.

Notes:

    This method assumes that the tree is consistent.

    IndexEntry must be a node entry.

--*/
{
    VCN CurrentVcn;
    NTFS_INDEX_BUFFER ChildBuffer;
    PINDEX_ENTRY CurrentEntry;


    CurrentVcn = GetDownpointer( IndexEntry );

    if( !ChildBuffer.Initialize( _Drive,
                                 CurrentVcn,
                                 _ClusterFactor * _Drive->QuerySectorSize(),
                                 _ClustersPerBuffer,
                                 _BufferSize,
                                 _CollationRule,
                                 _UpcaseTable ) ||
        !ChildBuffer.Read( _AllocationAttribute ) ) {

        return;
    }

    // First, recurse into the children, if any.

    if( !ChildBuffer.IsLeaf() ) {

        CurrentEntry = ChildBuffer.GetFirstEntry();

        while( TRUE ) {

            FreeChildren( CurrentEntry );

            if( CurrentEntry->Flags & INDEX_ENTRY_END ) {

                break;
            }

            CurrentEntry = GetNextEntry( CurrentEntry );
        }
    }

    // We've gotten rid of the children; add this buffer to the
    // free list.

    FreeIndexBuffer( CurrentVcn );

    return;
}



ULONG
NTFS_INDEX_TREE::QueryMaximumEntrySize(
    ) CONST
/*++

Routine Description:

    This method returns the maximum size buffer needed to hold an
    index entry from this index.

Arguments

    None.

Return Value:

    None.

Notes:

    The maximum entry size must be less than the buffer size for
    the allocation buffers in the tree (since an entry must fit
    into a buffer), so we'll return the index allocation buffer size.

--*/
{
    return( _BufferSize );
}



BOOLEAN
NTFS_INDEX_TREE::CreateAllocationAttribute(
    )
/*++

Routine Description:

    This method creates an allocation attribute.  This attribute is
    an empty, nonresident attribute.  This method also creates an
    index allocation bitmap associated with this index allocation
    attribute.

Arguments:

    None.

Return value:

    TRUE upon successful completion.  Note that if this method succeeds,
    the private member data _AllocationAttribute is set to point at the
    newly-created attribute and _IndexAllocationBitmap is set to point
    at the newly-created bitmap.

--*/
{
    PNTFS_ATTRIBUTE NewAttribute;
    PNTFS_BITMAP NewBitmap;
    NTFS_EXTENT_LIST Extents;

    DebugAssert(0 != _ClusterFactor);


    // Create an empty extent list.

    if( !Extents.Initialize( (ULONG)0, (ULONG)0 ) ) {

        return FALSE;
    }


    // Construct an index allocation attribute and initialize
    // it with this extent list.

    if( (NewAttribute = NEW NTFS_ATTRIBUTE) == NULL ||
        !NewAttribute->Initialize( _Drive,
                                   _ClusterFactor,
                                   &Extents,
                                   0,
                                   0,
                                   $INDEX_ALLOCATION,
                                   _Name ) ) {

        DebugPrint( "CreateAllocationAttribute--Cannot create index allocation attribute.\n" );

        DELETE( NewAttribute );
        return FALSE;
    }

    // Create a new bitmap.  Initialize it to cover zero allocation units,
    // and indicate that it is growable.

    if( (NewBitmap = NEW NTFS_BITMAP) == NULL ||
        !NewBitmap->Initialize( 0, TRUE ) ) {

        DebugPrint( "CreateAllocationAttribute--Cannot create index allocation bitmap.\n" );

        DELETE( NewAttribute );
        DELETE( NewBitmap );
        return FALSE;
    }

    _AllocationAttribute = NewAttribute;
    _IndexAllocationBitmap = NewBitmap;

    return TRUE;
}



BOOLEAN
NTFS_INDEX_TREE::InvalidateIterator(
    )
/*++

Routine Description:

    This method sets the tree's associated iterator into the invalid
    state.  This means that instead of caching a pointer to the current
    entry and the buffer that contains it, the iterator caches the
    information necessary to locate the current entry.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    // If the iterator is already reset, invalid, deleted, or corrupt,
    // then this method is a no-op.  In particular, the state of the
    // iterator is unchanged.

    if( _IteratorState == INDEX_ITERATOR_RESET ||
        _IteratorState == INDEX_ITERATOR_INVALID ||
        _IteratorState == INDEX_ITERATOR_DELETED ||
        _IteratorState == INDEX_ITERATOR_CORRUPT ) {

        return TRUE;
    }

    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );

    // Clean up the current entry and current buffer pointers.
    //
    _CurrentEntry = NULL;
    DELETE( _CurrentBuffer );

    _IteratorState = INDEX_ITERATOR_INVALID;

    return TRUE;
}


UNTFS_EXPORT
VOID
NTFS_INDEX_TREE::ResetIterator(
    )
/*++

Routine Description:

    This method sets the iterator into the RESET state, so that the
    next call to GetNext will return the first entry in the index.

Arguments:

    None.

Return value:

    None.

--*/
{
    // Clean up the current buffer and current entry pointers and
    // set the state appropriately.

    _CurrentEntry = NULL;
    DELETE( _CurrentBuffer );

    _IteratorState = INDEX_ITERATOR_RESET;

}


BOOLEAN
NTFS_INDEX_TREE::GetNextLeafEntry(
    )
/*++

Routine Description:

    This method is a helper function for GetNext.  It advances
    _CurrentEntry to the next leaf entry, adjusting the other
    private data as appropriate.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

Notes:

    This method should only be called if _CurrentEntry points at
    a valid node entry.

--*/
{
    DebugPtrAssert( _CurrentEntry );
    DebugAssert( _CurrentEntry->Flags & INDEX_ENTRY_NODE );
    DebugAssert( _IsCurrentEntryInRoot || _CurrentBuffer != NULL );


    while( _CurrentEntry->Flags & INDEX_ENTRY_NODE &&
           GetDownpointer( _CurrentEntry ) != INVALID_VCN ) {

        DebugPtrAssert( _AllocationAttribute );

        if( _CurrentBuffer == NULL &&
            (_CurrentBuffer = NEW NTFS_INDEX_BUFFER) == NULL ) {

            DebugAbort( "Can't construct index allocation buffer object.\n" );
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

        // If the current entry is in a buffer, record that buffer in
        // the trail before recursing into the child.

        if( !_IsCurrentEntryInRoot &&
            !_CurrentEntryTrail.Push( _CurrentBuffer->QueryVcn() ) ) {

            DebugAbort( "Parent Trail stack failure.\n" );
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

        // Initialize and read the child and take its first entry
        // for the current entry.

        if( !_CurrentBuffer->Initialize( _Drive,
                                         GetDownpointer( _CurrentEntry ),
                                         _ClusterFactor * _Drive->QuerySectorSize(),
                                         _ClustersPerBuffer,
                                         _BufferSize,
                                         _CollationRule,
                                         _UpcaseTable )) {

            DebugPrint("Can't init alloc buffer\n");
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

        if (!_CurrentBuffer->Read( _AllocationAttribute ) ) {

            DebugPrint( "Can't read allocation buffer.\n" );
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

        _IsCurrentEntryInRoot = FALSE;
        _CurrentEntry = _CurrentBuffer->GetFirstEntry();
    }


    return TRUE;
}


BOOLEAN
NTFS_INDEX_TREE::GetNextParent(
    )
/*++

Routine Description:

    This method is a helper function for GetNextUnfiltered.  It
    backtracks up the current entry's parent trail one level.

Arguments

    None.

Return Value:

    TRUE upon successful completion.  Private data for the iterator
    are adjusted appropriately.

Notes:

    This method should only be called if _CurrentEntry is valid.

--*/
{
    VCN CurrentVcn, ChildVcn;

    DebugPtrAssert( _CurrentEntry );
    DebugAssert( _IsCurrentEntryInRoot || _CurrentBuffer != NULL );

    if( !_IsCurrentEntryInRoot ) {

        DebugPtrAssert( _CurrentBuffer );
        DebugPtrAssert( _AllocationAttribute );

        ChildVcn = _CurrentBuffer->QueryVcn();

        if( _CurrentEntryTrail.QuerySize() == 0 ) {

            // The parent of the current buffer is the root.

            _CurrentEntry = _IndexRoot->GetFirstEntry();
            _IsCurrentEntryInRoot = TRUE;

        } else {

            // Get the VCN of the current buffer's parent from the
            // trail, and then pop the trail to reflect the fact
            // that we're going up a level in the tree.

            CurrentVcn = _CurrentEntryTrail.Look();
            _CurrentEntryTrail.Pop();

            if( !_CurrentBuffer->Initialize( _Drive,
                                             CurrentVcn,
                                             _ClusterFactor * _Drive->QuerySectorSize(),
                                             _ClustersPerBuffer,
                                             _BufferSize,
                                             _CollationRule,
                                             _UpcaseTable ) ||
                !_CurrentBuffer->Read( _AllocationAttribute ) ) {

                DebugAbort( "Can't find read/initialize buffer.\n" );
                _CurrentEntry = NULL;
                _IteratorState = INDEX_ITERATOR_CORRUPT;
                return FALSE;
            }

            _CurrentEntry = _CurrentBuffer->GetFirstEntry();
            _IsCurrentEntryInRoot = FALSE;
        }

        // Spin through the entries in this block (whether the root
        // or a buffer) until we find the entry which is the parent
        // of our child, or run out of entries, or both.

        while( !(_CurrentEntry->Flags & INDEX_ENTRY_END) &&
               ( !(_CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
                 !(GetDownpointer( _CurrentEntry ) == ChildVcn) ) ) {

            _CurrentEntry = GetNextEntry( _CurrentEntry );
        }

        if( !(_CurrentEntry->Flags & INDEX_ENTRY_NODE) ||
            !(GetDownpointer( _CurrentEntry ) == ChildVcn) ) {

            // Didn't find the parent.
            DebugAbort( "Can't find read/initialize buffer.\n" );
            _CurrentEntry = NULL;
            _IteratorState = INDEX_ITERATOR_CORRUPT;
            return FALSE;
        }

    } else {

        // Trying to get the parent when we're already in the
        // root isn't very meaningful.
        //
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
PCINDEX_ENTRY
NTFS_INDEX_TREE::GetNext(
    OUT PULONG      Depth,
    OUT PBOOLEAN    Error,
    IN  BOOLEAN     FilterEndEntries
    )
/*++

Routine Description:

    This method bumps the iterator forward and gets the next entry.

Arguments:

    Depth               --  Receives the depth in the tree of the
                            returned entry; 0 indicates the root.
    Error               --  Receives TRUE if this method fails because
                            of error.
    FilterEndEntries    --  Supplies a flag which indicates whether
                            entries with the INDEX_ENTRY_END flag
                            should be filtered.  If this parameter is
                            TRUE, this method will not return such
                            entries to the client.

Return Value:

    Returns a pointer to the next entry, or NULL if there are no more
    or an error occurs.

    If this method returns a non-NULL pointer, the value of *Error should
    be ignored.

--*/
{
    PCINDEX_ENTRY Result;

    Result = GetNextUnfiltered( Depth, Error );

    if( FilterEndEntries ) {

        // The client doesn't want to see END entries; keep
        // trying until we find a non-end entry or run out.
        //
        while( Result != NULL && Result->Flags & INDEX_ENTRY_END ) {

            Result = GetNextUnfiltered( Depth, Error );
        }
    }

    return Result;

}

UNTFS_EXPORT
BOOLEAN
NTFS_INDEX_TREE::CopyIterator(
    IN  PNTFS_INDEX_TREE    Index
    )
/*++

Routine Description:

    This method copies down the iterator state so that it can start at
    that state later on.  The size of the Buffer must be large enough
    to accomodate all the data.

    NOTE: This routine must be used in pairs due to the ReverseCopy trick.

Arguments:

    Index      --  Supplies the index to be copied.

Return Value:

    N/A

--*/
{
    DebugPtrAssert(Index);

    if ((_IteratorState = Index->_IteratorState) != INDEX_ITERATOR_RESET) {

        _Drive = Index->_Drive;
        _IsCurrentEntryInRoot = Index->_IsCurrentEntryInRoot;
        _CurrentKeyOrdinal = Index->_CurrentKeyOrdinal;
        _CurrentKeyLength = Index->_CurrentKeyLength;
        _CurrentKeyMaxLength = Index->_CurrentKeyMaxLength;

        if (Index->_CurrentBuffer) {
            if(_CurrentBuffer == NULL &&
               ((_CurrentBuffer = NEW NTFS_INDEX_BUFFER) == NULL)) {
                Destroy();
                return FALSE;
            }
            if (!_CurrentBuffer->Copy(Index->_CurrentBuffer, _Drive)) {
                Destroy();
                return FALSE;
            }
            if (Index->_CurrentEntry) {
                _CurrentEntry = (PINDEX_ENTRY)
                                 ((PCHAR)Index->_CurrentEntry -
                                 (PCHAR)Index->_CurrentBuffer->GetData() +
                                 (PCHAR)_CurrentBuffer->GetData());
            }
        }

        if (Index->_CurrentKey) {
            if (_CurrentKey == NULL &&
                (_CurrentKey = MALLOC(_CurrentKeyMaxLength)) == NULL) {
                Destroy();
                return FALSE;
            }
            memcpy(_CurrentKey, Index->_CurrentKey, _CurrentKeyLength);
        }

        if (!_CurrentEntryTrail.Initialize() ||
            !_CurrentEntryTrail.ReverseCopy(&(Index->_CurrentEntryTrail))) {
            Destroy();
            return FALSE;
        }
    }
    return TRUE;
}


PCINDEX_ENTRY
NTFS_INDEX_TREE::GetNextUnfiltered(
    OUT PULONG      Depth,
    OUT PBOOLEAN    Error
    )
/*++

Routine Description:

    This method bumps the iterator forward and gets the next entry.

Arguments:

    Depth    --  Receives the depth in the tree of the returned entry;
                 0 indicates the root.
    Error    --  Receives TRUE if this method fails because of error.

Return Value:

    Returns a pointer to the next entry, or NULL if there are no more
    or an error occurs.

    If this method returns a non-NULL pointer, the value of *Error should
    be ignored.

--*/
{
    DebugPtrAssert( Error );

    switch( _IteratorState ) {

    case INDEX_ITERATOR_CORRUPT :

        DebugPrint( "Index iterator is corrupt." );
        *Error = TRUE;
        return NULL;

    case INDEX_ITERATOR_RESET :


        // We want to get the first entry in the tree.  The easiest way
        // to do this is to start at the first entry in the root, drop
        // down to the the next leaf, and then bounce back up until
        // we find a non-end entry (which might be the leaf itself).
        // Since we're starting a search, reinitialize the parent
        // trail, too.
        //
        if( !_CurrentEntryTrail.Initialize() ) {

            DebugPrint( "UNTFS: Can't initialize intstack.\n" );
            *Error = TRUE;
            return NULL;
        }

        _CurrentEntry = _IndexRoot->GetFirstEntry();
        _IsCurrentEntryInRoot = TRUE;

        // If the current entry isn't a leaf, drop down 'til we
        // find a leaf entry.

        if( (_CurrentEntry->Flags & INDEX_ENTRY_NODE) &&
            GetDownpointer( _CurrentEntry ) != INVALID_VCN &&
            !GetNextLeafEntry()  ) {

            // GetNextLeafEntry cleans up the private data appropriately.
            *Error = TRUE;
            return NULL;
        }

        // We've got the first entry in the index--return it.
        // (Note that it may be an END entry).
        //
        _IteratorState = INDEX_ITERATOR_CURRENT;
        UpdateOrdinal();
        SaveCurrentKey();
        *Depth = QueryCurrentEntryDepth();
        *Error = FALSE;
        return _CurrentEntry;


    case INDEX_ITERATOR_INVALID :

        // We have the information necessary to find the current
        // entry, rather than the current entry itself.  Incrementing
        // _CurrentKeyOrdinal will give us the information needed
        // to find the next entry, and then we fall through into
        // the INDEX_ITERATOR_DELETED case.

        if( _CurrentEntry->Flags & INDEX_ENTRY_END ) {

            *Error = TRUE;
            return NULL;
        }

        _CurrentKeyOrdinal++;

        // Fall through to INDEX_ITERATOR_DELETED:

    case INDEX_ITERATOR_DELETED :

        // We have the information necessary to find the next entry,
        // so let's find it!
        //
        if( _CurrentKeyLength == 0 ) {

            *Error = TRUE;
            return NULL;
        }

        if( FindEntry( _CurrentKeyLength,
                       _CurrentKey,
                       _CurrentKeyOrdinal,
                       &_CurrentEntry,
                       &_CurrentBuffer,
                       &_CurrentEntryTrail ) ||
            _CurrentEntry != NULL ) {

            // We got an entry--return it.  Note that it
            // may be an END entry.
            //
            _IsCurrentEntryInRoot = (_CurrentBuffer == NULL);
            _IteratorState = INDEX_ITERATOR_CURRENT;
            UpdateOrdinal();
            SaveCurrentKey();
            *Depth = QueryCurrentEntryDepth();
            *Error = FALSE;
            return _CurrentEntry;

        } else {

            // An error occurred--this iterator is hosed.

            _IteratorState = INDEX_ITERATOR_CORRUPT;
            DELETE( _CurrentBuffer );
            *Error = TRUE;
            return NULL;
        }

    case INDEX_ITERATOR_CURRENT :

        // _CurrentEntry is valid.
        //
        if( !(_CurrentEntry->Flags & INDEX_ENTRY_END) ) {

            // There are more entries in this block.  Move on
            // to the next one: if it's a node, get its first
            // descendant; otherwise, we'll take that entry
            // itself.
            //
            _CurrentEntry = GetNextEntry( _CurrentEntry );

            if( _CurrentEntry->Flags & INDEX_ENTRY_NODE &&
                GetDownpointer( _CurrentEntry ) != INVALID_VCN ) {

                // This entry is a node; we want to return
                // all its descendants before returning it.
                //
                if( !GetNextLeafEntry() ) {

                    // GetNextLeafEntry cleans up the
                    // private data as needed.
                    //
                    *Error = TRUE;
                    return NULL;
                }
            }

            UpdateOrdinal();
            SaveCurrentKey();
            *Depth = QueryCurrentEntryDepth();
            *Error = FALSE;
            return _CurrentEntry;

        } else if( !_IsCurrentEntryInRoot ) {

            // There are no more entries in this block,
            // so we should return the parent of this block.
            // Note that GetNextParent sets up the information
            // about depth.
            //
            if( !GetNextParent() ) {

                // GetNextParent cleans up the private data
                // if it fails.
                //
                *Error = TRUE;
                return NULL;
            }

            UpdateOrdinal();
            SaveCurrentKey();
            *Depth = QueryCurrentEntryDepth();
            *Error = FALSE;
            return _CurrentEntry;

        } else {

            // There are no more entries in this block, and
            // it's the root (so it doesn't have a parent).
            // We're done!
            //
            *Error = FALSE;
            return NULL;
        }
    }

    return NULL;  // Keep the compiler happy.
}



BOOLEAN
NTFS_INDEX_TREE::DeleteCurrentEntry(
    )
/*++

Routine Description:

    This method deletes the entry which is the iterator's current entry.
    It also adjusts the iterator so that the next call to GetNext will
    return the entry after the one that got deleted.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    BOOLEAN Result;

    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );
    DebugPtrAssert( _CurrentEntry );
    DebugAssert( _IsCurrentEntryInRoot || _CurrentBuffer != NULL );

    if( _IteratorState != INDEX_ITERATOR_CURRENT ||
        _CurrentEntry->Flags & INDEX_ENTRY_END ) {

        return FALSE;
    }

    // The information we need to find the current entry again (which
    // is also the information we need to find the next entry after
    // we delete this entry) has been safely squirreled away by
    // GetNext.
    //
    // RemoveEntry requires the ContainingBuffer parameter to be
    // NULL if the target entry is in the root.

    if( _IsCurrentEntryInRoot ) {

        DELETE( _CurrentBuffer );
    }

    Result = RemoveEntry( _CurrentEntry,
                          _CurrentBuffer,
                          &_CurrentEntryTrail );

    // Note that RemoveEntry renders the current entry location
    // invalid.

    _CurrentEntry = NULL;
    DELETE( _CurrentBuffer );

    _IteratorState = INDEX_ITERATOR_DELETED;

    return Result;
}


BOOLEAN
NTFS_INDEX_TREE::WriteCurrentEntry(
    )
/*++

Routine Description:

    This method commits the current entry (and the index block containing
    it).  Note that it is provided for use at the client's risk.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );
    DebugPtrAssert( _CurrentEntry );
    DebugAssert( _IsCurrentEntryInRoot || _CurrentBuffer != NULL );

    if( _IteratorState != INDEX_ITERATOR_CURRENT ) {

        return FALSE;
    }

    // If the current entry is in the root, then there's no work
    // to be done; any changes to the current entry will be written
    // to disk when the index tree is saved.
    //
    if( !_IsCurrentEntryInRoot ) {

        return( _CurrentBuffer->Write( _AllocationAttribute ) );
    }

    return TRUE;  // If the current entry is in the root then write
                  // is a no-op.
}


VOID
NTFS_INDEX_TREE::UpdateOrdinal(
    )
/*++

Routine Description:

    This method is called when a the iterator advances _CurrentEntry
    to the next entry, in order to determine the correct value of
    _CurrentKeyOrdinal.  If the key value of the new _CurrentEntry
    is the same as the saved value, then _CurrentKeyOrdinal is
    incremented; otherwise, it is set to zero.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );
    DebugAssert( _CurrentEntry->AttributeLength <= _CurrentKeyMaxLength );
    DebugPtrAssert( _CurrentKey );
    DebugPtrAssert( _CurrentEntry );

    if( !(_CurrentEntry->Flags & INDEX_ENTRY_END) &&
        _CurrentKeyLength == _CurrentEntry->AttributeLength &&
        memcmp( _CurrentKey,
                GetIndexEntryValue( _CurrentEntry ),
                _CurrentEntry->AttributeLength ) == 0 ) {

        _CurrentKeyOrdinal += 1;

    } else {

        _CurrentKeyOrdinal = 0;
    }
}


VOID
NTFS_INDEX_TREE::SaveCurrentKey(
    )
/*++

Routine Description:

    This method squirrels away the information we need to find
    the current key.

Arguments:

    None.

Return value:

    None.
--*/
{
    DebugAssert( _IteratorState == INDEX_ITERATOR_CURRENT );
    DebugAssert( _CurrentEntry->AttributeLength <= _CurrentKeyMaxLength );
    DebugPtrAssert( _CurrentKey );
    DebugPtrAssert( _CurrentEntry );

    if( _CurrentEntry->Flags & INDEX_ENTRY_END ) {

        _CurrentKeyLength = 0;

    } else {

        memcpy( _CurrentKey,
                GetIndexEntryValue( _CurrentEntry ),
                _CurrentEntry->AttributeLength );

        _CurrentKeyLength = _CurrentEntry->AttributeLength;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\logfile.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    logfile.cxx

Abstract:

        This module contains the member function definitions for
    the NTFS_LOG_FILE class.

Author:

    Bill McJohn (billmc) 05-May-1992

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "untfs.hxx"

#include "ifssys.hxx"
#include "drive.hxx"
#include "attrib.hxx"
#include "logfile.hxx"

#include "message.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_LOG_FILE, NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

#define LOGFILE_PLACEMENT_V1    1

//
// These constants are used to determine the default log file size.
//

#define PrimaryLogFileGrowthRate     100           /* 1% of volume size */
#define SecondaryLogFileGrowthRate   200           /* 0.5% of volume size */

#define MaximumVolumeSizeBeforeSlowingDownLogFileGrowthRate (400UL*1024*1024)   // 400 MB

#define MaximumLogFileSize        MAXULONG      /* ~ 4 GB */
#define MaximumInitialLogFileSize 0x4000000    /* 64 MB */
#define MinimumLogFileSize        0x200000      /* 2 MB */
#define LogFileAlignmentMask      0x3FFF

VOID
NTFS_LOG_FILE::Construct(
        )
/*++

Routine Description:

    Worker function for the constructor.

Arguments:

        None.

Return Value:

        None.

--*/
{
}

UNTFS_EXPORT
NTFS_LOG_FILE::~NTFS_LOG_FILE(
    )
{
}


UNTFS_EXPORT
BOOLEAN
NTFS_LOG_FILE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes the log file object.

Arguments:

    Mft --  Supplies the volume MasterFileTable.

Return Value:

    TRUE upon successful completion.

--*/
{
    return( NTFS_FILE_RECORD_SEGMENT::Initialize( LOG_FILE_NUMBER,
                                                  Mft ) );

}



BOOLEAN
NTFS_LOG_FILE::Create(
    IN     PCSTANDARD_INFORMATION   StandardInformation,
    IN     LCN                      NearLcn,
    IN     ULONG                    InitialSize,
    IN OUT PNTFS_BITMAP             VolumeBitmap
    )
/*++

Routine Description:

    This method creates the Log File.  It allocates space for
    the $DATA attribute, fills it with LogFileFillCharacter
    (defined in logfile.hxx).

Arguments:

    StandardInformation --  Supplies the standard file information.
    NearLcn             --  Supplies an LCN near where the $DATA
                            attribute should be located.
    InitialSize         --  Supplies the initial size of the $DATA
                            attribute.  If the client passes in
                            zero, this routine will choose a default
                            size.
    VolumeBitmap        --  Supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

--*/
{
    // If the client passed in zero for initial size, calculate
    // the default initial size.
    //
    if( InitialSize == 0 ) {

        InitialSize = QueryDefaultSize( GetDrive(), QueryVolumeSectors() );
    }

    // Create the FRS and add the data attribute.
    //
    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ||
        !CreateDataAttribute( NearLcn, InitialSize, VolumeBitmap )
        ) {

        return FALSE;
    }

    if (IsAttributePresent($ATTRIBUTE_LIST, NULL, TRUE)) {
        DebugPrintTrace(("UNTFS: Data attribute of logfile is too fragmented that an attribute list is formed\n"));
        return FALSE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_LOG_FILE::CreateDataAttribute(
    IN     LCN          NearLcn,
    IN     ULONG        InitialSize OPTIONAL,
    IN OUT PNTFS_BITMAP VolumeBitmap
    )
/*++

Routine Description:

    This methods creates the log file's $DATA attribute.

Arguments:

    NearLcn             --  Supplies an LCN near where the $DATA
                            attribute should be located.
    InitialSize         --  Supplies the initial size of the $DATA
                            attribute.  If the client passes in
                            zero, this routine will choose a default
                            size.
    VolumeBitmap        --  Supplies the volume bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    This routine may not be multithread safe as it is calling
    SetNextAlloc() to be used by AddDataAttribute().

--*/
{
    ULONG   ClusterSize, ClustersInData;

    // If the client passed in zero for initial size, calculate
    // the default initial size.
    //
    if( InitialSize == 0 ) {

        InitialSize = QueryDefaultSize( GetDrive(), QueryVolumeSectors() );
    }

    // Make sure that the file size is a multiple of cluster size:
    //
    ClusterSize = QueryClusterFactor() * GetDrive()->QuerySectorSize();

    if( InitialSize % ClusterSize ) {

        ClustersInData = InitialSize / ClusterSize + 1;
        InitialSize = ClustersInData * ClusterSize;
    }
#if LOGFILE_PLACEMENT_V1

    else {
        ClustersInData = InitialSize / ClusterSize;
    }

    if (NearLcn != 0) {
        VolumeBitmap->SetNextAlloc(NearLcn - ClustersInData);
    }
#endif

    // Add the data attribute.
    //
    return( AddDataAttribute( InitialSize,
                              VolumeBitmap,
                              TRUE,
                              LogFileFillCharacter ) );

}


BOOLEAN
NTFS_LOG_FILE::MarkVolumeChecked(
    )
/*++

Routine Description:

    This method sets the signature in the log file to indicate
    that the volume has been checked.  This signature supports
    version 1.0 logfiles--ie. does not write the signature at
    the beginning of the second page, and does not record the
    greatest LSN.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    LSN     NullLsn;

    NullLsn.LowPart = 0;
    NullLsn.HighPart = 0;

    return( MarkVolumeChecked( FALSE, NullLsn ) );
}



BOOLEAN
NTFS_LOG_FILE::MarkVolumeChecked(
    BOOLEAN WriteSecondPage,
    LSN     GreatestLsn
    )
/*++

Routine Description:

    This method sets the signature in the log file to indicate
    that the volume has been checked.

Arguments:

    WriteSecondPage --  Supplies a flag which, if TRUE, indicates
                        that the checked signature should also be
                        written at the beginning of the second page
                        of the file, and the greatest LSN on the
                        volume should be recorded.

    GreatestLsn     --  Supplies the greatest LSN encountered on
                        the volume.  Ignored if WriteSecondPage is
                        FALSE.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    UCHAR Signature[LogFileSignatureLength];
    LSN SignatureAndLsn[2];
    ULONG BytesTransferred;
    BOOLEAN Error;
    ULONG i, PageSize;

    // Fetch the data attribute:
    //
    if( !QueryAttribute( &DataAttribute, &Error, $DATA ) ) {

        return FALSE;
    }

    // If the data attribute is resident, the volume is corrupt:
    //
    if( DataAttribute.IsResident() ) {

        DbgPrint( "UNTFS: Log File $DATA attribute is resident.\n" );
        return FALSE;
    }

    // Read the old signature--it's at offset zero in the $DATA
    // attribute, with a length of LogFileSignatureLength bytes.
    //
    if( !DataAttribute.Read( Signature,
                             0,
                             LogFileSignatureLength,
                             &BytesTransferred ) ||
        BytesTransferred != LogFileSignatureLength ) {

        DbgPrint( "UNTFS: Can't read log file signature.\n" );
        return FALSE;
    }

    if( !WriteSecondPage ) {

        DebugAssert(FALSE);

        // The client just wants the first signature.
        //
        memcpy( Signature,
                LOG_FILE_SIGNATURE_CHECKED,
                LogFileSignatureLength );

        if( !DataAttribute.Write( Signature,
                                  0,
                                  LogFileSignatureLength,
                                  &BytesTransferred,
                                  NULL ) ||
            BytesTransferred != LogFileSignatureLength ) {

            return FALSE;
        }

    } else {

        // The client wants us to write the signature and LSN at
        // the beginning of the first two pages.
        //
        PageSize = IFS_SYSTEM::QueryPageSize();

        if( PageSize == 0 ||
            CompareLT(DataAttribute.QueryValidDataLength(),
                      PageSize + sizeof( SignatureAndLsn )) ) {

            return FALSE;
        }

        memset( SignatureAndLsn, 0, sizeof(SignatureAndLsn) );

        memcpy( SignatureAndLsn,
                LOG_FILE_SIGNATURE_CHECKED,
                LogFileSignatureLength );

        SignatureAndLsn[1] = GreatestLsn;

        for( i = 0; i < 2; i++ ) {

            if( !DataAttribute.Write( SignatureAndLsn,
                                      PageSize * i,
                                      sizeof( SignatureAndLsn ),
                                      &BytesTransferred,
                                      NULL ) ||
                BytesTransferred != sizeof( SignatureAndLsn ) ) {

                DebugPrintTrace(("UNTFS: Unable to write out logfile signature & lsn\n"));
                return FALSE;
            }
        }
    }

    // Since we didn't modify the storage of the attribute, we don't
    // need to save it.
    //
    return TRUE;
}


BOOLEAN
NTFS_LOG_FILE::Reset(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This method resets the Log File by filling it with
    the LogFileFillCharacter (0xFF).

Arguments:

    Message --  Supplies an outlet for messages.

Return Value:

    TRUE upon successful completion.

    Note that, since the Log File's $DATA attribute is always
    non-resident and is never sparse, resetting the log file
    does not change the data attribute's Attribute Record or
    the Log File's File Record Segment

--*/
{
    NTFS_ATTRIBUTE  DataAttribute;
    BOOLEAN Error;

    Message->DisplayMsg( MSG_CHK_NTFS_RESETTING_LOG_FILE );

    if( !QueryAttribute( &DataAttribute, &Error, $DATA ) ||
        !DataAttribute.Fill( 0, LogFileFillCharacter ) ) {

        Message->DisplayMsg( MSG_CHK_NO_MEMORY );
        return FALSE;
    }

    return TRUE;
}



BOOLEAN
NTFS_LOG_FILE::Resize(
    IN      BIG_INT         NewSize,
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    IN      BOOLEAN         GetWhatYouCan,
    OUT     PBOOLEAN        Changed,
    OUT     PBOOLEAN        LogFileGrew,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This method resizes an existing log file.  It does not change
    the value of the remaining contents.

Arguments:

    NewSize         --  Supplies the new size of the log file's data
                        attribute, in bytes.  Zero means resize to the
                        default size.
    VolumeBitmap    --  Supplies the bitmap for the volume on which
                        the log file resides.
    GetWhatYouCan   --  Supplies a flag that indicates the method
                        should allocate as much of the requested
                        space as possible; if this value is FALSE,
                        this method will fail if it cannot make the
                        log file the requested size.
    Changed         --  Receives TRUE if the log file's size was changed
                        by this operation.
    LogFileGrew     --  Receives TRUE if the log file was made larger
                        by this operation.
    Message         --  Supplies an outlet for messages.

--*/
{
    NTFS_ATTRIBUTE  DataAttribute;
    BIG_INT OldSize;
    BOOLEAN Error;

    if (NewSize == 0) {

        NewSize = QueryDefaultSize( GetDrive(), QueryVolumeSectors() );
    }

    if (!QueryAttribute( &DataAttribute, &Error, $DATA )) {

        return FALSE;
    }

    if (NewSize == DataAttribute.QueryValueLength()) {

        *Changed = FALSE;
        return TRUE;
    }

    if (IsAttributeListPresent()) {
        Message->DisplayMsg( MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED_DUE_TO_ATTR_LIST_PRESENT );
        return FALSE;
    }

    Message->DisplayMsg( MSG_CHK_NTFS_RESIZING_LOG_FILE );

    OldSize = DataAttribute.QueryValueLength();

    *LogFileGrew = (NewSize > OldSize);


#if 0   // fragment the disk for debugging purpose
    ULONG   i;
    for (i = 0; i < 0x1f400*8; i += 2) {
        if (VolumeBitmap->IsFree(i, 1))
            VolumeBitmap->SetAllocated(i, 1);
    }
#endif

    if( !DataAttribute.Resize( NewSize, VolumeBitmap )       ||
        !DataAttribute.Fill( OldSize, LogFileFillCharacter ) ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        *Changed = FALSE;
        return FALSE;
    }

    if (IsAttributeListPresent()) {

        Message->DisplayMsg( MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED_DUE_TO_ATTR_LIST );

        if (!DataAttribute.Resize( OldSize, VolumeBitmap ) ||
            !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ||
            !PurgeAttributeList()) {

            *Changed = FALSE;
            return FALSE;
        }

    }

    *Changed = TRUE;
    return TRUE;
}


BOOLEAN
NTFS_LOG_FILE::VerifyAndFix(
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN OUT  PNTFS_CHKDSK_REPORT ChkdskReport,
    IN      FIX_LEVEL           FixLevel,
    IN      BOOLEAN             Resize,
    IN      ULONG               LogFileSize,
    IN OUT  PNUMBER_SET         BadClusters,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine ensures the validity of the log file; it should have
    a valid file name and standard information, and its size should be
    within reasonable limits.

Arguments:

    VolumeBitmap    - Supplies the volume bitmap.
    RootIndex       - Supplies the root index.
    Changes         - Returns whether or not changes were made.
    ChkdskReport    - Supplies the current chkdsk report.
    FixLevel        - Supplies the fix up level.
    Resize          - Supplies a flag indicating whether the log file
                      should be resized.
    LogFileSize     - If Resize is set, then LogFileSize supplies the
                      new size of the logfile.  If zero, the logfile will be
                      resized to the default size.
    BadClusters     - Supplies the current list of bad clusters.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE  data_attribute;
    BIG_INT         old_size;
    BOOLEAN         error, has_external;
    ULONG           default_size, max_size;
    BIG_INT         freeSectorSize;
    BIG_INT         bytes_recovered;
    BIG_INT         bad_clusters_count;
    BOOLEAN         bad_clusters_found;

    // The logfile should not have an attribute list, and the data
    // attribute should be non-resident and of a reasonable size.
    //

    error = *Changes = has_external = FALSE;

    if (QueryAttribute(&data_attribute, &error, $DATA) &&
        !data_attribute.IsResident()) {

        // If the log file has an attribute list, resize the
        // data attribute to zero and recreate it to force
        // it to be non-external.
        //

        old_size = data_attribute.QueryValueLength();

        default_size = QueryDefaultSize(GetDrive(), QueryVolumeSectors());
        max_size = QueryMaximumSize(GetDrive(), QueryVolumeSectors());

        DebugAssert(data_attribute.QueryValueLength().GetHighPart() == 0);

        if (Resize) {
            if (LogFileSize > max_size) {

                Message->DisplayMsg( MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_BIG );
                ChkdskReport->BytesLogFile = old_size;
                return TRUE;

            } else if (LogFileSize < MinimumLogFileSize) {

                Message->DisplayMsg( MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_SMALL );
                ChkdskReport->BytesLogFile = old_size;
                return TRUE;

            } else if (LogFileSize > old_size) {

                freeSectorSize = VolumeBitmap->QueryFreeClusters() * QueryClusterFactor();
                if (((LogFileSize-old_size-1)/GetDrive()->QuerySectorSize()+1) > freeSectorSize) {
                    Message->DisplayMsg(MSG_CHK_NTFS_OUT_OF_SPACE_FOR_SPECIFIED_LOGFILE_SIZE);
                    ChkdskReport->BytesLogFile = old_size;
                    return TRUE;
                }
            }
        } else {
            LogFileSize = default_size;
            if (old_size < MinimumLogFileSize) {

                Resize = TRUE;
                freeSectorSize = VolumeBitmap->QueryFreeClusters() * QueryClusterFactor();
                if (((LogFileSize-old_size-1)/GetDrive()->QuerySectorSize()+1) > freeSectorSize) {
                    Message->DisplayMsg(MSG_CHK_NTFS_OUT_OF_SPACE_TO_ENLARGE_LOGFILE_TO_DEFAULT_SIZE);
                    ChkdskReport->BytesLogFile = old_size;
                    return TRUE;
                }

            } else if (old_size > max_size) {

                Resize = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_LOGFILE_SIZE_TOO_BIG);
            }
        }

        bad_clusters_count = BadClusters->QueryCardinality();

        if (!data_attribute.RecoverAttribute(VolumeBitmap,
                                             BadClusters,
                                             &bytes_recovered)) {
            Message->DisplayMsg( MSG_CHK_NO_MEMORY );
            return FALSE;
        }

        bad_clusters_found = (BadClusters->QueryCardinality() != bad_clusters_count);

        if (IsAttributePresent($ATTRIBUTE_LIST, NULL, TRUE)) {

            Message->DisplayMsg(MSG_CHK_NTFS_ATTR_LIST_IN_LOG_FILE);

            *Changes = TRUE;

            has_external = TRUE;

            bad_clusters_found = FALSE;

            if (FixLevel != CheckOnly &&
                (!data_attribute.Resize(0, VolumeBitmap) ||
                 !data_attribute.InsertIntoFile(this, VolumeBitmap) ||
                 !Flush(VolumeBitmap, RootIndex) ||
                 !PurgeAttributeList() ||
                 !Flush(VolumeBitmap, RootIndex))) {

                // The log file is corrupt, and we can't fix it.
                //

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                return FALSE;
            }
        }

        if (has_external || Resize || bad_clusters_found) {

            //  The data attribute's size is out-of-bounds.  Resize it to
            //  the default size.
            //

            *Changes = TRUE;

            if (Resize) {
                Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE);
            }

            if (bad_clusters_found) {
                Message->DisplayMsg(MSG_CHK_NTFS_BAD_CLUSTERS_IN_LOG_FILE);
            }

            if (FixLevel != CheckOnly) {

#if 0   // fragment the disk for debugging purpose
                ULONG   i;
                for (i = 0; i < 0x1f400*8; i += 2) {
                    if (VolumeBitmap->IsFree(i, 1))
                        VolumeBitmap->SetAllocated(i, 1);
                }
#endif

                if (!data_attribute.Resize(LogFileSize, VolumeBitmap) ||
                    !data_attribute.Fill(0, LogFileFillCharacter) ||
                    !data_attribute.InsertIntoFile(this, VolumeBitmap) ||
                    !Flush(VolumeBitmap, RootIndex)) {

                    if (has_external) {

                        // The log file is corrupt, and we can't fix it.
                        //

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                        return FALSE;

                    } else {

                        // Print a warning message, but still return success.
                        //

                        Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED);

                        ChkdskReport->BytesLogFile = data_attribute.QueryValueLength();
                        return TRUE;
                    }
                }

                if (IsAttributeListPresent()) {

                    if (old_size < MinimumLogFileSize)
                        old_size = MinimumLogFileSize;

                    Message->DisplayMsg( MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED_DUE_TO_ATTR_LIST );

                    while (IsAttributeListPresent()) {

                        if (0 == old_size) {
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                            return FALSE;
                        }

                        if (!data_attribute.Resize( 0, VolumeBitmap ) ||
                            !data_attribute.InsertIntoFile( this, VolumeBitmap ) ||
                            !Flush(VolumeBitmap) ||
                            !PurgeAttributeList() ||
                            !data_attribute.Resize( old_size, VolumeBitmap ) ||
                            !data_attribute.Fill( old_size - 1, LogFileFillCharacter ) ||
                            !data_attribute.InsertIntoFile( this, VolumeBitmap )) {

                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                            return FALSE;
                        }

                        old_size = old_size / 2;

                    }

                    if (!data_attribute.Fill(0, LogFileFillCharacter) ||
                        !Flush(VolumeBitmap, RootIndex)) {

                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
                        return FALSE;
                    }
                }
            }
        }

        ChkdskReport->BytesLogFile = data_attribute.QueryValueLength();
        return TRUE;
    }

    if (error) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_OR_RESIDENT_DATA_ATTR_IN_LOG_FILE);

    *Changes = TRUE;

    Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_LOG_FILE);

    // Recreate the $DATA attribute.
    //

    if (FixLevel != CheckOnly) {

        // NTRAID#91401-2000/03/07 - danielch - Potential attribute list can be created here

        if (!CreateDataAttribute(0, 0, VolumeBitmap) ||
            !Flush(VolumeBitmap, RootIndex)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_LOG_FILE);
            return FALSE;
        }
    }

    if (QueryAttribute(&data_attribute, &error, $DATA)) {

        ChkdskReport->BytesLogFile = data_attribute.QueryValueLength();
    } else {

        ChkdskReport->BytesLogFile = 0;
    }

    return TRUE;
}

ULONG
NTFS_LOG_FILE::QueryDefaultSize(
    IN  PCDP_DRIVE  Drive,
    IN  BIG_INT     VolumeSectors
    )
/*++

Routine Description:

    This method returns the appropriate default log file size
    for the specified drive.

Arguments:

    Drive           - Supplies the drive under consideration.
    VolumeSectors   - Supplies the number of volume sectors.

Return Value:

    The appropriate default log file size for the drive.

--*/
{
    BIG_INT InitialSize, VolumeSize;
    ULONG   FinalSize;

    if (VolumeSectors.GetHighPart() != 0) {

        FinalSize = MaximumInitialLogFileSize;

    } else {

        VolumeSize = VolumeSectors * Drive->QuerySectorSize();

        if (VolumeSize <= (400UL * 1024UL * 1024UL)) {

            InitialSize = (VolumeSize / PrimaryLogFileGrowthRate);

            if (InitialSize < MinimumLogFileSize)
                InitialSize = MinimumLogFileSize;

        } else {

            VolumeSize = VolumeSize - MaximumVolumeSizeBeforeSlowingDownLogFileGrowthRate;

            InitialSize = VolumeSize/SecondaryLogFileGrowthRate +
                          MaximumVolumeSizeBeforeSlowingDownLogFileGrowthRate/
                          PrimaryLogFileGrowthRate;

            if (InitialSize > MaximumInitialLogFileSize)
                InitialSize = MaximumInitialLogFileSize;
        }

        FinalSize = (InitialSize + LogFileAlignmentMask).GetLowPart() & ~LogFileAlignmentMask;
    }

    return FinalSize;
}

ULONG
NTFS_LOG_FILE::QueryMinimumSize(
    IN  PCDP_DRIVE  Drive,
    IN  BIG_INT     VolumeSectors
    )
/*++

Routine Description:

    This method returns the minimum log file size
    for the specified drive.

Arguments:

    Drive           - Supplies the drive under consideration.
    VolumeSectors   - Supplies the number of volume sectors.

Return Value:

    The minimum log file size for the drive.

--*/
{
    UNREFERENCED_PARAMETER(Drive);
    UNREFERENCED_PARAMETER(VolumeSectors);

    return MinimumLogFileSize;
}

ULONG
NTFS_LOG_FILE::QueryMaximumSize(
    IN  PCDP_DRIVE  Drive,
    IN  BIG_INT     VolumeSectors
    )
/*++

Routine Description:

    This method returns the maximum log file size
    for the specified drive.

Arguments:

    Drive           - Supplies the drive under consideration.
    VolumeSectors   - Supplies the number of volume sectors.

Return Value:

    The maximum log file size for the drive.

--*/
{
    UNREFERENCED_PARAMETER(Drive);
    UNREFERENCED_PARAMETER(VolumeSectors);

    return MaximumLogFileSize;
}


BOOLEAN
NTFS_LOG_FILE::EnsureCleanShutdown(
    OUT PLSN        Lsn
    )
/*++

Routine Description:

    This method looks at the logfile to verify that the volume
    was shut down cleanly.  If we can't read the logfile well
    enough to say for sure, we assume that it was not shut down
    cleanly.

Arguments:

    Lsn         - Retrieves the last lsn in the restart area

Return Value:

    TRUE        - The volume was shut down cleanly.
    FALSE       - The volume was not shut down cleanly.

--*/
{
    NTFS_ATTRIBUTE              attrib;
    BOOLEAN                     error;
    ULONG                       nbyte;
    PLFS_RESTART_PAGE_HEADER    header;
    PLFS_RESTART_AREA           restarea;
    PBYTE                       buf;
    BOOLEAN                     r = TRUE;

    // Read the logfile contents to make sure the volume was shut
    // down cleanly.  If it wasn't generate an error message for
    // the user and bail.  Also generate an error if the logfile's
    // data isn't big enough to contain an indication of whether it
    // was cleanly shut down or not.
    //

    if (!QueryAttribute(&attrib, &error, $DATA)) {

        DebugPrintTrace(("UNTFS: Could not query logfile data\n"));
        return FALSE;
    }

    if (attrib.QueryValueLength() < IFS_SYSTEM::QueryPageSize()) {

        DebugPrintTrace(("UNTFS: LogFile too small to hold restart area\n"));
        return FALSE;
    }

    if (NULL == (buf = NEW BYTE[IFS_SYSTEM::QueryPageSize()])) {

        DebugPrintTrace(("UNTFS: Out of memory\n"));
        return FALSE;
    }

    if (!attrib.Read(buf, 0, IFS_SYSTEM::QueryPageSize(), &nbyte) ||
        nbyte != IFS_SYSTEM::QueryPageSize()) {

        DebugPrintTrace(("UNTFS: Unable to read logfile\n"));
        delete[] buf;
        return FALSE;
    }

    header = PLFS_RESTART_PAGE_HEADER(buf);

    if (0xffff == header->RestartOffset) {

        DebugPrintTrace(("UNTFS: Invalid restart offset\n"));
        delete[] buf;
        return FALSE;
    }

    restarea = PLFS_RESTART_AREA(buf + header->RestartOffset);


    *Lsn = restarea->CurrentLsn;
    // DebugPrintTrace(("UNTFS: Lsn value %I64x at offset %x\n", *Lsn, header->RestartOffset));

    if (!(restarea->Flags & LFS_CLEAN_SHUTDOWN)) {
        DebugPrintTrace(("UNTFS: LFS_CLEAN_SHUTDOWN flag not on %x\n", restarea->Flags));
        // r = FALSE;
    }

    delete[] buf;

    return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\mft.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"


#include "mft.hxx"

#include "attrib.hxx"
#include "drive.hxx"
#include "frsstruc.hxx"
#include "hmem.hxx"
#include "numset.hxx"




DEFINE_CONSTRUCTOR( NTFS_MASTER_FILE_TABLE, OBJECT );

NTFS_MASTER_FILE_TABLE::~NTFS_MASTER_FILE_TABLE(
    )
{
    Destroy();
}


VOID
NTFS_MASTER_FILE_TABLE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataAttribute = NULL;
    _MftBitmap = NULL;
    _VolumeBitmap = NULL;
    _BytesPerFrs = 0;
    _ClusterFactor = 0;
    _VolumeSectors = 0;
    _MethodsEnabled = FALSE;
    _ReadOnly = FALSE;
}


VOID
NTFS_MASTER_FILE_TABLE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_MASTER_FILE_TABLE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _DataAttribute = NULL;
    _MftBitmap = NULL;
    _VolumeBitmap = NULL;
    _BytesPerFrs = 0;
    _ClusterFactor = 0;
    _VolumeSectors = 0;
    _MethodsEnabled = FALSE;
    _ReadOnly = FALSE;
}


BOOLEAN
NTFS_MASTER_FILE_TABLE::Initialize(
    IN OUT  PNTFS_ATTRIBUTE     DataAttribute,
    IN OUT  PNTFS_BITMAP        MftBitmap,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNTFS_UPCASE_TABLE  UpcaseTable,
    IN      ULONG               ClusterFactor,
    IN      ULONG               FrsSize,
    IN      ULONG               SectorSize,
    IN      BIG_INT             VolumeSectors,
    IN      BOOLEAN             ReadOnly
    )
/*++

Routine Description:

    Initialize an NTFS_MASTER_FILE_TABLE object.

Arguments:

    DataAttribute   - Supplies the DATA attribute for the MFT.
    MftBitmap       - Supplies the MFT Bitmap for the MFT.
    VolumeBitmap    - Suppleis the volume bitmap.
    UpcaseTable     - Supplies the volume bitmap.
    ClusterFactor   - Supplies the number of sectors per cluster.
    FrsSize         - Supplies the number of bytes per FRS.
    SectorSize      - Supplies the number of bytes per sector.
    VolumeSectors   - Supplies the number of volume sectors.
    ReadOnly        - Supplies whether or not this class is read only.

Return Value:

    TRUE upon successful completion.

Notes:

    Unless the Upcase table is supplied, FRS's initialized with this
    MFT will not be able to manipulate named attributes until the
    upcase table is set.

--*/
{
    Destroy();

    DebugAssert(DataAttribute);
    DebugAssert(MftBitmap);
    DebugAssert(ClusterFactor);
    DebugAssert(FrsSize);
    DebugAssert(SectorSize);

    _DataAttribute = DataAttribute;
    _MftBitmap = MftBitmap;
    _VolumeBitmap = VolumeBitmap;
    _UpcaseTable = UpcaseTable;
    _ClusterFactor = ClusterFactor;
    _BytesPerFrs = FrsSize;
    _VolumeSectors = VolumeSectors;
    _MethodsEnabled = TRUE;
    _ReadOnly = ReadOnly;
    _SectorSize = SectorSize;

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MASTER_FILE_TABLE::AllocateFileRecordSegment(
    OUT PVCN    FileNumber,
    IN  BOOLEAN IsMft
    )
/*++

Routine Description:

    Allocate a File Record Segment from the Master File Table.  If the
    allocation is being done for a user file, we make sure that the frs
    doesn't come from the first cluster of the mft's allocation.

Arguments:

    FileNumber  -- Returns the file number of the allocated segment.
    IsMft       -- supplies a flag which indicates, if TRUE, that
                   the allocation is being made on behalf of the
                   MFT itself.

Return Value:

    TRUE upon successful completion.

Notes:

    Any bad clusters discovered by this routine are added to the volume
    bitmap but not added to the bad clusters file.

--*/
{
    VCN                 vcn, reserved_vcn;
    BIG_INT             run_length;
    HMEM                hmem;
    NTFS_FRS_STRUCTURE  frs;
    NUMBER_SET          bad_cluster_list;
    BOOLEAN             reserve_allocated;
    ULONG               cluster_size;

    //
    // This should really be a VCN instead of a LARGE_INTEGER, but the
    // VCN causes the compiler to insert a reference to atexit(), which
    // we want to avoid. -mjb.
    //

    STATIC LARGE_INTEGER LastAllocatedVcn;

    DebugAssert(_MftBitmap);

    if (!_MethodsEnabled) {
        return FALSE;
    }

    cluster_size = QueryClusterFactor() * _SectorSize;

    if (LastAllocatedVcn * QueryFrsSize() < cluster_size) {

        LastAllocatedVcn.QuadPart = cluster_size / QueryFrsSize();
    }

    if( IsMft ) {

        // If the MFT has asked for a sector to be allocated,
        // we can't grow the MFT (since we're in the process
        // of saving it).  However, the reservation scheme
        // means that if we have allocated any FRS's to
        // clients other than the MFT itself, there will be
        // a free one in the bitmap, so we can just return
        // it.
        //
        return _MftBitmap->AllocateClusters(1, 1, FileNumber, 1);
    }


    // Grab a reserved VCN for the MFT.
    //
    reserve_allocated = _MftBitmap->AllocateClusters(1, 1, &reserved_vcn, 1);


    if (reserve_allocated &&
        _MftBitmap->AllocateClusters(LastAllocatedVcn, 1, FileNumber, 1)) {

        LastAllocatedVcn = FileNumber->GetLargeInteger();
        _MftBitmap->SetFree( reserved_vcn, 1 );
        return TRUE;
    }

    // Grow the data attribute (and the MFT Bitmap) to
    // include another File Record Segment.
    //
    if( !Extend(8) ) {

        return FALSE;
    }

    // If we didn't get a reserved vcn before, get it now.
    //
    if( !reserve_allocated &&
        !_MftBitmap->AllocateClusters(1, 1, &reserved_vcn, 1) ) {

        return FALSE;
    }

    // And now allocate the FRS we will return to the client.
    //
    if (!_MftBitmap->AllocateClusters(LastAllocatedVcn, 1, FileNumber, 1)) {

        return FALSE;
    }


    // Now read in the new FRS to make sure that it is good.
    // Since we won't be manipulating any named attributes, we can
    // pass in NULL for the upcase table.

    if (hmem.Initialize() &&
        bad_cluster_list.Initialize() &&
        frs.Initialize(&hmem, _DataAttribute, *FileNumber,
                       QueryClusterFactor(),
                       QueryVolumeSectors(),
                       QueryFrsSize(),
                       NULL)) {

        if (!frs.Read()) {

            vcn = (*FileNumber*QueryFrsSize() + (cluster_size - 1))/cluster_size;

            run_length = (QueryFrsSize() + (cluster_size - 1))/cluster_size;

            if (!_VolumeBitmap ||
                !_DataAttribute->Hotfix(vcn, run_length, _VolumeBitmap,
                                        &bad_cluster_list)) {

                return FALSE;
            }
        }
    }

    // Free the reserved FRS and return success.
    //
    _MftBitmap->SetFree( reserved_vcn, 1 );
    LastAllocatedVcn = FileNumber->GetLargeInteger();
    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MASTER_FILE_TABLE::Extend(
    IN  ULONG   NumberOfSegmentsToAdd
    )
/*++

Routine Description:

    This method grows the Master File Table.  It increases the
    size of the Data attribute (to hold more File Record Segments)
    and increases the size of the MFT Bitmap to match.

Arguments:

    NumberOfSegmentsToAdd   --  supplies the number of new File Record
                                Segments to add to the Master File Table.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT OldAllocatedLength, NumberOfSegments;
    ULONG   BytesToAdd;

    DebugAssert(_MftBitmap);
    DebugAssert(_DataAttribute);

    if (!_MethodsEnabled || !_VolumeBitmap) {
        return FALSE;
    }

    // Find out how big it already is, and how much bigger
    // it needs to be.

    OldAllocatedLength = _DataAttribute->QueryAllocatedLength();

    BytesToAdd = NumberOfSegmentsToAdd * _BytesPerFrs;

    // Resize the attribute.  Note that if Resize fails, it
    // leaves the attribute unaltered.
    //
    if (!_DataAttribute->Resize( OldAllocatedLength + BytesToAdd,
                                 _VolumeBitmap )) {

        return FALSE;
    }

    // If the MFT is not operating in read-only mode, fill the
    // new space with zeroes.
    //
    if (!_ReadOnly && !_DataAttribute->Fill( OldAllocatedLength, 0 ) ) {

        _DataAttribute->Resize( OldAllocatedLength, _VolumeBitmap );
        return FALSE;
    }

#if DBG
    {
        ULONG   cluster_size = QueryClusterFactor() * _SectorSize;
        BIG_INT allocated_clusters = (OldAllocatedLength + BytesToAdd - 1 + cluster_size)/cluster_size;

        DebugAssert( _DataAttribute->QueryAllocatedLength() ==
                     (allocated_clusters*cluster_size) );
    }
#endif

    // Grow the MFT Bitmap to cover the new size of the Data Attribute.
    // Note that NTFS_BITMAP::Resize will set the new bits free, which
    // is what I want.

    NumberOfSegments = _DataAttribute->QueryAllocatedLength() / _BytesPerFrs;

    if( !_MftBitmap->Resize( NumberOfSegments ) ) {

        // I couldn't expand the MFT Bitmap to cover the new space,
        // so I'll have to truncate the data attribute back down.

        _DataAttribute->Resize( OldAllocatedLength, _VolumeBitmap );
        return FALSE;
    }

    return TRUE;
}

BIG_INT
NTFS_MASTER_FILE_TABLE::QueryFrsCount(
    )
/*++

Routine Description:

    This routine returns the number of frs's in the MFT.

Arguments:

    None.

Return Value:

    The number of frs's.

--*/
{
    BIG_INT num_frs;

    num_frs = _DataAttribute->QueryValueLength() / _BytesPerFrs;

    return num_frs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\mftinfo.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    mftinfo.cxx

Abstract:

    This module contains the declarations for the NTFS_MFT_INFO
    class, which stores extracted information from the NTFS MFT.

Author:

    Daniel Chan (danielch) Oct 18, 1999

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"

#include "attrib.hxx"
#include "frs.hxx"
#include "upcase.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "mftinfo.hxx"
#include "membmgr2.hxx"

//#define RUN_ON_W2K  1

#if defined(RUN_ON_W2K)
//
// This table is from Windows XP rtl\checksum.c
//
STATIC
ULONG32 RtlCrc32Table [] = {
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

//
// This routine is from Windows XP rtl\checksum.c
//
ULONG32
FsRtlComputeCrc32(
    ULONG32 PartialCrc,
    PVOID   Buf,
    ULONG Length
    )

/*++

Routine Description:

    Compute the CRC32 as specified in in IS0 3309. See RFC-1662 and RFC-1952
    for implementation details and references.

    Pre- and post-conditioning (one's complement) is done by this function, so
    it should not be done by the caller. That is, do:

        Crc = RtlComputeCrc32 ( 0, buffer, length );

    instead of

        Crc = RtlComputeCrc32 ( 0xffffffff, buffer, length );

    or
        Crc = RtlComputeCrc32 ( 0xffffffff, buffer, length) ^ 0xffffffff;


Arguments:

    PartialCrc - A partially calculated CRC32.

    Buffer - The buffer you want to CRC.

    Length - The length of the buffer in bytes.

Return Value:

    The updated CRC32 value.

Environment:

    Kernel mode at IRQL of APC_LEVEL or below, User mode, or within
    the boot-loader.

--*/



{
    PUCHAR  Buffer = (PUCHAR)Buf;
    ULONG32 Crc;
    ULONG i;

    //
    // Compute the CRC32 checksum.
    //

    Crc = PartialCrc ^ 0xffffffffL;

    for (i = 0; i < Length; i++) {
        Crc = RtlCrc32Table [(Crc ^ Buffer [ i ]) & 0xff] ^ (Crc >> 8);
    }

    return (Crc ^ 0xffffffffL);
}
#else

#define FsRtlComputeCrc32   RtlComputeCrc32

#endif


PNTFS_UPCASE_TABLE   NTFS_MFT_INFO::_upcase_table = NULL;
UCHAR                NTFS_MFT_INFO::_major = 0;
UCHAR                NTFS_MFT_INFO::_minor = 0;

DEFINE_CONSTRUCTOR( NTFS_MFT_INFO, OBJECT );

VOID
NTFS_MFT_INFO::Construct(
    )
/*++

Routine Description:

    This method is the worker function for object construction.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    _min_file_number = MAXLONGLONG;
    _max_file_number = -MAXLONGLONG;
    _major = _minor = 0;
    _upcase_table = NULL;
    _max_mem_use = 0;
    _num_of_files = 0;
    _mft_info = NULL;
}

VOID
NTFS_MFT_INFO::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    _min_file_number = MAXLONGLONG;
    _max_file_number = -MAXLONGLONG;
    _major = _minor = 0;
    _upcase_table = NULL;
    _max_mem_use = 0;
    _num_of_files = 0;
    FREE(_mft_info);
}

NTFS_MFT_INFO::~NTFS_MFT_INFO(
    )
/*++

Routine Description:

    This method un-initialize the class object.

Arguments:

    N/A

Returns:

    N/A

--*/
{
    Destroy();
}

BOOLEAN
NTFS_MFT_INFO::Initialize(
    IN     BIG_INT              NumberOfFrs,
    IN     PNTFS_UPCASE_TABLE   UpcaseTable,
    IN     UCHAR                Major,
    IN     UCHAR                Minor,
    IN     ULONG64              MaxMemUse
    )
/*++

Routine Description:

    This method initialize this class object.

Arguments:

    FrsInfo     --  Supplies the first name to compare.
    FielName    --  Supplies the second name to compare.

Returns:

    TRUE if there is a match; otherwise, FALSE.

--*/
{
    ULONG   size;

    Destroy();

    _num_of_files = NumberOfFrs.GetLowPart();
    size = NumberOfFrs.GetLowPart()*sizeof(PVOID);
    _mft_info = (PVOID *)MALLOC(size);
    if (_mft_info) {
        if (!_mem_mgr.Initialize(MaxMemUse)) {
            FREE(_mft_info);
            return FALSE;
        }
        memset(_mft_info, 0, size);
        _upcase_table = UpcaseTable;
        _major = Major;
        _minor = Minor;
        _max_mem_use = MaxMemUse;
        return TRUE;
    }
    return FALSE;
}

BOOLEAN
NTFS_MFT_INFO::Initialize(
    )
/*++

Routine Description:

    This method initialize this class object.

Arguments:

    FrsInfo     --  Supplies the first name to compare.
    FielName    --  Supplies the second name to compare.

Returns:

    TRUE if there is a match; otherwise, FALSE.

--*/
{
    if (_mft_info == NULL)
        return FALSE;   // have not been initialize before

    if (!_mem_mgr.Initialize(_max_mem_use)) {
        return FALSE;
    }

    // prevent accidental use of stale pointers
    memset(_mft_info, 0, _num_of_files * sizeof(PVOID));

    _min_file_number = MAXLONGLONG;
    _max_file_number = -MAXLONGLONG;

    return TRUE;
}

BOOLEAN
NTFS_MFT_INFO::CompareFileName(
    IN     PVOID                FrsInfo,
    IN     ULONG                ValueLength,
    IN     PFILE_NAME           FileName,
       OUT PUSHORT              FileNameIndex
    )
/*++

Routine Description:

    This method compares the signature computed from FileName against
    the signature stored in FrsInfo.

Arguments:

    FrsInfo     --  Supplies the first name to compare.
    ValueLength --  Supplies the length of the FileName (second name) value.
    FileName    --  Supplies the second name to compare.
    FileNameIndex -- Retrieves the index that matches the FileName & ValueLength

Returns:

    TRUE if there is a match; otherwise, FALSE.

--*/
{
    PNTFS_FRS_INFO          p = (PNTFS_FRS_INFO)FrsInfo;
    USHORT                  i, FileNameCount = p->NumberOfFileNames;
    FILE_NAME_SIGNATURE     signature;

    NTFS_MFT_INFO::ComputeFileNameSignature(ValueLength, FileName, signature);

    for (i=0; i<FileNameCount; i++) {
        if (memcmp(p->FileNameInfo[i].Signature,
                   signature,
                   sizeof(FILE_NAME_SIGNATURE)) == 0) {
            *FileNameIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}


BOOLEAN
NTFS_MFT_INFO::ExtractIndexEntryInfo(
    IN     PNTFS_FILE_RECORD_SEGMENT    Frs,
    IN     PMESSAGE                     Message,
    IN     BOOLEAN                      IgnoreFileName,
       OUT PBOOLEAN                     OutOfMemory
    )
/*++

Routine Description:

    This method extracts index entry information from the FRS.

Arguments:

    Frs       --  Supplies the file record segment to extract information from.
    Message   --  Supplies the outlet for message.

Returns:

    TRUE if successful
    FALSE if failure

--*/
{
    USHORT                     number_of_filenames;
    NTFS_ATTRIBUTE             attribute;
    BOOLEAN                    error;
    USHORT                     i;
    PNTFS_FRS_INFO             p;
    DUPLICATED_INFORMATION     dup_info;
    PFILE_NAME                 pFileName;

    CHAR                       x[50];


    *OutOfMemory = FALSE;

    number_of_filenames = 0;
    if (!IgnoreFileName) {
        for (i=0; Frs->QueryAttributeByOrdinal(&attribute,
                                               &error,
                                               $FILE_NAME,
                                               i); i++) {
            if (attribute.IsResident()) {
                number_of_filenames++;
            }
        }
        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    if (number_of_filenames) {

        p = (PNTFS_FRS_INFO) _mem_mgr.Allocate(sizeof(NTFS_FRS_INFO) +
                (number_of_filenames-1)*sizeof(_NTFS_FILE_NAME_INFO));
        if (p == NULL) {
            *OutOfMemory = TRUE;
            return FALSE;
        }

        p->SegmentReference = Frs->QuerySegmentReference();

        if (!Frs->QueryDuplicatedInformation(&dup_info)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        NTFS_MFT_INFO::ComputeDupInfoSignature(&dup_info, p->DupInfoSignature);
#if 0
        sprintf(x, "DI, %08d, %02x%02x%02x%02x%02x%02x\n",
               Frs->QueryFileNumber().GetLowPart(),
               p->DupInfoSignature[0],
               p->DupInfoSignature[1],
               p->DupInfoSignature[2],
               p->DupInfoSignature[3],
               p->DupInfoSignature[4],
               p->DupInfoSignature[5]);
        Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", x, " ");
#endif
        p->NumberOfFileNames = number_of_filenames;

        for (i=0; Frs->QueryAttributeByOrdinal(&attribute,
                                               &error,
                                               $FILE_NAME,
                                               i); i++) {
            if (attribute.IsResident()) {

                pFileName = (PFILE_NAME)attribute.GetResidentValue();
                DebugAssert(pFileName);
                DebugAssert(number_of_filenames);
                NTFS_MFT_INFO::ComputeFileNameSignature(
                    attribute.QueryValueLength().GetLowPart(),
                    pFileName,
                    p->FileNameInfo[--number_of_filenames].Signature);
                p->FileNameInfo[number_of_filenames].Flags = pFileName->Flags;
#if 0
                sprintf(x, "FN, %08d, %d: %02x%02x%02x%02x%02x%02x%02x\n",
                       Frs->QueryFileNumber().GetLowPart(),
                       number_of_filenames,
                       p->FileNameInfo[number_of_filenames].Signature[0],
                       p->FileNameInfo[number_of_filenames].Signature[1],
                       p->FileNameInfo[number_of_filenames].Signature[2],
                       p->FileNameInfo[number_of_filenames].Signature[3],
                       p->FileNameInfo[number_of_filenames].Signature[4],
                       p->FileNameInfo[number_of_filenames].Signature[5],
                       p->FileNameInfo[number_of_filenames].Signature[6]);
                Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", x, " ");
#endif
            }
        }
    } else {
        p = (PNTFS_FRS_INFO)_mem_mgr.Allocate(sizeof(NTFS_FRS_INFO)-sizeof(_NTFS_FILE_NAME_INFO));
        if (p == NULL) {
            *OutOfMemory = TRUE;
            return FALSE;
        }

        p->SegmentReference = Frs->QuerySegmentReference();
        p->NumberOfFileNames = 0;
    }
    _mft_info[Frs->QueryFileNumber().GetLowPart()] = p;

    if (_min_file_number > Frs->QueryFileNumber())
        _min_file_number = Frs->QueryFileNumber();
    if (_max_file_number < Frs->QueryFileNumber())
        _max_file_number = Frs->QueryFileNumber();

    return TRUE;
}


VOID
NTFS_MFT_INFO::ComputeFileNameSignature(
    IN     ULONG                    ValueLength,
    IN     PFILE_NAME               FileName,
       OUT FILE_NAME_SIGNATURE      Signature
    )
/*++

Routine Description:

    This method computes a signature based on the given file name.

Arguments:

    ValueLength -- Supplies the length of the entire FileName value
    FileName  --  Supplies the file name
    Signature --  Returns the signature of the file name

Returns:

    N/A

--*/
{
    ULONG32     crc;

    crc = FsRtlComputeCrc32(0, &(FileName->FileNameLength), sizeof(FileName->FileNameLength));
    crc = FsRtlComputeCrc32(crc, &(FileName->Flags), sizeof(FileName->Flags));
    crc = FsRtlComputeCrc32(crc, &ValueLength, sizeof(ValueLength));
    crc = FsRtlComputeCrc32(crc, &(FileName->ParentDirectory), sizeof(FileName->ParentDirectory));
    crc = FsRtlComputeCrc32(crc, FileName->FileName, FileName->FileNameLength * sizeof(WCHAR));
    memset(Signature, 0, sizeof(FILE_NAME_SIGNATURE));
    memcpy(Signature, &crc, min(sizeof(crc), sizeof(FILE_NAME_SIGNATURE)));
}

VOID
NTFS_MFT_INFO::ComputeDupInfoSignature(
    IN     PDUPLICATED_INFORMATION      DupInfo,
       OUT DUP_INFO_SIGNATURE           Signature
    )
/*++

Routine Description:

    This method computes a signature based on the given duplicated information.

Arguments:

    DupInfo   --  Supplies the duplicated information.
    Signature --  Returns the signature of the duplicated information.

Returns:

    N/A

--*/
{
    ULONG32 crc;
    ULONG   len;

    //
    // make sure the first three fields are contiguous
    //
    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, CreationTime) == 0);

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, LastModificationTime) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, CreationTime) ==
           sizeof(DupInfo->CreationTime));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, LastChangeTime) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, LastModificationTime) ==
           sizeof(DupInfo->LastModificationTime));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, LastAccessTime) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, LastChangeTime) ==
           sizeof(DupInfo->LastChangeTime));

    len = FIELD_OFFSET(DUPLICATED_INFORMATION, LastAccessTime);
    crc = FsRtlComputeCrc32(0, DupInfo, len);

    //
    // make sure the fourth field and on are contiguous
    //
    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, FileSize) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, AllocatedLength) ==
           sizeof(DupInfo->AllocatedLength));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, FileAttributes) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, FileSize) ==
           sizeof(DupInfo->FileSize));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, ReparsePointTag) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, FileAttributes) ==
           sizeof(DupInfo->FileAttributes));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, PackedEaSize) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, FileAttributes) ==
           sizeof(DupInfo->FileAttributes));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, Reserved) -
           FIELD_OFFSET(DUPLICATED_INFORMATION, PackedEaSize) ==
           sizeof(DupInfo->PackedEaSize));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, ReparsePointTag) +
           sizeof(DupInfo->ReparsePointTag) == sizeof(DUPLICATED_INFORMATION));

    DebugAssert(FIELD_OFFSET(DUPLICATED_INFORMATION, Reserved) +
           sizeof(DupInfo->Reserved) == sizeof(DUPLICATED_INFORMATION));

    len = FIELD_OFFSET(DUPLICATED_INFORMATION, ReparsePointTag) -
          FIELD_OFFSET(DUPLICATED_INFORMATION, AllocatedLength);
    if (_major >= 2 &&
        DupInfo->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
        len += sizeof(DupInfo->ReparsePointTag);
    } else {
        len += sizeof(DupInfo->PackedEaSize);
    }

    crc = FsRtlComputeCrc32(crc, &(DupInfo->AllocatedLength), len);
    memset(Signature, 0, sizeof(DUP_INFO_SIGNATURE));
    memcpy(Signature, &crc, min(sizeof(crc), sizeof(DUP_INFO_SIGNATURE)));
}


VOID
NTFS_MFT_INFO::UpdateRange(
    IN     VCN                  FileNumber
    )
/*++

Routine Description:

    This routine update the range of files that are covered by the object.


Arguments:

    FileNumber  - file number to include into the range.

Return Value:

    N/A

--*/
{
    if (_min_file_number > FileNumber)
        _min_file_number = FileNumber;
    if (_max_file_number < FileNumber)
        _max_file_number = FileNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\mftfile.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    mftfile.hxx

Abstract:

    This module contains the member function definitions for the
    NTFS_MFT_FILE class.

Author:

    Bill McJohn (billmc) 22-June-91

Environment:

    ULIB, User Mode

Notes:

    The MFT and the Volume Bitmap:

        The Master File Table needs the bitmap to extend itself.  The
        volume bitmap can be passed in upon initialization, or it can
        be supplied (using SetVolumeBitmap) at any time.  However,
        until it is supplied, the Master File Table is unable to grow
        itself.

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "attrib.hxx"
#include "ntfsbit.hxx"
#include "mftfile.hxx"
#include "clusrun.hxx"
#include "cmem.hxx"
#include "indxtree.hxx"

#define LOGFILE_PLACEMENT_V1    1

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_MFT_FILE, NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_MFT_FILE::~NTFS_MFT_FILE(
    )
{
    Destroy();
}


VOID
NTFS_MFT_FILE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FirstLcn = 0;
    _VolumeBitmap = NULL;
}


VOID
NTFS_MFT_FILE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_MFT_FILE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _FirstLcn = 0;
    _VolumeBitmap = NULL;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MFT_FILE::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE Drive,
    IN      LCN Lcn,
    IN      ULONG ClusterFactor,
    IN      ULONG FrsSize,
    IN      BIG_INT VolumeSectors,
    IN OUT  PNTFS_BITMAP VolumeBitmap,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
    )
/*++

Routine Description:

    Initialize an NTFS_MFT_FILE object.

Arguments:

    Drive           -- supplies the Drive on which the file table resides
    Lcn             -- supplies the logical cluster number of the master
                        file table entry which describes the master file
                        table itself.
    ClusterFactor   -- supplies the number of sectors per cluster.
    FrsSize         -- supplies the number of bytes per File Record
                        Segment in this MFT.
    VolumeSectors   -- supplies the number of volume sectors.
    VolumeBitmap    -- supplies the bitmap for the volume.  This parameter
                        may be NULL.

Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG MirroredClusters;
    ULONG ClusterSize;

    Destroy();

    DebugPtrAssert( Drive );

    _FirstLcn = Lcn;
    _VolumeBitmap = VolumeBitmap;

    ClusterSize = Drive->QuerySectorSize() * ClusterFactor;

    MirroredClusters = (REFLECTED_MFT_SEGMENTS * FrsSize + (ClusterSize - 1))
        / ClusterSize;

    if( !_MirrorMem.Initialize() ||
        !_MirrorClusterRun.Initialize( &_MirrorMem,
                                       Drive,
                                       0,
                                       ClusterFactor,
                                       MirroredClusters ) ) {

        DebugPrint( "Can't initialize MFT helper cluster run.\n" );
        Destroy();
        return FALSE;
    }

    if (!_Mft.Initialize(&_DataAttribute, &_MftBitmap, VolumeBitmap,
                         UpcaseTable, ClusterFactor, FrsSize,
                         Drive->QuerySectorSize(), VolumeSectors)) {

        return FALSE;
    }

    _Mft.DisableMethods();


    if (!NTFS_FILE_RECORD_SEGMENT::Initialize(Drive,
                                              Lcn,
                                              &_Mft) ) {

        Destroy();
        return FALSE;
    }



    return TRUE;
}


BOOLEAN
NTFS_MFT_FILE::Create(
    IN      ULONG                   InitialSize,
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
    )
/*++

Routine Description:

    Create a new Master File Table for the volume.

Arguments:

    InitialSize         -- supplies the number of clusters to allocate
                            to the MFT we create.
    StandardInformation -- supplies a standard information structure for
                            the MFT's File Record Segment.
    VolumeBitmap        -- supplies the bitmap for the volume.

Return Value:

    TRUE upon successful completion.

Notes:

    The caller must first allocate a run of InitialSize clusters
    from the bitmap, and initialize the NTFS_MFT_FILE object
    with the starting cluster of that run.

--*/
{
    NTFS_EXTENT_LIST Extents;
    NTFS_ATTRIBUTE MftBitmapAttribute;
    LCN FirstLcnInMftBitmap;
    ULONG ClustersInMftBitmap;
    ULONG MftBitmapSize;
    ULONG ClusterSize;
    ULONG MftClusters;

    _Mft.DisableMethods();

    if( InitialSize < FIRST_USER_FILE_NUMBER ) {

        DebugPrint( "MFT Initial Size is too small.\n" );
        return FALSE;
    }


    // Set this object up as a File Record Segment:

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }


    // OK, set up the data attribute with the disk space supplied
    // by the caller.

    ClusterSize = GetDrive()->QuerySectorSize() * QueryClusterFactor();

    MftClusters = (InitialSize * QuerySize() + (ClusterSize - 1)) / ClusterSize;

    if( !Extents.Initialize( 0, 0 ) ||
        !Extents.AddExtent( 0,
                            _FirstLcn,
                            MftClusters ) ||
        !_DataAttribute.Initialize( GetDrive(),
                                    QueryClusterFactor(),
                                    &Extents,
                                    InitialSize * QuerySize(),
                                    InitialSize * QuerySize(),
                                    $DATA ) ||
        !_DataAttribute.Fill(0, 0) ||
        !_DataAttribute.InsertIntoFile( this,
                                        VolumeBitmap ) ) {

        return FALSE;
    }

    // Create an MFT Bitmap attribute.  Allocate a run on disk to
    // hold its initial size, and use that to set up a non-resident
    // attribute to hold it.  The initial size is at least 8k (to
    // allow some space for future growth.)
    //

    MftBitmapSize = (InitialSize + 7)/ 8;

    ClustersInMftBitmap = max((MftBitmapSize + (ClusterSize - 1))/ClusterSize,
                             /* MFT_BITMAP_INITIAL_SIZE/ClusterSize */, 0);

    if( !VolumeBitmap->AllocateClusters(
#if LOGFILE_PLACEMENT_V1    // initial location of MFT Bitmap
                                         _FirstLcn - ClustersInMftBitmap,
#else
                                         1,
#endif
                                         ClustersInMftBitmap,
                                         &FirstLcnInMftBitmap,
                                         1 ) ||
        !Extents.Initialize( 0, 0 ) ||
        !Extents.AddExtent( 0,
                            FirstLcnInMftBitmap,
                            ClustersInMftBitmap ) ||
        !MftBitmapAttribute.Initialize( GetDrive(),
                                        QueryClusterFactor(),
                                        &Extents,
                                        MftBitmapSize,
                                                                /* value length */
                                        /* ClustersInMftBitmap * ClusterSize,   */
                                        MftBitmapSize,          /* valid length */
                                        $BITMAP ) ||
        !MftBitmapAttribute.InsertIntoFile( this,
                                            VolumeBitmap ) ) {

        return FALSE;
    }

    // Create the MFT Bitmap.  Note that it is growable.

    if( !_MftBitmap.Initialize( InitialSize, TRUE ) ) {

        return FALSE;
    }

    // Mark the system files as in use.  Note that we've already
    // checked that InitialSize is at least FIRST_USER_FILE_NUMBER.

    _MftBitmap.SetAllocated( 0, FIRST_USER_FILE_NUMBER );

    _Mft.EnableMethods();

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MFT_FILE::Read(
    )
/*++

Routine Description:

    This routine reads this FRS for the MFT and then proceeds
    to read the MFT bitmap.  If all goes well, the internal
    data attribute and MFT bitmap will be initialized.

    This method will return TRUE if and only if the base FRS for
    this MFT is correctly read in.  The MFT allocation methods will
    be enabled by this method if and only if MFT bitmap and the
    MFT data attribute are properly read in and initialized.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE  MftBitmapAttribute;
    BIG_INT         DataAttributeWrittenLength;
    BIG_INT         DataAttributeAllocatedLength;
    BIG_INT         NumberOfAllocatedFileRecordSegments,
                    NumberOfWrittenFileRecordSegments;
    ULONG           RequiredBitsInBitmap, PreferredBitsInBitmap;
    BOOLEAN         Error;

    _Mft.DisableMethods();

    if (!NTFS_FILE_RECORD_SEGMENT::Read()) {
        return FALSE;
    }

    _Mft.EnableMethods();

    // Make sure that we have the Data Attribute to play with.

    if (!QueryAttribute(&_DataAttribute, &Error, $DATA)) {

        _Mft.DisableMethods();
        return TRUE;
    }


    // The length of the bitmap depends on the allocated length of
    // the data attribute.

    _DataAttribute.QueryValueLength( &DataAttributeWrittenLength,
                                     &DataAttributeAllocatedLength );

    // A quick sanity check:
    //
    if( CompareGT(DataAttributeWrittenLength, DataAttributeAllocatedLength) ) {

        DebugAbort( "UNTFS: MFT Data attribute is corrupt.\n" );
        _Mft.DisableMethods();
        return TRUE;
    }

    NumberOfWrittenFileRecordSegments = DataAttributeWrittenLength / QuerySize();
    NumberOfAllocatedFileRecordSegments = DataAttributeAllocatedLength / QuerySize();

    DebugAssert( NumberOfWrittenFileRecordSegments.GetHighPart() == 0 );
    DebugAssert( NumberOfAllocatedFileRecordSegments.GetHighPart() == 0 );

    RequiredBitsInBitmap = NumberOfWrittenFileRecordSegments.GetLowPart();
    PreferredBitsInBitmap = NumberOfAllocatedFileRecordSegments.GetLowPart();

    // Create a bitmap, and get the MFT bitmap attribute through
    // which we read it, and read the bitmap.

    if( !_MftBitmap.Initialize( RequiredBitsInBitmap, TRUE ) ||
        !QueryAttribute( &MftBitmapAttribute, &Error, $BITMAP ) ||
        !_MftBitmap.Read( &MftBitmapAttribute ) ||
        !_MftBitmap.Resize( PreferredBitsInBitmap ) ) {

        DebugAbort( "Cannot read MFT Bitmap.\n" );
        _Mft.DisableMethods();
        return TRUE;
    }

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_MFT_FILE::Flush(
    )
/*++

Routine Description:

    This method flushes the MFT--re-inserts the DATA attribute (if
    necessary); writes the MFT bitmap, and writes the MFT's own
    File Record Segment.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

Notes:

    This method will also write the volume bitmap and the mft mirror.
    It will resize the $DATA attributes on the bitmap and mirror files
    and write those FRS's, if necessary.

--*/
{
    NTFS_BITMAP_FILE BitmapFile;
    NTFS_REFLECTED_MASTER_FILE_TABLE MirrorFile;
    NTFS_INDEX_TREE RootIndex;
    NTFS_FILE_RECORD_SEGMENT RootIndexFrs;
    DSTRING FileNameIndexName;

    NTFS_ATTRIBUTE MftBitmapAttribute,
                   MirrorDataAttribute,
                   VolumeBitmapAttribute;

    LCN FirstMirrorLcn;
    BIG_INT OldValidLength;
    BOOLEAN Error;

    if( !_Mft.AreMethodsEnabled() ) {

        DebugAbort( "Tried to flush the MFT before enabling it.\n" );
        return FALSE;
    }


    // Ensure that the bitmap file and mirror file's $DATA attributes
    // are the correct sizes.  This will later allow us to write these
    // two constructs without affecting their respective FRS's.

    if( !BitmapFile.Initialize( &_Mft ) ||
        !BitmapFile.Read() ||
        !BitmapFile.QueryAttribute( &VolumeBitmapAttribute,
                                    &Error,
                                    $DATA ) ||
        !_VolumeBitmap->CheckAttributeSize( &VolumeBitmapAttribute,
                                           _VolumeBitmap ) ||
        !MirrorFile.Initialize( &_Mft ) ||
        !MirrorFile.Read() ||
        !MirrorFile.QueryAttribute( &MirrorDataAttribute,
                                    &Error,
                                    $DATA ) ||
        !CheckMirrorSize( &MirrorDataAttribute,
                          TRUE,
                          _VolumeBitmap,
                          &FirstMirrorLcn ) ) {

        DebugPrint( "Cannot check size of bitmap & mirror attributes.\n" );
        return FALSE;
    }


    if( VolumeBitmapAttribute.IsStorageModified() &&
        ( !VolumeBitmapAttribute.InsertIntoFile( &BitmapFile,
                                                 _VolumeBitmap ) ||
          !BitmapFile.Flush( _VolumeBitmap ) ) ) {

        DebugPrint( "Cannot save volume bitmap attribute.\n" );
        return FALSE;
    }

    if( MirrorDataAttribute.IsStorageModified() &&
        ( !MirrorDataAttribute.InsertIntoFile( &MirrorFile, _VolumeBitmap ) ||
          !MirrorFile.Flush( _VolumeBitmap ) ) ) {

        DebugPrint( "Cannot save MFT mirror data attribute.\n" );
        return FALSE;
    }

    // Fetch the root index from its FRS.
    //
    if( !RootIndexFrs.Initialize( ROOT_FILE_NAME_INDEX_NUMBER, this ) ||
        !RootIndexFrs.Read() ||
        !FileNameIndexName.Initialize( FileNameIndexNameData ) ||
        !RootIndex.Initialize( GetDrive(),
                               QueryClusterFactor(),
                               _VolumeBitmap,
                               GetUpcaseTable(),
                               QuerySize()/2,
                               &RootIndexFrs,
                               &FileNameIndexName ) ) {

        return FALSE;
    }

    // Fetch the MFT Bitmap attribute.
    //
    if( !QueryAttribute( &MftBitmapAttribute, &Error, $BITMAP ) ) {

        DebugPrintTrace(( "UNTFS: Cannot fetch MFT bitmap attribute.\n" ));
        return FALSE;
    }

    // Write the bitmap once to make it the right size.  If
    // it grows while we're saving the MFT, we'll have to
    // write it again.
    //
    if( !_MftBitmap.Write( &MftBitmapAttribute, _VolumeBitmap ) ) {

        DebugPrintTrace(( "UNTFS: Cannot write the MFT bitmap.\n" ));
        return FALSE;
    }

    do {

        // Note that inserting an attribute into a file resets the
        // attribute's StorageModified flag.
        //
        if( MftBitmapAttribute.IsStorageModified() &&
            !MftBitmapAttribute.InsertIntoFile( this, NULL ) ) {

            DebugPrint( "UNTFS: Cannot save MFT bitmap attribute.\n" );
            return FALSE;
        }

        // Remember the bitmap size (which is equal to the number
        // of FRS's in the MFT).
        //
        OldValidLength = _DataAttribute.QueryValidDataLength();

        // Save the data attribute.
        //
        if( _DataAttribute.IsStorageModified() &&
            !_DataAttribute.InsertIntoFile(this, NULL) ) {

            DebugAbort( "UNTFS: Cannot save MFT's data attribute.\n" );
            return FALSE;
        }

        // Flush this FRS.
        //
        if( !NTFS_FILE_RECORD_SEGMENT::Flush( _VolumeBitmap, &RootIndex) ) {

            return FALSE;
        }

        // Write the bitmap again, in case it changed.
        //
        if( !_MftBitmap.Write( &MftBitmapAttribute, _VolumeBitmap ) ) {

            DebugPrintTrace(( "UNTFS: Cannot write the MFT bitmap.\n" ));
            return FALSE;
        }

        // If the MFT's Valid Data Length changed while we were
        // saving the data attribute and bitmap, we have to go
        // through this loop again.

    } while( OldValidLength != _DataAttribute.QueryValidDataLength() );

    // Save the root index:
    //
    if( !RootIndex.Save( &RootIndexFrs ) ||
        !RootIndexFrs.Flush( _VolumeBitmap ) ) {

        return FALSE;
    }

    if( !_VolumeBitmap->Write( &VolumeBitmapAttribute, NULL ) ||
        !WriteMirror( &MirrorDataAttribute ) ){

        DebugPrint( "Failed write of MFT Mirror or volume bitmap.\n" );
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_MFT_FILE::CheckMirrorSize(
    IN OUT PNTFS_ATTRIBUTE  MirrorDataAttribute,
    IN     BOOLEAN          Fix,
    IN OUT PNTFS_BITMAP     VolumeBitmap,
    OUT    PLCN             FirstLcn
    )
/*++

Routine Description:

    This method checks that the MFT Mirror $DATA attribute is the
    correct size and contiguous.  It can also be used to check these
    restrictions.

Arguments:

    MirrorDataAttribut  --  Supplies the MFT Mirror's $DATA attribute.
    Fix                 --  Supplies a flag which indicates that the
                            attribute should be reallocated if it is
                            the wrong size or not contiguous.
    VolumeBitmap        --  Supplies the volume bitmap (only required
                            if Fix is TRUE).
    FirstLcn            --  Receives the starting LCN of the mirror.

Return Value:

    TRUE upon successful completion.

--*/
{
    BIG_INT RunLength;
    LCN     NewStartingLcn;
    ULONG   MirroredClusters;
    ULONG   ClusterSize;

    ClusterSize = QueryClusterFactor() * _Mft.QuerySectorSize();

    MirroredClusters = (REFLECTED_MFT_SEGMENTS * QuerySize() + (ClusterSize - 1))
         / ClusterSize;

    if( MirrorDataAttribute->QueryLcnFromVcn( 0, FirstLcn, &RunLength ) &&
        *FirstLcn != 0 &&
        *FirstLcn != LCN_NOT_PRESENT &&
        RunLength >= MirroredClusters ) {

        // Everything is perfect.

        return TRUE;
    }

    // Something is not perfect.

    if( Fix &&
        VolumeBitmap->AllocateClusters( QueryVolumeSectors()/
                                            QueryClusterFactor()/
                                            2,
                                        MirroredClusters,
                                        &NewStartingLcn ) &&
        MirrorDataAttribute->Resize( 0, VolumeBitmap ) &&
        MirrorDataAttribute->AddExtent( 0,
                                        NewStartingLcn,
                                        MirroredClusters ) ) {

        // It was broken, but now it's perfect.

        *FirstLcn = NewStartingLcn;
        return TRUE;
    }

    return FALSE;
}


BOOLEAN
NTFS_MFT_FILE::WriteMirror(
    IN OUT PNTFS_ATTRIBUTE  MirrorDataAttribute
    )
/*++

Routine Description:

    This method writes the MFT Mirror.  Note that it will fail if
    the mirror's $DATA attribute is not the correct size or is
    not contiguous.

Arguments:

    MirrorDataAttribute --  Supplies the MFT Mirror's $DATA attribute.

Return Value:

    TRUE upon successful completion.

Notes:

    This method copies whatever is _on disk_ in the MFT's data attribute
    to the mirror's data attribute.  Therefore, it should only be called
    after the MFT itself has been written.

--*/
{
    LCN FirstMirrorLcn;

    if( !CheckMirrorSize( MirrorDataAttribute,
                          FALSE,
                          NULL,
                          &FirstMirrorLcn ) ) {

        return FALSE;
    }

    _MirrorClusterRun.Relocate( _FirstLcn );

    if( !_MirrorClusterRun.Read() ) {

        return FALSE;
    }

    _MirrorClusterRun.Relocate( FirstMirrorLcn );

    if( !_MirrorClusterRun.Write() ) {

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\mftref.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mftref.cxx

Abstract:

    This module contains the member function definitions for
    the NTFS_REFLECTED_MASTER_FILE_TABLE class.  This class
    models the backup copy of the Master File Table.

Author:

    Bill McJohn (billmc) 13-June-91

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "drive.hxx"
#include "attrib.hxx"
#include "ntfsbit.hxx"
#include "mftref.hxx"
#include "ifssys.hxx"
#include "numset.hxx"
#include "message.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_REFLECTED_MASTER_FILE_TABLE,
                    NTFS_FILE_RECORD_SEGMENT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_REFLECTED_MASTER_FILE_TABLE::~NTFS_REFLECTED_MASTER_FILE_TABLE(
    )
{
    Destroy();
}


VOID
NTFS_REFLECTED_MASTER_FILE_TABLE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
NTFS_REFLECTED_MASTER_FILE_TABLE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_MASTER_FILE_TABLE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


BOOLEAN
NTFS_REFLECTED_MASTER_FILE_TABLE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes a Master File Table Reflection object.
    The only special knowledge that it adds to the File Record Segment
    initialization is the location within the Master File Table of the
    Master File Table Reflection.

Arguments:

    Mft             -- Supplies the volume MasterFile Table.

Return Value:

    TRUE upon successful completion

Notes:

    This class is reinitializable.


--*/
{
    return( NTFS_FILE_RECORD_SEGMENT::Initialize( MASTER_FILE_TABLE2_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_REFLECTED_MASTER_FILE_TABLE::Create(
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
    )
/*++

Routine Description:

    This method formats a Master File Table Reflection File Record
    Segment in memory (without writing it to disk).

Arguments:

    StandardInformation -- supplies the standard information for the
                            file record segment.
    VolumeBitmap        -- supplies the bitmap for the volume on
                            which this object resides.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;
    LCN FirstLcn;
    BIG_INT Size;
    ULONG ReflectedMftClusters;
    ULONG cluster_size;

    // Set this object up as a File Record Segment.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }

    // The Master File Table Reflection has a data attribute whose value
    // consists of REFLECTED_MFT_SEGMENTS file record segments.  Create
    // merely allocates space for these clusters, it does not write them.

    cluster_size = QueryClusterFactor() * GetDrive()->QuerySectorSize();

    ReflectedMftClusters = (REFLECTED_MFT_SEGMENTS * QuerySize() + (cluster_size-1))
         / cluster_size;

    Size = ReflectedMftClusters * cluster_size;

    if( !VolumeBitmap->AllocateClusters( (QueryVolumeSectors()/2)/
                                                QueryClusterFactor(),
                                         ReflectedMftClusters,
                                         &FirstLcn ) ||
        !Extents.Initialize( 0, 0 ) ||
        !Extents.AddExtent( 0,
                            FirstLcn,
                            ReflectedMftClusters ) ||
        !DataAttribute.Initialize( GetDrive(),
                                    QueryClusterFactor(),
                                    &Extents,
                                    Size,
                                    Size,
                                    $DATA ) ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        return FALSE;
    }


    return TRUE;
}


NONVIRTUAL
BOOLEAN
NTFS_REFLECTED_MASTER_FILE_TABLE::VerifyAndFix(
    IN      PNTFS_ATTRIBUTE     MftData,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNUMBER_SET         BadClusters,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine ensures that this FRS's $DATA attribute is the
    appropriate length (from 1 to 3 clusters).  It also compares
    the data in these clusters with the first clusters of the
    $MftData attribute and prints a message if they are different.

    This routine does not actually write out the contents of these
    clusters because this is done by MFT_FILE::Flush()

Arguments:

    MftData      - Supplies the MFT $DATA attribute.
    VolumeBitmap - Supplies the volume bitmap.
    BadClusters  - Supplies the list of bad clusters.
    RootIndex    - Supplies the root index.
    Changes      - Returns whether or not changes were made.
    FixLevel     - Supplies the CHKDSK fix level.
    Message      - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM                mft_hmem, ref_hmem;
    SECRUN              mft_secrun, ref_secrun;
    LCN                 mft_lcn, ref_lcn;
    BIG_INT             run_length;
    ULONG               num_clusters;
    ULONG               num_sectors;
    ULONG               num_bytes, bytes_written;
    BOOLEAN             need_write;
    NTFS_ATTRIBUTE      data_attribute;
    NTFS_EXTENT_LIST    extents;
    BOOLEAN             error;


    *Changes = FALSE;

    // First read in the original stuff.

    num_sectors = (REFLECTED_MFT_SEGMENTS*QuerySize())/GetDrive()->QuerySectorSize();
    num_bytes = num_sectors * GetDrive()->QuerySectorSize();

    if (!MftData->QueryLcnFromVcn(0, &mft_lcn) ||
        !mft_hmem.Initialize() ||
        !mft_secrun.Initialize(&mft_hmem, GetDrive(),
                               mft_lcn*QueryClusterFactor(),
                               num_sectors) ||
        !mft_secrun.Read()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    need_write = FALSE;


    // Query the $DATA attribute from this FRS.

    if (!QueryAttribute(&data_attribute, &error, $DATA) ||
        data_attribute.IsResident()) {

        if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_OR_RESIDENT_DATA_ATTR_IN_MFT_MIRROR);

        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_MIRROR);

        need_write = TRUE;

        if (!extents.Initialize(0, 0) ||
            !data_attribute.Initialize(GetDrive(), QueryClusterFactor(),
                                       &extents, 0, 0, $DATA)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT_MIRROR);
            return FALSE;
        }
    }


    // Make sure that the $DATA attribute is the right size.

    error = FALSE;

    if (need_write) {
        error = TRUE;
    } else if (!data_attribute.QueryLcnFromVcn(0, &ref_lcn, &run_length)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT_MIRROR);

        error = TRUE;
    } else if (ref_lcn == LCN_NOT_PRESENT) {

        Message->LogMsg(MSG_CHKLOG_NTFS_LCN_NOT_PRESENT_FOR_VCN_ZERO_OF_MFT_MIRROR);

        error = TRUE;
    } else if (run_length*QueryClusterFactor() < num_sectors) {

        Message->LogMsg(MSG_CHKLOG_NTFS_DISCONTIGUOUS_MFT_MIRROR);

        error = TRUE;
    } else if (data_attribute.QueryValueLength() < num_bytes) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MFT_MIRROR_HAS_INVALID_VALUE_LENGTH,
                        "%I64x%x",
                        data_attribute.QueryValueLength().GetLargeInteger(),
                        num_bytes);

        error = TRUE;
    } else if (data_attribute.QueryValidDataLength() < num_bytes) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MFT_MIRROR_HAS_INVALID_DATA_LENGTH,
                        "%I64x%x",
                        data_attribute.QueryValidDataLength().GetLargeInteger(),
                        num_bytes);

        error = TRUE;
    } else if (!ref_hmem.Initialize()) {

        error = TRUE;
    } else if (!ref_secrun.Initialize(&ref_hmem, GetDrive(),
                                      ref_lcn*QueryClusterFactor(),
                                      num_sectors)) {

        error = TRUE;
    } else if (!ref_secrun.Read()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_MFT_MIRROR,
                     "%I64x%x",
                     ref_lcn.GetLargeInteger(),
                     num_sectors);
        error = TRUE;
    }

    if (error) {

        if (!need_write) {
            Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_MIRROR);
        }

        need_write = TRUE;

        if (data_attribute.QueryLcnFromVcn(0, &ref_lcn, &run_length) &&
            ref_lcn != LCN_NOT_PRESENT &&
            !BadClusters->Add(ref_lcn, run_length)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

         num_clusters = (num_sectors+QueryClusterFactor()-1)/QueryClusterFactor();

        // the write below is just to change the valid data length and valid length
        // to the correct value.  The content we write is not of importance.

        if (!data_attribute.Hotfix(0, num_clusters, VolumeBitmap,
                                   BadClusters, TRUE) ||
            !data_attribute.Write(NULL,
                                  num_bytes,
                                  0,
                                  &bytes_written,
                                  NULL)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT_MIRROR);
            return FALSE;
        }

    } else if (memcmp(mft_hmem.GetBuf(), ref_hmem.GetBuf(),
                      REFLECTED_MFT_SEGMENTS*QuerySize())) {

        Message->LogMsg(MSG_CHKLOG_NTFS_MFT_MIRROR_DIFFERENT_FROM_MFT);

        if (!need_write) {
            Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_MIRROR);
        }

        need_write = TRUE;  // set the change status
    }

    if ((data_attribute.IsStorageModified() &&
         !data_attribute.InsertIntoFile(this, VolumeBitmap)) ||
        (need_write && FixLevel != CheckOnly &&
         !Flush(VolumeBitmap, RootIndex))) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT_MIRROR);
        return FALSE;
    }

    *Changes = need_write;

    return TRUE;
}


LCN
NTFS_REFLECTED_MASTER_FILE_TABLE::QueryFirstLcn(
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    The LCN of the first cluster of the Master File Table
    Reflection's $DATA attribute.

--*/
{
    NTFS_ATTRIBUTE  DataAttribute;
    LCN             Result = 0;
    BOOLEAN         Error;

    if( !QueryAttribute( &DataAttribute, &Error, $DATA ) ||
        !DataAttribute.QueryLcnFromVcn( 0, &Result ) ) {

        Result = 0;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\ntfsbit.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    ntfsbit.cxx

Abstract:

    This module contains the declarations for NTFS_BITMAP,
    which models the bitmap of an NTFS volume, and MFT_BITMAP,
    which models the bitmap for the Master File Table.

Author:

    Bill McJohn (billmc) 17-June-91

Environment:

    ULIB, User Mode

Notes:

    This implementation only supports bitmaps which have a number
    of sectors which will fit in a ULONG.  The interface supports
    the 64-bit number of clusters, but Initialize will refuse to
    accept a number-of-clusters value which has a non-zero high part.

    If we rewrite BITVECTOR to accept 64-bit cluster numbers (or
    write a new one) this class could easily be fixed to support
    larger volumes.

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "ntfsbit.hxx"
#include "attrib.hxx"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_BITMAP, OBJECT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_BITMAP::~NTFS_BITMAP(
            )
{
    Destroy();
}

VOID
NTFS_BITMAP::Construct(
    )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _NumberOfClusters = 0;
    _BitmapSize = 0;
    _BitmapData = NULL;
    _NextAlloc = 0;
    _Mft = NULL;
    _ClusterFactor = 0;
    _Drive = NULL;
}

VOID
NTFS_BITMAP::Destroy(
    )
/*++

Routine Description:

    Worker method to prepare an object for destruction
    or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _NumberOfClusters = 0;
    _BitmapSize = 0;
    FREE( _BitmapData );
    _NextAlloc = 0;
    _Mft = NULL;
}



UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP::Initialize(
    IN BIG_INT NumberOfClusters,
    IN BOOLEAN IsGrowable,
    IN PLOG_IO_DP_DRIVE Drive,
    IN ULONG ClusterFactor
    )
/*++

Routine Description:

    This method initializes an NTFS_BITMAP object.

Arguments:

    NumberOfClusters    --  Supplies the number of allocation units
                            which the bitmap covers.
    IsGrowable          --  Supplies a flag indicating whether the
                            bitmap may grow (TRUE) or is of fixed size
                            (FALSE).

Return Value:

    TRUE upon successful completion.

Notes:

    The bitmap is initialized with all clusters within the range of
    NumberOfClusters marked as FREE.

--*/
{
    ULONG LowNumberOfClusters;

    Destroy();

    if( NumberOfClusters.GetHighPart() != 0 ) {

        DebugPrint( "bitmap.cxx:  cannot manage a volume of this size.\n" );
        return FALSE;
    }

    LowNumberOfClusters = NumberOfClusters.GetLowPart();

    _NumberOfClusters = NumberOfClusters;
    _IsGrowable = IsGrowable;

    _Drive = Drive;
    _ClusterFactor = ClusterFactor;


    // Determine the size in bytes of the bitmap.  Note that this size
    // is quad-aligned.

    _BitmapSize = ( LowNumberOfClusters % 8 ) ?
                        ( LowNumberOfClusters/8 + 1 ) :
                        ( LowNumberOfClusters/8 );

    _BitmapSize = QuadAlign( max(_BitmapSize, 1) );


    // Allocate space for the bitvector and initialize it.

    if( (_BitmapData = MALLOC( _BitmapSize )) == NULL ||
        !_Bitmap.Initialize( _BitmapSize * 8,
                             RESET,
                             (PPT)_BitmapData ) ) {

        // Note that Destroy will clean up _BitmapData

        Destroy();
        return FALSE;
    }

    // If the bitmap is growable, then any padding bits are reset (free);
    // if it is fixed size, they are set (allocated).

    if( _IsGrowable ) {

        _Bitmap.ResetBit( _NumberOfClusters.GetLowPart(),
                          _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );

    } else {

        _Bitmap.SetBit( _NumberOfClusters.GetLowPart(),
                        _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );
    }

    // The bitmap is intialized with all clusters marked free.
    //
    SetFree( 0, _NumberOfClusters );

    return TRUE;
}


UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP::Write(
    IN OUT  PNTFS_ATTRIBUTE BitmapAttribute,
    IN OUT  PNTFS_BITMAP    VolumeBitmap
    )
/*++

Routine Description:

    This method writes the bitmap.

Arguments:

    BitmapAttribute -- supplies the attribute which describes the
                        bitmap's location on disk.
    VolumeBitmap    -- supplies the volume's bitmap for possible
                        allocation during write.

Return Value:

    TRUE upon successful completion.

Notes:

    The attribute will, if necessary, allocate space from the
    bitmap to write it.

--*/
{
    ULONG BytesWritten;

    DebugPtrAssert( _BitmapData );



    return( CheckAttributeSize( BitmapAttribute, VolumeBitmap ) &&
            BitmapAttribute->Write( _BitmapData,
                                    0,
                                    _BitmapSize,
                                    &BytesWritten,
                                    VolumeBitmap ) &&
            BytesWritten == _BitmapSize );
}

UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP::IsFree(
    IN LCN Lcn,
    IN BIG_INT  RunLength
    ) CONST
/*++

Routine Description:

    This method determines whether the specified cluster run is
    marked as free in the bitmap.

Arguments:

    Lcn         -- supplies the LCN of the first cluster in the run
    RunLength   -- supplies the length of the run

Return Value:

    TRUE if all clusters in the run are free in the bitmap.

Notes:

    This method checks to make sure that the LCNs in question are in
    range, i.e. less than the number of clusters in the bitmap.

--*/
{
    ULONG i, CurrentLcn;


    if( Lcn < 0 ||
        Lcn + RunLength > _NumberOfClusters ) {

        return FALSE;
    }

    // Note that, since _NumberOfClusters is not greater than the
    // maximum ULONG, the high parts of Lcn and RunLength are
    // sure to be zero.

    for( i = 0, CurrentLcn = Lcn.GetLowPart();
         i < RunLength.GetLowPart();
         i++, CurrentLcn++ ) {

        if( _Bitmap.IsBitSet( CurrentLcn ) ) {

            return FALSE;
        }
    }

    return TRUE;
}

BIG_INT
NTFS_BITMAP::QueryFreeBlockSize(
    IN LCN Lcn
    ) CONST
/*++

Routine Description:

    This method determines the size of the free block starting at
    the given location.

Arguments:

    Lcn         -- supplies the LCN of the first cluster in the run

Return Value:

    Number of contiguous free cluster

Notes:

    This method checks to make sure that the LCNs in question are in
    range, i.e. less than the number of clusters in the bitmap.

--*/
{
    ULONG CurrentLcn;


    if( Lcn < 0 ||
        Lcn > _NumberOfClusters ) {

        return FALSE;
    }

    DebugAssert(Lcn.GetHighPart() == 0);
    DebugAssert(_NumberOfClusters.GetHighPart() == 0);

    for( CurrentLcn = Lcn.GetLowPart();
         CurrentLcn < _NumberOfClusters;
         CurrentLcn++ ) {

        if( _Bitmap.IsBitSet( CurrentLcn ) ) {

            return (CurrentLcn - Lcn.GetLowPart());
        }
    }

    return (CurrentLcn - Lcn.GetLowPart());
}

UNTFS_EXPORT
BOOLEAN
NTFS_BITMAP::IsAllocated(
    IN LCN Lcn,
    IN BIG_INT  RunLength
    ) CONST
/*++

Routine Description:

    This method determines whether the specified cluster run is
    marked as used in the bitmap.

Arguments:

    Lcn         -- supplies the LCN of the first cluster in the run
    RunLength   -- supplies the length of the run

Return Value:

    TRUE if all clusters in the run are in use in the bitmap.

Notes:

    This method checks to make sure that the LCNs in question are in
    range, i.e. less than the number of clusters in the bitmap.

--*/
{
    ULONG i, CurrentLcn;


    if( Lcn < 0 ||
        Lcn + RunLength > _NumberOfClusters ) {

        return FALSE;
    }

    // Note that, since _NumberOfClusters is not greater than the
    // maximum ULONG, the high parts of Lcn and RunLength are
    // sure to be zero.

    for( i = 0, CurrentLcn = Lcn.GetLowPart();
         i < RunLength.GetLowPart();
         i++, CurrentLcn++ ) {

        if( !_Bitmap.IsBitSet( CurrentLcn ) ) {

            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
NTFS_BITMAP::AllocateClusters(
    IN  LCN     NearHere,
    IN  BIG_INT RunLength,
    OUT PLCN    FirstAllocatedLcn,
    IN  ULONG   AlignmentFactor
    )
/*++

Routine Description:

    This method finds a free run of sectors and marks it as allocated.

    If the bitmap being allocated from is the volume bitmap, this method
    will have a valid _Drive member.  In this case, it will attempt to
    verify that only usable clusters are allocated.  If _Mft is also
    set, any bad clusters found will be added to the bad cluster file.

Arguments:

    NearHere            -- supplies the LCN near which the caller would
                            like the space allocated.
    RunLength           -- supplies the number of clusters to be allocated
    FirstAllocatedLcn   -- receives the first LCN of the allocated run
    AlignmentFactor     -- supplies the alignment requirement for the
                            allocated run--it must start on a multiple
                            of AlignmentFactor.

Return Value:

    TRUE upon successful completion; FirstAllocatedLcn receives the
    LCN of the first cluster in the run.

--*/
{
    ULONG       current_lcn;
    LCN         first_allocated_lcn;
    ULONG       count;
    BOOLEAN     verify_each;

    NTFS_BAD_CLUSTER_FILE badclus;

    if (NearHere == 0) {
        NearHere = _NextAlloc;
    }

    if (NearHere + RunLength >  _NumberOfClusters) {
        NearHere = _NumberOfClusters/2;
    }

    if( RunLength.GetHighPart() != 0 ) {

        DebugAbort( "UNTFS: Trying to allocate too many sectors.\n" );
        return FALSE;
    }

    //
    // First we'll allocate a run and verify the whole thing at once.
    // If that fails we'll go through the bitmap again, verifying each
    // cluster.
    //

    verify_each = FALSE;

again:

    // Search forwards for a big enough block.

    count = RunLength.GetLowPart();
    for (current_lcn = NearHere.GetLowPart();
         count > 0 && current_lcn < _NumberOfClusters;
         current_lcn += 1) {

        if (IsFree(current_lcn, 1)) {

            if (count == RunLength.GetLowPart() && current_lcn%AlignmentFactor != 0) {
                continue;
            }

            if (verify_each && NULL != _Drive) {

                // Insure that this cluster is functional and can accept IO.

                if (!_Drive->Verify(current_lcn * _ClusterFactor,
                                    _ClusterFactor)) {

                    // This cluster is bad.  Set the bit in the bitmap so we
                    // won't waste time trying to allocate it again and start
                    // over.

                    SetAllocated(current_lcn, 1);
                    count = RunLength.GetLowPart();

                    // If the bad cluster file is available, add this lcn
                    // to it.

                    if (NULL != _Mft) {
                        if (!badclus.Initialize(_Mft) ||
                            !badclus.Read() ||
                            !badclus.Add(current_lcn) ||
                            !badclus.Flush(this)) {
                            DebugPrintTrace(("Unable to update bad cluster file.  Bad Cluster at: %x\n",
                                             current_lcn));
                        }
                    }

                    continue;
                }
            }

            count -= 1;

        } else {
            count = RunLength.GetLowPart();
        }
    }

    //
    // If the forward search succeeded then allocate and return the
    // result.
    //

    if (count == 0) {

        first_allocated_lcn = current_lcn - RunLength;

        if (NULL != _Drive && !_Drive->Verify(first_allocated_lcn * _ClusterFactor,
                                              RunLength * _ClusterFactor,
                                              NULL)) {

            if (verify_each) {

                // If we have been here before, then the whole block is bad as
                // Verify cannot tell which individual cluster is/are bad

                SetAllocated(first_allocated_lcn, RunLength);
                verify_each = FALSE;
                NearHere = first_allocated_lcn + RunLength;

                if (NULL != _Mft) {
                    if (!badclus.Initialize(_Mft) ||
                        !badclus.Read() ||
                        !badclus.AddRun(first_allocated_lcn, RunLength) ||
                        !badclus.Flush(this)) {
                        DebugPrintTrace(("Unable to update bad cluster file.\n"
                                         "Bad Cluster starts at %x%x with run length %x%x\n",
                                         first_allocated_lcn.GetHighPart(),
                                         first_allocated_lcn.GetLowPart(),
                                         RunLength.GetHighPart(),
                                         RunLength.GetLowPart()));
                    }
                }

                goto again;
            }

            //
            // Want to go through each cluster in the run we found and
            // figure out which ones are bad.
            //

            verify_each = TRUE;
            NearHere = first_allocated_lcn;
            goto again;
        }

        *FirstAllocatedLcn = first_allocated_lcn;
        SetAllocated(first_allocated_lcn, RunLength);
        _NextAlloc = first_allocated_lcn + RunLength;
        return TRUE;
    }

    //
    // We couldn't find any space by searching forwards, so let's
    // search backwards.
    //

    verify_each = FALSE;

again_backward:

    count = RunLength.GetLowPart();
    for (current_lcn = NearHere.GetLowPart() + RunLength.GetLowPart() - 1;
         count > 0 && current_lcn > 0; current_lcn -= 1) {

        if (IsFree(current_lcn, 1)) {

            if (count == RunLength.GetLowPart() &&
                (current_lcn - RunLength.GetLowPart() + 1)%AlignmentFactor != 0) {

                continue;
            }

            if (verify_each && NULL != _Drive) {

                // Insure that this cluster is functional and can accept IO.

                if (!_Drive->Verify(current_lcn * _ClusterFactor,
                                    _ClusterFactor)) {

                    // This cluster is bad.  Set the bit in the bitmap so we
                    // won't waste time trying to allocate it again and start
                    // over.

                    SetAllocated(current_lcn, 1);
                    count = RunLength.GetLowPart();

                    // If the bad cluster file is available, add this lcn
                    // to it.

                    if (NULL != _Mft) {
                        if (!badclus.Initialize(_Mft) ||
                            !badclus.Read() ||
                            !badclus.Add(current_lcn) ||
                            !badclus.Flush(this)) {
                            DebugPrintTrace(("Unable to update bad cluster file.  Bad Cluster at: %x\n",
                                             current_lcn));
                        }
                    }

                    continue;
                }
            }

            count -= 1;
        } else {

            count = RunLength.GetLowPart();
        }
    }

    if (count != 0) {
        return FALSE;
    }

    first_allocated_lcn = current_lcn + 1;

    if (NULL != _Drive && !_Drive->Verify(first_allocated_lcn * _ClusterFactor,
                                          RunLength * _ClusterFactor,
                                          NULL)) {

        if (verify_each) {

            // If we have been here before, then the whole block is bad as
            // Verify cannot tell which individual cluster is/are bad

            SetAllocated(first_allocated_lcn, RunLength);
            verify_each = FALSE;
            NearHere = first_allocated_lcn - RunLength;

            if (NULL != _Mft) {
                if (!badclus.Initialize(_Mft) ||
                    !badclus.Read() ||
                    !badclus.AddRun(first_allocated_lcn, RunLength) ||
                    !badclus.Flush(this)) {
                    DebugPrintTrace(("Unable to update bad cluster file.\n"
                                     "Bad Cluster starts at %x%x with run length %x%x\n",
                                     first_allocated_lcn.GetHighPart(),
                                     first_allocated_lcn.GetLowPart(),
                                     RunLength.GetHighPart(),
                                     RunLength.GetLowPart()));
                }
            }

            goto again_backward;
        }

        //
        // Want to go through each cluster in the run we found and
        // figure out which ones are bad.
        //

        verify_each = TRUE;
        NearHere = first_allocated_lcn + RunLength + 1;
        goto again_backward;
    }

    //
    // Since we had to search backwards, we don't want to start
    // our next search from here (and waste time searching forwards).
    // Instead, set the roving pointer to zero.
    //

    *FirstAllocatedLcn = first_allocated_lcn;
    SetAllocated(first_allocated_lcn, RunLength);
    _NextAlloc = 0;

    return TRUE;
}


BOOLEAN
NTFS_BITMAP::Resize(
    IN BIG_INT NewNumberOfClusters
    )
/*++

Routine Description:

    This method changes the number of allocation units that the bitmap
    covers.  It may either grow or shrink the bitmap.

Arguments:

    NewNumberOfClusters --  supplies the new number of allocation units
                            covered by this bitmap.

Return Value:

    TRUE upon successful completion.

Notes:

    The size (in bytes) of the bitmap is always kept quad-aligned, and
    any padding bits are reset.

--*/
{
    PVOID NewBitmapData;
    ULONG NewSize;
    LCN OldNumberOfClusters;


    DebugAssert( _IsGrowable );


    // Make sure that the number of clusters fits into a ULONG,
    // so we can continue to use BITVECTOR.

    if( NewNumberOfClusters.GetHighPart() != 0 ) {

        DebugPrint( "bitmap.cxx:  cannot manage a volume of this size.\n" );
        return FALSE;
    }

    // Compute the new size of the bitmap, in bytes.  Note that this
    // size is always quad-aligned (ie. a multiple of 8).

    NewSize = ( NewNumberOfClusters.GetLowPart() % 8 ) ?
                    ( NewNumberOfClusters.GetLowPart()/8 + 1) :
                    ( NewNumberOfClusters.GetLowPart()/8 );

    NewSize = QuadAlign( NewSize );

    if( NewSize == _BitmapSize ) {

        // The bitmap is already the right size, so it's just a matter
        // of diddling the private data.  Since padding in a growable
        // bitmap is always reset (free), the new space is by default
        // free.

        _NumberOfClusters = NewNumberOfClusters;
        return TRUE;
    }

    // The bitmap has changed size, so we need to allocate new memory
    // for it and copy it.

    if( (NewBitmapData = MALLOC( NewSize )) == NULL ) {

        return FALSE;
    }

    // Note that, if we supply the memory, BITVECTOR::Initialize
    // cannot fail, so we don't check its return value.

    _Bitmap.Initialize( NewSize * 8,
                        RESET,
                        (PPT)NewBitmapData );

    if( NewNumberOfClusters < _NumberOfClusters ) {

        // Copy the part of the old bitmap that we wish to
        // preserve into the new bitmap.

        memcpy( NewBitmapData,
                _BitmapData,
                NewSize );

    } else {

        // Copy the old bitmap into the new bitmap, and then
        // mark all the newly claimed space as unused.

        memcpy( NewBitmapData,
                _BitmapData,
                _BitmapSize );

        SetFree( _NumberOfClusters,
                 NewNumberOfClusters - _NumberOfClusters );
    }

    FREE( _BitmapData );
    _BitmapData = NewBitmapData;

    _BitmapSize = NewSize;
    _NumberOfClusters = NewNumberOfClusters;

    // Make sure the padding bits are reset.

    _Bitmap.ResetBit( _NumberOfClusters.GetLowPart(),
                      _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );

    return TRUE;
}


VOID
NTFS_BITMAP::SetGrowable(
    IN  BOOLEAN Growable
    )
/*++

Routine Description:

    This method changes whether the bitmap is growable or not.  This
    primarily effects the padding bits, if any, at the end of the bitmap.
    They are clear for growable bitmaps and set for non-growable ones.

Arguments:

    Growable -- Whether the bitmap should be growable.

Return Value:

    None.

--*/
{
    if (Growable) {

        _Bitmap.ResetBit( _NumberOfClusters.GetLowPart(),
                          _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );
    } else {

        _Bitmap.SetBit( _NumberOfClusters.GetLowPart(),
                        _BitmapSize * 8 - _NumberOfClusters.GetLowPart() );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\pch.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Pre-compiled header for untfs.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#if defined(FE_SB) && defined(_X86_)
#include "machine.hxx"
#endif

#include "untfs.hxx"
#include "attrcol.hxx"
#include "attrdef.hxx"
#include "attrib.hxx"
#include "attrlist.hxx"
#include "attrrec.hxx"
#include "badfile.hxx"
#include "bitfrs.hxx"
#include "bootfile.hxx"
#include "clusrun.hxx"
#include "extents.hxx"
#include "frs.hxx"
#include "frsstruc.hxx"
#include "hackwc.hxx"
#include "indxbuff.hxx"
#include "indxroot.hxx"
#include "indxtree.hxx"
#include "logfile.hxx"
#include "mft.hxx"
#include "mftfile.hxx"
#include "mftinfo.hxx"
#include "mftref.hxx"
#include "ntfsbit.hxx"
#include "ntfssa.hxx"
#include "ntfsvol.hxx"
#include "rafile.hxx"
#include "rasd.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "ifssys.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\ntfssa.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"

#include "array.hxx"
#include "arrayit.hxx"

#include "mftfile.hxx"
#include "ntfsbit.hxx"
#include "frs.hxx"
#include "wstring.hxx"
#include "indxtree.hxx"
#include "badfile.hxx"
#include "bitfrs.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "mft.hxx"
#include "logfile.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "ifssys.hxx"

extern "C" {
#include "bootntfs.h"
#include "boot98n.h"
}

#if !defined( _SETUP_LOADER_ ) && !defined( _AUTOCHECK_ )

#include "path.hxx"

#endif // _SETUP_LOADER_

UCHAR NTFS_SA::_MajorVersion = NTFS_CURRENT_MAJOR_VERSION,
      NTFS_SA::_MinorVersion = NTFS_CURRENT_MINOR_VERSION;

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_SA, SUPERAREA, UNTFS_EXPORT );


VOID
NTFS_SA::Construct (
    )
/*++

Routine Description:

    This routine sets an NTFS_SA to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _cleanup_that_requires_reboot = FALSE;
    _boot_sector = NULL;
    memset(&_bpb, 0, sizeof(BIOS_PARAMETER_BLOCK));
    _boot2 = 0;
    _boot3 = 0;
    _NumberOfStages = 0;
    _cvt_zone = 0;
    _cvt_zone_size = 0;
}


VOID
NTFS_SA::Destroy(
    )
/*++

Routine Description:

    This routine returns an NTFS_SA to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _cleanup_that_requires_reboot = FALSE;
    _boot_sector = NULL;
    memset(&_bpb, 0, sizeof(BIOS_PARAMETER_BLOCK));
    _boot2 = 0;
    _boot3 = 0;
    _cvt_zone = 0;
    _cvt_zone_size = 0;
}


UNTFS_EXPORT
NTFS_SA::~NTFS_SA(
    )
/*++

Routine Description:

    Destructor for NTFS_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}



UNTFS_EXPORT
BOOLEAN
NTFS_SA::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE            Message,
    IN      LCN                 CvtStartZone,
    IN      BIG_INT             CvtZoneSize
    )
/*++

Routine Description:

    This routine returns an NTFS_SA to a default initial state.

Arguments:

    Drive               - Supplies the drive that this MultiSectorBuffer is on
    Message             - Supplies an outlet for messages.
    CvtStartZone        - Supplies the starting cluster of the convert zone
    CvtZoneSize         - Supplies the convert zone size in clusters

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   num_boot_sectors;

    Destroy();

    DebugAssert(Drive);
    DebugAssert(Message);

    num_boot_sectors = max(1, BYTES_PER_BOOT_SECTOR/Drive->QuerySectorSize());

    if (!_hmem.Initialize() ||
        !SUPERAREA::Initialize(&_hmem, Drive, num_boot_sectors, Message)) {

        return FALSE;
    }

    _boot_sector = (PPACKED_BOOT_SECTOR) SECRUN::GetBuf();

#if defined(FE_SB) && defined(_X86_)
    //
    //  Set the appropriate boot code according to environment.
    //
    if (IsNEC_98 && !_drive->IsATformat()) {
        _bootcode = PC98NtfsBootCode;
        _bootcodesize = sizeof(PC98NtfsBootCode);
    } else {
#endif
        _bootcode = NtfsBootCode;
        _bootcodesize = sizeof(NtfsBootCode);
#if defined(FE_SB) && defined(_X86_)
    }
#endif

    _cvt_zone = CvtStartZone;
    _cvt_zone_size = CvtZoneSize;

    return TRUE;
}

#if defined( _SETUP_LOADER_ )

BOOLEAN
NTFS_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      BOOLEAN         BackwardCompatible,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSectors

    )
{
    // Dummy implementation for Setup-Loader; the real thing
    // is in format.cxx.

    return FALSE;
}

BOOLEAN
NTFS_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN      ULONG           ClusterFactor,
    IN      ULONG           FrsSize,
    IN      ULONG           ClustersPerIndexBuffer,
    IN      ULONG           InitialLogFileSize,
    IN      BOOLEAN         BackwardCompatible,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label
    )
{
    // Dummy implementation for Setup-Loader; the real thing
    // is in format.cxx.

    return FALSE;
}


#endif // _SETUP_LOADER_

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ )

BOOLEAN
NTFS_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
{
    // Dummy implementation for AUTOCHECK and Setup-Loader

    return FALSE;
}

#else // _AUTOCHECK_ and _SETUP_LOADER_ are NOT defined


BOOLEAN
NTFS_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine recovers a file on the disk.

Arguments:

    FullPathFileName    - Supplies the file name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE BitmapAttribute;
    NTFS_MFT_FILE MftFile;
    NTFS_BITMAP_FILE BitmapFile;
    NTFS_BAD_CLUSTER_FILE BadClusterFile;
    NTFS_BITMAP VolumeBitmap;
    NTFS_FILE_RECORD_SEGMENT FrsToRecover;
    NTFS_UPCASE_FILE UpcaseFile;
    NTFS_ATTRIBUTE UpcaseAttribute;
    NTFS_UPCASE_TABLE UpcaseTable;
    BIG_INT BytesRecovered, TotalBytes;
    BOOLEAN Error = FALSE;
    ULONG BadClusters = 0;
    NUMBER_SET BadClusterList;
    UCHAR Major, Minor;
    BOOLEAN CorruptVolume;
    BOOLEAN SystemFile;


    // Lock the drive.

    if (!_drive->Lock()) {

        Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
        return FALSE;
    }

    // Determine the volume version information.
    //
    QueryVolumeFlagsAndLabel(&CorruptVolume, &Major, &Minor);

    if( CorruptVolume ) {

        Message->DisplayMsg( MSG_NTFS_RECOV_CORRUPT_VOLUME );
        return FALSE;
    }

    if( Major > 3 ) {

        Message->DisplayMsg( MSG_NTFS_RECOV_WRONG_VERSION );
        return FALSE;
    }

    SetVersionNumber( Major, Minor );


    // Initialize and read the MFT, the Bitmap File, the Bitmap, and the
    // Bad Cluster File.
    //
    if( !VolumeBitmap.Initialize( QueryVolumeSectors()/
                                  ((ULONG) QueryClusterFactor()),
                                  FALSE, _drive, QueryClusterFactor()) ||
        !MftFile.Initialize( _drive,
                             QueryMftStartingLcn(),
                             QueryClusterFactor(),
                             QueryFrsSize(),
                             QueryVolumeSectors(),
                             &VolumeBitmap,
                             NULL ) ) {

        Message->DisplayMsg( MSG_INSUFFICIENT_MEMORY );
        return FALSE;
    }

    if( !MftFile.Read() ) {

        DebugPrint( "NTFS_SA::RecoverFile: Cannot read MFT.\n" );

        Message->DisplayMsg( MSG_NTFS_RECOV_CORRUPT_VOLUME );
        return FALSE;
    }

    // Get the upcase table.
    //
    if( !UpcaseFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !UpcaseFile.Read() ||
        !UpcaseFile.QueryAttribute( &UpcaseAttribute, &Error, $DATA ) ||
        !UpcaseTable.Initialize( &UpcaseAttribute ) ) {

        DebugPrint( "UNTFS RecoverFile:Can't get the upcase table.\n" );

        Message->DisplayMsg( MSG_NTFS_RECOV_CORRUPT_VOLUME );
        return FALSE;
    }

    MftFile.SetUpcaseTable( &UpcaseTable );
    MftFile.GetMasterFileTable()->SetUpcaseTable( &UpcaseTable );


    // Initialize the Bitmap file and the Bad Cluster file, and
    // read the volume bitmap.
    //
    if( !BitmapFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BadClusterFile.Initialize( MftFile.GetMasterFileTable() ) ) {

        Message->DisplayMsg( MSG_INSUFFICIENT_MEMORY );
        return FALSE;
    }

    if( !BitmapFile.Read() ||
        !BitmapFile.QueryAttribute( &BitmapAttribute, &Error, $DATA ) ||
        !VolumeBitmap.Read( &BitmapAttribute ) ||
        !BadClusterFile.Read () ) {

        Message->DisplayMsg( MSG_NTFS_RECOV_CORRUPT_VOLUME );
        return FALSE;
    }


    // Find the File Record Segment.

    if( !QueryFrsFromPath( FullPathFileName,
                           MftFile.GetMasterFileTable(),
                           &VolumeBitmap,
                           &FrsToRecover,
                           &SystemFile,
                           &Error ) ) {

        if( !Error ) {

            Message->DisplayMsg( MSG_RECOV_FILE_NOT_FOUND );
            return FALSE;

        } else {

            Message->DisplayMsg( MSG_INSUFFICIENT_MEMORY );
            return FALSE;
        }
    }


    // If the File Record Segment is a system file, don't recover it.

    if( SystemFile ) {

        Message->DisplayMsg( MSG_NTFS_RECOV_SYSTEM_FILE );
        return FALSE;
    }

    // Recover the File Record Segment.

    if( !BadClusterList.Initialize() ||
        !FrsToRecover.RecoverFile( &VolumeBitmap,
                                   &BadClusterList,
                                   Major,
                                   &BadClusters,
                                   &BytesRecovered,
                                   &TotalBytes ) ||
        !BadClusterFile.Add(&BadClusterList)) {

        Message->DisplayMsg( MSG_NTFS_RECOV_FAILED );

        return FALSE;
    }

    // If any bad clusters were found, we need to flush the bad cluster
    // file and the MFT and write the bitmap.  If no bad clusters were
    // found, then these structures will be unchanged.

    if( BadClusters != 0 ) {

        if( !BadClusterFile.Flush( &VolumeBitmap ) ||
            !MftFile.Flush() ||
            !VolumeBitmap.Write( &BitmapAttribute, &VolumeBitmap ) ) {

            Message->DisplayMsg( MSG_NTFS_RECOV_CANT_WRITE_ELEMENTARY );

            return FALSE;
        }

    }

    Message->DisplayMsg(MSG_RECOV_BYTES_RECOVERED,
                        "%d%d",
                        BytesRecovered.GetLowPart(),
                        TotalBytes.GetLowPart() );

    return TRUE;
}

#endif // _AUTOCHECK_ || _SETUP_LOADER_



UNTFS_EXPORT
BOOLEAN
NTFS_SA::Read(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine reads the NTFS volume's boot sector from disk.
    If the read fails then a message will be printed and then
    we will attempt to find an alternate boot sector, looking
    first at the end of the volume and then in the middle.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Message);

    if (!SECRUN::Read()) {

        Message->DisplayMsg(MSG_NTFS_UNREADABLE_BOOT_SECTOR);

        _boot2 = _drive->QuerySectors() - 1;
        Relocate(_boot2);

        if (!SECRUN::Read() ||
            !IFS_SYSTEM::IsThisNtfs(_drive->QuerySectors(),
                                    _drive->QuerySectorSize(),
                                    (PVOID)_boot_sector)) {

            _boot2 = _drive->QuerySectors()/2;
            Relocate(_boot2);

            if (!SECRUN::Read() ||
                !IFS_SYSTEM::IsThisNtfs(_drive->QuerySectors(),
                                        _drive->QuerySectorSize(),
                                        (PVOID)_boot_sector)) {

                Message->DisplayMsg(MSG_NTFS_ALL_BOOT_SECTORS_UNREADABLE);

                _boot2 = 0;
                Relocate(0);
                return FALSE;
            }
        }

        Relocate(0);
    }

    UnpackBios(&_bpb, &(_boot_sector->PackedBpb));

    if (QueryVolumeSectors() < _drive->QuerySectors()) {
        _boot2 = _drive->QuerySectors() - 1;
    } else {
        _boot2 = _drive->QuerySectors() / 2;
    }

    return TRUE;
}



BOOLEAN
NTFS_SA::Write(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine writes both of the NTFS volume's boot sector to disk.
    If the write fails on either of the boot sectors then a message
    will be printed.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Message);

    PackBios(&_bpb, &(_boot_sector->PackedBpb));

    if (SECRUN::Write()) {

        Relocate(_boot2);

        if (!SECRUN::Write()) {

            Message->DisplayMsg(MSG_NTFS_SECOND_BOOT_SECTOR_UNWRITEABLE);
            return FALSE;
        }

        Relocate(0);

    } else {

        Message->DisplayMsg(MSG_NTFS_FIRST_BOOT_SECTOR_UNWRITEABLE);

        Relocate(_boot2);

        if (!SECRUN::Write()) {
            Message->DisplayMsg(MSG_NTFS_ALL_BOOT_SECTORS_UNWRITEABLE);
            Relocate(0);
            return FALSE;
        }

        Relocate(0);
    }

    return TRUE;
}

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )


UNTFS_EXPORT
BOOLEAN
NTFS_SA::QueryFrsFromPath(
    IN     PCWSTRING                    FullPathFileName,
    IN OUT PNTFS_MASTER_FILE_TABLE      Mft,
    IN OUT PNTFS_BITMAP                 VolumeBitmap,
    OUT    PNTFS_FILE_RECORD_SEGMENT    TargetFrs,
    OUT    PBOOLEAN                     SystemFile,
    OUT    PBOOLEAN                     InternalError
    )
/*++

Routine Description:

    This method finds the file segment for a specified path.

Arguments:

    FullPathFileName    --  Supplies the full path to the file
    Mft                 --  Supplies the volume's Master File Table
    VolumeBitmap        --  Supplies the volume bitmap
    TargetFrs           --  Supplies a File Record Segment which will be
                            initialized to the desired File Record Segment
    SystemFile          --  Receives TRUE if the file is a system file
    InternalError       --  Receives TRUE if the method fails because of
                            a resource error.

Return Value:

    TRUE upon successful completion.

    If the method succeeds, TargetFrs is initialized to the desired
    File Record Segment.

    If the method fails because of a resource error (ie. because it cannot
    initialize an object), *InternalError is set to TRUE; if it fails
    because it can't find the file, then *InternalError is set to FALSE.

--*/
{
    PATH FullPath;
    NTFS_INDEX_TREE IndexTree;
    DSTRING IndexName;
    PWSTRING CurrentComponent;
    PARRAY PathComponents = NULL;
    PARRAY_ITERATOR Iterator = NULL;
    PFILE_NAME SearchName;
    MFT_SEGMENT_REFERENCE FileReference;
    VCN FileNumber;
    ULONG MaximumBytesInName;

    DebugPtrAssert( SystemFile );

    *SystemFile = FALSE;

    if( !IndexName.Initialize( FileNameIndexNameData ) ||
        !FullPath.Initialize( FullPathFileName ) ||
        (PathComponents = FullPath.QueryComponentArray()) == NULL ||
        (Iterator =
            (PARRAY_ITERATOR)PathComponents->QueryIterator()) == NULL ||
        !TargetFrs->Initialize( ROOT_FILE_NAME_INDEX_NUMBER, Mft ) ||
        !TargetFrs->Read() ||
        (MaximumBytesInName = TargetFrs->QuerySize()) == 0 ||
        (SearchName = (PFILE_NAME)
                      MALLOC(MaximumBytesInName+1+sizeof(FILE_NAME)))
            == NULL ) {

        DebugPrint( "QueryFrsFromPath--cannot initialize helpers\n" );

        if( SearchName != NULL ) {

            FREE( SearchName );
        }

        DELETE( PathComponents );
        DELETE( Iterator );

        *InternalError = TRUE;
        return FALSE;
    }

    while( (CurrentComponent = (PWSTRING)Iterator->GetNext()) != NULL ) {


        // Set up a FILE_NAME structure to be the search key.  We need
        // to set the length field in the header and copy the name.
        // Note that this method only deals with NTFS names (not DOS
        // names), so we also set the file name flag to FILE_NAME_NTFS.

        SearchName->FileNameLength = (UCHAR)CurrentComponent->QueryChCount();
        SearchName->Flags = FILE_NAME_NTFS;

        if( !CurrentComponent->QueryWSTR( 0,
                                          TO_END,
                                          NtfsFileNameGetName( SearchName ),
                                          MaximumBytesInName/sizeof(WCHAR) ) ||
            !IndexTree.Initialize( _drive,
                                   QueryClusterFactor(),
                                   VolumeBitmap,
                                   TargetFrs->GetUpcaseTable(),
                                   TargetFrs->
                                        QueryMaximumAttributeRecordSize(),
                                   TargetFrs,
                                   &IndexName ) ) {

            DebugPrint( "QueryFrsFromPath--Cannot initialize index tree.\n" );

            if( SearchName != NULL ) {

                FREE( SearchName );
            }

            DELETE( PathComponents );
            DELETE( Iterator );

            *InternalError = TRUE;
            return FALSE;
        }

        // Find the current component in the tree:

        if( !IndexTree.QueryFileReference( NtfsFileNameGetLength( SearchName ),
                                           SearchName,
                                           0,
                                           &FileReference,
                                           InternalError ) ) {

            if( SearchName != NULL ) {

                FREE( SearchName );
            }

            DELETE( PathComponents );
            DELETE( Iterator );

            return FALSE;
        }

        //  Initialize and read a File Record Segment based on that
        //  File Reference.  Not only must the FRS be readable, but
        //  its sequence number must match the sequence number in the
        //  File Reference.

        FileNumber.Set( FileReference.LowPart,
                        (LONG) FileReference.HighPart );

        if ( FileNumber < FIRST_USER_FILE_NUMBER )
            *SystemFile = TRUE;

        if( !TargetFrs->Initialize( FileNumber, Mft ) ||
            !TargetFrs->Read() ||
            !(FileReference == TargetFrs->QuerySegmentReference()) ) {

            // Either we were unable to initialize and read this FRS,
            // or its segment reference didn't match (ie. the sequence
            // number is wrong.

            if( SearchName != NULL ) {

                FREE( SearchName );
            }

            DELETE( PathComponents );
            DELETE( Iterator );

            *InternalError = TRUE;
            return FALSE;
        }
    }

    if ( SearchName != NULL ) {

        FREE( SearchName );
    }

    // If we got this far, no errors have been encountered, we've
    // processed the entire path, and TargetFrs has been initialized
    // to the File Record Segment we want.

    return TRUE;
}

#endif // _AUTOCHECK_ || _SETUP_LOADER_


VOID
NTFS_SA::SetVersionNumber(
    IN  UCHAR   Major,
    IN  UCHAR   Minor
    )
{
    _MajorVersion = Major;
    _MinorVersion = Minor;
}


VOID
NTFS_SA::QueryVersionNumber(
    OUT PUCHAR  Major,
    OUT PUCHAR  Minor
    )
{
    *Major = _MajorVersion;
    *Minor = _MinorVersion;
}


UNTFS_EXPORT
USHORT
NTFS_SA::QueryVolumeFlagsAndLabel(
    OUT PBOOLEAN    CorruptVolume,
    OUT PUCHAR      MajorVersion,
    OUT PUCHAR      MinorVersion,
    OUT PWSTRING    Label
    )
/*++

Routine Description:

    This routine fetches the volume flags.

Arguments:

    CorruptVolume   - Returns whether or not a volume corruption was
                        detected.
    MajorVersion    - Returns the major file system version number.
    MinorVersion    - Returns the minor file system version number.
    Label           - Returns the volume label if it exists

Return Value:

    The flags describing this volume's state and optionally the
    volume label

--*/
{
    NTFS_FRS_STRUCTURE      frs;
    HMEM                    hmem;
    LCN                     cluster_number, alternate;
    ULONG                   cluster_offset, alternate_offset;
    PVOID                   p;
    NTFS_ATTRIBUTE_RECORD   attr_rec;
    PVOLUME_INFORMATION     vol_info;
    PCWSTR                  vol_name;

    if (CorruptVolume) {
        *CorruptVolume = FALSE;
    }

    if (MajorVersion) {
        *MajorVersion = 0;
    }

    if (MinorVersion) {
        *MinorVersion = 0;
    }

    if (Label && !Label->Initialize()) {
        DebugAbort("UNTFS: Out of memory\n");
        return FALSE;
    }

    ULONG cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    cluster_number = (VOLUME_DASD_NUMBER * QueryFrsSize())/ cluster_size +
        QueryMftStartingLcn();

    cluster_offset = (QueryMftStartingLcn()*cluster_size +
        VOLUME_DASD_NUMBER * QueryFrsSize() - cluster_number * cluster_size).GetLowPart();

    DebugAssert(cluster_offset < cluster_size);

    alternate = (VOLUME_DASD_NUMBER * QueryFrsSize())/ cluster_size +
        QueryMft2StartingLcn();

    alternate_offset = (QueryMft2StartingLcn()*cluster_size +
        VOLUME_DASD_NUMBER * QueryFrsSize() - alternate * cluster_size).GetLowPart();

    for (;;) {

        if (!hmem.Initialize() ||
            !frs.Initialize(&hmem, _drive, cluster_number,
                            QueryClusterFactor(),
                            QueryVolumeSectors(),
                            QueryFrsSize(),
                            NULL,
                            cluster_offset) ||
            !frs.Read()) {

            if (cluster_number == alternate) {
                break;
            } else {
                cluster_number = alternate;
                cluster_offset = alternate_offset;
                continue;
            }
        }

        p = NULL;
        while (p = frs.GetNextAttributeRecord(p)) {

            if (!attr_rec.Initialize(GetDrive(), p)) {
                // the attribute record containing the volume flags
                // is not available--this means that the volume is
                // dirty.
                //
                return VOLUME_DIRTY;
            }

#if ($VOLUME_NAME > $VOLUME_INFORMATION)
#error  Attribute type $VOLUME_NAME should be smaller than that of $VOLUME_INFORMATION
#endif

            if (Label &&
                attr_rec.QueryTypeCode() == $VOLUME_NAME &&
                attr_rec.QueryNameLength() == 0 &&
                attr_rec.QueryResidentValueLength() <= 256 &&
                (vol_name = (PCWSTR) attr_rec.GetResidentValue())) {

                if (!Label->Initialize(vol_name,
                                       attr_rec.QueryResidentValueLength()/sizeof(WCHAR))) {
                    DebugAbort("UNTFS: Out of memory\n");
                    return FALSE;
                }
            }
            if (attr_rec.QueryTypeCode() == $VOLUME_INFORMATION &&
                attr_rec.QueryNameLength() == 0 &&
                attr_rec.QueryRecordLength() > SIZE_OF_RESIDENT_HEADER &&
                attr_rec.QueryResidentValueLength() < attr_rec.QueryRecordLength() &&
                (attr_rec.QueryRecordLength() - attr_rec.QueryResidentValueLength()) >=
                attr_rec.QueryResidentValueOffset() &&
                attr_rec.QueryResidentValueLength() >= sizeof(VOLUME_INFORMATION) &&
                (vol_info = (PVOLUME_INFORMATION) attr_rec.GetResidentValue())) {

                if (MajorVersion) {
                    *MajorVersion = vol_info->MajorVersion;
                }

                if (MinorVersion) {
                    *MinorVersion = vol_info->MinorVersion;
                }

                if (*MajorVersion > 3) {
                    break;  // try the mirror copy
                }

                return (vol_info->VolumeFlags);
            }
        }

        // If the desired attribute wasn't found in the first
        // volume dasd file then check the mirror.

        if (cluster_number == alternate) {
            break;
        } else {
            cluster_number = alternate;
            cluster_offset = alternate_offset;
        }
    }

    if (CorruptVolume) {
        *CorruptVolume = TRUE;
    }

    return VOLUME_DIRTY;
}


BOOLEAN
NTFS_SA::ClearVolumeFlag(
    IN      USHORT                  FlagsToClear,
    IN OUT  PNTFS_LOG_FILE          LogFile,
    IN      BOOLEAN                 WriteSecondLogFilePage,
    IN      LSN                     LargestVolumeLsn,
    OUT     PBOOLEAN                CorruptVolume,
    IN      BOOLEAN                 UpdateMirror
    )
/*++

Routine Description:

    This routine sets the volume clean.

Arguments:

    FlagsToClear            - Supplies the volume flags to clear.
    LogFile                 - Supplies a valid log file.  May be NULL,
                              in which case the log file will not be
                              modified.
    WriteSecondLogFilePage  - Supplies whether or not to write the second
                                log file page.  Ignored if LogFile is NULL.
    LargestVolumeLsn        - This supplies the largest LSN on the volume.
                                This parameter will be used if and
                                only if the previous parameter is TRUE.
    CorruptVolume           - Returns whether or not the volume is corrupt.
    UpdateMirror            - Update the mirror copy of the file record segment

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FRS_STRUCTURE          frs;
    HMEM                        hmem;
    LCN                         volume_file_lcn;
    ULONG                       volume_file_offset;
    PVOID                       p;
    NTFS_ATTRIBUTE_RECORD       attr_rec;
    PVOLUME_INFORMATION         vol_info;
    ULONG                       cluster_size;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    if (CorruptVolume) {
        *CorruptVolume = FALSE;
    }

    // Compute the cluster that holds the start of the volume file frs and
    // the offset into that cluster (which will be zero unless the frs size
    // is less than the cluster size.)
    //

    volume_file_lcn = QueryMftStartingLcn();
    volume_file_offset = VOLUME_DASD_NUMBER * QueryFrsSize();

    for (;;) {
        if (!hmem.Initialize() ||
            !frs.Initialize(&hmem, _drive, volume_file_lcn,
                            QueryClusterFactor(),
                            QueryVolumeSectors(),
                            QueryFrsSize(),
                            NULL,
                            volume_file_offset) ||
            !frs.Read()) {

            return FALSE;
        }

        p = NULL;
        while (p = frs.GetNextAttributeRecord(p)) {

            if (!attr_rec.Initialize(GetDrive(), p)) {
                return FALSE;
            }

            if (attr_rec.QueryTypeCode() == $VOLUME_INFORMATION &&
                attr_rec.QueryNameLength() == 0 &&
                attr_rec.QueryRecordLength() > SIZE_OF_RESIDENT_HEADER &&
                attr_rec.QueryResidentValueLength() < attr_rec.QueryRecordLength() &&
                (attr_rec.QueryRecordLength() - attr_rec.QueryResidentValueLength()) >=
                attr_rec.QueryResidentValueOffset() &&
                attr_rec.QueryResidentValueLength() >= sizeof(VOLUME_INFORMATION) &&
                (vol_info = (PVOLUME_INFORMATION) attr_rec.GetResidentValue())) {

                break;
            }
        }

        if (!p) {
            if (CorruptVolume) {
                *CorruptVolume = TRUE;
            }
            return FALSE;
        }

        vol_info->VolumeFlags &= ~(FlagsToClear);
        if (!frs.Write()) {
            return FALSE;
        }

        if (!UpdateMirror ||
            volume_file_lcn == QueryMft2StartingLcn())
            break;

        volume_file_lcn = QueryMft2StartingLcn();
    }

    if( LogFile ) {

        return LogFile->MarkVolumeChecked(WriteSecondLogFilePage,
                                          LargestVolumeLsn);
    } else {

        return TRUE;
    }
}


UCHAR
NTFS_SA::PostReadMultiSectorFixup(
    IN OUT  PVOID           MultiSectorBuffer,
    IN      ULONG           BufferSize,
    IN      PIO_DP_DRIVE    Drive,
    IN      ULONG           ValidSize
    )
/*++

Routine Description:

    This routine first verifies that the first element of the
    update sequence array is written at the end of every
    SEQUENCE_NUMBER_STRIDE bytes till it exceeds the given
    valid size.  If not, then this routine returns FALSE.

    Otherwise this routine swaps the following elements in the
    update sequence array into the appropriate positions in the
    multi sector buffer.

    This routine will also check to make sure that the update
    sequence array is valid and that the BufferSize is appropriate
    for this size of update sequence array.  Otherwise, this
    routine will not update the array sequence and return TRUE.

Arguments:

    MultiSectorBuffer   - Supplies the buffer to be updated.
    BufferSize          - Supplies the number of bytes in this
                            buffer.
    Drive               - Supplies the drive that this MultiSectorBuffer is on
    ValidSize           - Supplies the number of bytes that is
                          valid in this buffer

Return Value:

    UpdateSequenceArrayCheckValueOk (always non-zero)
         - If everything is ok.  If any valid sector does not
           contain the check value, the header signature will
           be changed to 'BAAD'.
    UpdateSequenceArrayMinorError
         - Same as 1 except the check value beyond ValidSize
           is incorrect.
--*/
{
    PUNTFS_MULTI_SECTOR_HEADER  pheader;
    USHORT                      i, size, offset;
    PUPDATE_SEQUENCE_NUMBER     parray, pnumber;
    UCHAR                       rtncode = UpdateSequenceArrayCheckValueOk;

    pheader = (PUNTFS_MULTI_SECTOR_HEADER) MultiSectorBuffer;
    size = pheader->UpdateSequenceArraySize;
    offset = pheader->UpdateSequenceArrayOffset;

    if (BufferSize%SEQUENCE_NUMBER_STRIDE ||
        offset%sizeof(UPDATE_SEQUENCE_NUMBER) ||
        offset + size*sizeof(UPDATE_SEQUENCE_NUMBER) > BufferSize ||
        BufferSize/SEQUENCE_NUMBER_STRIDE + 1 != size) {

#if 0
        // This can happen naturally but the in use bit of the frs should be cleared.
        if (Drive) {

            PMESSAGE    msg = Drive->GetMessage();

            if (msg) {
                msg->Lock();
                msg->Set(MSG_CHKLOG_NTFS_INCORRECT_MULTI_SECTOR_HEADER);
                msg->Log("%x%x%x", BufferSize, offset, size);
                msg->DumpDataToLog(pheader, 0x40);
                msg->Unlock();
            }
        }
        DebugPrintTrace(("Incorrect multi-sector header with total size %d,\n"
                         "USA offset %d, and USA count %d\n",
                         BufferSize, offset, size));
#endif

        return rtncode;
    }

    parray = (PUPDATE_SEQUENCE_NUMBER) ((PCHAR) pheader + offset);

    pnumber = (PUPDATE_SEQUENCE_NUMBER)
              ((PCHAR) pheader + (SEQUENCE_NUMBER_STRIDE -
                                  sizeof(UPDATE_SEQUENCE_NUMBER)));

    for (i = 1; i < size; i++) {

        if (*pnumber != parray[0]) {
            if (ValidSize > 0) {

                if (Drive) {

                    PMESSAGE msg = Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_USA,
                                     "%x%x%x", size, *pnumber, parray[0]);
                    }
                }

                DebugPrintTrace(("Incorrect USA check value at block %d.\n"
                                 "The expected value is %d but found %d\n",
                                 i, *pnumber, parray[0]));

                pheader->Signature[0] = 'B';
                pheader->Signature[1] = 'A';
                pheader->Signature[2] = 'A';
                pheader->Signature[3] = 'D';
                return rtncode;
            } else
                rtncode = UpdateSequenceArrayCheckValueMinorError;
        }

        *pnumber = parray[i];

        if (ValidSize >= SEQUENCE_NUMBER_STRIDE)
            ValidSize -= SEQUENCE_NUMBER_STRIDE;
        else
            ValidSize = 0;

        pnumber = (PUPDATE_SEQUENCE_NUMBER)
                  ((PCHAR) pnumber + SEQUENCE_NUMBER_STRIDE);
    }

    return rtncode;
}


VOID
NTFS_SA::PreWriteMultiSectorFixup(
    IN OUT  PVOID   MultiSectorBuffer,
    IN      ULONG   BufferSize
    )
/*++

Routine Description:

    This routine first checks to see if the update sequence
    array is valid.  If it is then this routine increments the
    first element of the update sequence array.  It then
    writes the value of the first element into the buffer at
    the end of every SEQUENCE_NUMBER_STRIDE bytes while
    saving the old values of those locations in the following
    elements of the update sequence arrary.

Arguments:

    MultiSectorBuffer   - Supplies the buffer to be updated.
    BufferSize          - Supplies the number of bytes in this
                            buffer.

Return Value:

    None.

--*/
{
    PUNTFS_MULTI_SECTOR_HEADER    pheader;
    USHORT                  i, size, offset;
    PUPDATE_SEQUENCE_NUMBER parray, pnumber;

    pheader = (PUNTFS_MULTI_SECTOR_HEADER) MultiSectorBuffer;
    size = pheader->UpdateSequenceArraySize;
    offset = pheader->UpdateSequenceArrayOffset;

    if (BufferSize%SEQUENCE_NUMBER_STRIDE ||
        offset%sizeof(UPDATE_SEQUENCE_NUMBER) ||
        offset + size*sizeof(UPDATE_SEQUENCE_NUMBER) > BufferSize ||
        BufferSize/SEQUENCE_NUMBER_STRIDE + 1 != size) {

        return;
    }

    parray = (PUPDATE_SEQUENCE_NUMBER) ((PCHAR) pheader + offset);


    // Don't allow 0 or all F's to be the update character.

    do {
        parray[0]++;
    } while (parray[0] == 0 || parray[0] == (UPDATE_SEQUENCE_NUMBER) -1);


    for (i = 1; i < size; i++) {

        pnumber = (PUPDATE_SEQUENCE_NUMBER)
                  ((PCHAR) pheader + (i*SEQUENCE_NUMBER_STRIDE -
                   sizeof(UPDATE_SEQUENCE_NUMBER)));

        parray[i] = *pnumber;
        *pnumber = parray[0];
    }
}


UNTFS_EXPORT
BOOLEAN
NTFS_SA::IsDosName(
    IN  PCFILE_NAME FileName
    )
/*++

Routine Description:

    This routine computes whether or not the given file name would
    be appropriate under DOS's 8.3 naming convention.

Arguments:

    FileName    - Supplies the file name to check.

Return Value:

    FALSE   - The supplied name is not a DOS file name.
    TRUE    - The supplied name is a valid DOS file name.

--*/
{
    ULONG   i, n, name_length, ext_length;
    BOOLEAN dot_yet;
    PCWCHAR p;

    n = FileName->FileNameLength;
    p = FileName->FileName;
    name_length = n;
    ext_length = 0;

    if (n > 12) {
        return FALSE;
    }

    dot_yet = FALSE;
    for (i = 0; i < n; i++) {

        if (p[i] < 32) {
            return FALSE;
        }

        switch (p[i]) {
            case '*':
            case '?':
            case '/':
            case '\\':
            case '|':
            case ',':
            case ';':
            case ':':
            case '+':
            case '=':
            case '<':
            case '>':
            case '[':
            case ']':
            case '"':
                return FALSE;

            case '.':
                if (dot_yet) {
                    return FALSE;
                }
                dot_yet = TRUE;
                name_length = i;
                ext_length = n - i - 1;
                break;
        }
    }

    if (!name_length) {
        return dot_yet && n == 1;
    }

    if (name_length > 8 ||
        p[name_length - 1] == ' ') {

        return FALSE;
    }

    if (!ext_length) {
        return !dot_yet;
    }

    if (ext_length > 3 ||
        p[name_length + 1 + ext_length - 1] == ' ') {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::IsValidLabel(
    IN PCWSTRING    Label
    )
/*++

Routine Description:

    This method determines whether a specified string is a
    valid NTFS volume label.

Arguments:

    Label   --  Supplies the string to check.

Return Value:

    TRUE if the string is a valid NTFS label.

--*/
{
    CHNUM StringLength, i;

    StringLength = Label->QueryChCount();

    for( i = 0; i < StringLength; i++ ) {

        if (Label->QueryChAt(i) < 32) {
            return FALSE;
        }

        switch (Label->QueryChAt(i)) {
            case '*':
            case '?':
            case '/':
            case '\\':
            case '|':
            case '<':
            case '>':
            case '"':
                return FALSE;
        }
    }

    return TRUE;
}


ULONG
NTFS_SA::QueryDefaultClusterFactor(
    IN PCDP_DRIVE   Drive
    )
/*++

Routine Description:

    This method returns the default number of sectors per cluster
    for a given drive.

Arguments:

    Drive   --  Supplies the drive under consideration.

Return Value:

    The appropriate default cluster factor.

--*/
{
    // Hold off on this analysis until testing says ok.

    BIG_INT cbDiskSize;
    ULONG   cbClusterSize, csecClusterSize;

    cbDiskSize = Drive->QuerySectors()*Drive->QuerySectorSize();

    if (cbDiskSize > (ULONG) 2*1024*1024*1024) {    // > 2 Gig
        cbClusterSize = 4096;
    } else if (cbDiskSize > 1024*1024*1024) {       // > 1 Gig
        cbClusterSize = 2048;
    } else if (cbDiskSize > 512*1024*1024) {        // > 512 Meg
        cbClusterSize = 1024;
    } else {
        cbClusterSize = 512;
    }

    csecClusterSize = cbClusterSize/Drive->QuerySectorSize();
    if (!csecClusterSize) {
        csecClusterSize = 1;
    }

    return csecClusterSize;
}

UNTFS_EXPORT
ULONG
NTFS_SA::QueryDefaultClustersPerIndexBuffer(
    IN PCDP_DRIVE   Drive,
    IN ULONG        ClusterFactor
    )
/*++

Routine Description:

    This method computes the default number of clusters per
    NTFS index allocation buffer.

Arguments:

    Drive           --  supplies the drive under consideration.
    ClusterFactor   --  Supplies the cluster factor for the drive.

Return Value:

    The default number of clusters per NTFS index allocation
    buffer.

--*/
{
    ULONG   ClusterSize;

    if (ClusterFactor) {

        ClusterSize = Drive->QuerySectorSize() * ClusterFactor;

        if (ClusterSize > SMALL_INDEX_BUFFER_SIZE) {

            return 0;
        }

        return( ( SMALL_INDEX_BUFFER_SIZE + ClusterSize - 1 ) / ClusterSize );

    } else {

        ClusterSize = Drive->QuerySectorSize();

        if (ClusterSize > SMALL_INDEX_BUFFER_SIZE) {

            return 0;
        }
        return( ( SMALL_INDEX_BUFFER_SIZE + ClusterSize - 1 ) / ClusterSize );
    }
}

BOOLEAN
NTFS_SA::LogFileMayNeedResize(
    )
/*++

Routine Description:

    This routine

Arguments:



Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    NTFS_FRS_STRUCTURE frs;
    HMEM hmem;
    PVOID p;
    NTFS_ATTRIBUTE_RECORD attr_rec;
    LCN log_file_lcn;
    ULONG log_file_offset;
    BIG_INT log_file_size;
    ULONG cluster_size;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    log_file_lcn = QueryMftStartingLcn();
    log_file_offset =  LOG_FILE_NUMBER * QueryFrsSize();

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, _drive,
            log_file_lcn,
            QueryClusterFactor(),
            QueryVolumeSectors(),
            QueryFrsSize(),
            NULL,
            log_file_offset) ||
        !frs.Read()) {

        return TRUE;
    }

    p = NULL;
    while (NULL != (p = frs.GetNextAttributeRecord(p))) {

        if (!attr_rec.Initialize(GetDrive(), p)) {
            return TRUE;
        }

        if ($DATA == attr_rec.QueryTypeCode()) {

            ULONG max_size, min_size;

            attr_rec.QueryValueLength(&log_file_size);

            max_size = NTFS_LOG_FILE::QueryMaximumSize(_drive, QueryVolumeSectors());
            min_size = NTFS_LOG_FILE::QueryMinimumSize(_drive, QueryVolumeSectors());

            if (log_file_size < min_size ||
                log_file_size > max_size) {

                return TRUE;

            } else {

                return FALSE;
            }
        }
    }

    return TRUE;
}

UNTFS_EXPORT
BOOLEAN
NTFS_SA::SetVolumeFlag(
    IN      USHORT                  FlagsToSet,
    OUT     PBOOLEAN                CorruptVolume
    )
/*++

Routine Description:

    This routine sets the volume dirty.

Arguments:

    FlagsToSet              - Supplies the volume flags to set.
    CorruptVolume           - Returns whether or not the volume is corrupt.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FRS_STRUCTURE          frs;
    HMEM                        hmem;
    LCN                         volume_file_lcn;
    ULONG                       volume_file_offset;
    PVOID                       p;
    NTFS_ATTRIBUTE_RECORD       attr_rec;
    PVOLUME_INFORMATION         vol_info;

    if (CorruptVolume) {
        *CorruptVolume = FALSE;
    }

    ULONG cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    volume_file_lcn = QueryMftStartingLcn();
    volume_file_offset = VOLUME_DASD_NUMBER * QueryFrsSize();

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, _drive, volume_file_lcn,
                        QueryClusterFactor(),
                        QueryVolumeSectors(),
                        QueryFrsSize(),
                        NULL,
                        volume_file_offset) ||
        !frs.Read()) {

        return FALSE;
    }

    p = NULL;
    while (p = frs.GetNextAttributeRecord(p)) {

        if (!attr_rec.Initialize(GetDrive(), p)) {
            return FALSE;
        }

        if (attr_rec.QueryTypeCode() == $VOLUME_INFORMATION &&
            attr_rec.QueryNameLength() == 0 &&
            attr_rec.QueryResidentValueLength() >= sizeof(VOLUME_INFORMATION) &&
            (vol_info = (PVOLUME_INFORMATION) attr_rec.GetResidentValue())) {

            break;
        }
    }

    if (!p) {
        if (CorruptVolume) {
            *CorruptVolume = TRUE;
        }
        return FALSE;
    }

    vol_info->VolumeFlags |= FlagsToSet;
    if (!frs.Write()) {
        return FALSE;
    }

    return TRUE;
}

UNTFS_EXPORT
BOOLEAN
NTFS_SA::Read(
    )
/*++

Routine Description:

    This routine simply calls the other read with the default message
    object.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;

    return Read(&msg);
}

UNTFS_EXPORT
UCHAR
NTFS_SA::QueryClusterFactor(
    ) CONST
/*++

Routine Description:

    This routine returns the number of sectors per cluster.

Arguments:

    None.

Return Value:

    The number of sectors per cluster.

--*/
{
    return _bpb.SectorsPerCluster;
}

UNTFS_EXPORT
BOOLEAN
NTFS_SA::TakeCensus(
    IN  PNTFS_MASTER_FILE_TABLE     Mft,
    IN  ULONG                       ResidentFileSizeThreshhold,
    OUT PNTFS_CENSUS_INFO           Census
    )
/*++

Routine Description:

    This routine examines the MFT and makes a census report on the
    volume.  This is used by convert to determine whether there will
    be enough space on the volume to convert from NTFS to the new
    filesystem.

Arguments:

    ResidentFileSizeThreshhold - Used to determine whether a given resident
                file should be placed in the "small" or "large" resident file
                category.

    Census      - Returns the census information.


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    BOOLEAN                     error;
    NTFS_ATTRIBUTE              attrib;
    NTFS_FILE_RECORD_SEGMENT    frs;
    ULONG                       i, j;
    ULONG                       num_frs;
    ULONG                       length;

    memset(Census, 0, sizeof(*Census));

    Census->NumFiles;
    Census->BytesLgResidentFiles;
    Census->BytesIndices;
    Census->BytesExternalExtentLists;
    Census->BytesFileNames;

    num_frs = Mft->GetDataAttribute()->QueryValueLength().GetLowPart() / Mft->QueryFrsSize();

    for (i = 0; i < num_frs; i += 1) {

        if (i < FIRST_USER_FILE_NUMBER && i != ROOT_FILE_NAME_INDEX_NUMBER) {
            continue;
        }

        if (!frs.Initialize(i, Mft)) {
            return FALSE;
        }

        if (!frs.Read()) {
            return FALSE;
        }
        if (!frs.IsInUse() || !frs.IsBase()) {
            continue;
        }

        Census->NumFiles += 1;

        //
        // Examine all the data attributes and see which are Large and
        // resident.
        //

        for (j = 0; frs.QueryAttributeByOrdinal(&attrib, &error, $DATA, j); ++j) {

            length = attrib.QueryValueLength().GetLowPart();

            if (attrib.IsResident() && length > ResidentFileSizeThreshhold) {
                Census->BytesLgResidentFiles +=  length;
            }
        }

        //
        // If there's an index present, add in its size.  (We assume there's
        // no more than one.
        //

        if (frs.IsIndexPresent()) {

            if (frs.QueryAttributeByOrdinal(&attrib, &error,
                $INDEX_ALLOCATION, 0)) {

                length = attrib.QueryValueLength().GetLowPart();
                Census->BytesIndices += length;
            }
        }

        //
        // Query all the file names and add in the space they occupy.
        //

        for (j = 0; frs.QueryAttributeByOrdinal(&attrib, &error,
            $FILE_NAME, j); ++j) {

            length = attrib.QueryValueLength().GetLowPart();

            Census->BytesFileNames +=  length;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\ntfschk.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    ntfschk.cxx

Abstract:

    This module implements NTFS CHKDSK.

Author:

    Norbert P. Kusters (norbertk) 29-Jul-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

//#define TIMING_ANALYSIS 1
#define USE_CHKDSK_BIT

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"

// This global variable used by CHKDSK to compute the largest
// LSN and USN on the volume.

LSN             LargestLsnEncountered;
LARGE_INTEGER   LargestUsnEncountered;
ULONG64         FrsOfLargestUsnEncountered;

struct NTFS_CHKDSK_INTERNAL_INFO {
    ULONG           TotalFrsCount;
    ULONG           BaseFrsCount;
    BIG_INT         TotalNumFileNames;
    ULONG           FilesWithObjectId;
    ULONG           FilesWithReparsePoint;
    ULONG           TotalNumSID;
    LARGE_INTEGER   ElapsedTimeForFileVerification;
    LARGE_INTEGER   ElapsedTimeForIndexVerification;
    LARGE_INTEGER   ElapsedTimeForSDVerification;
    LARGE_INTEGER   ElapsedTimeForUserSpaceVerification;
    LARGE_INTEGER   ElapsedTimeForFreeSpaceVerification;
    LARGE_INTEGER   ElapsedTotalTime;
    LARGE_INTEGER   TimerFrequency;
};

BOOLEAN
EnsureValidFileAttributes(
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN OUT  PNTFS_INDEX_TREE            ParentIndex,
       OUT  PBOOLEAN                    SaveIndex,
    IN      ULONG                       FileAttributes,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
);

VOID
QueryFileNameFromIndex(
    IN      PFILE_NAME  P,
       OUT  PWCHAR      Buffer,
    IN      CHNUM       BufferLength
);

BOOLEAN
UpdateChkdskInfo(
    IN OUT  PNTFS_FRS_STRUCTURE Frs,
    IN OUT  PNTFS_CHKDSK_INFO   ChkdskInfo,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine computes the necessary changes to the chkdsk information
    for this FRS.

Arguments:

    Frs         - Supplies the base FRS.
    ChkdskInfo  - Supplies the current chkdsk information.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG                       file_number;
    BOOLEAN                     is_multi;
    NTFS_ATTRIBUTE_LIST         attr_list;
    PATTRIBUTE_RECORD_HEADER    precord;
    ATTRIBUTE_TYPE_CODE         type_code;
    VCN                         vcn;
    MFT_SEGMENT_REFERENCE       seg_ref;
    USHORT                      tag;
    DSTRING                     name;
    ULONG                       name_length;
    BOOLEAN                     data_present;
    PSTANDARD_INFORMATION2      pstandard;
    ATTR_LIST_CURR_ENTRY        entry;

    file_number = Frs->QueryFileNumber().GetLowPart();

    ChkdskInfo->ReferenceCount[file_number] =
            (SHORT) Frs->QueryReferenceCount();

    if (Frs->QueryReferenceCount() == 0) {

        if (!ChkdskInfo->FilesWithNoReferences.Add(file_number)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    data_present = FALSE;
    is_multi = Frs->QueryAttributeList(&attr_list) && attr_list.ReadList();
    precord = NULL;
    entry.CurrentEntry = NULL;
    for (;;) {

        if (is_multi) {
            if (!attr_list.QueryNextEntry(&entry,
                                          &type_code,
                                          &vcn,
                                          &seg_ref,
                                          &tag,
                                          &name)) {
                break;
            }
            name_length = name.QueryChCount();
        } else {
            if (!(precord = (PATTRIBUTE_RECORD_HEADER)
                            Frs->GetNextAttributeRecord(precord))) {
                break;
            }
            type_code = precord->TypeCode;
            name_length = precord->NameLength;
        }

        switch (type_code) {

            case $STANDARD_INFORMATION:
                if (ChkdskInfo->major >= 2) {
                    if (is_multi) {
                        precord = (PATTRIBUTE_RECORD_HEADER)
                                  Frs->GetAttribute($STANDARD_INFORMATION);
                        if (precord == NULL) {
                            DebugPrintTrace(("Standard Information does not exist "
                                        "in base FRS 0x%I64x\n",
                                        Frs->QueryFileNumber().GetLargeInteger()));
                            return FALSE;
                        }
                        if (precord->Form.Resident.ValueLength ==
                            SIZEOF_NEW_STANDARD_INFORMATION) {

                            pstandard = (PSTANDARD_INFORMATION2)
                                        ((PCHAR)precord +
                                         precord->Form.Resident.ValueOffset);
                            if (pstandard->Usn > LargestUsnEncountered) {
                                LargestUsnEncountered = pstandard->Usn;
                                FrsOfLargestUsnEncountered = file_number;
                            }
                        }
                    } else {
                        if (precord->Form.Resident.ValueLength ==
                            SIZEOF_NEW_STANDARD_INFORMATION) {
                            pstandard = (PSTANDARD_INFORMATION2)
                                        ((PCHAR) precord +
                                         precord->Form.Resident.ValueOffset);
                            if (pstandard->Usn > LargestUsnEncountered) {
                                LargestUsnEncountered = pstandard->Usn;
                                FrsOfLargestUsnEncountered = file_number;
                            }
                        }
                    }
                }
                ChkdskInfo->BaseFrsCount++;
                break;

            case $FILE_NAME:
                ChkdskInfo->TotalNumFileNames += 1;
                ChkdskInfo->NumFileNames[file_number]++;
                break;

            case $INDEX_ROOT:
                ChkdskInfo->CountFilesWithIndices += 1;

            case $INDEX_ALLOCATION:
                ChkdskInfo->FilesWithIndices.SetAllocated(file_number, 1);
                break;

            case $OBJECT_ID:
                if (ChkdskInfo->major >= 2 &&
                    !ChkdskInfo->FilesWithObjectId.Add(file_number)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                break;

            case $REPARSE_POINT:
                if (ChkdskInfo->major >= 2)
                    ChkdskInfo->FilesWithReparsePoint.SetAllocated(file_number, 1);
                break;

            case $EA_INFORMATION:
            case $EA_DATA:
                if (!ChkdskInfo->FilesWithEas.Add(file_number)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                break;

            case $DATA:
                if (!name_length) {
                    data_present = TRUE;
                }
                break;

            default:
                break;
        }
    }

    if (!data_present) {

        ChkdskInfo->FilesWhoNeedData.SetAllocated(file_number, 1);
    }

    return TRUE;
}


BOOLEAN
EnsureValidParentFileName(
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN      FILE_REFERENCE              ParentFileReference,
    OUT     PBOOLEAN                    Changes
    )
/*++

Routine Description:

    This method ensures that all file_names for the given file
    point back to the given root-file-reference.

Arguments:

    ChkdskInfo          - Supplies the current chkdsk info.
    Frs                 - Supplies the Frs to verify.
    ParentFileReference - Supplies the file reference for the parent directory.
    Changes             - Returns whether or not there were changes to
                             the file record.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;
    BOOLEAN         error;
    NTFS_ATTRIBUTE  attribute;
    PFILE_NAME      p;
    CHAR            buffer[sizeof(FILE_NAME) + 20*sizeof(WCHAR)];
    WCHAR           buffer1[20];
    WCHAR           buffer2[20];
    PFILE_NAME      new_file_name = (PFILE_NAME) buffer;
    DSTRING         file_name_text;
    BOOLEAN         success;
    ULONG           file_number;
    BOOLEAN         correct_name_encountered;
    BOOLEAN         no_file_name;

    DebugAssert(Changes);
    *Changes = FALSE;

    file_number = Frs->QueryFileNumber().GetLowPart();

    if (ChkdskInfo) {
        if (!GetSystemFileName(ChkdskInfo->major,
                               file_number,
                               &file_name_text,
                               &no_file_name))
            return FALSE;
    } else
        no_file_name = TRUE;

    correct_name_encountered = FALSE;

    for (i = 0; Frs->QueryAttributeByOrdinal(&attribute, &error,
                                             $FILE_NAME, i); i++) {

        p = (PFILE_NAME) attribute.GetResidentValue();
        DebugAssert(p);


        // Remove any file-name that doesn't point back to the root.

        if (!(p->ParentDirectory == ParentFileReference)) {

            PMESSAGE    msg;

            *Changes = TRUE;

            msg = Frs->GetDrive()->GetMessage();
            msg->LogMsg(MSG_CHKLOG_NTFS_FILENAME_HAS_INCORRECT_PARENT,
                         "%I64x%I64x%I64x",
                     Frs->QueryFileNumber().GetLargeInteger(),
                     p->ParentDirectory,
                     ParentFileReference);

            Frs->DeleteResidentAttribute($FILE_NAME, NULL, p,
                attribute.QueryValueLength().GetLowPart(), &success);
            if (ChkdskInfo)
                ChkdskInfo->NumFileNames[file_number]--;
            continue;
        }

        if (!no_file_name) {
            file_name_text.QueryWSTR(0, TO_END, buffer1, 20);
            QueryFileNameFromIndex(p, buffer2, 20);

            if (WSTRING::Stricmp(buffer1, buffer2)) {

                PMESSAGE    msg;

                *Changes = TRUE;

                msg = Frs->GetDrive()->GetMessage();
                msg->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FILENAME,
                             "%I64x%ws%ws",
                         Frs->QueryFileNumber().GetLargeInteger(),
                         buffer2,
                         buffer1);

                Frs->DeleteResidentAttribute($FILE_NAME, NULL, p,
                    attribute.QueryValueLength().GetLowPart(), &success);
                if (ChkdskInfo)
                    ChkdskInfo->NumFileNames[file_number]--;
            } else
                correct_name_encountered = TRUE;
        }
    }

    if (!correct_name_encountered && !no_file_name) {
        *Changes = TRUE;
        new_file_name->FileNameLength = (UCHAR)file_name_text.QueryChCount();
        new_file_name->ParentDirectory = ParentFileReference;
        new_file_name->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
        file_name_text.QueryWSTR(0,
                                 TO_END,
                                 new_file_name->FileName,
                                 file_name_text.QueryChCount(),
                                 FALSE);
        if (!Frs->AddFileNameAttribute(new_file_name))
            return FALSE;
        if (ChkdskInfo)
            ChkdskInfo->NumFileNames[file_number]++;
    }

    return TRUE;
}


BOOLEAN
EnsureSystemFilesInUse(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine goes through all of the system files and ensures that
    they are all in use.  Any that are not in use are created the way
    format would do it.  Besides that this method makes sure that none
    of the system files have file-names that point back to any directory
    besides the root (file 5).  Any offending file-names are tubed.

Arguments:

    ChkdskInfo  - Supplies the current chkdsk info.
    Mft         - Supplies the MFT.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG                       i;
    NTFS_FILE_RECORD_SEGMENT    frs;
    FILE_REFERENCE              root_file_reference;
    BOOLEAN                     changes;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    // First to the root index file since the others need to point back
    // to it.

    if (!frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, Mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read()) {
        DebugAbort("Can't read a hotfixed system FRS");
        return FALSE;
    }

    if (!frs.IsInUse()) {

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        ChkdskInfo->NumFileNames[ROOT_FILE_NAME_INDEX_NUMBER] = 1;

        if (!frs.CreateSystemFile()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetIndexPresent();

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            DebugAbort("can't write system file");
            return FALSE;
        }


    } else if (!frs.IsIndexPresent()) {

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        frs.SetIndexPresent();

        Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                            "%d", ROOT_FILE_NAME_INDEX_NUMBER);

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_FILE_NAME_INDEX_PRESENT_BIT,
                     "%x", ROOT_FILE_NAME_INDEX_NUMBER);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            DebugAbort("can't write system file");
            return FALSE;
        }
    }

    root_file_reference = frs.QuerySegmentReference();

    for (i = 0; i < FIRST_USER_FILE_NUMBER; i++) {

        if (!frs.Initialize(i, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            DebugAbort("Can't read a hotfixed system FRS");
            return FALSE;
        }

        if (ChkdskInfo->major < 2 ||
            (i != SECURITY_TABLE_NUMBER &&
             i != EXTEND_TABLE_NUMBER &&
             i != ROOT_FILE_NAME_INDEX_NUMBER)) {
            if (!frs.IsInUse()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                ChkdskInfo->NumFileNames[i] = 1;

                if (!frs.CreateSystemFile(ChkdskInfo->major,
                                          ChkdskInfo->minor)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }

                // Mark this file for consideration when handing out free
                // data attributes.

                ChkdskInfo->FilesWhoNeedData.SetAllocated(frs.QueryFileNumber(), 1);
            }
        } else if (i == SECURITY_TABLE_NUMBER) {
            if (!frs.IsInUse()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                ChkdskInfo->NumFileNames[i] = 1;

                if (!frs.CreateSystemFile(ChkdskInfo->major,
                                          ChkdskInfo->minor)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                frs.SetViewIndexPresent();

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }
            } else if (!frs.IsViewIndexPresent()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                frs.SetViewIndexPresent();

                Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                    "%d", SECURITY_TABLE_NUMBER);

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_VIEW_INDEX_PRESENT_BIT,
                             "%x", SECURITY_TABLE_NUMBER);

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }
            }
        } else if (i == EXTEND_TABLE_NUMBER ||
                   i == ROOT_FILE_NAME_INDEX_NUMBER) {
            if (!frs.IsInUse()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                ChkdskInfo->NumFileNames[i] = 1;

                if (!frs.CreateSystemFile(ChkdskInfo->major,
                                          ChkdskInfo->minor)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                frs.SetIndexPresent();

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }
            } else if (!frs.IsIndexPresent()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                frs.SetIndexPresent();

                Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS, "%d", i);

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_FILE_NAME_INDEX_PRESENT_BIT,
                             "%x", i);

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }
            }

        }

        // Make sure that this file has no $FILE_NAME attribute
        // who's parent is not the root directory.

        if (!EnsureValidParentFileName(ChkdskInfo, &frs,
                                       root_file_reference, &changes)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        ChkdskInfo->ReferenceCount[i] = frs.QueryReferenceCount();

        if (changes) {

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_SYSTEM_FILE_NAME,
                                "%d", frs.QueryFileNumber().GetLowPart());

            if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
                DebugAbort("can't write system file");
                return FALSE;
            }
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
NTFS_SA::CheckExtendSystemFiles(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine goes through all of the files in \$Extend and make
    sure they all exist, and are in use.  Besides that this method
    makes sure that none of the system files have file-names that
    point back to any directory besides the \$Extend (file 0xB).
    It also makes sure there the proper indices appear in each
    of the files.

Arguments:

    ChkdskInfo   - Supplies the current chkdsk info.
    ChkdskReport - Supplies the current chkdsk report.
    Mft          - Supplies the MFT.
    FixLevel     - Supplies the fix level.
    Message      - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG                       i;
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_FILE_RECORD_SEGMENT    parent_frs;
    FILE_REFERENCE              parent_file_reference;
    BOOLEAN                     changes;
    DSTRING                     index_name;
    NTFS_INDEX_TREE             parent_index;
    NTFS_INDEX_TREE             index;
    BIG_INT                     file_number;
    FILE_NAME                   file_name[2];
    BOOLEAN                     parent_index_need_save;
    BOOLEAN                     index_need_save;
    BOOLEAN                     error;
    PINDEX_ENTRY                found_entry;
    PNTFS_INDEX_BUFFER          ContainingBuffer;
    ULONG                       file_name_size;
    NTFS_ATTRIBUTE              attrib;
    BOOLEAN                     diskErrorsFound;
    BOOLEAN                     alloc_present;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    //
    // read in the $Extend FRS as parent
    //

    if (!parent_frs.Initialize(EXTEND_TABLE_NUMBER, Mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!parent_frs.Read()) {
        DebugAbort("Can't read a hotfixed system FRS");
        return FALSE;
    }

    parent_file_reference = parent_frs.QuerySegmentReference();

    //
    // Make sure the parent has an $I30 index
    //

    if (!index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    parent_index_need_save = FALSE;
    if (!parent_frs.IsIndexPresent() ||
        !parent_index.Initialize(_drive,
                                 QueryClusterFactor(),
                                 Mft->GetVolumeBitmap(),
                                 Mft->GetUpcaseTable(),
                                 parent_frs.QuerySize()/2,
                                 &parent_frs,
                                 &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name, EXTEND_TABLE_NUMBER);

        if (parent_frs.IsIndexPresent()) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_IS_MISSING,
                         "%I64x%W",
                         parent_frs.QueryFileNumber().GetLargeInteger(),
                         &index_name);
        } else {
            Message->LogMsg(MSG_CHKLOG_NTFS_FILE_NAME_INDEX_PRESENT_BIT_SET,
                         "%I64x", parent_frs.QueryFileNumber().GetLargeInteger());
        }

        if (!parent_index.Initialize($FILE_NAME,
                                     _drive,
                                     QueryClusterFactor(),
                                     Mft->GetVolumeBitmap(),
                                     Mft->GetUpcaseTable(),
                                     COLLATION_FILE_NAME,
                                     SMALL_INDEX_BUFFER_SIZE,
                                     parent_frs.QuerySize()/2,
                                     &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SYSTEM_FILE,
                                "%d", EXTEND_TABLE_NUMBER);
            return FALSE;
        }
        parent_frs.SetIndexPresent();
        parent_index_need_save = TRUE;
        ChkdskReport->NumIndices += 1;
    }

    //
    // now check the object id file
    //

    if (!index_name.Initialize(ObjectIdFileName)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->ObjectIdFileNumber.GetLargeInteger() == 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_OBJID);

        if (!Mft->AllocateFileRecordSegment(&file_number, FALSE)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            return FALSE;
        }

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.CreateExtendSystemFile(&index_name,
                FILE_SYSTEM_FILE | FILE_VIEW_INDEX_PRESENT,
                DUP_VIEW_INDEX_PRESENT)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetReferenceCount(1);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        ChkdskInfo->ObjectIdFileNumber = file_number;
    } else {

        file_number = ChkdskInfo->ObjectIdFileNumber;

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
            return FALSE;
        }

        if (!frs.IsSystemFile() || !frs.IsViewIndexPresent()) {

            MSGID   msgid;

            if (frs.IsSystemFile())
                msgid = MSG_CHKLOG_NTFS_MISSING_VIEW_INDEX_PRESENT_BIT;
            else
                msgid = MSG_CHKLOG_NTFS_MISSING_SYSTEM_FILE_BIT;
            Message->LogMsg(msgid, "%I64x", file_number.GetLargeInteger());

            frs.SetSystemFile();
            frs.SetViewIndexPresent();

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                "%d", file_number.GetLowPart());

            if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (!EnsureValidFileAttributes(&frs,
                                       &parent_index,
                                       &parent_index_need_save,
                                       DUP_VIEW_INDEX_PRESENT,
                                       ChkdskInfo,
                                       Mft,
                                       FixLevel,
                                       Message))
            return FALSE;
    }

    // Make sure that this file has no $FILE_NAME attribute
    // who's parent is not the extend directory.

    if (!EnsureValidParentFileName(NULL,
                                   &frs,
                                   parent_file_reference,
                                   &changes)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // now make sure the $ObjId file name appears
    // in the index entry of its parent

    if (!frs.QueryAttribute(&attrib, &error, $FILE_NAME)) {
        DebugPrint("Unable to locate $FILE_NAME attribute in the object id FRS\n");
        return FALSE;
    }

    DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

    file_name_size = attrib.QueryValueLength().GetLowPart();

    DebugAssert(file_name_size <= sizeof(FILE_NAME)*2);

    memcpy(file_name, attrib.GetResidentValue(), file_name_size);

    if (!parent_index.QueryEntry(file_name_size,
                                 &file_name,
                                 0,
                                 &found_entry,
                                 &ContainingBuffer,
                                 &error)) {

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                            "%d%W", EXTEND_TABLE_NUMBER,
                                 parent_index.GetName());

        if (!parent_index.InsertEntry(file_name_size,
                                      &file_name,
                                      frs.QuerySegmentReference())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W", EXTEND_TABLE_NUMBER, parent_index.GetName());
            return FALSE;
        }
        parent_index_need_save = TRUE;
    }

    //
    // now check the index of $ObjectId
    //

    if (!index_name.Initialize(ObjectIdIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive,
                          QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name, frs.QueryFileNumber());

        if (!index.Initialize(0,
                              _drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              COLLATION_ULONGS,
                              SMALL_INDEX_BUFFER_SIZE,
                              frs.QuerySize()/2,
                              &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !index.Save(&frs)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (!ValidateEntriesInObjIdIndex(&index,
                                         &frs,
                                         ChkdskInfo,
                                         &changes,
                                         Mft,
                                         FixLevel,
                                         Message,
                                         &diskErrorsFound)) {
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            return FALSE;
        }
        ChkdskReport->NumIndices += 1;
        alloc_present = frs.QueryAttribute(&attrib,
                                           &error,
                                           $INDEX_ALLOCATION,
                                           &index_name);

        if (!alloc_present && error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (alloc_present) {
           ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        }
    }

    //
    // now check the Reparse Point file
    //

    if (!index_name.Initialize(ReparseFileName)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->ReparseFileNumber.GetLargeInteger() == 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_REPARSE);

        if (!Mft->AllocateFileRecordSegment(&file_number, FALSE)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            return FALSE;
        }

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.CreateExtendSystemFile(&index_name,
                FILE_SYSTEM_FILE | FILE_VIEW_INDEX_PRESENT,
                DUP_VIEW_INDEX_PRESENT)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetReferenceCount(1);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        ChkdskInfo->ReparseFileNumber = file_number;
    } else {

        file_number = ChkdskInfo->ReparseFileNumber;

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
            return FALSE;
        }

        if (!frs.IsSystemFile() || !frs.IsViewIndexPresent()) {

            MSGID   msgid;

            if (frs.IsSystemFile())
                msgid = MSG_CHKLOG_NTFS_MISSING_VIEW_INDEX_PRESENT_BIT;
            else
                msgid = MSG_CHKLOG_NTFS_MISSING_SYSTEM_FILE_BIT;
            Message->LogMsg(msgid, "%I64x", file_number.GetLargeInteger());

            frs.SetSystemFile();
            frs.SetViewIndexPresent();

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                "%d", file_number.GetLowPart());

            if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (!EnsureValidFileAttributes(&frs,
                                       &parent_index,
                                       &parent_index_need_save,
                                       DUP_VIEW_INDEX_PRESENT,
                                       ChkdskInfo,
                                       Mft,
                                       FixLevel,
                                       Message))
            return FALSE;
    }

    // Make sure that this file has no $FILE_NAME attribute
    // who's parent is not the extend directory.

    if (!EnsureValidParentFileName(NULL,
                                   &frs,
                                   parent_file_reference,
                                   &changes)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // now make sure the $Reparse file name appears
    // in the index entry of its parent

    if (!frs.QueryAttribute(&attrib, &error, $FILE_NAME)) {
        DebugPrint("Unable to locate $FILE_NAME attribute in the reparse point FRS\n");
        return FALSE;
    }

    DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

    file_name_size = attrib.QueryValueLength().GetLowPart();

    DebugAssert(file_name_size <= sizeof(FILE_NAME)*2);

    memcpy(file_name, attrib.GetResidentValue(), file_name_size);

    if (!parent_index.QueryEntry(file_name_size,
                                 &file_name,
                                 0,
                                 &found_entry,
                                 &ContainingBuffer,
                                 &error)) {

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                            "%d%W", EXTEND_TABLE_NUMBER,
                                 parent_index.GetName());

        if (!parent_index.InsertEntry(file_name_size,
                                      &file_name,
                                      frs.QuerySegmentReference())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W", EXTEND_TABLE_NUMBER, parent_index.GetName());
            return FALSE;
        }
        parent_index_need_save = TRUE;
    }

    //
    // now check the index of $Reparse
    //

    if (!index_name.Initialize(ReparseIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive,
                          QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name, frs.QueryFileNumber());

        if (!index.Initialize(0,
                              _drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              COLLATION_ULONGS,
                              SMALL_INDEX_BUFFER_SIZE,
                              frs.QuerySize()/2,
                              &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !index.Save(&frs)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (!ValidateEntriesInReparseIndex(&index,
                                           &frs,
                                           ChkdskInfo,
                                           &changes,
                                           Mft,
                                           FixLevel,
                                           Message,
                                           &diskErrorsFound)) {
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            return FALSE;
        }
        ChkdskReport->NumIndices += 1;
        alloc_present = frs.QueryAttribute(&attrib,
                                           &error,
                                           $INDEX_ALLOCATION,
                                           &index_name);

        if (!alloc_present && error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (alloc_present) {
           ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        }
    }

    //
    // now check the quota file
    //

    if (!index_name.Initialize(QuotaFileName)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->QuotaFileNumber.GetLargeInteger() == 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_QUOTA);

        if (!Mft->AllocateFileRecordSegment(&file_number, FALSE)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.CreateExtendSystemFile(&index_name,
                FILE_SYSTEM_FILE | FILE_VIEW_INDEX_PRESENT,
                DUP_VIEW_INDEX_PRESENT)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetReferenceCount(1);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        ChkdskInfo->QuotaFileNumber = file_number;
    } else {

        file_number = ChkdskInfo->QuotaFileNumber;

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
            return FALSE;
        }

        if (!frs.IsSystemFile() || !frs.IsViewIndexPresent()) {

            MSGID   msgid;

            if (frs.IsSystemFile())
                msgid = MSG_CHKLOG_NTFS_MISSING_VIEW_INDEX_PRESENT_BIT;
            else
                msgid = MSG_CHKLOG_NTFS_MISSING_SYSTEM_FILE_BIT;
            Message->LogMsg(msgid, "%I64x", file_number.GetLargeInteger());

            frs.SetSystemFile();
            frs.SetViewIndexPresent();

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                "%d", file_number.GetLowPart());

            if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (!EnsureValidFileAttributes(&frs,
                                       &parent_index,
                                       &parent_index_need_save,
                                       DUP_VIEW_INDEX_PRESENT,
                                       ChkdskInfo,
                                       Mft,
                                       FixLevel,
                                       Message))
            return FALSE;
    }

    // Make sure that this file has no $FILE_NAME attribute
    // who's parent is not the extend directory.

    if (!EnsureValidParentFileName(NULL,
                                   &frs,
                                   parent_file_reference,
                                   &changes)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // now make sure the $Quota file name appears
    // in the index entry of its parent

    if (!frs.QueryAttribute(&attrib, &error, $FILE_NAME)) {
        DebugPrint("Unable to locate $FILE_NAME attribute in the quota FRS\n");
        return FALSE;
    }

    DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

    file_name_size = attrib.QueryValueLength().GetLowPart();

    DebugAssert(file_name_size <= sizeof(FILE_NAME)*2);

    memcpy(file_name, attrib.GetResidentValue(), file_name_size);

    if (!parent_index.QueryEntry(file_name_size,
                                 &file_name,
                                 0,
                                 &found_entry,
                                 &ContainingBuffer,
                                 &error)) {

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                            "%d%W", EXTEND_TABLE_NUMBER,
                                 parent_index.GetName());

        if (!parent_index.InsertEntry(file_name_size,
                                      &file_name,
                                      frs.QuerySegmentReference())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W", EXTEND_TABLE_NUMBER, parent_index.GetName());
            return FALSE;
        }
        parent_index_need_save = TRUE;
    }

    //
    // now check the indices of $Quota
    //

    //
    // Check the Sid to Userid index first for $Quota
    //

    if (!index_name.Initialize(Sid2UseridQuotaNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive,
                          QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name,
                                 frs.QueryFileNumber().GetLowPart());

        if (!index.Initialize(0,
                              _drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              COLLATION_SID,
                              SMALL_INDEX_BUFFER_SIZE,
                              frs.QuerySize()/2,
                              &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                                     frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !index.Save(&frs)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }
        ChkdskReport->NumIndices += 1;
    }

    //
    // now check the Userid to Sid index for $Quota
    //

    if (!index_name.Initialize(Userid2SidQuotaNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive,
                          QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name,
                                 frs.QueryFileNumber().GetLowPart());

        if (!index.Initialize(0,
                              _drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              COLLATION_ULONG,
                              SMALL_INDEX_BUFFER_SIZE,
                              frs.QuerySize()/2,
                              &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                                     frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !index.Save(&frs)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                                     frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        switch (frs.VerifyAndFixQuotaDefaultId(Mft->GetVolumeBitmap(),
                                               FixLevel == CheckOnly)) {
          case NTFS_QUOTA_INDEX_FOUND:
              DebugAssert(FALSE);
              break;

          case NTFS_QUOTA_INDEX_INSERTED:
          case NTFS_QUOTA_DEFAULT_ENTRY_MISSING:
              errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
              Message->DisplayMsg(MSG_CHK_NTFS_DEFAULT_QUOTA_ENTRY_MISSING,
                                "%d%W",
                               frs.QueryFileNumber().GetLowPart(),
                               &index_name);
              break;

          case NTFS_QUOTA_INDEX_NOT_FOUND:
              if (FixLevel != CheckOnly) {
                  DebugAssert(FALSE);
                  return FALSE;
              }
              break;

          case NTFS_QUOTA_ERROR:
              Message->DisplayMsg(MSG_CHK_NO_MEMORY);
              return FALSE;

          case NTFS_QUOTA_INSERT_FAILED:
              ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
              Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W",
                               frs.QueryFileNumber().GetLowPart(),
                               index_name);
              return FALSE;
        }

        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }
        ChkdskReport->NumIndices += 1;
        alloc_present = frs.QueryAttribute(&attrib,
                                           &error,
                                           $INDEX_ALLOCATION,
                                           &index_name);

        if (!alloc_present && error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (alloc_present) {
           ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        }
    }

    //
    // now check the Usn Journal file
    //

    if (!index_name.Initialize(UsnJournalFileName)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->UsnJournalFileNumber.GetLargeInteger() == 0) {

#if 0 // if journal file does not exist it means it's not being enabled
      // so don't create one

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_USNJRNL);

        if (!Mft->AllocateFileRecordSegment(&file_number, FALSE)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
            return FALSE;
        }

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.CreateExtendSystemFile(&index_name,
                                        FILE_SYSTEM_FILE,
                                        FILE_ATTRIBUTE_SPARSE_FILE)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetReferenceCount(1);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        ChkdskInfo->UsnJournalFileNumber = file_number;
#endif

    } else {

        file_number = ChkdskInfo->UsnJournalFileNumber;

        ChkdskInfo->FilesWhoNeedData.SetFree(file_number, 1);

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
            return FALSE;
        }

        if (!frs.IsSystemFile()) {
            frs.SetSystemFile();

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                "%d", file_number.GetLowPart());

            Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_SYSTEM_FILE_BIT,
                         "%I64x", file_number.GetLargeInteger());

            if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (!EnsureValidFileAttributes(&frs,
                                       &parent_index,
                                       &parent_index_need_save,
                                       FILE_ATTRIBUTE_SPARSE_FILE,
                                       ChkdskInfo,
                                       Mft,
                                       FixLevel,
                                       Message))
            return FALSE;
    }

    // Make sure that this file has no $FILE_NAME attribute
    // who's parent is not the $Extend directory.

    if (!EnsureValidParentFileName(NULL,
                                   &frs,
                                   parent_file_reference,
                                   &changes)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // now make sure the $UsnJrnl file name appears
    // in the index entry of its parent

    if (!frs.QueryAttribute(&attrib, &error, $FILE_NAME)) {
        DebugPrint("Unable to locate $FILE_NAME attribute in the Usn Journal FRS\n");
        return FALSE;
    }

    DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

    file_name_size = attrib.QueryValueLength().GetLowPart();

    DebugAssert(file_name_size <= sizeof(FILE_NAME)*2);

    memcpy(file_name, attrib.GetResidentValue(), file_name_size);

    if (!parent_index.QueryEntry(file_name_size,
                                 &file_name,
                                 0,
                                 &found_entry,
                                 &ContainingBuffer,
                                 &error)) {

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                            "%d%W", EXTEND_TABLE_NUMBER,
                                 parent_index.GetName());

        if (!parent_index.InsertEntry(file_name_size,
                                      &file_name,
                                      frs.QuerySegmentReference())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W", EXTEND_TABLE_NUMBER, parent_index.GetName());
            return FALSE;
        }
        parent_index_need_save = TRUE;
    }

    if (parent_index_need_save) {
        if (FixLevel != CheckOnly &&
            (!parent_index.Save(&parent_frs) ||
             !parent_frs.Flush(Mft->GetVolumeBitmap()))) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SYSTEM_FILE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
MarkQuotaOutOfDate(
    IN PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN PNTFS_MASTER_FILE_TABLE     Mft,
    IN BOOLEAN                     FixLevel,
    IN OUT PMESSAGE                Message
)
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    DSTRING                     index_name;
    PCINDEX_ENTRY               index_entry;
    PQUOTA_USER_DATA            QuotaUserData;
    NTFS_INDEX_TREE             index;
    ULONG                       depth;
    BOOLEAN                     error;
    NTFS_ATTRIBUTE              attrib;

    if (ChkdskInfo->QuotaFileNumber.GetLargeInteger() == 0) {
        DebugPrint("Quota file number not found.  Please rebuild.\n");
        return TRUE;
    }

    if (!frs.Initialize(ChkdskInfo->QuotaFileNumber, Mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    if (!frs.Read()) {
        DebugAbort("Previously readable FRS is no longer readable");
        return FALSE;
    }
    if (!index_name.Initialize(Userid2SidQuotaNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // Check to see if the index exists

    if (!frs.QueryAttribute(&attrib,
                            &error,
                            $INDEX_ROOT,
                            &index_name))
        return TRUE; // does nothing as the index does not exist

    if (!index.Initialize(frs.GetDrive(),
                          frs.QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // Get the first entry - that's the default entry

    index.ResetIterator();
    if (!(index_entry = index.GetNext(&depth, &error))) {
        DebugPrintTrace(("Default Quota Index does not exist"));
        return FALSE;
    }

    if (*((ULONG*)GetIndexEntryValue(index_entry)) != QUOTA_DEFAULTS_ID) {
        DebugPrintTrace(("Default Quota Index not at the beginning of index"));
        return FALSE;
    }
    QuotaUserData = (PQUOTA_USER_DATA)((char*)GetIndexEntryValue(index_entry) + sizeof(ULONG));
    QuotaUserData->QuotaFlags |= QUOTA_FLAG_OUT_OF_DATE;
    if (FixLevel != CheckOnly &&
        (!index.WriteCurrentEntry() ||
        !index.Save(&frs) ||
        !frs.Flush(Mft->GetVolumeBitmap()))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    return TRUE;
}

BOOLEAN
ValidateEa(
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
       OUT  PBOOLEAN                    Errors,
    IN OUT  PNTFS_BITMAP                VolumeBitmap,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This routine checks out the given file for any EA related attributes.
    It then makes sure that these are correct.  It will make minor
    corrections to the EA_INFORMATION attribute but beyond that it
    will tube the EA attributes if anything is bad.

Arguments:

    Frs             - Supplies the file with the alleged EAs.
    Errors          - Returns TRUE if error has been found
    VolumeBitmap    - Supplies the volume bitmap.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // Greater than theoretical upper bound for $EA_DATA attribute.
    CONST   MaxEaDataSize   = 256*1024;

    NTFS_ATTRIBUTE  ea_info;
    NTFS_ATTRIBUTE  ea_data;
    HMEM            data_hmem;
    ULONG           data_length;
    BOOLEAN         error;
    BOOLEAN         tube;
    EA_INFORMATION  disk_info;
    EA_INFORMATION  real_info;
    PPACKED_EA      pea;
    PULONG          plength;
    ULONG           packed_total, packed_length;
    ULONG           need_ea_count;
    ULONG           unpacked_total, unpacked_length;
    PCHAR           pend;
    ULONG           num_bytes;
    BOOLEAN         data_present, info_present;

    DebugPtrAssert(Errors);

    tube = *Errors = FALSE;

    data_present = Frs->QueryAttribute(&ea_data, &error, $EA_DATA);
    if (!data_present && error) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    info_present = Frs->QueryAttribute(&ea_info, &error, $EA_INFORMATION);
    if (!info_present && error) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!info_present && !data_present) {

        // There are no EAs here.
        return TRUE;
    }


    if (!info_present || !data_present) {

        tube = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_EA_INFO_XOR_EA_DATA,
                     "%I64x%x%x",
                     Frs->QueryFileNumber().GetLargeInteger(),
                     info_present,
                     data_present);

        DebugPrintTrace(("UNTFS: EA_INFO XOR EA_DATA in file 0x%I64x\n",
                         Frs->QueryFileNumber().GetLargeInteger()));

    } else if (ea_info.QueryValueLength() < sizeof(EA_INFORMATION) ||
               ea_info.QueryValueLength().GetHighPart() != 0) {

        tube = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_EA_INFO_LENGTH,
                     "%I64x%I64x",
                     ea_info.QueryValueLength().GetLargeInteger(),
                     Frs->QueryFileNumber().GetLargeInteger());

        DebugPrintTrace(("UNTFS: Bad EA info value length in file 0x%I64x\n",
                         Frs->QueryFileNumber().GetLargeInteger()));

    } else if (ea_data.QueryValueLength() > MaxEaDataSize) {

        tube = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_EA_DATA_LENGTH,
                     "%I64x%I64x",
                     ea_data.QueryValueLength().GetLargeInteger(),
                     Frs->QueryFileNumber().GetLargeInteger());

        DebugPrintTrace(("UNTFS: Bad EA data value length in file 0x%I64x\n",
                         Frs->QueryFileNumber().GetLargeInteger()));

    }

    if (!tube) {

        data_length = ea_data.QueryValueLength().GetLowPart();

        if (!data_hmem.Initialize() ||
            !data_hmem.Acquire(data_length)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!ea_info.Read(&disk_info,
                          0, sizeof(EA_INFORMATION), &num_bytes)) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_UNREADABLE_EA_INFO,
                         "%I64x", Frs->QueryFileNumber().GetLargeInteger());

            DebugPrintTrace(("UNTFS: Unable to read EA Info from file 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));

        } else if (num_bytes != sizeof(EA_INFORMATION)) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_EA_INFO_INCORRECT_SIZE,
                         "%I64x%x%x",
                         Frs->QueryFileNumber().GetLargeInteger(),
                         num_bytes,
                         sizeof(EA_INFORMATION));

            DebugPrintTrace(("UNTFS: EA Info too small in file 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));

        } else if (!ea_data.Read(data_hmem.GetBuf(),
                                 0, data_length, &num_bytes)) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_UNREADABLE_EA_DATA,
                         "%I64x", Frs->QueryFileNumber().GetLargeInteger());

            DebugPrintTrace(("UNTFS: Unable to read EA Data from file 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));

        } else if (num_bytes != data_length) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_EA_DATA_INCORRECT_SIZE,
                         "%I64x%x%x",
                         Frs->QueryFileNumber().GetLargeInteger(),
                         num_bytes,
                         data_length);

            DebugPrintTrace(("UNTFS: EA Data too small in file 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));
        }
    }

    if (!tube) {

        plength = (PULONG) data_hmem.GetBuf();

        pend = (PCHAR) data_hmem.GetBuf() + data_length;

        packed_total = 0;
        need_ea_count = 0;
        unpacked_total = 0;

        while ((PCHAR) plength < pend) {

            if ((PCHAR) plength + sizeof(ULONG) + sizeof(PACKED_EA) > pend) {

                tube = TRUE;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_CORRUPT_EA_SET);
                Message->Log("%I64x%x",
                             Frs->QueryFileNumber().GetLargeInteger(),
                             pend-(PCHAR)plength);
                Message->DumpDataToLog(plength, (ULONG)min(0x100, max(0, pend-(PCHAR)plength)));
                Message->Unlock();

                DebugPrintTrace(("UNTFS: Corrupt EA set. File 0x%I64x\n",
                                 Frs->QueryFileNumber().GetLargeInteger()));
                break;
            }

            pea = (PPACKED_EA) ((PCHAR) plength + sizeof(ULONG));

            packed_length = sizeof(PACKED_EA) + pea->NameSize +
                            pea->ValueSize[0] + (pea->ValueSize[1]<<8);

            unpacked_length = sizeof(ULONG) + DwordAlign(packed_length);

            packed_total += packed_length;
            unpacked_total += unpacked_length;
            if (pea->Flag & EA_FLAG_NEED) {
                need_ea_count++;
            }

            if (unpacked_total > data_length ||
                pea->Name[pea->NameSize] != 0) {

                tube = TRUE;

                if (unpacked_total > data_length) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_TOTAL_EA_SIZE,
                                 "%I64x%x%x",
                                 Frs->QueryFileNumber().GetLargeInteger(),
                                 unpacked_total,
                                 data_length);
                } else {
                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_INCORRECT_EA_NAME);
                    Message->Log("%I64x%x",
                                 Frs->QueryFileNumber().GetLargeInteger(),
                                 pea->NameSize);
                    Message->DumpDataToLog(pea->Name, pea->NameSize);
                    Message->Unlock();
                }

                DebugPrintTrace(("UNTFS: EA name in set is missing NULL. File 0x%I64x\n",
                                 Frs->QueryFileNumber().GetLargeInteger()));
                break;
            }

            if (*plength != unpacked_length) {

                tube = TRUE;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_EA_SIZE);
                Message->Log("%I64x%x%x",
                             Frs->QueryFileNumber().GetLargeInteger(),
                             unpacked_length,
                             *plength);
                Message->DumpDataToLog(plength, min(0x100, unpacked_length));
                Message->Unlock();

                DebugPrintTrace(("UNTFS: Bad unpacked length field in EA set. File 0x%I64x\n",
                                 Frs->QueryFileNumber().GetLargeInteger()));
                break;
            }

            plength = (PULONG) ((PCHAR) plength + unpacked_length);
        }

        if ((packed_total>>(8*sizeof(USHORT))) != 0) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_TOTAL_PACKED_TOO_LARGE,
                         "%I64x%x",
                         Frs->QueryFileNumber().GetLargeInteger(),
                         packed_total);
            DebugPrintTrace(("UNTFS: Total packed length is too large. File 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));
        }
    }

    if (!tube) {

        real_info.PackedEaSize = (USHORT)packed_total;
        real_info.NeedEaCount = (USHORT)need_ea_count;
        real_info.UnpackedEaSize = unpacked_total;

        if (memcmp(&real_info, &disk_info, sizeof(EA_INFORMATION))) {

            Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_EA,
                                "%d", Frs->QueryFileNumber().GetLowPart());

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_EA_INFO,
                         "%x%x%x%x%x%x",
                         real_info.PackedEaSize,
                         real_info.NeedEaCount,
                         real_info.UnpackedEaSize,
                         disk_info.PackedEaSize,
                         disk_info.NeedEaCount,
                         disk_info.UnpackedEaSize);

            DebugPrintTrace(("UNTFS: Incorrect EA information.  File 0x%I64x\n",
                      Frs->QueryFileNumber().GetLargeInteger()));

            *Errors = TRUE;
            if (FixLevel != CheckOnly) {

                if (!ea_info.Write(&real_info, 0, sizeof(EA_INFORMATION),
                                   &num_bytes, NULL) ||
                    num_bytes != sizeof(EA_INFORMATION) ||
                    !ea_info.InsertIntoFile(Frs, VolumeBitmap)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }
    }


    if (tube) {

        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_CORRUPT_EA_SET,
                            "%d", Frs->QueryFileNumber().GetLowPart());
        *Errors = TRUE;

        if (data_present) {
            if (!ea_data.IsResident()) {
                ChkdskReport->BytesUserData -= ea_data.QueryAllocatedLength();
            }
            ea_data.Resize(0, VolumeBitmap);
            Frs->PurgeAttribute($EA_DATA);
        }
        if (info_present) {
            if (!ea_info.IsResident()) {
                ChkdskReport->BytesUserData -= ea_info.QueryAllocatedLength();
            }
            ea_info.Resize(0, VolumeBitmap);
            Frs->PurgeAttribute($EA_INFORMATION);
        }
    }

    if (FixLevel != CheckOnly && !Frs->Flush(VolumeBitmap)) {

        DebugAbort("Can't write it.");
        return FALSE;
    }


    return TRUE;
}


BOOLEAN
ValidateEas(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine validates all of the EAs on the volume.

Arguments:

    ChkdskInfo      - Supplies the current chkdsk information.
    Mft             - Supplies the MFT.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_SET                 FilesWithEas;
    NTFS_FILE_RECORD_SEGMENT    frs;
    BIG_INT                     l;
    BOOLEAN                     errors;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    DebugPtrAssert(ChkdskInfo);

    FilesWithEas = &(ChkdskInfo->FilesWithEas);
    l = FilesWithEas->QueryCardinality();
    while (l > 0) {

        l -= 1;

        if (!frs.Initialize(FilesWithEas->QueryNumber(0), Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!FilesWithEas->Remove(frs.QueryFileNumber())) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            DebugAbort("Previously readable now unreadable");
            continue;
        }

        if (!ValidateEa(&frs, ChkdskReport, &errors, Mft->GetVolumeBitmap(), FixLevel, Message)) {
            return FALSE;
        }
        if (errors) {
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}

BOOLEAN
ValidateReparsePoint(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine validates all of the Reparse Point attributes
    on the volume.  It does not fix up the standard information
    or duplicated information.

Arguments:

    ChkdskInfo      - Supplies the current chkdsk information.
    Mft             - Supplies the MFT.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_BITMAP                filesWithReparsePoint;
    BIG_INT                     i, l;
    NTFS_ATTRIBUTE              attribute;
    REPARSE_DATA_BUFFER         reparse_point;
    DSTRING                     null_string;
    NTFS_FILE_RECORD_SEGMENT    frs;
    BOOLEAN                     ErrorInAttribute;
    BIG_INT                     length;
    ULONG                       BytesRead;
    ULONG                       frs_needs_flushing;
    NUMBER_SET                  filesWithBadReparsePoint;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    BOOLEAN                     error;

#if defined(TIMING_ANALYSIS)
    LARGE_INTEGER               temp_time, temp_time2;
#endif

    DebugPtrAssert(ChkdskInfo);

#if defined(TIMING_ANALYSIS)
    IFS_SYSTEM::QueryNtfsTime(&temp_time);
#endif

    if (!null_string.Initialize("\"\"") ||
        !filesWithBadReparsePoint.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    filesWithReparsePoint = &(ChkdskInfo->FilesWithReparsePoint);
    l = ChkdskInfo->NumFiles;

    for (i = 0; i < l; i += 1) {

        if (filesWithReparsePoint->IsFree(i, 1))
            continue;

        if (!frs.Initialize(i, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            DebugAbort("Previously readable now unreadable");
            continue;
        }

        if (!frs.QueryAttribute(&attribute,
                                &ErrorInAttribute,
                                $REPARSE_POINT)) {
            //
            // Got to exists otherwise it would not be in the number set
            //
            DebugPrintTrace(("Previously existed reparse point "
                        "attribute disappeared on file 0x%I64x\n",
                        frs.QueryFileNumber().GetLargeInteger()));
            return FALSE;
        }

        length = attribute.QueryValueLength();
        frs_needs_flushing = FALSE;

        DebugAssert(FIELD_OFFSET(_REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) <=
                    FIELD_OFFSET(_REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer.DataBuffer));

        error = FALSE;

        if (CompareGT(length, MAXIMUM_REPARSE_DATA_BUFFER_SIZE)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_REPARSE_POINT_LENGTH_TOO_LARGE);
            Message->Log("%I64x%x",
                         length.GetLargeInteger(),
                         MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("The reparse point length (0x%I64x) has exceeded a maximum of 0x%x.\n",
                             length,
                             MAXIMUM_REPARSE_DATA_BUFFER_SIZE));
            error = TRUE;
        } else if (CompareLT(length, FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                                  GenericReparseBuffer.DataBuffer))) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_REPARSE_POINT_LENGTH_TOO_SMALL);
            Message->Log("%I64x%x",
                         length.GetLargeInteger(),
                         FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                      GenericReparseBuffer.DataBuffer));
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("The reparse point length (0x%I64x) is less than a minimum of %x.\n",
                             length.GetLargeInteger(),
                             FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                          GenericReparseBuffer.DataBuffer)));
            error = TRUE;
        } else if (!attribute.Read(&reparse_point,
                                   0,
                                   FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                                GenericReparseBuffer.DataBuffer),
                                   &BytesRead)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_UNREADABLE_REPARSE_POINT);
            Message->Log();
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("Unable to read reparse point data buffer.\n"));

            error = TRUE;
        } else if (BytesRead != FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                             GenericReparseBuffer.DataBuffer)) {
            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_INCORRECT_REPARSE_POINT_SIZE);
            Message->Log("%x%x",
                         BytesRead,
                         FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                      GenericReparseBuffer.DataBuffer));
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("Only %d bytes returned from a read of %d bytes of the reparse data buffer.\n",
                             BytesRead,
                             FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                          GenericReparseBuffer.DataBuffer)));
            error = TRUE;
        } else if ((((reparse_point.ReparseDataLength +
                      FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                    GenericReparseBuffer.DataBuffer)) != length) ||
                    !IsReparseTagMicrosoft(reparse_point.ReparseTag)) &&
                   ((reparse_point.ReparseDataLength +
                     FIELD_OFFSET(_REPARSE_GUID_DATA_BUFFER,
                                  GenericReparseBuffer.DataBuffer)) != length)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_INCORRECT_REPARSE_DATA_LENGTH);
            Message->Log("%x%I64x",
                         reparse_point.ReparseDataLength,
                         length.GetLargeInteger());
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("ReparseDataLength (0x%x) inconsistence with the attribute length (0x%I64x).\n",
                             reparse_point.ReparseDataLength,
                             length.GetLargeInteger()));
            error = TRUE;
        } else if (reparse_point.ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO ||
                   reparse_point.ReparseTag == IO_REPARSE_TAG_RESERVED_ONE) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_REPARSE_TAG_IS_RESERVED);
            Message->Log("%x", reparse_point.ReparseTag);
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("Reparse Tag (0x%x) is a reserved tag.\n",
                             reparse_point.ReparseTag));
            error = TRUE;
        }

        if (error) {

            frs_needs_flushing = TRUE;
            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                                "%d%W%d",
                                attribute.QueryTypeCode(),
                                attribute.GetName()->QueryChCount() ?
                                attribute.GetName() : &null_string,
                                frs.QueryFileNumber().GetLowPart());

            if (!filesWithBadReparsePoint.Add(frs.QueryFileNumber())) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!attribute.Resize(0, Mft->GetVolumeBitmap()) ||
                !frs.PurgeAttribute($REPARSE_POINT)) {
                DebugPrintTrace(("Unable to delete reparse point attribute from file 0x%I64x\n",
                                 frs.QueryFileNumber().GetLargeInteger()));
                return FALSE;
            } else
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (frs.IsAttributePresent($EA_INFORMATION)) {
            frs_needs_flushing = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_EA_INFORMATION_WITH_REPARSE_POINT,
                         "%I64x", frs.QueryFileNumber().GetLargeInteger());

            Message->DisplayMsg(MSG_CHK_NTFS_DELETING_EA_SET,
                                "%d", frs.QueryFileNumber().GetLowPart());
            if (!ChkdskInfo->FilesWithEas.Remove(frs.QueryFileNumber())) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            if (!frs.QueryAttribute(&attribute,
                                    &ErrorInAttribute,
                                    $EA_DATA)) {
                if (ErrorInAttribute) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                //
                // $EA_DATA simply don't exists but there is an $EA_INFORMATION
                //
                if (!frs.PurgeAttribute($EA_INFORMATION)) {
                    DebugPrintTrace(("Unable to delete EA INFO attribute from file 0x%I64x\n",
                                frs.QueryFileNumber().GetLargeInteger()));
                    return FALSE;
                } else
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            } else if (!attribute.Resize(0, Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            } else {
                if (!frs.PurgeAttribute($EA_INFORMATION) ||
                    !frs.PurgeAttribute($EA_DATA)) {
                    DebugPrintTrace(("Unable to delete EA INFO/DATA attribute from file 0x%I64x\n",
                                frs.QueryFileNumber().GetLargeInteger()));
                    return FALSE;
                } else
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }

        if (frs_needs_flushing && FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            DebugAbort("Can't write it.");
            return FALSE;
        }
    }

    while (filesWithBadReparsePoint.QueryCardinality() != 0) {
        filesWithReparsePoint->SetFree(filesWithBadReparsePoint.QueryNumber(0), 1);
        filesWithBadReparsePoint.Remove(filesWithBadReparsePoint.QueryNumber(0));
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

#if defined(TIMING_ANALYSIS)
    IFS_SYSTEM::QueryNtfsTime(&temp_time2);
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%I64d", "ValidateReparsePoint time in ticks: ",
                        temp_time2.QuadPart - temp_time.QuadPart);
#endif

    return TRUE;
}

BOOLEAN
NTFS_SA::CheckAllForData(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine makes sure that all of the files in the list
    of files that don't have unnamed data attributes either
    get them or aren't supposed to have them anyway.

Arguments:

    ChkdskInfo  - Supplies the current chkdsk information.
    Mft         - Supplies the MFT.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    BIG_INT                     i, n;
    NTFS_ATTRIBUTE              data_attribute;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;


    // Compute the number of files to examine.

    n = ChkdskInfo->FilesWhoNeedData.QuerySize();

    // Create an empty unnamed data attribute.

    if (!data_attribute.Initialize(_drive,
                                   QueryClusterFactor(),
                                   NULL,
                                   0,
                                   $DATA)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    // Ensure that every file in the list either has a $DATA attribute
    // or is an directory.

    for (i = 0; i < n; i = i + 1) {

        if (ChkdskInfo->FilesWhoNeedData.IsFree(i, 1))
            continue;

        if (!frs.Initialize(i, Mft) ||
            !frs.Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (frs.IsIndexPresent() || frs.IsAttributePresent($DATA)) {
            continue;
        }

        Message->DisplayMsg(MSG_CHK_NTFS_MISSING_DATA_ATTRIBUTE,
                            "%I64d", i);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (!data_attribute.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
        }

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
ResolveCrossLink(
    IN      PCNTFS_CHKDSK_INFO      ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine resolved the cross-link specified in the
    'ChkdskInfo', if any.  The cross-link is resolved by
    copying if possible.

Arguments:

    ChkdskInfo  - Supplies the cross-link information.
    Mft         - Supplies the master file table.
    BadClusters - Supplies the current list of bad clusters.
    FixLevel    - Supplies the fix-up level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_ATTRIBUTE              attr;
    PNTFS_ATTRIBUTE             pattribute;
    BOOLEAN                     error;
    VCN                         vcn;
    LCN                         lcn;
    BIG_INT                     run_length;
    VCN                         hotfix_vcn;
    LCN                         hotfix_lcn, hotfix_last;
    BIG_INT                     hotfix_length;
    PVOID                       hotfix_buffer;
    ULONG                       cluster_size;
    ULONG                       bytes_read, hotfix_bytes;

    if (!ChkdskInfo->CrossLinkYet) {
        return TRUE;
    }

    Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_CROSS_LINK,
                        "%d", ChkdskInfo->CrossLinkedFile);

    if (!frs.Initialize(ChkdskInfo->CrossLinkedFile, Mft) ||
        !frs.Read()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->CrossLinkedFile == 0 &&
        ChkdskInfo->CrossLinkedAttribute == $DATA &&
        ChkdskInfo->CrossLinkedName.QueryChCount() == 0) {

        pattribute = Mft->GetDataAttribute();

    } else {

        if (!frs.QueryAttribute(&attr, &error,
                                ChkdskInfo->CrossLinkedAttribute,
                                &ChkdskInfo->CrossLinkedName)) {

            if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            // If the attribute is no longer there, that's ok, because
            // it may have been corrupt.

            return TRUE;
        }

        pattribute = &attr;
    }


    // Figure out which VCN's map to the given CrossLinked LCN's
    // and hotfix those VCN's using the hotfix routine.

    for (vcn = 0;
         pattribute->QueryLcnFromVcn(vcn, &lcn, &run_length);
         vcn += run_length) {

        if (lcn == LCN_NOT_PRESENT) {
            continue;
        }

        if (lcn < ChkdskInfo->CrossLinkStart) {
            hotfix_lcn = ChkdskInfo->CrossLinkStart;
        } else {
            hotfix_lcn = lcn;
        }
        if (lcn + run_length > ChkdskInfo->CrossLinkStart +
                               ChkdskInfo->CrossLinkLength) {
            hotfix_last = ChkdskInfo->CrossLinkStart +
                               ChkdskInfo->CrossLinkLength;
        } else {
            hotfix_last = lcn + run_length;
        }

        if (hotfix_last <= hotfix_lcn) {
            continue;
        }

        hotfix_length = hotfix_last - hotfix_lcn;
        hotfix_vcn = vcn + (hotfix_lcn - lcn);
        cluster_size = Mft->QueryClusterFactor()*
                       Mft->GetDataAttribute()->GetDrive()->QuerySectorSize();
        hotfix_bytes = hotfix_length.GetLowPart()*cluster_size;

        // Before hotfixing the cross-linked data, read in the
        // data into a buffer.

        if (!(hotfix_buffer = MALLOC(hotfix_bytes))) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        memset(hotfix_buffer, 0, hotfix_bytes);
        pattribute->Read(hotfix_buffer,
                         hotfix_vcn*cluster_size,
                         hotfix_bytes,
                         &bytes_read);

        if (!pattribute->Hotfix(hotfix_vcn, hotfix_length,
                                Mft->GetVolumeBitmap(),
                                BadClusters)) {

            // Purge the attribute since there isn't enough disk
            // space to save it.

            if (!frs.PurgeAttribute(ChkdskInfo->CrossLinkedAttribute,
                                    &ChkdskInfo->CrossLinkedName)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(hotfix_buffer);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(hotfix_buffer);
                return FALSE;
            }

            FREE(hotfix_buffer);
            return TRUE;
        }

        if (FixLevel != CheckOnly) {
            if (!pattribute->Write(hotfix_buffer,
                                   hotfix_vcn*cluster_size,
                                   hotfix_bytes,
                                   &bytes_read,
                                   NULL) ||
                bytes_read != hotfix_bytes ||
                !pattribute->InsertIntoFile(&frs, Mft->GetVolumeBitmap()) ||
                !frs.Flush(Mft->GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(hotfix_buffer);
                return FALSE;
            }
        }

        FREE(hotfix_buffer);
    }

    return TRUE;
}

#if defined( _SETUP_LOADER_ )

BOOLEAN
RecoverAllUserFiles(
    IN      UCHAR                   VolumeMajorVersion,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
{
    return TRUE;
}

BOOLEAN
RecoverFreeSpace(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
{
    return TRUE;
}

#else // _SETUP_LOADER_ not defined

BOOLEAN
RecoverAllUserFiles(
    IN      UCHAR                   VolumeMajorVersion,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine traverses all of the files in the MFT and
    verifies its attributes for bad clusters.

Arguments:

    Mft         - Supplies the master file table.
    BadClusters - Supplies the current list of bad clusters.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG                       i, n, percent_done;
    NTFS_FILE_RECORD_SEGMENT    frs;
    ULONG                       num_bad;
    BIG_INT                     bytes_recovered, total_bytes;
    DSTRING                     filename;


    Message->DisplayMsg(MSG_CHK_NTFS_VERIFYING_FILE_DATA, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 4, 5);

    n = Mft->GetDataAttribute()->QueryValueLength().GetLowPart() / Mft->QueryFrsSize();

    n -= FIRST_USER_FILE_NUMBER;

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    for (i = 0; i < n; i++) {

        if (Mft->GetMftBitmap()->IsFree(i + FIRST_USER_FILE_NUMBER, 1)) {
            continue;
        }

        if (!frs.Initialize(i + FIRST_USER_FILE_NUMBER, Mft) ||
            !frs.Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.IsBase()) {
            continue;
        }

        if (frs.RecoverFile(Mft->GetVolumeBitmap(),
                            BadClusters,
                            VolumeMajorVersion,
                            &num_bad,
                            &bytes_recovered,
                            &total_bytes)) {

            if (bytes_recovered < total_bytes) {

                frs.Backtrack(&filename);

                Message->DisplayMsg(MSG_CHK_BAD_CLUSTERS_IN_FILE_SUCCESS,
                                    "%d%W", frs.QueryFileNumber().GetLowPart(),
                                    filename.QueryString());
            }
        } else {

            frs.Backtrack(&filename);

            Message->DisplayMsg(MSG_CHK_BAD_CLUSTERS_IN_FILE_FAILURE,
                                "%d%W", frs.QueryFileNumber().GetLowPart(),
                                filename.QueryString());
        }

        if (i*100/n > percent_done) {
            percent_done = i*100/n;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }
    }

    percent_done = 100;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_NTFS_VERIFYING_FILE_DATA_COMPLETED, PROGRESS_MESSAGE);

    return TRUE;
}


BOOLEAN
RecoverFreeSpace(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine verifies all of the unused clusters on the disk.
    It adds any that are bad to the given bad cluster list.

Arguments:

    Mft         - Supplies the master file table.
    BadClusters - Supplies the current list of bad clusters.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PLOG_IO_DP_DRIVE    drive;
    PNTFS_BITMAP        bitmap;
    BIG_INT             i, len, max_len;
    ULONG               percent_done;
    BIG_INT             checked, total_to_check;
    NUMBER_SET          bad_sectors;
    ULONG               cluster_factor;
    BIG_INT             start, run_length, next;
    ULONG               j;

    Message->DisplayMsg(MSG_CHK_NTFS_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 5, 5);

    drive = Mft->GetDataAttribute()->GetDrive();
    bitmap = Mft->GetVolumeBitmap();
    cluster_factor = Mft->QueryClusterFactor();
    max_len = bitmap->QuerySize()/20 + 1;
    total_to_check = bitmap->QueryFreeClusters();
    checked = 0;

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    for (i = 0; i < bitmap->QuerySize(); i += 1) {

        for (len = 0; i + len < bitmap->QuerySize() &&
                      bitmap->IsFree(i + len, 1) &&
                      len < max_len; len += 1) {
        }

        if (len > 0) {

            if (!bad_sectors.Initialize() ||
                !drive->Verify(i*cluster_factor,
                               len*cluster_factor,
                               &bad_sectors)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            for (j = 0; j < bad_sectors.QueryNumDisjointRanges(); j++) {

                bad_sectors.QueryDisjointRange(j, &start, &run_length);
                next = start + run_length;

                // Adjust start and next to be on cluster boundaries.
                start = start/cluster_factor;
                next = (next - 1)/cluster_factor + 1;

                // Add the bad clusters to the bad cluster list.
                if (!BadClusters->Add(start, next - start)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                // Mark the bad clusters as allocated in the bitmap.
                bitmap->SetAllocated(start, next - start);
            }

            checked += len;
            i += len - 1;

            if (100*checked/total_to_check > percent_done) {
                percent_done = (100*checked/total_to_check).GetLowPart();
                if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                    return FALSE;
                }
            }
        }
    }

    percent_done = 100;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_DONE_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);

    return TRUE;
}

#endif // _SETUP_LOADER_


BOOLEAN
NTFS_SA::DumpMessagesToFile(
    IN      PCWSTRING                   FileName,
    IN OUT  PNTFS_MFT_FILE              MftFile,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This function dumps the logged messages remembered by the
    message object into a file in the root directory.

Arguments:

    FileName        --  Supplies the (unqualified) name of the file.
    MftFile         --  Supplies an initialized, active Mft File object
                        for the volume.
    RootIndex       --  Supplies the root index for the volume
    RootIndexFile   --  Supplies the FRS for the root index file.

Return Value:

    TRUE upon successful completion.

--*/
{
    BYTE                        FileNameBuffer[NTFS_MAX_FILE_NAME_LENGTH * sizeof(WCHAR) + sizeof(FILE_NAME)];
    HMEM                        LoggedMessageMem;
    ULONG                       MessageDataLength;
    NTFS_FILE_RECORD_SEGMENT    TargetFrs;
    NTFS_INDEX_TREE             RootIndex;
    NTFS_FILE_RECORD_SEGMENT    RootIndexFrs;
    NTFS_ATTRIBUTE              DataAttribute;
    STANDARD_INFORMATION        StandardInformation;
    MFT_SEGMENT_REFERENCE       FileReference;
    PNTFS_MASTER_FILE_TABLE     Mft = MftFile->GetMasterFileTable();
    PFILE_NAME                  SearchName = (PFILE_NAME)FileNameBuffer;
    VCN                         FileNumber;
    DSTRING                     FileNameIndexName;
    ULONG                       BytesWritten;
    BOOLEAN                     InternalError;

    ULONG                       sys_space_needed;
    ULONG                       data_space_needed;
    BIG_INT                     free_clusters;
    ULONG                       space_remained;
    ULONG                       cluster_size;

    if( Mft == NULL ) {

        return FALSE;
    }

    // Fetch the messages.
    //
    if( !LoggedMessageMem.Initialize() ||
        !Message->QueryPackedLog( &LoggedMessageMem, &MessageDataLength ) ) {

        DebugPrintTrace(("UNTFS: can't collect logged messages.\n"));
        return FALSE;
    }

    // estimate the amount of space needed

    cluster_size = MftFile->GetDrive()->QuerySectorSize() * MftFile->QueryClusterFactor();

    // system space
    sys_space_needed = (Mft->QueryFrsSize() - 1)/cluster_size + 1;
    sys_space_needed += (SMALL_INDEX_BUFFER_SIZE - 1)/cluster_size + 1;

    // data space
    data_space_needed = (MessageDataLength - 1)/cluster_size + 1;

    free_clusters = Mft->GetVolumeBitmap()->QueryFreeClusters();
    if ((sys_space_needed+data_space_needed) > free_clusters) {

        DebugAssert(free_clusters.GetHighPart() == 0);
        space_remained = (free_clusters.GetLowPart() - sys_space_needed) * cluster_size;

        if (sys_space_needed >= free_clusters || MessageDataLength <= space_remained) {
            DebugPrintTrace(("UNTFS: Out of space to write BOOTEX.LOG\n"));
            Message->DisplayMsg(MSG_CHK_OUTPUT_LOG_ERROR);
            return FALSE;
        }

        // clip the output
        MessageDataLength = space_remained;
    }

    // Fetch the volume's root index:
    //
    if( !RootIndexFrs.Initialize( ROOT_FILE_NAME_INDEX_NUMBER, MftFile ) ||
        !RootIndexFrs.Read() ||
        !FileNameIndexName.Initialize( FileNameIndexNameData ) ||
        !RootIndex.Initialize( MftFile->GetDrive(),
                               MftFile->QueryClusterFactor(),
                               Mft->GetVolumeBitmap(),
                               MftFile->GetUpcaseTable(),
                               MftFile->QuerySize()/2,
                               &RootIndexFrs,
                               &FileNameIndexName ) ) {

        return FALSE;
    }

    memset( FileNameBuffer, 0, sizeof(FileNameBuffer) );

    SearchName->ParentDirectory = RootIndexFrs.QuerySegmentReference();
    SearchName->FileNameLength = (UCHAR)FileName->QueryChCount();
    SearchName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    if( !FileName->QueryWSTR( 0, TO_END,
                              NtfsFileNameGetName( SearchName ),
                              NTFS_MAX_FILE_NAME_LENGTH ) ) {

        DebugPrintTrace(("UNTFS: log file name is too long.\n"));
        return FALSE;
    }

    DebugPrintTrace(("UNTFS: Searching for BOOTEX.LOG\n"));

    if( RootIndex.QueryFileReference( NtfsFileNameGetLength( SearchName ),
                                      SearchName,
                                      0,
                                      &FileReference,
                                      &InternalError ) ) {

        DebugPrintTrace(("UNTFS: BOOTEX.LOG found.\n"));

        FileNumber.Set( FileReference.LowPart, (LONG) FileReference.HighPart );

        if( !TargetFrs.Initialize( FileNumber, Mft )    ||
            !TargetFrs.Read()                           ||
            !(FileReference == TargetFrs.QuerySegmentReference()) ||
            !TargetFrs.QueryAttribute( &DataAttribute,
                                       &InternalError,
                                       $DATA ) ) {

            // Either we were unable to initialize and read this FRS,
            // or its segment reference didn't match (ie. the sequence
            // number is wrong) or it didn't have a $DATA attribute
            // (i.e. it's a directory or corrupt).

            return FALSE;
        }

    } else if( InternalError ) {

        DebugPrintTrace(("UNTFS: Error searching for BOOTEX.LOG.\n"));
        return FALSE;

    } else {

        LARGE_INTEGER SystemTime;

        // This file does not exist--create it.
        //
        DebugPrintTrace(("UNTFS: BOOTEX.LOG not found.\n"));

        memset( &StandardInformation, 0, sizeof(StandardInformation) );

        IFS_SYSTEM::QueryNtfsTime( &SystemTime );

        StandardInformation.CreationTime =
            StandardInformation.LastModificationTime =
            StandardInformation.LastChangeTime =
            StandardInformation.LastAccessTime = SystemTime;

        if( !Mft->AllocateFileRecordSegment( &FileNumber, FALSE )   ||
            !TargetFrs.Initialize( FileNumber, Mft )                ||
            !TargetFrs.Create( &StandardInformation )               ||
            !TargetFrs.AddFileNameAttribute( SearchName )           ||
            !TargetFrs.AddSecurityDescriptor( NoAclCannedSd,
                                              Mft->GetVolumeBitmap() )  ||
            !RootIndex.InsertEntry( NtfsFileNameGetLength( SearchName ),
                                    SearchName,
                                    TargetFrs.QuerySegmentReference() ) ) {

            DebugPrintTrace(("UNTFS: Can't create BOOTEX.LOG\n"));
            return FALSE;
        }

        if( !DataAttribute.Initialize( MftFile->GetDrive(),
                                       MftFile->QueryClusterFactor(),
                                       NULL,
                                       0,
                                       $DATA ) ) {

            return FALSE;
        }
    }

    if( !DataAttribute.Write( LoggedMessageMem.GetBuf(),
                              DataAttribute.QueryValueLength(),
                              MessageDataLength,
                              &BytesWritten,
                              Mft->GetVolumeBitmap() ) ) {

        DebugPrintTrace(("UNTFS: Can't write logged message.\n"));
        return FALSE;
    }

    if( !DataAttribute.InsertIntoFile( &TargetFrs, Mft->GetVolumeBitmap() ) ) {

        // Insert failed--if it's resident, make it non-resident and
        // try again.
        //
        if( !DataAttribute.IsResident() ||
            !DataAttribute.MakeNonresident( Mft->GetVolumeBitmap() ) ||
            !DataAttribute.InsertIntoFile( &TargetFrs,
                                           Mft->GetVolumeBitmap() ) ) {

            DebugPrintTrace(("UNTFS: Can't save BOOTEX.LOG's data attribute.\n"));
            return FALSE;
        }
    }

    if( !TargetFrs.Flush( Mft->GetVolumeBitmap(), &RootIndex ) ) {

        DebugPrintTrace(("UNTFS: Can't flush BOOTEX.LOG.\n"));
        return FALSE;
    }

    if( !RootIndex.Save( &RootIndexFrs ) ||
        !RootIndexFrs.Flush( NULL ) ) {

        DebugPrintTrace(("UNTFS: Can't flush root index after logging messages.\n"));
        return FALSE;
    }

    MftFile->Flush();
    return TRUE;
}




BOOLEAN
NTFS_SA::VerifyAndFix(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       DesiredLogFileSize,
    IN      USHORT      Algorithm,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine verifies and, if necessary, fixes an NTFS volume.

Arguments:

    FixLevel            - Supplies the level of fixes that may be performed on
                            the disk.
    Message             - Supplies an outlet for messages.
    Flags               - Supplies flags to control behavior of chkdsk
                          (see ulib\inc\ifsentry.hxx for details)
    DesiredLogFileSize  - Supplies the desired logfile size in bytes, or 0 if
                            the logfile is to be resized to the default size.
    Algorithm           - Supplies the algorithm to use for index verification
    ExitStatus          - Returns an indication of how the checking went
    DriveLetter         - For autocheck, the letter for the volume we're checking

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_BITMAP                         mft_bitmap;
    NTFS_BITMAP                         volume_bitmap;
    NTFS_UPCASE_TABLE                   upcase_table;
    NTFS_ATTRIBUTE                      mft_data;
    BIG_INT                             num_frs, num_mft_bits;
    BIG_INT                             volume_clusters;
    NTFS_ATTRIBUTE_COLUMNS              attribute_def_table;
    NTFS_FRS_STRUCTURE                  frsstruc;
    HMEM                                hmem;
    VCN                                 i;
    NUMBER_SET                          bad_clusters;
    NTFS_MASTER_FILE_TABLE              internal_mft;
    NTFS_MFT_FILE                       mft_file;
    NTFS_REFLECTED_MASTER_FILE_TABLE    mft_ref;
    NTFS_ATTRIBUTE_DEFINITION_TABLE     attr_def_file;
    NTFS_BOOT_FILE                      boot_file;
    NTFS_UPCASE_FILE                    upcase_file;
    NTFS_LOG_FILE                       log_file;
    NTFS_BAD_CLUSTER_FILE               bad_clus_file;
    NTFS_FILE_RECORD_SEGMENT            root_file;
    NTFS_INDEX_TREE                     root_index;
    VCN                                 child_file_number;
    NTFS_CHKDSK_REPORT                  chkdsk_report;
    NTFS_CHKDSK_INFO                    chkdsk_info;
    BIG_INT                             disk_size;
    BIG_INT                             free_clusters;
    BIG_INT                             cluster_count;
    ULONG                               cluster_size;
    BIG_INT                             tmp_size;
    DIGRAPH                             directory_digraph;
    BOOLEAN                             corrupt_volume;
    USHORT                              volume_flags;
    BOOLEAN                             volume_is_dirty;
    BOOLEAN                             resize_log_file;
    MFT_SEGMENT_REFERENCE               seg_ref;
    ULONG                               entry_index;
    BOOLEAN                             disk_errors_found = FALSE;
    DSTRING                             index_name;
    UCHAR                               major, minor;
    ULONG                               num_boot_clusters;
    BIG_INT                             LsnResetThreshhold;
    PREAD_CACHE                         read_cache = NULL;
    BOOLEAN                             changes = FALSE;
    BOOLEAN                             RefrainFromResizing = FALSE;
    BOOLEAN                             bitmap_growable;
    ULONG                               errFixedStatus = CHKDSK_EXIT_SUCCESS;
    DSTRING                             label;
    NTFS_CHKDSK_INTERNAL_INFO           chkdsk_internal_info;
    LARGE_INTEGER                       temp_time;

    BOOLEAN       Verbose = (Flags & CHKDSK_VERBOSE) ? TRUE : FALSE;
    BOOLEAN       OnlyIfDirty = (Flags & CHKDSK_CHECK_IF_DIRTY) ? TRUE : FALSE;
//    BOOLEAN       EnableUpgrade = (Flags & CHKDSK_ENABLE_UPGRADE) ? TRUE : FALSE;
//    BOOLEAN       EnableDowngrade = FALSE;
    BOOLEAN       RecoverFree = (Flags & CHKDSK_RECOVER_FREE_SPACE) ? TRUE : FALSE;
    BOOLEAN       RecoverAlloc = (Flags & CHKDSK_RECOVER_ALLOC_SPACE) ? TRUE : FALSE;
    BOOLEAN       ResizeLogFile = (Flags & CHKDSK_RESIZE_LOGFILE) ? TRUE : FALSE;
    BOOLEAN       SkipIndexScan = (Flags & CHKDSK_SKIP_INDEX_SCAN) ? TRUE : FALSE;
    BOOLEAN       SkipCycleScan = (Flags & CHKDSK_SKIP_CYCLE_SCAN) ? TRUE : FALSE;
    BOOLEAN       AlgorithmSpecified = (Flags & CHKDSK_ALGORITHM_SPECIFIED) ? TRUE : FALSE;

#if defined(TIMING_ANALYSIS)
    LARGE_INTEGER                       temp_time2;
#endif

#if !defined(_AUTOCHECK_)
    STATIC LONG   NtfsChkdskIsRunning = 0;
#endif

    //
    // When TRUE is returned, CHKDSK_EXIT_SUCCESS will be the
    // default.  When FALSE is returned, the default will be
    // CHKDSK_EXIT_COULD_NOT_CHK.
    //

    if (NULL == ExitStatus) {
        ExitStatus = &chkdsk_info.ExitStatus;
    }
    *ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
    chkdsk_info.ExitStatus = CHKDSK_EXIT_SUCCESS;

#if !defined(_AUTOCHECK_)
    if (InterlockedCompareExchange(&NtfsChkdskIsRunning, 1, 0) != 0) {
        Message->DisplayMsg(MSG_CHK_NO_MULTI_THREAD);
        return FALSE;
    }
#endif

    memset(&chkdsk_internal_info, 0, sizeof(NTFS_CHKDSK_INTERNAL_INFO));

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTotalTime);

    SetNumberOfStages(3 + (RecoverFree ? 1 : 0) + (RecoverAlloc ? 1 : 0));

    if (SetupSpecial == FixLevel) {

        //
        // The "SetupSpecial" fixlevel is used only when the volume
        // is ntfs and the /s flag is passed to autochk.  It means that
        // we should not bother to resize the logfile, since setup
        // doesn't want to reboot the system for that.
        //

        RefrainFromResizing = TRUE;
        FixLevel = TotalFix;
    }

#if 0
    if (EnableDowngrade && EnableUpgrade) {
        EnableDowngrade = EnableUpgrade = FALSE;
    }
#endif

    // Try to enable caching, if there's not enough resources then
    // just run without a cache.  Make the cache 64K.

    if ((read_cache = NEW READ_CACHE) &&
        read_cache->Initialize(_drive, MFT_PRIME_SIZE/_drive->QuerySectorSize())) {

        _drive->SetCache(read_cache);

    } else {
        DELETE(read_cache);
        read_cache = NULL;
    }

    chkdsk_info.Verbose = Verbose;

    volume_flags = QueryVolumeFlagsAndLabel(&corrupt_volume, &major, &minor, &label);
    volume_is_dirty = (volume_flags & VOLUME_DIRTY) ? TRUE : FALSE;
    if (!ResizeLogFile)
        DesiredLogFileSize = 0;
    resize_log_file = (volume_flags & VOLUME_RESIZE_LOG_FILE) || ResizeLogFile;

    if (corrupt_volume) {
        Message->DisplayMsg(MSG_NTFS_CHK_NOT_NTFS);
        return FALSE;
    }

    if (major > 3) {
        Message->DisplayMsg(MSG_CHK_NTFS_WRONG_VERSION);
        return FALSE;
    }

    if ((volume_flags & VOLUME_DELETE_USN_UNDERWAY) && FixLevel == CheckOnly) {
        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_USNJRNL_UNDERWAY);
        return FALSE;
    }

    SetVersionNumber( major, minor );

    if (label.QueryChCount()) {
        Message->DisplayMsg(MSG_CHK_NTFS_VOLUME_LABEL,
                            "%W", &label);
    }

    // If default autochk and the volume is not dirty then
    //    do minimal and return
    // Alternatively, if it's a user requested autochk and
    //    it has been executed previously, do minimal and return

#if defined(USE_CHKDSK_BIT)
    if ((OnlyIfDirty && !volume_is_dirty)
#if defined(_AUTOCHECK_)
        // only autochk should see this flag set
        // if chkdsk sees it, it should clear it
        ||
        (!volume_is_dirty &&
         (volume_flags & VOLUME_CHKDSK_RAN_ONCE) &&
         !Message->IsInSetup())
#endif
        ) {
#else
    if (OnlyIfDirty && !volume_is_dirty) {
#endif
        Message->DisplayMsg(MSG_CHK_VOLUME_CLEAN);

        // If the volume version number is 1.2 or greater, check
        // the log file size.
        //
        if (!RefrainFromResizing &&
            FixLevel != CheckOnly &&
            (major > 1 || (major == 1 && minor >= 2))) {

            if (!ResizeCleanLogFile( Message, ResizeLogFile, DesiredLogFileSize )) {

                Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED);
            }
        }

#if 0
        if (EnableUpgrade && FixLevel != CheckOnly) {
            if (!SetVolumeFlag(VOLUME_UPGRADE_ON_MOUNT, &corrupt_volume) ||
                corrupt_volume) {
                Message->DisplayMsg(MSG_CHKNTFS_NOT_ENABLE_UPGRADE,
                                    "%W", DriveLetter);
            }
        }
#endif

#if defined(USE_CHKDSK_BIT)
        if (volume_flags & VOLUME_CHKDSK_RAN_ONCE) {

            BIG_INT BigZero = 0;

            DebugPrintTrace(("UNTFS: Clearing chkdsk ran once flag\n"));

            if (!ClearVolumeFlag(VOLUME_CHKDSK_RAN_ONCE,
                                 NULL,
                                 FALSE,
                                 BigZero.GetLargeInteger(),
                                 &corrupt_volume,
                                 TRUE) ||
                corrupt_volume) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANNOT_CLEAR_VOLUME_CHKDSK_RAN_ONCE_FLAG);
            }
        }
#endif

        Message->SetLoggingEnabled(FALSE);

        *ExitStatus = CHKDSK_EXIT_SUCCESS;

        return TRUE;
    }

    if (FixLevel == CheckOnly) {
        Message->DisplayMsg(MSG_CHK_NTFS_READ_ONLY_MODE, NORMAL_MESSAGE, TEXT_MESSAGE);
    } else {

        //
        // The volume is not clean, so if we're autochecking we want to
        // make sure that we're printing real messages on the console
        // instead of just dots.
        //

#if defined( _AUTOCHECK_ )

        if (Message->SetDotsOnly(FALSE)) {

            Message->SetLoggingEnabled(FALSE);
            if (NULL != DriveLetter) {

                Message->DisplayMsg(MSG_CHK_RUNNING,
                                    "%W", DriveLetter);
            }

            Message->DisplayMsg(MSG_FILE_SYSTEM_TYPE,
                                "%ws", L"NTFS");

            if (label.QueryChCount()) {
                Message->DisplayMsg(MSG_CHK_NTFS_VOLUME_LABEL,
                                    "%W", &label);
            }
            Message->SetLoggingEnabled();
        }

#endif /* _AUTOCHECK_ */

    }

    if (SkipIndexScan || SkipCycleScan) {
        Message->DisplayMsg(MSG_BLANK_LINE);
        if (SkipIndexScan) {
            Message->DisplayMsg(MSG_CHK_NTFS_SKIP_INDEX_SCAN);
        }
        if (SkipCycleScan) {
            Message->DisplayMsg(MSG_CHK_NTFS_SKIP_CYCLE_SCAN);
        }
        Message->DisplayMsg(MSG_CHK_NTFS_SKIP_SCAN_WARNING );
    }

#if defined( _AUTOCHECK_ )

    if (Message->IsInAutoChk()) { // if in normal autochk

        ULONG   timeout;

        if (!VOL_LIODPDRV::QueryAutochkTimeOut(&timeout)) {
            timeout = AUTOCHK_TIMEOUT;
        }

        if (timeout > MAX_AUTOCHK_TIMEOUT_VALUE)
            timeout = AUTOCHK_TIMEOUT;

        if (timeout != 0) {

            MSGID   msgid;

            // leave logging on so that the user will know if
            // chkdsk invocation is due to dirty drive
            if (volume_is_dirty)
                msgid = MSG_CHK_AUTOCHK_SKIP_WARNING;
            else
                msgid = MSG_CHK_USER_AUTOCHK_SKIP_WARNING;
            Message->DisplayMsg(msgid);
            if (Message->IsKeyPressed(MSG_CHK_ABORT_AUTOCHK, timeout)) {
                Message->SetLoggingEnabled(FALSE);
                Message->DisplayMsg(MSG_CHK_AUTOCHK_ABORTED);
                *ExitStatus = CHKDSK_EXIT_SUCCESS;
                return TRUE;
            } else {
                Message->DisplayMsg(MSG_CHK_AUTOCHK_RESUMED);
            }
        } else if (volume_is_dirty) {
            Message->DisplayMsg(MSG_CHK_VOLUME_IS_DIRTY);
        }
    } else {
        DebugAssert(Message->IsInSetup());
        if (volume_is_dirty) {
            Message->DisplayMsg(MSG_CHK_VOLUME_IS_DIRTY);
        }
    }

#endif  // _AUTOCHECK_

    memset(&chkdsk_report, 0, sizeof(NTFS_CHKDSK_REPORT));


    // Set the 'LargestLsnEncountered' variable to the smallest
    // possible LSN value.

    LargestLsnEncountered.LowPart = 0;
    LargestLsnEncountered.HighPart = MINLONG;


    // Set the 'LargestUsnEncountered' variable to the smallest
    // possible USN value.

    LargestUsnEncountered.LowPart = 0;
    LargestUsnEncountered.HighPart = 0;
    FrsOfLargestUsnEncountered = 0;

    // Fetch the MFT's $DATA attribute.

    if (!FetchMftDataAttribute(Message, &mft_data)) {
        return FALSE;
    }

    // Now make sure that the first four FRS of the MFT are readable,
    // contiguous, and not too corrupt.

    if (!ValidateCriticalFrs(&mft_data, Message, FixLevel)) {
        return FALSE;
    }


    // Compute the number of file record segments and the number of volume
    // clusters on disk.

    mft_data.QueryValueLength(&num_frs, &num_mft_bits);

    num_frs = num_frs / QueryFrsSize();

    num_mft_bits = num_mft_bits / QueryFrsSize();

    if (num_frs.GetHighPart() != 0) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        Message->LogMsg(MSG_CHKLOG_NTFS_TOO_MANY_FILES,
                     "%I64x", num_frs.GetLargeInteger());
        return FALSE;
    }

    volume_clusters = QueryVolumeSectors()/((ULONG) QueryClusterFactor());

    // Initialize the internal MFT bitmap, volume bitmap, and unreadable
    // file record segments.
    //

    num_boot_clusters = max(1, BYTES_PER_BOOT_SECTOR/
                               (_drive->QuerySectorSize()*
                                QueryClusterFactor()));

#if defined(_AUTOCHECK_)
    SYSTEM_PERFORMANCE_INFORMATION  perf_info;
    NTSTATUS                        status;

    status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &perf_info,
                                      sizeof(perf_info),
                                      NULL);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("UNTFS: NtQuerySystemInformation(SystemPerformanceInformation) failed (%x)\n", status));
        return FALSE;
    }

    chkdsk_info.AvailablePages = perf_info.AvailablePages;
#endif

    DebugAssert(num_frs.GetHighPart() == 0);
    chkdsk_info.major = major;
    chkdsk_info.minor = minor;
    chkdsk_info.QuotaFileNumber = 0;
    chkdsk_info.ObjectIdFileNumber = 0;
    chkdsk_info.UsnJournalFileNumber = 0;
    chkdsk_info.ReparseFileNumber = 0;
    chkdsk_info.NumFiles = num_frs.GetLowPart();
    chkdsk_info.BaseFrsCount = 0;
    chkdsk_info.TotalNumFileNames = 0;
    chkdsk_info.CrossLinkYet = FALSE;
    chkdsk_info.CrossLinkStart = (volume_clusters/2).GetLowPart();
    chkdsk_info.CrossLinkLength = num_boot_clusters;
    chkdsk_info.CountFilesWithIndices = 0;

    bitmap_growable = /* MJB _drive->QuerySectors() != QueryVolumeSectors() */ FALSE;

    if (!mft_bitmap.Initialize(num_mft_bits, TRUE) ||
        !volume_bitmap.Initialize(volume_clusters, bitmap_growable, _drive,
            QueryClusterFactor()) ||
        !(chkdsk_info.NumFileNames = NEW USHORT[chkdsk_info.NumFiles]) ||
        !(chkdsk_info.ReferenceCount = NEW SHORT[chkdsk_info.NumFiles]) ||
        !chkdsk_info.FilesWithIndices.Initialize(num_frs, TRUE) ||
        !chkdsk_info.FilesWithEas.Initialize() ||
        !chkdsk_info.ChildFrs.Initialize() ||
        !chkdsk_info.BadFiles.Initialize() ||
        !chkdsk_info.FilesWhoNeedData.Initialize(num_frs, FALSE) ||
        !chkdsk_info.FilesWithNoReferences.Initialize() ||
        !chkdsk_info.FilesWithTooManyFileNames.Initialize() ||
        !chkdsk_info.FilesWithObjectId.Initialize() ||
        !chkdsk_info.FilesWithReparsePoint.Initialize(num_frs, FALSE)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    memset(chkdsk_info.NumFileNames, 0, chkdsk_info.NumFiles*sizeof(USHORT));
    memset(chkdsk_info.ReferenceCount, 0, chkdsk_info.NumFiles*sizeof(USHORT));


    // Mark as allocated on the bitmap, the clusters reserved
    // for the boot file.
    //

    volume_bitmap.SetAllocated(0, num_boot_clusters);

    // If the volume size is smaller than the partition size, we figure that
    // the replica boot sector is at the end of the partition.  Otherwise we
    // figure it must be in the middle.
    //

    if (QueryVolumeSectors() == _drive->QuerySectors()) {
        volume_bitmap.SetAllocated(volume_clusters/2, num_boot_clusters);
    }

    // Fetch the attribute definition table.

    if (!FetchAttributeDefinitionTable(&mft_data,
                                       Message,
                                       &attribute_def_table)) {
        return FALSE;
    }

    // Fetch the upcase table.

    if (!FetchUpcaseTable(&mft_data, Message, &upcase_table)) {
        return FALSE;
    }

    if (!hmem.Initialize()) {
        return FALSE;
    }

    // Verify and fix all of the file record segments.

    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (!StartProcessingFiles(num_frs,
                              &disk_errors_found,
                              FixLevel,
                              &mft_data,
                              &mft_bitmap,
                              &volume_bitmap,
                              &upcase_table,
                              &attribute_def_table,
                              &chkdsk_report,
                              &chkdsk_info,
                              Message))
        return FALSE;

#if defined(LOCATE_DELETED_FILE)
    return FALSE;
#endif

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForFileVerification);
    chkdsk_internal_info.ElapsedTimeForFileVerification.QuadPart -= temp_time.QuadPart;

#if defined(TIMING_ANALYSIS)
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%I64d", "Stage 1 in ticks: ",
                        chkdsk_internal_info.ElapsedTimeForFileVerification);
#endif

    chkdsk_internal_info.TotalFrsCount = num_frs.GetLowPart();
    chkdsk_internal_info.BaseFrsCount = chkdsk_info.BaseFrsCount;
    chkdsk_internal_info.TotalNumFileNames = chkdsk_info.TotalNumFileNames;
    chkdsk_internal_info.FilesWithObjectId =
        chkdsk_info.FilesWithObjectId.QueryCardinality().GetLowPart();
    chkdsk_internal_info.FilesWithReparsePoint =
        (num_frs - chkdsk_info.FilesWithReparsePoint.QueryFreeClusters()).GetLowPart();

    // Compute the files that have too many file-names.

    for (i = 0; i < chkdsk_info.NumFiles; i += 1) {
        if (chkdsk_info.NumFileNames[i.GetLowPart()] > 500) {
            if (!chkdsk_info.FilesWithTooManyFileNames.Add(i)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_FILE_NAMES,
                                "%d", i.GetLowPart());
        }
    }


    // Clean up orphan file record segments.

    while (chkdsk_info.ChildFrs.QueryCardinality() > 0) {

        child_file_number = chkdsk_info.ChildFrs.QueryNumber(0);

        if (mft_bitmap.IsFree(child_file_number, 1)) {

            Message->DisplayMsg(MSG_CHK_NTFS_ORPHAN_FRS,
                                "%d", child_file_number.GetLowPart());

            disk_errors_found = TRUE;

            if (!frsstruc.Initialize(&hmem,
                                     &mft_data,
                                     child_file_number,
                                     QueryClusterFactor(),
                                     QueryVolumeSectors(),
                                     QueryFrsSize(),
                                     &upcase_table)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frsstruc.Read()) {

                DebugAssert("previously readable frs is now unreadable");
                return FALSE;
            }

            frsstruc.ClearInUse();

            if (FixLevel != CheckOnly && !frsstruc.Write()) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", frsstruc.QueryFileNumber().GetLowPart());
                return FALSE;
            }
        }

        if (!chkdsk_info.ChildFrs.Remove(child_file_number)) {
            DebugAbort("Couldn't remove from the beginning of a num set.");
            return FALSE;
        }
    }

    if (disk_errors_found) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    if (disk_errors_found && FixLevel == CheckOnly) {
        Message->DisplayMsg(MSG_CHK_NTFS_ERRORS_FOUND);
        return FALSE;
    }


    mft_bitmap.SetAllocated(0, FIRST_USER_FILE_NUMBER);

    // Now the internal volume bitmap and internal MFT bitmap are in
    // ssync with the state of the disk.  We must insure that the
    // internal MFT data attribute, the internal MFT bitmap, the
    // internal volume bitmap, and the internal attribute definition table
    // are the same as the corresponding disk structures.

    // The first step is to hotfix all of the unreadable FRS in the
    // master file table.  We'll store bad cluster numbers in a
    // number set.

    if (!HotfixMftData(&mft_data, &volume_bitmap, &chkdsk_info.BadFiles,
                       &bad_clusters, FixLevel, Message)) {

        return FALSE;
    }

    if (!internal_mft.Initialize(&mft_data,
                                 &mft_bitmap,
                                 &volume_bitmap,
                                 &upcase_table,
                                 QueryClusterFactor(),
                                 QueryFrsSize(),
                                 _drive->QuerySectorSize(),
                                 QueryVolumeSectors(),
                                 FixLevel == CheckOnly)) {

        DebugAbort("Couldn't initialize the internal MFT.");
        return FALSE;
    }


    // Check to see if there's a file cross-linked with the boot
    // mirror and attempt to fix it by copying the data.

    if (!ResolveCrossLink(&chkdsk_info, &internal_mft, &bad_clusters,
                          FixLevel, Message)) {
        return FALSE;
    }


    // At this point, use the internal MFT to validate all of the
    // OS/2 EAs and NTFS indices.

#if defined(TIMING_ANALYSIS)
    IFS_SYSTEM::QueryNtfsTime(&temp_time);
#endif

    if (!ValidateEas(&chkdsk_info,
                     &chkdsk_report,
                     &internal_mft,
                     FixLevel, Message)) {
        return FALSE;
    }

#if defined(TIMING_ANALYSIS)
    IFS_SYSTEM::QueryNtfsTime(&temp_time2);
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%I64d", "ValidateEas time in ticks: ",
                        temp_time2.QuadPart - temp_time.QuadPart);
#endif

    // Make sure that all of the system files are marked in use.
    // (They are definitely marked in the MFT bitmap).  If they're
    // not then mark them for orphan recovery.

    if (!EnsureSystemFilesInUse(&chkdsk_info, &internal_mft,
                                FixLevel, Message)) {
        return FALSE;
    }

    //
    // Validate all Reparse Point attribute
    //

    if (!ValidateReparsePoint(&chkdsk_info,
                              &internal_mft,
                              FixLevel, Message)) {
        return FALSE;
    }


    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (!ValidateIndices(&chkdsk_info,
                         &directory_digraph,
                         &internal_mft,
                         &attribute_def_table,
                         &chkdsk_report,
                         &bad_clusters,
                         AlgorithmSpecified ? Algorithm : CHKDSK_ALGORITHM_NOT_SPECIFIED,
                         SkipIndexScan,
                         SkipCycleScan,
                         FixLevel, Message,
                         &disk_errors_found)) {

        return FALSE;
    }

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForIndexVerification);
    chkdsk_internal_info.ElapsedTimeForIndexVerification.QuadPart -= temp_time.QuadPart;

    if (disk_errors_found && FixLevel == CheckOnly) {
        Message->DisplayMsg(MSG_CHK_NTFS_ERRORS_FOUND);
        return FALSE;
    }


    // Now recover orphans into a nice directory.

    if (!RecoverOrphans(&chkdsk_info,
                        &chkdsk_report,
                        &directory_digraph,
                        &internal_mft,
                        SkipCycleScan,
                        FixLevel, Message)) {

        return FALSE;
    }

    DELETE(chkdsk_info.NumFileNames);
    DELETE(chkdsk_info.ReferenceCount);

    if (major >= 2) {
        if (!CheckExtendSystemFiles(&chkdsk_info, &chkdsk_report,
                                    &internal_mft, FixLevel, Message))
            return FALSE;
    }

    // Make sure that everyone's security descriptor is valid.

    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (!ValidateSecurityDescriptors(&chkdsk_info, &chkdsk_report, &internal_mft,
                                     &bad_clusters, SkipIndexScan, FixLevel,
                                     Message)) {
        return FALSE;
    }

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForSDVerification);
    chkdsk_internal_info.ElapsedTimeForSDVerification.QuadPart -= temp_time.QuadPart;
    chkdsk_internal_info.TotalNumSID = chkdsk_info.TotalNumSID;

    // Now make sure that everyone who should have an unnamed $DATA
    // attribute has one.

    if (!CheckAllForData(&chkdsk_info, &internal_mft, FixLevel, Message)) {

        return FALSE;
    }

    chkdsk_info.FilesWhoNeedData.~NTFS_BITMAP();

    // Make sure that all records in Usn Journal is valid

    if (major >= 2 &&
        !ValidateUsnJournal(&chkdsk_info, &chkdsk_report, &internal_mft,
                            &bad_clusters, FixLevel, Message)) {
        return FALSE;
    }

    // Verify all user file data if requested.

    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (RecoverAlloc && FixLevel != CheckOnly &&
        !RecoverAllUserFiles(major, &internal_mft, &bad_clusters, Message)) {

        return FALSE;
    }

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForUserSpaceVerification);
    chkdsk_internal_info.ElapsedTimeForUserSpaceVerification.QuadPart -= temp_time.QuadPart;

    // Verify all free space if requested.

    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (RecoverFree &&
        !RecoverFreeSpace(&internal_mft, &bad_clusters, Message)) {

        return FALSE;
    }

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForFreeSpaceVerification);
    chkdsk_internal_info.ElapsedTimeForFreeSpaceVerification.QuadPart -= temp_time.QuadPart;

    //
    // Take care of the remaining system files
    //

    if (!root_file.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, &internal_mft) ||
        !root_file.Read() ||
        !index_name.Initialize(FileNameIndexNameData) ||
        !root_index.Initialize(_drive, QueryClusterFactor(),
                               internal_mft.GetVolumeBitmap(),
                               internal_mft.GetUpcaseTable(),
                               root_file.QuerySize()/2,
                               &root_file, &index_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    // In this space Fix the MFT mirror, attribute definition table,
    // the boot file, the bad cluster file.

    if (!mft_ref.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!mft_ref.Read()) {
        DebugAbort("Can't read in hotfixed MFT reflection file.");
        return FALSE;
    }

    if (!mft_ref.VerifyAndFix(internal_mft.GetDataAttribute(),
                              internal_mft.GetVolumeBitmap(),
                              &bad_clusters,
                              &root_index,
                              &changes,
                              FixLevel,
                              Message)) {
        return FALSE;
    }

    if (mft_ref.QueryFirstLcn() != QueryMft2StartingLcn()) {

        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_MIRROR);
        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_STARTING_LCN,
                     "%I64x%I64x",
                     mft_ref.QueryFirstLcn().GetLargeInteger(),
                     QueryMft2StartingLcn().GetLargeInteger());

        DebugPrintTrace(("UNTFS: Bad Mirror LCN in boot sector.\n"));

        _boot_sector->Mft2StartLcn = mft_ref.QueryFirstLcn();
        changes = TRUE;
    }

    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    if (!attr_def_file.Initialize(&internal_mft, major)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!attr_def_file.Read()) {
        DebugAbort("Can't read in hotfixed attribute definition file.");
        return FALSE;
    }

    if (!attr_def_file.VerifyAndFix(&attribute_def_table,
                                    internal_mft.GetVolumeBitmap(),
                                    &bad_clusters,
                                    &root_index,
                                    &changes,
                                    FixLevel,
                                    Message)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    if (!boot_file.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!boot_file.Read()) {
        DebugAbort("Can't read in hotfixed boot file.");
        return FALSE;
    }

    if (!boot_file.VerifyAndFix(internal_mft.GetVolumeBitmap(),
                                &root_index,
                                &changes,
                                FixLevel,
                                Message)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    if (!upcase_file.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!upcase_file.Read()) {
        DebugAbort("Can't read in hotfixed upcase file.");
        return FALSE;
    }

    if (!upcase_file.VerifyAndFix(&upcase_table,
                                  internal_mft.GetVolumeBitmap(),
                                  &bad_clusters,
                                  &root_index,
                                  &changes,
                                  FixLevel,
                                  Message)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    // check out the bad cluster file before the log file
    // as the log file may add bad clusters directly into
    // the bad cluster file

    if (!bad_clus_file.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!bad_clus_file.Read()) {
        DebugAbort("Can't read in hotfixed bad cluster file.");
        return FALSE;
    }

    if (!bad_clus_file.VerifyAndFix(internal_mft.GetVolumeBitmap(),
                                    &root_index,
                                    &changes,
                                    FixLevel,
                                    Message)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    internal_mft.GetMftBitmap()->SetAllocated(BAD_CLUSTER_FILE_NUMBER, 1);

    if (!log_file.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!log_file.Read()) {
        DebugAbort("Can't read in hotfixed log file.");
        return FALSE;
    }

    if (!log_file.VerifyAndFix(internal_mft.GetVolumeBitmap(),
                               &root_index,
                               &changes,
                               &chkdsk_report,
                               FixLevel,
                               resize_log_file,
                               DesiredLogFileSize,
                               &bad_clusters,
                               Message)) {

        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    if (bad_clusters.QueryCardinality() != 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_ADDING_BAD_CLUSTERS,
                            "%d", bad_clusters.QueryCardinality().GetLowPart());

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (bad_clus_file.Add(&bad_clusters)) {

            if (FixLevel != CheckOnly &&
                !bad_clus_file.Flush(internal_mft.GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_BAD_FILE);
                return FALSE;
            }

        } else {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_ADD_BAD_CLUSTERS);
            chkdsk_info.ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
        }
    }

    // If the largest LSN on the volume has exceeded the
    // tolerated threshhold, reset all LSN's on the volume
    // and clear the log file.
    //
    LsnResetThreshhold.Set( 0, LsnResetThreshholdHighPart );

    if (FixLevel != CheckOnly &&
        LargestLsnEncountered > LsnResetThreshhold) {

        // The largest LSN on the volume is beyond the tolerated
        // threshhold.  Set all the LSN's on the volume to zero.
        // Since the root index file is in memory, we have to
        // do it separately.
        //

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (!ResetLsns(Message, &internal_mft, TRUE)) {
            return FALSE;
        }

        root_file.SetLsn(0);

        if (!root_index.ResetLsns(Message)) {
            return FALSE;
        }

        LargestLsnEncountered.LowPart = 0;
        LargestLsnEncountered.HighPart = 0;

        // Now reset the Log File.  Note that resetting the log
        // file does not change its size, so the Log File FRS
        // won't need to be flushed.
        //
        if (!log_file.Initialize( &internal_mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!log_file.Read()) {
            DebugAbort("Can't read in hotfixed log file.");
            return FALSE;
        }

        if (!log_file.Reset(Message)) {
            return FALSE;
        }
    }

    // Mark the volume clean, clearing both the dirty bit,
    // the resize-log-file bit, and the chkdsk-ran-once bit.
    //
    if (FixLevel != CheckOnly &&
        !ClearVolumeFlag(VOLUME_DIRTY | VOLUME_RESIZE_LOG_FILE | VOLUME_CHKDSK_RAN_ONCE |
                         ((major >= 2) ? VOLUME_DELETE_USN_UNDERWAY | VOLUME_REPAIR_OBJECT_ID : 0),
                         &log_file, minor > 0 || major > 1,
                         LargestLsnEncountered, &corrupt_volume)) {

        DebugPrint("Could not set volume clean.\n");

        Message->DisplayMsg(corrupt_volume ? MSG_CHK_NTFS_BAD_MFT :
                                             MSG_CHK_NO_MEMORY);
        return FALSE;
    }

#if 0
    if (EnableUpgrade && FixLevel != CheckOnly) {
        if (!SetVolumeFlag(VOLUME_UPGRADE_ON_MOUNT, &corrupt_volume) ||
            corrupt_volume) {
            Message->DisplayMsg(MSG_CHKNTFS_NOT_ENABLE_UPGRADE,
                                "%W", DriveLetter);
            chkdsk_info.ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
        }
    }
#endif

    if ((chkdsk_info.ExitStatus || errFixedStatus) &&
        FixLevel != CheckOnly && major >= 2) {

        if (!MarkQuotaOutOfDate(&chkdsk_info, &internal_mft, FixLevel, Message)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANNOT_SET_QUOTA_FLAG_OUT_OF_DATE);
            return FALSE;
        }

        if (!SetVolumeFlag(VOLUME_CHKDSK_RAN, &corrupt_volume) ||
            corrupt_volume) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANNOT_SET_VOLUME_CHKDSK_RAN_FLAG);
            chkdsk_info.ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
        }
    }

#if 0

    // There is a bug in SynchronizeMft that in CheckOnly mode, it does
    // change the values of internal_mft.  This is undesirable.
    // If we ever do downgrade again, this bug must be fixed.

    if (!SynchronizeMft(&root_index, &internal_mft, &changes,
                        CheckOnly, Message, SuppressMessage)) {
        return FALSE;
    }

    if (EnableDowngrade &&
        !DownGradeNtfs(Message, &internal_mft, &chkdsk_info)) {
        return FALSE;
    }
#endif

    // Now fix the mft (both data, and bitmap), and the volume bitmap.
    // Write everything out to disk.

    if (!SynchronizeMft(&root_index, &internal_mft, &changes,
                        FixLevel, Message, CorrectMessage)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    // Now flush out the root index that was used in v+f of the critical
    // files.

    if (FixLevel != CheckOnly) {
        if (!root_index.Save(&root_file) ||
            !root_file.Flush(NULL)) {

            DebugPrint("Could not flush root index.\n");

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    // After synchronizing the MFT flush it out so that the MFT mirror
    // gets written.

    if (!mft_file.Initialize(_drive, QueryMftStartingLcn(),
                             QueryClusterFactor(), QueryFrsSize(),
                             QueryVolumeSectors(),
                             internal_mft.GetVolumeBitmap(),
                             internal_mft.GetUpcaseTable())) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (FixLevel != CheckOnly) {
        if (!mft_file.Read() || !mft_file.Flush() || !Write(Message)) {
            DebugAbort("Couldn't IO hotfixed MFT file.");
            return FALSE;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, &chkdsk_info);
    *ExitStatus = chkdsk_info.ExitStatus;

    switch (*ExitStatus) {
      case CHKDSK_EXIT_SUCCESS:
        Message->DisplayMsg(MSG_CHK_NO_PROBLEM_FOUND);
        break;

      case CHKDSK_EXIT_ERRS_FIXED:
        Message->DisplayMsg((FixLevel != CheckOnly) ? MSG_CHK_ERRORS_FIXED : MSG_CHK_NEED_F_PARAMETER);
        break;

      case CHKDSK_EXIT_COULD_NOT_CHK:
//    case CHKDSK_EXIT_ERRS_NOT_FIXED:
//    case CHKDSK_EXIT_COULD_NOT_FIX:
        Message->DisplayMsg(MSG_CHK_ERRORS_NOT_FIXED);
        break;

    }

#if defined(_AUTOCHECK_)
    if (_cleanup_that_requires_reboot) {
        // if it is not CHKDSK_EXIT_COULD_NOT_FIX then it can only be
        // CHKDSK_EXIT_ERRS_FIXED, CHKDSK_EXIT_SUCCESS, or CHKDSK_EXIT_MINOR_ERRS
        // so overwrite the not so important code with CHKDSK_EXIT_ERRS_FIXED
        if (*ExitStatus != CHKDSK_EXIT_COULD_NOT_FIX)
            *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;   // we want a reboot when called within textmode setup
    }
#endif

    IFS_SYSTEM::QueryNtfsTime(&temp_time);
    chkdsk_internal_info.ElapsedTotalTime.QuadPart = temp_time.QuadPart -
                                                     chkdsk_internal_info.ElapsedTotalTime.QuadPart;

    // Generate the chkdsk report.

    cluster_size = QueryClusterFactor()*_drive->QuerySectorSize();

    disk_size = _drive->QuerySectorSize()*QueryVolumeSectors();


    if (disk_size.GetHighPart() < 0x200)  {   // if >= 2TB
        Message->DisplayMsg(MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_KB,
                            "%10u", (disk_size/1024).GetLowPart());
    } else {
        Message->DisplayMsg(MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_MB,
                            "%10u", (disk_size/(1024*1024)).GetLowPart());
    }

    if (chkdsk_report.NumUserFiles != 0) {
        ULONG nfiles;

        nfiles = chkdsk_report.NumUserFiles.GetLowPart();
        if (chkdsk_report.BytesUserData.GetHighPart() < 0x200) {
            ULONG kbytes;

            kbytes = (chkdsk_report.BytesUserData/1024).GetLowPart();

            Message->DisplayMsg(MSG_CHK_NTFS_USER_FILES_IN_KB,
                                "%10u%u", kbytes, nfiles);
        } else {
            ULONG mbytes;

            mbytes = (chkdsk_report.BytesUserData/(1024*1024)).GetLowPart();

            Message->DisplayMsg(MSG_CHK_NTFS_USER_FILES_IN_MB,
                                "%10u%u", mbytes, nfiles);
        }
    }

    if (chkdsk_report.NumIndices != 0) {
        ULONG nindices;

        nindices = chkdsk_report.NumIndices.GetLowPart();

        if (chkdsk_report.BytesInIndices.GetHighPart() < 0x200) {
            ULONG kbytes;

            kbytes = (chkdsk_report.BytesInIndices/1024).GetLowPart();

            Message->DisplayMsg(MSG_CHK_NTFS_INDICES_REPORT_IN_KB,
                                "%10u%u", kbytes, nindices);

        } else {
            ULONG mbytes;

            mbytes = (chkdsk_report.BytesInIndices/(1024*1024)).GetLowPart();

            Message->DisplayMsg(MSG_CHK_NTFS_INDICES_REPORT_IN_MB,
                                "%10u%u", mbytes, nindices);
        }
    }

    tmp_size = bad_clus_file.QueryNumBad() * cluster_size;

    if (tmp_size.GetHighPart() < 0x200) {
        Message->DisplayMsg(MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB,
                            "%10u", (tmp_size/1024).GetLowPart());
    } else {
        Message->DisplayMsg(MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_MB,
                            "%10u", (tmp_size/(1024*1024)).GetLowPart());
    }

    free_clusters = internal_mft.GetVolumeBitmap()->QueryFreeClusters();

    tmp_size = disk_size - tmp_size -
                  free_clusters*cluster_size - chkdsk_report.BytesUserData -
                  chkdsk_report.BytesInIndices;

    if (tmp_size.GetHighPart() < 0x200) {
        Message->DisplayMsg(MSG_CHK_NTFS_SYSTEM_SPACE_IN_KB,
                            "%10u", (tmp_size/1024).GetLowPart());
    } else {
        Message->DisplayMsg(MSG_CHK_NTFS_SYSTEM_SPACE_IN_MB,
                            "%10u", (tmp_size/(1024*1024)).GetLowPart());
    }

    Message->DisplayMsg(MSG_CHK_NTFS_LOGFILE_SPACE,
                        "%10u", (chkdsk_report.BytesLogFile/1024).GetLowPart());

    tmp_size = free_clusters * cluster_size;

    if (tmp_size.GetHighPart() < 0x200) {
        Message->DisplayMsg(MSG_CHK_NTFS_AVAILABLE_SPACE_IN_KB,
                            "%10u", (tmp_size/1024).GetLowPart());
    } else {
        Message->DisplayMsg(MSG_CHK_NTFS_AVAILABLE_SPACE_IN_MB,
                            "%10u", (tmp_size/(1024*1024)).GetLowPart());
    }

    Message->DisplayMsg(MSG_BYTES_PER_ALLOCATION_UNIT, "%10u", cluster_size);

    Message->DisplayMsg(MSG_TOTAL_ALLOCATION_UNITS,
                        "%10u", volume_clusters.GetLowPart());

    Message->DisplayMsg(MSG_AVAILABLE_ALLOCATION_UNITS,
                        "%10u", free_clusters.GetLowPart());

    //
    // Get the frequency counter so that we know how to scale the delta time.
    // However, this counter is not accurate and sometimes incorrect on some hardware
    // so we just store it and not divide the data with it.  Theoretically, it
    // should be around 10000000 ticks and each tick is 100ns.
    //

    {
        LARGE_INTEGER   perf_count;
        LARGE_INTEGER   perf_freq;

        if (NT_SUCCESS(NtQueryPerformanceCounter(&perf_count, &perf_freq))) {
            chkdsk_internal_info.TimerFrequency = perf_freq;
        }
    }

#if defined( _AUTOCHECK_ )

    //
    // It would be nice if we can dump out the binary info in autochk like we did in chkdsk
    //
    Message->LogMsg(MSG_CHKLOG_NTFS_INTERNAL_INFO);
    Message->DumpDataToLog(&chkdsk_internal_info, sizeof(NTFS_CHKDSK_INTERNAL_INFO));

    // If this is AUTOCHK and we're running on the boot partition then
    // we should reboot so that the cache doesn't stomp on us.

    DSTRING sdrive, canon_sdrive, canon_drive;
    BOOLEAN dump_message_to_file, reboot_the_system;

    dump_message_to_file = Message->IsLoggingEnabled();

    if (Message->IsInSetup()) {
        reboot_the_system = FALSE;
        dump_message_to_file = (*ExitStatus == CHKDSK_EXIT_ERRS_FIXED ||
                                *ExitStatus == CHKDSK_EXIT_COULD_NOT_FIX) &&
                               dump_message_to_file;

    } else {
        // example of canonical name: \Device\HarddiskVolumeX
        reboot_the_system =
            dump_message_to_file &&
            IFS_SYSTEM::QueryNtSystemDriveName(&sdrive) &&
            IFS_SYSTEM::QueryCanonicalNtDriveName(&sdrive, &canon_sdrive) &&
            IFS_SYSTEM::QueryCanonicalNtDriveName(_drive->GetNtDriveName(),
                                                  &canon_drive) &&
            canon_drive.Stricmp(&canon_sdrive) == 0;

        if (reboot_the_system) {

            Message->DisplayMsg(MSG_CHK_BOOT_PARTITION_REBOOT);

#if defined(USE_CHKDSK_BIT)
            // if autochk requested by user and flag is not set
            // set it and leave
            if (!(volume_flags & VOLUME_CHKDSK_RAN_ONCE)) {
                DebugPrintTrace(("UNTFS: Setting chkdsk ran once flag\n"));
                if (!SetVolumeFlag(VOLUME_CHKDSK_RAN_ONCE, &corrupt_volume)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANNOT_SET_VOLUME_CHKDSK_RAN_ONCE_FLAG);
                    chkdsk_info.ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
                }
            }
#endif
        }
    }

    if (dump_message_to_file) {

        FSTRING boot_log_file_name;

        DebugPrintTrace(("UNTFS: Dumping messages into bootex.log\n"));

        boot_log_file_name.Initialize( L"bootex.log" );

        if (!DumpMessagesToFile( &boot_log_file_name,
                                 &mft_file,
                                 Message ) ) {
            DebugPrintTrace(("UNTFS: Error writing messages to BOOTEX.LOG\n"));
        }

    }

    // turn off logging so that we don't
    // dump the message out again
    Message->SetLoggingEnabled(FALSE);

    if (reboot_the_system)
        IFS_SYSTEM::Reboot();

#else

    if (FixLevel != CheckOnly &&
        (*ExitStatus == CHKDSK_EXIT_ERRS_FIXED ||
         *ExitStatus == CHKDSK_EXIT_COULD_NOT_FIX) &&
        Message->IsLoggingEnabled()) {

        HMEM        LoggedMessageMem;
        ULONG       MessageDataLength;
        HANDLE      hEventLog;
        NTSTATUS    ntstatus;
        PWSTR       Strings[1];

        if( !LoggedMessageMem.Initialize() ||
            !Message->QueryPackedLog( &LoggedMessageMem, &MessageDataLength ) ) {

            Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_TO_COLLECT_LOGGED_MESSAGES);

        } else {

            hEventLog = RegisterEventSource(NULL, TEXT("Chkdsk"));

            if (hEventLog == NULL) {
                Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_TO_OBTAIN_EVENTLOG_HANDLE);
            } else {
                Strings[0] = (PWSTR)LoggedMessageMem.GetBuf();
                if (MessageDataLength > 32768) {
                    Strings[0][32768/sizeof(WCHAR)] = 0;
                }
                if (!ReportEvent(hEventLog,
                                 EVENTLOG_INFORMATION_TYPE,
                                 0,
                                 MSG_CHK_NTFS_EVENTLOG,
                                 NULL,
                                 1,
                                 sizeof(NTFS_CHKDSK_INTERNAL_INFO),
                                 (PCWSTR*)Strings,
                                 &chkdsk_internal_info)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_FAILED_TO_CREATE_EVENTLOG,
                                        "%d", GetLastError());
                }
                DeregisterEventSource(hEventLog);
            }
        }
    }

#endif

    return TRUE;
}


BOOLEAN
NTFS_SA::ValidateCriticalFrs(
    IN OUT  PNTFS_ATTRIBUTE MftData,
    IN OUT  PMESSAGE        Message,
    IN      FIX_LEVEL       FixLevel
    )
/*++

Routine Description:

    This routine makes sure that the MFT's first four FRS are contiguous
    and readable.  If they are not contiguous, then this routine will
    print a message stating that this volume is not NTFS.  If they are
    not readable then this routine will read the MFT mirror and if that
    is readable then it will replace the MFT's first four FRS with
    the MFT mirror.

Arguments:

    MftData     - Supplies the MFT's data attribute.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_CLUSTER_RUN    clusrun;
    HMEM                hmem, volume_hmem;
    LCN                 lcn;
    BIG_INT             run_length;
    ULONG               cluster_size;
    NTFS_FRS_STRUCTURE  volume_frs;
    BIG_INT             volume_cluster;
    ULONG               volume_cluster_offset;
    PCHAR               p;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    if (!MftData->QueryLcnFromVcn(0, &lcn, &run_length)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT, "%x", 0);
        return FALSE;
    }

    if (lcn != QueryMftStartingLcn() ||
        run_length <
         (REFLECTED_MFT_SEGMENTS*QueryFrsSize() + (cluster_size - 1)) /cluster_size ) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_MFT);
        return FALSE;
    }

    volume_cluster = lcn-1 + (VOLUME_DASD_NUMBER*QueryFrsSize() +
        (cluster_size - 1)) / cluster_size;

    volume_cluster_offset = (lcn * cluster_size + VOLUME_DASD_NUMBER * QueryFrsSize()
        - volume_cluster * cluster_size).GetLowPart();

    if (!hmem.Initialize() ||
        !clusrun.Initialize(&hmem, _drive, lcn, QueryClusterFactor(),
            (REFLECTED_MFT_SEGMENTS*QueryFrsSize() + (cluster_size - 1))/cluster_size) ||
        !volume_hmem.Initialize() ||
        !volume_frs.Initialize(&volume_hmem, _drive,
           volume_cluster,
           QueryClusterFactor(),
           QueryVolumeSectors(),
           QueryFrsSize(), NULL,
           volume_cluster_offset)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    BOOLEAN     x = FALSE;

    if (!clusrun.Read() || !volume_frs.Read() ||
        (x = !volume_frs.GetAttribute($VOLUME_INFORMATION))) {

        if (x) {
            Message->LogMsg(MSG_CHKLOG_NTFS_VOLUME_INFORMATION_MISSING,
                         "%x", VOLUME_DASD_NUMBER);
        }

        Message->DisplayMsg(MSG_CHK_NTFS_USING_MFT_MIRROR);

        clusrun.Relocate(QueryMft2StartingLcn());

        if (!clusrun.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_MFT);
            return FALSE;
        }

        if (!MftData->ReplaceVcns(0, QueryMft2StartingLcn(),
            (REFLECTED_MFT_SEGMENTS*QueryFrsSize() + (cluster_size - 1))/cluster_size)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (FixLevel != CheckOnly) {
            p = (PCHAR)clusrun.GetBuf();
            p[0] = 'B';
            p[1] = 'A';
            p[2] = 'A';
            p[3] = 'D';
            clusrun.Write();    // invalidate mirror MFT to avoid updating of volume bitmap
                                // as the first four frs'es lcn are no longer correct
        }

        _boot_sector->MftStartLcn = QueryMft2StartingLcn();
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::FetchMftDataAttribute(
    IN OUT  PMESSAGE        Message,
    OUT     PNTFS_ATTRIBUTE MftData
    )
/*++

Routine Description:

    This routine weeds through the minimal necessary NTFS disk structures
    in order to establish the location of the MFT's $DATA attribute.

Arguments:

    Message - Supplies an outlet for messages.
    MftData - Returns an extent list for the MFT's $DATA attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FRS_STRUCTURE  frs;
    HMEM                hmem;
    ULONG               bytes_per_frs;
    BIG_INT             rounded_value_length;
    BIG_INT             rounded_alloc_length;
    BIG_INT             rounded_valid_length;

    DebugAssert(Message);
    DebugAssert(MftData);

    bytes_per_frs = QueryFrsSize();

    // Initialize the NTFS_FRS_STRUCTURE object we'll use to manipulate
    // the mft's FRS.  Note that we won't manipulate any named attributes,
    // so we can pass in NULL for the upcase table.

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, _drive, QueryMftStartingLcn(),
                        QueryClusterFactor(),
                        QueryVolumeSectors(),
                        QueryFrsSize(), NULL)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read() ||
        !frs.SafeQueryAttribute($DATA, MftData, MftData) ||
        MftData->QueryValueLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs ||
        MftData->QueryValidDataLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs) {

        // The first copy of the FRS is unreadable or corrupt
        // so try the second copy.

        if (!hmem.Initialize() ||
            !frs.Initialize(&hmem, _drive, QueryMft2StartingLcn(),
                            QueryClusterFactor(),
                            QueryVolumeSectors(),
                            QueryFrsSize(), NULL)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_MFT);
            return FALSE;
        }

        if (!frs.SafeQueryAttribute($DATA, MftData, MftData)) {
            Message->DisplayMsg(MSG_CHK_NTFS_BAD_MFT);
            return FALSE;
        }
    }


    if (MftData->QueryValueLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs ||
        MftData->QueryValidDataLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs) {
        Message->DisplayMsg(MSG_CHK_NTFS_BAD_MFT);
        return FALSE;
    }

    // Truncate the MFT to be a whole number of file-records.

    rounded_alloc_length = MftData->QueryAllocatedLength()/bytes_per_frs*
                           bytes_per_frs;
    rounded_value_length = MftData->QueryValueLength()/bytes_per_frs*
                           bytes_per_frs;
    rounded_valid_length = MftData->QueryValidDataLength()/bytes_per_frs*
                           bytes_per_frs;

    if (MftData->QueryValidDataLength() != MftData->QueryValueLength()) {
        MftData->Resize(rounded_valid_length, NULL);
    } else if (rounded_value_length != MftData->QueryValueLength() ||
               rounded_alloc_length != MftData->QueryAllocatedLength()) {
        MftData->Resize(rounded_value_length, NULL);
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::QueryDefaultAttributeDefinitionTable(
    OUT     PNTFS_ATTRIBUTE_COLUMNS AttributeDefinitionTable,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine computes the default attribute definition table as put
    down by format.

Arguments:

    AttributeDefinitionTable    - Returns the default attribute definition
                                    table.
    Message                     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UCHAR   major, minor;

    QueryVersionNumber(&major, &minor);

    if (!AttributeDefinitionTable->Initialize(
            (major >= 2) ?
                NumberOfNtfsAttributeDefinitions_2 :
                NumberOfNtfsAttributeDefinitions_1,
            (major >= 2) ?
                NtfsAttributeDefinitions_2 :
                NtfsAttributeDefinitions_1)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::FetchAttributeDefinitionTable(
    IN OUT  PNTFS_ATTRIBUTE         MftData,
    IN OUT  PMESSAGE                Message,
    OUT     PNTFS_ATTRIBUTE_COLUMNS AttributeDefinitionTable
    )
/*++

Routine Description:

    This routine weeds through the minimal necessary NTFS disk structures
    in order to establish an attribute definition table.  This function
    should return the attribute definition table supplied by FORMAT if it
    is unable to retrieve one from disk.

Arguments:

    MftData                     - Supplies the extent list for the MFT's
                                    $DATA attribute.
    Message                     - Supplies an outlet for messages.
    AttributeDefinitionTable    - Returns the volume's attribute definition
                                    table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                Message);

// Comment out this block for future revisions of CHKDSK that will read
// the attribute definition table from the disk.  Version 1.0 and 1.1
// of chkdsk will just get the attribute definition table that FORMAT
// lays out.

#if 0
    NTFS_FRS_STRUCTURE      frs;
    HMEM                    hmem;
    NTFS_ATTRIBUTE          attr_def_table;
    ULONG                   num_columns;
    BIG_INT                 value_length;

    // Initialize an FRS for the attribute definition table file's
    // FRS.  Note that we won't manipulate any named attributes, so
    // we can pass in NULL for the upcase table.

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, MftData, ATTRIBUTE_DEF_TABLE_NUMBER,
                        QueryClusterFactor(), QueryFrsSize(),
                        QueryVolumeSectors(), NULL)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read()) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_DEF_TABLE);

        return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                    Message);
    }

    if (!frs.SafeQueryAttribute($DATA, MftData, &attr_def_table)) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_DEF_TABLE);

        return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                    Message);
    }

    attr_def_table.QueryValueLength(&value_length);

    num_columns = (value_length/sizeof(ATTRIBUTE_DEFINITION_COLUMNS)).GetLowPart();

    if (value_length%sizeof(ATTRIBUTE_DEFINITION_COLUMNS) != 0) {

        Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_DEF_TABLE_LENGTH_NOT_IN_MULTIPLES_OF_ATTR_DEF_COLUMNS,
                     "%I64x%x",
                     value_length.GetLargeInteger(),
                     sizeof(ATTRIBUTE_DEFINITION_COLUMNS));

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_DEF_TABLE);

        return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                    Message);
    }

    if (!AttributeDefinitionTable->Initialize(num_columns)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!AttributeDefinitionTable->Read(&attr_def_table) ||
        !AttributeDefinitionTable->Verify()) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_DEF_TABLE);

        return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                    Message);
    }

    return TRUE;
#endif
}


BOOLEAN
NTFS_SA::FetchUpcaseTable(
    IN OUT  PNTFS_ATTRIBUTE         MftData,
    IN OUT  PMESSAGE                Message,
    OUT     PNTFS_UPCASE_TABLE      UpcaseTable
    )
/*++

Routine Description:

    This routine safely fetches the NTFS upcase table.  It none is
    available on disk then this routine gets the one from the
    operating system.

Arguments:

    MftData     - Supplies the MFT's data attribute.
    Message     - Supplies an outlet for messages.
    UpcaseTable - Returns the upcase table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // For product 1, always use the system's upcase table.  If this upcase
    // table differs from the upcase table on disk then it will be written
    // to disk at the end of CHKDSK.  CHKDSK will resort indices as
    // needed to reflect any upcase table changes.

    if (!UpcaseTable->Initialize()) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_GET_UPCASE_TABLE);
        return FALSE;
    }

    return TRUE;


#if 0
    NTFS_FRS_STRUCTURE      frs;
    HMEM                    hmem;
    NTFS_ATTRIBUTE          upcase_table;

    // Initialize an FRS for the upcase table file's
    // FRS.  Note that we won't manipulate any named attributes, so
    // we can pass in NULL for the upcase table.

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, MftData, UPCASE_TABLE_NUMBER,
                        QueryClusterFactor(), QueryFrsSize(),
                        QueryVolumeSectors(), NULL)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read() ||
        !frs.SafeQueryAttribute($DATA, MftData, &upcase_table) ||
        !UpcaseTable->Initialize(&upcase_table) ||
        !UpcaseTable->Verify()) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_UPCASE_TABLE);

        if (!UpcaseTable->Initialize()) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_GET_UPCASE_TABLE);
            return FALSE;
        }
    }

    return TRUE;
#endif
}


BOOLEAN
NTFS_SA::VerifyAndFixMultiFrsFile(
    IN OUT  PNTFS_FRS_STRUCTURE         BaseFrs,
    IN OUT  PNTFS_ATTRIBUTE_LIST        AttributeList,
    IN      PNTFS_ATTRIBUTE             MftData,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN OUT  PNTFS_BITMAP                VolumeBitmap,
    IN OUT  PNTFS_BITMAP                MftBitmap,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine verifies, and if necessary fixes, a multi-FRS file.

Arguments:

    BaseFrs             - Supplies the base FRS of the file to validate.
    AttributeList       - Supplies the attribute list of the file to
                            validate.
    MftData             - Supplies the MFT's $DATA attribute.
    AttributeDefTable   - Supplies the attribute definition table.
    VolumeBitmap        - Supplies the volume bitmap.
    MftBitmap           - Supplies the MFT bitmap.
    ChkdskReport        - Supplies the current chkdsk report.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not there have been any
                            disk errors found so far.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NUMBER_SET          child_file_numbers;
    PHMEM*              child_frs_hmem;
    LIST                child_frs_list;
    PITERATOR           iter;
    PNTFS_FRS_STRUCTURE pfrs;
    ULONG               num_child_frs, i;
    BOOLEAN             changes;
    BOOLEAN             need_write;
    ULONG               errFixedStatus = CHKDSK_EXIT_SUCCESS;

    DebugAssert(BaseFrs);
    DebugAssert(AttributeList);
    DebugAssert(MftData);
    DebugAssert(AttributeDefTable);
    DebugAssert(VolumeBitmap);
    DebugAssert(MftBitmap);
    DebugAssert(Message);


    // First get a list of the child FRSs pointed to by the
    // attribube list.

    if (!QueryListOfFrs(BaseFrs, AttributeList, MftData,
                        &child_file_numbers, Message)) {

        return FALSE;
    }


    // Create some HMEMs for the FRS structures.

    num_child_frs = child_file_numbers.QueryCardinality().GetLowPart();

    if (!(child_frs_hmem = NEW PHMEM[num_child_frs])) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    memset(child_frs_hmem, 0, num_child_frs*sizeof(PHMEM));


    // Read in all of the child FRS.

    if (!child_frs_list.Initialize() ||
        !VerifyAndFixChildFrs(&child_file_numbers, MftData, AttributeDefTable,
                              BaseFrs->GetUpcaseTable(),
                              child_frs_hmem, &child_frs_list, FixLevel,
                              Message, DiskErrorsFound)) {

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }

    // At this point we have a list of child FRSs that are all readable.
    // This list contains all of the possible children for the parent
    // but are not all necessarily valid children.


    // Now go through the attribute list and make sure that all of the
    // entries in the list correspond to correct attribute records.
    // Additionally, make sure that multi-record attributes are well-linked
    // and that there are no cross-links.

    if (!EnsureWellDefinedAttrList(BaseFrs, AttributeList, &child_frs_list,
                                   VolumeBitmap, ChkdskReport, ChkdskInfo,
                                   FixLevel, Message, DiskErrorsFound)) {

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }


    // Next, we go through all of the attribute records in all of the
    // FRS and make sure that they have a corresponding attribute list
    // entry.

    if (!EnsureSurjectiveAttrList(BaseFrs, AttributeList, &child_frs_list,
                                  FixLevel, Message, DiskErrorsFound)) {

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }

    // Mark all of the child FRS in the MFT bitmap.

    if (!(iter = child_frs_list.QueryIterator())) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }

    while (pfrs = (PNTFS_FRS_STRUCTURE) iter->GetNext()) {
        MftBitmap->SetAllocated(pfrs->QueryFileNumber().GetLowPart(), 1);
    }

    // Check the instance tags on the attribute records in the base
    // frs and in each child frs.

    need_write = FALSE;

    if (!BaseFrs->CheckInstanceTags(FixLevel,
                                    ChkdskInfo->Verbose,
                                    Message,
                                    &changes,
                                    AttributeList)) {
        DELETE(iter);
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }

    need_write |= changes;

    iter->Reset();

    while (pfrs = (PNTFS_FRS_STRUCTURE)iter->GetNext()) {
        if (!pfrs->CheckInstanceTags(FixLevel,
                                     ChkdskInfo->Verbose,
                                     Message,
                                     &changes,
                                     AttributeList)) {
            break;
        }

        need_write |= changes;
    }

    DELETE(iter);

    if (need_write) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (FixLevel != CheckOnly) {
            AttributeList->WriteList(NULL);
        }
    }

    for (i = 0; i < num_child_frs; i++) {
        DELETE(child_frs_hmem[i]);
    }
    DELETE(child_frs_hmem);
    child_frs_list.DeleteAllMembers();

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
NTFS_SA::QueryListOfFrs(
    IN      PCNTFS_FRS_STRUCTURE    BaseFrs,
    IN      PCNTFS_ATTRIBUTE_LIST   AttributeList,
    IN OUT  PNTFS_ATTRIBUTE         MftData,
    OUT     PNUMBER_SET             ChildFileNumbers,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine computes all of the child file numbers pointed to by
    the given attribute list which is contained in the given FRS.

Arguments:

    BaseFrs             - Supplies the base FRS.
    AttributeList       - Supplies the attribute list for the base FRS.
    MftData             - Supplies the Mft's data attribute.
    ChildFileNumbers    - Return a list of child FRS numbers.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM                        hmem;
    NTFS_FRS_STRUCTURE          child_frs;
    ATTRIBUTE_TYPE_CODE         attr_code;
    VCN                         lowest_vcn;
    MFT_SEGMENT_REFERENCE       seg_ref;
    DSTRING                     attr_name;
    VCN                         file_number;
    USHORT                      instance;
    ATTR_LIST_CURR_ENTRY        entry;

    DebugAssert(BaseFrs);
    DebugAssert(AttributeList);
    DebugAssert(ChildFileNumbers);
    DebugAssert(Message);

    if (!ChildFileNumbers->Initialize()) {
        return FALSE;
    }

    entry.CurrentEntry = NULL;
    while (AttributeList->QueryNextEntry(&entry,
                                         &attr_code,
                                         &lowest_vcn,
                                         &seg_ref,
                                         &instance,
                                         &attr_name)) {

        file_number.Set(seg_ref.LowPart, (ULONG) seg_ref.HighPart);

        if (file_number != BaseFrs->QueryFileNumber()) {
            if (!ChildFileNumbers->DoesIntersectSet(file_number, 1)) {

                if (!hmem.Initialize() ||
                    !child_frs.Initialize(&hmem, MftData, file_number,
                                          QueryClusterFactor(),
                                          QueryVolumeSectors(),
                                          QueryFrsSize(),
                                          NULL)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }


                // Only add this FRS to the list of child FRS's
                // if it is readable and points back to the base.

                if (child_frs.Read() &&
                    child_frs.QueryBaseFileRecordSegment() ==
                    BaseFrs->QuerySegmentReference()) {

                    if (!ChildFileNumbers->Add(file_number)) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
                }
            }
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::VerifyAndFixChildFrs(
    IN      PCNUMBER_SET                ChildFileNumbers,
    IN      PNTFS_ATTRIBUTE             MftData,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN      PNTFS_UPCASE_TABLE          UpcaseTable,
    OUT     PHMEM*                      ChildFrsHmemList,
    IN OUT  PCONTAINER                  ChildFrsList,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine reads in all of the child FRS listed in 'ChildFileNumbers'
    and returns the readable ones into the 'ChildFrsList'.  These FRS will
    be initialized with the HMEM provided in 'ChildFrsHmemList'.

    Then this routine verifies all of these FRS.  Any FRS that are not
    good will not be returned in the list.

Arguments:

    ChildFileNumbers    - Supplies the file numbers of the child FRS.
    MftData             - Supplies the MFT data attribute.
    AttributeDefTable   - Supplies the attribute definition table.
    UpcaseTable         - Supplies the volume upcase table.
    ChildFrsHmemList    - Returns the HMEM for the FRS structures.
    ChildFrsList        - Returns a list of FRS structures corresponding
                            to the readable FRS found in the given list.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have been
                            found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG               i;
    ULONG               num_child_frs;
    PNTFS_FRS_STRUCTURE frs;

    num_child_frs = ChildFileNumbers->QueryCardinality().GetLowPart();

    for (i = 0; i < num_child_frs; i++) {

        frs = NULL;

        if (!(ChildFrsHmemList[i] = NEW HMEM) ||
            !ChildFrsHmemList[i]->Initialize() ||
            !(frs = NEW NTFS_FRS_STRUCTURE) ||
            !frs->Initialize(ChildFrsHmemList[i],
                             MftData,
                             ChildFileNumbers->QueryNumber(i),
                             QueryClusterFactor(),
                             QueryVolumeSectors(),
                             QueryFrsSize(),
                             UpcaseTable)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE(frs);
            return FALSE;
        }

        if (!frs->Read()) {
            DELETE(frs);
            continue;
        }

        if (!frs->IsInUse()) {
            DELETE(frs);
            continue;
        }

        if (!frs->VerifyAndFix(FixLevel, Message, AttributeDefTable,
                               DiskErrorsFound)) {
            DELETE(frs);
            return FALSE;
        }

        if (!frs->IsInUse()) {
            DELETE(frs);
            continue;
        }


        // Compare the LSN of this FRS with the current largest LSN.

        if (frs->QueryLsn() > LargestLsnEncountered) {
            LargestLsnEncountered = frs->QueryLsn();
        }

        if (!ChildFrsList->Put(frs)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE(frs);
            return FALSE;
        }
    }

    return TRUE;
}


VOID
DeleteAllAttributes(
    IN  PSEQUENTIAL_CONTAINER   AllAttributes
    )
{
    PITERATOR               alliter;
    PSEQUENTIAL_CONTAINER   attribute;

    if (!(alliter = AllAttributes->QueryIterator())) {
        return;
    }

    while (attribute = (PSEQUENTIAL_CONTAINER) alliter->GetNext()) {
        attribute->DeleteAllMembers();
    }
    DELETE(alliter);

    AllAttributes->DeleteAllMembers();
}


BOOLEAN
NTFS_SA::EnsureWellDefinedAttrList(
    IN      PNTFS_FRS_STRUCTURE     BaseFrs,
    IN OUT  PNTFS_ATTRIBUTE_LIST    AttributeList,
    IN      PCSEQUENTIAL_CONTAINER  ChildFrsList,
    IN OUT  PNTFS_BITMAP            VolumeBitmap,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message,
    IN OUT  PBOOLEAN                DiskErrorsFound
    )
/*++

Routine Desciption:

    This routine makes sure that every entry in the attribute list
    points to an FRS with the same segment reference and that the
    attribute record refered to in the entry actually exists in the
    FRS.  Invalid attribute list entries will be deleted.

Arguments:

    BaseFrs         - Supplies the base file record segment.
    AttributeList   - Supplies the attribute list.
    ChildFrsList    - Supplies a list of all of the child FRS.
    VolumeBitmap    - Supplies a volume bitmap.
    ChkdskReport    - Supplies the current chkdsk report.
    FixLevel        - Supplies the fix up level.
    Message         - Supplies an outlet for messages.
    DiskErrorsFound - Supplies whether or not disk errors have been
                        found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ATTR_LIST_CURR_ENTRY        entry;
    BOOLEAN                     changes;
    PITERATOR                   child_frs_iter;
    PITERATOR                   attribute_iter;
    ATTRIBUTE_TYPE_CODE         attr_code;
    VCN                         lowest_vcn;
    MFT_SEGMENT_REFERENCE       seg_ref;
    MFT_SEGMENT_REFERENCE       base_ref;
    DSTRING                     attr_name, attr_name2;
    PNTFS_FRS_STRUCTURE         frs;
    PVOID                       precord;
    NTFS_ATTRIBUTE_RECORD       attr_record;
    PLIST                       attribute;
    PNTFS_ATTRIBUTE_RECORD      pattr_record;
    BOOLEAN                     errors_found;
    LIST                        all_attributes;
    BOOLEAN                     user_file;
    NTFS_CHKDSK_REPORT          dummy_report;
    USHORT                      instance;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;


    if (!(child_frs_iter = ChildFrsList->QueryIterator())) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!(attribute = NEW LIST) ||
        !attribute->Initialize() ||
        !all_attributes.Initialize()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    // Go through each attribute entry and make sure it's right.
    // If it isn't right then delete it.  Otherwise, check for
    // cross-links and consistency between multi-record attributes.

    changes = FALSE;
    base_ref = BaseFrs->QuerySegmentReference();
    user_file = FALSE;


    entry.CurrentEntry = NULL;
    while (AttributeList->QueryNextEntry(&entry,
                                         &attr_code,
                                         &lowest_vcn,
                                         &seg_ref,
                                         &instance,
                                         &attr_name)) {

        if (attr_code == $DATA ||
            attr_code == $EA_DATA ||
            ((ChkdskInfo->major >= 2) ?
                (attr_code >= $FIRST_USER_DEFINED_ATTRIBUTE_2) :
                (attr_code >= $FIRST_USER_DEFINED_ATTRIBUTE_1)) ) {

            VCN FileNumber = BaseFrs->QueryFileNumber();

            if (FileNumber >= FIRST_USER_FILE_NUMBER) {
                user_file = TRUE;
            }
        }


        // First find which frs this refers to.

        if (seg_ref == base_ref) {

            frs = BaseFrs;

        } else {

            child_frs_iter->Reset();
            while (frs = (PNTFS_FRS_STRUCTURE) child_frs_iter->GetNext()) {

                if (frs->QuerySegmentReference() == seg_ref &&
                    frs->QueryBaseFileRecordSegment() == base_ref) {
                    break;
                }
            }
        }


        // If the frs is present then look for the record.

        if (frs) {

            // Try to locate the exact attribute record.

            precord = NULL;
            while (precord = frs->GetNextAttributeRecord(precord)) {

                if (!attr_record.Initialize(GetDrive(), precord)) {
                    DebugAbort("Couldn't initialize an attribute record.");
                    return FALSE;
                }

                if (attr_record.QueryTypeCode() == attr_code &&
                    attr_record.QueryLowestVcn() == lowest_vcn &&
                    attr_record.QueryInstanceTag() == instance) {

                    if (!attr_record.QueryName(&attr_name2)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        DELETE(child_frs_iter);
                        return FALSE;
                    }

                    if (!attr_name.Strcmp(&attr_name2)) {
                        break;
                    }
                }
            }

        } else {
            precord = NULL;
        }


        // If we have not found a match then delete the entry.
        // Also, there should be no entries in the attribute list
        // for the attribute list entry itself.  If there is
        // then remove is without hurting anything.

        if (!precord || attr_code == $ATTRIBUTE_LIST) {

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST_ENTRY,
                                "%d%d", attr_code,
                                BaseFrs->QueryFileNumber().GetLowPart());

            if (frs == NULL) {

                BIG_INT     file_number;

                file_number.Set(seg_ref.LowPart, seg_ref.HighPart);

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_LOCATE_CHILD_FRS,
                             "%I64x%x",
                             file_number.GetLargeInteger(),
                             seg_ref.SequenceNumber);

                DebugPrintTrace(("UNTFS: Unable to find child frs 0x%I64x with sequence number 0x%x\n",
                                 file_number.GetLargeInteger(), seg_ref.SequenceNumber));

            } else if (!precord) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_LOCATE_ATTR_IN_ATTR_LIST,
                             "%x%I64x%x%I64x",
                             attr_code,
                             lowest_vcn.GetLargeInteger(),
                             instance,
                             frs->QueryFileNumber().GetLargeInteger());

                DebugPrintTrace(("UNTFS: Could not locate attribute of type code 0x%x,\n"
                                 "Lowest Vcn 0x%I64x, and Instance number 0x%x in frs 0x%I64x\n",
                                 attr_code,
                                 lowest_vcn.GetLargeInteger(),
                                 instance,
                                 frs->QueryFileNumber().GetLargeInteger()));
            } else {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LIST_WITHIN_ATTR_LIST,
                             "%I64x", frs->QueryFileNumber().GetLargeInteger());
            }

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            AttributeList->DeleteCurrentEntry(&entry);

            attribute->DeleteAllMembers();
            DeleteAllAttributes(&all_attributes);

            if (!attribute->Initialize() ||
                !all_attributes.Initialize()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);

                DELETE(child_frs_iter);
                DELETE(attribute);
                return FALSE;
            }

            changes = TRUE;
            entry.CurrentEntry = NULL;
            user_file = FALSE;

            continue;
        }


        // If the lowest vcn of this one is zero then package up the
        // previous attribute and start a new container for the
        // next attribute.

        if (attr_record.QueryLowestVcn() == 0 &&
            attribute->QueryMemberCount()) {

            if (!all_attributes.Put(attribute) ||
                !(attribute = NEW LIST) ||
                !attribute->Initialize()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);

                DELETE(child_frs_iter);
                attribute->DeleteAllMembers();
                DELETE(attribute);
                DeleteAllAttributes(&all_attributes);
                return FALSE;
            }
        }

        if (!(pattr_record = NEW NTFS_ATTRIBUTE_RECORD) ||
            !pattr_record->Initialize(GetDrive(), precord) ||
            !attribute->Put(pattr_record)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);

            DELETE(child_frs_iter);
            DELETE(pattr_record);
            attribute->DeleteAllMembers();
            DELETE(attribute);
            DeleteAllAttributes(&all_attributes);
            return FALSE;
        }

    }

    DELETE(child_frs_iter);

    if (attribute->QueryMemberCount() &&
        !all_attributes.Put(attribute)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        attribute->DeleteAllMembers();
        DELETE(attribute);
        DeleteAllAttributes(&all_attributes);
        return FALSE;
    }
    attribute = NULL;

    if (user_file) {
        ChkdskReport->NumUserFiles += 1;
    }


    // Now go through all of the attributes in 'all_attributes' and
    // make sure that every attribute is well-defined and that there
    // are no cross-links.

    if (!(attribute_iter = all_attributes.QueryIterator())) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        DeleteAllAttributes(&all_attributes);
        return FALSE;
    }


    while (attribute = (PLIST) attribute_iter->GetNext()) {

        if (!VerifyAndFixAttribute(attribute, AttributeList,
                                   VolumeBitmap, BaseFrs, &errors_found,
                                   user_file ? ChkdskReport : &dummy_report,
                                   ChkdskInfo, Message)) {

            DeleteAllAttributes(&all_attributes);
            DELETE(attribute_iter);
            return FALSE;
        }

        changes = (BOOLEAN) (changes || errors_found);
    }
    DELETE(attribute_iter);

    if (changes && DiskErrorsFound) {
        *DiskErrorsFound = TRUE;
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    if (changes &&
        FixLevel != CheckOnly &&
        !AttributeList->WriteList(VolumeBitmap)) {
        Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                            "%d", BaseFrs->QueryFileNumber().GetLowPart());
        return FALSE;
    }


    DeleteAllAttributes(&all_attributes);

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
NTFS_SA::VerifyAndFixAttribute(
    IN      PCLIST                  Attribute,
    IN OUT  PNTFS_ATTRIBUTE_LIST    AttributeList,
    IN OUT  PNTFS_BITMAP            VolumeBitmap,
    IN      PCNTFS_FRS_STRUCTURE    BaseFrs,
    OUT     PBOOLEAN                ErrorsFound,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine verifies a list of attribute records as an attribute.

Arguments:

    Attribute       - Supplies the attribute as a list of attribute
                        records.
    AttributeList   - Supplies the attribute list.
    VolumeBitmap    - Supplies the volume bitmap.
    BaseFrs         - Supplies the base FRS.
    ErrorsFound     - Returns whether or not error were found.
    ChkdskReport    - Supplies the current chkdsk report.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    This thing is speced to take a list because it depends on the
    attribute records to be in the order that they were in the
    attribute list.

--*/
{
    PITERATOR               iter;
    PNTFS_ATTRIBUTE_RECORD  attr_record;
    DSTRING                 name;
    PNTFS_ATTRIBUTE_RECORD  first_record;
    PNTFS_ATTRIBUTE_RECORD  last_record;
    DSTRING                 first_record_name;
    DSTRING                 record_name;
    BIG_INT                 value_length;
    BIG_INT                 alloc_length;
    BIG_INT                 cluster_count;
    BIG_INT                 total_clusters = 0;
    BIG_INT                 total_allocated;
    BOOLEAN                 got_allow_cross_link;
    ULONG                   errFixedStatus = CHKDSK_EXIT_SUCCESS;
    BOOLEAN                 unuse_clusters;

    if (!(iter = Attribute->QueryIterator())) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    *ErrorsFound = FALSE;

    if (!(first_record = (PNTFS_ATTRIBUTE_RECORD) iter->GetNext())) {
        DebugAbort("Attribute has no attribute records");
        return FALSE;
    }

    if (first_record->QueryLowestVcn() != 0) {

        *ErrorsFound = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LOWEST_VCN_IS_NOT_ZERO,
                     "%x%I64x%x%I64x",
                     first_record->QueryTypeCode(),
                     first_record->QueryLowestVcn().GetLargeInteger(),
                     first_record->QueryInstanceTag(),
                     BaseFrs->QueryFileNumber().GetLargeInteger());
    }

    got_allow_cross_link = FALSE;

    if (!first_record->IsResident() &&
        !first_record->UseClusters(VolumeBitmap,
                                   &cluster_count, ChkdskInfo->CrossLinkStart,
                                   ChkdskInfo->CrossLinkYet ? 0 :
                                       ChkdskInfo->CrossLinkLength,
                                   &got_allow_cross_link)) {
        *ErrorsFound = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_CLUSTERS_IN_USE,
                     "%x%x%I64x",
                     first_record->QueryTypeCode(),
                     first_record->QueryInstanceTag(),
                     BaseFrs->QueryFileNumber().GetLargeInteger());

        got_allow_cross_link = FALSE;

        //
        // We don't want to free the clusters allocated to this attribute
        // record below, because some of them are cross-linked and the ones
        // that are not have not been allocated in the volume bitmap.
        //

        first_record->DisableUnUse();
    }

    if( first_record->IsResident() ) {

        total_clusters = 0;

    } else {

        total_clusters = cluster_count;
    }

    if (got_allow_cross_link) {
        ChkdskInfo->CrossLinkYet = TRUE;
        ChkdskInfo->CrossLinkedFile = BaseFrs->QueryFileNumber().GetLowPart();
        ChkdskInfo->CrossLinkedAttribute = first_record->QueryTypeCode();
        if (!first_record->QueryName(&ChkdskInfo->CrossLinkedName)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        }
    }

    if (!first_record->QueryName(&first_record_name)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    last_record = first_record;
    while (!(*ErrorsFound) &&
           (attr_record = (PNTFS_ATTRIBUTE_RECORD) iter->GetNext())) {

        if (!attr_record->QueryName(&record_name)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // The filesystem only cares about and maintains the Flags member
        // in the first attribute record of a multi-frs attribute.  So
        // I removed the check below, which used to insure that each set
        // of flags was identical. -mjb.

        // else if (attr_record->QueryFlags() != first_record->QueryFlags()) {

        if (!*ErrorsFound) {

             if (first_record->IsResident()) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_FIRST_ATTR_RECORD_CANNOT_BE_RESIDENT,
                             "%x%x%I64x",
                              first_record->QueryTypeCode(),
                              first_record->QueryInstanceTag(),
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             } else if (attr_record->IsResident()) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_CANNOT_BE_RESIDENT,
                             "%x%x%I64x",
                              attr_record->QueryTypeCode(),
                              attr_record->QueryInstanceTag(),
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             } else if (attr_record->QueryTypeCode() != first_record->QueryTypeCode()) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_TYPE_CODE_MISMATCH,
                             "%x%x%x%x%I64x",
                              first_record->QueryTypeCode(),
                              first_record->QueryInstanceTag(),
                              attr_record->QueryTypeCode(),
                              attr_record->QueryInstanceTag(),
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             } else if (attr_record->QueryLowestVcn() != last_record->QueryNextVcn()) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_VCN_NOT_CONTIGUOUS,
                             "%x%x%I64x%x%I64x%I64x",
                              last_record->QueryTypeCode(),
                              last_record->QueryInstanceTag(),
                              last_record->QueryNextVcn().GetLargeInteger(),
                              attr_record->QueryInstanceTag(),
                              attr_record->QueryLowestVcn().GetLargeInteger(),
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             } else if (record_name.Strcmp(&first_record_name)) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_NAME_MISMATCH,
                             "%x%x%W%x%W%I64x",
                              first_record->QueryTypeCode(),
                              first_record->QueryInstanceTag(),
                              &first_record_name,
                              attr_record->QueryInstanceTag(),
                              &record_name,
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             }
        }

        if (!attr_record->UseClusters(VolumeBitmap,
                                      &cluster_count,
                                      ChkdskInfo->CrossLinkStart,
                                      ChkdskInfo->CrossLinkYet ? 0 :
                                          ChkdskInfo->CrossLinkLength,
                                      &got_allow_cross_link)) {
            *ErrorsFound = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_CLUSTERS_IN_USE,
                         "%x%x%I64x",
                         attr_record->QueryTypeCode(),
                         attr_record->QueryInstanceTag(),
                         BaseFrs->QueryFileNumber().GetLargeInteger());

            got_allow_cross_link = FALSE;

            //
            // We don't want to free the clusters allocated to this attribute
            // record below, because some of them are cross-linked and the ones
            // that are not have not been allocated in the volume bitmap.
            //

            attr_record->DisableUnUse();
        }

        total_clusters += cluster_count;

        if (got_allow_cross_link) {
            ChkdskInfo->CrossLinkYet = TRUE;
            ChkdskInfo->CrossLinkedFile = BaseFrs->QueryFileNumber().GetLowPart();
            ChkdskInfo->CrossLinkedAttribute = attr_record->QueryTypeCode();
            if (!attr_record->QueryName(&ChkdskInfo->CrossLinkedName)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            }
        }

        last_record = attr_record;
    }

    // Check the allocated length.

    first_record->QueryValueLength(&value_length, &alloc_length, NULL,
        &total_allocated);

    if (!first_record->IsResident()) {

        BIG_INT     temp_length = last_record->QueryNextVcn()*
                                  _drive->QuerySectorSize()*
                                  QueryClusterFactor();

        if (alloc_length != temp_length) {

            *ErrorsFound = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_INCORRECT_ALLOCATE_LENGTH,
                         "%x%x%I64x%I64x%I64x",
                         first_record->QueryTypeCode(),
                         first_record->QueryInstanceTag(),
                         alloc_length.GetLargeInteger(),
                         temp_length.GetLargeInteger(),
                         BaseFrs->QueryFileNumber().GetLargeInteger());

        }

#if 0
//
// MJB: deleting the attribute because the total allocated is
//  wrong is considered too severe, so what we really want to do is
//  repair the attribute record.  Unfortunately, I don't see any
//  reasonable way to do that, so we'll let it be.  The filesystem
//  guarantees that nothing terrible will happen if your TotalAllocated
//  field is out-of-whack.
//
        if ((first_record->QueryFlags() & ATTRIBUTE_FLAG_COMPRESSION_MASK)
            != 0) {

            if (total_clusters * _drive->QuerySectorSize() *
                QueryClusterFactor() != total_allocated) {

                DebugPrintTrace(("multi-frs total allocated wrong\n"));

                *ErrorsFound = TRUE;
            }
        }
#endif
    }


    if (*ErrorsFound) {

        // There's a problem so tell the user and tube all of the
        // attribute list entries concerned.

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST_ENTRY,
                            "%d%d", first_record->QueryTypeCode(),
                            BaseFrs->QueryFileNumber().GetLowPart());

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        unuse_clusters = FALSE;

        iter->Reset();
        while (attr_record = (PNTFS_ATTRIBUTE_RECORD) iter->GetNext()) {

            // The algorithm above stops calling UseClusters() once it
            // encountered a cross linked attribute.  So, we need to
            // disable UnUseClusters() once we have an attribute that
            // already have the UnUseClusters() disabled.

            if (unuse_clusters)
                attr_record->DisableUnUse();
            else
                unuse_clusters = attr_record->IsUnUseDisabled();

            if (!attr_record->IsResident() &&
                !attr_record->UnUseClusters(VolumeBitmap,
                                            ChkdskInfo->CrossLinkStart,
                                            ChkdskInfo->CrossLinkLength)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);

                DELETE(iter);
                return FALSE;
            }

            if (!attr_record->QueryName(&name) ||
                !AttributeList->DeleteEntry(attr_record->QueryTypeCode(),
                                            attr_record->QueryLowestVcn(),
                                            &name)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);

                DELETE(iter);
                return FALSE;
            }
        }
    } else {

        ChkdskReport->BytesUserData += total_clusters *
                            _drive->QuerySectorSize()*
                            QueryClusterFactor();
    }

    DELETE(iter);

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
NTFS_SA::EnsureSurjectiveAttrList(
    IN OUT  PNTFS_FRS_STRUCTURE     BaseFrs,
    IN      PCNTFS_ATTRIBUTE_LIST   AttributeList,
    IN OUT  PSEQUENTIAL_CONTAINER   ChildFrsList,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message,
    IN OUT  PBOOLEAN                DiskErrorsFound
    )
/*++

Routine Description:

    This routine remove any attribute records that are not present in
    the attribute list.

Arguments:

    BaseFrs         - Supplies the base file record segment.
    AttributeList   - Supplies the attribute list.
    ChildFrsList    - Supplies the list of child FRS.
    FixLevel        - Supplies the fix up level.
    Message         - Supplies an outlet for messages.
    DiskErrorsFound - Supplies whether or not disk errors have been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVOID                   record;
    NTFS_ATTRIBUTE_RECORD   attr_record;
    PNTFS_FRS_STRUCTURE     frs, del_frs;
    PITERATOR               iter;
    DSTRING                 null_string;
    BOOLEAN                 changes;
    DSTRING                 name;
    BOOLEAN                 match_found;
    ATTRIBUTE_TYPE_CODE     attr_code;
    VCN                     lowest_vcn;
    DSTRING                 list_name;

    if (!(iter = ChildFrsList->QueryIterator()) ||
        !null_string.Initialize("\"\"")) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    for (frs = BaseFrs; frs; frs = (PNTFS_FRS_STRUCTURE) iter->GetNext()) {

        changes = FALSE;

        record = NULL;
        while (record = frs->GetNextAttributeRecord(record)) {

            if (!attr_record.Initialize(GetDrive(), record)) {
                DebugAbort("Couldn't initialize an attribute record");
                return FALSE;
            }

            // The attribute list entry is not required to be in the
            // attribute list.

            if (frs == BaseFrs &&
                attr_record.QueryTypeCode() == $ATTRIBUTE_LIST) {

                continue;
            }


            // Find this attribute record in the attribute list.
            // Otherwise, tube this attribute record.

            match_found = AttributeList->QueryEntry(
                                frs->QuerySegmentReference(),
                                attr_record.QueryInstanceTag(),
                                &attr_code, &lowest_vcn, &list_name);

            if (!match_found) {

                if (!attr_record.QueryName(&name)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_NOT_IN_ATTR_LIST,
                             "%x%x%I64x",
                             attr_record.QueryTypeCode(),
                             attr_record.QueryInstanceTag(),
                             frs->QuerySegmentReference());

                Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                                    "%d%W%I64d",
                                    attr_record.QueryTypeCode(),
                                    name.QueryChCount() ? &name : &null_string,
                                    frs->QueryFileNumber().GetLargeInteger());

                frs->DeleteAttributeRecord(record);
                record = NULL;
                changes = TRUE;
            }
        }

        if (frs != BaseFrs && !frs->GetNextAttributeRecord(NULL)) {
            changes = TRUE;
            frs->ClearInUse();
            if (!(del_frs = (PNTFS_FRS_STRUCTURE) ChildFrsList->Remove(iter))) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            iter->GetPrevious();
        } else {
            del_frs = NULL;
        }

        if (changes && DiskErrorsFound) {
            *DiskErrorsFound = TRUE;
        }

        if (changes && FixLevel != CheckOnly && !frs->Write()) {
            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                "%d", frs->QueryFileNumber().GetLowPart());
            return FALSE;
        }

        DELETE(del_frs);
    }


    DELETE(iter);

    return TRUE;
}

BOOLEAN
NTFS_SA::HotfixMftData(
    IN OUT  PNTFS_ATTRIBUTE MftData,
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    IN      PNUMBER_SET     BadFrsList,
    OUT     PNUMBER_SET     BadClusterList,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine replaces the unreadable FRS in the MFT with readable
    FRS allocated from the volume bitmap.  This routine will fail if
    it cannot hotfix all of the system files.  If there is not
    sufficient disk space to hotfix non-system files then these files
    will be left alone.

    The clusters from the unreadable FRS will be added to the
    unreadable clusters list.  Only those FRS that were successfully
    hotfixed will be added to this list.

Arguments:

    MftData             - Supplies the MFT data attribute.
    VolumeBitmap        - Supplies a valid volume bitmap.
    BadFrsList          - Supplies the list of unreadable FRS.
    BadClusterList      - Returns the list of unreadable clusters.
    FixLevel            - Tells whether the disk should be modified.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    VCN                 unreadable_vcn;
    VCN                 file_number;
    ULONG               i, j;
    HMEM                hmem;
    NTFS_FRS_STRUCTURE  frs;
    LCN                 lcn, previous_lcn;
    NUMBER_SET          last_action;
    ULONG               cluster_size;
    ULONG               clusters_per_frs;
    NUMBER_SET          fixed_frs_list;

    DebugAssert(MftData);
    DebugAssert(VolumeBitmap);
    DebugAssert(BadFrsList);
    DebugAssert(BadClusterList);

    if (!BadClusterList->Initialize() ||
        !fixed_frs_list.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    if (QueryFrsSize() > cluster_size) {
        clusters_per_frs = QueryFrsSize() / cluster_size;
    } else {
        clusters_per_frs = 1;
    }

    for (i = 0; i < BadFrsList->QueryCardinality(); i++) {

        if (!last_action.Initialize()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        file_number = BadFrsList->QueryNumber(i);

        unreadable_vcn = (file_number * QueryFrsSize()) / cluster_size;

        // Figure out which clusters go with this frs.  Save away the
        // first one so that we can try to copy its contents later, if
        // necessary.
        //

        if (!MftData->QueryLcnFromVcn(unreadable_vcn, &previous_lcn)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT, "%I64x", unreadable_vcn);
            return FALSE;
        }

        for (j = 0; j < clusters_per_frs; j++) {

            BOOLEAN     error = FALSE;

            if (!MftData->QueryLcnFromVcn(unreadable_vcn + j, &lcn)) {
                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT, "%I64x", unreadable_vcn+j);
                error = TRUE;
            } else if (lcn == LCN_NOT_PRESENT) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                error = TRUE;
            } else if (!BadClusterList->Add(lcn)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                error = TRUE;
            } else if (!last_action.Add(lcn)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                error = TRUE;
            }
            if (error) {
                return FALSE;
            }
        }

        if (MftData->Hotfix(unreadable_vcn,
                            clusters_per_frs,
                            VolumeBitmap,
                            BadClusterList,
                            FALSE)) {

            // The mft data clusters have been successfully replaced with new
            // clusters.  We want to set the new clusters/frs to indicate that
            // it is not in use.
            //

            if (!hmem.Initialize() ||
                !frs.Initialize(&hmem, MftData, file_number,
                                QueryClusterFactor(),
                                QueryVolumeSectors(),
                                QueryFrsSize(),
                                NULL)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            memset(hmem.GetBuf(), 0, hmem.QuerySize());
            frs.ClearInUse();
            if (FixLevel != CheckOnly) {
                frs.Write();
            }

            // If there were multiple frs in a replaced cluster, we
            // want to copy all those that can be read to the new location.
            //

            if (QueryFrsSize() < cluster_size) {

                ULONG sectors_per_frs = QueryFrsSize() / _drive->QuerySectorSize();
                SECRUN secrun;

                if (!MftData->QueryLcnFromVcn(unreadable_vcn, &lcn)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT, "%I64x", unreadable_vcn);
                    return FALSE;
                }

                for (j = 0; j < cluster_size / QueryFrsSize(); j += sectors_per_frs) {

                    if (!hmem.Initialize() ||
                        !secrun.Initialize(&hmem, _drive,
                                           previous_lcn * QueryClusterFactor() + j,
                                           sectors_per_frs) ||
                        !secrun.Read()) {

                        continue;
                    }

                    secrun.Relocate(lcn * QueryClusterFactor() + j);

                    if (FixLevel != CheckOnly) {

                        PreWriteMultiSectorFixup(secrun.GetBuf(), QueryFrsSize());

                        secrun.Write();

                        PostReadMultiSectorFixup(secrun.GetBuf(), QueryFrsSize(), NULL);
                    }
                }
            }

            if (!fixed_frs_list.Add(file_number)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

        } else {

            // We couldn't hot fix it so we don't want it to ever be added
            // to the bad clusters file.

            for (j = 0; j < last_action.QueryCardinality().GetLowPart(); j++) {

                if (!BadClusterList->Remove(last_action.QueryNumber(j))) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }


            // If we couldn't fix one of the system files then scream.

            if (file_number < FIRST_USER_FILE_NUMBER) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_HOTFIX_SYSTEM_FILES,
                                    "%d", file_number.GetLowPart());
                return FALSE;
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_HOTFIX,
                                    "%d", file_number.GetLowPart());
            }
        }
    }

    if (!BadFrsList->Remove(&fixed_frs_list)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::AreBitmapsEqual(
    IN OUT  PNTFS_ATTRIBUTE BitmapAttribute,
    IN      PCNTFS_BITMAP   Bitmap,
    IN      BIG_INT         MinimumBitmapSize   OPTIONAL,
    IN OUT  PMESSAGE        Message,
    OUT     PBOOLEAN        CompleteFailure,
    OUT     PBOOLEAN        SecondIsSubset
    )
/*++

Routine Description:

    This routine compares these two bitmaps and returns whether
    or not they are equal.

    This routine will return FALSE if it cannot read all of the
    attribute pointed to by 'BitmapAttribute'.

Arguments:

    BitmapAttribute     - Supplies the bitmap attribute to compare.
    Bitmap              - Supplies the in memory bitmap to compare.
    MinimumBitmapSize   - Supplies the minimum number of bits
                            required in the bitmap.  All subsequent
                            bits must be zero.  If this parameter
                            is zero then both bitmaps must be the
                            same size.
    Message             - Supplies an outlet for messages.
    CompleteFailure     - Returns whether or not an unrecoverable
                            error occured while running.
    SecondIsSubset      - Returns TRUE if 'Bitmap' is has a
                            subset of the bits set by 'BitmapAttribute'.

Return Value:

    FALSE   - The bitmaps are not equal.
    TRUE    - The bitmaps are equal.

--*/
{
    CONST   MaxNumBytesToCompare    = 65536;

    ULONG   num_bytes, chomp_length, bytes_read, min_num_bytes, disk_bytes;
    ULONG   bytes_left;
    PUCHAR  attr_ptr, in_mem_ptr;
    PBYTE   p1, p2;
    ULONG   i, j;
    ULONG   debug_output_count = 0;

    *CompleteFailure = FALSE;

    if (SecondIsSubset) {
        *SecondIsSubset = TRUE;
    }

    in_mem_ptr = (PUCHAR) Bitmap->GetBitmapData(&num_bytes);
    disk_bytes = BitmapAttribute->QueryValueLength().GetLowPart();

    // The size of the on-disk bitmap must be a multiple of 8
    // bytes.

    if (disk_bytes % 8 != 0) {
        if (SecondIsSubset) {
            *SecondIsSubset = FALSE;
        }
        return FALSE;
    }

    // Compute the number of bytes that need to be compared.
    // Beyond this point, all bytes must be zero.

    if (MinimumBitmapSize == 0) {
        min_num_bytes = num_bytes;
    } else {
        min_num_bytes = ((MinimumBitmapSize - 1)/8 + 1).GetLowPart();
    }

    // If the minimum bitmap size is not defined or the given
    // value is greater than either of the operands then this
    // means that the bitmaps must really be equal, including
    // their lengths.

    if (MinimumBitmapSize == 0 ||
        min_num_bytes > num_bytes ||
        min_num_bytes > disk_bytes) {

        if (num_bytes != disk_bytes) {
            if (SecondIsSubset) {
                *SecondIsSubset = FALSE;
            }
            return FALSE;
        }

        min_num_bytes = num_bytes;
    }

    if (!(attr_ptr = NEW UCHAR[min(MaxNumBytesToCompare, min_num_bytes)])) {
        *CompleteFailure = TRUE;
        if (SecondIsSubset) {
            *SecondIsSubset = FALSE;
        }

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    for (i = 0; i < min_num_bytes; i += MaxNumBytesToCompare) {

        chomp_length = min(MaxNumBytesToCompare, min_num_bytes - i);

        // NOTE: these variables are used to avoid an optimization
        // bug in the compiler.  Before removing them, check that code
        // generated for the memcmp below is correct.
        //
        p1 = attr_ptr;
        p2 = &in_mem_ptr[i];

        if (!BitmapAttribute->Read(attr_ptr, i, chomp_length, &bytes_read) ||
            bytes_read != chomp_length) {

            if (SecondIsSubset) {
                *SecondIsSubset = FALSE;
            }

            DELETE(attr_ptr);
            return FALSE;
        }

        if (memcmp(p1, p2, chomp_length)) {

            for (j=0; j<chomp_length; j++) {
                if (p1[j] != p2[j]) {
                    if (debug_output_count++ < 20) {
                        DebugPrintTrace(("UNTFS: Bitmap Offset %x: %02x vs %02x\n", i+j, p1[j], p2[j]));
                    }
                }
            }

            if (SecondIsSubset) {
                for (j = 0; j < chomp_length; j++) {
                    if (~(~in_mem_ptr[i + j] | attr_ptr[j]) != 0) {
                        *SecondIsSubset = FALSE;
                    }
                }
            }

            DELETE(attr_ptr);
            return FALSE;
        }
    }
    if (debug_output_count > 20) {
        DebugPrintTrace(("UNTFS: Too much bitmap differences.  Output clipped.\n"));
    }


    DELETE(attr_ptr);

    // Make sure that everything after 'min_num_bytes' on both
    // bitmaps is zero.

    for (i = min_num_bytes; i < num_bytes; i++) {
        if (in_mem_ptr[i]) {

            if (SecondIsSubset) {
                *SecondIsSubset = FALSE;
            }

            return FALSE;
        }
    }

    // Read in the remainder of the on disk bitmap.

    bytes_left = disk_bytes - min_num_bytes;

    if (!bytes_left) {
        return TRUE;
    }

    if (!(attr_ptr = NEW UCHAR[bytes_left]) ||
        !BitmapAttribute->Read(attr_ptr, min_num_bytes,
                               bytes_left, &bytes_read) ||
        bytes_read != bytes_left) {

        if (SecondIsSubset) {
            *SecondIsSubset = FALSE;
        }

        DELETE(attr_ptr);
        return FALSE;
    }

    for (i = 0; i < bytes_left; i++) {
        if (attr_ptr[i]) {
            if (SecondIsSubset) {
                *SecondIsSubset = FALSE;
            }
            return FALSE;
        }
    }

    DELETE(attr_ptr);

    return TRUE;
}


BOOLEAN
NTFS_SA::SynchronizeMft(
    IN OUT  PNTFS_INDEX_TREE        RootIndex,
    IN      PNTFS_MASTER_FILE_TABLE InternalMft,
       OUT  PBOOLEAN                Errors,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message,
    IN      MessageMode             MsgMode
    )
/*++

Routine Description:

    This routine fixes the MFT file with the internal Mft.

Arguments:

    RootIndex   - Supplies the root index.
    InternalMft - Supplies the internal MFT.
    Errors      - Returns TRUE if errors has been found.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.
    MsgMode     - Supplies the type of messages that should be displayed.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    Any bad clusters discovered by this routine are marked in the volume
    bitmap but not added to the bad clusters file.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    mft_file;
    NTFS_FILE_RECORD_SEGMENT    bitmap_file;
    NTFS_ATTRIBUTE              disk_mft_data;
    NTFS_ATTRIBUTE              mft_bitmap_attribute;
    NTFS_ATTRIBUTE              volume_bitmap_attribute;
    PNTFS_ATTRIBUTE             mft_data;
    PNTFS_BITMAP                mft_bitmap;
    PNTFS_BITMAP                volume_bitmap;
    BOOLEAN                     replace;
    BOOLEAN                     convergence;
    ULONG                       i;
    NTFS_EXTENT_LIST            extents;
    NUMBER_SET                  bad_clusters;
    BOOLEAN                     complete_failure;
    BOOLEAN                     second_is_subset;
    BOOLEAN                     ErrorInAttribute;
    ULONG                       min_bits_in_mft_bitmap;


    DebugPtrAssert(InternalMft);
    DebugPtrAssert(Message);
    DebugPtrAssert(Errors);

    *Errors = FALSE;

    if (!bad_clusters.Initialize()) {
        DebugAssert("Could not initialize a bad clusters list");
        return FALSE;
    }

    mft_data = InternalMft->GetDataAttribute();
    mft_bitmap = InternalMft->GetMftBitmap();
    volume_bitmap = InternalMft->GetVolumeBitmap();

    DebugAssert(mft_data);
    DebugAssert(mft_bitmap);
    DebugAssert(volume_bitmap);

    if (!mft_file.Initialize(MASTER_FILE_TABLE_NUMBER, InternalMft) ||
        !bitmap_file.Initialize(BIT_MAP_FILE_NUMBER, InternalMft)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!mft_file.Read() || !bitmap_file.Read()) {
        DebugAbort("Previously readable FRS is unreadable");
        return FALSE;
    }

    convergence = FALSE;
    for (i = 0; !convergence; i++) {

        convergence = TRUE;


        // Do the MFT $DATA first.

        if (mft_file.QueryAttribute(&disk_mft_data, &ErrorInAttribute, $DATA)) {

            if (disk_mft_data == *mft_data) {
                replace = FALSE;
            } else {
                replace = TRUE;
            }
        } else if (ErrorInAttribute) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            replace = TRUE;
        }

        if (replace) {

            *Errors = TRUE;

            if (FixLevel != CheckOnly) {
                convergence = FALSE;
            }

            // We don't resize the disk MFT to zero because
            // this could clear bits that are now in use
            // by other attributes.

            if (!mft_data->MarkAsAllocated(volume_bitmap)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (i == 0) {
                switch (MsgMode) {
                    case UpdateMessage:
                        Message->DisplayMsg(MSG_CHK_NTFS_UPDATING_MFT_DATA);
                        break;

                    case CorrectMessage:
                        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_DATA);
                        break;
                }
            }

            if (!mft_data->InsertIntoFile(&mft_file, volume_bitmap)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !mft_file.Flush(volume_bitmap, RootIndex)) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", ROOT_FILE_NAME_INDEX_NUMBER);
                return FALSE;
            }
        }


        // Do the MFT $BITMAP next.

        if (mft_file.QueryAttribute(&mft_bitmap_attribute,
                                    &ErrorInAttribute, $BITMAP)) {

            min_bits_in_mft_bitmap =
            (mft_data->QueryValueLength()/mft_file.QuerySize()).GetLowPart();

            if (AreBitmapsEqual(&mft_bitmap_attribute, mft_bitmap,
                                min_bits_in_mft_bitmap,
                                Message, &complete_failure,
                                &second_is_subset)) {

                replace = FALSE;

            } else {

                if (complete_failure) {
                    return FALSE;
                }

                replace = TRUE;
            }
        } else if (ErrorInAttribute) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            replace = TRUE;
            second_is_subset = FALSE;

            // Create mft_bitmap_attribute.

            if (!extents.Initialize(0, 0) ||
                !mft_bitmap_attribute.Initialize(_drive,
                                                 QueryClusterFactor(),
                                                 &extents,
                                                 0, 0, $BITMAP)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                return FALSE;
            }
        }

        if (replace) {

            *Errors = TRUE;

            if (FixLevel != CheckOnly) {
                convergence = FALSE;
            }

            if (i == 0 || !second_is_subset) {

                switch (MsgMode) {
                    case CorrectMessage:
                        Message->DisplayMsg(second_is_subset ?
                                            MSG_CHK_NTFS_MINOR_MFT_BITMAP_ERROR :
                                            MSG_CHK_NTFS_CORRECTING_MFT_BITMAP);
                        break;

                    case UpdateMessage:
                        Message->DisplayMsg(MSG_CHK_NTFS_UPDATING_MFT_BITMAP);
                        break;
                }
            }

            if (FixLevel != CheckOnly &&
                (!mft_bitmap_attribute.MakeNonresident(volume_bitmap) ||
                 !mft_bitmap->Write(&mft_bitmap_attribute, volume_bitmap))) {

                if (!mft_bitmap_attribute.RecoverAttribute(volume_bitmap,
                                                           &bad_clusters) ||
                    !mft_bitmap->Write(&mft_bitmap_attribute, volume_bitmap)) {

                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                    return FALSE;
                }
            }

            if (mft_bitmap_attribute.IsStorageModified() &&
                !mft_bitmap_attribute.InsertIntoFile(&mft_file,
                                                       volume_bitmap)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !mft_file.Flush(volume_bitmap, RootIndex)) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", ROOT_FILE_NAME_INDEX_NUMBER);
                return FALSE;
            }
        }

        // Do the volume bitmap next.

        if (bitmap_file.QueryAttribute(&volume_bitmap_attribute,
                                     &ErrorInAttribute, $DATA)) {

//            DebugPrintTrace(("Comparing volume bitmap\n"));

            if (AreBitmapsEqual(&volume_bitmap_attribute, volume_bitmap, 0,
                                Message, &complete_failure,
                                &second_is_subset)) {

                replace = FALSE;

            } else {

                if (complete_failure) {
                    return FALSE;
                }

                replace = TRUE;
            }
        } else if (ErrorInAttribute) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            replace = TRUE;
            second_is_subset = FALSE;

            // Create mft_bitmap_attribute.

            if (!extents.Initialize(0, 0) ||
                !volume_bitmap_attribute.Initialize(_drive,
                                                    QueryClusterFactor(),
                                                    &extents,
                                                    0, 0, $DATA)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_VOLUME_BITMAP);
                return FALSE;
            }
        }

        if (replace) {

            *Errors = TRUE;

            if (FixLevel != CheckOnly) {
                convergence = FALSE;
            }

            if (i == 0 || !second_is_subset) {

                switch (MsgMode) {
                    case CorrectMessage:
                        Message->DisplayMsg(second_is_subset ?
                                            MSG_CHK_NTFS_MINOR_VOLUME_BITMAP_ERROR :
                                            MSG_CHK_NTFS_CORRECTING_VOLUME_BITMAP);
                        break;

                    case UpdateMessage:
                        Message->DisplayMsg(MSG_CHK_NTFS_UPDATING_VOLUME_BITMAP);
                }
            }

            if (FixLevel != CheckOnly &&
                (!volume_bitmap_attribute.MakeNonresident(volume_bitmap) ||
                 !volume_bitmap->Write(&volume_bitmap_attribute,
                                       volume_bitmap))) {

                if (!volume_bitmap_attribute.RecoverAttribute(volume_bitmap,
                                                              &bad_clusters) ||
                    !volume_bitmap->Write(&volume_bitmap_attribute,
                                          volume_bitmap)) {

                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_VOLUME_BITMAP);
                    return FALSE;
                }
            }

            if (volume_bitmap_attribute.IsStorageModified() &&
                !volume_bitmap_attribute.InsertIntoFile(&bitmap_file,
                                                        volume_bitmap)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !bitmap_file.Flush(volume_bitmap, RootIndex)) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", ROOT_FILE_NAME_INDEX_NUMBER);
                return FALSE;
            }
        }
    }

    if (FixLevel != CheckOnly) {
        if (!mft_file.Flush(NULL, RootIndex) ||
            !bitmap_file.Flush(NULL, RootIndex)) {
            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                "%d", ROOT_FILE_NAME_INDEX_NUMBER);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::ResetLsns(
    IN OUT  PMESSAGE                Message,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      BOOLEAN                 SkipRootIndex
    )
/*++

Routine Description:

    This method sets all the LSN's on the volume to zero.

Arguments:

    Message         --  Supplies an outlet for messages.
    Mft             --  Supplies the volume's Master File Table.
    SkipRootIndex   --  Supplies a flag which indicates, if TRUE,
                        that the root index FRS and index should
                        be skipped.  In that case, the client is
                        responsible for resetting the LSN's on
                        those items.
--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_INDEX_TREE             index;
    NTFS_ATTRIBUTE              index_root;
    ULONG                       i, j, n, frs_size, num_frs_per_prime;
    ULONG                       percent_done = 0;
    BOOLEAN                     error_in_attribute;

    Message->DisplayMsg(MSG_CHK_NTFS_RESETTING_LSNS);

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0)) {
        return FALSE;
    }

    // Compute the number of file records.
    //
    frs_size = Mft->QueryFrsSize();

    n = (Mft->GetDataAttribute()->QueryValueLength()/frs_size).GetLowPart();
    num_frs_per_prime = MFT_PRIME_SIZE/frs_size;

    for (i = 0; i < n; i += 1) {

        if (i*100/n != percent_done) {
            percent_done = (i*100/n);
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i % num_frs_per_prime == 0) {
            Mft->GetDataAttribute()->PrimeCache(i*frs_size,
                                                num_frs_per_prime*frs_size);
        }

        // if specified, skip the root file index
        //
        if (SkipRootIndex && i == ROOT_FILE_NAME_INDEX_NUMBER) {

            continue;
        }

        if (!frs.Initialize(i, Mft)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // If the FRS is unreadable or is not in use, skip it.
        //
        if (!frs.Read() || !frs.IsInUse()) {

            continue;
        }

        frs.SetLsn( 0 );
        frs.Write();

        // Iterate through all the indices present in this FRS
        // (if any), resetting LSN's on all of them.
        //
        error_in_attribute = FALSE;

        for (j = 0; frs.QueryAttributeByOrdinal( &index_root,
                                                 &error_in_attribute,
                                                 $INDEX_ROOT,
                                                 j ); j++) {

            if (!index.Initialize(_drive,
                                  QueryClusterFactor(),
                                  Mft->GetVolumeBitmap(),
                                  Mft->GetUpcaseTable(),
                                  frs.QuerySize()/2,
                                  &frs,
                                  index_root.GetName()) ||
                !index.ResetLsns(Message)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (error_in_attribute) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_SA::FindHighestLsn(
    IN OUT  PMESSAGE                Message,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    OUT     PLSN                    HighestLsn
    )
/*++

Routine Description:

    This function traverses the volume to find the highest LSN
    on the volume.  It is currently unused, but had previously
    been a worker for ResizeCleanLogFile().

Arguments:

    Message     --  Supplies an outlet for messages.
    Mft         --  Supplies the volume Master File Table.
    HighestLsn  --  Receives the highest LSN found on the volume.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_INDEX_TREE             index;
    NTFS_ATTRIBUTE              index_root;
    LSN                         HighestLsnInIndex;
    ULONG                       i, j, n, frs_size, num_frs_per_prime;
    ULONG                       percent_done = 0;
    BOOLEAN                     error_in_attribute;

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0)) {
        return FALSE;
    }

    // Compute the number of file records.
    //
    frs_size = Mft->QueryFrsSize();

    n = (Mft->GetDataAttribute()->QueryValueLength()/frs_size).GetLowPart();
    num_frs_per_prime = MFT_PRIME_SIZE/frs_size;

    for (i = 0; i < n; i += 1) {

        if (i*100/n != percent_done) {
            percent_done = (i*100/n);
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i % num_frs_per_prime == 0) {
            Mft->GetDataAttribute()->PrimeCache(i*frs_size,
                                                num_frs_per_prime*frs_size);
        }

        if (!frs.Initialize(i, Mft)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // If the FRS is unreadable or is not in use, skip it.
        //
        if (!frs.Read() || !frs.IsInUse()) {

            continue;
        }

        if (frs.QueryLsn() > *HighestLsn) {

            *HighestLsn = frs.QueryLsn();
        }

        // Iterate through all the indices present in this FRS
        // (if any), resetting LSN's on all of them.
        //
        error_in_attribute = FALSE;

        for (j = 0; frs.QueryAttributeByOrdinal( &index_root,
                                                 &error_in_attribute,
                                                 $INDEX_ROOT,
                                                 j ); j++) {

            if (!index.Initialize(_drive,
                                  QueryClusterFactor(),
                                  Mft->GetVolumeBitmap(),
                                  Mft->GetUpcaseTable(),
                                  frs.QuerySize()/2,
                                  &frs,
                                  index_root.GetName()) ||
                !index.FindHighestLsn(Message, &HighestLsnInIndex)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (HighestLsnInIndex > *HighestLsn) {

                *HighestLsn = HighestLsnInIndex;
            }
        }

        if (error_in_attribute) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    return TRUE;

}


BOOLEAN
NTFS_SA::ResizeCleanLogFile(
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExplicitResize,
    IN      ULONG       DesiredSize
    )
/*++

Routine Description:

    This method resizes the log file to its default size.   It may
    be used only when the volume has been shut down cleanly.

Arguments:

    Message         - Supplies an outlet for messages.
    ExplicitResize  - Tells whether this is just the default check, or
                      if the user explicitly asked for a resize.  If FALSE, the
                      logfile will be resized only if it is wildly out of
                      whack.  If TRUE, the logfile will be resized to
                      the desired size.
    DesiredSize     - Supplies the desired size, or zero if the user just
                      wants to query the current size.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_BITMAP         VolumeBitmap;
    NTFS_UPCASE_TABLE   UpcaseTable;

    NTFS_UPCASE_FILE    UpcaseFile;
    NTFS_BITMAP_FILE    BitmapFile;
    NTFS_MFT_FILE       MftFile;
    NTFS_LOG_FILE       LogFile;
    NTFS_FILE_RECORD_SEGMENT MftMirror;

    NTFS_ATTRIBUTE      UpcaseAttribute;
    NTFS_ATTRIBUTE      BitmapAttribute;
    NTFS_ATTRIBUTE      MirrorAttribute;

    HMEM                MirrorMem;

    LSN                 HighestLsn;
    BIG_INT             BigZero, TempBigInt;
    BIG_INT             FreeSectorSize;
    ULONG               MirrorSize, BytesTransferred;
    BOOLEAN             error, LogFileGrew, Changed;

    ULONG               current_size;
    NTFS_ATTRIBUTE      attrib;

    ULONG               volume_flags;
    UCHAR               major, minor;
    BOOLEAN             corrupt_volume;
    LSN                 lsn;

    // If we're just doing the usual check and not an explicitly-asked for
    // resize, do a quick check to see if there's anything to do.
    //

    if (!ExplicitResize) {
        if (!LogFileMayNeedResize()) {
            return TRUE;
        } else {
            DesiredSize = NTFS_LOG_FILE::QueryDefaultSize(_drive, QueryVolumeSectors());
        }
    }

    // Initialize the bitmap, fetch the MFT, and read the bitmap
    // and upcase table.
    //

    if (!VolumeBitmap.Initialize( QueryVolumeSectors()/QueryClusterFactor(),
                                  FALSE, _drive, QueryClusterFactor() ) ||
        !MftFile.Initialize( _drive,
                             QueryMftStartingLcn(),
                             QueryClusterFactor(),
                             QueryFrsSize(),
                             QueryVolumeSectors(),
                             &VolumeBitmap,
                             NULL ) ||
        !MftFile.Read() ||
        MftFile.GetMasterFileTable() == NULL ||
        !BitmapFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BitmapFile.Read() ||
        !BitmapFile.QueryAttribute( &BitmapAttribute, &error, $DATA ) ||
        !VolumeBitmap.Read( &BitmapAttribute ) ||
        !UpcaseFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !UpcaseFile.Read() ||
        !UpcaseFile.QueryAttribute( &UpcaseAttribute, &error, $DATA ) ||
        !UpcaseTable.Initialize( &UpcaseAttribute ) ) {

        return FALSE;
    }

    MftFile.SetUpcaseTable( &UpcaseTable );
    MftFile.GetMasterFileTable()->SetUpcaseTable( &UpcaseTable );

    // Initialize and read the log file.  Make sure the volume
    // was shut down cleanly.
    //

    if (!LogFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !LogFile.Read()) {

        return FALSE;
    }

    if (!LogFile.QueryAttribute( &attrib, &error, $DATA )) {
        return FALSE;
    }

    current_size = attrib.QueryValueLength().GetLowPart();

    if (DesiredSize > current_size) {
        FreeSectorSize = VolumeBitmap.QueryFreeClusters() * QueryClusterFactor();
        if (((DesiredSize-current_size-1)/_drive->QuerySectorSize()+1) > FreeSectorSize) {

            Message->DisplayMsg( ExplicitResize ?
                                    MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_BIG :
                                    MSG_CHK_NTFS_OUT_OF_SPACE_TO_ENLARGE_LOGFILE_TO_DEFAULT_SIZE );
            return FALSE;
        }
    }

    if (ExplicitResize && 0 == DesiredSize) {

        ULONG default_size;

        // The user just wants to query the current logfile size.  Do
        // that and exit.  Also print the default logfile size for this
        // volume.
        //

        current_size = current_size / 1024;
        default_size = LogFile.QueryDefaultSize( _drive, QueryVolumeSectors() ) / 1024;

        Message->DisplayMsg(MSG_CHK_NTFS_LOGFILE_SIZE,
                            "%d%d", current_size, default_size );

        return TRUE;
    }

    if (ExplicitResize &&
        DesiredSize < LogFile.QueryMinimumSize( _drive, QueryVolumeSectors() )) {

        Message->DisplayMsg(MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_SMALL);
        return FALSE;
    }

    // Resize the logfile.
    //
    volume_flags = QueryVolumeFlagsAndLabel(&corrupt_volume, &major, &minor);

    if (corrupt_volume ||
        (volume_flags & VOLUME_DIRTY) ||
        !LogFile.EnsureCleanShutdown(&lsn)) {

        DebugPrintTrace(("CorruptFlag %x, VolumeFlag %x\n", corrupt_volume, volume_flags));

        Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOGFILE_BUT_DIRTY);
        return FALSE;
    }

    if (!LogFile.Resize( DesiredSize, &VolumeBitmap, FALSE, &Changed,
                         &LogFileGrew, Message )) {

        return FALSE;
    }

    if (!Changed) {

        // The log file was already the correct size.
        //
        return TRUE;
    }

    // If the log file is growing, write the volume bitmap
    // before flushing the log file frs; if it's shrinking, write
    // the bitmap after flushing the log file frs.  That way, if
    // the second operation (either writing the log file FRS or
    // the bitmap) fails, the only bitmap errors will be free
    // space marked as allocated.
    //
    // Since this is a fixed-size, non-resident attribute, writing
    // it doesn't change its  File Record Segment.
    //

    if (LogFileGrew && !VolumeBitmap.Write( &BitmapAttribute, NULL )) {

        return FALSE;
    }

    // Flush the log file.  Since the log file never has
    // external attributes, flushing it won't change the MFT.
    // Note that the index entry for the log file is not updated.
    //

    if (!LogFile.Flush( NULL, NULL )) {

        return FALSE;
    }

    //  If we didn't already, write the volume bitmap.
    //

    if (!LogFileGrew && !VolumeBitmap.Write( &BitmapAttribute, NULL )) {

        return FALSE;
    }

    // Clear the Resize Log File bit in the Volume DASD file.
    // Note that the log file is already marked as Checked.
    //

    BigZero = 0;
    ClearVolumeFlag( VOLUME_RESIZE_LOG_FILE,
                     &LogFile, TRUE, lsn, &corrupt_volume );

    // Update the MFT Mirror.
    //

    MirrorSize = REFLECTED_MFT_SEGMENTS * MftFile.QuerySize();

    if (!MirrorMem.Initialize() ||
        !MirrorMem.Acquire( MirrorSize ) ||
        !MftMirror.Initialize( MASTER_FILE_TABLE2_NUMBER, &MftFile ) ||
        !MftMirror.Read() ||
        !MftMirror.QueryAttribute( &MirrorAttribute, &error, $DATA ) ||
        !MftFile.GetMasterFileTable()->
            GetDataAttribute()->Read( MirrorMem.GetBuf(), 0,
                                        MirrorSize, &BytesTransferred ) ||
        BytesTransferred != MirrorSize ||
        !MirrorAttribute.Write( MirrorMem.GetBuf(), 0, MirrorSize,
                                        &BytesTransferred, NULL ) ||
        BytesTransferred != MirrorSize) {

        DebugPrintTrace(("UNTFS: Error updating MFT Mirror.\n"));
        // but don't return FALSE, since we've changed the log file.
    }


#if defined( _AUTOCHECK_ )

    // If this is AUTOCHK and we're running on the boot partition then
    // we should reboot so that the cache doesn't stomp on us.

    DSTRING sdrive, canon_sdrive, canon_drive;

    FSTRING boot_log_file_name;

    if (IFS_SYSTEM::QueryNtSystemDriveName(&sdrive) &&
        IFS_SYSTEM::QueryCanonicalNtDriveName(&sdrive, &canon_sdrive) &&
        IFS_SYSTEM::QueryCanonicalNtDriveName(_drive->GetNtDriveName(),
                                              &canon_drive) &&
        !canon_drive.Stricmp(&canon_sdrive)) {

        Message->DisplayMsg(MSG_CHK_BOOT_PARTITION_REBOOT);

        boot_log_file_name.Initialize( L"bootex.log" );

        if (Message->IsLoggingEnabled() &&
            !DumpMessagesToFile( &boot_log_file_name,
                                 &MftFile,
                                 Message )) {

            DebugPrintTrace(("UNTFS: Error writing messages to BOOTEX.LOG\n"));
        }

        IFS_SYSTEM::Reboot();
    }

#endif

    return TRUE;
}

BOOLEAN
EnsureValidFileAttributes(
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN OUT  PNTFS_INDEX_TREE            ParentIndex,
       OUT  PBOOLEAN                    SaveIndex,
    IN      ULONG                       FileAttributes,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This routine makes sure the FileAttributes in the given
    Frs has the hidden and system flags set but not the read-only
    bit.

Arguments:

    Frs          - Supplies the frs to examine
    ParentIndex  - Supplies the parent index of the given Frs
    SaveIndex    - Supplies whether there is a need to save the
                   parent index
    FileAttributes
                 - Supplies extra bits that should be set
    ChkdskInfo   - Supplies the current chkdsk info.
    Mft          - Supplies the MFT.
    FixLevel     - Supplies the fix level.
    Message      - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTANDARD_INFORMATION2  pstandard;
    NTFS_ATTRIBUTE          attrib;
    BOOLEAN                 error;
    ULONG                   file_attributes;
    ULONG                   old_file_attributes;
    PINDEX_ENTRY            foundEntry;
    PNTFS_INDEX_BUFFER      containingBuffer;
    ULONG                   num_bytes;
    ULONG                   length;
    PFILE_NAME              pfile_name;
    ULONG                   errFixedStatus = CHKDSK_EXIT_SUCCESS;

    //
    // Check the FileAttributes in $STANDARD_INFORMATION first
    //

    if (!Frs->QueryAttribute(&attrib, &error, $STANDARD_INFORMATION)) {
        DebugPrintTrace(("Unable to locate $STANDARD_INFORMATION attribute of file %d\n",
                    Frs->QueryFileNumber().GetLowPart()));
        return FALSE;
    }

    pstandard = (PSTANDARD_INFORMATION2)attrib.GetResidentValue();
    if (!pstandard) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_attributes = pstandard->FileAttributes;
    if (!(file_attributes & FAT_DIRENT_ATTR_HIDDEN) ||
        ((file_attributes & FileAttributes) != FileAttributes) ||
        !(file_attributes & FAT_DIRENT_ATTR_SYSTEM) ||
        (file_attributes & FAT_DIRENT_ATTR_READ_ONLY)) {

        file_attributes &= ~FAT_DIRENT_ATTR_READ_ONLY;
        file_attributes |= FAT_DIRENT_ATTR_HIDDEN |
                          FAT_DIRENT_ATTR_SYSTEM |
                          FileAttributes;

        Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_FILE_ATTR,
                     "%x%x%I64x",
                     pstandard->FileAttributes,
                     file_attributes,
                     Frs->QueryFileNumber().GetLargeInteger());

        pstandard->FileAttributes = file_attributes;

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                            "%d", Frs->QueryFileNumber().GetLowPart());

        DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

        if (FixLevel != CheckOnly &&
            (!attrib.Write((PVOID)pstandard,
                           0,
                           attrib.QueryValueLength().GetLowPart(),
                           &num_bytes,
                           Mft->GetVolumeBitmap()) ||
             num_bytes != attrib.QueryValueLength().GetLowPart())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                "%d%d", attrib.QueryTypeCode(),
                                Frs->QueryFileNumber().GetLowPart());
            return FALSE;
        }

        if (FixLevel != CheckOnly && attrib.IsStorageModified() &&
            !attrib.InsertIntoFile(Frs, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                "%d%d", attrib.QueryTypeCode(),
                                Frs->QueryFileNumber().GetLowPart());
            return FALSE;
        }

        //
        // Now update the FileAttributes in DUPLICATED_INFORMATION in $FILE_NAME
        //

        if (!Frs->QueryAttribute(&attrib, &error, $FILE_NAME)) {
            DebugPrintTrace(("Unable to locate $FILE_NAME attribute of file %d\n",
                        Frs->QueryFileNumber().GetLowPart()));
            return FALSE;
        }

        DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);
        length = attrib.QueryValueLength().GetLowPart();
        if (!(pfile_name = (PFILE_NAME)MALLOC(length))) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!attrib.Read(pfile_name, 0, length, &num_bytes) ||
            num_bytes != length) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(pfile_name);
            return FALSE;
        }

        old_file_attributes = pfile_name->Info.FileAttributes;
        pfile_name->Info.FileAttributes = file_attributes;
        if (!attrib.Write(pfile_name, 0, length, &num_bytes,
                          Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                "%d%d", attrib.QueryTypeCode(),
                                Frs->QueryFileNumber().GetLowPart());
            FREE(pfile_name);
            return FALSE;
        }

        //
        // Finally, delete the $FILE_NAME entry in the index
        // so that it will get updated later on
        //

        pfile_name->Info.FileAttributes = old_file_attributes;

        if (ParentIndex->QueryEntry(length,
                                    pfile_name,
                                    0,
                                    &foundEntry,
                                    &containingBuffer,
                                    &error)) {

            if (!ParentIndex->DeleteEntry(length, pfile_name, 0)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(pfile_name);
                return FALSE;
            }
            *SaveIndex = TRUE;

        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(pfile_name);
            return FALSE;
        }

        FREE(pfile_name);

        if (FixLevel != CheckOnly && !Frs->Flush(NULL)) {
            if (ChkdskInfo->ObjectIdFileNumber == Frs->QueryFileNumber())
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            else if (ChkdskInfo->QuotaFileNumber == Frs->QueryFileNumber())
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            else if (ChkdskInfo->UsnJournalFileNumber == Frs->QueryFileNumber())
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
            else if (ChkdskInfo->ReparseFileNumber == Frs->QueryFileNumber())
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            else
                DebugAssert(FALSE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
GetSystemFileName(
    IN      UCHAR       Major,
    IN      VCN         FileNumber,
       OUT  PWSTRING    FileName,
       OUT  PBOOLEAN    NoName
    )
/*++

Routine Description:

    This routine returns the name of the system file corresponding
    to the given FileNumber.

Arguments:

    Major        - Supplies the major volume revision
    FileNumber   - Supplies the system FRS file number
    FileName     - Returns the name of the system file
    NoName       - TRUE if FileNumber is one of the system file number

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN     r;

    *NoName = FALSE;

    if (FileNumber        == MASTER_FILE_TABLE_NUMBER    ) {
        r = FileName->Initialize("$MFT");

    } else if (FileNumber == MASTER_FILE_TABLE2_NUMBER   ) {
        r = FileName->Initialize("$MFTMirr");

    } else if (FileNumber == LOG_FILE_NUMBER             ) {
        r = FileName->Initialize("$LogFile");

    } else if (FileNumber == VOLUME_DASD_NUMBER          ) {
        r = FileName->Initialize("$Volume");

    } else if (FileNumber == ATTRIBUTE_DEF_TABLE_NUMBER  ) {
        r = FileName->Initialize("$AttrDef");

    } else if (FileNumber == ROOT_FILE_NAME_INDEX_NUMBER ) {
        r = FileName->Initialize(".");

    } else if (FileNumber == BIT_MAP_FILE_NUMBER         ) {
        r = FileName->Initialize("$Bitmap");

    } else if (FileNumber == BOOT_FILE_NUMBER            ) {
        r = FileName->Initialize("$Boot");

    } else if (FileNumber == BAD_CLUSTER_FILE_NUMBER     ) {
        r = FileName->Initialize("$BadClus");

    } else if (FileNumber == SECURITY_TABLE_NUMBER && Major >= 2) {
        r = FileName->Initialize("$Secure");

    } else if (FileNumber == QUOTA_TABLE_NUMBER && Major <= 1) {
        r = FileName->Initialize("$Quota");

    } else if (FileNumber == UPCASE_TABLE_NUMBER         ) {
        r = FileName->Initialize("$UpCase");

    } else if (FileNumber == EXTEND_TABLE_NUMBER && Major >= 2) {
        r = FileName->Initialize("$Extend");

    } else {
        r = *NoName = TRUE;

    }
    return r;
}

VOID
QueryFileNameFromIndex(
    IN      PFILE_NAME  P,
       OUT  PWCHAR      Buffer,
    IN      CHNUM       BufferLength
    )
{
    UCHAR           len, i;

    DebugAssert(P);
    DebugAssert(Buffer);
    DebugAssert(P->FileNameLength <= 0xff || BufferLength <= 0x100);
    DebugAssert(P->FileNameLength <= 0xff);

    len = (UCHAR)min(BufferLength-1, P->FileNameLength);
    for (i=0; i < len; i++)
        Buffer[i] = P->FileName[i];
    Buffer[i] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\rasd.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    rasd.cxx

Abstract:

    This module implements the read ahead algorithm for the
    security descriptor verification stage of chkdsk.

Author:

    Daniel Chan (danielch) 09-Dec-98

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"
#include "rasd.hxx"

PNTFS_SA                    RA_PROCESS_SD::_sa;
ULONG64                     RA_PROCESS_SD::_total_number_of_frs;
PVCN                        RA_PROCESS_SD::_first_frs_number;
PULONG                      RA_PROCESS_SD::_number_of_frs_to_read;
PNTFS_FILE_RECORD_SEGMENT   RA_PROCESS_SD::_frs1;
PNTFS_FILE_RECORD_SEGMENT   RA_PROCESS_SD::_frs2;
HANDLE                      RA_PROCESS_SD::_read_ahead_event;
HANDLE                      RA_PROCESS_SD::_read_ready_event;
PNTFS_MASTER_FILE_TABLE     RA_PROCESS_SD::_mft;

DEFINE_EXPORTED_CONSTRUCTOR( RA_PROCESS_SD, OBJECT, UNTFS_EXPORT );

BOOLEAN
NTFS_SA::StartProcessingSD(
    IN      BIG_INT                  TotalNumberOfFrs,
    IN      FIX_LEVEL                FixLevel,
    IN OUT  PNTFS_MASTER_FILE_TABLE  Mft,
    IN OUT  PNTFS_CHKDSK_REPORT      ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO        ChkdskInfo,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT SecurityFrs,
    IN OUT  PNUMBER_SET              BadClusters,
    IN OUT  PULONG                   ErrFixedStatus,
    IN      BOOLEAN                  SecurityDescriptorStreamPresent,
    IN OUT  PNUMBER_SET              SidEntries,
    IN OUT  PNUMBER_SET              SidEntries2,
    IN OUT  PBOOLEAN                 HasErrors,
    IN      BOOLEAN                  SkipEntriesScan,
    IN OUT  PBOOLEAN                 ChkdskErrCouldNotFix,
    IN OUT  PMESSAGE                 Message
)
/*++

Routine Description:

    This routine initializes all the synchronization objects,
    creates the read-ahead thread, and start the processing
    routine.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FixLevel         - Supplies the fix level.
    Mft              - Supplies a valid MFT.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    SecurityFrs      - Supplies the initialized security frs.
    BadClusters      - Receives the bad clusters identified by this method.
    ErrFixedStatus   - Supplies & receives whether errors have been fixed.
    SecurityDescriptorStreamPresent
                     - Supplies whether there is a security descriptor stream.
    SidEntries       - Supplies the set of security ids found in the security descriptor stream.
    SidEntries2      - Receives the set of security ids that is in use.
    HasErrors        - Receives whether there is any error found.
    SkipEntriesScan  - Supplies whether index entries scan were skipped earlier.
    ChkdskErrCoundNotFix
                     - Receives whehter there is error that could not be fixed.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    RA_PROCESS_SD               ra_process_sd;
    HANDLE                      thread_handle;
    NTFS_FILE_RECORD_SEGMENT    frs1, frs2;
    HANDLE                      read_ahead_event;
    HANDLE                      read_ready_event;
    VCN                         first_frs_number;
    ULONG                       number_of_frs_to_read;
    BOOLEAN                     status;

    NTSTATUS                    ntstatus;
    LARGE_INTEGER               timeout;
    THREAD_BASIC_INFORMATION    basic_info;
    SYSTEM_BASIC_INFORMATION    system_basic_info;
    OBJECT_ATTRIBUTES           objAttr;


    if (TotalNumberOfFrs == 0)
        return TRUE;

    ntstatus = NtQuerySystemInformation(SystemBasicInformation,
                                        &system_basic_info,
                                        sizeof(system_basic_info),
                                        NULL);

    if (!NT_SUCCESS(ntstatus)) {
        // assume single proc and proceed
        DebugPrintTrace(("UNTFS: Unable to determine number of processors.  Assume one.\n"));
        system_basic_info.NumberOfProcessors = 1;
    }

    if (system_basic_info.NumberOfProcessors == 1) {

        // if UP then use single thread approach

        return ProcessSD2(TotalNumberOfFrs,
                          FixLevel,
                          Mft,
                          ChkdskReport,
                          ChkdskInfo,
                          SecurityFrs,
                          BadClusters,
                          ErrFixedStatus,
                          SecurityDescriptorStreamPresent,
                          SidEntries,
                          SidEntries2,
                          HasErrors,
                          SkipEntriesScan,
                          ChkdskErrCouldNotFix,
                          Message);
    }

    // create the read ahead event which signals when the read ahead thread should start reading

    InitializeObjectAttributes(&objAttr,
                               NULL,
                               0L,
                               NULL,
                               NULL);

    ntstatus = NtCreateEvent(&read_ahead_event,
                             EVENT_ALL_ACCESS,
                             &objAttr,
                             SynchronizationEvent,
                             FALSE                  // initial state
                             );

    if (!NT_SUCCESS(ntstatus)) {

        DebugPrintTrace(("UNTFS: Unable to create read ahead event (%x)\n", ntstatus));

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    // create the read ready event which signals when the read is completed

    ntstatus = NtCreateEvent(&read_ready_event,
                             EVENT_ALL_ACCESS,
                             &objAttr,
                             SynchronizationEvent,
                             FALSE                  // initial state
                             );

    if (!NT_SUCCESS(ntstatus)) {

        NtClose(read_ahead_event);

        DebugPrintTrace(("UNTFS: Unable to create read ready event (%x)\n", ntstatus));

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    RA_PROCESS_SD::Initialize(this,
                              TotalNumberOfFrs,
                              &first_frs_number,
                              &number_of_frs_to_read,
                              &frs1,
                              &frs2,
                              read_ahead_event,
                              read_ready_event,
                              Mft);

    // create the read ahead thread

    ntstatus = RtlCreateUserThread(NtCurrentProcess(),
                                   NULL,
                                   FALSE,
                                   0,
                                   0,
                                   0,
                                   RA_PROCESS_SD::ProcessSDWrapper,
                                   &ra_process_sd,
                                   &thread_handle,
                                   NULL);

    if (!NT_SUCCESS(ntstatus)) {

        NtClose(read_ahead_event);
        NtClose(read_ready_event);

        Message->DisplayMsg(MSG_CHK_UNABLE_TO_CREATE_THREAD, "%x", ntstatus);
        return FALSE;
    }

    status = ProcessSD(TotalNumberOfFrs,
                       &first_frs_number,
                       &number_of_frs_to_read,
                       &frs1,
                       &frs2,
                       read_ahead_event,
                       read_ready_event,
                       thread_handle,
                       FixLevel,
                       Mft,
                       ChkdskReport,
                       ChkdskInfo,
                       SecurityFrs,
                       BadClusters,
                       ErrFixedStatus,
                       SecurityDescriptorStreamPresent,
                       SidEntries,
                       SidEntries2,
                       HasErrors,
                       SkipEntriesScan,
                       ChkdskErrCouldNotFix,
                       Message);

    //
    // Clean up the read ahead thread if it is still alive
    //
    number_of_frs_to_read = 0;
    ntstatus = NtSetEvent(read_ahead_event, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: Unable to set read ahead event (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    // wait for the read ahead thread to terminate

    timeout.QuadPart = -2000000000;     // 200 seconds
    ntstatus = NtWaitForSingleObject(thread_handle, FALSE, &timeout);
    if (ntstatus != STATUS_WAIT_0) {
        DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    // check the exit code of the read ahead thread

    ntstatus = NtQueryInformationThread(thread_handle,
                                        ThreadBasicInformation,
                                        &basic_info,
                                        sizeof(basic_info),
                                        NULL);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: NtQueryInformationThread failed (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    if (!NT_SUCCESS(basic_info.ExitStatus)) {
        DebugPrintTrace(("Premature termination of files read ahead thread (%x)\n", basic_info.ExitStatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    NtClose(read_ahead_event);
    NtClose(read_ready_event);
    NtClose(thread_handle);

    return status;
}

UNTFS_EXPORT
RA_PROCESS_SD::~RA_PROCESS_SD(
)
{
    Destroy();
}

VOID
RA_PROCESS_SD::Construct(
)
{
}

VOID
RA_PROCESS_SD::Destroy(
)
{
}

NTSTATUS
RA_PROCESS_SD::ProcessSDWrapper(
    IN OUT PVOID      lpParameter
)
{
    return  RA_PROCESS_SD::GetSa()->SDReadAhead(RA_PROCESS_SD::GetTotalNumberOfFrs(),
                                                RA_PROCESS_SD::GetFirstFrsNumber(),
                                                RA_PROCESS_SD::GetNumberOfFrsToRead(),
                                                RA_PROCESS_SD::GetFrs1(),
                                                RA_PROCESS_SD::GetFrs2(),
                                                RA_PROCESS_SD::GetReadAheadEvent(),
                                                RA_PROCESS_SD::GetReadReadyEvent(),
                                                RA_PROCESS_SD::GetMft());
}

BOOLEAN
RA_PROCESS_SD::Initialize(
    IN      PNTFS_SA                    Sa,
    IN      BIG_INT                     TotalNumberOfFrs,
    IN      PVCN                        FirstFrsNumber,
    IN      PULONG                      NumberOfFrsToRead,
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs1,
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs2,
    IN      HANDLE                      ReadAheadEvent,
    IN      HANDLE                      ReadReadyEvent,
    IN      PNTFS_MASTER_FILE_TABLE     Mft
)
{
    _sa = Sa;
    _total_number_of_frs = TotalNumberOfFrs.GetQuadPart();
    _first_frs_number = FirstFrsNumber;
    _number_of_frs_to_read = NumberOfFrsToRead;
    _frs1 = Frs1;
    _frs2 = Frs2;
    _read_ahead_event = ReadAheadEvent;
    _read_ready_event = ReadReadyEvent;
    _mft = Mft;

    return TRUE;
}

BOOLEAN
NTFS_SA::ProcessSD(
    IN      BIG_INT                   TotalNumberOfFrs,
       OUT  PVCN                      FirstFrsNumber,
       OUT  PULONG                    NumberOfFrsToRead,
    IN      PNTFS_FILE_RECORD_SEGMENT Frs1,
    IN      PNTFS_FILE_RECORD_SEGMENT Frs2,
    IN      HANDLE                    ReadAheadEvent,
       OUT  HANDLE                    ReadReadyEvent,
    IN      HANDLE                    ThreadHandle,
    IN      FIX_LEVEL                 FixLevel,
    IN OUT  PNTFS_MASTER_FILE_TABLE   Mft,
    IN OUT  PNTFS_CHKDSK_REPORT       ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO         ChkdskInfo,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT SecurityFrs,
    IN OUT  PNUMBER_SET               BadClusters,
    IN OUT  PULONG                    ErrFixedStatus,
    IN      BOOLEAN                   SecurityDescriptorStreamPresent,
    IN OUT  PNUMBER_SET               SidEntries,
    IN OUT  PNUMBER_SET               SidEntries2,
    IN OUT  PBOOLEAN                  HasErrors,
    IN      BOOLEAN                   SkipEntriesScan,
    IN OUT  PBOOLEAN                  ChkdskErrCouldNotFix,
    IN OUT  PMESSAGE                  Message
)
/*++

Routine Description:

    This routine controls the read-ahead thread and
    checks the security descriptor or security id
    of each file record segment.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FirstFrsNumber   - Supplies the shared storage location for first frs number to be processed.
    NumberOfFrsToRead- Supplies the shared storage location to how many frs to read at a time.
    Frs1             - Supplies the shared frs object for read-ahead use.
    Frs2             - Supplies the shared frs object for read-ahead use.
    ReadAheadEvent   - Supplies the event to trigger the read ahead thread to read ahead.
    ReadReadyEvent   - Supplies the event to tell this routine that data is ready.
    ThreadHandle     - Supplies the handle to the read-ahead thread.
    FixLevel         - Supplies the fix level.
    Mft              - Supplies a valid MFT.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    SecurityFrs      - Supplies the initialized security frs.
    BadClusters      - Receives the bad clusters identified by this method.
    ErrFixedStatus   - Supplies & receives whether errors have been fixed.
    SecurityDescriptorStreamPresent
                     - Supplies whether there is a security descriptor stream.
    SidEntries       - Supplies the set of security ids found in the security descriptor stream.
    SidEntries2      - Receives the set of security ids that is in use.
    HasErrors        - Receives whether there is any error found.
    SkipEntriesScan  - Supplies whether index entries scan were skipped earlier.
    ChkdskErrCoundNotFix
                     - Receives whehter there is error that could not be fixed.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN                             diskHasErrors;
    BOOLEAN                             need_new;
    BOOLEAN                             has_security_descriptor_attribute;
    NTFS_ATTRIBUTE                      attrib;
    BOOLEAN                             error;
    ULONG                               length;
    PSECURITY_DESCRIPTOR                security;
    ULONG                               num_bytes;
    ULONG                               bytesWritten;
    PSTANDARD_INFORMATION2              standard_information2;
    ULONG                               securityId;

    VCN                                 i;
    BIG_INT                             time_to_read;
    PNTFS_FILE_RECORD_SEGMENT           frs, last_frs;
    BOOLEAN                             changes;

    BOOLEAN                             first_read;
    BOOLEAN                             read_status;
    ULONG                               percent_done;

    NTSTATUS                            ntstatus;
    THREAD_BASIC_INFORMATION            basic_info;
    LARGE_INTEGER                       timeout;

    *FirstFrsNumber = 0;
    if (TotalNumberOfFrs >= MFT_READ_CHUNK_SIZE)
        *NumberOfFrsToRead = MFT_READ_CHUNK_SIZE;
    else
        *NumberOfFrsToRead = TotalNumberOfFrs.GetLowPart();

    ntstatus = NtSetEvent(ReadAheadEvent, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: Unable to set read ahead event (%x)\n", ntstatus));
        return FALSE;
    }

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    frs = Frs2;
    time_to_read = 0;
    timeout.QuadPart = -2000000000;     // 200 seconds

    for (i = 0; i < TotalNumberOfFrs; i += 1) {

        if (i*100/TotalNumberOfFrs != percent_done) {
            percent_done = (i*100/TotalNumberOfFrs).GetLowPart();
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i == (SECURITY_TABLE_NUMBER+1)) {
            frs = last_frs;
        }

        if (i == time_to_read) {

            BIG_INT     remaining_frs;
            ULONG       number_to_read;
            ULONG       exit_code;

            ntstatus = NtWaitForSingleObject(ReadReadyEvent, FALSE, &timeout);
            if (ntstatus != STATUS_WAIT_0) {
                DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
                return FALSE;
            }

            //
            // The advancing of frs number needs to keep in sync with that in FilesReadAhead
            //
            time_to_read += *NumberOfFrsToRead;
            *FirstFrsNumber = time_to_read;
            remaining_frs = TotalNumberOfFrs - time_to_read;

            if (remaining_frs.GetLowPart() < MFT_READ_CHUNK_SIZE &&
                remaining_frs.GetHighPart() == 0)
                *NumberOfFrsToRead = remaining_frs.GetLowPart();
            else
                *NumberOfFrsToRead = MFT_READ_CHUNK_SIZE;

            ntstatus = NtQueryInformationThread(ThreadHandle,
                                                ThreadBasicInformation,
                                                &basic_info,
                                                sizeof(basic_info),
                                                NULL);

            if (!NT_SUCCESS(ntstatus)) {
                DebugPrintTrace(("UNTFS: NtQueryInformationThread failed (%x)\n", ntstatus));
                return FALSE;
            }

            if (basic_info.ExitStatus != STATUS_PENDING && !NT_SUCCESS(basic_info.ExitStatus)) {
                DebugPrintTrace(("UNTFS: Premature termination of files read ahead thread (%x)\n",
                                 basic_info.ExitStatus));
                return FALSE;
            }

            ntstatus = NtSetEvent(ReadAheadEvent, NULL);
            if (!NT_SUCCESS(ntstatus)) {
                DebugPrintTrace(("UNTFS: NtSetEvent failed (%x)\n", ntstatus));
                return FALSE;
            }

            if (frs == Frs2)  {
                frs = Frs1;
            } else {
                DebugAssert(frs == Frs1);
                frs = Frs2;
            }

            first_read = TRUE;
        }

        if (first_read) {
            first_read = FALSE;
            read_status = frs->ReadAgain(i);
        } else {
            if (!frs->Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            read_status = frs->ReadNext(i);
        }

        if (i == SECURITY_TABLE_NUMBER) {
            last_frs = frs;
            frs = SecurityFrs;
        } else {
            if (!read_status)
                continue;
        }

        if (Mft->GetMftBitmap()->IsFree(i, 1)) {
            continue;
        }

        if (!frs->IsInUse() || !frs->IsBase()) {
            continue;
        }

        if (SkipEntriesScan &&
            !ChkdskInfo->FilesWithTooManyFileNames.DoesIntersectSet(i, 1)) {
            diskHasErrors = FALSE;
            if (!frs->VerifyAndFixFileNames(Mft->GetMftBitmap(),
                                             ChkdskInfo,
                                             FixLevel,
                                             Message,
                                             &diskHasErrors,
                                             FALSE)) {
                return FALSE;
            } else if (diskHasErrors) {
                // no need to set hasErrors as this has nothing to do with security descriptor
                *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }

        need_new = has_security_descriptor_attribute = FALSE;

        if (frs->QueryAttribute(&attrib, &error, $SECURITY_DESCRIPTOR)) {

            // First recover this attribute to make sure that
            // everything is readable.

            if (FixLevel != CheckOnly) {
                attrib.RecoverAttribute(Mft->GetVolumeBitmap(), BadClusters);
            }

            // Read in the security descriptor and validate.

            length = attrib.QueryValueLength().GetLowPart();

            if (attrib.QueryValueLength().GetHighPart() != 0 ||
                !(security = (PSECURITY_DESCRIPTOR) MALLOC(length))) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            error = FALSE;
            if (!attrib.Read(security, 0, length, &num_bytes)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_SECURITY_DESCRIPTOR,
                             "%x", i);

                error = TRUE;
            } else if (num_bytes != length) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_SECURITY_DESCRIPTOR,
                             "%x", i);

                error = TRUE;
            } else if (!IFS_SYSTEM::CheckValidSecurityDescriptor(length, (PISECURITY_DESCRIPTOR)security) ||
                       length < RtlLengthSecurityDescriptor(security)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_SECURITY_DESCRIPTOR_IN_FILE,
                             "%x", i);

                error = TRUE;
            }

            if (error) {

                if (!attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs->PurgeAttribute($SECURITY_DESCRIPTOR)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_new = TRUE;
            } else
                has_security_descriptor_attribute = TRUE;

            FREE(security);

        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            need_new = (ChkdskInfo->major <= 1);
        }

        if (ChkdskInfo->major >= 2) {
            if (frs->QueryAttribute(&attrib, &error, $STANDARD_INFORMATION)) {
                length = attrib.QueryValueLength().GetLowPart();
                if (length == sizeof(STANDARD_INFORMATION2)) {

                    if (!SecurityDescriptorStreamPresent)
                        continue;

                    if (!(standard_information2 =
                          (PSTANDARD_INFORMATION2)attrib.GetResidentValue())) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    securityId = standard_information2->SecurityId;

                    if (securityId == SECURITY_ID_INVALID)
                        continue;

                    if (has_security_descriptor_attribute ||
                        !SidEntries->DoesIntersectSet(securityId, 1)) {

                        standard_information2->SecurityId = SECURITY_ID_INVALID;
                        Message->DisplayMsg(MSG_CHK_NTFS_INVALID_SECURITY_ID,
                                            "%d", i);

                        *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        if (FixLevel != CheckOnly &&
                            (!attrib.Write((PVOID)standard_information2,
                                           0,
                                           sizeof(STANDARD_INFORMATION2),
                                           &bytesWritten,
                                           Mft->GetVolumeBitmap()) ||
                             bytesWritten != sizeof(STANDARD_INFORMATION2))) {
                            *ChkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                                "%d%d", attrib.QueryTypeCode(), i);
                        }
                        if (FixLevel != CheckOnly && attrib.IsStorageModified() &&
                            !attrib.InsertIntoFile(frs, Mft->GetVolumeBitmap())) {
                            *ChkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                                "%d%d", attrib.QueryTypeCode(), i);
                        }
                        if (FixLevel != CheckOnly &&
                            !frs->Flush(Mft->GetVolumeBitmap())) {
                            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                                "%d", frs->QueryFileNumber().GetLowPart());
                            return FALSE;
                        }
                        continue;
                    } // if (!SidEntries->DoesIntersectSet(...
                    SidEntries2->Add(standard_information2->SecurityId);
                    continue;
                } // if (length == sizeof(STANDARD_INFORMATION2))
            } else if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            } else {
                DebugPrint("Standard Information Missing\n");
                return FALSE;
            }
        }

        if (need_new) {

            Message->DisplayMsg(MSG_CHK_NTFS_INVALID_SECURITY_DESCRIPTOR,
                                "%d", i);

            *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (FixLevel != CheckOnly) {
                if (!frs->AddSecurityDescriptor(EditCannedSd,
                                                Mft->GetVolumeBitmap()) ||
                    !frs->Flush(Mft->GetVolumeBitmap())) {

                    *ChkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY,
                                        "%d", i);
                }
            }
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_SA::ProcessSD2(
    IN      BIG_INT                   TotalNumberOfFrs,
    IN      FIX_LEVEL                 FixLevel,
    IN OUT  PNTFS_MASTER_FILE_TABLE   Mft,
    IN OUT  PNTFS_CHKDSK_REPORT       ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO         ChkdskInfo,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT SecurityFrs,
    IN OUT  PNUMBER_SET               BadClusters,
    IN OUT  PULONG                    ErrFixedStatus,
    IN      BOOLEAN                   SecurityDescriptorStreamPresent,
    IN OUT  PNUMBER_SET               SidEntries,
    IN OUT  PNUMBER_SET               SidEntries2,
    IN OUT  PBOOLEAN                  HasErrors,
    IN      BOOLEAN                   SkipEntriesScan,
    IN OUT  PBOOLEAN                  ChkdskErrCouldNotFix,
    IN OUT  PMESSAGE                  Message
)
/*++

Routine Description:

    This routine checks the security descriptor or security id
    of each file record segment.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FixLevel         - Supplies the fix level.
    Mft              - Supplies a valid MFT.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    SecurityFrs      - Supplies the initialized security frs.
    BadClusters      - Receives the bad clusters identified by this method.
    ErrFixedStatus   - Supplies & receives whether errors have been fixed.
    SecurityDescriptorStreamPresent
                     - Supplies whether there is a security descriptor stream.
    SidEntries       - Supplies the set of security ids found in the security descriptor stream.
    SidEntries2      - Receives the set of security ids that is in use.
    HasErrors        - Receives whether there is any error found.
    SkipEntriesScan  - Supplies whether index entries scan were skipped earlier.
    ChkdskErrCoundNotFix
                     - Receives whehter there is error that could not be fixed.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN                             diskHasErrors;
    BOOLEAN                             need_new;
    BOOLEAN                             has_security_descriptor_attribute;
    NTFS_ATTRIBUTE                      attrib;
    BOOLEAN                             error;
    ULONG                               length;
    PSECURITY_DESCRIPTOR                security;
    ULONG                               num_bytes;
    ULONG                               bytesWritten;
    PSTANDARD_INFORMATION2              standard_information2;
    ULONG                               securityId;

    VCN                                 i;
    PNTFS_FILE_RECORD_SEGMENT           frs;
    NTFS_FILE_RECORD_SEGMENT            myfrs;
    BOOLEAN                             changes;

    ULONG                               percent_done;


    DebugAssert(TotalNumberOfFrs.GetHighPart() == 0);

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    for (i = 0; i < TotalNumberOfFrs; i += 1) {

        if (i*100/TotalNumberOfFrs != percent_done) {
            percent_done = (i*100/TotalNumberOfFrs).GetLowPart();
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i % MFT_READ_CHUNK_SIZE == 0) {

            ULONG       remaining_frs;
            ULONG       number_to_read;

            remaining_frs = (TotalNumberOfFrs - i).GetLowPart();
            number_to_read = min(MFT_READ_CHUNK_SIZE, remaining_frs);

            if (!myfrs.Initialize(i, number_to_read, Mft)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (i == SECURITY_TABLE_NUMBER) {
            frs = SecurityFrs;
            // no need to read the security frs as it's already initialized
            if (!myfrs.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            myfrs.ReadNext(i);      // dummy read
        } else {
            frs = &myfrs;
            if (!myfrs.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            if (!myfrs.ReadNext(i))
                continue;
        }

        if (Mft->GetMftBitmap()->IsFree(i, 1)) {
            continue;
        }

        if (!frs->IsInUse() || !frs->IsBase()) {
            continue;
        }

        if (SkipEntriesScan &&
            !ChkdskInfo->FilesWithTooManyFileNames.DoesIntersectSet(i, 1)) {
            diskHasErrors = FALSE;
            if (!frs->VerifyAndFixFileNames(Mft->GetMftBitmap(),
                                             ChkdskInfo,
                                             FixLevel,
                                             Message,
                                             &diskHasErrors,
                                             FALSE)) {
                return FALSE;
            } else if (diskHasErrors) {
                // no need to set hasErrors as this has nothing to do with security descriptor
                *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }

        need_new = has_security_descriptor_attribute = FALSE;

        if (frs->QueryAttribute(&attrib, &error, $SECURITY_DESCRIPTOR)) {

            // First recover this attribute to make sure that
            // everything is readable.

            if (FixLevel != CheckOnly) {
                attrib.RecoverAttribute(Mft->GetVolumeBitmap(), BadClusters);
            }

            // Read in the security descriptor and validate.

            length = attrib.QueryValueLength().GetLowPart();

            if (attrib.QueryValueLength().GetHighPart() != 0 ||
                !(security = (PSECURITY_DESCRIPTOR) MALLOC(length))) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!attrib.Read(security, 0, length, &num_bytes) ||
                num_bytes != length ||
                !IFS_SYSTEM::CheckValidSecurityDescriptor(length, (PISECURITY_DESCRIPTOR)security) ||
                length < RtlLengthSecurityDescriptor(security)) {

                if (!attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !frs->PurgeAttribute($SECURITY_DESCRIPTOR)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                need_new = TRUE;
            } else
                has_security_descriptor_attribute = TRUE;

            FREE(security);

        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            need_new = (ChkdskInfo->major <= 1);
        }

        if (ChkdskInfo->major >= 2) {
            if (frs->QueryAttribute(&attrib, &error, $STANDARD_INFORMATION)) {
                length = attrib.QueryValueLength().GetLowPart();
                if (length == sizeof(STANDARD_INFORMATION2)) {

                    if (!SecurityDescriptorStreamPresent)
                        continue;

                    if (!(standard_information2 =
                          (PSTANDARD_INFORMATION2)attrib.GetResidentValue())) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }

                    securityId = standard_information2->SecurityId;

                    if (securityId == SECURITY_ID_INVALID)
                        continue;

                    if (has_security_descriptor_attribute ||
                        !SidEntries->DoesIntersectSet(securityId, 1)) {

                        standard_information2->SecurityId = SECURITY_ID_INVALID;
                        Message->DisplayMsg(MSG_CHK_NTFS_INVALID_SECURITY_ID,
                                            "%d", i);

                        *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                        if (FixLevel != CheckOnly &&
                            (!attrib.Write((PVOID)standard_information2,
                                           0,
                                           sizeof(STANDARD_INFORMATION2),
                                           &bytesWritten,
                                           Mft->GetVolumeBitmap()) ||
                             bytesWritten != sizeof(STANDARD_INFORMATION2))) {
                            *ChkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                                "%d%d", attrib.QueryTypeCode(), i);
                        }
                        if (FixLevel != CheckOnly && attrib.IsStorageModified() &&
                            !attrib.InsertIntoFile(frs, Mft->GetVolumeBitmap())) {
                            *ChkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                                "%d%d", attrib.QueryTypeCode(), i);
                        }
                        if (FixLevel != CheckOnly &&
                            !frs->Flush(Mft->GetVolumeBitmap())) {
                            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                                "%d", frs->QueryFileNumber().GetLowPart());
                            return FALSE;
                        }
                        continue;
                    } // if (!SidEntries->DoesIntersectSet(...
                    SidEntries2->Add(standard_information2->SecurityId);
                    continue;
                } // if (length == sizeof(STANDARD_INFORMATION2))
            } else if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            } else {
                DebugPrint("Standard Information Missing\n");
                return FALSE;
            }
        }

        if (need_new) {

            Message->DisplayMsg(MSG_CHK_NTFS_INVALID_SECURITY_DESCRIPTOR, "%d", i);

            *ErrFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (FixLevel != CheckOnly) {
                if (!frs->AddSecurityDescriptor(EditCannedSd,
                                                Mft->GetVolumeBitmap()) ||
                    !frs->Flush(Mft->GetVolumeBitmap())) {

                    *ChkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY,
                                        "%d", i);
                }
            }
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
NTFS_SA::SDReadAhead(
    IN      BIG_INT                     TotalNumberOfFrs,
    IN      PVCN                        FirstFrsNumber,
    IN      PULONG                      NumberOfFrsToRead,
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs1,
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs2,
       OUT  HANDLE                      ReadAhead,
    IN      HANDLE                      ReadReady,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft
)
/*++

Routine Description:

    This routine performs the read-ahead action.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FirstFrsNumber   - Supplies the shared storage location for first frs number to be processed.
    NumberOfFrsToRead- Supplies the shared storage location to how many frs to read at a time.
    Frs1             - Supplies the shared frs object for read-ahead use.
    Frs2             - Supplies the shared frs object for read-ahead use.
    ReadAhead        - Supplies the event to trigger the read ahead thread to read ahead.
    ReadReady        - Supplies the event to tell this routine that data is ready.
    Mft              - Supplies a valid MFT.

Return Value:

    STATUS_SUCCESS   - Success

--*/
{
    PNTFS_FILE_RECORD_SEGMENT   frs = Frs2;
    NTSTATUS                    ntstatus;

    for(;;) {

        //
        // The advancing of frs number needs to keep in sync with that in ProcessFiles
        //

        ntstatus = NtWaitForSingleObject(ReadAhead, FALSE, NULL) ;
        if (ntstatus != STATUS_WAIT_0) {
            DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
            return ntstatus;
        }

        if (*NumberOfFrsToRead == 0)
            break;

        if (frs == Frs2) {
            frs = Frs1;
        } else {
            DebugAssert(frs == Frs1);
            frs = Frs2;
        }

        if (!frs->Initialize(*FirstFrsNumber,
                             *NumberOfFrsToRead,
                             Mft)) {
            DebugPrintTrace(("Out of Memory\n"));
            return STATUS_NO_MEMORY;
        }

        //
        // ignore the error as the main process will run into it again on ReadAgain()
        //
        frs->ReadNext(*FirstFrsNumber);

        ntstatus = NtSetEvent(ReadReady, NULL);
        if (!NT_SUCCESS(ntstatus)) {
            DebugPrintTrace(("UNTFS: NtSetEvent failed (%x)\n", ntstatus));
            return ntstatus;
        }
    }

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\rafile.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    rafile.cxx

Abstract:

    This module implements the read ahead algorithm for the
    file verification stage of chkdsk.

Author:

    Daniel Chan (danielch) 08-Dec-97

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"
#include "rafile.hxx"

PNTFS_SA                 RA_PROCESS_FILE::_sa;
ULONG64                  RA_PROCESS_FILE::_total_number_of_frs;
PVCN                     RA_PROCESS_FILE::_first_frs_number;
PULONG                   RA_PROCESS_FILE::_number_of_frs_to_read;
PNTFS_FRS_STRUCTURE      RA_PROCESS_FILE::_frsstruc1;
PNTFS_FRS_STRUCTURE      RA_PROCESS_FILE::_frsstruc2;
PHMEM                    RA_PROCESS_FILE::_hmem1;
PHMEM                    RA_PROCESS_FILE::_hmem2;
HANDLE                   RA_PROCESS_FILE::_read_ahead_event;
HANDLE                   RA_PROCESS_FILE::_read_ready_event;
PNTFS_ATTRIBUTE          RA_PROCESS_FILE::_mft_data;
PNTFS_UPCASE_TABLE       RA_PROCESS_FILE::_upcase_table;

DEFINE_EXPORTED_CONSTRUCTOR( RA_PROCESS_FILE, OBJECT, UNTFS_EXPORT );

BOOLEAN
NTFS_SA::StartProcessingFiles(
    IN      BIG_INT                  TotalNumberOfFrs,
    IN OUT  PBOOLEAN                 DiskErrorFound,
    IN      FIX_LEVEL                FixLevel,
    IN OUT  PNTFS_ATTRIBUTE          MftData,
    IN OUT  PNTFS_BITMAP             MftBitmap,
    IN OUT  PNTFS_BITMAP             VolumeBitmap,
    IN OUT  PNTFS_UPCASE_TABLE       UpcaseTable,
    IN OUT  PNTFS_ATTRIBUTE_COLUMNS  AttributeDefTable,
    IN OUT  PNTFS_CHKDSK_REPORT      ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO        ChkdskInfo,
    IN OUT  PMESSAGE                 Message
)
/*++

Routine Description:

    This routine initializes all the synchronization objects,
    creates the read-ahead thread, and start the processing
    routine.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    DiskErrorFound   - Returns whether or not disk errors have been found.
    FixLevel         - Supplies the fix level.
    MftData          - Supplies the MFT's data attribute.
    MftBitmap        - Supplies the MFT bitmap.
    VolumeBitmap     - Supplies the volume bitmap.
    UpcaseTable      - Supplies the upcase table.
    AttributeDefTable- Supplies the attribute definition table.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    RA_PROCESS_FILE             ra_process_file;
    HANDLE                      thread_handle;
    NTFS_FRS_STRUCTURE          frsstruc1, frsstruc2;
    HMEM                        hmem1, hmem2;
    HANDLE                      read_ahead_event;
    HANDLE                      read_ready_event;
    VCN                         first_frs_number;
    ULONG                       number_of_frs_to_read;
    BOOLEAN                     status;

    NTSTATUS                    ntstatus;
    LARGE_INTEGER               timeout;
    THREAD_BASIC_INFORMATION    basic_info;
    OBJECT_ATTRIBUTES           objAttr;


    if (TotalNumberOfFrs == 0)
        return TRUE;

    // create the read ahead event which signals when the read ahead thread should start reading

    InitializeObjectAttributes(&objAttr,
                               NULL,
                               0L,
                               NULL,
                               NULL);

    ntstatus = NtCreateEvent(&read_ahead_event,
                             EVENT_ALL_ACCESS,
                             &objAttr,
                             SynchronizationEvent,
                             FALSE                  // initial state
                             );

    if (!NT_SUCCESS(ntstatus)) {

        DebugPrintTrace(("UNTFS: Unable to create read ahead event (%x)\n", ntstatus));

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    // create the read ready event which signals when the read is completed

    ntstatus = NtCreateEvent(&read_ready_event,
                             EVENT_ALL_ACCESS,
                             &objAttr,
                             SynchronizationEvent,
                             FALSE                  // initial state
                             );

    if (!NT_SUCCESS(ntstatus)) {

        NtClose(read_ahead_event);

        DebugPrintTrace(("UNTFS: Unable to create read ready event (%x)\n", ntstatus));

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    RA_PROCESS_FILE::Initialize(this,
                                TotalNumberOfFrs,
                                &first_frs_number,
                                &number_of_frs_to_read,
                                &frsstruc1,
                                &frsstruc2,
                                &hmem1,
                                &hmem2,
                                read_ahead_event,
                                read_ready_event,
                                MftData,
                                UpcaseTable);

    // create the read ahead thread


    ntstatus = RtlCreateUserThread(NtCurrentProcess(),
                                   NULL,
                                   FALSE,
                                   0,
                                   0,
                                   0,
                                   RA_PROCESS_FILE::ProcessFilesWrapper,
                                   &ra_process_file,
                                   &thread_handle,
                                   NULL);

    if (!NT_SUCCESS(ntstatus)) {

        NtClose(read_ahead_event);
        NtClose(read_ready_event);

        Message->DisplayMsg(MSG_CHK_UNABLE_TO_CREATE_THREAD, "%d", ntstatus);
        return FALSE;
    }

    status = ProcessFiles(TotalNumberOfFrs,
                          &first_frs_number,
                          &number_of_frs_to_read,
                          DiskErrorFound,
                          &frsstruc1,
                          &frsstruc2,
                          read_ahead_event,
                          read_ready_event,
                          thread_handle,
                          FixLevel,
                          MftData,
                          MftBitmap,
                          VolumeBitmap,
                          UpcaseTable,
                          AttributeDefTable,
                          ChkdskReport,
                          ChkdskInfo,
                          Message);

    //
    // Clean up the read ahead thread if it is still alive
    //
    number_of_frs_to_read = 0;
    ntstatus = NtSetEvent(read_ahead_event, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: Unable to set read ahead event (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    // wait for the read ahead thread to terminate

    timeout.QuadPart = -2000000000;  // 200 seconds
    ntstatus = NtWaitForSingleObject(thread_handle, FALSE, &timeout);
    if (ntstatus != STATUS_WAIT_0) {
        DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    // check the exit code of the read ahead thread

    ntstatus = NtQueryInformationThread(thread_handle,
                                        ThreadBasicInformation,
                                        &basic_info,
                                        sizeof(basic_info),
                                        NULL);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: NtQueryInformationThread failed (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    if (!NT_SUCCESS(basic_info.ExitStatus)) {
        DebugPrintTrace(("Premature termination of files read ahead thread (%x)\n", basic_info.ExitStatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    NtClose(read_ahead_event);
    NtClose(read_ready_event);
    NtClose(thread_handle);

    return status;
}

UNTFS_EXPORT
RA_PROCESS_FILE::~RA_PROCESS_FILE(
)
{
    Destroy();
}

VOID
RA_PROCESS_FILE::Construct(
)
{
}

VOID
RA_PROCESS_FILE::Destroy(
)
{
}

NTSTATUS
RA_PROCESS_FILE::ProcessFilesWrapper(
    IN OUT PVOID      lpParameter
)
{
    return  RA_PROCESS_FILE::GetSa()->FilesReadAhead(RA_PROCESS_FILE::GetTotalNumberOfFrs(),
                                                     RA_PROCESS_FILE::GetFirstFrsNumber(),
                                                     RA_PROCESS_FILE::GetNumberOfFrsToRead(),
                                                     RA_PROCESS_FILE::GetFrsStruc1(),
                                                     RA_PROCESS_FILE::GetFrsStruc2(),
                                                     RA_PROCESS_FILE::GetHmem1(),
                                                     RA_PROCESS_FILE::GetHmem2(),
                                                     RA_PROCESS_FILE::GetReadAheadEvent(),
                                                     RA_PROCESS_FILE::GetReadReadyEvent(),
                                                     RA_PROCESS_FILE::GetMftData(),
                                                     RA_PROCESS_FILE::GetUpcaseTable());
}

BOOLEAN
RA_PROCESS_FILE::Initialize(
    IN      PNTFS_SA            Sa,
    IN      BIG_INT             TotalNumberOfFrs,
    IN      PVCN                FirstFrsNumber,
    IN      PULONG              NumberOfFrsToRead,
    IN      PNTFS_FRS_STRUCTURE FrsStruc1,
    IN      PNTFS_FRS_STRUCTURE FrsStruc2,
    IN      PHMEM               Hmem1,
    IN      PHMEM               Hmem2,
    IN      HANDLE              ReadAheadEvent,
    IN      HANDLE              ReadReadyEvent,
    IN      PNTFS_ATTRIBUTE     MftData,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
)
{
    _sa = Sa;
    _total_number_of_frs = TotalNumberOfFrs.GetQuadPart();
    _first_frs_number = FirstFrsNumber;
    _number_of_frs_to_read = NumberOfFrsToRead;
    _frsstruc1 = FrsStruc1;
    _frsstruc2 = FrsStruc2;
    _hmem1 = Hmem1;
    _hmem2 = Hmem2;
    _read_ahead_event = ReadAheadEvent;
    _read_ready_event = ReadReadyEvent;
    _mft_data = MftData;
    _upcase_table = UpcaseTable;

    return TRUE;
}

BOOLEAN
NTFS_SA::ProcessFiles(
    IN      BIG_INT                  TotalNumberOfFrs,
       OUT  PVCN                     FirstFrsNumber,
       OUT  PULONG                   NumberOfFrsToRead,
    IN OUT  PBOOLEAN                 DiskErrorFound,
    IN      PNTFS_FRS_STRUCTURE      FrsStruc1,
    IN      PNTFS_FRS_STRUCTURE      FrsStruc2,
    IN      HANDLE                   ReadAheadEvent,
       OUT  HANDLE                   ReadReadyEvent,
    IN      HANDLE                   ThreadHandle,
    IN      FIX_LEVEL                FixLevel,
    IN OUT  PNTFS_ATTRIBUTE          MftData,
    IN OUT  PNTFS_BITMAP             MftBitmap,
    IN OUT  PNTFS_BITMAP             VolumeBitmap,
    IN OUT  PNTFS_UPCASE_TABLE       UpcaseTable,
    IN OUT  PNTFS_ATTRIBUTE_COLUMNS  AttributeDefTable,
    IN OUT  PNTFS_CHKDSK_REPORT      ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO        ChkdskInfo,
    IN OUT  PMESSAGE                 Message
)
/*++

Routine Description:

    This routine controls the read-ahead thread and
    checks each file record segment.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FirstFrsNumber   - Supplies the shared storage location for first frs number to be processed.
    NumberOfFrsToRead- Supplies the shared storage location to how many frs to read at a time.
    DiskErrorFound   - Returns whether or not disk errors have been found.
    FrsStruc1        - Supplies the shared frs object for read-ahead use.
    FrsStruc2        - Supplies the shared frs object for read-ahead use.
    ReadAheadEvent   - Supplies the event to trigger the read ahead thread to read ahead.
    ReadReadyEvent   - Supplies the event to tell this routine that data is ready.
    ThreadHandle     - Supplies the handle to the read-ahead thread.
    FixLevel         - Supplies the fix level.
    MftData          - Supplies the MFT's data attribute.
    MftBitmap        - Supplies the MFT bitmap.
    VolumeBitmap     - Supplies the volume bitmap.
    UpcaseTable      - Supplies the upcase table.
    AttributeDefTable- Supplies the attribute definition table.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    VCN                                 i;
    BIG_INT                             time_to_read;
    PNTFS_FRS_STRUCTURE                 frsstruc;
    NTFS_ATTRIBUTE_LIST                 attr_list;
    BOOLEAN                             tube;
    NTFS_ATTRIBUTE_RECORD               attr_rec;
    BIG_INT                             cluster_count;
    MFT_SEGMENT_REFERENCE               seg_ref;
    ULONG                               entry_index;
    BOOLEAN                             changes;
    ULONG                               errFixedStatus = CHKDSK_EXIT_SUCCESS;

    ULONG                               num_boot_clusters;
    BIG_INT                             volume_clusters;
    BOOLEAN                             first_read;
    BOOLEAN                             read_status;
    ULONG                               percent_done;

    NTSTATUS                            ntstatus;
    THREAD_BASIC_INFORMATION            basic_info;
    LARGE_INTEGER                       timeout;

    *FirstFrsNumber = 0;
    if (TotalNumberOfFrs >= MFT_READ_CHUNK_SIZE)
        *NumberOfFrsToRead = MFT_READ_CHUNK_SIZE;
    else
        *NumberOfFrsToRead = TotalNumberOfFrs.GetLowPart();

    ntstatus = NtSetEvent(ReadAheadEvent, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: Unable to set read ahead event (%x)\n", ntstatus));
        return FALSE;
    }

    volume_clusters = QueryVolumeSectors()/((ULONG)QueryClusterFactor());
    num_boot_clusters = max(1, BYTES_PER_BOOT_SECTOR/
                               (_drive->QuerySectorSize()*
                                QueryClusterFactor()));

    Message->DisplayMsg(MSG_CHK_NTFS_CHECKING_FILES, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 1, GetNumberOfStages());

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    frsstruc = FrsStruc2;
    time_to_read = 0;
    timeout.QuadPart = -2000000000;  // 200 seconds

    for (i = 0; i < TotalNumberOfFrs; i += 1) {

        if (i*100/TotalNumberOfFrs != percent_done) {
            percent_done = (i*100/TotalNumberOfFrs).GetLowPart();
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i == time_to_read) {

            BIG_INT     remaining_frs;
            ULONG       number_to_read;
            ULONG       exit_code;

            ntstatus = NtWaitForSingleObject(ReadReadyEvent, FALSE, &timeout);
            if (ntstatus != STATUS_WAIT_0) {
                DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
                return FALSE;
            }

            //
            // The advancing of frs number needs to keep in sync with that in FilesReadAhead
            //
            time_to_read += *NumberOfFrsToRead;
            *FirstFrsNumber = time_to_read;
            remaining_frs = TotalNumberOfFrs - time_to_read;

            if (remaining_frs.GetLowPart() < MFT_READ_CHUNK_SIZE &&
                remaining_frs.GetHighPart() == 0)
                *NumberOfFrsToRead = remaining_frs.GetLowPart();
            else
                *NumberOfFrsToRead = MFT_READ_CHUNK_SIZE;

            ntstatus = NtQueryInformationThread(ThreadHandle,
                                                ThreadBasicInformation,
                                                &basic_info,
                                                sizeof(basic_info),
                                                NULL);

            if (!NT_SUCCESS(ntstatus)) {
                DebugPrintTrace(("UNTFS: NtQueryInformationThread failed (%x)\n", ntstatus));
                return FALSE;
            }

            if (basic_info.ExitStatus != STATUS_PENDING && !NT_SUCCESS(basic_info.ExitStatus)) {
                DebugPrintTrace(("UNTFS: Premature termination of files read ahead thread (%x)\n",
                                 basic_info.ExitStatus));
                return FALSE;
            }

            ntstatus = NtSetEvent(ReadAheadEvent, NULL);
            if (!NT_SUCCESS(ntstatus)) {
                DebugPrintTrace(("UNTFS: NtSetEvent failed (%x)\n", ntstatus));
                return FALSE;
            }

            if (frsstruc == FrsStruc2)  {
                frsstruc = FrsStruc1;
            } else {
                frsstruc = FrsStruc2;
            }

            first_read = TRUE;
        }

        // Make sure the FRS is readable.  If it isn't then add it to
        // the list of unreadable FRSs.

        if (first_read) {
            first_read = FALSE;
            read_status = frsstruc->ReadAgain(i);
        } else
            read_status = frsstruc->ReadNext(i);

        if (!read_status) {

            *DiskErrorFound = TRUE;

            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS,
                                "%d", i.GetLowPart());

            if (!ChkdskInfo->BadFiles.Add(i)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            continue;
        }

        if (i < FIRST_USER_FILE_NUMBER) {

            if (MASTER_FILE_TABLE_NUMBER + 1 == i) {

                // After verifying FRS 0, make sure that the
                // space for the internal MFT $DATA is allocated in
                // the internal Volume Bitmap.

                if (!MftData->MarkAsAllocated(VolumeBitmap)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_MFT);
                    return FALSE;
                }

            } else if (BOOT_FILE_NUMBER == i) {

                // boot file $DATA will cover the boot sector as well
                // so mark it as free first
                VolumeBitmap->SetFree(0, num_boot_clusters);

                if (QueryVolumeSectors() == _drive->QuerySectors()) {
                    VolumeBitmap->SetFree(volume_clusters/2, num_boot_clusters);
                }
            } else if (BOOT_FILE_NUMBER + 1 == i) {

                // boot sector should have been marked as in use
                // but do it again
                VolumeBitmap->SetAllocated(0, num_boot_clusters);

                if (QueryVolumeSectors() == _drive->QuerySectors()) {
                    VolumeBitmap->SetAllocated(volume_clusters/2, num_boot_clusters);
                }

            }
        }

        // Ignore FRSs if they are not in use.

        if (!frsstruc->IsInUse()) {
#if defined(LOCATE_DELETED_FILE)
            frsstruc->LocateUnuseFrs(FixLevel,
                                     Message,
                                     AttributeDefTable,
                                     DiskErrorFound);
#endif
            continue;
        }


        // If the FRS is a child then just add it to the list of child
        // FRSs for later orphan detection.  Besides that just ignore
        // Child FRSs since they'll be validated with their parents.

        if (!frsstruc->IsBase()) {

            if (!ChkdskInfo->ChildFrs.Add(i)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            continue;
        }


        // Verify and fix this base file record segment.

        if (!frsstruc->VerifyAndFix(FixLevel,
                                   Message,
                                   AttributeDefTable,
                                   DiskErrorFound)) {
            return FALSE;
        }

        // If this FRS was in very bad shape then it was marked as
        // not in use and should be ignored.

        if (!frsstruc->IsInUse()) {

            continue;
        }


        // Compare this LSN against the current highest LSN.

        if (frsstruc->QueryLsn() > LargestLsnEncountered) {
            LargestLsnEncountered = frsstruc->QueryLsn();
        }

        // Mark off this FRS in the MFT bitmap.

        MftBitmap->SetAllocated(i, 1);


        if (frsstruc->QueryAttributeList(&attr_list)) {

            // First verify the attribute list.

            if (!attr_list.VerifyAndFix(FixLevel,
                                        VolumeBitmap,
                                        Message,
                                        i,
                                        &tube,
                                        DiskErrorFound)) {
                return FALSE;
            }

            // Make sure that the attribute list has a correct
            // $STANDARD_INFORMATION entry and that the attribute
            // list is not cross-linked.  Otherwise tube it.

            if (!tube) {

                BOOLEAN     x1, x2;

                if (!attr_rec.Initialize(GetDrive(), frsstruc->GetAttributeList()) ||
                    !attr_rec.UseClusters(VolumeBitmap, &cluster_count)) {

                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST,
                                        "%I64d", frsstruc->QueryFileNumber().GetLargeInteger());

                    DebugPrintTrace(("UNTFS: Cross-link in attr list.\n"));
                    DebugPrintTrace(("UNTFS: File 0x%I64x\n",
                                     frsstruc->QueryFileNumber().GetLargeInteger()));

                    tube = TRUE;

                } else if ((x1 = !attr_list.QueryExternalReference($STANDARD_INFORMATION,
                                                                   &seg_ref,
                                                                   &entry_index)) ||
                           (x2 = !(seg_ref == frsstruc->QuerySegmentReference()))) {

                    MSGID   msgid;

                    if (x1) {
                        msgid = MSG_CHKLOG_NTFS_STANDARD_INFORMATION_MISSING_FROM_ATTR_LIST;
                    } else {
                        DebugAssert(x2);
                        msgid = MSG_CHKLOG_NTFS_STANDARD_INFORMATION_OUTSIDE_BASE_FRS;
                    }
                    Message->LogMsg(msgid,
                                    "%I64x", frsstruc->QueryFileNumber().GetLargeInteger());

                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST,
                                        "%d",
                                        frsstruc->QueryFileNumber().GetLowPart());

                    DebugPrintTrace(("UNTFS: Missing standard info in attr list.\n"));
                    DebugPrintTrace(("UNTFS: File 0x%I64x\n",
                                     frsstruc->QueryFileNumber().GetLargeInteger()));

                    attr_rec.UnUseClusters(VolumeBitmap, 0, 0);

                    tube = TRUE;
                }
            }

            if (tube) {

                // The attribute list needs to be tubed.

                frsstruc->DeleteAttributeRecord(frsstruc->GetAttributeList());

                if (FixLevel != CheckOnly && !frsstruc->Write()) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", frsstruc->QueryFileNumber().GetLowPart());
                    return FALSE;
                }


                // Then, treat this FRS as though there were no
                // attribute list, since there isn't any.

                if (!frsstruc->LoneFrsAllocationCheck(VolumeBitmap,
                                                     ChkdskReport,
                                                     ChkdskInfo,
                                                     FixLevel,
                                                     Message,
                                                     DiskErrorFound)) {
                    return FALSE;
                }

                if (!UpdateChkdskInfo(frsstruc, ChkdskInfo, Message)) {
                    return FALSE;
                }
                continue;
            }

            // Now, we have a valid attribute list.


            if (!VerifyAndFixMultiFrsFile(frsstruc,
                                          &attr_list,
                                          MftData,
                                          AttributeDefTable,
                                          VolumeBitmap,
                                          MftBitmap,
                                          ChkdskReport,
                                          ChkdskInfo,
                                          FixLevel,
                                          Message,
                                          DiskErrorFound)) {

                return FALSE;
            }


            if (!frsstruc->UpdateAttributeList(&attr_list,
                                              (FixLevel != CheckOnly))) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

        } else {

            // The FRS has no children.  Just check that all
            // of the attribute records start at VCN 0 and
            // that the alloc length is right on non-residents.
            // Additionally, mark off the internal bitmap with
            // the space taken by the non-resident attributes.

            if (!frsstruc->LoneFrsAllocationCheck(VolumeBitmap,
                                                 ChkdskReport,
                                                 ChkdskInfo,
                                                 FixLevel,
                                                 Message,
                                                 DiskErrorFound)) {
                return FALSE;
            }

            if (!frsstruc->CheckInstanceTags(FixLevel, ChkdskInfo->Verbose, Message, &changes)) {
                return FALSE;
            }

            if (changes) {
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }

        if (!UpdateChkdskInfo(frsstruc, ChkdskInfo, Message)) {
            return FALSE;
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }
    Message->DisplayMsg(MSG_CHK_NTFS_FILE_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

    if (*DiskErrorFound) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}

NTSTATUS
NTFS_SA::FilesReadAhead(
    IN      BIG_INT              TotalNumberOfFrs,
    IN      PVCN                 FirstFrsNumber,
    IN      PULONG               NumberOfFrsToRead,
    IN      PNTFS_FRS_STRUCTURE  FrsStruc1,
    IN      PNTFS_FRS_STRUCTURE  FrsStruc2,
    IN      PHMEM                Hmem1,
    IN      PHMEM                Hmem2,
       OUT  HANDLE               ReadAhead,
    IN      HANDLE               ReadReady,
    IN      PNTFS_ATTRIBUTE      MftData,
    IN      PNTFS_UPCASE_TABLE   UpCaseTable
)
/*++

Routine Description:

    This routine performs the read-ahead action.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FirstFrsNumber   - Supplies the shared storage location for first frs number to be processed.
    NumberOfFrsToRead- Supplies the shared storage location to how many frs to read at a time.
    FrsStruc1        - Supplies the shared frs object for read-ahead use.
    FrsStruc2        - Supplies the shared frs object for read-ahead use.
    Hmem1            - Supplies the storage object for read-ahead use.
    Hmem2            - Supplies the storage object for read-ahead use.
    ReadAhead        - Supplies the event to trigger the read ahead thread to read ahead.
    ReadReady        - Supplies the event to tell this routine that data is ready.
    MftData          - Supplies the MFT's data attribute.
    UpcaseTable      - Supplies the upcase table.

Return Value:

    STATUS_SUCCESS   - Success

Notes:

    The HmemX objects are not shared directly.  They could be locally defined in
    this routine.  However, in the event of premature termination of this thread,
    the existance of these objects may save an AV.

--*/
{
    PNTFS_FRS_STRUCTURE     frsstruc = FrsStruc2;
    PHMEM                   hmem;
    NTSTATUS                ntstatus;

    if (!Hmem1->Initialize() ||
        !Hmem2->Initialize()) {
        DebugPrintTrace(("Out of memory\n"));
        NtTerminateThread(NtCurrentThread(), STATUS_NO_MEMORY);
        return STATUS_NO_MEMORY;
    }

    for(;;) {

        //
        // The advancing of frs number needs to keep in sync with that in ProcessFiles
        //

        ntstatus = NtWaitForSingleObject(ReadAhead, FALSE, NULL) ;
        if (ntstatus != STATUS_WAIT_0) {
            DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
            NtTerminateThread(NtCurrentThread(), ntstatus);
            return ntstatus;
        }

        if (*NumberOfFrsToRead == 0)
            break;

        if (frsstruc == FrsStruc2) {
            frsstruc = FrsStruc1;
            hmem = Hmem1;
        } else {
            frsstruc = FrsStruc2;
            hmem = Hmem2;
        }
        if (!frsstruc->Initialize(hmem,
                                  MftData,
                                  *FirstFrsNumber,
                                  *NumberOfFrsToRead,
                                  QueryClusterFactor(),
                                  QueryVolumeSectors(),
                                  QueryFrsSize(),
                                  UpCaseTable)) {
            DebugPrintTrace(("Out of Memory\n"));
            NtTerminateThread(NtCurrentThread(), STATUS_NO_MEMORY);
            return STATUS_NO_MEMORY;
        }

        //
        // ignore the error as the main process will run into it again on ReadAgain()
        //
        frsstruc->ReadNext(*FirstFrsNumber);

#if 0
        LARGE_INTEGER   timeout;

        timeout.QuadPart = -10000;

        for (;;) {
            NtDelayExecution(FALSE, &timeout);
        }
#endif

        ntstatus = NtSetEvent(ReadReady, NULL);
        if (!NT_SUCCESS(ntstatus)) {
            DebugPrintTrace(("UNTFS: NtSetEvent failed (%x)\n", ntstatus));
            NtTerminateThread(NtCurrentThread(), ntstatus);
            return ntstatus;
        }
    }

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\ntfsvol.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "ntfsvol.hxx"

#include "message.hxx"
#include "rtmsg.h"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( NTFS_VOL, VOL_LIODPDRV );

BOOLEAN
VerifyExtendedSpace(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      BIG_INT                 StartingCluster,
    IN      BIG_INT                 NumberClusters,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    );

VOID
NTFS_VOL::Construct (
    )

/*++

Routine Description:

    Constructor for NTFS_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}


VOID
NTFS_VOL::Destroy(
    )
/*++

Routine Description:

    This routine returns a NTFS_VOL object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}


NTFS_VOL::~NTFS_VOL(
    )
/*++

Routine Description:

    Destructor for NTFS_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

FORMAT_ERROR_CODE
NTFS_VOL::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    )
/*++

Routine Description:

    This routine initializes a NTFS_VOL object.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_ntfssa, Message,
                                       ExclusiveWrite, FormatMedia, MediaType);

    if (errcode != NoError)
        return errcode;

    if (!Message) {
        Message = &msg;
    }

    if (!_ntfssa.Initialize(this, Message)) {
        return GeneralError;
    }

    if (!FormatMedia && !_ntfssa.Read(Message)) {
        return GeneralError;
    }

    return NoError;
}


PVOL_LIODPDRV
NTFS_VOL::QueryDupVolume(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine allocates a NTFS_VOL and initializes it to 'NtDriveName'.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    A pointer to a newly allocated NTFS volume.

--*/
{
    PNTFS_VOL   vol;

    // unreferenced parameters
    (void)(this);

    if (!(vol = NEW NTFS_VOL)) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return NULL;
    }

    if (!vol->Initialize(NtDriveName, Message, ExclusiveWrite,
                         FormatMedia, MediaType)) {
        DELETE(vol);
        return NULL;
    }

    return vol;
}

BOOLEAN
NTFS_VOL::Extend(
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Verify,
    IN      BIG_INT     nsecOldSize
    )
/*++

Routine Description:

    This routine extends the volume.  Sector zero will already
    have been modified.

    The first thing to do is to write the duplicate boot sector
    at the end of the partition.  Then we'll verify the remaining
    new sectors.  Finally, we'll allocate a larger volume bitmap
    and add any bad clusters that were found to the bad cluster
    file.

Arguments:

    Message         - Supplies an outlet for messages.
    Verify          - Tells whether to verify the space that has been added.
    nsecOldSize     - Supplies the previous size of the volume, in sectors.

Return Value:

    TRUE if successful.

--*/
{
    HMEM                        hmem;
    BIG_INT                     last_sector;
    SECRUN                      secrun;
    NUMBER_SET                  bad_clusters;
    NTFS_MFT_FILE               mft;
    NTFS_UPCASE_TABLE           upcase_table;
    NTFS_ATTRIBUTE              upcase_attr;
    NTFS_ATTRIBUTE              volume_bitmap_attr;
    NTFS_BITMAP                 volume_bitmap;
    NTFS_BITMAP_FILE            bitmap_file;
    NTFS_UPCASE_FILE            upcase_file;
    NTFS_INDEX_TREE             root_index;
    NTFS_FILE_RECORD_SEGMENT    root_frs;
    NTFS_EXTENT_LIST            extents;
    NTFS_BOOT_FILE              boot_file;
    NTFS_ATTRIBUTE              boot_attr;
    DSTRING                     index_name;
    ULONG                       i;
    BIG_INT                     li, old_nclus;
    ULONG                       cluster_size;
    ULONG                       nclus_boot_area;
    BOOLEAN                     error;

    // QueryVolumeSectors will return a volume size one less than
    // the partition size.  Note that we'll be writing past the end of
    // the volume file.
    //

    last_sector = GetNtfsSuperArea()->QueryVolumeSectors();
    cluster_size = GetNtfsSuperArea()->QueryClusterFactor() * QuerySectorSize();
    old_nclus = nsecOldSize / GetNtfsSuperArea()->QueryClusterFactor();

    if (!mft.Initialize(this,
                        GetNtfsSuperArea()->QueryMftStartingLcn(),
                        GetNtfsSuperArea()->QueryClusterFactor(),
                        GetNtfsSuperArea()->QueryFrsSize(),
                        GetNtfsSuperArea()->QueryVolumeSectors(),
                        NULL, NULL) ||
        !mft.Read() ||
        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
        !bitmap_file.Read() ||
        !bitmap_file.QueryAttribute(&volume_bitmap_attr, &error, $DATA) ||
        !volume_bitmap.Initialize(old_nclus, TRUE) ||
        !bad_clusters.Initialize()) {

        return FALSE;
    }


    if (!volume_bitmap.Read(&volume_bitmap_attr) ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attr, &error, $DATA) ||
        !upcase_table.Initialize(&upcase_attr) ||
        !mft.Initialize(this,
                        GetNtfsSuperArea()->QueryMftStartingLcn(),
                        GetNtfsSuperArea()->QueryClusterFactor(),
                        GetNtfsSuperArea()->QueryFrsSize(),
                        GetNtfsSuperArea()->QueryVolumeSectors(),
                        &volume_bitmap,
                        &upcase_table) ||
        !mft.Read()) {

        return FALSE;
    }

    if (!index_name.Initialize("$I30") ||
        !root_frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, &mft) ||
        !root_frs.Read()) {
        return FALSE;
    }

    if (!root_index.Initialize(this, GetNtfsSuperArea()->QueryClusterFactor(),
        &volume_bitmap, &upcase_table, root_frs.QuerySize(), &root_frs, &index_name)) {

        return FALSE;
    }

    //
    // Truncate the boot file to be just the sector 0 boot area.
    //

    nclus_boot_area = (BYTES_IN_BOOT_AREA % cluster_size) ?
                        BYTES_IN_BOOT_AREA / cluster_size + 1 :
                        BYTES_IN_BOOT_AREA / cluster_size;

    if (!boot_file.Initialize(mft.GetMasterFileTable()) ||
        !boot_file.Read() ||
        !boot_file.QueryAttribute(&boot_attr, &error, $DATA) ||
        !boot_attr.Resize(nclus_boot_area * cluster_size, &volume_bitmap) ||
        !boot_attr.InsertIntoFile(&boot_file, &volume_bitmap) ||
        !boot_file.Flush(&volume_bitmap, &root_index)) {

        return FALSE;
    }

    //
    // Grow the bitmap to represent the new volume size.
    //

    if (!volume_bitmap.Resize(GetNtfsSuperArea()->QueryVolumeSectors() /
        GetNtfsSuperArea()->QueryClusterFactor())) {

        return FALSE;
    }

    // The volume bitmap may have set bits at the end, beyond the end of
    // the old volume, because format pads the bitmap that way.  We clear
    // those bits because they don't make sense for the new volume.
    //

    for (li = old_nclus; li < old_nclus + 64; li += 1) {

        volume_bitmap.SetFree(li, 1);
    }

    // We won't want to resize the bitmap again, and the volume bitmap is
    // usually considered non-growable, so make it that way now.  This will
    // have the size-effect of setting the padding bits at the end.
    //

    volume_bitmap.SetGrowable(FALSE);

    //
    // Copy the boot sector to the end of the partition.
    //

    if (!secrun.Initialize(&hmem, this, 0, 1)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    if (!secrun.Read()) {
        //Message->DisplayMsg(MSG_DEVICE_ERROR);
        return FALSE;
    }

    secrun.Relocate(last_sector);

    if (!secrun.Write()) {
        //Message->DisplayMsg(MSG_DEVICE_ERROR);
        return FALSE;
    }

    if (Verify) {

        if (!VerifyExtendedSpace(mft.GetMasterFileTable(),
                                  nsecOldSize - 1,
                                  (last_sector + 1) - nsecOldSize,
                                  &bad_clusters,
                                  Message)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    if (!volume_bitmap_attr.MakeNonresident(&volume_bitmap) ||
        !volume_bitmap.Write(&volume_bitmap_attr, &volume_bitmap)) {

        if (!volume_bitmap_attr.RecoverAttribute(&volume_bitmap, &bad_clusters) ||
            !volume_bitmap.Write(&volume_bitmap_attr, &volume_bitmap)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_VOLUME_BITMAP);
            return FALSE;
        }
    }

    if (!volume_bitmap_attr.InsertIntoFile(&bitmap_file, &volume_bitmap) ||
        !bitmap_file.Flush(&volume_bitmap, &root_index)) {

        return FALSE;
    }

    return TRUE;
}

//
// Local support routine
//

BOOLEAN
VerifyExtendedSpace(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      BIG_INT                 StartingCluster,
    IN      BIG_INT                 NumberClusters,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine verifies all of the unused clusters on the disk.
    It adds any that are bad to the given bad cluster list.

Arguments:

    StartingCluster - Supplies the cluster to start verifying at.
    NumberClusters  - Supplies the number of clusters to verify.
    BadClusters     - Supplies the current list of bad clusters.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PLOG_IO_DP_DRIVE    drive;
    PNTFS_BITMAP        bitmap;
    BIG_INT             i, len;
    ULONG               percent_done;
    NUMBER_SET          bad_sectors;
    ULONG               cluster_factor;
    BIG_INT             start, run_length, next;
    ULONG               j;

    Message->DisplayMsg(MSG_CHK_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);

    drive = Mft->GetDataAttribute()->GetDrive();
    bitmap = Mft->GetVolumeBitmap();
    cluster_factor = Mft->QueryClusterFactor();

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    for (i = 0; i < NumberClusters; ) {

        len = min(NumberClusters - i, 100);

        if (len < 1) {
            break;
        }

        if (!bad_sectors.Initialize() ||
            !drive->Verify((i + StartingCluster) * cluster_factor,
                           len*cluster_factor,
                           &bad_sectors)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        for (j = 0; j < bad_sectors.QueryNumDisjointRanges(); j++) {

            bad_sectors.QueryDisjointRange(j, &start, &run_length);
            next = start + run_length;

            // Adjust start and next to be on cluster boundaries.
            start = start/cluster_factor;
            next = (next - 1)/cluster_factor + 1;

            // Add the bad clusters to the bad cluster list.
            if (!BadClusters->Add(start, next - start)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            // Mark the bad clusters as allocated in the bitmap.
            bitmap->SetAllocated(start, next - start);
        }

        i += len;

        if (100*i/NumberClusters > percent_done) {
            percent_done = (100*i/NumberClusters).GetLowPart();
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }
    }

    percent_done = 100;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_DONE_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\sdchk.cxx ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    sdchk.cxx

Abstract:

    This module implements Security Descriptors Checking.

Author:

    Daniel Chan (danielch) 30-Sept-96

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

//#define TIMING_ANALYSIS     1

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
extern "C" {
    #include <stdio.h>
    #include <time.h>
}
#endif

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"
#include "sdchk.hxx"
#include "spaset.hxx"

typedef struct _REPAIR_RECORD {
    ULONG   Offset;
    ULONG   Length;
};

DEFINE_TYPE(_REPAIR_RECORD, REPAIR_RECORD);

ULONG
ComputeDefaultSecurityId(
   PNUMBER_SET  SidSet
);

VOID
ClearSecurityDescriptorEntry(
    IN OUT  PSECURITY_ENTRY Security_entry,
    IN      ULONG           SecurityDescriptorSize
);

BOOLEAN
RecoverSecurityDescriptorsDataStream(
    IN OUT PNTFS_FILE_RECORD_SEGMENT    Frs,
    IN OUT PNTFS_ATTRIBUTE              Attrib,
    IN     ULONG                        AttributeSize,
    IN     PCHAR                        Buffer,
    IN     ULONG                        BufferSize,
    IN     ULONG                        ClusterSize,
    IN OUT PNTFS_BITMAP                 Bitmap,
    OUT    PBOOLEAN                     DiskHasErrors,
    IN OUT PNUMBER_SET                  BadClusters,
    IN OUT PMESSAGE                     Message,
    IN     BOOLEAN                      FixLevel
);

BOOLEAN
RepairSecurityDescriptorsSegment(
    IN OUT  PNTFS_ATTRIBUTE Attrib,
    IN      PCHAR           Buffer,
    IN      ULONG           Offset,
    IN      ULONG           BytesToProcess,
    IN OUT  PREPAIR_RECORD  Record,
    IN OUT  USHORT          *RecordCount,
    IN      ULONG           ClusterSize
);

#if defined( _SETUP_LOADER_ )

BOOLEAN
NTFS_SA::ValidateSecurityDescriptors(
    IN      PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN      BOOLEAN                 SkipEntriesScan,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine ensures that every file on the disk contains
    a valid security descriptor.

Arguments:

    ChkdskInfo  - Supplies the current chkdsk information.
    ChkdskReport- Supplies the current chkdsk report.
    Mft         - Supplies a valid MFT.
    BadClusters - Receives the bad clusters identified by this method.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // Stub for Setup Loader.

    return TRUE;
}

#else // not _SETUP_LOADER_

BOOLEAN
NTFS_SA::ValidateSecurityDescriptors(
    IN      PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN      BOOLEAN                 SkipEntriesScan,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine ensures that every file on the disk contains
    a valid security descriptor.  If that's not the case, then
    it expects to find the $SDS data stream in $Secure and each
    of those files contain a security id.

Arguments:

    ChkdskInfo  - Supplies the current chkdsk information.
    Mft         - Supplies a valid MFT.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    myfrs;
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    security_frs;
    ULONG                       i, n;
    ULONG                       percent;
    NTFS_ATTRIBUTE              attrib;
    NTFS_ATTRIBUTE              SDS_attrib;
    NTFS_ATTRIBUTE              SII_attrib;
    BOOLEAN                     error;
    BOOLEAN                     hasErrors = FALSE;
    BOOLEAN                     diskHasErrors;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    BOOLEAN                     chkdskCleanUp = FALSE;
    ULONG                       cleanup_count;
    BOOLEAN                     attribute_need_write = FALSE;
    BOOLEAN                     frs_need_flush = FALSE;
    BOOLEAN                     index_need_save = FALSE;
    BOOLEAN                     attribute_need_resize;
    BOOLEAN                     boundary_problem_found;
    BOOLEAN                     lastblock;
    BOOLEAN                     fixing_mirror;
    ULONG                       length;
    ULONG                       num_bytes;
    BOOLEAN                     securityDescriptorStreamPresent = FALSE;
    BOOLEAN                     alreadyExists;
    BOOLEAN                     new_SII_index = FALSE;
    BOOLEAN                     new_SDH_index = FALSE;
    BOOLEAN                     alloc_present;
    DSTRING                     SII_IndexName;
    DSTRING                     SDH_IndexName;
    DSTRING                     indexName;
    ULONG                       hash, offset;
    ULONG                       bytesWritten;
    BIG_INT                     hashkey;
    NUMBER_SET                  sid_entries, sid_entries2;
    SPARSE_SET                  hashkey_entries;
    NTFS_INDEX_TREE             SII_Index;
    NTFS_INDEX_TREE             SDH_Index;
    ULONG                       count_sid = 0;
    ULONG                       count_hashkey = 0;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    ULONG                       securityId;
    ULONG                       defaultSecurityId = 0;
    PSECURITY_ENTRY             security_entry = NULL;
    PSECURITY_ENTRY             previous_security_entry;
    PSECURITY_ENTRY             previous_previous_security_entry;
    PSECURITY_ENTRY             initial_security_entry = NULL;
    PSECURITY_ENTRY             endOfBlock;
    ULONG                       lengthUptoPreviousBlock;
    ULONG                       resizeTo;
    ULONG                       remain_length;
    ULONG                       bytesToRead;
    ULONG                       lengthOfBlock;
    ULONG                       align_num_bytes;
    ULONG                       se_offset;
    ULONG                       total_length;
    ULONG                       sdLength;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time_t                      time1, time2;
    PCHAR                       timestr;
#endif

    DebugPtrAssert(ChkdskInfo);
    DebugPtrAssert(ChkdskReport);

    Message->DisplayMsg(MSG_CHK_NTFS_CHECKING_SECURITY, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 3, GetNumberOfStages());

    // Check for existence of $SecurityDescriptorStream in SECURITY_TABLE_NUMBER

    if (!security_frs.Initialize(SECURITY_TABLE_NUMBER, Mft) ||
        !indexName.Initialize(SecurityDescriptorStreamNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // ??what to do if frs is unreadable or not in use or not a base??

    if (security_frs.Read() && security_frs.IsInUse() && security_frs.IsBase()) {
        securityDescriptorStreamPresent =
            security_frs.QueryAttribute(&SDS_attrib,
                                        &error,
                                        $DATA,
                                        &indexName) &&
            ChkdskInfo->major >= 2;

        if (!error && !securityDescriptorStreamPresent && ChkdskInfo->major >= 2) {
            // delete all $DATA attribute first
            while (security_frs.QueryAttribute(&SDS_attrib, &error, $DATA, 0)) {

                Message->DisplayMsg(MSG_CHKLOG_NTFS_UNKNOWN_SECURITY_DATA_STREAM,
                                    "%W%I64x",
                                    SDS_attrib.GetName(),
                                    security_frs.QueryFileNumber().GetLargeInteger());

                if (!SDS_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !security_frs.PurgeAttribute(SDS_attrib.QueryTypeCode(),
                                                 SDS_attrib.GetName())) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
            if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            Message->LogMsg(MSG_CHKLOG_NTFS_SECURITY_DATA_STREAM_MISSING,
                         "%I64x", security_frs.QueryFileNumber().GetLargeInteger());

            // now create the $DATA, $SDS stream
            if (!SDS_attrib.Initialize(_drive,
                                       QueryClusterFactor(),
                                       NULL,
                                       0,
                                       $DATA,
                                       &indexName)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            if (!SDS_attrib.InsertIntoFile(&security_frs,
                                           Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }
            if (FixLevel != CheckOnly &&
                !security_frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            hasErrors = TRUE;
            securityDescriptorStreamPresent = TRUE;
        }
        if (!error && securityDescriptorStreamPresent) {

            if (!SII_IndexName.Initialize(SecurityIdIndexNameData) ||
                !SDH_IndexName.Initialize(SecurityDescriptorHashIndexNameData)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            // make sure the $SII index exists
            // if it does not exists, an empty one will be created

            if (!SII_Index.Initialize(_drive,
                                      QueryClusterFactor(),
                                      Mft->GetVolumeBitmap(),
                                      Mft->GetUpcaseTable(),
                                      security_frs.QuerySize()/2,
                                      &security_frs,
                                      &SII_IndexName)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                                    "%W%d", &SII_IndexName, SECURITY_TABLE_NUMBER);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                hasErrors = TRUE;
                if (!SII_Index.Initialize(0,
                                          _drive,
                                          QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          COLLATION_ULONG,
                                          SMALL_INDEX_BUFFER_SIZE,
                                          security_frs.QuerySize()/2,
                                          &SII_IndexName)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (FixLevel != CheckOnly &&
                    (!SII_Index.Save(&security_frs) ||
                     !security_frs.Flush(Mft->GetVolumeBitmap()))) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                        "%d%W",
                                        security_frs.QueryFileNumber().GetLowPart(),
                        &SII_IndexName);
                    return FALSE;
                }
                ChkdskReport->NumIndices += 1;
                new_SII_index = TRUE;
            }

            // make sure the $SDH index exists
            // if it does not exists, an empty one will be created

            if (!SDH_Index.Initialize(_drive,
                                      QueryClusterFactor(),
                                      Mft->GetVolumeBitmap(),
                                      Mft->GetUpcaseTable(),
                                      security_frs.QuerySize()/2,
                                      &security_frs,
                                      &SDH_IndexName)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                                    "%W%d", &SDH_IndexName, SECURITY_TABLE_NUMBER);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                hasErrors = TRUE;
                if (!SDH_Index.Initialize(0,
                                          _drive,
                                          QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          COLLATION_SECURITY_HASH,
                                          SMALL_INDEX_BUFFER_SIZE,
                                          security_frs.QuerySize()/2,
                                          &SDH_IndexName)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY,
                                        "%d%W",
                                        security_frs.QueryFileNumber().GetLowPart(),
                                        &SDH_IndexName);
                    return FALSE;
                }

                if (FixLevel != CheckOnly &&
                    (!SDH_Index.Save(&security_frs) ||
                     !security_frs.Flush(Mft->GetVolumeBitmap()))) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                        "%d%W",
                                        security_frs.QueryFileNumber().GetLowPart(),
                                        &SDH_IndexName);
                    return FALSE;
                }
                ChkdskReport->NumIndices += 1;
                new_SDH_index = TRUE;
            }

            // Read in the security descriptor and validate.

            length = SDS_attrib.QueryValueLength().GetLowPart();

            // allocate space for a block of security descriptors

            if (SDS_attrib.QueryValueLength().GetHighPart() != 0 ||
                !(initial_security_entry = (SECURITY_ENTRY*)
                                   MALLOC(SecurityDescriptorsBlockSize))) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!RecoverSecurityDescriptorsDataStream(
                    &security_frs,
                    &SDS_attrib,
                    length,
                    (PCHAR)initial_security_entry,
                    SecurityDescriptorsBlockSize,
                    _drive->QuerySectorSize()*QueryClusterFactor(),
                    Mft->GetVolumeBitmap(),
                    &diskHasErrors,
                    BadClusters,
                    Message,
                    FixLevel)) {
                FREE(initial_security_entry);
                return FALSE;
            } else if (diskHasErrors) {
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                hasErrors = TRUE;
                if (FixLevel != CheckOnly &&
                    !security_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", security_frs.QueryFileNumber().GetLowPart());
                    FREE(initial_security_entry);
                    return FALSE;
                }
            }

            // get the actual length of the first copy of security descriptor data

            if (length < SecurityDescriptorsBlockSize) {

                // Resize the whole thing to zero length

                Message->LogMsg(MSG_CHKLOG_NTFS_SECURITY_DATA_STREAM_SIZE_TOO_SMALL,
                             "%x%x",
                             length,
                             SecurityDescriptorsBlockSize);

                attribute_need_resize = TRUE;
                length = 0;
            } else {
                attribute_need_resize = FALSE;
                length -= SecurityDescriptorsBlockSize;
            }

            offset = 0;
            lengthUptoPreviousBlock = 0;
            frs_need_flush = FALSE;
            boundary_problem_found = FALSE;
            resizeTo = 0;
            endOfBlock = (PSECURITY_ENTRY)((PCHAR)initial_security_entry+
                                           SecurityDescriptorsBlockSize);
            remain_length = length;

            if (!sid_entries.Initialize() ||
                !sid_entries2.Initialize() ||
                !hashkey_entries.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(initial_security_entry);
                return FALSE;
            }

            for (;length > 0;) {
                previous_previous_security_entry = previous_security_entry = NULL;
                attribute_need_write = FALSE;
                bytesToRead = min(SecurityDescriptorsBlockSize, length);
                security_entry = initial_security_entry;
                if (!SDS_attrib.Read(security_entry,
                                     offset,
                                     bytesToRead, &num_bytes) ||
                    num_bytes != bytesToRead) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_SECURITY_DATA_STREAM);
                    FREE(initial_security_entry);
                    return FALSE;
                }

                lastblock = length <= SecurityDescriptorsBlockSize;
                lengthOfBlock = 0;

                // Validate each security descriptor record in the data stream

                while (length > 0) {

                    // see if there is a need to move to next security descriptor block

                    if (security_entry == endOfBlock ||
                        (security_entry->security_descriptor_header.Length == 0 &&
                         security_entry->security_descriptor_header.HashKey.SecurityId == 0 &&
                         security_entry->security_descriptor_header.HashKey.Hash == 0)) {
                        if (!lastblock &&
                            (remain_length >= (SecurityDescriptorsBlockSize<<1))) {
                            lengthOfBlock = (ULONG)((PCHAR)security_entry-
                                                    (PCHAR)initial_security_entry);
                            if (!RemainingBlockIsZero((PCHAR)security_entry,
                                    (ULONG)((PCHAR)endOfBlock-(PCHAR)security_entry))) {
                                MarkEndOfSecurityDescriptorsBlock(security_entry,
                                    (ULONG)((PCHAR)endOfBlock-(PCHAR)security_entry));

                                Message->LogMsg(MSG_CHKLOG_NTFS_REMAINING_SECURITY_DATA_BLOCK_CONTAINS_NON_ZERO,
                                             "%x%x",
                                             offset+lengthOfBlock,
                                             (ULONG)((PCHAR)endOfBlock-(PCHAR)security_entry));

                                DebugPrint("Clearing till end of the security descriptors block.\n");
                                attribute_need_write = TRUE;
                            }
                            break;
                        } else
                            boundary_problem_found = TRUE;
                    }

                    num_bytes = security_entry->security_descriptor_header.Length;
                    align_num_bytes = (num_bytes + 0xf) & ~0xf;

                    error = FALSE;
                    if (boundary_problem_found) {

                        // loglog
                        error = TRUE;
                    } else if ((PCHAR)security_entry-(PCHAR)initial_security_entry+
                               num_bytes > SecurityDescriptorsBlockSize) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_ENTRY_CROSSES_PAGE_BOUNDARY,
                                     "%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     num_bytes
                                     );
                        error = TRUE;
                    } else if (num_bytes < sizeof(SECURITY_ENTRY)) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_ENTRY_LENGTH_TOO_SMALL,
                                     "%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     num_bytes,
                                     sizeof(SECURITY_ENTRY));
                        error = TRUE;
                    } else if (num_bytes > SecurityDescriptorMaxSize) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_ENTRY_LENGTH_EXCEEDS_PAGE_BOUNDARY,
                                     "%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     num_bytes,
                                     SecurityDescriptorMaxSize
                                     );
                        error = TRUE;
                    } else if (length < sizeof(SECURITY_ENTRY)) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_REMAINING_PAGE_LENGTH_TOO_SMALL,
                                     "%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     length,
                                     sizeof(SECURITY_ENTRY));
                        error = TRUE;
                    } else if (length != num_bytes && length < align_num_bytes) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_REMAINING_PAGE_LENGTH_TOO_SMALL,
                                     "%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     length,
                                     align_num_bytes);
                        error = TRUE;
                    }

                    if (error) {

                        boundary_problem_found = FALSE;
                        if (!lastblock) {
                            if ((PCHAR)security_entry-(PCHAR)initial_security_entry+
                                sizeof(SECURITY_DESCRIPTOR_HEADER) <=
                                SecurityDescriptorsBlockSize) {
                                MarkEndOfSecurityDescriptorsBlock(security_entry,
                                                                  (ULONG)((PCHAR)endOfBlock-
                                                                          (PCHAR)security_entry));
                                if (previous_security_entry)
                                    lengthOfBlock = (ULONG)((PCHAR)previous_security_entry -
                                                            (PCHAR)initial_security_entry) +
                                                            previous_security_entry->security_descriptor_header.Length;
                                else
                                    lengthOfBlock = 0;
                            } else if (previous_security_entry) {
                                sid_entries.Remove(previous_security_entry->
                                    security_descriptor_header.HashKey.SecurityId);
                                hashkey.Set(previous_security_entry->
                                    security_descriptor_header.HashKey.Hash,
                                    previous_security_entry->
                                    security_descriptor_header.HashKey.SecurityId);
                                hashkey_entries.CheckAndRemove(hashkey);

                                // the index entry will automatically be removed at a later stage

                                MarkEndOfSecurityDescriptorsBlock(previous_security_entry,
                                                            (ULONG)((PCHAR)endOfBlock-
                                                                    (PCHAR)previous_security_entry));
                                if (previous_previous_security_entry) {
                                    lengthOfBlock = (ULONG)((PCHAR)previous_previous_security_entry -
                                                            (PCHAR)initial_security_entry) +
                                                            previous_previous_security_entry->
                                                                security_descriptor_header.Length;
                                } else {
                                    lengthOfBlock = 0;
                                }
                            } else {
                                DebugAssert(FALSE);

                                // It doesn't make much sense to get here.
                                // If we don't have a previous_security_entry then
                                // security_entry is at the beginning of the block
                                // and should have enough space to include the EOB
                                // mark.

                            }
                            attribute_need_write = TRUE;
                            DebugPrint("Clearing till end of the security descriptors block.\n");
                        } else { // if lastblock
                            if (previous_security_entry) {
                                DebugAssert(remain_length <= SecurityDescriptorsBlockSize);
                                bytesToRead = remain_length = lengthOfBlock =
                                    (ULONG)((PCHAR)previous_security_entry-
                                            (PCHAR)initial_security_entry+
                                            previous_security_entry->
                                             security_descriptor_header.Length);
                                resizeTo = lengthOfBlock + offset;
                            } else {
                                bytesToRead = remain_length = lengthOfBlock = 0;
                                resizeTo = lengthUptoPreviousBlock;
                                DebugAssert(!attribute_need_write);
                            }
                            attribute_need_resize = TRUE;   // no need to write attribute
                            DebugPrint("Truncating the security descriptors block.\n");
                        }
                        break;
                    }

                    // skip over invalidated entries

                    securityId = security_entry->security_descriptor_header.HashKey.SecurityId;
                    if (securityId == SECURITY_ID_INVALID)
                        goto GetNextSDEntry;

                    sdLength = num_bytes - sizeof(SECURITY_DESCRIPTOR_HEADER);
                    if (!IFS_SYSTEM::CheckValidSecurityDescriptor(
                            sdLength,
                            (PISECURITY_DESCRIPTOR)&(security_entry->security)) ||
                        sdLength < RtlLengthSecurityDescriptor(
                                        &(security_entry->security))) {

                        // the data part is invalid
                        // fill the whole thing with zeros except the length byte in the header

                        Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_SECURITY_DESCRIPTOR_IN_SDS_ENTRY,
                                     "%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     securityId);

                        ClearSecurityDescriptorEntry(security_entry, sdLength);
                        attribute_need_write = TRUE;
                        DebugPrint("Clearing invalid security descriptor.\n");
                        goto GetNextSDEntry;
                    }

                    // check to see if we encountered this sid before
                    // also build a set with all the sid encountered

                    if (sid_entries.CheckAndAdd(securityId, &alreadyExists)) {
                        if (alreadyExists) {

                            Message->LogMsg(MSG_CHKLOG_NTFS_DUPLICATE_SID_IN_SDS_ENTRY,
                                         "%x%x",
                                         offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                         securityId);

                            ClearSecurityDescriptorEntry(security_entry, sdLength);
                            attribute_need_write = TRUE;
                            DebugPrint("Clearing duplicate security descriptor.\n");
                            goto GetNextSDEntry;
                        }
                    } else {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }

                    // check to see if the hash value is good

                    hash = ComputeSecurityDescriptorHash(
                                        &(security_entry->security), sdLength);
                    if (security_entry->security_descriptor_header.HashKey.Hash != hash) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_HASH_IN_SDS_ENTRY,
                                     "%x%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     security_entry->security_descriptor_header.HashKey.Hash,
                                     hash,
                                     securityId);

                        security_entry->security_descriptor_header.HashKey.Hash = hash;
                        attribute_need_write = TRUE;
                        DebugPrint("Repairing hash value of a security descriptor header.\n");
                    }

                    // check to see if the offset stored in the security descriptor header is good

                    se_offset = (ULONG)((PCHAR)security_entry -
                                        (PCHAR)initial_security_entry +
                                        offset);
                    if (security_entry->security_descriptor_header.Offset != se_offset) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_OFFSET_IN_SDS_ENTRY,
                                     "%x%I64x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     security_entry->security_descriptor_header.Offset,
                                     se_offset,
                                     securityId);

                        security_entry->security_descriptor_header.Offset = se_offset;
                        attribute_need_write = TRUE;
                        DebugPrint("Repairing offset value of a security descriptor header.\n");
                    }

                    // build a set with all the hashkey encountered

                    hashkey.Set(hash, securityId);
                    if (hashkey_entries.CheckAndAdd(hashkey, &alreadyExists)) {
                        DebugAssert(!alreadyExists);   // sid is unique thus hashkey
                    } else {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }

                    // now we know the entry is unique and good
                    // make sure there is a corresponding entry in
                    // SecurityIdIndex and SecurityDescriptorHashIndex
                    // index streams

                    switch (security_frs.FindSecurityIndexEntryAndValidate(
                            &SII_Index,
                            (PVOID)&securityId,
                            sizeof(securityId),
                            &(security_entry->security_descriptor_header),
                            Mft->GetVolumeBitmap(),
                            FixLevel == CheckOnly)) {
                      case NTFS_SECURITY_INDEX_FOUND:

                        // good, entry already exists in the index

                        break;   // go onto next entry

                      case NTFS_SECURITY_INDEX_FIXED:
                      case NTFS_SECURITY_INDEX_DATA_ERROR:
                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        DebugAssert(sizeof(securityId) == sizeof(ULONG));
                        Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_INDEX_ENTRY_WITH_ID,
                                            "%d%W%d",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SII_IndexName,
                                            securityId);
                        frs_need_flush = TRUE;
                        break;

                      case NTFS_SECURITY_INDEX_ENTRY_MISSING:
                      case NTFS_SECURITY_INDEX_INSERTED:
                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        DebugAssert(sizeof(securityId) == sizeof(ULONG));
                        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY_WITH_ID,
                                            "%d%W%d",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SII_IndexName,
                                            securityId);
                        frs_need_flush = TRUE;
                        break;

                      case NTFS_SECURITY_INSERT_FAILED:
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                            "%d%W",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SII_IndexName);
                        break;

                      case NTFS_SECURITY_ERROR:
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                    switch (security_frs.FindSecurityIndexEntryAndValidate(
                            &SDH_Index,
                            (PVOID)&(security_entry->security_descriptor_header.HashKey),
                            sizeof(security_entry->security_descriptor_header.HashKey),
                            &(security_entry->security_descriptor_header),
                            Mft->GetVolumeBitmap(),
                            FixLevel == CheckOnly)) {
                      case NTFS_SECURITY_INDEX_FOUND:

                        // good, entry already exists in the index

                        break;   // go onto next entry

                      case NTFS_SECURITY_INDEX_FIXED:
                      case NTFS_SECURITY_INDEX_DATA_ERROR:

                        //*DiskErrorsFound = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_INDEX_ENTRY_WITH_ID,
                                            "%d%W%d",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SDH_IndexName,
                                            security_entry->security_descriptor_header.
                                                                        HashKey.SecurityId);
                        frs_need_flush = TRUE;
                        break;

                      case NTFS_SECURITY_INDEX_ENTRY_MISSING:
                      case NTFS_SECURITY_INDEX_INSERTED:

                        //*DiskErrorsFound = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY_WITH_ID,
                                            "%d%W%d",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SDH_IndexName,
                                            security_entry->security_descriptor_header.
                                                                        HashKey.SecurityId);

                        frs_need_flush = TRUE;
                        break;

                      case NTFS_SECURITY_INSERT_FAILED:
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                            "%d%W",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SDH_IndexName);
                        break;

                      case NTFS_SECURITY_ERROR:
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }

                GetNextSDEntry:
                    if (length == num_bytes) {
                        lengthOfBlock = (ULONG)((PCHAR)security_entry-
                                                (PCHAR)initial_security_entry+
                                                num_bytes);
                        break; // done, leave the while loop
                    } else {
                        length -= align_num_bytes;
                        previous_previous_security_entry = previous_security_entry;
                        previous_security_entry = security_entry;
                        security_entry = (SECURITY_ENTRY*)((char *)security_entry +
                                         align_num_bytes);
                    }
                } // while
                if (attribute_need_write) {
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                    hasErrors = TRUE;
                    if (FixLevel != CheckOnly &&
                        (!SDS_attrib.Write(initial_security_entry,
                                           offset,
                                           bytesToRead,
                                           &bytesWritten,
                                           Mft->GetVolumeBitmap()) ||
                         bytesWritten != bytesToRead)) {
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                    } else
                        frs_need_flush = TRUE;
                }
                if (lengthOfBlock)
                    lengthUptoPreviousBlock = lengthOfBlock + offset;
                offset += (SecurityDescriptorsBlockSize<<1);
                remain_length -= bytesToRead;
                if (remain_length >= SecurityDescriptorsBlockSize)
                    remain_length -= SecurityDescriptorsBlockSize;
                else
                    remain_length = 0;
                length = remain_length;
            } // for
            if (attribute_need_resize) {
                hasErrors = TRUE;
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                if (FixLevel != CheckOnly &&
                    !SDS_attrib.Resize(resizeTo +
                                       SecurityDescriptorsBlockSize,
                                       Mft->GetVolumeBitmap())) {
                    chkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                } else {
                    frs_need_flush = TRUE;

                    if (FixLevel != CheckOnly && SDS_attrib.IsStorageModified() &&
                        !SDS_attrib.InsertIntoFile(&security_frs, Mft->GetVolumeBitmap())) {
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                    }
                }
            }
            if (frs_need_flush) {
                Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_SECURITY_FRS);
                if (FixLevel != CheckOnly &&
                    !security_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", security_frs.QueryFileNumber().GetLowPart());
                    FREE(initial_security_entry);
                    return FALSE;
                }
            }

            ChkdskInfo->TotalNumSID = sid_entries.QueryCardinality().GetLowPart();

            // now make sure each entry in the index has
            // a corresponding entry in the $SDS data stream

            index_need_save = FALSE;
            SII_Index.ResetIterator();
            while (index_entry = SII_Index.GetNext(&depth, &error)) {
                securityId = *(ULONG*)GetIndexEntryValue(index_entry);
                if (!sid_entries.DoesIntersectSet(securityId, 1)) {
                    index_need_save = TRUE;
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                    hasErrors = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY_WITH_ID,
                                        "%d%W%d",
                                        security_frs.QueryFileNumber().GetLowPart(),
                                        SII_Index.GetName(),
                                        securityId);
                    if (FixLevel != CheckOnly && !SII_Index.DeleteCurrentEntry()) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                } else
                    count_sid++;
            } // while

            if (index_need_save && FixLevel != CheckOnly) {
                if (!SII_Index.Save(&security_frs)) {
                    chkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                        "%d%W", security_frs.QueryFileNumber().GetLowPart(),
                                        SII_Index.GetName());
                }
                if (!security_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", security_frs.QueryFileNumber().GetLowPart());
                    FREE(initial_security_entry);
                    return FALSE;
                }
            }

            index_need_save = FALSE;
            SDH_Index.ResetIterator();
            while (index_entry = SDH_Index.GetNext(&depth, &error)) {
                if (hashkey_entries.CheckAndRemove(
                        *(BIG_INT*)GetIndexEntryValue(index_entry),
                        &alreadyExists)) {
                    if (!alreadyExists) {
                        index_need_save = TRUE;
                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY_WITH_ID,
                            "%d%W%d",
                            security_frs.QueryFileNumber().GetLowPart(),
                            SDH_Index.GetName(),
                            ((PSECURITY_HASH_KEY)GetIndexEntryValue(index_entry))->SecurityId);
                        if (FixLevel != CheckOnly && !SDH_Index.DeleteCurrentEntry()) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            FREE(initial_security_entry);
                            return FALSE;
                        }
                    } else
                        count_hashkey++;
                } else {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    FREE(initial_security_entry);
                    return FALSE;
                }
            } // while

            if (index_need_save && FixLevel != CheckOnly) {
                if (!SDH_Index.Save(&security_frs)) {
                    chkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                     "%d%W", security_frs.QueryFileNumber().GetLowPart(),
                                     SDH_Index.GetName());
                }
                if (!security_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", security_frs.QueryFileNumber().GetLowPart());
                    FREE(initial_security_entry);
                    return FALSE;
                }
            }

            if (FixLevel != CheckOnly && !chkdskErrCouldNotFix) {
                DebugAssert(count_hashkey == count_sid);
            }
        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } // if (!error && securityDescriptorStreamPresent)
    } else {
        DebugPrintTrace(("Hotfixed security frs still has problems\n"));
        return FALSE;
    }


    // now each valid entry in SecurityDescriptorStream has a corresponding
    // entry in SecurityIdIndex and SecurityDescriptorHashIndex

    // Compute the number of file records.

    n = Mft->GetDataAttribute()->QueryValueLength().GetLowPart() / Mft->QueryFrsSize();

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time1);
    timestr = ctime(&time1);
    timestr[strlen(timestr)-1] = 0;
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", "Before stage 3: ", timestr);
#endif

    if (!StartProcessingSD(n,
                           FixLevel,
                           Mft,
                           ChkdskReport,
                           ChkdskInfo,
                           &security_frs,
                           BadClusters,
                           &errFixedStatus,
                           securityDescriptorStreamPresent,
                           &sid_entries,
                           &sid_entries2,
                           &hasErrors,
                           SkipEntriesScan,
                           &chkdskErrCouldNotFix,
                           Message)) {
        FREE(initial_security_entry);
        return FALSE;
    }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time2);
    Message->Lock();
    Message->Set(MSG_CHK_NTFS_MESSAGE);
    timestr = ctime(&time2);
    timestr[strlen(timestr)-1] = 0;
    Message->Display("%s%s", "After stage 3: ", timestr);
    Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(time2, time1));
    Message->Unlock();
#endif

    if (securityDescriptorStreamPresent) {


        // now remove those unused sid in the SecurityIdIndex

        SII_Index.ResetIterator();

        // calculate the set of sid that are not in use

        sid_entries.Remove(&sid_entries2);

        sid_entries2.RemoveAll();

        if (!chkdskErrCouldNotFix &&
            (!hasErrors || (hasErrors && FixLevel != CheckOnly))) {

            cleanup_count = 0;
            DebugAssert(sid_entries.QueryCardinality().GetHighPart() == 0);
            for (i=0; i<sid_entries.QueryCardinality(); i++) {
                securityId = sid_entries.QueryNumber(i).GetLowPart();
                while (index_entry = SII_Index.GetNext(&depth, &error)) {
                    if (*(ULONG*)GetIndexEntryValue(index_entry) == securityId) {
                        cleanup_count++;
                        if (FixLevel != CheckOnly && !SII_Index.DeleteCurrentEntry()) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            FREE(initial_security_entry);
                            return FALSE;
                        }
                        break;
                    }
                } // while
#if DBG
                if (FixLevel != CheckOnly && !chkdskErrCouldNotFix)
                    DebugAssert(index_entry != NULL);
#endif
            }
            chkdskCleanUp = chkdskCleanUp || (cleanup_count != 0);

            if (cleanup_count) {
                if (ChkdskInfo->Verbose || hasErrors) {
                    Message->DisplayMsg(MSG_CHK_NTFS_DELETING_UNUSED_INDEX_ENTRY,
                                        "%d%W%d",
                                        security_frs.QueryFileNumber().GetLowPart(),
                                        SII_Index.GetName(),
                                        cleanup_count);
                } else {
                    Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_INDEX_ENTRIES,
                                    "%I64x%W%d",
                                    security_frs.QueryFileNumber().GetLargeInteger(),
                                    SII_Index.GetName(),
                                    cleanup_count);
                }
                if (FixLevel != CheckOnly) {
                    if (!SII_Index.Save(&security_frs)) {
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W", security_frs.QueryFileNumber().GetLowPart(),
                                         SII_Index.GetName());
                    }
                    if (!security_frs.Flush(Mft->GetVolumeBitmap())) {
                        Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                            "%d", security_frs.QueryFileNumber().GetLowPart());
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                }
            }

            //
            // if the SII index is newly created, then include its size into
            // chkdsk report
            //

            if (new_SII_index) {
                alloc_present = security_frs.QueryAttribute(&attrib,
                                                            &error,
                                                            $INDEX_ALLOCATION,
                                                            SII_Index.GetName());

                if (!alloc_present && error) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    FREE(initial_security_entry);
                    return FALSE;
                }
                if (alloc_present) {
                   ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
                }
            }

            // now removes those unused entries in SecurityDescriptorHashIndex

            if (sid_entries.QueryCardinality().GetLowPart()) {
                cleanup_count = 0;
                SDH_Index.ResetIterator();
                while (index_entry = SDH_Index.GetNext(&depth, &error)) {
                    securityId = ((PSECURITY_HASH_KEY)GetIndexEntryValue(index_entry))
                                    ->SecurityId;
                    if (sid_entries.DoesIntersectSet(securityId, 1)) {
                        cleanup_count++;
                        if (FixLevel != CheckOnly && !SDH_Index.DeleteCurrentEntry()) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            FREE(initial_security_entry);
                            return FALSE;
                        }
                    }
                } // while
                chkdskCleanUp = chkdskCleanUp || (cleanup_count != 0);

                if (cleanup_count) {
                    if (ChkdskInfo->Verbose || hasErrors) {
                        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_UNUSED_INDEX_ENTRY,
                                         "%d%W%d",
                                         security_frs.QueryFileNumber().GetLowPart(),
                                         SDH_Index.GetName(),
                                         cleanup_count);
                    } else {
                        Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_INDEX_ENTRIES,
                                        "%I64x%W%d",
                                        security_frs.QueryFileNumber().GetLargeInteger(),
                                        SDH_Index.GetName(),
                                        cleanup_count);
                    }
                    if (FixLevel != CheckOnly) {
                        if (!SDH_Index.Save(&security_frs)) {
                            chkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W", security_frs.QueryFileNumber().GetLowPart(),
                                             SDH_Index.GetName());
                        }
                        if (!security_frs.Flush(Mft->GetVolumeBitmap())) {
                            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                                "%d", security_frs.QueryFileNumber().GetLowPart());
                            FREE(initial_security_entry);
                            return FALSE;
                        }
                    }
                }
            } // if


            //
            // if the SDH index is newly created, then include its size into
            // chkdsk report
            //

            if (new_SDH_index) {
                alloc_present = security_frs.QueryAttribute(&attrib,
                                                            &error,
                                                            $INDEX_ALLOCATION,
                                                            SDH_Index.GetName());

                if (!alloc_present && error) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    FREE(initial_security_entry);
                    return FALSE;
                }
                if (alloc_present) {
                   ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
                }
            }

            // now null those unused entries in SecurityDescriptorStream

            if (sid_entries.QueryCardinality().GetLowPart()) {
                cleanup_count = 0;
                length = SDS_attrib.QueryValueLength().GetLowPart();
                length -= SecurityDescriptorsBlockSize;
                offset = 0;
                frs_need_flush = FALSE;
                endOfBlock = (PSECURITY_ENTRY)((PCHAR)initial_security_entry+
                                               SecurityDescriptorsBlockSize);
                remain_length = length;

                for (;length > 0;) {
                    attribute_need_write = FALSE;
                    bytesToRead = min(SecurityDescriptorsBlockSize, length);
                    security_entry = initial_security_entry;
                    if (!SDS_attrib.Read(security_entry,
                                         offset,
                                         bytesToRead, &num_bytes) ||
                        num_bytes != bytesToRead) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_SECURITY_DATA_STREAM);
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                    while (length > 0) {

                        // see if there is a need to move to next security descriptor block

                        if (security_entry == endOfBlock ||
                            (security_entry->security_descriptor_header.Length == 0 &&
                             security_entry->security_descriptor_header.HashKey.SecurityId == 0 &&
                             security_entry->security_descriptor_header.HashKey.Hash == 0)) {
                            break;
                        }

                        num_bytes = security_entry->security_descriptor_header.Length;
                        securityId = security_entry->security_descriptor_header.HashKey.SecurityId;

                        // skip over invalidated entries

                        if (securityId == SECURITY_ID_INVALID)
                            goto GetNextSDEntry2;

                        if (sid_entries.DoesIntersectSet(securityId, 1)) {

                            // fill the whole thing with zeros except the length byte in the header

                            ClearSecurityDescriptorEntry(security_entry,
                                security_entry->security_descriptor_header.Length -
                                sizeof(SECURITY_DESCRIPTOR_HEADER));
                            attribute_need_write = TRUE;
                            cleanup_count++;
                        }

                    GetNextSDEntry2:
                        if (length == num_bytes) {
                            break; // done, leave the while loop
                        } else {
                            align_num_bytes = (num_bytes + 0xf) & ~0xf;
                            DebugAssert(length > align_num_bytes);
                            length -= align_num_bytes;
                            security_entry = (SECURITY_ENTRY*)
                                                ((PCHAR)security_entry + align_num_bytes);
                        }
                    } // while
                    if (attribute_need_write) {
                        DebugAssert(cleanup_count != 0);
                        if (FixLevel != CheckOnly &&
                            (!SDS_attrib.Write(initial_security_entry,
                                               offset,
                                               bytesToRead,
                                               &bytesWritten,
                                               Mft->GetVolumeBitmap()) ||
                             bytesWritten != bytesToRead)) {
                            chkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                        } else
                            frs_need_flush = TRUE;
                    }
                    offset += (SecurityDescriptorsBlockSize<<1);
                    remain_length -= bytesToRead;
                    if (remain_length >= SecurityDescriptorsBlockSize)
                        remain_length -= SecurityDescriptorsBlockSize;
                    else
                        remain_length = 0;
                    length = remain_length;
                } // for
                chkdskCleanUp = chkdskCleanUp || (cleanup_count != 0);

                if (frs_need_flush) {
                    DebugAssert(cleanup_count != 0);
                    if (ChkdskInfo->Verbose || hasErrors) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CLEANUP_UNUSED_SECURITY_DESCRIPTORS,
                                            "%d", cleanup_count);
                    } else {
                        Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_UNUSED_SECURITY_DESCRIPTORS,
                                        "%d", cleanup_count);
                    }
                    if (FixLevel != CheckOnly &&
                        !security_frs.Flush(Mft->GetVolumeBitmap())) {
                        Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                            "%d", security_frs.QueryFileNumber().GetLowPart());
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                }
            } // if
        } // if

        // now make sure the first copy of the security descriptors in the data
        // stream matches that in the mirror copy

        FREE(initial_security_entry);

        if (!(initial_security_entry = (PSECURITY_ENTRY)
                MALLOC(SecurityDescriptorsBlockSize<<1))) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        total_length = SDS_attrib.QueryValueLength().GetLowPart();
        length = (SecurityDescriptorsBlockSize<<1);
        fixing_mirror = FALSE;
        for (offset=0; offset < total_length; offset+=length) {
            bytesToRead = min(length, total_length-offset);
            if (!SDS_attrib.Read(initial_security_entry,
                                 offset,
                                 bytesToRead,
                                 &num_bytes) ||
                num_bytes != bytesToRead) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_SECURITY_DATA_STREAM);
                FREE(initial_security_entry);
                return FALSE;
            }
            bytesToRead -= SecurityDescriptorsBlockSize;
            if (memcmp((PVOID)initial_security_entry,
                       (PVOID)((PCHAR)initial_security_entry+
                               SecurityDescriptorsBlockSize),
                       bytesToRead)) {

                if (hasErrors || ChkdskInfo->Verbose || !chkdskCleanUp) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SDS_MIRROR,
                                    "%x", offset);
                }

                if (hasErrors || !chkdskCleanUp)
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                if (FixLevel != CheckOnly &&
                    (!SDS_attrib.Write(initial_security_entry,
                                       offset+SecurityDescriptorsBlockSize,
                                       bytesToRead,
                                       &bytesWritten,
                                       Mft->GetVolumeBitmap()) ||
                     bytesToRead != bytesWritten)) {
                    chkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                } else
                    fixing_mirror = TRUE;
            }
        } // for
        if (fixing_mirror) {
            if (hasErrors || ChkdskInfo->Verbose || !chkdskCleanUp) {
                Message->DisplayMsg(MSG_CHK_NTFS_FIXING_SECURITY_DATA_STREAM_MIRROR);
            }
            if (FixLevel != CheckOnly &&
                !security_frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                FREE(initial_security_entry);
                return FALSE;
            }
        }

        FREE(initial_security_entry);
    } // if (securityDescriptorStreamPresent)

    Message->DisplayMsg(MSG_CHK_NTFS_SECURITY_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
    else if (chkdskCleanUp) {
        _cleanup_that_requires_reboot = TRUE;
        if (ChkdskInfo->ExitStatus == CHKDSK_EXIT_SUCCESS)
            ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
    }

    return TRUE;
}
#endif // _SETUP_LOADER_

ULONG
ComputeSecurityDescriptorHash(
   IN PSECURITY_DESCRIPTOR    SecurityDescriptor,
   IN ULONG                   Length
   )
{
   ULONG    hash = 0;
   ULONG    count = Length / 4;
   PULONG   rover = (PULONG)SecurityDescriptor;

   DebugAssert(rover);
   if (!rover)
      return 0;

   while (count--) {
       hash = ((hash << 3) | (hash >> (32-3))) + *rover++;
   }
   return hash;
}

ULONG
ComputeDefaultSecurityId(
   PNUMBER_SET  SidSet
   )
{
    BIG_INT  start;
    BIG_INT  length;

    if (SidSet->QueryCardinality() == 0)
        return SECURITY_ID_FIRST;

    SidSet->QueryDisjointRange(0, &start, &length);
    if (start > SECURITY_ID_FIRST)
        return SECURITY_ID_FIRST;
    else {
        start += length;
        DebugAssert(start.GetHighPart() == 0);
        return start.GetLowPart();
    }
}

VOID
ClearSecurityDescriptorEntry(
    IN OUT  PSECURITY_ENTRY Security_entry,
    IN      ULONG           SecurityDescriptorSize
    )
{
    Security_entry->security_descriptor_header.Offset =
        Security_entry->security_descriptor_header.HashKey.Hash = 0;
    Security_entry->security_descriptor_header.HashKey.SecurityId =
        SECURITY_ID_INVALID;
    memset(&(Security_entry->security), 0, SecurityDescriptorSize);
}

VOID
MarkEndOfSecurityDescriptorsBlock(
    IN OUT  PSECURITY_ENTRY Security_entry,
    IN      ULONG           LengthOfBlock
    )
{
    // zero the length, hash values, and set invalid SID
    // also zero the rest of the block

    memset(Security_entry, 0, LengthOfBlock);
    DebugAssert(SECURITY_ID_INVALID == 0);
}

BOOLEAN
RemainingBlockIsZero(
    IN OUT  PCHAR   Buffer,
    IN      ULONG   Size
    )
{
    PCHAR   endp;

    endp = Buffer+Size;
    while (Buffer < endp)
        if (*Buffer == 0)
            Buffer++;
        else
            return FALSE;
    return TRUE;
}

BOOLEAN
RecoverSecurityDescriptorsDataStream(
    IN OUT PNTFS_FILE_RECORD_SEGMENT    Frs,
    IN OUT PNTFS_ATTRIBUTE              Attrib,
    IN     ULONG                        AttributeSize,
    IN     PCHAR                        Buffer,
    IN     ULONG                        BufferSize,
    IN     ULONG                        ClusterSize,
    IN OUT PNTFS_BITMAP                 Bitmap,
    OUT    PBOOLEAN                     DiskHasErrors,
    IN OUT PNUMBER_SET                  BadClusters,
    IN OUT PMESSAGE                     Message,
    IN     BOOLEAN                      FixLevel
    )
/*++

Routine Description:

    This method replaces all those unreadable clusters with readable
    one.  It grabs data from the mirror copy of the stream for those
    new clusters.

Arguments:

Return Value:

    TRUE upon successful completion.

--*/
{
    PREPAIR_RECORD  pRecord;
    PREPAIR_RECORD  pFirstRecord;
    USHORT          recordCount = 0;
    NUMBER_SET      badClusterNumSet;
    BIG_INT         currentBytesRecovered;
    ULONG           bytesToRead;
    ULONG           offset;
    ULONG           length;
    ULONG           num_bytes;
    BOOLEAN         result = TRUE;

    *DiskHasErrors = FALSE;

    if (!badClusterNumSet.Initialize() ||
        !(pRecord = (PREPAIR_RECORD)MALLOC((SecurityDescriptorsBlockSize/
                                     ClusterSize)*sizeof(REPAIR_RECORD)))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    offset = 0;
    length = AttributeSize;
    if (length < SecurityDescriptorsBlockSize) {

        // doesn't matter as the stream will be zapped

        FREE(pRecord);
        if (FixLevel != CheckOnly) {

            // no need to say disk has errors as its length is invalid anyway

            result = Attrib->RecoverAttribute(Bitmap,
                                              &badClusterNumSet,
                                              &currentBytesRecovered);
        } else {
            FREE(pRecord);
            return TRUE;
        }
    } else {

        length -= SecurityDescriptorsBlockSize;

        while (length > 0) {
            bytesToRead = min(length, BufferSize);

            if (!Attrib->Read(Buffer,
                              offset,
                              bytesToRead,
                              &num_bytes)) {
                RepairSecurityDescriptorsSegment(Attrib,
                                                 Buffer,
                                                 offset,
                                                 bytesToRead,
                                                 pRecord,
                                                 &recordCount,
                                                 ClusterSize);
                *DiskHasErrors = TRUE;
            }
            offset += (SecurityDescriptorsBlockSize<<1);
            length -= bytesToRead;
            if (length > SecurityDescriptorsBlockSize)
                length -= SecurityDescriptorsBlockSize;
            else
                length = 0;
        }

        if (*DiskHasErrors) {
            Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_UNREADABLE_SECURITY_DATA_STREAM);
        } else {
            FREE(pRecord);
            return TRUE;
        }

        if (FixLevel == CheckOnly) {
            FREE(pRecord);
            return TRUE;
        }
        if (Attrib->RecoverAttribute(Bitmap,
                                     &badClusterNumSet,
                                     &currentBytesRecovered)) {
            pFirstRecord = pRecord;
            while (recordCount-- > 0) {
                offset = pFirstRecord->Offset;
                bytesToRead = pFirstRecord->Length;
                pFirstRecord++;
                if (Attrib->Read(Buffer,
                                 offset+SecurityDescriptorsBlockSize,
                                 bytesToRead,
                                 &num_bytes) &&
                    num_bytes == bytesToRead) {
                    if (!Attrib->Write(Buffer,
                                       offset,
                                       bytesToRead,
                                       &num_bytes,
                                       NULL) ||
                        num_bytes != bytesToRead) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                        result = FALSE;
                        break;
                    }
                } else {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_SECURITY_DATA_STREAM);
                    result = FALSE;
                    break;
                }
            } // while
        } else {
            result = FALSE;
        }
    }

    if (result && Attrib->IsStorageModified() &&
        !Attrib->InsertIntoFile(Frs, Bitmap)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                            "%d%d", $DATA, Frs->QueryFileNumber().GetLowPart());
        result = FALSE;
    }

    if (!BadClusters->Add(&badClusterNumSet)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        result = FALSE;
    }

    FREE(pRecord);
    return result;
}

BOOLEAN
RepairSecurityDescriptorsSegment(
    IN OUT  PNTFS_ATTRIBUTE Attrib,
    IN      PCHAR           Buffer,
    IN      ULONG           Offset,
    IN      ULONG           BytesToProcess,
    IN OUT  PREPAIR_RECORD  Record,
    IN OUT  USHORT          *RecordCount,
    IN      ULONG           ClusterSize
    )
/*++

Routine Description:

    This method identifies all those records that can be fixed up
    by reading the data out from the mirror copy.

Arguments:

Return Value:

    TRUE if all unreadable records can be recovered with no loss of data.
    FALSE if not all unreadable records can be recovered with no loss of data.

--*/
{
    ULONG   bytesToRead;
    ULONG   num_bytes;
    BOOLEAN completeRecovery = TRUE;

    bytesToRead = BytesToProcess/2;

    if (!Attrib->Read(Buffer,
                      Offset,
                      bytesToRead,
                      &num_bytes) ||
        bytesToRead != num_bytes) {
        if (!Attrib->Read(Buffer,
                          Offset+SecurityDescriptorsBlockSize,
                          bytesToRead,
                          &num_bytes)) {
            if (bytesToRead > ClusterSize) {
                completeRecovery =
                    completeRecovery &&
                    RepairSecurityDescriptorsSegment(Attrib,
                                                     Buffer,
                                                     Offset,
                                                     bytesToRead,
                                                     Record,
                                                     RecordCount,
                                                     ClusterSize);
            } else
                return FALSE;
        } else {
            Record[*RecordCount].Offset = Offset;
            Record[(*RecordCount)++].Length = bytesToRead;
        }
    }

    bytesToRead = BytesToProcess-bytesToRead;

    if (!Attrib->Read(Buffer,
                      Offset+bytesToRead,
                      bytesToRead,
                      &num_bytes) ||
        bytesToRead != num_bytes) {
        if (!Attrib->Read(Buffer,
                          Offset+bytesToRead+SecurityDescriptorsBlockSize,
                          bytesToRead,
                          &num_bytes)) {
            if (bytesToRead > ClusterSize) {
                completeRecovery =
                    completeRecovery &&
                    RepairSecurityDescriptorsSegment(Attrib,
                                                     Buffer,
                                                     Offset+bytesToRead,
                                                     bytesToRead,
                                                     Record,
                                                     RecordCount,
                                                     ClusterSize);
            } else
                return FALSE;
        } else {
            Record[*RecordCount].Offset = Offset + bytesToRead;
            Record[(*RecordCount)++].Length = bytesToRead;
        }
    }
    return completeRecovery;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

TARGETNAME=untfs
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(PROJECT_LIB_PATH)\patchbc.lib \
           $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib    \
           $(PROJECT_ROOT)\fs\utils\\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib

USE_MSVCRT=1
DLLENTRY=InitializeUntfs
PRECOMPILED_INCLUDE= ..\pch.cxx
MSC_WARNING_LEVEL=/W3 /WX

SOURCES= ..\attrcol.cxx    \
         ..\attrdef.cxx    \
         ..\attrib.cxx     \
         ..\attrlist.cxx   \
         ..\attrrec.cxx    \
         ..\badfile.cxx    \
         ..\bitfrs.cxx     \
         ..\bootfile.cxx   \
         ..\clusrun.cxx    \
         ..\downgrad.cxx   \
         ..\entry.cxx      \
         ..\extents.cxx    \
         ..\format.cxx     \
         ..\frs.cxx        \
         ..\frsstruc.cxx   \
         ..\hackwc.cxx     \
         ..\indxbuff.cxx   \
         ..\indxchk.cxx    \
         ..\indxroot.cxx   \
         ..\indxtree.cxx   \
         ..\largemcb.c     \
         ..\logfile.cxx    \
         ..\mft.cxx        \
         ..\mftfile.cxx    \
         ..\mftinfo.cxx    \
         ..\mftref.cxx     \
         ..\ntfsbit.cxx    \
         ..\ntfschk.cxx    \
         ..\ntfssa.cxx     \
         ..\ntfsvol.cxx    \
         ..\rafile.cxx     \
         ..\rasd.cxx       \
         ..\sdchk.cxx      \
         ..\untfs.cxx      \
         ..\upcase.cxx     \
         ..\upfile.cxx     \
         ..\usnjrnl.cxx    \
         ..\untfs.rc

INCLUDES=..\.;          \
         ..\..\inc;     \
         $(PROJECT_ROOT)\fs\utils\ulib\inc;     \
         $(PROJECT_ROOT)\fs\utils\ifsutil\inc;  \
         $(DDK_INC_PATH)

C_DEFINES=/DUNICODE=1
!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console
DLLDEF=..\untfs.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\untfs.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        untfs.cxx

Abstract:

        This module contains run-time, global support for the
        NTFS IFS Utilities library (UNTFS).  This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Bill McJohn (billmc) 15-Aug-1991

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "untfs.hxx"

extern "C" {
    #include <patchbc.h>
    #include "rtmsg.h"
    extern UCHAR NtfsBootCode[8192];
}

#ifdef _AUTOCHECK_

BOOLEAN
SimpleFetchMessageTextInOemCharSet(
    IN  ULONG  MessageId,
    OUT CHAR  *Text,
    IN  ULONG  BufferLen
    );

#endif // _AUTOCHECK_


//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

BOOLEAN
PatchNtfsBootCodeMessages(
    VOID
    );



extern "C"
BOOLEAN
InitializeUntfs (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        );

BOOLEAN
InitializeUntfs (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Untfs by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#ifdef _AUTOCHECK_

    UNREFERENCED_PARAMETER( Reason );

    if(!PatchNtfsBootCodeMessages()) {
        DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
        return(FALSE);
    }

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Untfs initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_UNTFS_MEM_LEAK)
    DebugPrint("UNTFS.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
            //
            // Get translated boot messages into FAT boot code.
            //
            if(!PatchNtfsBootCodeMessages()) {
                //
                // Internal error only, don't worry about translating it.
                //
                MessageBoxA(
                    NULL,
                    "Internal error: Translated boot messages are too long or missing.",
                    "ULIB.DLL (UNTFS.DLL)",
                    MB_ICONERROR | MB_SYSTEMMODAL | MB_OK
                    );

                DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
                return(FALSE);
            }

            // Success, FALL THROUGH to thread attach case

        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrintTrace(("UNTFS.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Untfs initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_UNTFS_MEM_LEAK)
            DebugPrint("UNTFS.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrintTrace(("UNTFS.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrint("UNTFS.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrint("UNTFS.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif // _AUTOCHECK_

    return TRUE;
}



DECLARE_CLASS( NTFS_ATTRIBUTE );
DECLARE_CLASS( NTFS_ATTRIBUTE_COLUMNS );
DECLARE_CLASS( NTFS_ATTRIBUTE_DEFINITION_TABLE );
DECLARE_CLASS( NTFS_ATTRIBUTE_LIST );
DECLARE_CLASS( NTFS_ATTRIBUTE_RECORD );
DECLARE_CLASS( NTFS_BAD_CLUSTER_FILE );
DECLARE_CLASS( NTFS_BITMAP_FILE );
DECLARE_CLASS( NTFS_BOOT_FILE );
DECLARE_CLASS( NTFS_CLUSTER_RUN );
DECLARE_CLASS( NTFS_EXTENT );
DECLARE_CLASS( NTFS_EXTENT_LIST );
DECLARE_CLASS( NTFS_FILE_RECORD_SEGMENT );
DECLARE_CLASS( NTFS_FRS_STRUCTURE );
DECLARE_CLASS( NTFS_INDEX_BUFFER );
DECLARE_CLASS( NTFS_INDEX_ROOT );
DECLARE_CLASS( NTFS_INDEX_TREE );
DECLARE_CLASS( NTFS_LOG_FILE );
DECLARE_CLASS( NTFS_MASTER_FILE_TABLE );
DECLARE_CLASS( NTFS_MFT_FILE );
DECLARE_CLASS( NTFS_MFT_INFO );
DECLARE_CLASS( NTFS_REFLECTED_MASTER_FILE_TABLE );
DECLARE_CLASS( NTFS_BITMAP );
DECLARE_CLASS( NTFS_UPCASE_FILE );
DECLARE_CLASS( NTFS_UPCASE_TABLE );
DECLARE_CLASS( NTFS_VOL );
DECLARE_CLASS( NTFS_SA );
DECLARE_CLASS( RA_PROCESS_FILE );
DECLARE_CLASS( RA_PROCESS_SD );

STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
        if( DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_DEFINITION_TABLE    ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE                     ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_COLUMNS             ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_LIST                ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_RECORD              ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_BAD_CLUSTER_FILE              ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_BITMAP_FILE                   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_BOOT_FILE                     ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_CLUSTER_RUN                   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_EXTENT                        ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_EXTENT_LIST                   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_FILE_RECORD_SEGMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_FRS_STRUCTURE                 ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_BUFFER                  ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_ROOT                    ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_TREE                    ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_LOG_FILE                      ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_MASTER_FILE_TABLE             ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_MFT_FILE                      ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_MFT_INFO                      ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_REFLECTED_MASTER_FILE_TABLE   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_UPCASE_FILE                   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_UPCASE_TABLE                  ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_VOL                           ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_SA                            ) &&
        DEFINE_CLASS_DESCRIPTOR( RA_PROCESS_FILE                    ) &&
        DEFINE_CLASS_DESCRIPTOR( RA_PROCESS_SD                      ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_BITMAP                        ) ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_DEFINITION_TABLE    );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE                     );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_COLUMNS             );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_LIST                );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_RECORD              );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_BAD_CLUSTER_FILE              );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_BITMAP_FILE                   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_BOOT_FILE                     );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_CLUSTER_RUN                   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_EXTENT                        );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_EXTENT_LIST                   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_FILE_RECORD_SEGMENT           );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_FRS_STRUCTURE                 );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_BUFFER                  );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_ROOT                    );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_TREE                    );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_LOG_FILE                      );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_MASTER_FILE_TABLE             );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_MFT_FILE                      );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_MFT_INFO                      );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_REFLECTED_MASTER_FILE_TABLE   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_UPCASE_FILE                   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_UPCASE_TABLE                  );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_VOL                           );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_SA                            );
    UNDEFINE_CLASS_DESCRIPTOR( RA_PROCESS_FILE                    );
    UNDEFINE_CLASS_DESCRIPTOR( RA_PROCESS_SD                      );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_BITMAP                        );
    return TRUE;
}


BOOLEAN
PatchNtfsBootCodeMessages(
    VOID
    )
{
    CHAR NtldrMissing[100];
    CHAR NtldrCompressed[100];
    CHAR DiskError[100];
    CHAR PressKey[100];

    //
    // Get message text.
    //
#ifdef _AUTOCHECK_
    //
    // ntlib.lib, messages are in the binary being run.
    //
    {
        BOOLEAN b;

        b = SimpleFetchMessageTextInOemCharSet(
                MSG_BOOT_NTFS_NTLDR_MISSING,
                NtldrMissing,
                sizeof(NtldrMissing)
                );

        if(b) {
            b = SimpleFetchMessageTextInOemCharSet(
                    MSG_BOOT_NTFS_NTLDR_COMPRESSED,
                    NtldrCompressed,
                    sizeof(NtldrCompressed)
                    );

            if(b) {
                b = SimpleFetchMessageTextInOemCharSet(
                        MSG_BOOT_NTFS_IO_ERROR,
                        DiskError,
                        sizeof(DiskError)
                        );

                if(b) {
                    b = SimpleFetchMessageTextInOemCharSet(
                            MSG_BOOT_NTFS_PRESS_KEY,
                            PressKey,
                            sizeof(PressKey)
                            );
                }
            }

            if(!b) {
                return(FALSE);
            }
        }
    }
#else
    //
    // Win32 case, messages are in ulib.dll.
    //
    {
        HINSTANCE h;
        DWORD d;

        h = LoadLibraryEx(TEXT("ULIB"),NULL,LOAD_LIBRARY_AS_DATAFILE);
        if(!h) {
            return(FALSE);
        }

        d = FormatMessageA(
                FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                h,
                MSG_BOOT_NTFS_NTLDR_MISSING,
                0,
                NtldrMissing,
                sizeof(NtldrMissing),
                NULL
                );

        if(d) {

            d = FormatMessageA(
                    FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                    h,
                    MSG_BOOT_NTFS_IO_ERROR,
                    0,
                    DiskError,
                    sizeof(DiskError),
                    NULL
                    );

            if(d) {
                d = FormatMessageA(
                        FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                        h,
                        MSG_BOOT_NTFS_PRESS_KEY,
                        0,
                        PressKey,
                        sizeof(PressKey),
                        NULL
                        );

                if(d) {
                    d = FormatMessageA(
                            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                            h,
                            MSG_BOOT_NTFS_NTLDR_COMPRESSED,
                            0,
                            NtldrCompressed,
                            sizeof(NtldrCompressed),
                            NULL
                            );
                }
            }
        }

        FreeLibrary(h);
        if(!d) {
            return(FALSE);
        }

        CharToOemA(NtldrMissing,NtldrMissing);
        CharToOemA(NtldrCompressed,NtldrCompressed);
        CharToOemA(DiskError,DiskError);
        CharToOemA(PressKey,PressKey);
    }
#endif

    //
    // Call code in patchbc.lib to do the patching now that we've got
    // the translated message text.
    //
    if(!PatchMessagesIntoNtfsBootCode(NtfsBootCode,NtldrMissing,NtldrCompressed,DiskError,PressKey)) {

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ureg\src\makefile.inc ===
!IF !$(FREEBUILD)

$(O)\ureg.def: ..\def$(TARGET_DIRECTORY).fre ..\def$(TARGET_DIRECTORY).dbg
        copy ..\def$(TARGET_DIRECTORY).fre + ..\def$(TARGET_DIRECTORY).dbg $(O)\ureg.def

!ELSE

$(O)\ureg.def: ..\def$(TARGET_DIRECTORY).fre
        copy ..\def$(TARGET_DIRECTORY).fre $(O)\ureg.def

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\upfile.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    upfile.cxx

Abstract:

    This module contains the declarations for the NTFS_UPCASE_FILE
    class, which models the upcase-table file for an NTFS volume.
    This class' main purpose in life is to encapsulate the creation
    of this file.

Author:

    Bill McJohn (billmc) 04-March-1992

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "ntfsbit.hxx"
#include "drive.hxx"
#include "attrib.hxx"
#include "bitfrs.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "message.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_UPCASE_FILE,
                             NTFS_FILE_RECORD_SEGMENT,
                             UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_UPCASE_FILE::~NTFS_UPCASE_FILE(
    )
{
    Destroy();
}


VOID
NTFS_UPCASE_FILE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
NTFS_UPCASE_FILE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_UPCASE_FILE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
}



UNTFS_EXPORT
BOOLEAN
NTFS_UPCASE_FILE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes an Upcase File object.  The only special
    knowledge that it adds to the File Record Segment initialization
    is the location within the Master File Table of the Upcase table
    file.

Arguments:

    Mft             -- Supplies the volume MasterFile Table.
    UpcaseTable     -- Supplies the volume upcase table.

Return Value:

    TRUE upon successful completion

Notes:

    This class is reinitializable.


--*/
{
    Destroy();

    return( NTFS_FILE_RECORD_SEGMENT::Initialize( UPCASE_TABLE_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_UPCASE_FILE::Create(
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN      PNTFS_UPCASE_TABLE      UpcaseTable,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
    )
/*++

Routine Description:

    This method formats an Upcase-File File Record
    Segment in memory (without writing it to disk).

    It creates a DATA attribute to hold the volume's upcase
    table and writes the table to disk through that attribute.

Arguments:

    StandardInformation --  Supplies the standard information for the
                            file record segment.
    UpcaseTable         --  Supplies the volume's upcase table.
    VolumeBitmap        --  Supplies the volume bitmap

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;


    // Set this object up as a File Record Segment.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }

    // Create an unnamed data attribute, write the upcase table out
    // through that attribute, and save the attribute to this file.
    //
    if( !Extents.Initialize( 0, 0 ) ||
        !DataAttribute.Initialize( GetDrive(),
                                   QueryClusterFactor(),
                                   &Extents,
                                   0,
                                   0,
                                   $DATA,
                                   NULL ) ||
        !UpcaseTable->Write( &DataAttribute, VolumeBitmap ) ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_UPCASE_FILE::VerifyAndFix(
    IN OUT  PNTFS_UPCASE_TABLE  UpcaseTable,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNUMBER_SET         BadClusterList,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine compares the given attribute definition table with
    the one contained in this file's DATA attribute and ensures
    that both are the same.  The in-memory version will override the
    on-disk version.

Arguments:

    UpcaseTable     - Supplies the in-memory version of the table.
    VolumeBitmap    - Supplies the volume bitmap.
    BadClusterList  - Supplies the list of bad clusters.
    RootIndex       - Supplies the root index.
    Changes         - Returns whether or not changes were made.
    FixLevel        - Supplies the fix up level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE                  data_attribute;
    BOOLEAN                         errors;
    PCWCHAR                         mem_upcase;
    PWCHAR                          disk_upcase;
    ULONG                           num_char;
    NTFS_EXTENT_LIST                extent_list;
    BOOLEAN                         ErrorInAttribute;
    ULONG                           value_length;
    ULONG                           num_bytes;

    *Changes = FALSE;

    mem_upcase = UpcaseTable->GetUpcaseArray(&num_char);

    if (!(disk_upcase = NEW WCHAR[num_char])) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!QueryAttribute(&data_attribute, &ErrorInAttribute, $DATA)) {

        *Changes = TRUE;

        if (!ErrorInAttribute) {
            Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_DATA_ATTR_IN_UPCASE_FILE);
        }

        if (!extent_list.Initialize(0, 0)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!data_attribute.Initialize(GetDrive(),
                                       QueryClusterFactor(),
                                       &extent_list,
                                       0,
                                       0,
                                       $DATA)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    value_length = num_char*sizeof(WCHAR);

    errors = FALSE;
    if (*Changes) {
        errors = TRUE;
    } else if (value_length != data_attribute.QueryValueLength()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_UPCASE_FILE_LENGTH,
                     "%I64x%x",
                     data_attribute.QueryValueLength().GetLargeInteger(),
                     value_length);
        errors = TRUE;
    } else if (!data_attribute.Read(disk_upcase, 0, value_length, &num_bytes)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_UPCASE_TABLE);

        errors = TRUE;
    } else if (num_bytes != value_length) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_UPCASE_TABLE);

        errors = TRUE;
    } else if (memcmp(mem_upcase, disk_upcase, value_length)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_UPCASE_FILE);
        errors = TRUE;
    }

    if (errors) {

        *Changes = TRUE;

        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_UPCASE_FILE);

        if (FixLevel != CheckOnly) {
            if (!data_attribute.MakeNonresident(VolumeBitmap) ||
                !data_attribute.Resize(value_length, VolumeBitmap) ||
                !data_attribute.Write(mem_upcase, 0, value_length, &num_bytes,
                                      VolumeBitmap) ||
                num_bytes != value_length) {

                if (!data_attribute.RecoverAttribute(VolumeBitmap, BadClusterList) ||
                    !data_attribute.Write(mem_upcase, 0, value_length,
                                          &num_bytes, VolumeBitmap) ||
                    num_bytes != value_length) {

                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_UPCASE_FILE);
                    DELETE(disk_upcase);
                    return FALSE;
                }
            }
        }

        if (!data_attribute.InsertIntoFile(this, VolumeBitmap)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_UPCASE_FILE);
            DELETE(disk_upcase);
            return FALSE;
        }
    }

    if (FixLevel != CheckOnly && !Flush(VolumeBitmap, RootIndex)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_UPCASE_FILE);
        DELETE(disk_upcase);
        return FALSE;
    }

    DELETE(disk_upcase);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\upcase.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    upcase.cxx

Abstract:

    This module contains the member function definitions for the
    NTFS_UPCASE_TABLE class.  This class models the upcase table
    stored on an NTFS volume, which is used to upper-case characters
    in attribute and file names for comparison.

Author:

    Bill McJohn (billmc) 04-March-92

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "attrib.hxx"
#include "ntfsbit.hxx"
#include "upcase.hxx"

extern "C" {
#include <ctype.h>
}


DEFINE_EXPORTED_CONSTRUCTOR( NTFS_UPCASE_TABLE, OBJECT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_UPCASE_TABLE::~NTFS_UPCASE_TABLE(
    )
/*++

Routine Description:

    This method is the destructor for the class.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
NTFS_UPCASE_TABLE::Construct(
    )
/*++

routine Description:

    This method is the helper function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Data = NULL;
    _Length = 0;
}

VOID
NTFS_UPCASE_TABLE::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE( _Data );
    _Length = 0;
}



UNTFS_EXPORT
BOOLEAN
NTFS_UPCASE_TABLE::Initialize(
    IN PNTFS_ATTRIBUTE Attribute
    )
/*++

Routine Description:

    This method initializes the object based on the value of
    an NTFS Attribute.

Arguments:

    Attribute   --  Supplies the attribute whose value is the
                    upcase table.


Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG BytesInValue, BytesRead;


    DebugPtrAssert( Attribute );

    Destroy();

    // Perform validity checks on the attribute; it must be
    // small enough that the length fits in a ULONG, and
    // its length must be a multiple of sizeof(WCHAR).

    if( Attribute->QueryValueLength().GetHighPart() != 0 ) {

        DebugAbort( "Upcase table is impossibly large.\n" );
        return FALSE;
    }

    BytesInValue = Attribute->QueryValueLength().GetLowPart();

    if( BytesInValue % sizeof(WCHAR) != 0 )  {

        DebugAbort( "Upcase table is an odd number of bytes.\n" );
        return FALSE;
    }

    // Allocate the buffer for the upcase data and read the attribute
    // value into it.

    if( (_Data = (PWCHAR)MALLOC( BytesInValue )) == NULL ||
        !Attribute->Read( _Data,
                          0,
                          BytesInValue,
                          &BytesRead ) ||
        BytesRead != BytesInValue ) {

        Destroy();
        return FALSE;
    }

    // _Length is the number of WCHAR's in the table.

    _Length = BytesInValue / sizeof(WCHAR);

    return TRUE;
}


BOOLEAN
NTFS_UPCASE_TABLE::Initialize(
    IN PWCHAR   Data,
    IN ULONG    Length
    )
/*++

Routine Description:

    This method initializes the upcase table based on client-supplied
    data.

Arguments:

    Data    --  Supplies the data for the table.
    Length  --  Supplies the number of WCHAR's in the table.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    if( (_Data = (PWCHAR)MALLOC( Length * sizeof(WCHAR) )) == NULL ) {

        Destroy();
        return FALSE;
    }

    memcpy( _Data, Data, Length * sizeof(WCHAR) );

    _Length = Length;

    return TRUE;
}



BOOLEAN
NTFS_UPCASE_TABLE::Initialize(
    )
/*++

Routine Description:

    This method initializes the upcase table based on system defaults.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    CONST ULONG MaximumChunkLength = 16 * 1024;
    WCHAR w;
    ULONG i, ChunkLength;
    UNICODE_STRING UpcaseMe;
    NTSTATUS Status;

    _Length = QueryDefaultLength();

    if( (_Data = (PWCHAR)MALLOC( _Length * sizeof(WCHAR) )) == NULL ) {

        Destroy();
        return FALSE;
    }

    // First, set the table up as an identity transformation:
    //
    for( i = 0; i < _Length; i++ ) {

        _Data[i] = (WCHAR)i;
    }

    // Now call RtlUpcaseUnicodeString on successive chunks
    // of the buffer.
    //
    ChunkLength = MaximumChunkLength;

    for( i = 0; i < _Length; i += ChunkLength ) {

        if( i + ChunkLength > _Length ) {

            ChunkLength = (ULONG)(_Length - i);
        }

        UpcaseMe.Length        = (USHORT)(sizeof(WCHAR) * ChunkLength);
        UpcaseMe.MaximumLength = (USHORT)(sizeof(WCHAR) * ChunkLength);
        UpcaseMe.Buffer        = _Data + i;

        Status = RtlUpcaseUnicodeString( &UpcaseMe,
                                         &UpcaseMe,
                                         FALSE );

        if( !NT_SUCCESS(Status) ) {

            DebugPrintTrace(( "UNTFS: RtlUpcaseUnicodeString failed - status 0x%x\n", Status ));
            Destroy();
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_UPCASE_TABLE::Verify(
    ) CONST
/*++

Routine Description:

    This routine ensures that the first 128 entries of this
    table are compliant with the ANSI character set.

Arguments:

    None.

Return Value:

    FALSE   - This table is not valid.
    TRUE    - This table is valid.

--*/
{
    WCHAR   i;

    if (_Length < 128) {
        return FALSE;
    }

    for (i = 0; i < 128; i++) {
        if (_Data[i] != toupper(i)) {
            return FALSE;
        }
    }

    return TRUE;
}



LONG
UNTFS_EXPORT
NtfsUpcaseCompare(
    IN PCWSTR               LeftName,
    IN ULONG                LeftNameLength,
    IN PCWSTR               RightName,
    IN ULONG                RightNameLength,
    IN PCNTFS_UPCASE_TABLE  UpcaseTable,
    IN BOOLEAN              CaseSensitive
    )
/*++

Routine Description:

    This function compares two NTFS names.

Arguments:

    LeftName        --  Supplies the left-hand operand of the comparison.
    LeftNameLength  --  Supplies the length in characters of LeftName.
    RightName       --  Supplies the Right-hand operand of the comparison.
    RightNameLength --  Supplies the length in characters of RightName.
    UpcaseTable     --  Supplies the volume upcase table.
    CaseSensitive   --  Supplies a flag which, if TRUE, indicates that
                        the comparison is case-sensitive.

Return Value:

    <0 if LeftName is less than RightName.
     0 if the names are equal.
    >0 if LeftName is greater than RightName.

Notes:

    UpcaseTable may be NULL if either or both names are zero-length,
    or if the names are exactly identical.  Otherwise, it must point
    at an initialized Upcase Table object.

    If the comparison is case-sensitive, then the names are first
    compared case-insensitive.  If that comparison evaluates to equality,
    then they are compared case-sensitive.  Attribute names and
    non-DOS, non-NTFS file names are compared case-sensitive.

--*/
{
    ULONG ShorterLength, i;
    LONG Result;

    // First, if both names have zero length, then they're equal.
    //
    if( LeftNameLength == 0 && RightNameLength == 0 ) {

        return 0;
    }

    // At least one has a non-zero-length name.  If the other has
    // a zero-length name, it's the lesser of the two.
    //
    if( LeftNameLength == 0 ) {

        return -1;
    }

    if( RightNameLength == 0 ) {

        return 1;
    }

    // Both have non-zero length names.  If they have the same length,
    // do a quick memcmp to see if they're identical.
    //
    if( LeftNameLength == RightNameLength &&
        memcmp( LeftName, RightName, LeftNameLength * sizeof(WCHAR) ) == 0 ) {

        return 0;
    }

    // Perform case-insensitive comparison.  This requires
    // UpcaseTable to be valid.
    //
    DebugPtrAssert( UpcaseTable );

    ShorterLength = MIN( LeftNameLength, RightNameLength );

    for( i = 0; i < ShorterLength; i++ ) {

        Result =  UpcaseTable->UpperCase( LeftName[i] ) -
                  UpcaseTable->UpperCase( RightName[i] );

        if( Result != 0 ) {

            return Result;
        }
    }

    // The names are case-insensitive equal for the length of
    // the shorter name; if they are of different lengths, the
    // shorter is the lesser.
    //
    Result = LeftNameLength - RightNameLength;

    if( Result != 0 ) {

        return Result;
    }

    // The names are equal except for case.  If this is an
    // case-sensitive comparison, perform a final comparison;
    // otherwise, they're equal.
    //
    if( !CaseSensitive ) {

        return 0;

    } else {

        // We already know they're of the same length.
        //
        for( i = 0; i < LeftNameLength; i++ ) {

            Result = LeftName[i] - RightName[i];

            if( Result != 0 ) {

                return Result;
            }
        }

        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ureg\src\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ureg\src\registry.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    registry.cxx

Abstract:

    This module contains the methods for the REGISTRY class.

Author:

    Jaime Sasson (jaimes) 26-Aug-1991

Environment:

    Ulib, Regedit, Windows, User Mode

--*/

#include "registry.hxx"


#if defined( _AUTOCHECK_ )

#define KEY_BASIC_SIZE      sizeof(KEY_BASIC_INFORMATION)+MAXIMUM_FILENAME_LENGTH
#define KEY_FULL_SIZE       sizeof(KEY_FULL_INFORMATION)+MAXIMUM_FILENAME_LENGTH
#define VALUE_BASIC_SIZE    sizeof(KEY_VALUE_BASIC_INFORMATION)+MAXIMUM_FILENAME_LENGTH
#define VALUE_FULL_SIZE     sizeof(KEY_VALUE_FULL_INFORMATION)+MAXIMUM_FILENAME_LENGTH

#endif



DEFINE_CONSTRUCTOR( REGISTRY, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( REGISTRY );


//
//  Initialization of static variable
//

PWSTRING    REGISTRY::_Separator = NULL;




REGISTRY::~REGISTRY(
)
/*++

Routine Description:

    Destroy a REGISTRY object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
REGISTRY::Construct (
    )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   Index;

#if !defined( _AUTOCHECK_ )

    for( Index = 0; Index < NUMBER_OF_PREDEFINED_KEYS; Index++ ) {
        _PredefinedKey[ Index ] = 0;
    }

#endif

}



VOID
REGISTRY::Destroy(
    )
/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if !defined( _AUTOCHECK_ )

    ULONG   Index;

    if( _RemoteRegistry ) {
        if( _PredefinedKey[ PREDEFINED_KEY_USERS ] != 0 ) {
            RegCloseKey( _PredefinedKey[ PREDEFINED_KEY_USERS ] );
        }
        if( _PredefinedKey[ PREDEFINED_KEY_LOCAL_MACHINE ] != 0 ) {
            RegCloseKey( _PredefinedKey[ PREDEFINED_KEY_LOCAL_MACHINE ] );
        }
    }
    _RemoteRegistry = FALSE;
    for( Index = 0; Index < NUMBER_OF_PREDEFINED_KEYS; Index++ ) {
        _PredefinedKey[ Index ] = 0;
    }

#endif

}


BOOLEAN
REGISTRY::Initialize(
    IN PCWSTRING MachineName,
    IN PULONG           ErrorCode
    )

/*++

Routine Description:

    Initialize a REGISTRY object.

Arguments:

    MachineName - The name of the machine whose registry we want to access.
                  NULL means the local machine.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.

Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    PWSTR       MachineNameString = NULL;
    ULONG       Status;
    DSTRING     TmpName;


    Destroy();

    _RemoteRegistry = FALSE;

    if( _Separator == NULL ) {
        _Separator = ( PWSTRING )NEW( DSTRING );
        if( _Separator == NULL ) {
            DebugPtrAssert( _Separator );

#if !defined( _AUTOCHECK_ )
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
#endif
            return( FALSE );
        }
        if( !_Separator->Initialize( "\\" ) ) {
            DebugPrint( "_Separator.Initialize() failed \n" );

#if !defined( _AUTOCHECK_ )
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
#endif

            return( FALSE );
        }
    }


#if !defined( _AUTOCHECK_ )

    if( !InitializeMachineName( MachineName ) ) {
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
        return( FALSE );
    }

    if( !IsRemoteRegistry() ) {
        _PredefinedKey[ PREDEFINED_KEY_CLASSES_ROOT ] = HKEY_CLASSES_ROOT;
        _PredefinedKey[ PREDEFINED_KEY_CURRENT_USER ] = HKEY_CURRENT_USER;
        _PredefinedKey[ PREDEFINED_KEY_LOCAL_MACHINE ] = HKEY_LOCAL_MACHINE;
        _PredefinedKey[ PREDEFINED_KEY_USERS ] = HKEY_USERS;
        _PredefinedKey[ PREDEFINED_KEY_CURRENT_CONFIG ] = HKEY_CURRENT_CONFIG;
    } else {
        if( !TmpName.Initialize( ( LPWSTR )L"\\\\" ) ||
            !TmpName.Strcat( MachineName ) ){
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
            return( FALSE );
        }

        MachineNameString = TmpName.QueryWSTR();
        if( MachineNameString == NULL ) {
            DebugPrint( "TmpName.QueryWSTR() failed" );
            return( FALSE );
        }
        _PredefinedKey[ PREDEFINED_KEY_CLASSES_ROOT ] = 0;
        _PredefinedKey[ PREDEFINED_KEY_CURRENT_USER ] = 0;
        _PredefinedKey[ PREDEFINED_KEY_CURRENT_CONFIG ] = 0;
        Status = RegConnectRegistry( MachineNameString,
                                     HKEY_LOCAL_MACHINE,
                                     &_PredefinedKey[ PREDEFINED_KEY_LOCAL_MACHINE ] );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegConnectRegistry() failed: HKEY_LOCAL_MACHINE, Status = %#x \n",
                       Status ));
            DebugPrint( "RegConnectRegistry() failed: HKEY_LOCAL_MACHINE" );
            FREE( MachineNameString );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            return( FALSE );
        }
        Status = RegConnectRegistry( MachineNameString,
                                 HKEY_USERS,
                                 &_PredefinedKey[ PREDEFINED_KEY_USERS ] );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegConnectRegistry() failed: HKEY_USERS, Status = %#x \n", Status ));
            DebugPrint( "RegConnectRegistry() failed: HKEY_USERS" );
            FREE( MachineNameString );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            return( FALSE );
        }
        FREE( MachineNameString );
    }

#endif
    return( TRUE );
}





BOOLEAN
REGISTRY::InitializeMachineName(
    IN PCWSTRING MachineName
    )

/*++

Routine Description:

    Initialize the data member that contains the machine name, and
    the flag that indicate whether the registry is local or remote

Arguments:

    MachineName - Pointer to a WSTRING object that contains the machine
                  name.
                  It can be NULL, or it can be a NUL string, and in this case
                  this REGISTRY object will represent the local machine.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( MachineName );

    return( FALSE );

#else


    WSTR    LocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1];


    ULONG   NameLength;
    DSTRING Name;

#if 0
  PSTR DebugNameString;
#endif

    //
    //  Determine the name of the local machine
    //

    NameLength = sizeof( LocalMachineName );
    if( !GetComputerName( LocalMachineName,
                          &NameLength ) ) {

        DebugPrintTrace(( "GetComputerName() failed, Error = %#x \n", GetLastError() ));
        DebugPrint( "GetComputerName() failed" );
        return( FALSE );
    }
    if( !Name.Initialize( LocalMachineName, NameLength ) ) {
        DebugPrint( "Name.Initialize() failed" );
        return( FALSE );
    }

#if 0
  DebugNameString = Name.QuerySTR();
  DebugPtrAssert( DebugNameString );
  DebugPrintTrace(( "MachineName = %s \n", DebugNameString ));
#endif

    //
    //  Find out if the name received as parameter represents the local
    //  machine.
    //

    if( ( MachineName == NULL ) ||
        ( MachineName->QueryChCount() == 0 )
      ) {
        //
        //  Local machine
        //
        if( !_MachineName.Initialize( &Name ) ) {
            DebugPrint( "_MachineName.Initialize( &Name ) failed" );
            return( FALSE );
        }
        _RemoteRegistry = FALSE;
    } else {
        //
        //  Remote machine
        //
        if( !_MachineName.Initialize( MachineName ) ) {
            DebugPrint( "_MachineName.Initialize( MachineName ) failed" );
            return( FALSE );
        }
        _RemoteRegistry = TRUE;
    }
    return( TRUE );

#endif
}




BOOLEAN
REGISTRY::AddValueEntry(
    IN     PREDEFINED_KEY           PredefinedKey,
    IN     PCWSTRING         ParentName,
    IN     PCWSTRING         KeyName,
    IN     PCREGISTRY_VALUE_ENTRY   Value,
    IN     BOOLEAN                  FailIfExists,
    OUT    PULONG                  ErrorCode
    )

/*++

Routine Description:

    Add a value entry to an existing key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - The parent name of the key (can be NULL ).

    KeyName - The name of the key where the Value will be added (cannot be NULL).

    Value - Pointer to the object that contains the information about the
            value to be created.


    FailIfExists - If TRUE, overwrite the existing value.


    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the value entry was added, or FALSE otherwise.


--*/

{

#if defined( _AUTOCHECK_ )

    PWSTRING            CompleteKeyName;
    PWSTR               CompleteKeyNameString;
    PWSTR               ValueNameString;
    UNICODE_STRING      UnicodeKeyName;
    UNICODE_STRING      UnicodeValueName;
    OBJECT_ATTRIBUTES   ObjAttr;
    HANDLE              Handle;
    NTSTATUS            Status;
    PBYTE               Data;
    ULONG               Size;


    if ( !OpenKey( ParentName, KeyName, KEY_SET_VALUE, &Handle, ErrorCode ) ) {
        return FALSE;
    }

    if ( !Value                                                         ||
         !(ValueNameString = Value->GetName()->QueryWSTR() )

       ) {

        FREE( ValueNameString );
        NtClose( Handle );
        return FALSE;
    }


    if( FailIfExists &&
        DoesValueExist( PredefinedKey, ParentName, KeyName, Value->GetName() ) ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = 0;
        }

        FREE( ValueNameString );
        NtClose( Handle );
        return( FALSE );
    }

    RtlInitUnicodeString( &UnicodeValueName, ValueNameString );

    Size = Value->GetData( &Data );

    Status = NtSetValueKey( Handle,
                            &UnicodeValueName,
                            Value->GetTitleIndex(),
                            Value->GetType(),
                            Data,
                            Size );

    FREE( ValueNameString );
    NtClose( Handle );

    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode != NULL ) {
            *ErrorCode = Status;
        }
        return FALSE;
    }

    return TRUE;

#else


    HKEY       Handle;
    PCWSTRING  ValueName;
    PWSTR      ValueNameString;
    DWORD      Status;
    PBYTE      Data;
    ULONG      Size;


    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );
    DebugPtrAssert( Value );



    //
    //  Open the key with KEY_SET_VALUE access so that the key is locked
    //

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_SET_VALUE,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  Verify whether the value exists
    //
    if( FailIfExists &&
        DoesValueExist( PredefinedKey, ParentName, KeyName, Value->GetName(), ErrorCode ) ) {
        //
        //  If the key is not a predefined key, then we must close the handle
        //
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        return( FALSE );
    }

    //
    //  Set the value:
    //      .Determine the value name
    //      .Get the value data from Value object
    //      .Create the value entry in the key
    //
    ValueName = Value->GetName();
    DebugPtrAssert( ValueName );
    ValueNameString = ValueName->QueryWSTR();
    if( ValueNameString == NULL ) {
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( ValueNameString );
        return( FALSE );
    }
    Size = Value->GetData( (PCBYTE *)&Data );

    Status = RegSetValueEx( Handle,
                            ValueNameString,
                            0,                  // Value->GetTitleIndex(),
                            Value->GetType(),
                            Data,
                            Size );

    FREE( ValueNameString );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegSetValueEx() failed, Status = %#x \n", Status ));
        DebugPrint( "RegSetValueEx() failed" );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    Status = RegFlushKey( Handle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::AddValueEntry(
    IN     PREDEFINED_KEY           PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO       KeyInfo,
    IN     PCREGISTRY_VALUE_ENTRY   Value,
    IN     BOOLEAN                  FailIfExists,
    OUT    PULONG                   ErrorCode
    )

/*++

Routine Description:

    Add a value entry to an existing key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              the key where the value will be created. This object will be
              updated to reflect the addition of a new value.

    Value - Pointer to the object that contains the information about the
            value to be created.

    FailIfExists - A flag that indicates if the method should fail if a
                   value entry with the same name already exists.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( KeyInfo );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( FailIfExists );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;


#else

    PCWSTRING   ParentName;
    PCWSTRING   KeyName;


    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( Value );

    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    //
    // Create the new value entry
    //
    if( !AddValueEntry( PredefinedKey,
                        ParentName,
                        KeyName,
                        Value,
                        FailIfExists,
                        ErrorCode ) ) {
        DebugPrint( "CreateValueEntry() failed \n" );
        return( FALSE );
    }

    //
    //  Now that the value entry is created we need to update KeyInfo
    //

    if( !UpdateKeyInfo( PredefinedKey, KeyInfo, ErrorCode ) ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }
    return( TRUE );

#endif
}



#if 0  //  NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyKey(
     IN  PREDEFINED_KEY     FromPredefinedKey,
     IN  PCWSTRING   FromParentName,
     IN  PCWSTRING   FromKeyName,
     IN  PREDEFINED_KEY     ToPredefinedKey,
     IN  PCWSTRING   ToParentName,
     OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy a key and all its sub keys, to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the key to be copied.

    FromKeyName - The name of the key to be copied (name relative to its parent).

    ToPredefinedKey - The root of the tree were the new key will be.

    ToParentName - The parent name of the new key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

}

#endif  // NOT_IMPLEMENTED


#if 0  // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyKey(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN      PCWSTRING    FromParentName,
    IN      PCWSTRING    FromKeyName,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToParentName,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy a key and all its sub keys, to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the key to be copied.

    FromKeyName - The name of the key to be copied (name relative to its parent).

    ToPredefinedKey - The root of the tree were the new key will be.

    ToParentKeyInfo - Pointer to the object that contains the information about
                      the parent key of the new key. The information in this
                      object will be updated to reflect the addition of a new
                      subkey.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey);
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}
#endif // NOT_IMPLEMENTED



#if 0 // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyAllValueEntries(
    IN  PREDEFINED_KEY      FromPredefinedKey,
    IN  PCWSTRING    FromParentName,
    IN  PCWSTRING    FromKeyName,
    IN  PREDEFINED_KEY      ToPredefinedKey,
    IN  PCWSTRING    ToParentName,
    IN  PCWSTRING    ToKeyName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy all value entries from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the source key.

    FromKeyName - The name of the source key.

    ToPredefinedKey - The root of the tree where the destination key is.

    ToParentName - The parent name of the destination key.

    ToKeyName - The name of the destination key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName    );
    UNREFERENCED_PARAMETER( ToPredefinedKey);
    UNREFERENCED_PARAMETER( ToParentName   );
    UNREFERENCED_PARAMETER( ToKeyName      );
    UNREFERENCED_PARAMETER( ErrorCode      );

    return FALSE;
}
#endif  // NOT_IMPLEMENTED


#if 0  // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyAllValueEntries(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN      PCWSTRING    FromParentName,
    IN      PCWSTRING    FromKeyName,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToKeyInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy all value entries from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the source key.

    FromKeyName - The name of the source key.

    ToPredefinedKey - The root of the tree where the destination key is.

    ToKeyInfo - Pointer to the object that contains the information about
                the destination key. This object will be updated to reflect
                the addition of the new values.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToKeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif // NOT_IMPLEMENTED



#if 0 // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyOneValueEntry(
    IN  PREDEFINED_KEY      FromPredefinedKey,
    IN  PCWSTRING    FromParentName,
    IN  PCWSTRING    FromKeyName,
    IN  PCWSTRING    FromValueName,
    IN  PREDEFINED_KEY      ToPredefinedKey,
    IN  PCWSTRING    ToParentName,
    IN  PCWSTRING    ToKeyName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy one value entry from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentKeyName - The parent name of the source key.

    FromKeyName - The name of the source key.

    FromValueName - The name of the value to be copied (cannot be NULL).

    ToPredefinedKey - The root of the tree where the destination key is.

    ToParentName - The parent name of the destination key.

    ToKeyName - The name of the destination key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( FromValueName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ToKeyName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif // NOT_IMPLEMENTED


#if 0 // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyOneValueEntry(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN      PCWSTRING    FromParentName,
    IN      PCWSTRING    FromKeyName,
    IN      PCWSTRING    FromValueName,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToKeyInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy one value entry from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentKeyName - The parent name of the source key.

    FromKeyName - The name of the source key.

    FromValueName - The name of the value to be copied (can be NULL).

    ToPredefinedKey - The root of the tree where the destination key is.

    ToKeyInfo - Pointer to the object that contains the information about
                the destination key. This object will be updated to reflect
                the addition of the new values.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( FromValueName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToKeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif  // NOT_IMPLEMENTED


BOOLEAN
REGISTRY::CreateKey(
    IN OUT PREGISTRY_KEY_INFO   NewSubKeyInfo,
    IN     PREDEFINED_KEY       PredefinedKey,
    OUT    PULONG               ErrorCode,
    IN     BOOLEAN              Volatile
    )

/*++

Routine Description:

    Add a subkey to an existing key, and update NewSubkeyInfo to reflect the
    creation of the new key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    NewSubKeyInfo - Pointer to the object that contains the information about
                    the subkey to be created. This object will be updated to
                    reflect the new information about the subkey created.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.

    Volatile    - Volatile flag.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{


#if defined( _AUTOCHECK_ )


    PWSTRING                CompleteKeyName;
    PWSTR                   CompleteKeyNameString;
    PWSTR                   ClassString;
    UNICODE_STRING          UnicodeKeyName;
    UNICODE_STRING          UnicodeClass;
    OBJECT_ATTRIBUTES       ObjAttr;
    HANDLE                  Handle;
    ULONG                   Length;
    NTSTATUS                Status;
    BYTE                    KeyInfo[ KEY_BASIC_SIZE ];



    if ( !NewSubKeyInfo ) {
        return FALSE;
    }
    if ( !NewSubKeyInfo                                                         ||
         !(CompleteKeyName = BuildCompleteName( NewSubKeyInfo->GetParentName(), NewSubKeyInfo->GetName() ) ) ||
         !(CompleteKeyNameString = CompleteKeyName->QueryWSTR() )                ||
         !(ClassString = NewSubKeyInfo->GetClass()->QueryWSTR() )
       ) {

        DELETE( CompleteKeyName );
        FREE( CompleteKeyNameString );
        FREE( ClassString );

        return FALSE;
    }



    //
    // Initialize the OBJECT_ATTRIBUTES structure
    //
    RtlInitUnicodeString( &UnicodeKeyName, CompleteKeyNameString );
    RtlInitUnicodeString( &UnicodeClass,  ClassString );

    InitializeObjectAttributes( &ObjAttr,
                                &UnicodeKeyName,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );


    Status = NtCreateKey( &Handle,
                          KEY_READ,
                          &ObjAttr,
                          NewSubKeyInfo->GetTitleIndex(),
                          &UnicodeClass,
                          Volatile ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE,
                          NULL );


    DELETE( CompleteKeyName );
    FREE( CompleteKeyNameString );
    FREE( ClassString );


    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode ) {
            *ErrorCode = Status;
        }

        return FALSE;
    }


    Status = NtQueryKey( Handle,
                         KeyBasicInformation,
                         &KeyInfo,
                         KEY_BASIC_SIZE,
                         &Length );

    NtClose( Handle );

    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode ) {
            *ErrorCode = Status;
        }

        return FALSE;
    }


    NewSubKeyInfo->SetNumberOfSubKeys( 0 );
    NewSubKeyInfo->SetNumberOfValues( 0 );
    NewSubKeyInfo->SetLastWriteTime( ((PKEY_BASIC_INFORMATION)KeyInfo)->LastWriteTime );

    return TRUE;



#else

    DWORD       Status;
    HKEY        ParentHandle;
    HKEY        SubKeyHandle;
    PCWSTRING   ParentName;
    PCWSTRING   SubKeyName;
    PWSTR       SubKeyNameString;
    PCWSTRING   Class;
    PWSTR       ClassString;
    TIMEINFO    LastWriteTime;

    PWSTR       lpClass;
    DWORD       cbClass;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;
    DSTRING     NullString;




    DebugPtrAssert( NewSubKeyInfo );

    //
    //  Open a handle to the parent key
    //
    if( !NullString.Initialize( "" ) ) {
        DebugPrint( "NullString.Initialize() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }
    ParentName = NewSubKeyInfo->GetParentName();
    DebugPtrAssert( ParentName );

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  &NullString,
                  KEY_CREATE_SUB_KEY,
                  &ParentHandle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  To Create the subkey, we need to:
    //
    //      .Get its name
    //      .Get its class
    //      .Call the API to create the subkey
    //

    SubKeyName = ( PWSTRING )NewSubKeyInfo->GetName();
    DebugPtrAssert( SubKeyName );
    SubKeyNameString = SubKeyName->QueryWSTR();

    if( SubKeyNameString == NULL ) {
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( SubKeyNameString );
        return( FALSE );
    }

    Class = NewSubKeyInfo->GetClass();
    DebugPtrAssert( Class );
    ClassString = Class->QueryWSTR();
    if( ClassString == NULL ) {
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        FREE( SubKeyNameString );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( SubKeyNameString );
        return( FALSE );
    }

    Status = RegCreateKeyEx( ParentHandle,
                             SubKeyNameString,
                             0,                 // NewSubKeyInfo->GetTitleIndex(),
                             ClassString,
                             Volatile ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE,
                             KEY_READ,
                             ( PSECURITY_ATTRIBUTES )NewSubKeyInfo->GetSecurityAttributes(),
                             &SubKeyHandle,
                             NULL );
    FREE( ClassString );
    FREE( SubKeyNameString );
    if( Status != 0 ) {
        DebugPrint( "RegCreateKey() failed" );
        DebugPrintTrace(( "RegCreateKeyEx() returned Status = %#x", Status ));
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    Status = RegFlushKey( ParentHandle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }


    //
    //  Update NewSubKeyInfo:
    //
    //      .Call RegQueryInfoKey to retrieve the LastWriteTime
    //
    //

    cbClass = ( Class->QueryChCount() + 1 );
    lpClass = ( PWSTR ) MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
    if( lpClass == NULL ) {
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        RegCloseKey( SubKeyHandle );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( lpClass );
        return( FALSE );
    }

    Status = RegQueryInfoKey( SubKeyHandle,
                              ( LPWSTR )lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );

    RegCloseKey( SubKeyHandle );
    FREE( lpClass );
    if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( ParentHandle );
    }
    if( Status != 0 ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }

    if( !LastWriteTime.Initialize( &ftLastWriteTime ) ) {
        DebugPrint( "LastWriteTime.Initialize( &ftLastWriteTime ) failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
    }

    NewSubKeyInfo->SetNumberOfSubKeys( 0 );
    NewSubKeyInfo->SetNumberOfValues( 0 );
    NewSubKeyInfo->PutLastWriteTime( &LastWriteTime );
    NewSubKeyInfo->SetKeyInitializedFlag( TRUE );
    return( TRUE );

#endif

}



BOOLEAN
REGISTRY::CreateKey(
    IN     PREDEFINED_KEY       PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO   KeyInfo,
    IN OUT PREGISTRY_KEY_INFO   NewSubKeyInfo,
    OUT    PULONG               ErrorCode,
    IN     BOOLEAN              Volatile
    )

/*++

Routine Description:

    Add a subkey to an existing key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              the key where the subkey will be created. This object will be
              updated to reflect the addition of a new subkey.

    NewSubKeyInfo - Pointer to the object that contains the information about
                    the subkey to be created. This object will be updated to
                    reflect the new information about the subkey created.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


    Volatile  - Volatile flag

Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( KeyInfo );
    UNREFERENCED_PARAMETER( NewSubKeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else


    PCTIMEINFO   NewLastWriteTime;

    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( NewSubKeyInfo );


    if( !CreateKey( NewSubKeyInfo,
                    PredefinedKey,
                    ErrorCode,
                    Volatile ) ) {

            DebugPrint( "CreateSubKey() failed" );
            return( FALSE );
    }

    NewLastWriteTime = NewSubKeyInfo->GetLastWriteTime();
    DebugPtrAssert( NewLastWriteTime );

    ( KeyInfo->_LastWriteTime ).Initialize( NewLastWriteTime );
    KeyInfo->SetNumberOfSubKeys( KeyInfo->GetNumberOfSubKeys() + 1 );
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::DeleteKey(
    IN     PREDEFINED_KEY       PredefinedKey,
    IN     PCWSTRING     ParentKeyName,
    IN     PCWSTRING     KeyName,
    OUT    PULONG              ErrorCode
    )

/*++

Routine Description:

    Delete a key and all its subkeys.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentKeyName - The parent name of the key. It can be NULL, and in this
                    case the key to be deleted is a subkey of a predefined
                    key.

    KeyName - The name of the key to be deleted (cannot be NULL). This name
              is relative to its parent.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( ParentKeyName );
    UNREFERENCED_PARAMETER( KeyName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PWSTR   KeyNameWSTR;
    HKEY    ParentHandle;
    HKEY    KeyHandle;
    DWORD   Status;
    DSTRING NullString;


    DebugPtrAssert( ParentKeyName );
    DebugPtrAssert( KeyName );


    //
    //  Open a handle to the parent key
    //

    if( !NullString.Initialize( "" ) ) {
        DebugPrint( "NullString.Initialize() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }
    if( !OpenKey( PredefinedKey,
                  ParentKeyName,
                  &NullString,
                  KEY_READ,
                  &ParentHandle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  We also need a handle to the key to be deleted
    //


    if( !OpenKey( PredefinedKey,
                  ParentKeyName,
                  KeyName,
                  READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, // MAXIMUM_ALLOWED,
                  &KeyHandle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        return( FALSE );
    }


    //
    //  Delete the children
    //
    Status = DeleteTree( KeyHandle );
    if( Status != 0 ) {
        DebugPrintTrace(( "DeleteTree() failed, Status = %#x \n", Status ));
        DebugPrintTrace(( "DeleteTree() failed" ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );

        }
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        RegFlushKey( KeyHandle );
        RegCloseKey( KeyHandle );
        return( FALSE );
    }
    RegCloseKey( KeyHandle );

    //
    //  Delete the key
    //
    KeyNameWSTR = KeyName->QueryWSTR();
    if( KeyNameWSTR == NULL ) {
        DebugPrint( "KeyName->QueryWSTR() failed" );
        DebugPtrAssert( KeyNameWSTR );
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegDeleteKey( ParentHandle, KeyNameWSTR );
    FREE( KeyNameWSTR );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegDeleteKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegDeleteKey() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        return( FALSE );
    }
    Status = RegFlushKey( ParentHandle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }
    if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( ParentHandle );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::DeleteKey(
    IN     PREDEFINED_KEY       PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO   ParentKeyInfo,
    IN     PCWSTRING     KeyName,
    OUT    PULONG              ErrorCode
    )

/*++

Routine Description:

    Delete a key and all its subkeys, and update ParentKeyInfo.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              the key that contains the subkey to be deleted. This object
              will be updated to reflect the deletion of a subkey.

    KeyName - Name of the key to be deleted (cannot be NULL )

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( ParentKeyInfo );
    UNREFERENCED_PARAMETER( KeyName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PWSTRING    ParentName;
    PCWSTRING   TmpName;
    PCWSTRING   TmpName1;

    DebugPtrAssert( ParentKeyInfo );
    DebugPtrAssert( KeyName );

    TmpName = ParentKeyInfo->GetParentName();
    DebugPtrAssert( TmpName );
    TmpName1 = ParentKeyInfo->GetName();
    DebugPtrAssert( TmpName1 );

    ParentName = BuildCompleteName( TmpName, TmpName1 );
    if( ParentName == NULL ) {
        DebugPrint( "BuildCompleteName() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }

    if( !DeleteKey( PredefinedKey, ParentName, KeyName, ErrorCode ) ) {
        DebugPrint( "DeleteKey() failed" );
        DELETE( ParentName );
        return( FALSE );
    }
    DELETE( ParentName );

    //
    //  Update KeyInfo
    //

    if( !UpdateKeyInfo( PredefinedKey, ParentKeyInfo, ErrorCode ) ) {
        DebugPrint( "UpdateKeyInfo() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::DeleteValueEntry(
    IN  PREDEFINED_KEY      PredefinedKey,
    IN  PCWSTRING    ParentKeyName,
    IN  PCWSTRING    KeyName,
    IN  PCWSTRING    ValueName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Delete a value entry from a key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentKeyName - The parent name of the key (can be NULL ).

    KeyName - The name of that contains the Value (cannot be NULL).

    ValueName - The name of the value to be deleted.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )

    PWSTR               ValueNameString = NULL;
    UNICODE_STRING      UnicodeValueName;
    HANDLE              Handle;
    NTSTATUS            Status;
    BOOLEAN             Done = FALSE;


    if ( !OpenKey( ParentKeyName, KeyName, KEY_SET_VALUE, &Handle, ErrorCode ) ) {
        return FALSE;
    }


    if ( ValueName &&
         (ValueNameString = ValueName->QueryWSTR() )
       ) {

        RtlInitUnicodeString( &UnicodeValueName, ValueNameString );

        //
        //  Delete the value
        //
        Status = NtDeleteValueKey( Handle, &UnicodeValueName );


        if ( NT_SUCCESS( Status ) ) {

            Done = TRUE;

        } else {

            if ( ErrorCode != NULL ) {
                *ErrorCode = Status;
            }
        }
    }

    NtClose( Handle );
    FREE( ValueNameString );

    return Done;


#else


    PWSTR       ValueNameString;
    DWORD       Status;
    HKEY        Handle;


    DebugPtrAssert( ValueName );

    if( !OpenKey( PredefinedKey,
                  ParentKeyName,
                  KeyName,
                  KEY_SET_VALUE,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  Get the value name
    //

    ValueNameString = ValueName->QueryWSTR();
    if( ValueNameString == NULL ) {
        DebugPrint( "ValueName->QueryWSTR() failed" );
        DebugPtrAssert( ValueNameString );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    //
    // Delete the value
    //

    Status = RegDeleteValue( Handle, ValueNameString );
    if( Status != 0 ) {
        DebugPrint( "RegDeleteValue() failed" );
        DebugPrintTrace(( "RegDeleteValue() failed, Status = %#x \n", Status ));
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        FREE( ValueNameString );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    Status = RegFlushKey( Handle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n" ));
        DebugPrint( "RegFlushKey() failed" );
    }
    FREE( ValueNameString );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::DeleteValueEntry(
    IN     PREDEFINED_KEY      PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO  KeyInfo,
    IN     PCWSTRING    Value,
    OUT    PULONG             ErrorCode
    )

/*++

Routine Description:

    Delete a value entry from a key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              the key that has the value to be deleted.. This object will be
              updated to reflect the deletion of a new value.

    Value - Name of the value to be deleted.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( KeyInfo );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( ErrorCode);

    return FALSE;

#else

    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( Value );


    PCWSTRING   TmpString;
    PCWSTRING   TmpString1;

    TmpString = KeyInfo->GetParentName();
    DebugPtrAssert( TmpString );
    TmpString1 = KeyInfo->GetName();
    DebugPtrAssert( TmpString1 );

    if( !DeleteValueEntry( PredefinedKey, TmpString, TmpString1, Value, ErrorCode ) ) {
        DebugPrint( "DeleteKey() failed" );
        return( FALSE );
    }
    if( !UpdateKeyInfo( PredefinedKey, KeyInfo, ErrorCode ) ) {
        if( ( ErrorCode != NULL ) && ( *ErrorCode != REGISTRY_ERROR_OUTOFMEMORY ) ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }
    return( TRUE );

#endif
}


BOOLEAN
REGISTRY::DoesKeyExist(
    IN  PREDEFINED_KEY      PredefinedKey,
    IN  PCWSTRING    ParentName,
    IN  PCWSTRING    KeyName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Determine whether a value entry exists.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - The parent name of the key we want to check the existence.

    KeyName - The name of the key we want to check the existence.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined ( _AUTOCHECK_ )

    HANDLE  Handle;


    if ( !OpenKey( ParentName, KeyName, KEY_QUERY_VALUE, &Handle, ErrorCode ) ) {
        return FALSE;
    }

    NtClose( Handle );

    return TRUE;


#else


    HKEY     Handle;
    ULONG    Status;

    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );

    //
    //  Try to open the key, if it doesn't fail, or if it fails due to
    //  lack of permission, then the key exists
    //
    if( OpenKey( PredefinedKey,
                 ParentName,
                 KeyName,
                 KEY_READ, // MAXIMUM_ALLOWED,
                 &Handle,
                 &Status ) ) {
        RegCloseKey( Handle );
        return( TRUE );
    } else if( Status != REGISTRY_ERROR_ACCESS_DENIED ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = Status;
        }
        return( FALSE );
    } else {
        return( TRUE );
    }
#endif

}




BOOLEAN
REGISTRY::DoesValueExist(
    IN  PREDEFINED_KEY      PredefinedKey,
    IN  PCWSTRING    ParentName,
    IN  PCWSTRING    KeyName,
    IN  PCWSTRING    ValueName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Determine whether a value entry exists.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - The the parent name of the key that might contain the value.

    KeyName - The name of the key that might contain the value.

    ValueName - Name of the value we want to check the existence.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )


    PWSTR               ValueNameString = NULL;
    UNICODE_STRING      UnicodeValueName;
    HANDLE              Handle;
    NTSTATUS            Status;
    ULONG               Length;
    BOOLEAN             Done = FALSE;
    BYTE                ValueInfo[ VALUE_BASIC_SIZE ];



    if ( !OpenKey( ParentName, KeyName, KEY_QUERY_VALUE, &Handle, ErrorCode ) ) {
        return FALSE;
    }

    if ( ValueName  &&
         (ValueNameString = ValueName->QueryWSTR() )
       ) {

        RtlInitUnicodeString( &UnicodeValueName, ValueNameString );

        //
        //  At this point we have the handle to the key.
        //  Let's check the existence of the value
        //
        Status = NtQueryValueKey( Handle,
                                  &UnicodeValueName,
                                  KeyValueBasicInformation,
                                  &ValueInfo,
                                  VALUE_BASIC_SIZE,
                                  &Length );

        if ( NT_SUCCESS( Status ) ) {

            Done = TRUE;

        } else {

            if ( ErrorCode != NULL ) {
                *ErrorCode = Status;
            }
        }
    }

    NtClose( Handle );
    FREE( ValueNameString );

    return Done;


#else

    HKEY     Handle;
    PWSTR    ValueNameString;
    DWORD    Status;

    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );
    DebugPtrAssert( ValueName );


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_QUERY_VALUE,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey failed" );
        return( FALSE );
    }

    //
    //  Check the existence of the value on the key
    //
    ValueNameString = ValueName->QueryWSTR();
    if( ValueNameString == NULL ) {
        DebugPrint( "ValueName->QueryWSTR() failed" );
        DebugPtrAssert( ValueNameString );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegQueryValueEx( Handle,
                              ValueNameString,
                              NULL,
                              NULL,
                              NULL,
                              NULL );
    FREE( ValueNameString );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    //
    //  If we can successfully query the key, then it exists.
    //  Otherwise, we have to examine the status code returned by the
    //  API to determine if the value doesn't exist, or if another error
    //  has occurred
    //
    if( Status != 0 ) {
        if( ErrorCode != NULL ) {
            if( Status == ERROR_PATH_NOT_FOUND ) {
                *ErrorCode = REGISTRY_ERROR_VALUE_DOESNT_EXIST;
            } else {
//                DebugPrintTrace(( "RegQueryValueEx() failed, Status = %#x \n", Status ));
//                DebugPrint( "RegQueryValueEx() failed" );
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
        }
        return( FALSE );
    }
    return( TRUE );

#endif
}



#if 0  // NOT_IMPLEMENTED
BOOLEAN
REGISTRY::MoveKey(
     IN  PREDEFINED_KEY     FromPredefinedKey,
     IN  PCWSTRING   FromParentName,
     IN  PCWSTRING   FromKeyName,
     IN  PREDEFINED_KEY     ToPredefinedKey,
     IN  PCWSTRING   ToParentName,
     OUT PULONG            ErrorCode
    )

/*++

Routine Description:

    Move a key and all its sub keys, to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the key to be moved.

    FromKeyName - The name of the key to be moved (name relative to its parent).

    ToPredefinedKey - The root of the tree were the new key will be.

    ToParentName - The parent name of the new key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif  // NOT_IMPLEMENTED


#if 0   // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::MoveKey(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  FromParentKeyInfo,
    IN      PCWSTRING    FromKeyName,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToParentName,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Move a key and all its sub keys, to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentKeyInfo - Pointer to the object that contains information about
                        the key that holds the subkey to be moved.
                        The information in this object will be updated to reflect
                        the removal of a subkey.

    FromKeyName - The name of the key to be copied (name relative to its parent).

    ToPredefinedKey - The root of the tree were the new key will be.

    ToParentKeyInfo - Pointer to the object that contains the information about
                      the parent key of the new key. The information in this
                      object will be updated to reflect the addition of a new
                      subkey.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentKeyInfo );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif // NOT_IMPLEMENTED


#if 0  // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::MoveAllValueEntries(
    IN  PREDEFINED_KEY      FromPredefinedKey,
    IN  PCWSTRING    FromParentName,
    IN  PCWSTRING    FromKeyName,
    IN  PREDEFINED_KEY      ToPredefinedKey,
    IN  PCWSTRING    ToParentName,
    IN  PCWSTRING    ToKeyName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy one or all value entries from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the source key (can be NULL ).

    FromKeyName - The name of the source key (cannot be NULL).

    ToPredefinedKey - The root of the tree where the destination key is.

    ToParentName - The parent name of the destination key (can be NULL ).

    ToKeyName - The name of the destination key (cannot be NULL )

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ToKeyName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif


#if 0  // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::MoveAllValueEntries(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  FromKeyInfo,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToKeyInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Move one or all value entries from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromKeyInfo - Pointer to the object that contains the information about
                  the source key. The information in this object will be
                  updated to reflect the deletion of values.

    ToPredefinedKey - The root of the tree where the destination key is.

    ToKeyInfo - Pointer to the object that contains the information about
                the destination key. This object will be updated to reflect
                the addition of the new values.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromKeyInfo );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToKeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif // NOT_IMPLEMENTED


BOOLEAN
REGISTRY::QueryKeyInfo(
    IN      PREDEFINED_KEY      PredefinedKey,
    IN      PCWSTRING           ParentName,
    IN      PCWSTRING           KeyName,
    OUT     PREGISTRY_KEY_INFO  KeyInfo,
    OUT     PULONG              ErrorCode
    )

/*++

Routine Description:

    Retrieve the information of a key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - Name of the parent key (can be NULL).

    KeyName - Name of the key to be queried (cannot be NULL).

    KeyInfo - Pointer to a NON-INITIALIZED object that will contain the
              information about the key to be queried.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.



--*/


{
#if defined( _AUTOCHECK_ )


    NTSTATUS            Status;
    HANDLE              Handle;
    DSTRING             Class;
    ULONG               Length;
    BYTE                KeyBuf[ KEY_FULL_SIZE ];


    if ( !KeyInfo   ||
         !OpenKey( ParentName, KeyName, KEY_READ, &Handle, ErrorCode ) ) {
        return FALSE;
    }

    Status = NtQueryKey( Handle,
                         KeyFullInformation,
                         &KeyBuf,
                         KEY_FULL_SIZE,
                         &Length );

    NtClose( Handle );

    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode ) {
            *ErrorCode = Status;
        }
    }


    if ( !Class.Initialize( (PWSTR)((PKEY_FULL_INFORMATION)KeyBuf)->Class ) ||
         !KeyInfo->Initialize( KeyName,
                               ParentName,
                               ((PKEY_FULL_INFORMATION)KeyBuf)->TitleIndex,
                               &Class,
                               NULL )

       ) {

        return FALSE;
    }


    KeyInfo->SetLastWriteTime( ((PKEY_FULL_INFORMATION)KeyBuf)->LastWriteTime );
    KeyInfo->SetNumberOfSubKeys( ((PKEY_FULL_INFORMATION)KeyBuf)->SubKeys );
    KeyInfo->SetNumberOfValues( ((PKEY_FULL_INFORMATION)KeyBuf)->Values );

    return TRUE;

#else

    DSTRING     TmpClass;
    TIMEINFO    TmpLastWriteTime;


    DWORD       Status;
    HKEY        Handle;


    //
    // Variables used in QueryKeyInfo()
    //
    LPWSTR      lpClass;
    WSTR        DummyVariable;
    DWORD       cbClass;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;



    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_READ,
                  &Handle,
                  ErrorCode ) ) {
//        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }


    //
    //  Query the key to find out the size of the buffer needed to hold
    //  the class
    //
    cbClass = 0;
    lpClass = &DummyVariable;
    Status = RegQueryInfoKey( Handle,
                              ( LPWSTR )lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );

    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        DebugPrintTrace(( "RegQueryInfoKey() failed. Error code = %#x \n", Status ));
        DebugPrint( "RegQueryInfoKey() failed." );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        return( FALSE );
    }

    //
    //  If the value in cbClass is not zero, then allocate a buffer big
    //  enough to hold the class, and query the key again to obtain its
    //  class.
    //
    if( cbClass != 0 ) {
        cbClass++;
        lpClass = ( PWSTR )MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
        if (lpClass == NULL) {
            DebugPrint( "Unable to allocate memory" );
            DebugPtrAssert( lpClass );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            return( FALSE );
        }
        Status = RegQueryInfoKey( Handle,
                                  ( LPWSTR )lpClass,
                                  &cbClass,
                                  NULL,
                                  &cSubKeys,
                                  &cbMaxSubKeyLen,
                                  &cbMaxClassLen,
                                  &cValues,
                                  &cbMaxValueNameLen,
                                  &cbMaxValueLen,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        if( Status != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed. Error code = %#x \n", Status ));
            DebugPrint( "RegQueryInfoKey() failed." );
            FREE( lpClass );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            return( FALSE );
        }
    }

    //
    //  At this point there is no need to keep the handle opened.
    //  So, we close the handle.
    //
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }

    //
    //  Initialize a WSTRING object that contains the class
    //
    if( cbClass != 0 ) {
        //
        //  Initialize TmpClass using the class size. It is not safe to assume
        //  that the class is NULL terminated
        //
        if( !TmpClass.Initialize( ( LPWSTR )lpClass, cbClass ) ) {
            DebugPrint( "TmpClass.Initialize( lpClass ) failed" );
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
        }
        FREE( lpClass );
    } else {
        if( !TmpClass.Initialize( "" ) ) {
            DebugPrint( "TmpClass.Initialize() failed" );
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
        }
    }

    //
    //  Initialize TIMEINFO that contains the last write time
    //
    if( !TmpLastWriteTime.Initialize( &ftLastWriteTime ) ) {
        DebugPrint( "TmpLastWriteTime.Initialize( &ftLastWriteTime ) failed" );
        if( ErrorCode != NULL )  {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }

    //
    //  Update KeyInfo
    //

    //
    // Security attributes is currently set to NULL since the API
    // to retrive it is not yet implemented
    //
    SECURITY_ATTRIBUTES     BugSecAttrib;
    PSECURITY_DESCRIPTOR    BugSecDesc;

    BugSecDesc =( PSECURITY_DESCRIPTOR )MALLOC( (size_t) SECURITY_DESCRIPTOR_MIN_LENGTH );
    if (BugSecDesc == NULL) {
        DebugPrint( "Unable to allocate memory" );
        DebugPtrAssert( BugSecDesc );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }
    InitializeSecurityDescriptor( BugSecDesc, 1 );
    BugSecAttrib.nLength = sizeof( SECURITY_ATTRIBUTES );
    BugSecAttrib.lpSecurityDescriptor = BugSecDesc;
    BugSecAttrib.bInheritHandle = FALSE;


    //
    //  Initialize the REGISTRY_KEY_INFO object
    //
    if( !KeyInfo->Initialize( KeyName,
                              ParentName,
                              0,               // TitleIndex,
                              &TmpClass,
                              &BugSecAttrib ) ) {
        DebugPrint( "KeyInfo->Initialize() failed" );
        DebugPrint( "KeyInfo->Initialize() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        FREE( BugSecDesc );
        return( FALSE );
    }

    FREE( BugSecDesc );
    KeyInfo->PutLastWriteTime( &TmpLastWriteTime );
    KeyInfo->SetNumberOfSubKeys( cSubKeys );
    KeyInfo->SetNumberOfValues( cValues );
    KeyInfo->SetKeyInitializedFlag( TRUE );
    return( TRUE );

#endif
}


BOOLEAN
REGISTRY::QueryKeySecurity(
    IN  PREDEFINED_KEY          PredefinedKey,
    IN  PCREGISTRY_KEY_INFO     KeyInfo,
    IN  SECURITY_INFORMATION    SecurityInformation,
    IN  PSECURITY_DESCRIPTOR*   SecurityDescriptor,
    IN  PULONG                  ErrorCode
    )

/*++

Routine Description:

    Retrieve security information of a particular key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to a REGISTRY_KEY_INFO object that describes the key
              whose security information is to be retrieved.

    SecurityInformation - Specifies the type of descriptor to retrieve.

    SecurityDescriptor - Address of the variable that will contain the pointer
                         to the security descriptor.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined ( _AUTOCHECK_ )

    return FALSE;

#else

    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    HKEY        Handle;
    DWORD       DummyVariable;
    DWORD       Size;
    PBYTE       Pointer;
    DWORD       Status;
    REGSAM      samDesired;

#if DBG
    PSID    DebugOwnerSid;
    PSID    DebugGroupSid;
    PACL    DebugDacl;
    PACL    DebugSacl;
    BOOL    DebugFlag;
    BOOL    DebugDaclPresent;
    BOOL    DebugSaclPresent;
#endif

    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( SecurityDescriptor );


    ParentName = KeyInfo->GetParentName();
    DebugPtrAssert( ParentName );
    KeyName = KeyInfo->GetName();
    DebugPtrAssert( KeyName );


    //
    //  Open the key.
    //  Need to use ACCESS_SYSTEM_SECURITY to retrieve SACL
    //

    samDesired = ( SecurityInformation & SACL_SECURITY_INFORMATION )?
                   ACCESS_SYSTEM_SECURITY | READ_CONTROL : READ_CONTROL;


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  samDesired,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  Find out the size of the security descriptor
    //
    Size = 0;
    Status = RegGetKeySecurity( Handle,
                                SecurityInformation,
                                &DummyVariable,
                                &Size );

    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        DebugPrintTrace(( "RegGetKeySecurity() failed, Status = %#x \n", Status ));
        DebugPrint( "RegGetKeySecurity() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }

    //
    //  Read the security descriptor
    //
    Pointer = ( PBYTE ) MALLOC( ( size_t )Size );
    if( Pointer == NULL ) {
        DebugPrint( "Unable to allocate memory" );
        DebugPtrAssert( Pointer );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegGetKeySecurity( Handle,
                                SecurityInformation,
                                ( PSECURITY_DESCRIPTOR )Pointer,
                                &Size );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    if( Status != 0 ) {
        DebugPrintTrace(( "RegGetKeySecurity() failed, Status = %#x \n", Status ));
        DebugPrint( "RegGetKeySecurity() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );;
        }
        FREE( Pointer );
        return( FALSE );
    }

    *SecurityDescriptor = Pointer;

        //
#if DBG // Security Descriptor Validation
        //
    if( IsValidSecurityDescriptor( *SecurityDescriptor ) ) {
//        DebugPrintTrace(( "Security Descriptor is valid \n" ));
    } else {
        DebugPrint( "IsValidSecurityDescriptor() failed" );
        DebugPrintTrace(( "Security Descriptor is NOT valid, Error = %#d \n", GetLastError() ));
    }

    if( !GetSecurityDescriptorOwner( Pointer, &DebugOwnerSid, &DebugFlag ) ) {
        DebugPrint( "GetSecurityDescriptorOwner() failed" );
        DebugPrintTrace(( "Unable to get Sid Owner, Error = %d \n", GetLastError() ));
    } else {
        if( IsValidSid( DebugOwnerSid ) ) {
//            DebugPrintTrace(( "Owner Sid is valid\n" ));
        } else {
            DebugPrint( "IsValidSid() failed" );
            DebugPrintTrace(( "Owner Sid is NOT valid, Error = %#d \n", GetLastError() ));
        }
    }
    if( !GetSecurityDescriptorGroup( Pointer, &DebugGroupSid, &DebugFlag ) ) {
        DebugPrint( "GetSecurityDescriptorGroup() failed" );
        DebugPrintTrace(( "Unable to get Sid Group, Error = %d \n", GetLastError() ));
    } else {
        if( IsValidSid( DebugGroupSid ) ) {
//            DebugPrintTrace(( "Group Sid is valid\n" ));
        } else {
            DebugPrint( "IsValidSid() failed" );
            DebugPrintTrace(( "Group Sid is NOT valid, Error = %#d \n", GetLastError() ));
        }
    }

    if( ( SecurityInformation & DACL_SECURITY_INFORMATION ) != 0 ) {
        if( !GetSecurityDescriptorDacl( Pointer, &DebugDaclPresent, &DebugDacl, &DebugFlag ) ) {
            DebugPrint( "GetSecurityDescriptorDacl() failed" );
            DebugPrintTrace(( "Unable to get DACL, Error = %d \n", GetLastError() ));
        } else {
            if( DebugDaclPresent ) {
                if( IsValidAcl( DebugDacl ) ) {
//                  DebugPrintTrace(( "DACL is valid\n" ));
                } else {
                    DebugPrint( "IsValidAcl() failed" );
                    DebugPrintTrace(( "DACL is NOT valid, Error = %#d \n", GetLastError() ));
                }
            } else {
                DebugPrint( "GetSecurityDescriptorDacl() succeeded but DACL is not present" );
            }
        }
    }

    if( ( SecurityInformation & SACL_SECURITY_INFORMATION ) != 0 ) {
        if( !GetSecurityDescriptorSacl( Pointer, &DebugSaclPresent, &DebugSacl, &DebugFlag ) ) {
            DebugPrint( "GetSecurityDescriptorDacl() failed" );
            DebugPrintTrace(( "Unable to get DACL, Error = %d \n", GetLastError() ));
        } else {
            if( DebugSaclPresent ) {
                if( IsValidAcl( DebugSacl ) ) {
//                  DebugPrintTrace(( "SACL is valid\n" ));
                } else {
                    DebugPrint( "IsValidAcl() failed" );
                    DebugPrintTrace(( "SACL is NOT valid, Error = %#d \n", GetLastError() ));
                }
            } else {
                DebugPrint( "GetSecurityDescriptorSacl() succeeded but SACL is not present" );
            }
        }
    }
#endif //
       // Security Descriptor Validation
       //

    return( TRUE );

#endif
}





BOOLEAN
REGISTRY::QuerySubKeysInfo(
    IN      PREDEFINED_KEY      PredefinedKey,
    IN      PCWSTRING    ParentKey,
    IN      PCWSTRING    KeyName,
    OUT     PARRAY              SubKeysInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Return an array of PREGISTRY_KEY_INFO objects, each object containing
    the information of a subkey.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentKey - Name of the parent key.

    KeyName - Name of the key that contains the subkeys to be queried.

    SubKeysInfo - Pointer to an initialized array that will contain the
                  information (PREGISTRY_KEY_INFO) about the subkeys queried.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{


#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( ParentKey );
    UNREFERENCED_PARAMETER( KeyName );
    UNREFERENCED_PARAMETER( SubKeysInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PWSTRING            CompleteName;
    DSTRING             SubKeyName;


    PREGISTRY_KEY_INFO  TmpInfoKey;
    ULONG               Index;

    DWORD               Status;
    HKEY                Handle;


    //
    // Variables used in RegQueryInfoKey() and RegEnumKeyEx()
    //
    WCHAR       lpName[ MAX_PATH + 1 ];
    DWORD       cbName;
    LPWSTR      lpClass;
    WSTR        DummyVariable;
    DWORD       cbClass;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;



    DebugPtrAssert( SubKeysInfo );
    DebugPtrAssert( ParentKey );
    DebugPtrAssert( KeyName );


    //
    //  Open a handle to the key, and find out the number of subkeys it has
    //

    if( !OpenKey( PredefinedKey,
                  ParentKey,
                  KeyName,
                  KEY_READ,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey failed" );
        return( FALSE );
    }


    //
    //  Query the key to find out the number of subkeys it has
    //
    cbClass = 0;
    lpClass = &DummyVariable;
    Status = RegQueryInfoKey( Handle,
                              lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );


    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ){
        DebugPrintTrace(( "RegQueryInfoKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegQueryInfoKey() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        return( FALSE );
    }

    if( cbClass != 0 ) {
        //
        //  If the key has a Class, then we need to allocate a buffer and
        //  read the class, even though we don't need it. If it is not
        //  safe to assume that the other information returned by the
        //  API are correct.
        //
        cbClass++;
        lpClass = ( PWSTR )MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
        if( lpClass == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            DebugPtrAssert( lpClass );
            return( FALSE );
        }
        Status = RegQueryInfoKey( Handle,
                                  lpClass,
                                  &cbClass,
                                  NULL,
                                  &cSubKeys,
                                  &cbMaxSubKeyLen,
                                  &cbMaxClassLen,
                                  &cValues,
                                  &cbMaxValueNameLen,
                                  &cbMaxValueLen,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        FREE( lpClass );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Status = %#x \n", Status ));
            DebugPrint( "RegQueryInfoKey() failed" );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            return( FALSE );
        }
    }

    //
    //  Get the complete key name. It is the parent name of each
    //  subkey that we are goint to read.
    //

    CompleteName = BuildCompleteName( ParentKey, KeyName );
    if( CompleteName == NULL ) {
        DebugPrint( "BuildCompleteName() failed" );
        DebugPrint( "BuildCompleteName() failed" );
        DebugPtrAssert( CompleteName );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }

    //
    //  Get the name of each subkey, build a REGISTRY_INFO_KEY for
    //  each of them, and put them in the array.
    //

    for( Index = 0; Index < cSubKeys; Index++ ) {

        cbName = sizeof( lpName ) / sizeof (WCHAR);
        Status = RegEnumKeyEx( Handle,
                               Index,
                               ( LPWSTR )lpName,
                               &cbName,
                               NULL,
                               NULL,
                               NULL,
                               &ftLastWriteTime );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegEnumKeyEx() failed, Status = %#x \n", Status ));
            DebugPrint( "RegEnumKeyEx() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            DELETE( CompleteName );
            return( FALSE );
        }
        //
        //  Initialize SubKeyName using the subkey name length. It is not
        //  safe to assume that the name is NULL terminated.
        //
        if( ( cbName != 0 ) &&
            ( lpName[ cbName - 1 ] == ( WCHAR )'\0' ) ) {
            cbName--;
        }

        if( !SubKeyName.Initialize( ( LPWSTR )lpName ) )  {
            DebugPrint( "SubKeyName.Initialize( ( LPWSTR )lpName ) failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
            DELETE( CompleteName );
            return( FALSE );
        }
        TmpInfoKey = ( PREGISTRY_KEY_INFO )NEW( REGISTRY_KEY_INFO );
        if( TmpInfoKey == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            DELETE( CompleteName );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            DebugPtrAssert( TmpInfoKey );
            return( FALSE );
        }


        if( !QueryKeyInfo( PredefinedKey,
                           CompleteName,
                           &SubKeyName,
                           TmpInfoKey,
                           ErrorCode ) ) {
            //
            // We have to know why it failed. If it is because we don't have
            // the right permission, we should continue to query the other
            // subkeys.
            //
//            if( ( ErrorCode != NULL ) ) { // && ( *ErrorCode == REGISTRY_ERROR_ACCESS_DENIED ) ) {
                //
                //  If it failed because we don't have permission to access the key
                //  initialize key info with the parent name and key name only.
                //  Notice that Class and LastWriteTime won't be initialized.ext file
                //
                TmpInfoKey->SetKeyInitializedFlag( FALSE );
                if( !TmpInfoKey->PutParentName( CompleteName ) ||
                    !TmpInfoKey->PutName( &SubKeyName ) ) {
                    DebugPrint( "Initialization failure" );
                    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                        RegCloseKey( Handle );
                    }
                    if( ErrorCode != NULL ) {
                        *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
                    }
                    DELETE( CompleteName );
                    DELETE( TmpInfoKey );
                    return( FALSE );
                }

//            } else {
//                DebugPrint( "QueryKeyInfo failed" );
//                if( Handle != _PredefinedKey[ PredefinedKey ] ) {
//                    RegCloseKey( Handle );
//                }
//                DELETE( CompleteName );
//                DELETE( TmpInfoKey );
//                return( FALSE );
//            }
        }


        SubKeysInfo->Put( TmpInfoKey );
    }

    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    DELETE( CompleteName );
    return( TRUE );

#endif
}


BOOLEAN
REGISTRY::QueryValue(
    IN      PREDEFINED_KEY           PredefinedKey,
    IN      PCWSTRING         ParentName,
    IN      PCWSTRING         KeyName,
    IN      PCWSTRING         ValueName,
    OUT     PREGISTRY_VALUE_ENTRY    Value,
    OUT     PULONG                  ErrorCode
    )

/*++

Routine Description:

    Return  PREGISTRY_VALUE_ENTRY object, that contains the information
    of a particular value entry in a key.


Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - Name of the parent key.

    KeyName - Name of the key that contains the value to be
              queried.

    ValueName - The name of the desired value.

    Value - Pointer to a non initialized REGISTRY_VLUE_ENTRY object
            that will contain the information about the desired value.


    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( ParentName );
    UNREFERENCED_PARAMETER( KeyName );
    UNREFERENCED_PARAMETER( ValueName );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PWSTR               ValueNameString;


    DWORD               Status;
    HKEY                Handle;


    //
    // Variables used in RegQueryValueEx()
    //

    DWORD       Type;
    PBYTE       Data;
    DWORD       cbData;
    DWORD       DummyVariable;

    DebugPtrAssert( Value );
    DebugPtrAssert( ValueName );
    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_QUERY_VALUE,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey failed" );
        return( FALSE );
    }

    //
    // Get the value information
    //

    ValueNameString = ValueName->QueryWSTR();
    if( ValueNameString == NULL ) {
        DebugPrint( "ValueName->QueryWSTR()" );
        DebugPtrAssert( ValueNameString );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Data = ( PBYTE )&DummyVariable;
    cbData = 0;
    Status = RegQueryValueEx( Handle,
                              ValueNameString,
                              NULL,
                              &Type,
                              Data,
                              &cbData );
    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        DebugPrintTrace(( "RegQueryValueEx() failed, Status = %#x \n", Status ));
        DebugPrint( "RegQueryValue() failed" );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        FREE( ValueNameString );
        return( FALSE );
    }


    if( cbData != 0 ) {
        //
        //  If the value entry has data, then read it
        //
        Data = ( PBYTE )MALLOC( ( size_t )cbData );
        if( Data == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            FREE( ValueNameString );
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            DebugPtrAssert( Data );
            return( FALSE );
        }

        Status = RegQueryValueEx( Handle,
                                  ValueNameString,
                                  NULL,
                                  &Type,
                                  Data,
                                  &cbData );

        if( Status != 0 ) {
            DebugPrintTrace(( "RegQueryValueEx() failed, Status = %#x \n", Status ));
            DebugPrint( "RegQueryValue() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            FREE( ValueNameString );
            return( FALSE );
        }
    }

    FREE( ValueNameString );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    if( Status != 0 ) {
        DebugPrintTrace(( "RegQueryValueEx() failed, Status = %#x \n", Status ));
        DebugPrint( "RegQueryValue() failed" );

        //
        //  If the value entry has data, the free the buffer that
        //  contains the data.
        //
        if( Data != ( PBYTE )&DummyVariable ) {
            FREE( Data );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }

    if( !Value->Initialize( ValueName,
                            0,                    // TitleIndex,
                            ( REG_TYPE )Type,
                            Data,
                            cbData ) ) {
        DebugPrint( "Value->Initialize() failed" );
        if( Data != ( PBYTE )&DummyVariable ) {
            FREE( Data );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }
    if( Data != ( PBYTE )&DummyVariable ) {
        FREE( Data );
    }

    return( TRUE );

#endif
}




BOOLEAN
REGISTRY::QueryValues(
    IN      PREDEFINED_KEY      PredefinedKey,
    IN      PCWSTRING    ParentName,
    IN      PCWSTRING    KeyName,
    OUT     PARRAY              Values,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Return an array of PREGISTRY_VALUE_ENTRY objects, each object containing
    the information of a value in a key..

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - Name of the parent key.

    KeyName - Name of the key that contains the values to be
              queried.

    Values - Pointer to an initialized array that will contain the
             information (PREGISTRY_VALUE_ENTRY) of each value in the key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

#if defined( _AUTOCHECK_ )

    BYTE                        KeyBuf[ KEY_FULL_SIZE ];
    PKEY_VALUE_FULL_INFORMATION ValueBuf = NULL;
    ULONG                       ValueBufSize = 1;
    ULONG                       Length;
    ULONG                       Index;
    PREGISTRY_VALUE_ENTRY       RegValue;
    DSTRING                     ValueName;
    PBYTE                       Data;
    NTSTATUS                    Status;
    HANDLE                      Handle;


    if ( !OpenKey( ParentName, KeyName, KEY_READ, &Handle, ErrorCode ) ) {
        return FALSE;
    }


    //
    //  Query the key to find out the number of values it has
    //
    Status = NtQueryKey( Handle,
                         KeyFullInformation,
                         &KeyBuf,
                         KEY_FULL_SIZE,
                         &Length );

    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode != NULL ) {
            *ErrorCode = Status;
        }
        NtClose( Handle );
        return FALSE;
    }


    ValueBufSize = ((PKEY_FULL_INFORMATION)KeyBuf)->MaxValueDataLen;

    if ( !Values                                                        ||
         !(ValueBuf = (PKEY_VALUE_FULL_INFORMATION)MALLOC( ValueBufSize ) )
       ) {

        NtClose( Handle );
        return FALSE;
    }


    //
    //  Get each value, build a REGISTRY_VALUE_ENTRY for
    //  each of them, and put them in the array.
    //
    Values->Initialize( ((PKEY_FULL_INFORMATION)KeyBuf)->Values );

    for ( Index = 0; Index < ((PKEY_FULL_INFORMATION)KeyBuf)->Values; Index++ ) {


        Status = NtEnumerateValueKey( Handle,
                                      Index,
                                      KeyValueFullInformation,
                                      ValueBuf,
                                      ValueBufSize,
                                      &Length );

        if ( !NT_SUCCESS( Status ) ) {

            //
            //  If overflow, grow the bufer and try again.
            //
            if ( Status == STATUS_BUFFER_OVERFLOW ) {

                if ( !(ValueBuf = (PKEY_VALUE_FULL_INFORMATION)REALLOC( ValueBuf, Length ) ) ) {
                    *ErrorCode = 0;
                    NtClose( Handle );
                    FREE( ValueBuf );
                    return FALSE;
                }

                ValueBufSize = Length;

                Status = NtEnumerateValueKey( Handle,
                                              Index,
                                              KeyValueFullInformation,
                                              ValueBuf,
                                              ValueBufSize,
                                              &Length );

            }

            if ( !NT_SUCCESS( Status ) ) {
                if ( ErrorCode ) {
                    *ErrorCode = Status;
                    NtClose( Handle );
                    FREE( ValueBuf );
                    return FALSE;
                }
            }
        }


        //
        //  Initialize the REGISTRY_VALUE_ENTRY object and put it in the array
        //
        Data = (PBYTE)ValueBuf +  ((PKEY_VALUE_FULL_INFORMATION)ValueBuf)->DataOffset;

        if ( !(RegValue = NEW REGISTRY_VALUE_ENTRY )                                        ||
             !ValueName.Initialize( (PSTR)((PKEY_VALUE_FULL_INFORMATION)ValueBuf->Name) )   ||
             !RegValue->Initialize( &ValueName,
                                    (ULONG)ValueBuf->TitleIndex,
                                    (REG_TYPE)ValueBuf->Type,
                                    (PCBYTE)Data,
                                    (ULONG)ValueBuf->DataLength )      ||
             !Values->Put( RegValue )

           ) {

            NtClose( Handle );
            FREE( ValueBuf );
            DELETE( RegValue );
            return FALSE;
        }
    }

    NtClose( Handle );

    FREE( ValueBuf );

    return TRUE;

#else

    DSTRING                ValueNameString;

    PREGISTRY_VALUE_ENTRY  TmpValueEntry;
    ULONG                  Index;

    DWORD                  Status;
    HKEY                   Handle;



    //
    // Variables used in RegQueryInfoKey() and RegEnumKeyEx()
    //
    LPWSTR      lpClass;
    DWORD       cbClass;
    WSTR        DummyVariable;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    FILETIME    ftLastWriteTime;

    PWCHAR      ValueName;
    DWORD       cbValueName;
    DWORD       cbSecurityDescriptor;
    DWORD       Type;
    PBYTE       Data;
    DWORD       cbData;

    DebugPtrAssert( Values );
    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );


    //
    //  Open the key
    //

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_READ,
                  &Handle,
                  ErrorCode ) ) {

        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }


    //
    //  Query the key to find out the number of values it has
    //
    lpClass = &DummyVariable;
    cbClass = 0;
    Status = RegQueryInfoKey( Handle,
                              ( LPWSTR )lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );


    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        return( FALSE );
    }
    //
    //  If the key has a Class, then we have to query it again, to retrieve
    //  its class, becase we cannot assume that the other information that the
    //  API returned is correct
    //
    if( cbClass != 0 ) {
        cbClass++;
        lpClass = ( PWSTR )MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
        if( lpClass == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            DebugPtrAssert( lpClass );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            return( FALSE );
        }

        Status = RegQueryInfoKey( Handle,
                                  ( LPWSTR )lpClass,
                                  &cbClass,
                                  NULL,
                                  &cSubKeys,
                                  &cbMaxSubKeyLen,
                                  &cbMaxClassLen,
                                  &cValues,
                                  &cbMaxValueNameLen,
                                  &cbMaxValueLen,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        FREE( lpClass );
        if( Status != 0 ) {
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            return( FALSE );
        }
    }
    //
    //  Get each value, build a REGISTRY_VALUE_ENTRY for
    //  each of them, and put them in the array.
    //
    cbMaxValueNameLen++;
    ValueName = ( PWCHAR )MALLOC( (size_t)( cbMaxValueNameLen*sizeof( WCHAR ) ) );
    Data = ( PBYTE )MALLOC( ( size_t )cbMaxValueLen );
    if( ( Data == NULL ) || ( ValueName == NULL ) ) {
        DebugPrint( "Unable to allocate memory" );
        DebugPtrAssert( Data );
        DebugPtrAssert( ValueName );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        FREE( ValueName );
        FREE( Data );
        return( FALSE );
    }
    for( Index = 0; Index < cValues; Index++ ) {
        cbData = cbMaxValueLen;
        cbValueName = cbMaxValueNameLen;
        Status = RegEnumValue( Handle,
                               Index,
                               ( LPWSTR )ValueName,
                               &cbValueName,
                               NULL,
                               &Type,
                               Data,
                               &cbData );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegEnumValue() failed, Status = %#x, cbValueName = %d \n", Status, cbValueName ));
            DebugPrint( "RegEnumValue() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            FREE( Data );
            FREE( ValueName );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            return( FALSE );
        }
        if( ( cbValueName != 0 ) &&
            ( ValueName[ cbValueName  - 1 ] == ( WCHAR )'\0' ) ) {
            cbValueName--;
        }
        if( !ValueNameString.Initialize( ( LPWSTR )ValueName ) ) {
            DebugPrint( "ValueNameString.Initialize( ( LPWSTR )ValueName ) failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            FREE( Data );
            FREE( ValueName );
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
            return( FALSE );
        }

        TmpValueEntry = ( PREGISTRY_VALUE_ENTRY )NEW( REGISTRY_VALUE_ENTRY );
        if( TmpValueEntry == NULL ) {
            DebugPtrAssert( TmpValueEntry );
            DebugPrint( "Unable to allocate memory" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            FREE( ValueName );
            FREE( Data );
            return( FALSE );
        }
        if( !TmpValueEntry->Initialize( &ValueNameString,
                                        0,                    // TitleIndex,
                                        (REG_TYPE)Type ) ) {
            DebugPrint( "TmpValueEntry->Initialize( ) failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            FREE( TmpValueEntry);
            FREE( Data );
            FREE( ValueName );
            return( FALSE );
        }
        if (!TmpValueEntry->PutData( Data, cbData )) {
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            FREE( TmpValueEntry);
            FREE( ValueName );
            FREE( Data );
            return( FALSE );
        }
        Values->Put( TmpValueEntry );
    }
    FREE( Data );
    FREE( ValueName );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::SetKeySecurity(
    IN     PREDEFINED_KEY         PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO     KeyInfo,
    IN     SECURITY_INFORMATION   SecurityInformation,
    IN     PSECURITY_DESCRIPTOR   SecurityDescriptor,
    IN     PULONG                 ErrorCode,
    IN     BOOLEAN                Recurse
    )

/*++

Routine Description:

    Set security information of a particular key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to a REGISTRY_KEY_INFO object that describes the key
              whose security information is to be set.

    SecurityInformation - Specifies the type of descriptor to set.

    SecurityDescriptor - Pointer to the scurity descriptor.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.

    Recurse - Indicates whether the security of the subkeys should also be
              set.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined ( _AUTOCHECK_ )

    return FALSE;

#else

    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    HKEY        Handle;
    DWORD       Status;
    REGSAM      samDesired;


    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( SecurityDescriptor );

    ParentName = KeyInfo->GetParentName();
    DebugPtrAssert( ParentName );

    KeyName = KeyInfo->GetName();
    DebugPtrAssert( KeyName );

    samDesired = MAXIMUM_ALLOWED;
    if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
        samDesired |= ACCESS_SYSTEM_SECURITY;
    } else if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
        samDesired |= WRITE_DAC;
    } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
        samDesired |= WRITE_OWNER;
    } else {
        DebugPrint( "ERROR: SecurityInformation is invalid" );
        DebugPrintTrace(( "SecurityInformation is invalid, SecurityInformation = %# \n",
                   SecurityInformation ));
    }


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  samDesired,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }


    if( Recurse ) {

        if( !SetSubKeysSecurity( Handle,
                                 SecurityInformation,
                                 SecurityDescriptor,
                                 ErrorCode ) ) {

            DebugPrintTrace(( "SetSubKeysSecurity failed, ErrorCode = %#x \n", *ErrorCode ));
            DebugPrint( "SetSubKeysSecurity failed" );
            RegFlushKey( Handle );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( *ErrorCode );
            }
            return( FALSE );
        }
    } else {


        Status = RegSetKeySecurity( Handle,
                                    SecurityInformation,
                                    SecurityDescriptor );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegSetKeySecurity() failed, Status = %#x \n", Status ));
            DebugPrint( "RegSetKeySecurity() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            return( FALSE );
        }
    }

    Status = RegFlushKey( Handle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n" ));
        DebugPrint( "RegFlushKey() failed" );
    }

    //
    //  Close the handle even if it is a predefined handle.
    //  This is necessary so that the predfined handle will contain the new
    //  security, next time it is accesed.
    //
    RegCloseKey( Handle );

    return( TRUE );

#endif
}







BOOLEAN
REGISTRY::UpdateKeyInfo(
    IN      PREDEFINED_KEY      PredefinedKey,
    IN OUT  PREGISTRY_KEY_INFO  KeyInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Update _LastWriteTime, _NumberOfSubKeys and _NumberOfValues of
    a REGISTRY_KEY_INFO object.
    This method is used by methods that create key or value entry.


Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              key to be updated.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( KeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PCWSTRING   ParentName;
    PCWSTRING   KeyName;

    DWORD       Status;
    HKEY        Handle;

    // PTIMEINFO   LastWriteTime;

    //
    // Variables used in QueryKeyInfo()
    //
    LPWSTR      lpClass;
    WSTR        DummyVariable;
    DWORD       cbClass;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;


    DebugPtrAssert( KeyInfo );

    ParentName = KeyInfo->GetParentName();
    DebugPtrAssert( ParentName );

    KeyName = KeyInfo->GetName();
    DebugPtrAssert( KeyName );

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_READ,
                  &Handle,
                  ErrorCode  ) ) {
//        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  Query the key to update _LastWriteTime, _NumberOfSubKeys and _NumberOfValues in KeyInfo
    //
    lpClass = &DummyVariable;
    cbClass = 0;
    Status = RegQueryInfoKey( Handle,
                              ( LPWSTR )lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );

    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        DebugPrintTrace(( "RegQueryInfoKey() failed, Status = %#x \n" ));
        DebugPrint( "RegQueryInfoKey() failed" );

        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
    }

    //
    //  If the key has a Class, then we need to query the key again to
    //  retrieve its class. This is to make sure that all the information
    //  returned by  API is correct
    //

    if( cbClass != 0 ) {
        cbClass++;
        lpClass = ( LPWSTR )MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
        if( lpClass == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            DebugPtrAssert( lpClass );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            KeyInfo->SetKeyInitializedFlag( FALSE );
            return( FALSE );
        }
        Status = RegQueryInfoKey( Handle,
                                  ( LPWSTR )lpClass,
                                  &cbClass,
                                  NULL,
                                  &cSubKeys,
                                  &cbMaxSubKeyLen,
                                  &cbMaxClassLen,
                                  &cValues,
                                  &cbMaxValueNameLen,
                                  &cbMaxValueLen,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        FREE( lpClass );

        if( Status != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Status = %#x \n" ));
            DebugPrint( "RegQueryInfoKey() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            KeyInfo->SetKeyInitializedFlag( FALSE );
            return( FALSE );
        }
    }

    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }



    //
    //  Update _LastWriteTime in KeyInfo
    //
    if( !( ( KeyInfo->_LastWriteTime ).Initialize( &ftLastWriteTime ) ) ) {
        DebugPrint( "( KeyInfo->_LastWriteTime )->Initialize( &ftLastWriteTime ) failed" );
        KeyInfo->SetKeyInitializedFlag( FALSE );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
    }

    //
    //  Update NumberOfSubKeys and NumberOfValues in KeyInfo
    //
    KeyInfo->SetNumberOfSubKeys( cSubKeys );
    KeyInfo->SetNumberOfValues( cValues );
    KeyInfo->SetKeyInitializedFlag( TRUE );
    return( TRUE );

#endif
}



PWSTRING
REGISTRY::BuildCompleteName(
    IN  PCWSTRING    ParentName,
    IN  PCWSTRING    KeyName
    )

/*++

Routine Description:

    Build a complete key name based on its parent name and its name

Arguments:


    ParentName - The name of a key relative to a predefined key (root of a tree).

    KeyName - The name of a key relative to its parent.


Return Value:

    PWSTRING - Returns a WSTRING that contains the complete key name, or
               NULL if an error occurs..


--*/

{

#if defined( _AUTOCHECK_ )


    PWSTRING    CompleteName;

    if ( !(CompleteName = NEW DSTRING )                                 ||
         !CompleteName->Initialize( ParentName )                        ||
         !CompleteName->Strcat( _Separator )                            ||
         !CompleteName->Strcat( KeyName )

       ) {

        DELETE( CompleteName );
        CompleteName = NULL;
    }

    return CompleteName;

#else

    PWSTRING    CompleteName;


    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );

    CompleteName = ( PWSTRING )NEW( DSTRING );
    if( CompleteName == NULL ) {
        DebugPtrAssert( CompleteName );
        return( NULL );
    }

    if( ( ParentName->QueryChCount() == 0 ) &&
        ( KeyName->QueryChCount() == 0 ) ) {
        //
        //  The key is a predefined key
        //
        if( !CompleteName->Initialize( "" ) ) {
            DebugPrint( "CompleteName->Initialize() failed \n" );
            DELETE( CompleteName );
            return( NULL );
        }
    } else if( ParentName->QueryChCount() == 0 ) {
        //
        // The key is a subkey of a predefined key
        //
        if( !CompleteName->Initialize( KeyName ) ) {
            DebugPrint( "CompleteName->Initialize( KeyName ) failed" );
            FREE( CompleteName );
            return( NULL );
        }
    } else {
        if( !CompleteName->Initialize( ParentName ) ) {
            DebugPrint( "CompleteName->Initialize( ParentName ) failed" );
            FREE( CompleteName );
            return( NULL );
        }
        if( KeyName->QueryChCount() != 0 ) {
            CompleteName->Strcat( _Separator );
            CompleteName->Strcat( KeyName );
        }
    }
    return( CompleteName );

#endif
}




#if !defined( _AUTOCHECK_ )
ULONG
REGISTRY::MapWin32RegApiToRegistryError(
    IN ULONG    Status
    ) CONST

/*++

Routine Description:

    Maps status codes returned by Win32 Registry APIs to REGISTRY error codes.

Arguments:

    Status  - Supplies a Win32 status code.

Return Value:

    LONG    - Returns a Registry error code.


        - REGISTRY_ERROR_BADDB
        - REGISTRY_ERROR_CANTOPEN
        - REGISTRY_ERROR_CANTREAD
        - REGISTRY_ERROR_ACCESS_DENIED
        - REGISTRY_ERROR_INVALID_PARAMETER
        - REGISTRY_ERROR_OUTOFMEMORY

--*/

{

    //
    // Map the Win 32 code to a Registry error code.
    //

    switch( Status ) {

    case ERROR_BADDB:

        return REGISTRY_ERROR_BADDB;

    case ERROR_ACCESS_DENIED:

        return REGISTRY_ERROR_ACCESS_DENIED;

    case ERROR_CANTOPEN:

        return REGISTRY_ERROR_CANTOPEN;

    case ERROR_CANTREAD:

        return REGISTRY_ERROR_CANTREAD;

    case ERROR_INVALID_PARAMETER:

        return REGISTRY_ERROR_INVALID_PARAMETER;

    case ERROR_OUTOFMEMORY:

        return REGISTRY_ERROR_OUTOFMEMORY;

    case ERROR_PRIVILEGE_NOT_HELD:

        return REGISTRY_ERROR_PRIVILEGE_NOT_HELD;

    case RPC_S_SERVER_UNAVAILABLE:
    case RPC_S_CALL_FAILED:

        return REGISTRY_RPC_S_SERVER_UNAVAILABLE;

    case ERROR_KEY_DELETED:

        return REGISTRY_ERROR_KEY_DELETED;

    case ERROR_FILE_NOT_FOUND:

        return REGISTRY_ERROR_KEY_NOT_FOUND;

    case ERROR_CHILD_MUST_BE_VOLATILE:

        return REGISTRY_ERROR_CHILD_MUST_BE_VOLATILE;

    default:

//        DebugPrintTrace(( "REGEDIT: Unknown Registry error %#x \n", Status ));
//        DebugPrint( "REGEDIT: Unknown Registry error" );
        return REGISTRY_ERROR_UNKNOWN_ERROR;
    }
}
#endif  // _AUTOCHECK



#if defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::OpenKey(
    IN  PCWSTRING    ParentKeyName,
    IN  PCWSTRING    KeyName,
    IN  ULONG               Flags,
    OUT PHANDLE             Handle,
    OUT PULONG              ErrorCode
    )
/*++

Routine Description:


    Opens a key and obtains a handle to it

Arguments:


    ParentName  - Supplies the name of a key relative to a predefined key (root of a tree).

    KeyName     - Supplies the name of a key relative to its parent.

    Handle      - Returns the handle to the key

    Status      - Returns the NT status in case of error


Return Value:

    BOOLEAN - TRUE if key opened

--*/
{
    PWSTRING            CompleteKeyName         = NULL;
    PWSTR               CompleteKeyNameString   = NULL;
    UNICODE_STRING      UnicodeKeyName;
    OBJECT_ATTRIBUTES   ObjAttr;
    NTSTATUS            Status;
    BOOLEAN             Opened = FALSE;

    if ( ParentKeyName                                                     &&
         KeyName                                                           &&
         (CompleteKeyName = BuildCompleteName( ParentKeyName, KeyName ) )  &&
         (CompleteKeyNameString = CompleteKeyName->QueryWSTR() )
       ) {

        RtlInitUnicodeString( &UnicodeKeyName, CompleteKeyNameString );

        InitializeObjectAttributes( &ObjAttr,
                                    &UnicodeKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    0,
                                    0 );

        //
        //  Open the key
        //
        Status = NtOpenKey( Handle, Flags, &ObjAttr );

        if ( NT_SUCCESS( Status ) ) {

            Opened = TRUE;

        } else {

            if ( ErrorCode != NULL ) {
                *ErrorCode = Status;
            }
        }
    }

    DELETE( CompleteKeyName );
    FREE( CompleteKeyNameString );


    return Opened;
}

#endif



#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::OpenKey(
    IN  PREDEFINED_KEY      PredefinedKey,
    IN  PCWSTRING    ParentName,
    IN  PCWSTRING    KeyName,
    IN  DWORD               Permission,
    OUT PHKEY               Key,
    OUT PULONG              ErrorCode
    )
/*++

Routine Description:


    Opens a handle to a key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName  - Supplies the name of a key relative to a predefined key (root of a tree).

    KeyName     - Supplies the name of a key relative to its parent.

    Permission  - Type of access to the key

    Handle      - Returns the handle to the key

    Status      - Returns an error code if the operation fails.


Return Value:

    BOOLEAN - TRUE if key opened

--*/
{

    PWSTRING    CompleteName;
    PWSTR       CompleteNameString;
    ULONG       Status;

#if 0 // DBG
    PSTR        DebugKeyName;
#endif


    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );
    DebugPtrAssert( Key );


    //
    //  Get the complete key name
    //
    CompleteName = BuildCompleteName( ParentName, KeyName );
    if( CompleteName == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( CompleteName );
        return( FALSE );
    }
    //
    //  Open a handle to the key
    //
    if( CompleteName->QueryChCount() == 0 ) {
        //
        //  This is a predefined key
        //
        if( !IsRemoteRegistry() ||
            ( IsRemoteRegistry() &&
              ( ( Permission & ACCESS_SYSTEM_SECURITY ) == 0 )
            )
          ) {
            *Key = _PredefinedKey[ PredefinedKey ];
            DELETE( CompleteName );
            return( TRUE );
        }
    }

    //
    //  Find out the complete name of the key
    //
    CompleteNameString = CompleteName->QueryWSTR();
#if 0 // DBG
    DebugKeyName = CompleteName->QuerySTR();
#endif
    DELETE( CompleteName );
    if( CompleteNameString == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( CompleteName );
        return( FALSE );
    }
    //
    //  Open handle to the key
    //
    Status = RegOpenKeyEx( _PredefinedKey[ PredefinedKey ],
                           CompleteNameString,
                           0,
                           Permission,
                           Key );

    if( Status != 0 ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
#if 0 // DBG
        DebugPrintTrace(( "RegOpenKeyEx() failed, KeyName = %s, Permission = %#x, Status = %#x \n"),
                   DebugKeyName, Permission, Status );
#endif
//      DebugPrint( "RegOpenKeyEx() failed" );
        FREE( CompleteNameString );
#if 0 // DBG
        FREE( DebugKeyName );
#endif
        return( FALSE );
    }
    FREE( CompleteNameString );
#if 0 // DBG
    FREE( DebugKeyName );
#endif
    return( TRUE );
}

#endif


#if !defined( _AUTOCHECK_ )

ULONG
REGISTRY::DeleteTree(
    IN HKEY KeyHandle
    )

/*++

Routine Description:


    Delete the subkeys of the key whose handle was passed as argument.
    The deletion process is recusive, that is, the children of the
    subkeys are also deleted.


Arguments:


    KeyHandle - Handle to the key whose subkeys are to be deleted.


Return Value:

    ULONG - Returns 0 if all subkeys were deleted or a Win32 error code
            if something went wrong.


--*/
{

    ULONG       Error;
    DWORD       Index;
    HKEY        ChildHandle;


    WCHAR       KeyName[ MAX_PATH + 1 ];  // +1 counts for the NULL
    DWORD       KeyNameLength;
    PWSTR       ClassName;
    DWORD       ClassNameLength;
    WSTR        DummyVariable;

    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;
    ULONG       Status;


    //
    //  Find out the total number of subkeys
    //


    ClassNameLength = 0;

    Error = RegQueryInfoKey(
                KeyHandle,
                &DummyVariable,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    if( ( Error != 0 ) && ( Error != ERROR_INVALID_PARAMETER ) && ( Error != ERROR_INSUFFICIENT_BUFFER ) ) {
        DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
        DebugPrint( "RegQueryInfoKey() failed" );
        return( Error );
    }

    if( ClassNameLength != 0 ) {
        ClassNameLength++;
        ClassName = ( PWSTR )MALLOC( ( size_t )( ClassNameLength*sizeof( WCHAR ) ) );
        if( ClassName == NULL ) {
            DebugPrint( "UnableToAllocateMemory" );
            return( ERROR_OUTOFMEMORY );
        }
        Error = RegQueryInfoKey(
                    KeyHandle,
                    ClassName,
                    &ClassNameLength,
                    NULL,
                    &NumberOfSubKeys,
                    &MaxSubKeyLength,
                    &MaxClassLength,
                    &NumberOfValues,
                    &MaxValueNameLength,
                    &MaxValueDataLength,
                    &SecurityDescriptorLength,
                    &LastWriteTime
                    );
        FREE( ClassName );
        if( Error != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegQueryInfoKey() failed" );
            return( Error );
        }
    }
    //
    //  Start de deletion from the last child, instead of the first child.
    //  In this way, it is guaranteed that RegEnumKey() will return
    //  the correct subkey while we are deleting them.
    //
    Status = 0;
    for( Index = NumberOfSubKeys; Index > 0; Index-- ) {

        //  If the key has subkeys, then for each subkey, do:
        //
        //
        //  - Determine the subkey name
        //
        KeyNameLength = sizeof( KeyName ) / sizeof( WCHAR );

        Error = RegEnumKey(
                    KeyHandle,
                    Index-1,
                    KeyName,
                    KeyNameLength
                    );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegQueryInfoKey() failed" );
            return( Error );
        }

        //
        //  - Open a handle to the subkey
        //

        Error = RegOpenKeyEx(
                    KeyHandle,
                    KeyName,
                    REG_OPTION_RESERVED,
                    READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, // MAXIMUM_ALLOWED,
                    &ChildHandle
                    );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegOpenKeyEx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegOpenKey() failed" );
            //
            // We want to delete the maximum number of subkeys.
            //
            Status = Error;
            continue;
        }

        //
        //  - Delete the child's subkeys
        //

        Error = DeleteTree( ChildHandle );
        if( Error != 0 ) {
            Status = Error;
        }
        Error = RegCloseKey(
                    ChildHandle
                    );

        if( Error != 0 ) {
            DebugPrintTrace(( "CloseKeyx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegCloseKey() failed" );
        }

        //
        //  -Delete the subkey
        //

        Error = RegDeleteKey(
                    KeyHandle,
                    KeyName
                    );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegDeletKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegDeleteKey() failed" );

        }
    }
    return Status;
}

#endif




#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::EnableRootNotification(
    IN PREDEFINED_KEY   PredefinedKey,
    IN HANDLE           Event,
    IN DWORD            NotifyFilter,
    IN BOOLEAN          WatchSubTree
    )

/*++

Routine Description:


    Enable notification in the prdefined key of a registry.


Arguments:

    PredefinedKey - Indicates which Predefined Key should be monitored.

    Event - Handle to the event object to be signaled when the predefined
            key changes.

    NotifyFilter - Flags that specify in what condition the event should
                   be signaled.

    WatchTree - If TRUE, indicates that the root and all its decsendants
                should be monitored.



Return Value:

    ULONG - Returns 0 if all subkeys were deleted or a Win32 error code
            if something went wrong.


--*/
{
    DWORD   Status;

//    DebugPrintTrace(( "Calling RegNotifyChangeKeyValue() PredefinedKey = %d \n"),
//              PredefinedKey );

//    DebugPrintTrace(( "Calling RegNotifyChangeKeyValue(), PredefinedKey =%d \n", PredefinedKey ));
    Status = RegNotifyChangeKeyValue( _PredefinedKey[ PredefinedKey ],
                                      WatchSubTree,
                                      NotifyFilter,
                                      Event,
                                      TRUE );

    if( Status != 0 ) {

        DebugPrintTrace(( "RegNotifyChangeKeyValue() failed, PredefinedKey = %d, Status = %#x \n",
                   PredefinedKey,
                   Status  ));
        DebugPrint( "RegNotifyChangeKeyValue() failed" );
        return( FALSE );
    }


    return( TRUE );

}

#endif


#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::
SetSubKeysSecurity(
    IN HKEY                   KeyHandle,
    IN SECURITY_INFORMATION   SecurityInformation,
    IN PSECURITY_DESCRIPTOR   SecurityDescriptor,
    IN PULONG                 ErrorCode
    )

/*++

Routine Description:


    Set the security of the key whose handle was passed as argument,
    and all its subkeys.


Arguments:


    KeyHandle - Handle to the key that contains the subkeys whose security
                is to be set.

    SecurityInformation -

    SecurityDescriptor - Security descriptor to be set in the key.

    ErrorCode - Contains a win32 error code if the call fails.


Return Value:

    BOOLEAN - Returns TRUE if if security was set successfully, or FALSE
              otherwise. If it fails, ErrorCode will contain a win32 error
              code.



--*/
{

    ULONG       Error;
    DWORD       Index;
    HKEY        ChildHandle;


    WCHAR       SubKeyName[ MAX_PATH ];
    DWORD       SubKeyNameLength;
    DWORD       ClassNameLength;
    WSTR        DummyVariable;

    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;
    REGSAM      samDesired;
    BOOLEAN     Status;

    HKEY        NewHandle;
    ULONG       Error1;
    DSTRING     ChildKeyName;


    //
    //  -Change the security of the current key
    //

    Error1 = RegSetKeySecurity( KeyHandle,
                                SecurityInformation,
                                SecurityDescriptor );


    //
    //  Find out the total number of subkeys
    //

    Status = TRUE;
    ClassNameLength = 0;

    Error = RegQueryInfoKey(
                KeyHandle,
                &DummyVariable,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    if( ( Error != 0 ) &&
        ( Error != ERROR_ACCESS_DENIED ) &&
        ( Error != ERROR_INVALID_PARAMETER ) &&
        ( Error != ERROR_INSUFFICIENT_BUFFER ) &&
        ( Error != ERROR_MORE_DATA ) ) {
        DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
        DebugPrint( "RegQueryInfoKey() failed" );
        *ErrorCode = Error;
        return( FALSE );
    }

    if( Error == ERROR_ACCESS_DENIED ) {
        //
        //  Handle doesn't allow KEY_QUERY_VALUE or READ_CONTROL access.
        //  Open a new handle with these accesses.
        //
        samDesired = KEY_QUERY_VALUE | READ_CONTROL; // MAXIMUM_ALLOWED | READ_CONTROL;
        if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
            samDesired |= ACCESS_SYSTEM_SECURITY;
        } else if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            samDesired |= WRITE_DAC;
        } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            samDesired |= WRITE_OWNER;
        } else {
            DebugPrint( "ERROR: SecurityInformation is invalid" );
            DebugPrintTrace(( "SecurityInformation is invalid, SecurityInformation = %# \n",
                       SecurityInformation ));
        }

        Error = RegOpenKeyEx( KeyHandle,
                              NULL,
                              REG_OPTION_RESERVED,
                              samDesired,
                              &NewHandle
                            );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegOpenKeyEx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegOpenKey() failed" );
            *ErrorCode = Error;
            return( FALSE );
        }

        Error = RegQueryInfoKey(
                    NewHandle,
                    &DummyVariable,
                    &ClassNameLength,
                    NULL,
                    &NumberOfSubKeys,
                    &MaxSubKeyLength,
                    &MaxClassLength,
                    &NumberOfValues,
                    &MaxValueNameLength,
                    &MaxValueDataLength,
                    &SecurityDescriptorLength,
                    &LastWriteTime
                    );

        if( ( Error != 0 ) &&
            ( Error != ERROR_INVALID_PARAMETER ) &&
            ( Error != ERROR_INSUFFICIENT_BUFFER ) &&
            ( Error != ERROR_MORE_DATA ) ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegQueryInfoKey() failed" );
            *ErrorCode = Error;
            RegCloseKey( NewHandle );
            return( FALSE );
        }
        RegCloseKey( NewHandle );
    }

    if( NumberOfSubKeys == 0 ) {
        //
        //  If the key doesn't have any subkey, return TRUE or FALSE
        //  depending on whether RegSetKeySecurity() succeeded.
        //
        if( Error1 != ERROR_SUCCESS ) {
            *ErrorCode = Error1;
            return( FALSE );
        }
        return( TRUE );
    }

    //
    //  The key has subkeys.
    //  Find out if we are able to enumerate the key using the handle
    //  passed as argument.
    //
    SubKeyNameLength = MAX_PATH;

    Error = RegEnumKey( KeyHandle,
                        0,
                        SubKeyName,
                        SubKeyNameLength
                      );


    if( Error == ERROR_ACCESS_DENIED ) {
        //
        //  Handle doesn't allow 'enumerate' access.
        //  Open a new handle with KEY_ENUMERATE_SUB_KEYS access.
        //
#if 0
        samDesired = MAXIMUM_ALLOWED | KEY_ENUMERATE_SUB_KEYS;
        if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
            samDesired |= ACCESS_SYSTEM_SECURITY;
        } else if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            samDesired |= WRITE_DAC;
        } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            samDesired |= WRITE_OWNER;
        } else {
            DebugPrint( "ERROR: SecurityInformation is invalid" );
            DebugPrintTrace(( "SecurityInformation is invalid, SecurityInformation = %# \n"),
                       SecurityInformation );
        }
#endif

        Error = RegOpenKeyEx( KeyHandle,
                              NULL,
                              REG_OPTION_RESERVED,
                              KEY_ENUMERATE_SUB_KEYS, // samDesired,
                              &NewHandle
                            );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegOpenKeyEx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegOpenKey() failed" );
            *ErrorCode = Error;
            return( FALSE );
        }

    } else {
        NewHandle = KeyHandle;
    }




    for( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        //  If the key has subkeys, then for each subkey, do:
        //
        //
        //  - Determine the subkey name
        //
        SubKeyNameLength = MAX_PATH;

        Error = RegEnumKey( NewHandle,
                            Index,
                            SubKeyName,
                            SubKeyNameLength
                          );


        if( Error != ERROR_SUCCESS ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegQueryInfoKey() failed" );
            *ErrorCode = Error;
            if( NewHandle != KeyHandle ){
                RegCloseKey( NewHandle );
            }
            return( FALSE );
        }

        if( !ChildKeyName.Initialize( SubKeyName ) ) {
            DebugPrint( "ChildKeyName.Initialize() failed" );
            *ErrorCode = ERROR_OUTOFMEMORY;
            if( NewHandle != KeyHandle ){
                RegCloseKey( NewHandle );
            }
            return( FALSE );
        }


        //
        //  - Open a handle to the subkey
        //

        samDesired = MAXIMUM_ALLOWED;
        if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
            samDesired |= ACCESS_SYSTEM_SECURITY;
        } else if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            samDesired |= WRITE_DAC;
        } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            samDesired |= WRITE_OWNER;
        } else {
            DebugPrint( "ERROR: SecurityInformation is invalid" );
            DebugPrintTrace(( "SecurityInformation is invalid, SecurityInformation = %# \n",
                       SecurityInformation ));
        }

        Error = RegOpenKeyEx( NewHandle,
                              ( LPWSTR )( ChildKeyName.GetWSTR() ),
                              REG_OPTION_RESERVED,
                              samDesired,
                              &ChildHandle
                            );


        if( Error == ERROR_SUCCESS ) {

            //
            //  - Set the security of the child's subkeys
            //

            if( !SetSubKeysSecurity( ChildHandle,
                                     SecurityInformation,
                                     SecurityDescriptor,
                                     ErrorCode ) ) {
                Status = FALSE;
            }

            Error = RegCloseKey( ChildHandle );
            if( Error != 0 ) {
                DebugPrintTrace(( "CloseKey() failed, Error = %#x \n", Error ));
                DebugPrint( "RegCloseKey() failed" );
            }

        } else {
            DebugPrintTrace(( "RegOpenKeyEx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegOpenKey() failed" );
            *ErrorCode = Error;
            Status = FALSE;
        }

    }

    if( KeyHandle != NewHandle ) {
        RegCloseKey( NewHandle );
    }

    if( Error1 != ERROR_SUCCESS ) {
        *ErrorCode = Error1;
        return( FALSE );
    }
    return Status;
}

#endif



#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::LoadHive(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    IN    PCWSTRING             FileName,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Load a file that conmtains a hive in a particular key in the
    registry.


Arguments:


    PredefinedKey

    KeyInfo

    FileName

    ErrorCode


Return Value:

    BOOLEAN - Returns TRUE if the hive was loaded.

--*/
{
    LONG        Status;
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    PWSTRING    CompleteName;

    PWSTR       String;
    PWSTR       String1;


    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( FileName );


    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    if( ( ParentName == NULL ) ||
        ( KeyName == NULL ) ) {
        if( ErrorCode  != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            return( FALSE );
        }
    }

    //
    //  Get the complete key name
    //
    CompleteName = BuildCompleteName( ParentName, KeyName );
    if( CompleteName == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( CompleteName );
        return( FALSE );
    }


    String = CompleteName->QueryWSTR();
    String1 = FileName->QueryWSTR();

    DELETE( CompleteName );

    if( ( String == NULL  ) ||
        ( String1 == NULL ) ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( String );
        DebugPtrAssert( String1 );
        return( FALSE );
    }

    Status = RegLoadKey( _PredefinedKey[ PredefinedKey ],
                           String,
                           String1 );

    FREE( String );
    FREE( String1 );
    if( Status != 0 ) {
        DebugPrint( "RegLoadKey() failed" );
        DebugPrintTrace(( "RegLoadKey() failed, Status = %d \n", Status ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }

    Status = RegFlushKey( _PredefinedKey[ PredefinedKey ] );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %d \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }


    if( !UpdateKeyInfo( PredefinedKey, KeyInfo, ErrorCode ) ) {
        DebugPrint( "UpdateKeyInfo() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }

    return( TRUE );
}

#endif




#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::UnLoadHive(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Unload a the key from the registry.


Arguments:


    PredefinedKey

    KeyInfo

    ErrorCode


Return Value:

    BOOLEAN - Returns TRUE if the hive was loaded.

--*/
{
    LONG        Status;
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    PWSTRING    CompleteName;

    PWSTR       Name;


    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    if( ( ParentName == NULL ) ||
        ( KeyName == NULL ) ) {
        if( ErrorCode  != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            return( FALSE );
        }
    }

    //
    //  Get the complete key name
    //
    CompleteName = BuildCompleteName( ParentName, KeyName );
    if( CompleteName == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( CompleteName );
        return( FALSE );
    }


    Name = CompleteName->QueryWSTR();
    DELETE( CompleteName );

    if( Name == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( Name );
        return( FALSE );
    }

    Status = RegUnLoadKey( _PredefinedKey[ PredefinedKey ],
                           Name );

    FREE( Name );
    if( Status != 0 ) {
        DebugPrint( "RegUnLoadKey() failed" );
        DebugPrintTrace(( "RegUnLoadKey() failed, Status = %d \n", Status ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    Status = RegFlushKey( _PredefinedKey[ PredefinedKey ] );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %d \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }
    return( TRUE );
}

#endif





BOOLEAN
REGISTRY::SaveKeyToFile(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    IN    PCWSTRING             FileName,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Save a key and all uts subkeys to a file..


Arguments:


    KeyInfo

    FileName

    ErrorCode


Return Value:

    BOOLEAN - Returns TRUE if the key was saved.

--*/
{
    LONG        Status;
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    HKEY        Key;
    PWSTR       Name;


    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    if( ( ParentName == NULL ) ||
        ( KeyName == NULL ) ) {
        if( ErrorCode  != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            return( FALSE );
        }
    }


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_READ,
                  &Key,
                  ErrorCode ) ) {

        DebugPrint( "OpenKey() failed" );
        DebugPrintTrace(( "OpenKey() failed, ErrorCode = %d \n", *ErrorCode ));
        return( FALSE );
    }


    Name = FileName->QueryWSTR();

    if( Name == NULL ) {
        if( Key != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Key );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegSaveKey( Key,
                         Name,
                         NULL );
    FREE( Name );

    if( Key != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Key );
    }
    if( Status != 0 ) {
        DebugPrint( "RegSaveKey() failed" );
        DebugPrintTrace(( "RegSaveKey() failed, Status = %d \n", Status ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    return( TRUE );
}



BOOLEAN
REGISTRY::RestoreKeyFromFile(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    IN    PCWSTRING             FileName,
    IN    BOOLEAN               Volatile,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Save a key and all uts subkeys to a file..


Arguments:


    KeyInfo - Pointer to the object that describes the key where the
              contents of the file is to be restored.

    FileName - Name of the file that contains the information to be
               restored.

    Volatile - Indicates whether the information should be restore as
               volatile or non-volatile.

    ErrorCode - Contains an error code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the key was restored.

--*/
{
    LONG        Status;
    LONG        Error;
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    HKEY        Key;
    PWSTR       Name;


    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    if( ( ParentName == NULL ) ||
        ( KeyName == NULL ) ) {
        if( ErrorCode  != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            return( FALSE );
        }
    }


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_WRITE,
                  &Key,
                  ErrorCode ) ) {

        DebugPrint( "OpenKey() failed" );
        DebugPrintTrace(( "OpenKey() failed, ErrorCode = %d \n", *ErrorCode ));
        return( FALSE );
    }


    Name = FileName->QueryWSTR();

    if( Name == NULL ) {
        if( Key != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Key );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegRestoreKey( Key,
                            Name,
                            (Volatile)? REG_WHOLE_HIVE_VOLATILE : 0 );
    FREE( Name );




    if( Status == 0 ) {
        Error = RegFlushKey( Key );
        if( Error != 0 ) {
            DebugPrintTrace(( "RegFlushKey() failed, Error = %d \n", Error ));
            DebugPrint( "RegFlushKey() failed" );
        }
    }
    if( Key != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Key );
    }
    if( Status != 0 ) {
        DebugPrint( "RegRestoreKey() failed" );
        DebugPrintTrace(( "RegRestoreKey() failed, Status = %d \n", Status ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }

    return( TRUE );
}



BOOLEAN
REGISTRY::IsAccessAllowed(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    IN    REGSAM                SamDesired,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Determine if a key allows a particular access.

Arguments:


    PredefinedKey -

    KeyInfo - Pointer to the object that describes the key.

    SamDesired - Access to be verified.

    ErrorCode - Contains an error code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the key allows the access, or FALSE otherwise

--*/
{
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;

    HKEY        Handle;



    DebugPtrAssert( KeyInfo );

    ParentName = KeyInfo->GetParentName();
    DebugPtrAssert( ParentName );

    KeyName = KeyInfo->GetName();
    DebugPtrAssert( KeyName );

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  SamDesired,
                  &Handle,
                  ErrorCode  ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\untfs\src\usnjrnl.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    usnjrnl.cxx

Abstract:

    This module implements the Usn Journal Checking

Author:

    Daniel Chan (danielch) 05-Mar-97

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_


#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"
#include "sdchk.hxx"


VOID
MarkEndOfUsnBlock(
    IN OUT  PUSN_REC        UsnEntry,
    IN      ULONG           LengthOfBlock
);

BOOLEAN
NTFS_SA::ValidateUsnJournal(
    IN      PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine ensures that the two data streams in the USN Journal
    file is in good shape.  For the $MAX data stream, it makes sure
    its value is within a resonable range.  For the $J data stream,
    it make sures its file size agree with the largest Usn found on
    the volume.  It also make sures each record is consistent.


Arguments:

    ChkdskInfo  - Supplies the current chkdsk information.
    ChkdskReport- Supplies the current chkdsk report.
    Mft         - Supplies a valid MFT.
    BadClusters - Receives the bad clusters identified by this method.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_ATTRIBUTE              attrib;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    BOOLEAN                     attribute_need_write;
    BOOLEAN                     empty_usn_journal;
    BOOLEAN                     frs_need_flush;
    BOOLEAN                     lastblock;
    BOOLEAN                     error;
    BOOLEAN                     rst;
//    ULONG                       new_percent_done;
//    ULONG                       percent_done = 0;
    ULONG                       num_bytes;
    ULONG                       remain_length;
    ULONG                       remain_block_length;
    ULONG                       bytesWritten;
    ULONG                       bytesToRead;
    ULONG                       depth;
//    ULONG                       initial_length;
    ULONG                       length;
    ULONG                       record_size;
    BIG_INT                     offset;
    BIG_INT                     total_length;
    BIG_INT                     usnJournalMaxSize;
    CREATE_USN_JOURNAL_DATA     usnJournalMax;
    PCINDEX_ENTRY               index_entry;
    PUSN_REC                    usn_entry = NULL;
    PUSN_REC                    previous_usn_entry;
    PUSN_REC                    initial_usn_entry = NULL;
    PUSN_REC                    endOfBlock;
    DSTRING                     attributeName;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    USHORT                      volume_flags;
    BOOLEAN                     is_corrupt;
    UCHAR                       major, minor;
    BIG_INT                     location;

    DebugPtrAssert(ChkdskInfo);
    DebugPtrAssert(ChkdskReport);

    if (ChkdskInfo->UsnJournalFileNumber.GetLowPart() == 0 &&
        ChkdskInfo->UsnJournalFileNumber.GetHighPart() == 0) {

        // assume the Usn Journal feature has not been enabled
        // all Usn should be zeroed

        if (LargestUsnEncountered == 0) {
            return TRUE;
        }

        // some Usn are non-zeros, so zero them out.

        return ResetUsns(ChkdskInfo, FixLevel, Message, Mft);
    }

    Message->DisplayMsg(MSG_CHK_NTFS_CHECKING_USNJRNL, PROGRESS_MESSAGE);

    if (!frs.Initialize(ChkdskInfo->UsnJournalFileNumber, Mft) ||
        !attributeName.Initialize(UsnJournalMaxNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read()) {
        DebugAbort("Previously readable FRS is no longer readable");
        return FALSE;
    }

    volume_flags = QueryVolumeFlagsAndLabel(&is_corrupt, &major, &minor);
    if (volume_flags & VOLUME_DELETE_USN_UNDERWAY && FixLevel != CheckOnly) {

        NTFS_FILE_RECORD_SEGMENT    extend_frs;
        NTFS_INDEX_TREE             index;

        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_USNJRNL);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (!attributeName.Initialize(UsnJournalNameData)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (frs.QueryAttribute(&attrib,
                               &error,
                               $DATA,
                               &attributeName)) {

            BIG_INT     total_user_bytes;

            total_user_bytes = attrib.QueryClustersAllocated() * QueryClusterFactor() *
                               _drive->QuerySectorSize();

            // un-account user data previously accounted for

            ChkdskReport->BytesUserData -= total_user_bytes;
            ChkdskReport->NumUserFiles -= 1;
        } else {
            if (error) {
                DebugPrintTrace(("UNTFS: Unable to query Usn Journal $DATA, %s attribute.\n",
                                 UsnJournalNameData));
            }
            // not fatal yet as we are going to delete it anyway
        }

        if (!frs.Delete(Mft->GetVolumeBitmap())) {
            DebugPrintTrace(("Error in deleting the USN Journal file.\n"));
            return FALSE;
        }

        if (!extend_frs.Initialize(EXTEND_TABLE_NUMBER, Mft) ||
            !attributeName.Initialize(FileNameIndexNameData)) {
             Message->DisplayMsg(MSG_CHK_NO_MEMORY);
             return FALSE;
        }

        if (!extend_frs.Read()) {
            DebugPrintTrace(("Previously readable FRS is no longer readable\n"));
            return FALSE;
        }

        if (!index.Initialize(_drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              extend_frs.QuerySize()/2,
                              &extend_frs,
                              &attributeName)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        index.ResetIterator();

        while (index_entry = index.GetNext(&depth, &error)) {
            if ((index_entry->FileReference.LowPart ==
                 ChkdskInfo->UsnJournalFileNumber.GetLowPart()) &&
                (index_entry->FileReference.HighPart ==
                 ChkdskInfo->UsnJournalFileNumber.GetHighPart())) {
                ChkdskInfo->UsnJournalFileNumber = 0;
                if (!index.DeleteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                } else if (!index.Save(&extend_frs) ||
                           !extend_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                        "%d%W",
                                        EXTEND_TABLE_NUMBER,
                                        index.GetName());
                    return FALSE;
                } else {
                    rst = ResetUsns(ChkdskInfo, FixLevel, Message, Mft);
                    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);
                    return rst;
                }
            }
        }
        DebugPrintTrace(("Unable to locate the USN journal index entry\n"));
        return FALSE;
    }

    //
    // now check the named $DATA, $Max attribute of Usn Journal
    //

    if (!frs.QueryAttribute(&attrib,
                            &error,
                            $DATA,
                            &attributeName)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_USNJRNL_DATA,
                            "%W", &attributeName);
        if (!attrib.Initialize(_drive,
                               QueryClusterFactor(),
                               NULL,
                               0,
                               $DATA,
                               &attributeName)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // use zeros so that ntfs will use its own default

        usnJournalMax.MaximumSize = 0;
        usnJournalMax.AllocationDelta = 0;

        if (!attrib.Write(&usnJournalMax,
                          0,
                          sizeof(usnJournalMax),
                          &bytesWritten,
                          Mft->GetVolumeBitmap()) ||
            bytesWritten != sizeof(usnJournalMax)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                "%W", &attributeName);
            return FALSE;
        }

        if (!attrib.InsertIntoFile(&frs,
                                   Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
            return FALSE;
        }

        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    } else {

        if (!attrib.RecoverAttribute(Mft->GetVolumeBitmap(),
                                     BadClusters)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                "%W", &attributeName);
            return FALSE;
        }

        // don't be strict on size of attribute value

        error = FALSE;
        if (attrib.QueryValueLength() < sizeof(usnJournalMax)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LENGTH_TOO_SMALL_FOR_FILE,
                         "%x%W%I64x%x%I64x",
                         attrib.QueryTypeCode(),
                         &attributeName,
                         attrib.QueryValueLength().GetLargeInteger(),
                         sizeof(usnJournalMax),
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        } else if (!attrib.Read(&usnJournalMax,
                                0,
                                sizeof(usnJournalMax),
                                &bytesToRead)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_USN_JRNL_ATTR,
                         "%x%W%I64x",
                         attrib.QueryTypeCode(),
                         &attributeName,
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        } else if (bytesToRead != sizeof(usnJournalMax)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_USN_JRNL_ATTR,
                         "%x%W%I64x",
                         attrib.QueryTypeCode(),
                         &attributeName,
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        }

        if (error) {

            Message->DisplayMsg(MSG_CHK_NTFS_REPAIR_USN_DATA_STREAM,
                                "%W", &attributeName);

            usnJournalMax.MaximumSize = 0;
            usnJournalMax.AllocationDelta = 0;

            if (!attrib.Write(&usnJournalMax,
                              0,
                              sizeof(usnJournalMax),
                              &bytesWritten,
                              Mft->GetVolumeBitmap()) ||
                bytesWritten != sizeof(usnJournalMax)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                    "%W", &attributeName);
                return FALSE;
            }
            if (!attrib.InsertIntoFile(&frs,
                                       Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    //
    // now check the named $DATA, $J attribute of Usn Journal
    //

    if (!attributeName.Initialize(UsnJournalNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.QueryAttribute(&attrib,
                            &error,
                            $DATA,
                            &attributeName)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_USNJRNL_DATA,
                            "%W", &attributeName);

        if (!attrib.Initialize(_drive,
                               QueryClusterFactor(),
                               NULL,
                               0,
                               $DATA,
                               &attributeName,
                               ATTRIBUTE_FLAG_SPARSE)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        //
        // Align to max cluster size (64K) boundary
        //

        total_length = LargestUsnEncountered+8;
        total_length = total_length + 0xffff;
        total_length.Set(total_length.GetLowPart() & ~0xFFFF,
                          total_length.GetHighPart());

        if (total_length.GetQuadPart() > USN_JRNL_MAX_FILE_SIZE) {
            total_length = 0;
        }

        if (!attrib.SetSparse(total_length, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (!attrib.InsertIntoFile(&frs,
                                   Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
            return FALSE;
        }

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (total_length == 0)
            rst = ResetUsns(ChkdskInfo, FixLevel, Message, Mft);
        else
            rst = TRUE;

        Message->DisplayMsg(MSG_CHK_NTFS_USNJRNL_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

        UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

        return rst;    // done

    } else {

        BIG_INT     total_user_bytes;

        total_user_bytes = attrib.QueryClustersAllocated() * QueryClusterFactor() *
                           _drive->QuerySectorSize();

        // un-account user data previously accounted for

        ChkdskReport->BytesUserData -= total_user_bytes;
        ChkdskReport->NumUserFiles -= 1;

        if (!attrib.RecoverAttribute(Mft->GetVolumeBitmap(),
                                     BadClusters)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                "%W", &attributeName);
            return FALSE;
        }

        attribute_need_write = FALSE;
        empty_usn_journal = FALSE;

        if (!(attrib.QueryFlags() & ATTRIBUTE_FLAG_SPARSE)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_SPARSE_FLAG_NOT_SET_FOR_ATTR,
                         "%x%W%I64x",
                         attrib.QueryTypeCode(),
                         &attributeName,
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());


            attrib.SetFlags(ATTRIBUTE_FLAG_SPARSE);
            attribute_need_write = TRUE;
            DebugPrintTrace(("UNTFS: The sparse flag for $J attribute is not set\n"));
        }

        total_length = attrib.QueryValueLength();

        offset = 0;
        usnJournalMaxSize = -1;

        if (!attrib.GetNextAllocationOffset(&offset, &usnJournalMaxSize)) {
            return FALSE;
        }

        if (offset > total_length) {
            DebugAbort("The offset is larger than the length of the attribute");
            return FALSE;
        }

        if (offset.GetLowPart() & (USN_PAGE_SIZE-1)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_OFFSET_NOT_AT_PAGE_BOUNDARY,
                         "%I64x%I64x",
                         offset.GetLargeInteger(),
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: USN allocation offset of 0x%I64x not at USN page boundary\n",
                             offset.GetLargeInteger()));
            //
            // Start at page boundary
            //
            offset = (offset + (USN_PAGE_SIZE-1));
            offset.Set(offset.GetLowPart() & ~(USN_PAGE_SIZE-1),
                       offset.GetHighPart());
        }

        error = FALSE;
        if ((!(total_length == 0 && LargestUsnEncountered == 0)) &&
            total_length < (LargestUsnEncountered+8)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_LENGTH_LESS_THAN_LARGEST_USN_ENCOUNTERED,
                         "%I64x%I64x%I64x%I64x",
                         total_length.GetLargeInteger(),
                         LargestUsnEncountered,
                         *((PLARGE_INTEGER)&FrsOfLargestUsnEncountered),
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: Usn journal length 0x%I64x\n"
                             "and largest Usn encountered 0x%I64x.\n",
                             total_length,
                             LargestUsnEncountered));
            DebugPrintTrace(("UNTFS: Largest Usn encountered at frs 0x%I64x\n",
                             FrsOfLargestUsnEncountered));
            error = TRUE;
        } else if (total_length.GetQuadPart() > USN_JRNL_MAX_FILE_SIZE) {

            Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_LENGTH_TOO_LARGE,
                         "%I64x%I64x%I64x",
                         total_length.GetLargeInteger(),
                         USN_JRNL_MAX_FILE_SIZE,
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        } else if (offset > total_length) {

            Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_LENGTH_LESS_THAN_OFFSET,
                         "%I64x%I64x%I64x",
                         total_length.GetLargeInteger(),
                         offset.GetLargeInteger(),
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        }

        if (error) {

            // Align to max cluster size (64K) boundary

            total_length = LargestUsnEncountered+8;
            total_length = total_length + 0xffff;
            total_length.Set(total_length.GetLowPart() & ~0xFFFF,
                             total_length.GetHighPart());

            if (total_length.GetQuadPart() > USN_JRNL_MAX_FILE_SIZE) {
                DebugPrintTrace(("UNTFS: Resetting USN journal size as it exceeded maximum.\n"));
                total_length = 0;
            }

            if (!attrib.SetSparse(total_length,
                                  Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            attribute_need_write = TRUE;
            empty_usn_journal = TRUE;

        }

        if (attribute_need_write) {

            Message->DisplayMsg(MSG_CHK_NTFS_REPAIR_USN_DATA_STREAM,
                                "%W", &attributeName);

            if (!attrib.InsertIntoFile(&frs,
                                       Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }
            if (FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (empty_usn_journal) {
                if (total_length == 0)
                    rst = ResetUsns(ChkdskInfo, FixLevel, Message, Mft);
                else
                    rst = TRUE;

                Message->DisplayMsg(MSG_CHK_NTFS_USNJRNL_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

                UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

                return rst;
            }
        }
    }

    // Read in the $DATA, $J attribute and validate.

    // allocate space for a page of usn journal records

    if ((initial_usn_entry = (PUSN_REC)MALLOC(USN_PAGE_SIZE)) == NULL) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    frs_need_flush = FALSE;
    endOfBlock = (PUSN_REC)((PCHAR)initial_usn_entry+USN_PAGE_SIZE);
    total_length = total_length - offset;
    DebugAssert(total_length.GetHighPart() == 0);
    remain_length = total_length.GetLowPart();

#if 0   // disable progress bar as it may be needed in the future
    initial_length = remain_length;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0)) {
        return FALSE;
    }
#endif

    for(; remain_length > 0;) {

#if 0   // disable progress bar as it may be needed in the future
        new_percent_done = 100*(initial_length - remain_length)/initial_length;
        if (new_percent_done != percent_done) {
            percent_done = new_percent_done;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }
#endif

        previous_usn_entry = NULL;
        attribute_need_write = FALSE;
        bytesToRead = min(USN_PAGE_SIZE, remain_length);
        usn_entry = initial_usn_entry;

        if (!attrib.Read(usn_entry,
                         offset,
                         bytesToRead,
                         &num_bytes) ||
            num_bytes != bytesToRead) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_USN_DATA_STREAM,
                                "%W", &attributeName);
            FREE(initial_usn_entry);
            return FALSE;
        }

        lastblock = remain_length <= USN_PAGE_SIZE;
        length = bytesToRead;

        while (length > 0) {
            if (usn_entry == endOfBlock) {
                break;
            }
            if (usn_entry->RecordLength == 0) {
                DebugAssert((LONG)bytesToRead >= ((PCHAR)usn_entry-(PCHAR)initial_usn_entry));
                if (lastblock) {
                    DebugAssert(bytesToRead == remain_length);
                    if (bytesToRead < USN_PAGE_SIZE) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INCOMPLETE_LAST_USN_JRNL_PAGE,
                                     "%I64x%I64x",
                                     (offset+(ULONG)(((PCHAR)usn_entry-(PCHAR)initial_usn_entry))).GetLargeInteger(),
                                     ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                        attribute_need_write = TRUE;
                    }
                    remain_block_length = USN_PAGE_SIZE -
                                          (ULONG)((PCHAR)usn_entry-(PCHAR)initial_usn_entry);
                    bytesToRead = remain_length = USN_PAGE_SIZE;
                } else {
                    remain_block_length = bytesToRead -
                                          (ULONG)((PCHAR)usn_entry-(PCHAR)initial_usn_entry);
                    DebugAssert(remain_block_length == length);
                }
                if (!RemainingBlockIsZero((PCHAR)usn_entry, remain_block_length)) {

                    location = offset + (ULONG)((PCHAR)usn_entry - (PCHAR)initial_usn_entry);

                    Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_REMAINING_OF_A_PAGE_CONTAINS_NON_ZERO,
                                 "%I64x%I64x",
                                 location.GetLargeInteger(),
                                 ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                    DebugPrintTrace(("UNTFS: USN remaining block starting at 0x%I64x non-zero\n",
                                     location.GetLargeInteger()));
                    MarkEndOfUsnBlock(usn_entry, remain_block_length);
                    attribute_need_write = TRUE;
                }
                break;
            }

            num_bytes = usn_entry->RecordLength;
            error = FALSE;

            location = offset + (ULONG)((PCHAR)usn_entry - (PCHAR)initial_usn_entry);

            if ((PCHAR)usn_entry - (PCHAR)initial_usn_entry + num_bytes > USN_PAGE_SIZE) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_CROSSES_PAGE_BOUNDARY,
                             "%I64x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry end crosses USN page boundary.\n"));

                error = TRUE;
            } else if (length < num_bytes) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_LENGTH_EXCEEDS_REMAINING_PAGE_LENGTH,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             length,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry length of %d exceeds remaining page length of %x.\n",
                                 num_bytes, length));
                error = TRUE;
            } else if (num_bytes >= USN_PAGE_SIZE) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_LENGTH_EXCEEDS_PAGE_BOUNDARY,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             USN_PAGE_SIZE,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry length of %d exceeds USN page boundary.\n", num_bytes));
                error = TRUE;
            } else if (num_bytes != QuadAlign(num_bytes)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_LENGTH_MISALIGNED,
                             "%I64x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry length of %d not quad aligned.\n", num_bytes));
                error = TRUE;
            } else if ((usn_entry->MajorVersion != 1 && usn_entry->MajorVersion != 2) ||
                       (usn_entry->MinorVersion != 0)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_USN_JRNL_ENTRY_VERSION,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             usn_entry->MajorVersion,
                             usn_entry->MinorVersion,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry version mark %d.%d not recognized.\n",
                                 usn_entry->MajorVersion,
                                 usn_entry->MinorVersion));
                error = TRUE;
            } else if (!(record_size = ((usn_entry->MajorVersion == 1) ?
                                        SIZE_OF_USN_REC_V1 : SIZE_OF_USN_REC_V2)) ||
                        (num_bytes < record_size)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_LENGTH_TOO_SMALL,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             record_size,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry length of %d less than the minimum record size of %d\n",
                                 num_bytes, record_size));
                error = TRUE;
            } else if (length < record_size) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_REMAINING_PAGE_LENGTH_TOO_SMALL,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             length,
                             record_size,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN remaining page length of %d less than the minimum record size of %d.\n",
                                 length, record_size));
                error = TRUE;
            } else if (usn_entry->MajorVersion == 1 &&
                       !(usn_entry->version.u1.Usn == location.GetQuadPart())) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_USN_JRNL_ENTRY_OFFSET,
                             "%I64x%I64x%I64x",
                             usn_entry->version.u1.Usn,
                             location.GetLargeInteger(),
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry offset 0x%I64x is invalid.\n",
                                 usn_entry->version.u1.Usn));
                error = TRUE;
            } else if (usn_entry->MajorVersion == 1 &&
                       ((ULONG)usn_entry->version.u1.FileNameLength +
                        (ULONG)FIELD_OFFSET(USN_REC, version.u1.FileName)) >
                       num_bytes) {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCONSISTENCE_USN_JRNL_ENTRY);
                Message->Log("%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             usn_entry->version.u1.FileNameLength,
                             num_bytes,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());
                Message->DumpDataToLog(usn_entry, min(num_bytes, 0x100));
                Message->Unlock();

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("Usn entry length being inconsistent.\n"));
                error = TRUE;
            } else if (usn_entry->MajorVersion == 2 &&
                       !(usn_entry->version.u2.Usn == location.GetQuadPart())) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_USN_JRNL_ENTRY_OFFSET,
                             "%I64x%I64x%I64x",
                             usn_entry->version.u2.Usn,
                             location.GetLargeInteger(),
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry offset 0x%I64x is invalid.\n",
                                 usn_entry->version.u2.Usn));
                error = TRUE;
            } else if (usn_entry->MajorVersion == 2 &&
                       ((ULONG)usn_entry->version.u2.FileNameLength +
                        (ULONG)FIELD_OFFSET(USN_REC, version.u2.FileName)) >
                       num_bytes) {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCONSISTENCE_USN_JRNL_ENTRY);
                Message->Log("%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             usn_entry->version.u2.FileNameLength,
                             num_bytes,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());
                Message->DumpDataToLog(usn_entry, min(num_bytes, 0x100));
                Message->Unlock();

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("Usn entry length being inconsistent.\n"));
                error = TRUE;
            }

            if (error) {

                if (lastblock) {
                    DebugAssert(bytesToRead == remain_length);
                    bytesToRead = remain_length = USN_PAGE_SIZE;
                }

                if ((PCHAR)usn_entry - (PCHAR)initial_usn_entry +
                    sizeof(usn_entry->RecordLength) <= USN_PAGE_SIZE) {
                    // if enough space to fit a zero
                    // RecordLength in this block
                    MarkEndOfUsnBlock(usn_entry,
                                      (ULONG)((PCHAR)endOfBlock-(PCHAR)usn_entry));
                } else if (previous_usn_entry) {
                    // not enough space to fit a zero RecordLength in this
                    // block so eat into the previous record to make space
                    // for a zero RecordLength
                    MarkEndOfUsnBlock(previous_usn_entry,
                                      (ULONG)((PCHAR)endOfBlock-(PCHAR)previous_usn_entry));
                } else  {
                    DebugAssert(FALSE);

                    // It doesn't make much sense to get here.
                    // If we don't have a previous_usn_entry then
                    // usn_entry is at the beginning of the block
                    // and should have enough space to include the
                    // EOB mark.

                    return FALSE;
                }
                attribute_need_write = TRUE;
                break;
            } else {
                if (length == num_bytes) {
                    break;
                } else {
                    length -= num_bytes;
                    previous_usn_entry = usn_entry;
                    usn_entry = (PUSN_REC)(num_bytes + (PCHAR)usn_entry);
                }
            }
        } // while
        if (attribute_need_write) {
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            if (FixLevel != CheckOnly &&
                (!attrib.Write(initial_usn_entry,
                               offset,
                               bytesToRead,
                               &bytesWritten,
                               Mft->GetVolumeBitmap()) ||
                 bytesWritten != bytesToRead)) {
                chkdskErrCouldNotFix = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                    "%W", &attributeName);
            } else
                frs_need_flush = TRUE;
        }
        offset += USN_PAGE_SIZE;
        remain_length -= bytesToRead;
    } // for
    if (frs_need_flush) {
        Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_USN_FRS);
        if (FixLevel != CheckOnly) {
            if (attrib.IsStorageModified() &&
                !attrib.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
                chkdskErrCouldNotFix = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                    "%W", &attributeName);
            }
            if (!frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", frs.QueryFileNumber());
                FREE(initial_usn_entry);
                return FALSE;
            }
        }
    }

    Message->DisplayMsg(MSG_CHK_NTFS_USNJRNL_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

    FREE(initial_usn_entry);

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}

VOID
MarkEndOfUsnBlock(
    IN OUT  PUSN_REC        UsnEntry,
    IN      ULONG           LengthOfBlock
    )
{
    // zero the length and
    // also the rest of the block

    memset(UsnEntry, 0, LengthOfBlock);
}


BOOLEAN
NTFS_SA::ResetUsns(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method sets all the USN's on the volume to zero.

Arguments:

    ChkdskInfo      --  Supplies the current chkdsk information.
    Message         --  Supplies an outlet for messages.
    Mft             --  Supplies the volume's Master File Table.
--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    ULONG                       i, n, frs_size, num_frs_per_prime;
    ULONG                       percent_done = 0;
    ULONG                       new_percent_done;
    BOOLEAN                     error;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    NTFS_ATTRIBUTE              attrib;
    PSTANDARD_INFORMATION2      standard_information2;
    ULONG                       bytesWritten;


    Message->DisplayMsg(MSG_CHK_NTFS_RESETTING_USNS);

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0)) {
        return FALSE;
    }

    // Compute the number of file records.
    //
    frs_size = Mft->QueryFrsSize();

    n = (Mft->GetDataAttribute()->QueryValueLength()/frs_size).GetLowPart();
    num_frs_per_prime = MFT_PRIME_SIZE/frs_size;

    for (i = 0; i < n; i += 1) {

        new_percent_done = i*100/n;
        if (new_percent_done != percent_done) {
            percent_done = new_percent_done;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i % num_frs_per_prime == 0) {
            Mft->GetDataAttribute()->PrimeCache(i*frs_size,
                                                num_frs_per_prime*frs_size);
        }

        if (!frs.Initialize(i, Mft)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // If the FRS is unreadable or is not in use, skip it.
        //
        if (!frs.Read() || !frs.IsInUse() || !frs.IsBase()) {

            continue;
        }

        if (!frs.QueryAttribute(&attrib,
                                &error,
                                $STANDARD_INFORMATION)) {
            if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            } else {
                DebugPrint("Standard Information Missing\n");
            }
            return FALSE;
        }

        if (attrib.QueryValueLength() == sizeof(STANDARD_INFORMATION2)) {
            standard_information2 = (PSTANDARD_INFORMATION2)attrib.GetResidentValue();
            if (standard_information2->Usn == 0) {
                continue;
            }
            standard_information2->Usn.LowPart = 0;
            standard_information2->Usn.HighPart = 0;
            if (!attrib.Write((PVOID)standard_information2,
                              0,
                              sizeof(STANDARD_INFORMATION2),
                              &bytesWritten,
                              Mft->GetVolumeBitmap()) ||
                bytesWritten != sizeof(STANDARD_INFORMATION2)) {
                chkdskErrCouldNotFix = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                    "%d%d", attrib.QueryTypeCode(), i);
                continue;
            }
            if (attrib.IsStorageModified() &&
                !attrib.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
                chkdskErrCouldNotFix = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                    "%d%d", attrib.QueryTypeCode(), i);
                continue;
            }
            if (FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", frs.QueryFileNumber());
                return FALSE;
            }
        }

    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ureg\src\regvalue.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    value.cxx

Abstract:

    This module contains the methods for the REGISTRY_VALUE_ENTRY class.

Author:

    Jaime Sasson (jaimes) 26-Aug-1991

Environment:

    Ulib, Regedit, Windows, User Mode

--*/

#include "regvalue.hxx"


DEFINE_CONSTRUCTOR( REGISTRY_VALUE_ENTRY, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( REGISTRY_VALUE_ENTRY );



REGISTRY_VALUE_ENTRY::~REGISTRY_VALUE_ENTRY(

)
/*++

Routine Description:

    Destroy a REGISTRY_VALUE_ENTRY object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
REGISTRY_VALUE_ENTRY::Construct (
    )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _TitleIndex = 0;
    _Type = TYPE_UNKNOWN;
    _Size = 0;
    _Data = NULL;
}


VOID
REGISTRY_VALUE_ENTRY::Destroy(
    )
/*++

Routine Description:

    Worker method for object destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE( _Data );
    _Data = NULL;
    _TitleIndex = 0;
    _Type = TYPE_UNKNOWN;
    _Size = 0;
}


BOOLEAN
REGISTRY_VALUE_ENTRY::Initialize(
    )

/*++

Routine Description:

    Initialize or re-initialize a REGISTRY_VALUE_ENTRY object.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns always TRUE


--*/


{
    Destroy();
    return( TRUE );
}


BOOLEAN
REGISTRY_VALUE_ENTRY::Initialize(
    IN PCWSTRING ValueName,
    IN ULONG            TitleIndex,
    IN REG_TYPE         Type,
    IN PCBYTE           Data,
    IN ULONG            Size
    )

/*++

Routine Description:

    Initialize or re-initialize a REGISTRY_VALUE_ENTRY object.

Arguments:


    ValueName - Pointer to a WSTRING that contains the value name.

    TitleIndex - The title index associated with the value name.

    Type - The type of value stored in this object.

    Data - Buffer that contains the value to be stored.

    Size - Number of bytes in the buffer.



Return Value:

    BOOLEAN - Returns always TRUE


--*/


{
    DebugPtrAssert( ValueName );
    DebugAssert( ( Size == 0 ) || ( Data != NULL ) );

    Destroy();
    if( !_Name.Initialize( ValueName ) ) {
        return( FALSE );
    }
    _TitleIndex = TitleIndex;
    _Type = Type;
    if( Size == 0 ) {
        _Data = NULL;
        _Size = 0;
    } else {
        return PutData( Data, Size );
    }
    return( TRUE );
}



BOOLEAN
REGISTRY_VALUE_ENTRY::PutData(
    IN PCBYTE   Data,
    IN ULONG    Size
    )

/*++

Routine Description:

    Set the data stored in this object.


Arguments:

    Data - Pointer to the buffer that contains the data.

    Size - Number of valid bytes in the buffer (data size).


Return Value:

    None.


--*/


{
    DebugAssert( ( Size == 0 ) || ( Data != NULL ) );

    if( _Data != NULL ) {
        FREE( _Data );
    }
    if( Size == 0 ) {
        _Data = NULL;
        _Size = 0;
    } else {
        _Data = ( PBYTE )MALLOC( ( size_t )( Size + 2 ) );
        if (_Data == NULL) {
            DebugPtrAssert( _Data );
            DebugPrint("UREG: Out of memory\n");
            return FALSE;
        }
        _Size = Size;
        memcpy( _Data, Data, ( size_t )Size );
        *( _Data + Size ) = '\0';
        *( _Data + Size + 1 ) = '\0';
    }

    return TRUE;
}




#if DBG

VOID
REGISTRY_VALUE_ENTRY::DbgPrintValueEntry(
    )

/*++

Routine Description:

    Display the contents of a value entry object

Arguments:

    None.

Return Value:

    None.


--*/


{
    PSTR    Pointer;

    DebugPrintTrace(( "======== Dumping a REGISTRY_VALUE_ENTRY object ==== \n\n" ));
    Pointer = _Name.QuerySTR();
    DebugPrintTrace(( "    _Name = %s \n", Pointer ));
    FREE( Pointer );

    DebugPrintTrace(( "    _TitleIndex = %d \n", _TitleIndex ));

    switch( _Type ) {

        case TYPE_REG_NONE:
            DebugPrintTrace(( "    _Type = TYPE_REG_NONE \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));
            break;

        case TYPE_REG_SZ:
            DebugPrintTrace(( "    _Type = TYPE_REG_SZ \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));
            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    _Data = %s \n", _Data ));
            }
            break;

        case TYPE_REG_BINARY:
            DebugPrintTrace(( "    _Type = TYPE_REG_BINARY \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));

            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    Don't know how to print binary data \n" ));
            }
            break;

        case TYPE_REG_DWORD:
            DebugPrintTrace(( "    _Type = TYPE_REG_DWORD \n" ));
            if( _Size == sizeof( DWORD ) ) {
                DebugPrintTrace(( "    _Data = %08x \n", *( ( LPDWORD ) _Data ) ));
            } else {
                DebugPrintTrace(( "    ERROR: Data has incorrect size, Size = %d \n", _Size ));
            }
            break;

        case TYPE_REG_RESOURCE_LIST:
            DebugPrintTrace(( "    _Type = TYPE_REG_RESOURCE_LIST \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));

            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    Don't know how to print resource list \n" ));
            }
            break;

        case TYPE_REG_FULL_RESOURCE_DESCRIPTOR:
            DebugPrintTrace(( "    _Type = TYPE_REG_FULL_RESOURCE_DESCRIPTOR \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));

            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    Don't know how to print a full resource descriptor \n" ));
            }
            break;

        case TYPE_REG_RESOURCE_REQUIREMENTS_LIST:
            DebugPrintTrace(( "    _Type = TYPE_REG_RESOURCE_REQUIREMENTS_LIST \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));

            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    Don't know how to print a requirements list \n" ));
            }
            break;

        case TYPE_UNKNOWN:
        default:
            DebugPrintTrace(( "    _Type = UNKNOWN \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));
            break;
    }

}

#endif   // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ureg\src\regkey.cxx ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    regkey.cxx

Abstract:

    This module contains the member function definitions for REGISTRY_KEY_INFO
    class.
    REGISTRY_KEY_INFO is class that contains all the information of a
    registry key, such as:

        -Key Name
        -Title Index
        -Class
        -Security Attributes
        -Last Write Time
        -Number of Sub-keys
        -Number of Value Entries

    A REGISTRY_KEY_INFO object is reinitializable.

Author:

    Jaime Sasson (jaimes) 01-Mar-1992


Environment:

    Ulib, User Mode


--*/


#include "regkey.hxx"


DEFINE_CONSTRUCTOR( REGISTRY_KEY_INFO, OBJECT );



REGISTRY_KEY_INFO::~REGISTRY_KEY_INFO(

)
/*++

Routine Description:

    Destroy a REGISTRY_KEY_INFO object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}



VOID
REGISTRY_KEY_INFO::Construct (
    )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _TitleIndex = 0;
    _NumberOfSubKeys = 0;
    _NumberOfValues = 0;

#if !defined( _AUTOCHECK_ )
    _SecurityAttributes.nLength = 0;
    _SecurityAttributes.lpSecurityDescriptor = NULL;
    _SecurityAttributes.bInheritHandle = FALSE;
#endif
}



VOID
REGISTRY_KEY_INFO::Destroy(
    )
/*++

Routine Description:

    Worker method for object destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _NumberOfSubKeys = 0;
    _NumberOfValues = 0;
    _TitleIndex = 0;
    _KeyIsCompletelyInitialized = FALSE;

#if !defined( _AUTOCHECK_ )
    FREE( _SecurityAttributes.lpSecurityDescriptor );
    _SecurityAttributes.nLength = 0;
    _SecurityAttributes.lpSecurityDescriptor = NULL;
    _SecurityAttributes.bInheritHandle = FALSE;
#endif
}



BOOLEAN
REGISTRY_KEY_INFO::Initialize(
    )
/*++

Routine Description:

    Initialize or re-initialize a REGISTRY_KEY_INFO object.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns always TRUE.

--*/

{
    Destroy();
    if( !_ParentName.Initialize( "" ) ) {
        DebugPrint( "_ParentName.Initialize() failed" );
        return( FALSE );
    }
    if( !_Name.Initialize( "" ) ) {
        DebugPrint( "_Name.Initialize() failed" );
        return( FALSE );
    }
    return( TRUE );
}



BOOLEAN
REGISTRY_KEY_INFO::Initialize(
    IN PCWSTRING     KeyName,
    IN PCWSTRING     ParentName,
    IN ULONG                TitleIndex,
    IN PCWSTRING     Class,
    IN PSECURITY_ATTRIBUTES SecurityAttributes
    )

/*++

Routine Description:

    Initialize or re-initialize a REGISTRY_KEY_INFO object.

Arguments:

    KeyName - Pointer to a WSTRING object that contains the key name.

    ParentName - Pointer to a WSTRING object that contains the parent's
                 name.

    TitleIndex - The title index associated to the key.

    Class - Pointer to a WSTRING object that contains the key class.

    SecurityAttributes - Pointer to an initialized security attribute object.


Return Value:

    BOOLEAN - Returns TRUE if the operation succeeds.

--*/

{
    //
    //  Check for NULL pointers
    //
    DebugPtrAssert( Class );
//    DebugPtrAssert( SecurityAttributes );
    DebugAssert( !( ( ParentName != NULL ) && ( KeyName == NULL ) ) ||
               !( ( ParentName != NULL ) && ( ParentName->QueryChCount() != 0 ) &&
                  ( KeyName != NULL ) && ( KeyName->QueryChCount() == 0 ) ) );



    Destroy();


    if( ( ( KeyName == NULL ) && ( ParentName == NULL ) ) ||
        ( ( KeyName != NULL ) && ( KeyName->QueryChCount() == 0 ) &&
          ( ParentName != NULL ) && ( ParentName->QueryChCount() == 0 ) ) ) {
        //
        // This REGISTRY_KEY_INFO represents a predefined key.
        //
        if( !_ParentName.Initialize( "" ) ) {
            DebugPrint( "_ParentName.Initialize() failed" );
            return( FALSE );
        }
        if( !_Name.Initialize( "" ) ) {
            DebugPrint( "_Name.Initialize() failed" );
            return( FALSE );
        }

    } else {
        //
        //  This REGISTRY_KEY_INFO does not represent a predefined key,
        //  so it has a name.
        //  Make sure that the name is relative to its parent
        //
        if( KeyName->Strrchr( ( WCHAR )'\\' ) != INVALID_CHNUM ) {
            DebugPrint( "KeyName is not a valid one" );
        }

        //
        // Initialize _ParentName
        //
        if( ( ParentName == NULL ) || ( ParentName->QueryChCount() == 0 ) ) {
            //
            //  This REGISTRY_KEY_INFO represents the subkey of a
            //  predefined key
            //
            if( !_ParentName.Initialize( "" ) ) {
                DebugPrint( "_ParentName.Initialize() failed" );
                return( FALSE );
            }
        } else {
            if( !_ParentName.Initialize( ParentName ) ) {
                DebugPrint( "_ParentName.Initialize( ParentName )" );
                return( FALSE );
            }
        }

        //
        // Initialize _Name
        //
        if( !_Name.Initialize( KeyName ) ) {
            DebugPrint( "_Name.Initialize( KeyName )" );
            return( FALSE );
        }
    }


    _TitleIndex = TitleIndex;

    if( !_Class.Initialize( Class ) ) {
        DebugPrint( "_Class.Initialize( Class )" );
        return( FALSE );
    }

#if !defined( _AUTOCHECK_ )
    if (!PutSecurityAttributes( SecurityAttributes )) {
        DebugPrint( "PutSecurityAttributes( SecurityAttributes )");
        return( FALSE );
    }
#endif
    _KeyIsCompletelyInitialized = FALSE;
    return( TRUE );
}

#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY_KEY_INFO::PutSecurityAttributes(
    IN PSECURITY_ATTRIBUTES    SecurityAttributes
    )

/*++

Routine Description:

    Initialize the variable _SecurityAttributes.


Arguments:

    SecurityAttributes - Pointer to the security attribute


Return Value:

    None.


--*/

{
    ULONG   Length;
    PBYTE   Pointer;


    if( SecurityAttributes != NULL ) {

        Length = GetSecurityDescriptorLength( SecurityAttributes->lpSecurityDescriptor );

        FREE( _SecurityAttributes.lpSecurityDescriptor );

        Pointer = ( PBYTE )MALLOC( ( size_t )Length );
        if (Pointer == NULL) {
            DebugPtrAssert( Pointer );
            return FALSE;
        }
        memcpy( Pointer, SecurityAttributes->lpSecurityDescriptor, ( size_t )Length );

       _SecurityAttributes.nLength = SecurityAttributes->nLength;
       _SecurityAttributes.lpSecurityDescriptor = Pointer;
       _SecurityAttributes.bInheritHandle = SecurityAttributes->bInheritHandle;
    } else {
        Pointer = ( PBYTE )MALLOC( ( size_t )SECURITY_DESCRIPTOR_MIN_LENGTH );
        if (Pointer == NULL) {
            DebugPtrAssert( Pointer );
            return FALSE;
        }
        InitializeSecurityDescriptor( Pointer, 1 );
        _SecurityAttributes.nLength = sizeof( SECURITY_ATTRIBUTES );
        _SecurityAttributes.lpSecurityDescriptor = Pointer;
        _SecurityAttributes.bInheritHandle = FALSE;
    }
    return TRUE;
}
#endif


#if DBG

VOID
REGISTRY_KEY_INFO::DbgPrintKeyInfo(
    )

/*++

Routine Description:

    Print the contents of a REGISTRY_INFO_KEY.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSTR    Pointer;
    PSTR    StrDate;
    PSTR    StrTime;

    DSTRING Date;
    DSTRING Time;

    DebugPrintTrace(( "====Dumping a REGISTRY_KEY_INFO object ====\n \n" ));
    Pointer = _ParentName.QuerySTR();
    DebugPtrAssert( Pointer );
    DebugPrintTrace(( "    ParentName = %s \n", Pointer ));
    FREE( Pointer );

    Pointer = _Name.QuerySTR();
    DebugPtrAssert( Pointer );
    DebugPrintTrace(( "    Name = %s \n", Pointer ));
    FREE( Pointer );

    Pointer = _Class.QuerySTR();
    DebugPtrAssert( Pointer );
    DebugPrintTrace(( "    Class = %s \n", Pointer ));
    FREE( Pointer );

    DebugPrintTrace(( "    Title Index = %d \n", _TitleIndex ));

    if( !_LastWriteTime.QueryDate( &Date ) ||
        !_LastWriteTime.QueryTime( &Time ) ) {
        DebugPrint( "Can't get date or time" );
    } else {
        StrDate = Date.QuerySTR();
        DebugPtrAssert( StrDate );
        StrTime = Time.QuerySTR();
        DebugPtrAssert( StrTime );
        DebugPrintTrace(( "    LastWriteTime = %s  %s \n", StrDate, StrTime ));
        FREE( StrDate );
        FREE( StrTime );
    }

    DebugPrintTrace(( "    SecurityAttributes.nLength = %d \n", _SecurityAttributes.nLength ));
    DebugPrintTrace(( "    SecurityAttributes.lpSecurityDescriptor = %08x \n",
               _SecurityAttributes.lpSecurityDescriptor ));

    if( _SecurityAttributes.bInheritHandle ) {
        DebugPrintTrace(( "    SecurityAttributes.bInheritHandle = TRUE \n" ));
    } else {
        DebugPrintTrace(( "    SecurityAttributes.bInheritHandle = FALSE \n" ));
    }

    DebugPrintTrace(( "    NumberOfSubKeys = %d \n", _NumberOfSubKeys ));
    DebugPrintTrace(( "    NumberOfValues = %d \n", _NumberOfValues ));
    DebugPrintTrace(( "\n\n" ));
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ureg\src\ureg.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        ureg.cxx

Abstract:

        This module contains run-time, global support for the
        Registry Utilities library (UREG).       This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        JAIME SASSON (JAIMES) 02-Dez-1992

Environment:

        User Mode

Notes:

--*/

#include "ulib.hxx"

//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors (
        );

STATIC
BOOLEAN
UndefineClassDescriptors (
        );

extern "C" BOOLEAN
InitializeUreg (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

BOOLEAN
InitializeUreg (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Ureg by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "UREG initialization failed!!!\n" );
                return FALSE;
            }

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
                return TRUE;
            }

            if (count == 1) {
                UndefineClassDescriptors();

                count--;
            } else {
                DebugPrint("UREG detached more than attached\n");
            }
            break;
    }

    return TRUE;
}



DECLARE_CLASS(  REGISTRY_VALUE_ENTRY  );
DECLARE_CLASS(  REGISTRY_KEY_INFO     );
DECLARE_CLASS(  REGISTRY              );


STATIC
BOOLEAN
DefineClassDescriptors(
        )
/*++

Routine Description:

    Defines all the class descriptors used by UREG

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              constructed and initialized.

--*/
{
    if( DEFINE_CLASS_DESCRIPTOR( REGISTRY_VALUE_ENTRY ) &&
        DEFINE_CLASS_DESCRIPTOR( REGISTRY_KEY_INFO    ) &&
        DEFINE_CLASS_DESCRIPTOR( REGISTRY             )
    ) {

            return TRUE;

    } else {

            DebugPrint( "UREG: Could not initialize class descriptors!");
            return FALSE;
    }
}


STATIC
BOOLEAN
UndefineClassDescriptors (
    )

/*++

Routine Description:

    Undefines all the class descriptors used by UREG.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              undefined.

--*/

{
    UNDEFINE_CLASS_DESCRIPTOR( REGISTRY_VALUE_ENTRY );
    UNDEFINE_CLASS_DESCRIPTOR( REGISTRY_KEY_INFO    );
    UNDEFINE_CLASS_DESCRIPTOR( REGISTRY             );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\ureg\src\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ureg
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib    \
           $(SDK_LIB_PATH)\advapi32.lib    \
           ..\..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib

DLLENTRY=InitializeUreg

USE_MSVCRT=1

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\regvalue.cxx \
        ..\regkey.cxx   \
        ..\registry.cxx \
        ..\ureg.cxx     \
        ..\ureg.rc


INCLUDES=..\..\inc;..\..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

UMLIBS=$(O)\ureg.lib

UMTYPE=console

UMRES=$(O)\ureg.res
DLLDEF=$(O)\ureg.def
NTTARGETFILES=

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\checkfilestruct.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    CheckFileStruct.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"
#include "ScanFIDs.hxx"

#include "crc.hxx"
#include "unicode.hxx"

BOOL
UDF_LVOL::CheckFileStructure()
{
    BOOL Result = FALSE;

    USHORT      TagIdentifier = DESTAG_ID_NOTSPEC;

    UINT        TotalFiles = 0;
    UINT        TotalDirs = 0;
    ULONGLONG   RootICBBlockOffset = 0;
    UINT        RootICBBlockSize =  0;

    DSTRING FileSetID;
    UncompressDString( (LPBYTE) _FileSetDescriptor->FileSetID, sizeof( _FileSetDescriptor->FileSetID ), &FileSetID );

    _Message->Set( MSG_UDF_FILE_SYSTEM_INFO );
    _Message->Display( "%W", &FileSetID );

    if (ReadIcbDirectEntry( &_FileSetDescriptor->IcbRoot, &TagIdentifier, &_RootIcbFileEntry, &RootICBBlockOffset, &RootICBBlockSize, 0 )) {

        //  Mark the ICB of the Root directory as used.
        //

        Result = MarkBlocksUsed( RootICBBlockOffset, RootICBBlockSize );

        if (ExpandDirectoryHierarchy( _RootIcbFileEntry, FALSE, &TotalFiles, &TotalDirs, 0 )) {

            DebugPrintTrace(( "ExpandDirectoryHierarchy() results:\n" ));
            DebugPrintTrace(( "\tTotalFiles: %d\n", TotalFiles ));
            DebugPrintTrace(( "\tTotalDirs:  %d\n", TotalDirs ));

        }

    }

    USHORT UdfVersion = ((PUDF_SUFFIX_UDF) &_LogicalVolumeDescriptor->DomainID.Suffix)->UdfRevision;
    if (UdfVersion >= UDF_VERSION_200) {

        UINT        TotalStreamFiles = 0;
        UINT        TotalStreamDirs = 0;
        PICBFILE    RootStreamIcbFileEntry = NULL;
        ULONGLONG   RootStreamICBBlockOffset = 0;
        UINT        RootStreamICBBlockSize =  0;

        if (ReadIcbDirectEntry( &_FileSetDescriptor->StreamDirectoryIcb, &TagIdentifier,
            &RootStreamIcbFileEntry, &RootStreamICBBlockOffset, &RootStreamICBBlockSize, 0 )) {

            //  Mark the ICB of the Root directory as used.
            //

            Result = MarkBlocksUsed( RootStreamICBBlockOffset, RootStreamICBBlockSize );

            if (ExpandDirectoryHierarchy( RootStreamIcbFileEntry, FALSE, &TotalStreamFiles, &TotalStreamDirs, 0 )) {

                DebugPrintTrace(( "ExpandDirectoryHierarchy() results:\n" ));
                DebugPrintTrace(( "Total Stream Files: %d\n", TotalStreamFiles ));
                DebugPrintTrace(( "Total Stream Dirs:  %d\n", TotalStreamDirs ));

            }

        } else {

            _Message->DisplayMsg( MSG_UDF_INVALID_SYSTEM_STREAM );

        }

    }

    if (!VerifySBDAllocation( _SpaceBitmapDescriptor, _NewSpaceBitmapDescriptor )) {

        return FALSE;

    }

    return TRUE;
}

BOOL
UDF_LVOL::ReadIcbDirectEntry
(
    LONGAD*         pIcb,
    USHORT*         pTagIdentifier,
    PICBFILE*       NewIcbFile,
    OUT PULONGLONG  BlockNum,
    OUT PUINT       BlockSize,
    UINT            readIcbDirectRecursionCount
)
{
    BOOL Result = FALSE;

    *pTagIdentifier = DESTAG_ID_NOTSPEC;

    LPBYTE IcbFileBuffer = (LPBYTE) malloc( pIcb->Length.Length );
    if (IcbFileBuffer != NULL) {

        Result = Read( pIcb->Start.Lbn, 1, IcbFileBuffer );
        if (!Result) {

            DebugPrintTrace(( "ReadIcbDirectEntry error: Error reading physical block %u\n",
                pIcb->Start.Lbn ));

        } else {

            /* Node context in node and mc must be set for context verification.
             * In case of an error, at least the descriptor tag will be swapped !!
             */
            Result = VerifyDescriptor( IcbFileBuffer, QuerySectorSize(), DESTAG_ID_NOTSPEC, pTagIdentifier );
            if (!Result) {

                DebugPrintTrace(( "ICB Direct Entry error\n" ));

            } else {
            
                if ((*pTagIdentifier) != DESTAG_ID_NSR_FILE && (*pTagIdentifier) != DESTAG_ID_NSR_EXT_FILE) {

                    DebugPrintTrace(( "Unexpected descriptor: %x\n", *pTagIdentifier ));

                } else {

                    if (((PICBFILE) IcbFileBuffer)->Icbtag.StratType != 4) {
        
                        DebugPrintTrace((  "Error: Illegal ICB Strategy Type: %u\n",
                            ((PICBFILE) IcbFileBuffer)->Icbtag.StratType ));


                    } else {

                        Result = TRUE;

                    }

                }

            }

        }
    }

    if (!Result) {

        free( IcbFileBuffer );

    } else {

        *NewIcbFile = (PICBFILE) IcbFileBuffer;
        *BlockNum = pIcb->Start.Lbn;
        *BlockSize = 1;

    }

    return Result;
}

BOOL
UDF_LVOL::ExpandFID
(
    PNSR_FID    NsrFid,
    BOOL        isStreamDir,
    PUINT       TotalFiles,
    PUINT       TotalDirs,
    UINT        ExpandDirRecursionCount
)
{
    BOOL Result = TRUE;

    ULONG FidSize = ISONsrFidSize( NsrFid );

#if DEBUG_DUMP_FIDS
    WCHAR FileAttributes[ 6 ];
    FileAttributes[ 0 ] = (NsrFid->Flags & NSR_FID_F_HIDDEN)    ? L'h' : L'.';
    FileAttributes[ 1 ] = (NsrFid->Flags & NSR_FID_F_DIRECTORY) ? L'd' : L'.';
    FileAttributes[ 2 ] = (NsrFid->Flags & NSR_FID_F_DELETED)   ? L'x' : L'.';
    FileAttributes[ 3 ] = (NsrFid->Flags & NSR_FID_F_PARENT)    ? L'p' : L'.';
    FileAttributes[ 4 ] = (NsrFid->Flags & NSR_FID_F_META)      ? L'm' : L'.';
    FileAttributes[ 5 ] = L'\0';

    DSTRING FileID;
    Result = UncompressUnicode( NsrFid->FileIDLen, LPBYTE( NsrFid ) + ISONsrFidConstantSize + NsrFid->ImpUseLen, &FileID );
    if (Result) {
        DebugPrintTrace(( "%S %S\n", FileAttributes, FileID.GetWSTR() ));
    }
#endif DEBUG_DUMP_FIDS

    if (NsrFid->Flags & NSR_FID_F_DIRECTORY) {

        if ((NsrFid->Flags & NSR_FID_F_PARENT) == 0) {

            PICBFILE    SubDirectoryICBEntry = NULL;
            ULONGLONG   ICBBlockOffset = 0;
            UINT        ICBBlockSize =  0;
            USHORT      TagIdentifier;

            Result = ReadIcbDirectEntry( &NsrFid->Icb, &TagIdentifier, &SubDirectoryICBEntry, &ICBBlockOffset, &ICBBlockSize, 0 );
            if (Result) {

                Result = MarkBlocksUsed( ICBBlockOffset, ICBBlockSize );

                *TotalDirs += 1;

                Result = ExpandDirectoryHierarchy( SubDirectoryICBEntry, FALSE, TotalFiles, TotalDirs, ExpandDirRecursionCount );

                free( SubDirectoryICBEntry );

            }

        }

    } else {

        PICBFILE    SubDirectoryICBEntry = NULL;
        ULONGLONG   ICBBlockOffset = 0;
        UINT        ICBBlockSize =  0;
        USHORT      TagIdentifier;

        Result = ReadIcbDirectEntry( &NsrFid->Icb, &TagIdentifier, &SubDirectoryICBEntry, &ICBBlockOffset, &ICBBlockSize, 0 );
        if (Result) {

            ULONGLONG                   ComputedFileSize = 0;
            SCAN_ALLOCTION_DESCRIPTORS  ReadInfo;

            Result = MarkBlocksUsed( ICBBlockOffset, ICBBlockSize );

            if ((SubDirectoryICBEntry->Icbtag.Flags & ICBTAG_F_ALLOC_MASK) == ICBTAG_F_ALLOC_IMMEDIATE) {

                ComputedFileSize = SubDirectoryICBEntry->InfoLength;

            } else {

                Result = ReadInfo.Initialize( this, SubDirectoryICBEntry );
                if (Result) {

                    ULONG   StartBlockNum;
                    ULONG   Length;
                    SHORT   Type;

                    while (ReadInfo.Next(&StartBlockNum, &Length, &Type)) {

                        if (Length == 0) {

                            //  UNDONE, CBiks, 8/3/2000
                            //      UDF 2.01/2.3.11 says that the unused bytes after the last AD should be zero.  Maybe
                            //      we should verify this.

                            break;

                        } else {

                            //  UNDONE, CBiks, 8/3/2000
                            //      What do we do when the AD contains a bad start or length?

                            if (Type == NSRLENGTH_TYPE_RECORDED) {

                                //  Mark the sectors as used and add the size to the computed file size.
                                //

                                ComputedFileSize += Length;

                                Result = MarkBlocksUsed( StartBlockNum, RoundUp( Length, QuerySectorSize() ) );

                            } else if (Type == NSRLENGTH_TYPE_UNRECORDED) {

                                //  Mark the sectors as used, but don't add the unrecorded size to the file size.
                                //

                                Result = MarkBlocksUsed( StartBlockNum, RoundUp( Length, QuerySectorSize() ) );

                            } else {

                                DebugPrintTrace(( "Unsupported NSRLENGTH.Type: %x\n",
                                    Type ));
                                ASSERT( 0 );

                            }

                        }

                    }

                }

            }

            //  UNDONE, CBiks, 8/3/2000
            //      What do we do when the computed size does not match the size in the ICB?
            //

            ASSERT( ComputedFileSize == SubDirectoryICBEntry->InfoLength );

        }

        *TotalFiles += 1;

    }

    return Result;
}

BOOL
UDF_LVOL::ExpandDirectoryHierarchy
(
    PICBFILE    FileIcbEntry,
    BOOL        isStreamDir,
    PUINT       TotalFiles,
    PUINT       TotalDirs,
    UINT        ExpandDirRecursionCount
)
{
    BOOL    result = TRUE;

    ULONG   CalculatedInfoLength = 0;

    UCHAR   feAdType = FileIcbEntry->Icbtag.Flags & ICBTAG_F_ALLOC_MASK;

    if (feAdType == ICBTAG_F_ALLOC_IMMEDIATE) {

        LPBYTE  AllocationDescriptors = (LPBYTE)( FileIcbEntry ) + FeEasFieldOffset( FileIcbEntry ) + FeEaLength( FileIcbEntry );
        ULONG   AllocationDescriptorLength = FeAllocLength( FileIcbEntry );
        ULONG   AllocDescOffset = 0;

        while (result && (AllocDescOffset < AllocationDescriptorLength)) {

            PNSR_FID NsrFid = (PNSR_FID)( FeEas( FileIcbEntry ) + FeEaLength( FileIcbEntry ) + AllocDescOffset );

            result = VerifyDescriptor( (LPBYTE) NsrFid, FeAllocLength( FileIcbEntry ) - AllocDescOffset, DESTAG_ID_NSR_FID, NULL );
            if (result) {

                result = ExpandFID( NsrFid, isStreamDir, TotalFiles, TotalDirs, ExpandDirRecursionCount );

                AllocDescOffset += ISONsrFidSize( NsrFid );

            }

        }

    } else if (feAdType == ICBTAG_F_ALLOC_SHORT) {

        SCAN_FIDS ReadInfo;

        result = ReadInfo.Initialize( this, FileIcbEntry );
        if (result) {

            PNSR_FID NsrFid = NULL;
            while (ReadInfo.Next( &NsrFid )) {

                result = ExpandFID( NsrFid, isStreamDir, TotalFiles, TotalDirs, ExpandDirRecursionCount );

            }

        }

    } else {

        DebugPrintTrace(( "Unsupported ICB Allocation Type: %x\n",
            feAdType ));
        ASSERT( 0 );
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\crc.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    crc.cxx

Author:

    Centis Biks (cbiks) 12-Jun-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

static USHORT crc_table[256] = {
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
    0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
    0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
    0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
    0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
    0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
    0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
    0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
    0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
    0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
    0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
    0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
    0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
    0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
    0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
    0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
    0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
    0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
    0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
    0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
    0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
    0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
    0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
    0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
    0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};

USHORT
CalculateCrc
(
    LPBYTE      p,
    ULONGLONG   size
)
{
    USHORT CRC = 0;

    while ( size-- > 0 ) {

        CRC = (USHORT)( crc_table[(CRC >> 8 ^ *p++) & 0xff] ^ (CRC << 8) );

    }

    return CRC;
}

UCHAR
CalculateTagChecksum
(
    DESTAG* gt
)
{
    LPBYTE  b;
    UCHAR   sum = 0;
    UCHAR   counter;

    b = (LPBYTE) gt;
    for(counter = 0; counter <= 3; counter++)
        sum = (UCHAR) ((sum + b[counter]) % 256);
    for(counter = 5; counter <= 15; counter++)
        sum = (UCHAR) ((sum + b[counter]) % 256);
    return sum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\entry.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    entry.cxx

Abstract:

    This module contains the entry points for UUDF.DLL.  These
    include:

        Chkdsk
        ChkdskEx
        Format
        FormatEx
        Recover

Author:

    Centis Biks (cbiks) 05-05-2000

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include "ulib.hxx"
#include "error.hxx"
#include "path.hxx"
#include "ifssys.hxx"
#include "rcache.hxx"
#include "ifsserv.hxx"

extern "C" {
    #include "nturtl.h"
    #include "udf.h"
}

#include "message.hxx"
#include "rtmsg.h"


BOOLEAN
FAR APIENTRY
Chkdsk(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Fix,
    IN      BOOLEAN     Verbose,
    IN      BOOLEAN     OnlyIfDirty,
    IN      BOOLEAN     Recover,
    IN      PPATH       PathToCheck,
    IN      BOOLEAN     Extend,
    IN      BOOLEAN     ResizeLogFile,
    IN      ULONG       DesiredLogFileSize,
    OUT     PULONG      ExitStatus
    )
/*++

Routine Description:

    Check an Universal Data Format (UDF) volume.

Arguments:

    NtDrivName          supplies the name of the drive to check
    Message             supplies an outlet for messages
    Fix                 TRUE if Chkdsk should fix errors
    Verbose             TRUE if Chkdsk should list every file it finds
    OnlyIfDirty         TRUE if the drive should be checked only if
                            it is dirty
    Recover             TRUE if the drive is to be completely checked
                            for bad sectors.
    PathToCheck         supplies a path to files Chkdsk should check
                            for contiguity
    Extend              Unused (should always be FALSE)
    ResizeLogfile       Unused (should always be FALSE)
    DesiredLogfileSize  Unused (should always be 0)
    ExitStatus          Returns information about whether the chkdsk failed


Return Value:

    TRUE if successful.

--*/
{
    UDF_VOL         UDFVol;
    BOOLEAN         RecoverFree, RecoverAlloc;
    DWORD           oldErrorMode;
    ULONG           flags;

    //  Only NTFS implements extend, so we can just error out if we see it.
    //
    if (Extend || ResizeLogFile || (DesiredLogFileSize != 0)) {

        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;

    }

    RecoverFree = RecoverAlloc = Recover;

   
    // disable popups while we initialize the volume
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    if (!UDFVol.Initialize(NtDriveName, Message)) {
        SetErrorMode ( oldErrorMode );
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    // Re-enable hardware popups
    SetErrorMode ( oldErrorMode );

    flags = (Verbose ? CHKDSK_VERBOSE : 0);
    flags |= (OnlyIfDirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    flags |= (RecoverFree ? CHKDSK_RECOVER_FREE_SPACE : 0);
    flags |= (RecoverAlloc ? CHKDSK_RECOVER_ALLOC_SPACE : 0);

    if (Fix) {
        
        if (!UDFVol.Lock()) {

            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;

        }

    }

    return UDFVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                           Message,
                           flags,
                           0,
                           0,
                           ExitStatus );
}


BOOLEAN
FAR APIENTRY
ChkdskEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Fix,
    IN      PCHKDSKEX_FN_PARAM  Param,
    OUT     PULONG              ExitStatus
    )
/*++

Routine Description:

    Check an NTFS volume.

Arguments:

    NtDrivName          supplies the name of the drive to check
    Message             supplies an outlet for messages
    Fix                 TRUE if Chkdsk should fix errors
    Param               supplies the chkdsk parameter block
    ExitStatus          Returns information about whether the chkdsk failed


Return Value:

    TRUE if successful.

--*/
{
    UDF_VOL         UDFVol;
    BOOLEAN         RecoverFree, RecoverAlloc;
    DWORD           oldErrorMode;

    //  Make sure the data sturcture is a version we recognize.
    //
    if (Param->Major != 1 || (Param->Minor != 0 && Param->Minor != 1)) {

        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;

    }

    //  Only NTFS implements extend and resize, so we can just error out if we see either of these.
    //
    if ((Param->Flags & CHKDSK_EXTEND) || (Param->Flags & CHKDSK_RESIZE_LOGFILE)) {

        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;

    }

    RecoverFree = RecoverAlloc = (BOOLEAN)(Param->Flags & CHKDSK_RECOVER);

    // disable popups while we initialize the volume
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    if (!UDFVol.Initialize(NtDriveName, Message)) {
        SetErrorMode ( oldErrorMode );
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    // Re-enable hardware popups
    SetErrorMode ( oldErrorMode );

    if (Fix) {
        
        if (!UDFVol.Lock()) {

            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;

        }

    }

    return UDFVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                           Message,
                           Param->Flags,
                           0,
                           0,
                           ExitStatus,
                           NtDriveName );
}


BOOLEAN
FAR APIENTRY
Format(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Quick,
    IN      BOOLEAN     BackwardCompatible,
    IN      MEDIA_TYPE  MediaType,
    IN      PCWSTRING   LabelString,
    IN      ULONG       ClusterSize
    )
/*++

Routine Description:

    Format an NTFS volume.

Arguments:

    NtDriveName     -- supplies the name (in NT API form) of the volume
    Message         -- supplies an outlet for messages
    Quick           -- supplies a flag to indicate whether to do Quick Format
    BackwardCompatible
                    -- supplies a flag to indicate if formatting to previous
                       version of file system (e.g. FAT32->FAT16, NTFS 5.0->NTFS 4.0)
    MediaType       -- supplies the volume's Media Type
    LabelString     -- supplies the volume's label
    ClusterSize     -- supplies the cluster size for the volume.

--*/
{
    DP_DRIVE            DpDrive;
    UDF_VOL             UDFVol;
    FORMAT_ERROR_CODE   errcode;
    ULONG               flags;

    if (ClusterSize && ClusterSize > 64*1024) {
        Message->DisplayMsg(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
        return FALSE;
    }

    if (!DpDrive.Initialize( NtDriveName, Message )) {

        return FALSE;
    }

    if (DpDrive.IsFloppy()) {

        Message->DisplayMsg(MSG_NTFS_FORMAT_NO_FLOPPIES);
        return FALSE;
    }

    errcode = UDFVol.Initialize( NtDriveName,
                                  Message,
                                  FALSE,
                                  MediaType );

    if (errcode == NoError) {
        flags = (BackwardCompatible ? FORMAT_BACKWARD_COMPATIBLE : 0);
        errcode = UDFVol.Format( LabelString, Message, flags, ClusterSize );
    }

    if (errcode == LockError) {
        Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
        return FALSE;
    } else
        return (errcode == NoError);
}


BOOLEAN
FAR APIENTRY
FormatEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      PFORMATEX_FN_PARAM  Param,
    IN      MEDIA_TYPE          MediaType
    )
/*++

Routine Description:

    Format an UDFS volume.

Arguments:

    NtDriveName     -- supplies the name (in NT API form) of the volume
    Message         -- supplies an outlet for messages
    Param           -- supplies the format parameter block
    MediaType       -- supplies the volume's Media Type

--*/
{
    DP_DRIVE            DpDrive;
    UDF_VOL             UDFVol;
    FORMAT_ERROR_CODE   errcode;

    if (Param->Major != 1 || Param->Minor != 0) {
        return FALSE;
    }

    if (!DpDrive.Initialize( NtDriveName, Message )) {

        return FALSE;
    }

    if (DpDrive.IsFloppy()) {

        Message->DisplayMsg(MSG_NTFS_FORMAT_NO_FLOPPIES);
        return FALSE;
    }

    errcode = UDFVol.Initialize( NtDriveName,
                                  Message,
                                  FALSE,
                                  (Param->Flags & FORMAT_UDF_200) ? UDF_VERSION_200 : UDF_VERSION_201 );

    if (errcode == NoError) {
        errcode = UDFVol.Format( Param->LabelString,
                                  Message,
                                  Param->Flags,
                                  Param->ClusterSize );
    }

    if (errcode == LockError) {

        if (!(Param->Flags & FORMAT_FORCE)) {
            Message->DisplayMsg(MSG_FMT_FORCE_DISMOUNT_PROMPT);

            if (Message->IsYesResponse(FALSE) &&
                IFS_SYSTEM::DismountVolume(NtDriveName)) {
                Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
            }
        } else if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
            Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
        }

        errcode = UDFVol.Initialize( NtDriveName,
                                      Message,
                                      FALSE,
                                      MediaType );

        if (errcode == NoError) {
            errcode = UDFVol.Format( Param->LabelString,
                                      Message,
                                      Param->Flags,
                                      Param->ClusterSize );
        }

        if (errcode == LockError) {
            Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
            return FALSE;
        } else
            return (errcode == NoError);
    } else
        return (errcode == NoError);
}


BOOLEAN
FAR APIENTRY
Recover(
    IN      PPATH       RecFilePath,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    Recover a file on an NTFS disk.

Arguments:

    RecFilePath --  supplies the path to the file to recover
    Message     --  supplies a channel for messages

Return Value:

    TRUE if successful.

--*/
{
    UDF_VOL    UDFVol;
    PWSTRING    FullPath;
    PWSTRING    DosDriveName;
    DSTRING     NtDriveName;
    BOOLEAN     Result;

    FullPath = RecFilePath->QueryDirsAndName();
    DosDriveName = RecFilePath->QueryDevice();

    if ( DosDriveName == NULL ||
         !IFS_SYSTEM::DosDriveNameToNtDriveName(DosDriveName,
                                                &NtDriveName) ||
         FullPath == NULL ) {

        DELETE(DosDriveName);
        DELETE(FullPath);
        return FALSE;
    }

    Message->DisplayMsg(MSG_RECOV_BEGIN,
                     "%W", DosDriveName);
    Message->WaitForUserSignal();

    Result = ( UDFVol.Initialize( &NtDriveName, Message ) &&
               UDFVol.Recover( FullPath, Message ) );

    DELETE(DosDriveName);
    DELETE(FullPath);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\pch.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Pre-compiled header for untfs.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

#define _UUDF_MEMBER_

#include "ulib.hxx"

#include <stddef.h>
#include <limits.h>

#pragma warning( disable: 4200 )

inline size_t RoundUp( size_t BlockSize, size_t ElementSize ) {

    return (BlockSize + ElementSize - 1) / ElementSize;

}

//  UNDONE, CBiks, 7/31/2000
//      Iso13346 depends on the alignment macros in udfprocs, which is lame.  These macros should be moved to iso13346.h.
//      
#define LongAlign(Ptr) ((((ULONG)(Ptr)) + 3) & 0xfffffffc)

#define Add2Ptr(PTR,INC,CAST) ((CAST)((ULONG_PTR)(PTR) + (INC)))

#include "udf.h"

#include "uudf.hxx"
#include "udfvol.hxx"
#include "udfsa.hxx"

#include "ifssys.hxx"

#include "chkmsg.hxx"
#include "rtmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\format.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

   format.cxx

Abstract:

    This module contains the definition of UDF_SA::Create,
    which performs FORMAT for an UDF volume.

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include <ntddcdrm.h>

#include "crc.hxx"
#include "unicode.hxx"

//  UNDONE, CBiks, 08/18/2000
//      We should find a way to get this from Udfdata.c
//
CHAR UdfCS0IdentifierArray[] = { 'O', 'S', 'T', 'A', ' ',
                                 'C', 'o', 'm', 'p', 'r', 'e', 's', 's', 'e', 'd', ' ',
                                 'U', 'n', 'i', 'c', 'o', 'd', 'e' };

CHAR UdfDomainIdentifierArray[] = { '*', 'O', 'S', 'T', 'A', ' ',
                                    'U', 'D', 'F', ' ',
                                    'C', 'o', 'm', 'p', 'l', 'i', 'a', 'n', 't' };

CHAR UdfImplementationName[] = { '*', 'M', 'i', 'c', 'r', 'o', 's', 'o', 'f', 't' };

BOOL
MarkBlocksUsed
(
    IN  PNSR_SBD    SpaceBitmap,
    IN  ULONGLONG   StartingSector,
    IN  SECTORCOUNT NumberOfSectors
)
{
    BOOL Result = TRUE;

    for ( ULONGLONG BlockNum = StartingSector; BlockNum < (StartingSector + NumberOfSectors); BlockNum++ ) {

        ASSERTMSG( "Cross linked clusters detected",
            (SpaceBitmap->Bits[ (BlockNum / CHAR_BIT) ] & (1 << (BlockNum % CHAR_BIT))) != 0 );

        SpaceBitmap->Bits[ (BlockNum / CHAR_BIT) ] &= ~(1 << (BlockNum % CHAR_BIT));

    }

    return Result;
}

VOID
GetSystemTimeStamp
(
    PTIMESTAMP TimeStamp
)
{
    TIME_ZONE_INFORMATION TimeZoneInfo;
    DWORD TimeZoneResult = GetTimeZoneInformation( &TimeZoneInfo );

    SYSTEMTIME SystemTime;
    GetSystemTime( &SystemTime );

    TimeStamp->Type = TIMESTAMP_T_LOCAL;
    if (TimeZoneResult == TIME_ZONE_ID_UNKNOWN) {

        TimeStamp->Zone = TIMESTAMP_Z_NONE;

    } else {

        TimeStamp->Zone = TimeZoneInfo.Bias;

    }

    TimeStamp->Year =           SystemTime.wYear;
    TimeStamp->Month =          (UCHAR) SystemTime.wMonth;
    TimeStamp->Day =            (UCHAR) SystemTime.wDay;
    TimeStamp->Hour =           (UCHAR) SystemTime.wHour;
    TimeStamp->Minute =         (UCHAR) SystemTime.wMinute;
    TimeStamp->Second =         (UCHAR) SystemTime.wSecond;
    TimeStamp->CentiSecond =    0;
    TimeStamp->Usec100 =        0;
    TimeStamp->Usec =           0;
}

VOID
InitializeREGID
(
    PREGID  RegId,
    PCHAR   Identifier,
    USHORT  IdentifierSize
)
{
    memset( RegId, '\0', sizeof( REGID ) );
    memcpy( RegId->Identifier, Identifier, IdentifierSize );
}

VOID
ComputeTagCRCs
(
    LPBYTE  Descriptor
)
{
    PDESTAG Destag = (PDESTAG) Descriptor;

    //
    //  Generate and store the CRC of the descriptor section.
    //

    if (Destag->CRCLen != 0) {

        Destag->CRC = CalculateCrc( Descriptor + sizeof( DESTAG ), Destag->CRCLen );

    } else {

        Destag->CRC = 0;

    }

    //
    //  Finally, generate and store the checksum of the DESTAG.
    //

    Destag->Checksum = CalculateTagChecksum( Destag );
}

VOID    
RelocateDescriptorTag
(
    LPBYTE  Descriptor,
    ULONG   Lbn
)
{
    PDESTAG Destag = (PDESTAG) Descriptor;

    Destag->Lbn = Lbn;

    ComputeTagCRCs( Descriptor );
}

VOID
InitializeDescriptorTag
(
    LPBYTE  Descriptor,
    ULONG   DescriptorSize,
    USHORT  Ident,
    ULONG   Lbn,
    USHORT  Serial
)
{
    PDESTAG Destag = (PDESTAG) Descriptor;

    //
    //  Initialize the DESTAG portion of the descriptor.
    //

    Destag->Lbn = Lbn;
    Destag->Ident = Ident;
    Destag->Version = DESTAG_VER_NSR03;
    Destag->Res5 = 0;
    Destag->Serial = Serial;

    if (DescriptorSize < MAXUSHORT) {

        Destag->CRCLen = (USHORT)( DescriptorSize ) - sizeof( DESTAG );

    } else {

        Destag->CRCLen = 0;

    }

    ComputeTagCRCs( Descriptor );

    ASSERTMSG( "InitializeDescriptorTag(): The descriptor created is not valid.",
        VerifyDescriptor( Descriptor, DescriptorSize, Ident, NULL ) );
}

VOID
InitializeLogicalVolumeDescriptor
(
    PNSR_LVOL   LogicalVolumeDescriptor,
    ULONG       VolDescSeqNum,
    USHORT      UdfRevision,
    PCWSTRING   Label,
    USHORT      VolumeSetSequence,
    USHORT      PartitionNumber,
    ULONG       FileSetSequenceLBN,
    ULONG       FileSetSequenceSize,
    ULONG       IntegritySequenceLSN,
    ULONG       IntegritySequenceLen,
    USHORT      PrimaryPartitionRefNum,
    ULONG       SectorLen
)
{
    LogicalVolumeDescriptor->VolDescSeqNum = VolDescSeqNum;

    LogicalVolumeDescriptor->Charset.Type = CHARSPEC_T_CS0;
    memcpy( LogicalVolumeDescriptor->Charset.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    //
    //  If the user supplied a volume lable, copy it in.  Otherwise just null out the field.
    //
    
    if (Label != NULL) {
        
        CompressDString( 8, Label->GetWSTR(), (UCHAR) Label->QueryChCount(), LogicalVolumeDescriptor->VolumeID,
            sizeof( LogicalVolumeDescriptor->VolumeID ) );
        
    } else {
    
        ZeroMemory( LogicalVolumeDescriptor->VolumeID, sizeof( LogicalVolumeDescriptor->VolumeID ) );
        
    }

    LogicalVolumeDescriptor->BlockSize = SectorLen;

    InitializeREGID( &LogicalVolumeDescriptor->DomainID, UdfDomainIdentifierArray, sizeof( UdfDomainIdentifierArray ) );
    PUDF_SUFFIX_DOMAIN UdfSuffixDomain = (PUDF_SUFFIX_DOMAIN) &LogicalVolumeDescriptor->DomainID.Suffix;
    UdfSuffixDomain->UdfRevision = UdfRevision;
    UdfSuffixDomain->Flags = 0;
    ZeroMemory( UdfSuffixDomain->Reserved, sizeof( UdfSuffixDomain->Reserved ) );

    LogicalVolumeDescriptor->FSD.Length.Type = NSRLENGTH_TYPE_RECORDED;
    LogicalVolumeDescriptor->FSD.Length.Length = FileSetSequenceSize * SectorLen;
    LogicalVolumeDescriptor->FSD.Start.Lbn = FileSetSequenceLBN;
    LogicalVolumeDescriptor->FSD.Start.Partition = PrimaryPartitionRefNum;
    memset( LogicalVolumeDescriptor->FSD.ImpUse, '\0', sizeof( LogicalVolumeDescriptor->FSD.ImpUse ) );

    InitializeREGID( &LogicalVolumeDescriptor->ImpUseID, UdfImplementationName, sizeof( UdfImplementationName ) );
    PUDF_SUFFIX_IMPLEMENTATION UdfSuffixImplementation = (PUDF_SUFFIX_IMPLEMENTATION) &LogicalVolumeDescriptor->ImpUseID.Suffix;
    UdfSuffixImplementation->OSClass = OSCLASS_WINNT;
    UdfSuffixImplementation->OSIdentifier = OSIDENTIFIED_WINNT_WINNT;

    memset( LogicalVolumeDescriptor->ImpUse, '\0', sizeof( LogicalVolumeDescriptor->ImpUse ) );

    LogicalVolumeDescriptor->Integrity.Len = IntegritySequenceLen * SectorLen;
    LogicalVolumeDescriptor->Integrity.Lsn = IntegritySequenceLSN;

    PPARTMAP_PHYSICAL MapTable = (PPARTMAP_PHYSICAL) ((LPBYTE)( LogicalVolumeDescriptor ) + sizeof( NSR_LVOL ) + LogicalVolumeDescriptor->MapTableLength);

    MapTable->Type = PARTMAP_TYPE_PHYSICAL;
    MapTable->Length = sizeof( PARTMAP_PHYSICAL );
    MapTable->VolSetSeq = VolumeSetSequence;
    MapTable->Partition = PartitionNumber;

    LogicalVolumeDescriptor->MapTableCount += 1;
    LogicalVolumeDescriptor->MapTableLength = LogicalVolumeDescriptor->MapTableCount * sizeof( PARTMAP_PHYSICAL );
}

VOID
InitializePrimaryVolumeDescriptor
(
    PNSR_PVD    NsrPVD,
    ULONG       VolDescSeqNum,
    PCWSTR      VolumeID,
    PCWSTR      VolumeSetID
)
{
    //  Main Volume Descriptor Sequence (16 sectors min)
    //
    //  19          DESTAG_ID_NSR_PVD
    NsrPVD->VolDescSeqNum = VolDescSeqNum;
    NsrPVD->Number =        0;

    CompressDString( 8, VolumeID, (UCHAR) wcslen( VolumeID ), NsrPVD->VolumeID, sizeof( NsrPVD->VolumeID ) );

    //
    //  The Volume Set Sequence fields indicates how many volumes form the volume set and what number this volume is in that
    //  sequence.  We are a level 2 implementation, meaning that the volumes we read consist of a single volume. See ECMA 3/8.8.
    //

    NsrPVD->VolSetSeq = 1;
    NsrPVD->VolSetSeqMax = 1;
    NsrPVD->Level = 2;
    NsrPVD->LevelMax = 2;

    //
    //  Set bit zero in the CharSetList masks to indicate we support only CS0 per UDF 2.2.2.3 & 2.2.2.4,
    //
    NsrPVD->CharSetList = UDF_CHARSETLIST;
    NsrPVD->CharSetListMax = UDF_CHARSETLIST;

    CompressDString( 8, VolumeSetID, (UCHAR) wcslen( VolumeSetID ), NsrPVD->VolSetID, sizeof( NsrPVD->VolSetID ) );

    NsrPVD->CharsetDesc.Type = CHARSPEC_T_CS0;
    memcpy( NsrPVD->CharsetDesc.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    NsrPVD->CharsetExplan.Type = CHARSPEC_T_CS0;
    memcpy( NsrPVD->CharsetExplan.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    NsrPVD->Abstract.Len = 0;
    NsrPVD->Abstract.Lsn = 0;

    NsrPVD->Copyright.Len = 0;
    NsrPVD->Copyright.Lsn = 0;

    memset( &NsrPVD->Application, '\0', sizeof( NsrPVD->Application ) );

    GetSystemTimeStamp( &NsrPVD->RecordTime );

    memset( &NsrPVD->ImpUseID, '\0', sizeof( NsrPVD->ImpUseID ) );
    memset( &NsrPVD->ImpUse, '\0', sizeof( NsrPVD->ImpUse ) );

    NsrPVD->Predecessor = 0;
    NsrPVD->Flags = 0;
}

VOID
InitializePartitionDescriptor
(
    PNSR_PART   PartitionDescriptor,
    USHORT      PartitionNumber,
    ULONG       Sector,
    ULONG       VolDescSeqNum,
    ULONG       Start,
    ULONG       Length,
    ULONG       SpaceBitmapLBN,
    ULONG       SpaceBitmapLen,
    ULONG       SectorLen,
    USHORT      Serial
)
{
    PartitionDescriptor->VolDescSeqNum = VolDescSeqNum;

    PartitionDescriptor->Flags = NSR_PART_F_ALLOCATION;

    PartitionDescriptor->Number = PartitionNumber;

    InitializeREGID( &PartitionDescriptor->ContentsID, NSR_PART_CONTID_NSR03, sizeof( NSR_PART_CONTID_NSR03 ) );

    //
    //
    //

    PNSR_PART_H PartitionHeader = (PNSR_PART_H) &PartitionDescriptor->ContentsUse;

    ZeroMemory( &PartitionHeader->UASTable, sizeof( PartitionHeader->UASTable ) );

    PartitionHeader->UASBitmap.Start = SpaceBitmapLBN;
    PartitionHeader->UASBitmap.Length.Type = NSRLENGTH_TYPE_RECORDED;
    PartitionHeader->UASBitmap.Length.Length = SpaceBitmapLen * SectorLen;


    ZeroMemory( &PartitionHeader->IntegTable, sizeof( PartitionHeader->IntegTable ) );
    ZeroMemory( &PartitionHeader->FreedTable, sizeof( PartitionHeader->FreedTable ) );
    ZeroMemory( &PartitionHeader->FreedBitmap, sizeof( PartitionHeader->FreedBitmap ) );

    ZeroMemory( &PartitionHeader->Res40, sizeof( PartitionHeader->Res40 ) );

    //
    //
    //

    PartitionDescriptor->AccessType = NSR_PART_ACCESS_RW_OVER;

    PartitionDescriptor->Start = Start;
    PartitionDescriptor->Length = Length;

    InitializeREGID( &PartitionDescriptor->ImpUseID, UdfImplementationName, sizeof( UdfImplementationName ) );

    memset( PartitionDescriptor->ImpUse, '\0', sizeof( PartitionDescriptor->ImpUse ) );
    memset( PartitionDescriptor->Res356, '\0', sizeof( PartitionDescriptor->Res356 ) );

    InitializeDescriptorTag( (LPBYTE) PartitionDescriptor, sizeof( NSR_PART ), DESTAG_ID_NSR_PART,
        Sector, Serial );
}

VOID
InitializeIntegrityDescriptor
(
    PNSR_INTEG  IntegrityDescriptor,
    ULONG       IntegritySequenceLSN,
    ULONG       PartitionFreeSpace,
    ULONG       PartitionLen,
    USHORT      Serial,
    USHORT      UdfRevision
)
{
    PLVID_IMP_USE ImpUse;

    ZeroMemory( IntegrityDescriptor, sizeof( IntegrityDescriptor) );
    
    GetSystemTimeStamp( &IntegrityDescriptor->Time );

    //  UNDONE, CBiks, 08/21/2000
    //      Maybe the integrity descriptor should be opened until we are finished writing the disk and then
    //      we rewrite it closed...
    //
    IntegrityDescriptor->Type = NSR_INTEG_T_CLOSE;

    IntegrityDescriptor->Next.Len = 0;
    IntegrityDescriptor->Next.Lsn = 0;

    *((ULONGLONG*) &IntegrityDescriptor->LVHD.UniqueID) = 16;

    IntegrityDescriptor->PartitionCount = 1;

    NsrLvidFreeTable( IntegrityDescriptor)[ 0 ] = PartitionFreeSpace;
    NsrLvidSizeTable( IntegrityDescriptor)[ 0 ] = PartitionLen;

    //
    //  Init the UDF specific part of the LVID
    //

    IntegrityDescriptor->ImpUseLength = sizeof( LVID_IMP_USE);

    ImpUse = Add2Ptr( IntegrityDescriptor, 
                      NsrLvidImpUseOffset( IntegrityDescriptor),
                      PLVID_IMP_USE);

    ImpUse->NumDirs = 1;

    ImpUse->UdfMinRead = 
    ImpUse->UdfMaxWrite = 
    ImpUse->UdfMinWrite = UdfRevision;

    InitializeDescriptorTag( (LPBYTE) IntegrityDescriptor, 
                             NsrLvidSize( IntegrityDescriptor), 
                             DESTAG_ID_NSR_LVINTEG,
                             IntegritySequenceLSN, 
                             Serial );
}

VOID
InitializeFileSet
(
    PNSR_FSD    FileSet,
    ULONG       FileSetSequenceLBN,
    PCWSTRING   Label,
    PCWSTR      VolumeSetIdentifier,
    USHORT      UdfRevision,
    ULONG       RootDirectoryLBN,
    ULONG       RootDirectoryLen,
    USHORT      PrimaryPartitionRefNum,
    ULONG       SectorLen,
    USHORT      Serial
)
{
    GetSystemTimeStamp( &FileSet->Time );

    //
    //  UDF 2.3.2.1 & 2.3.2.2 specify the interchange level must be 3.
    //

    FileSet->Level = 3;
    FileSet->LevelMax = 3;

    FileSet->CharSetList = UDF_CHARSETLIST;
    FileSet->CharSetListMax = UDF_CHARSETLIST;

    FileSet->FileSet = 1;
    FileSet->FileSetDesc = 1;

    FileSet->CharspecVolID.Type = CHARSPEC_T_CS0;
    memcpy( FileSet->CharspecVolID.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    //
    //  If the user supplied a volume lable, copy it in.  Otherwise just null out the field.
    //
    
    if (Label != NULL) {
        
        CompressDString( 8, Label->GetWSTR(), (UCHAR) Label->QueryChCount(), FileSet->VolID,
            sizeof( FileSet->VolID ) );
        
    } else {
    
        ZeroMemory( FileSet->VolID, sizeof( FileSet->VolID ) );
        
    }

    FileSet->CharspecFileSet.Type = CHARSPEC_T_CS0;
    memcpy( FileSet->CharspecFileSet.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    CompressDString( 8, VolumeSetIdentifier, (UCHAR) wcslen( VolumeSetIdentifier ),
        FileSet->FileSetID, sizeof( FileSet->FileSetID ) );

    ZeroMemory( FileSet->Copyright, sizeof( FileSet->Copyright ) );
    ZeroMemory( FileSet->Abstract, sizeof( FileSet->Abstract ) );

    FileSet->IcbRoot.Start.Lbn = RootDirectoryLBN;
    FileSet->IcbRoot.Start.Partition = PrimaryPartitionRefNum;
    FileSet->IcbRoot.Length.Type = NSRLENGTH_TYPE_RECORDED;
    FileSet->IcbRoot.Length.Length = RootDirectoryLen * SectorLen;
    ZeroMemory( FileSet->IcbRoot.ImpUse, sizeof( FileSet->IcbRoot.ImpUse ) );

    InitializeREGID( &FileSet->DomainID, UdfDomainIdentifierArray, sizeof( UdfDomainIdentifierArray ) );
    PUDF_SUFFIX_DOMAIN UdfSuffixDomain = (PUDF_SUFFIX_DOMAIN) &FileSet->DomainID.Suffix;
    UdfSuffixDomain->UdfRevision = UdfRevision;
    UdfSuffixDomain->Flags = 0;
    ZeroMemory( UdfSuffixDomain->Reserved, sizeof( UdfSuffixDomain->Reserved ) );

    ZeroMemory( &FileSet->NextExtent, sizeof( FileSet->NextExtent ) );

    ZeroMemory( &FileSet->StreamDirectoryIcb, sizeof( FileSet->StreamDirectoryIcb ) );

    ZeroMemory( FileSet->Res464, sizeof( FileSet->Res464 ) );

    InitializeDescriptorTag( (LPBYTE) FileSet, sizeof( NSR_FSD ), DESTAG_ID_NSR_FSD,
        FileSetSequenceLBN, Serial );
}

VOID
InitializeSpaceBitmap
(
    PNSR_SBD    SpaceBitmap,
    ULONG       SpaceBitmapLBN,
    PNSR_PART   NsrPart,
    USHORT      Serial
)
{
    SpaceBitmap->BitCount = NsrPart->Length;
    SpaceBitmap->ByteCount = RoundUp( SpaceBitmap->BitCount, CHAR_BIT );

    FillMemory( &SpaceBitmap->Bits, SpaceBitmap->ByteCount, 0xff );

    InitializeDescriptorTag( (LPBYTE) SpaceBitmap, sizeof( NSR_SBD ) + SpaceBitmap->ByteCount,
        DESTAG_ID_NSR_SBP, SpaceBitmapLBN, Serial );

}

VOID
InitializeRootDirICB
(
    PICBEXTFILE ICBExtFile,
    USHORT      PartitionRefNum,
    ULONG       RootDirectoryLBN,
    ULONG       RootDirectoryLen,
    ULONG       SectorLen,
    USHORT      Serial
)
{
    ICBExtFile->Icbtag.PriorDirectCount = 0;
    ICBExtFile->Icbtag.StratType = ICBTAG_STRAT_DIRECT;
    ICBExtFile->Icbtag.StratParm = 0;
    ICBExtFile->Icbtag.MaxEntries = 1;
    ICBExtFile->Icbtag.Res10 = 0;
    ICBExtFile->Icbtag.FileType = ICBTAG_FILE_T_DIRECTORY;
    ICBExtFile->Icbtag.IcbParent.Lbn = 0;
    ICBExtFile->Icbtag.IcbParent.Partition = 0;
    ICBExtFile->Icbtag.Flags = ICBTAG_F_ALLOC_IMMEDIATE;

    ICBExtFile->UID = 0xffffffff;
    ICBExtFile->GID = 0xffffffff;

    ICBExtFile->Permissions = (ICBFILE_PERM_OWN_A | ICBFILE_PERM_OWN_R) |
        (ICBFILE_PERM_OWN_W | ICBFILE_PERM_OWN_X | ICBFILE_PERM_GRP_A) |
        (ICBFILE_PERM_GRP_R | ICBFILE_PERM_GRP_W | ICBFILE_PERM_GRP_X) |
        (ICBFILE_PERM_OTH_A | ICBFILE_PERM_OTH_R | ICBFILE_PERM_OTH_W | ICBFILE_PERM_OTH_X);

    ICBExtFile->LinkCount = 1;

    ICBExtFile->RecordFormat = 0;
    ICBExtFile->RecordDisplay = 0;
    ICBExtFile->RecordLength = 0;

    //
    //
    //

    ICBExtFile->AllocLength = LongAlign( sizeof( NSR_FID));

    PNSR_FID ParentDirFID = (PNSR_FID)( (LPBYTE)( ICBExtFile ) + sizeof( ICBEXTFILE) );

    ParentDirFID->Version = 1;
    ParentDirFID->Flags = NSR_FID_F_PARENT | NSR_FID_F_DIRECTORY;
    ParentDirFID->FileIDLen = 0;
    ParentDirFID->Icb.Start.Partition = PartitionRefNum;
    ParentDirFID->Icb.Start.Lbn = RootDirectoryLBN;
    ParentDirFID->Icb.Length.Type = NSRLENGTH_TYPE_RECORDED;
    ParentDirFID->Icb.Length.Length = RootDirectoryLen * SectorLen;

    InitializeDescriptorTag( (LPBYTE) ParentDirFID, ISONsrFidSize( ParentDirFID ), DESTAG_ID_NSR_FID,
        RootDirectoryLBN, Serial );

    //
    //
    //

    ICBExtFile->InfoLength = ICBExtFile->AllocLength;
    ICBExtFile->ObjectSize = ICBExtFile->InfoLength;

    ICBExtFile->BlocksRecorded = 0;

    GetSystemTimeStamp( &ICBExtFile->AccessTime );
    GetSystemTimeStamp( &ICBExtFile->ModifyTime );
    GetSystemTimeStamp( &ICBExtFile->CreationTime );
    GetSystemTimeStamp( &ICBExtFile->AttributeTime );
   
    ICBExtFile->Checkpoint = 1;

    ICBExtFile->Reserved = 0;

    ZeroMemory( &ICBExtFile->IcbEA, sizeof( ICBExtFile->IcbEA ) );
    ZeroMemory( &ICBExtFile->IcbStream, sizeof( ICBExtFile->IcbStream ) );

    InitializeREGID( &ICBExtFile->ImpUseID, UdfImplementationName, sizeof( UdfImplementationName ) );
    PUDF_SUFFIX_IMPLEMENTATION UdfSuffixImplementation = (PUDF_SUFFIX_IMPLEMENTATION) &ICBExtFile->ImpUseID.Suffix;
    UdfSuffixImplementation->OSClass = OSCLASS_WINNT;
    UdfSuffixImplementation->OSIdentifier = OSIDENTIFIED_WINNT_WINNT;

    ICBExtFile->UniqueID = 0;

    ICBExtFile->EALength = 0;

    InitializeDescriptorTag( (LPBYTE) ICBExtFile, sizeof( ICBEXTFILE) + ICBExtFile->AllocLength, DESTAG_ID_NSR_EXT_FILE,
        RootDirectoryLBN, Serial );
}


BOOLEAN
UDF_SA::FormatVolumeRecognitionSequence()
{
    BOOLEAN Result = TRUE;

    //  Volume Recognition Sequence.  
    //
    //  NOTE: These structures are 2048 bytes in length,  regardless of sector size.
    //        n = 2048 / sectorsize.  We must also cope with sector sizes > 2048 when
    //        calulating the length of the run in sectors.
    //
    //
    //  16          BEA01
    //  16+n        NSR03
    //  16+2n       TEA01

    ULONG   SectorLen = _drive->QuerySectorSize();

    HMEM    VolumeRecognitionSequenceMem;
    SECRUN  VolumeRecognitionSequenceSecrun;

    ULONG   VolumeRecognitionSequenceStart = 0;
    ULONG   VolumeRecognitionSequenceSectors = (((3 * sizeof( VSD_GENERIC)) + VRA_BOUNDARY_LOCATION) + (SectorLen - 1)) / SectorLen;

    Result = VolumeRecognitionSequenceMem.Initialize();
    if (Result) {

        Result = VolumeRecognitionSequenceSecrun.Initialize( &VolumeRecognitionSequenceMem, _drive,
            VolumeRecognitionSequenceStart, VolumeRecognitionSequenceSectors );
            
        if (Result) {

            LPBYTE VRSBuffer = (LPBYTE) VolumeRecognitionSequenceSecrun.GetBuf();

            //
            //  We zero from and including sector zero to clear out any data at
            //  the beginning of the volume (e.g. BPB) that might decoy other file systems
            //  (i.e. FAT) into trying to mount it and getting in a mess.
            //
    
            memset( VRSBuffer, 0, VolumeRecognitionSequenceSectors * SectorLen);
            VRSBuffer += VRA_BOUNDARY_LOCATION;

            PVSD_BEA01 BEA01 = (PVSD_BEA01) VRSBuffer;
            PVSD_NSR02 NSR =   (PVSD_NSR02) (VRSBuffer + sizeof( VSD_GENERIC));
            PVSD_TEA01 TEA01 = (PVSD_TEA01) (VRSBuffer + 2 * sizeof( VSD_GENERIC));

            BEA01->Type = VSD_NSR02_TYPE_0;
            BEA01->Version = VSD_NSR02_VER;
            memcpy( BEA01->Ident, VSD_IDENT_BEA01, VSD_LENGTH_IDENT );

            //
            //

            NSR->Type = VSD_NSR02_TYPE_0;
            NSR->Version = VSD_NSR02_VER;
            memcpy( NSR->Ident, VSD_IDENT_NSR03, VSD_LENGTH_IDENT );

            //
            //

            TEA01->Type = VSD_NSR02_TYPE_0;
            TEA01->Version = VSD_NSR02_VER;
            memcpy( TEA01->Ident, VSD_IDENT_TEA01, VSD_LENGTH_IDENT );

            Result = VolumeRecognitionSequenceSecrun.Write();
            
            if (!Result) {

                DebugPrint( "UUDF: Unable to write Volume Recognition Sequence.\n" );
            }

        }

    }

    return Result;
}

BOOLEAN
FormatAnchorVolumeDescriptorPtr
(
    PNSR_ANCHOR NsrAnchor,
    ULONG       Sector,
    ULONG       MainVolumeSequenceLSN,
    ULONG       BackupVolumeSequenceLSN,
    SECTORCOUNT VolumeSequenceLen,
    ULONG       SectorLen,
    USHORT      Serial
)
{
    BOOLEAN Result = TRUE;

    //
    //  ECMA 3/8.4.4 requires any space in the sector after the descriptor to be zeroed, so
    //  we start out by zeroing the entire sector.
    //

    ZeroMemory( NsrAnchor, SectorLen );

    //
    //  Save the Volume Descriptor Sequence pointers.
    //

    NsrAnchor->Main.Lsn = MainVolumeSequenceLSN;
    NsrAnchor->Main.Len = VolumeSequenceLen * SectorLen;

    NsrAnchor->Reserve.Lsn = BackupVolumeSequenceLSN;
    NsrAnchor->Reserve.Len = VolumeSequenceLen * SectorLen;

    InitializeDescriptorTag( (LPBYTE) NsrAnchor, sizeof( NSR_ANCHOR ), DESTAG_ID_NSR_ANCHOR, Sector, Serial );

    return Result;
}

BOOLEAN
UDF_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      ULONG           Flags,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSectors
    )
/*++

Routine Description:

    This routine creates a new UDF volume on disk based on defaults.

Arguments:

    BadSectors  - Supplies a list of the bad sectors on the disk.
    Message     - Supplies an outlet for messages.
    Label       - Supplies an optional volume label (may be NULL).
    ClusterSize - Supplies the desired size of a cluster in bytes.
    BackwardCompatible
                - TRUE if volume is not suppose to be upgraded;
                  FALSE if volume is suppose to be upgraded on mount.


Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN Result = TRUE;

    UNREFERENCED_PARAMETER( VirtualSectors );

    if ((ClusterSize != 0) && (ClusterSize != _drive->QuerySectorSize())) {

        Message->DisplayMsg(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
        Result = FALSE;

    } else {

        ULONG   SectorLen = _drive->QuerySectorSize();

        //
        //  The initial layout of the disk is explained below (for 2k/sector media - for 
        //  other sector sizes the end block of the VRS changes moving everything following).  
        //
        //  In this example assume the Last LSN is 0x129800, standard
        //  2.6GB/side media.
        //
        //      000000-00000F   The first 32k of the disk is reseved by IDF.
        //      000010-000010   Volume Recognition Sequence
        //             +01800b      BEA01
        //                          NSR02/NSR03
        //                          TEA01
        //      000013-000022   Volume Descriptor Sequence in next 16 sectors of the disk.
        //                          DESTAG_ID_NSR_PVD
        //                          DESTAG_ID_NSR_PART
        //                          DESTAG_ID_NSR_LVOL
        //                          DESTAG_ID_NSR_UASD
        //                          DESTAG_ID_NSR_TERM
        //      000023-000024   Logical Volume Integrity Descriptor Sequence
        //                          DESTAG_ID_NSR_LVINTEG
        //                          DESTAG_ID_NSR_TERM
        //      000025-0000FF   Unallocated space referenced by the Unallocated Space Descriptor.
        //      000100-000100   Anchor Volume Descriptor Pointer - Must be at sector 256.
        //
        //      000101-1297E9   Actual UDF Partition
        //      000101-000101       DESTAG_ID_NSR_FSD       File Set Descriptor
        //      000102-000102       DESTAG_ID_NSR_TERM      Terminating Descriptor
        //      000103-00014D       DESTAG_ID_NSR_SBP       Space Bitmap Descriptor
        //      00014E-00014E       DESTAG_ID_NSR_EXT_FILE  Root Directory
        //      00014F-1297E8   End of UDF Partition
        //
        //      1297E9-1297FE   Backup Volume Descriptor Sequence in 16 sectors at the end of the disk.
        //      1297FF-1297FF   Backup Anchor Volume Descriptor Pointer - Must be at the last sector of the disk.
        //

        //  UNDONE, CBiks, 08/22/2000
        //      Use SECTORCOUNT, LSN and LBN where appropriate instead of ULONG.
        //

        SECTORCOUNT LastLSN =               _drive->QuerySectors().GetLowPart();
                                            
        ULONG VolumeRecognitionStart =      VRA_BOUNDARY_LOCATION / SectorLen;
        ULONG VolumeRecognitionLength =     ((3 * sizeof( VSD_GENERIC)) + (SectorLen - 1)) / SectorLen;
                                            
        ULONG MainVolumeSequenceStart =     VolumeRecognitionStart + VolumeRecognitionLength;
        ULONG VolumeSequenceLength =        16;
                                            
        ULONG PVDAbsoluteSector =           MainVolumeSequenceStart;
        ULONG PartitionAbsoluteSector =     PVDAbsoluteSector + 1;
        ULONG LVolAbsoluteSector =          PartitionAbsoluteSector + 1;
        ULONG UasdAbsoluteSector =          LVolAbsoluteSector + 1;
        ULONG TermAbsoluteSector =          UasdAbsoluteSector + 1;
                                        
        ULONG IntegritySequenceLSN =        MainVolumeSequenceStart + VolumeSequenceLength;
        
        // UDF 2.2.4.6 - LVID extent must be 8k minimum length?!
        ULONG IntegritySequenceLen =		8*1024 / SectorLen; 
                                        
        ULONG MainAnchorVolumePointer =     0x100;

        ULONG UnallocatedSpaceStart =       IntegritySequenceLSN + IntegritySequenceLen;
        ULONG UnallocatedSpaceLength =      MainAnchorVolumePointer - UnallocatedSpaceStart;
                                            
        ULONG BackupAnchorVolumePointer =   LastLSN - 1;
        ULONG BackupVolumeSequenceLSN =     BackupAnchorVolumePointer - VolumeSequenceLength;
                                            
        ULONG LastSectorInPartition =       BackupVolumeSequenceLSN - 1;
                                        
        USHORT  PrimaryPartitionNumber =    0x2000;
        USHORT  PrimaryPartitionRefNum =    0;

        ULONG   FirstSectorInPartition =    MainAnchorVolumePointer + 1;
        ULONG   PartitionLength =           LastSectorInPartition - FirstSectorInPartition;

        ULONG   FileSetSequenceLBN =        0;
        ULONG   FileSetSequenceLSN =        FirstSectorInPartition;
        ULONG   FileSetSequenceLen =        2;

        ULONG   SpaceBitmapLBN =            FileSetSequenceLBN + FileSetSequenceLen;
        ULONG   SpaceBitmapLSN =            FirstSectorInPartition + SpaceBitmapLBN;
        ULONG   SpaceBitmapLen =            RoundUp( offsetof( NSR_SBD, Bits ) + RoundUp(PartitionLength, CHAR_BIT), SectorLen );
                                        
        ULONG   RootDirectoryLBN =          SpaceBitmapLBN + SpaceBitmapLen;
        ULONG   RootDirectoryLSN =          FirstSectorInPartition + RootDirectoryLBN;
        ULONG   RootDirectoryLen =          1;

        //                              
        //
        //

        PCWSTR VolumeSetIdentifier = L"UDF Volume Set";

        //
        //
        //

        HMEM    MainVolumeSequenceSecrunMem;
        SECRUN  MainVolumeSequenceSecrun;

        HMEM    IntegritySequenceSecrunMem;
        SECRUN  IntegritySequenceSecrun;

        HMEM    PartitionSecrunMem;
        SECRUN  PartitionSecrun;

        HMEM    AnchorVolumePtrSecrunMem;
        SECRUN  AnchorVolumePtrSecrun;

        Result = AnchorVolumePtrSecrunMem.Initialize();
        if (Result) {

            Result = AnchorVolumePtrSecrun.Initialize( &AnchorVolumePtrSecrunMem, _drive, MainAnchorVolumePointer, 1 );

            Result = AnchorVolumePtrSecrun.Read();

            if (Result) {

                USHORT Id;

                //
                //  TEJ 11.1.00 - Extract and increment the tagserial from this
                //                AVDP if it looks valid.
                //

                if (VerifyDescriptor( (LPBYTE)(AnchorVolumePtrSecrun.GetBuf()), 
                                      SectorLen, 
                                      DESTAG_ID_NSR_ANCHOR, 
                                      &Id))  {

                    _NsrAnchor = *(PNSR_ANCHOR)(AnchorVolumePtrSecrun.GetBuf());
                    _NsrAnchor.Destag.Serial += 1;
                }
                else {
                    
                    _NsrAnchor.Destag.Serial = 0;
                }
            }
        }

        Result = MainVolumeSequenceSecrunMem.Initialize();
        if (Result) {

            Result = MainVolumeSequenceSecrun.Initialize( &MainVolumeSequenceSecrunMem, _drive, MainVolumeSequenceStart,
                VolumeSequenceLength );
            if (Result) {

                memset( MainVolumeSequenceSecrun.GetBuf(), '\0', MainVolumeSequenceSecrun.QueryLength() * SectorLen );

            }

        }

        Result = IntegritySequenceSecrunMem.Initialize();
        if (Result) {

            Result = IntegritySequenceSecrun.Initialize( &IntegritySequenceSecrunMem, _drive, IntegritySequenceLSN,
                IntegritySequenceLen );
            if (Result) {

                memset( IntegritySequenceSecrun.GetBuf(), '\0', IntegritySequenceSecrun.QueryLength() * SectorLen );

            }

        }

        if (Result) {

            Result = PartitionSecrunMem.Initialize();
            if (Result) {

                ULONG PartitionLen = FileSetSequenceLen + SpaceBitmapLen + RootDirectoryLen;

                Result = PartitionSecrun.Initialize( &PartitionSecrunMem, _drive, FileSetSequenceLSN, PartitionLen );
                if (Result) {

                    memset( PartitionSecrun.GetBuf(), '\0', PartitionSecrun.QueryLength() * SectorLen );

                }

            }

        }

        if (Result) {

            //
            //
            //

            ULONG VolDescSeqNum = 1;

            //
            //
            //

            LPBYTE VDSSecrunBuffer =   (LPBYTE) MainVolumeSequenceSecrun.GetBuf();

            PNSR_PVD NsrPVD = (PNSR_PVD)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            PNSR_PART NsrPart = (PNSR_PART)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            PNSR_LVOL NsrLvol = (PNSR_LVOL)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            PNSR_UASD NsrUasd = (PNSR_UASD)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            PNSR_TERM NsrTerm = (PNSR_TERM)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            //
            //
            //

            LPBYTE IntegritySequenceBuffer = (LPBYTE) IntegritySequenceSecrun.GetBuf();

            PNSR_INTEG NsrInteg = (PNSR_INTEG)( IntegritySequenceBuffer );
            IntegritySequenceBuffer += SectorLen;

            PNSR_TERM NsrIntegTerm = (PNSR_TERM)( IntegritySequenceBuffer );
            IntegritySequenceBuffer += SectorLen;

            //
            //
            //

            LPBYTE PartitionSecrunBuffer = (LPBYTE) PartitionSecrun.GetBuf();

            PNSR_FSD FileSet = (PNSR_FSD) PartitionSecrunBuffer;
            PartitionSecrunBuffer += SectorLen;

            PNSR_TERM FileSetTerm = (PNSR_TERM)( PartitionSecrunBuffer );
            PartitionSecrunBuffer += SectorLen;

            PNSR_SBD SpaceBitmap = (PNSR_SBD)( PartitionSecrunBuffer );
            PartitionSecrunBuffer += SpaceBitmapLen * SectorLen;

            PICBEXTFILE RootDirectoryIcb = (PICBEXTFILE)( PartitionSecrunBuffer );
            PartitionSecrunBuffer += SectorLen;

            //
            //  The first entry in the VDS will be the Primary Volume Descriptor.
            //

            InitializePrimaryVolumeDescriptor( NsrPVD, VolDescSeqNum, L"UDF Volume", VolumeSetIdentifier );
            InitializeDescriptorTag( (LPBYTE) NsrPVD, sizeof( NSR_PVD ), DESTAG_ID_NSR_PVD, PVDAbsoluteSector, 
                                    _NsrAnchor.Destag.Serial);

            //
            //
            //

            InitializePartitionDescriptor( NsrPart, PrimaryPartitionNumber, PartitionAbsoluteSector, VolDescSeqNum,
                FirstSectorInPartition, PartitionLength, SpaceBitmapLBN, SpaceBitmapLen, SectorLen ,
                _NsrAnchor.Destag.Serial);

            //
            //
            //

            InitializeLogicalVolumeDescriptor( NsrLvol, VolDescSeqNum, _FormatUDFRevision, Label, NsrPVD->VolSetSeq, NsrPart->Number,
                FileSetSequenceLBN, FileSetSequenceLen,
                IntegritySequenceLSN, IntegritySequenceLen,
                PrimaryPartitionRefNum, SectorLen );

            InitializeDescriptorTag( (LPBYTE) NsrLvol, sizeof( NSR_LVOL ) + NsrLvol->MapTableLength,
                DESTAG_ID_NSR_LVOL, LVolAbsoluteSector, _NsrAnchor.Destag.Serial );

            //
            //
            //

            NsrUasd->VolDescSeqNum = VolDescSeqNum;

            NsrUasd->ExtentCount = 1;

            PEXTENTAD Extents = (PEXTENTAD) NsrUasd->Extents;
            Extents->Len = UnallocatedSpaceLength * SectorLen;
            Extents->Lsn = UnallocatedSpaceStart;

            InitializeDescriptorTag( (LPBYTE) NsrUasd, sizeof( NSR_UASD ) + (NsrUasd->ExtentCount * sizeof( EXTENTAD )),
                DESTAG_ID_NSR_UASD, UasdAbsoluteSector, _NsrAnchor.Destag.Serial );

            //
            //
            //

            InitializeDescriptorTag( (LPBYTE) NsrTerm, sizeof( NSR_TERM ), DESTAG_ID_NSR_TERM, TermAbsoluteSector, 
                                      _NsrAnchor.Destag.Serial );

            //
            //
            //

            InitializeFileSet( FileSet, FileSetSequenceLBN, Label, VolumeSetIdentifier, _FormatUDFRevision,
                RootDirectoryLBN, RootDirectoryLen, PrimaryPartitionRefNum, SectorLen, _NsrAnchor.Destag.Serial );

            InitializeDescriptorTag( (LPBYTE) FileSetTerm, sizeof( NSR_TERM ), DESTAG_ID_NSR_TERM,
                FileSetSequenceLBN + 1, _NsrAnchor.Destag.Serial );

            //  259 - 333   DESTAG_ID_NSR_SBP
            //BITVECTOR SpaceBitmap;
            InitializeSpaceBitmap( SpaceBitmap, SpaceBitmapLBN, NsrPart, _NsrAnchor.Destag.Serial );

            //  334         DESTAG_ID_NSR_EXT_FILE  (RootDirectory)
            InitializeRootDirICB( RootDirectoryIcb, PrimaryPartitionRefNum, RootDirectoryLBN, RootDirectoryLen, SectorLen,
                                  _NsrAnchor.Destag.Serial);

            MarkBlocksUsed( SpaceBitmap, FileSetSequenceLBN, FileSetSequenceLen );
            MarkBlocksUsed( SpaceBitmap, SpaceBitmapLBN, SpaceBitmapLen );
            MarkBlocksUsed( SpaceBitmap, RootDirectoryLBN, RootDirectoryLen );

            //  UNDONE, CBiks, 08/21/2000
            //      Fill in the real partition size and free space below.
            //

            InitializeIntegrityDescriptor( NsrInteg, 
                                           IntegritySequenceLSN, 
                                           (NsrPart->Length - FileSetSequenceLen - SpaceBitmapLen - RootDirectoryLen), 
                                           NsrPart->Length, 
                                          _NsrAnchor.Destag.Serial, 
                                          _FormatUDFRevision );

            InitializeDescriptorTag( (LPBYTE) NsrIntegTerm, sizeof( NSR_TERM ), DESTAG_ID_NSR_TERM,
                IntegritySequenceLSN + 1, _NsrAnchor.Destag.Serial );

            if (Result) {

                Result = MainVolumeSequenceSecrun.Write();
                if (Result) {

                    MainVolumeSequenceSecrun.Relocate( BackupVolumeSequenceLSN );
                    RelocateDescriptorTag( (LPBYTE) NsrPVD,  BackupVolumeSequenceLSN );
                    RelocateDescriptorTag( (LPBYTE) NsrPart, BackupVolumeSequenceLSN + 1 );
                    RelocateDescriptorTag( (LPBYTE) NsrLvol, BackupVolumeSequenceLSN + 2 );
                    RelocateDescriptorTag( (LPBYTE) NsrUasd, BackupVolumeSequenceLSN + 3 );
                    RelocateDescriptorTag( (LPBYTE) NsrTerm, BackupVolumeSequenceLSN + 4 );

                    Result = MainVolumeSequenceSecrun.Write();
                    if (Result) {

                        Result = IntegritySequenceSecrun.Write();
                        if (Result) {

                            Result = PartitionSecrun.Write();
                            if (Result) {

                                //
                                //  Write the primary Anchor Volume Descriptor pointer.
                                //

                                PNSR_ANCHOR NsrAnchor = (PNSR_ANCHOR) AnchorVolumePtrSecrun.GetBuf();

                                Result = FormatAnchorVolumeDescriptorPtr( NsrAnchor, MainAnchorVolumePointer, MainVolumeSequenceStart,
                                    BackupVolumeSequenceLSN, VolumeSequenceLength, SectorLen, _NsrAnchor.Destag.Serial );

                                if (Result) {

                                    Result = AnchorVolumePtrSecrun.Write();
                                    if (Result) {

                                        AnchorVolumePtrSecrun.Relocate( BackupAnchorVolumePointer );
                                        RelocateDescriptorTag( (LPBYTE) NsrAnchor,  BackupAnchorVolumePointer );

                                        Result = AnchorVolumePtrSecrun.Write();

                                    }

                                    if (!Result) {

                                        DebugPrint( "UUDF: Unable to write Anchor Volume Descriptor Pointer.\n" );

                                    }
                                }
                            }

                        }

                    }

                }

            }

            //
            //  Write the Volume Recognition Sequence last because the disk is unrecognizable without it, which is what we
            //  want if something goes wrong.
            //

            if (Result) {

                Result = FormatVolumeRecognitionSequence();
                if (!Result) {

                    //  UNDONE, CBiks, 08/17/2000
                    //      Use a real error message.
                    //
                    Message->Set( MSG_FORMAT_FAILED );
                    Message->Display( "" );

                }

            }

        }

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\readvrs.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ReadVRS.cxx

Author:

    Centis Biks (cbiks) 12-Jun-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "message.hxx"

typedef struct      /* ECMA 2/9.1 etc. */
{
    VSD_IDENT   type;
    PCSTR       string;    /* \0 terminated StandardIdentifier string */
} VsdTable;

static VsdTable vsdTable[] =
{
    { VsdIdentBEA01, VSD_IDENT_BEA01 },
    { VsdIdentBOOT2, VSD_IDENT_BOOT2 },
    { VsdIdentCD001, VSD_IDENT_CD001 },
    { VsdIdentCDW02, VSD_IDENT_CDW02 },
    { VsdIdentNSR02, VSD_IDENT_NSR02 },
    { VsdIdentNSR03, VSD_IDENT_NSR03 },
    { VsdIdentTEA01, VSD_IDENT_TEA01 }
};

static VSD_IDENT
VerifyVolRecVSD
(
    PVSD_GENERIC vsd
)
{
    VSD_IDENT  type = VsdIdentBad;
    int      i;
    char    *dInfo = "Volume Structure Descriptor. ECMA 2/9. or 3/9.1";
    char    *typeStr = "";

    for( i = 0; i < (sizeof( vsdTable ) / sizeof( VsdTable )); i++ )
    {
        if( memcmp( vsd->Ident, vsdTable[i].string, 5 ) == 0)
        {
            type = vsdTable[i].type;
            typeStr = (char*)vsdTable[i].string;
            DbgPrint( "\t%s\n", typeStr);
            if(    type != VsdIdentCD001    /* no further test for VsdIdentCD001 */
                && type != VsdIdentCDW02 )                  /* and VsdIdentCDW02 */
            {
                if( vsd->Type != 0 )
                {
                    DbgPrint( "\tError: Type   : %lu, expected 0\n"
                        "-\t       in %s %s\n", vsd->Type, typeStr, dInfo );
                }

                if( vsd->Version != 1 )
                {
                    DbgPrint( "\tError: Version: %lu, expected 1\n"
                        "-\t       in %s %s\n", vsd->Version, typeStr, dInfo );
                }
            }
            break;      /* type found */
        }
    }
    return type;
}

BOOL
UDF_SA::ReadVolumeRecognitionSequence()
{
    LPBYTE      readbuffer;
    BOOL        ready, result;
    VSD_IDENT   vsdType;
    VSD_IDENT   prevVsdType;
    int         BEA_TEA_balance;
    int         cntTotal;
    int         cntBEA01;
    int         cntTEA01;
    int         cntNSR02;
    int         cntNSR03;
    UINT        blocksPerVSD;

    DbgPrint( "\tRead Volume Recognition Sequence\n" );

    ASSERT( sizeof( VSD_GENERIC ) == 2048 );

    blocksPerVSD = RoundUp( sizeof( VSD_GENERIC ), QuerySectorSize() );

    UINT sectNumb = 16;

    readbuffer = (LPBYTE) malloc( blocksPerVSD * QuerySectorSize() );
    if( readbuffer == NULL ) {
        return FALSE;
    }

    vsdType = VsdIdentBad;
    cntTotal = cntBEA01 = cntTEA01 = cntNSR02 = cntNSR03 = 0;

    for( ready = FALSE; ready == FALSE; sectNumb += blocksPerVSD )
    {
        prevVsdType = vsdType;
        if( !Read( sectNumb, blocksPerVSD, readbuffer ) )
        {
            vsdType = VsdIdentBad;  /* read error */
        }
        else
        {
            vsdType = VerifyVolRecVSD( (PVSD_GENERIC) readbuffer );
        }
        if( vsdType != VsdIdentBad )
        {
            cntTotal++;
        }
        switch( vsdType )
        {
        case VsdIdentBad:       /* read error or unknown descriptor */
            ready = TRUE;
            break;
        case VsdIdentBEA01:
            if( cntBEA01 == 0 )     /* first BEA01 */
            {
                if( cntTEA01 != 0 )
                {
                    DbgPrint( "\tWarning: %lu times %s before first %s\n",
                        cntTEA01, VSD_IDENT_TEA01, VSD_IDENT_BEA01);
                }
                if( cntTotal != 1 )
                {
                    DbgPrint( "\t%lu Volume Structure Descriptors found before first %s\n",
                        cntTotal - 1, VSD_IDENT_BEA01 );
                }
                DbgPrint( "\tStart of Extended Area\n");
                BEA_TEA_balance = 0;
            }
            else                    /* not first BEA01 */
            {
                if( prevVsdType != VsdIdentTEA01 )
                {
                    DbgPrint( "\tWarning: %s not preceded by %s\n",
                                    VSD_IDENT_BEA01, VSD_IDENT_TEA01);
                }
            }

            if( BEA_TEA_balance != 0 )
            {
                DbgPrint( "\tWarning: %s / %s unbalance\n",
                                    VSD_IDENT_BEA01, VSD_IDENT_TEA01);
            }
            BEA_TEA_balance = 1;
            cntBEA01++;
            break;
        case VsdIdentTEA01:
            if(    cntBEA01 != 0            /* within Extended Area */
                && BEA_TEA_balance != 1
              )
            {
                DbgPrint( "\tWarning: %s / %s unbalance\n",
                                    VSD_IDENT_BEA01, VSD_IDENT_TEA01);
            }
            BEA_TEA_balance = 0;
            cntTEA01++;
            break;
        case VsdIdentNSR02:
            cntNSR02++;
            break;
        case VsdIdentNSR03:
            cntNSR03++;
            break;
        }
    }       /* endfor */

    if( cntBEA01 != 0 )
    {
        DbgPrint( "\tEnd of Extended Area\n");
    }
    DbgPrint(    "\tEnd of Volume Recognition Sequence\n\n");

    result = TRUE;          /* check results */


    if( cntBEA01 == 0 )     /* no Extended Area */
    {
        DbgPrint( "\tError: %s Volume Recognition Sequence\n",
                        (cntTotal==0) ? "Empty" : "No Extended Area in");
        result = FALSE;
    }
    else if( prevVsdType != VsdIdentTEA01 ) /* last valid descriptor read */
    {
        DbgPrint( 
             "\tError: End of Extended Area was no %s\n"
            "-\t       Volume Recognition Sequence not properly closed\n",
                                            VSD_IDENT_TEA01);
        result = FALSE;
    }

    /* test NSR descriptors
     */
    if( cntNSR02 != 0 && cntNSR03 != 0 )
    {
        DbgPrint( "\tError: %lu %s and %lu %s descriptors found\n",
                            cntNSR02, VSD_IDENT_NSR02, cntNSR03, VSD_IDENT_NSR03);
        result = FALSE;
    }
    else if( cntNSR02 + cntNSR03 == 0 )
    {
        DbgPrint( "\tError: NSR descriptor missing\n");
        result = FALSE;
    }

    free( readbuffer );

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\readvol.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ReadVRS.cxx

Author:

    Centis Biks (cbiks) 12-Jun-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"
#include "message.hxx"

#include "crc.hxx"

BOOL
GetLengthOfDescriptor
(
    LPBYTE  d,
    PUINT   dLen
)
{
    BOOL Result = TRUE;
    USHORT TagId = ((DESTAG*) d)->Ident;

    switch( TagId ) {

        case DESTAG_ID_NSR_PVD:
            ASSERT( sizeof( NSR_PVD ) == 512);
            *dLen = sizeof( NSR_PVD );
            break;

        case DESTAG_ID_NSR_ANCHOR:
            ASSERT( sizeof( NSR_ANCHOR ) == 512);
            *dLen = sizeof( NSR_ANCHOR );
            break;

        case DESTAG_ID_NSR_VDP:
            ASSERT( sizeof( NSR_VDP ) == 512 );
            *dLen = sizeof( NSR_VDP );
            break;

        case DESTAG_ID_NSR_IMPUSE:
            ASSERT( sizeof( NSR_IMPUSE ) == 512 );
            *dLen = sizeof( NSR_IMPUSE );
            break;

        case DESTAG_ID_NSR_PART:
            ASSERT( sizeof( NSR_PART ) == 512);
            *dLen = sizeof( NSR_PART );
            break;

        case DESTAG_ID_NSR_LVOL: {

            UINT TableLen = ((PNSR_LVOL) d)->MapTableLength;
            ASSERT( offsetof( NSR_LVOL, MapTable ) == 440 );
            *dLen = offsetof( NSR_LVOL, MapTable ) + TableLen;
            break;
        }

        case DESTAG_ID_NSR_UASD: {

            UINT NmbAD = ((PNSR_UASD) d)->ExtentCount;
            ASSERT( offsetof( NSR_UASD, Extents ) == 24 );
            *dLen = offsetof( NSR_UASD, Extents ) + NmbAD * sizeof( EXTENTAD );
            break;
        }

        case DESTAG_ID_NSR_TERM:
            ASSERT( sizeof( NSR_TERM) == 512 );
            *dLen = sizeof( NSR_TERM );
            break;

        case DESTAG_ID_NSR_LVINTEG: {

            *dLen = NsrLvidSize( ((PNSR_INTEG)d));
            break;

        }

        case DESTAG_ID_NSR_FSD:
            ASSERT( sizeof( NSR_FSD ) == 512);
            *dLen = sizeof( NSR_FSD );
            break;

        case DESTAG_ID_NSR_FID: {

            ASSERT( sizeof( NSR_FID) == 38 );
            *dLen = 4 * RoundUp( sizeof( NSR_FID) + ((NSR_FID*) d)->FileIDLen + ((NSR_FID*) d)->ImpUseLen, 4 );
            break;

        }

        case DESTAG_ID_NSR_ALLOC: {

            UINT LenAD = ((PNSR_ALLOC) d)->AllocLen;
            ASSERT( sizeof( NSR_ALLOC ) == 24);
            *dLen = sizeof( NSR_ALLOC ) + LenAD;
            break;

        }

        case DESTAG_ID_NSR_ICBIND:
            ASSERT( sizeof( ICBIND ) == 52);
            *dLen = sizeof( ICBIND );
            break;

        case DESTAG_ID_NSR_ICBTRM:
            ASSERT( sizeof( ICBTRM ) == 36 );
            *dLen = sizeof( ICBTRM );
            break;

        case DESTAG_ID_NSR_FILE: {

            PICBFILE fe = (PICBFILE) d;
            ASSERT( sizeof( ICBFILE) == 176 );
            *dLen = sizeof( ICBFILE) + fe->EALength + fe->AllocLength;
            break;

        }

        case DESTAG_ID_NSR_EXT_FILE: {

            PICBEXTFILE efe = (PICBEXTFILE) d;
            ASSERT( FeEasFieldOffset( efe ) == 216 );

            *dLen = FeEasFieldOffset( efe ) + efe->EALength + efe->AllocLength;
            break;

        }

        case DESTAG_ID_NSR_EA:
            ASSERT( sizeof( NSR_EAH ) == 24 );
            *dLen = sizeof( NSR_EAH );
            break;

        case DESTAG_ID_NSR_UASE: {

            UINT LenAD = ((PICBUASE) d)->AllocLen;
            ASSERT( sizeof( ICBUASE ) == 40);
            *dLen = sizeof( ICBUASE ) + LenAD;
            break;

        }

        case DESTAG_ID_NSR_SBP: {

            UINT NmbBytes = ((NSR_SBD*) d)->ByteCount;
            ASSERT( offsetof( NSR_SBD, Bits ) == 24);
            *dLen = offsetof( NSR_SBD, Bits ) + NmbBytes;
            break;

        }

        default: {

            DbgPrint( "GetLengthOfDescriptor: Error: Unknown descriptor tagIdentifier: %u\n", TagId);
            Result = FALSE;
            break;
        }
    }

    return Result;
}

BOOL
VerifyDescriptorTag
(
    LPBYTE  buffer,
    UINT    bufferLength,
    USHORT  expectedTagId,
    PUSHORT pExportTagId
)
{
    DESTAG* DescriptorTag = (DESTAG*) buffer;
    USHORT  TagId;
    BOOL    Result = TRUE;

    //  Clear optional return arguments, if they're there.
    //
    if (pExportTagId != NULL) {
        *pExportTagId = DESTAG_ID_NOTSPEC;
    }

    if (bufferLength < sizeof( DESTAG )) {

        DbgPrint("inspectDescriptor error: buffer length: %lu, less than tag size, please report.\n",
            bufferLength );
        return FALSE;

    }

    TagId = DescriptorTag->Ident;

    if (expectedTagId == DESTAG_ID_NOTSPEC) {

        //  If the caller doesn't expect any specail Tag in return, make sure the one we found makes sense.
        //
        if (TagId < DESTAG_ID_MINIMUM_PART3 ||
            (TagId > DESTAG_ID_MAXIMUM_PART3 && TagId < DESTAG_ID_MINIMUM_PART4) ||
            TagId > DESTAG_ID_MAXIMUM_PART4_NSR03 ||
            TagId == DESTAG_ID_NSR_PINTEG) {

            DbgPrint( "Error: Unknown descriptor tag identifier: %u\n", TagId);
            return FALSE;

        }

    } else if (expectedTagId != TagId) {

        //  The Tag we found is not the Tag the caller expected.
        //
        DbgPrint( "Error: Unexpected descriptor tag id: %x expected: %x\n",
            TagId, expectedTagId );
        return FALSE;

    }

    UCHAR TagChecksum = CalculateTagChecksum( DescriptorTag );
    if ( DescriptorTag->Checksum != TagChecksum )
    {
        DbgPrint( "Tag Checksum Error: %u, expected: %u",
            DescriptorTag->Checksum, TagChecksum );
        return FALSE;
    }

    //  It looks like the descriptor is valid, so send the Tag ID back to the caller.
    //

    if ( pExportTagId != NULL ) {
        *pExportTagId = TagId;
    }

    return TRUE;
}

BOOL
VerifyDescriptor
(
    LPBYTE  buffer,
    UINT    numberOfBytesRead,
    USHORT  expectedTagId,
    USHORT* pExportTagId
)
{
    BOOL Result = VerifyDescriptorTag( buffer, numberOfBytesRead, expectedTagId, pExportTagId );
    if (Result) {

        DESTAG* DescriptorTag = (DESTAG*) buffer;
        USHORT tagId = DescriptorTag->Ident;

        UINT DescriptorLength;
        Result = GetLengthOfDescriptor( buffer, &DescriptorLength );
        if (Result) {

            if (numberOfBytesRead < DescriptorLength) {

                DbgPrint( "\tDescriptor length error: %lu, expected: %lu\n",
                    numberOfBytesRead, DescriptorLength );
                Result = FALSE;

            } else {

                USHORT ExpectedCRC = CalculateCrc( buffer + sizeof( DESTAG ), DescriptorTag->CRCLen );
                if (DescriptorTag->CRC != ExpectedCRC) {

                    DbgPrint( "\tDescriptor CRC error: %u, expected: %u\n",
                        DescriptorTag->CRC, ExpectedCRC );
                    Result = FALSE;

                }

            }

        }

    }

    return Result;
}

BOOL
UDF_SA::ReadAnchorVolumeDescriptorPointer
(
    UINT        Sector,
    PNSR_ANCHOR NsrAnchorFound
)
{
    BOOL Result = FALSE;

    HMEM SecrunMemory;
    if (!SecrunMemory.Initialize()) {
        
        return FALSE;

    }

    SECRUN Secrun;
    if (!Secrun.Initialize( &SecrunMemory, _drive, Sector, 1 )) {

        return FALSE;

    }

    if (Secrun.Read()) {

        PNSR_ANCHOR NsrAnchorInSecRun = (PNSR_ANCHOR) Secrun.GetBuf();

        if (!VerifyDescriptor( (LPBYTE) NsrAnchorInSecRun, QuerySectorSize(), DESTAG_ID_NSR_ANCHOR, NULL )) {

            DbgPrint( "\tNo correct AVDP found here\n" );

        } else {

            *NsrAnchorFound = *NsrAnchorInSecRun;
            Result = TRUE;

        }
    }

    return Result;
}

static BOOL
CompareAnchorVolumeDescriptorPointers
(
    PNSR_ANCHOR NsrAnchor1,
    PNSR_ANCHOR NsrAnchor2
)
{
    BOOL Result = FALSE;

    if ( memcmp( &NsrAnchor1->Main, &NsrAnchor2->Main, sizeof( EXTENTAD ) ) == 0 &&
        memcmp( &NsrAnchor1->Reserve, &NsrAnchor2->Reserve, sizeof( EXTENTAD ) ) == 0 ) {

        Result = TRUE;

    } else {

        DbgPrint( "\tAVDP error: Volume Descriptor Sequence Extent not equal to\n"
            "-\t\t    the one read in first AVDP\n"
            "-\t\t       Main VDSE: %3lu, %-5lu expected:  %3lu, %-5lu\n"
            "-\t\t    Reverve VDSE: %3lu, %-5lu expected:  %3lu, %-5lu\n"
            "-\tUsing first AVDP\n",
            NsrAnchor1->Main.Len, NsrAnchor1->Main.Lsn,
            NsrAnchor2->Main.Len, NsrAnchor2->Main.Lsn,
            NsrAnchor1->Reserve.Len, NsrAnchor1->Reserve.Lsn,
            NsrAnchor2->Reserve.Len, NsrAnchor2->Reserve.Lsn );

    }

    return Result;
}

BOOL
UDF_SA::GetAnchorVolumeDescriptorPointer
(
    PNSR_ANCHOR         pavdp
)
{
    BOOL Result = TRUE;
    INT MismatchCount = 0;
    INT AnchorCount = 0;

    NSR_ANCHOR NsrAnchor1;
    BOOL FoundNsrAnchor1 = FALSE;
    if (ReadAnchorVolumeDescriptorPointer( 256, &NsrAnchor1 ))
    {
        FoundNsrAnchor1 = TRUE;
        AnchorCount++;

        *pavdp = NsrAnchor1;
    }

    UINT LastSector = _drive->QuerySectors().GetLowPart();

    NSR_ANCHOR NsrAnchor2;
    BOOL FoundNsrAnchor2 = FALSE;
    if (ReadAnchorVolumeDescriptorPointer( LastSector - 256, &NsrAnchor2 ))
    {
        if (FoundNsrAnchor1)
        {
            if (!CompareAnchorVolumeDescriptorPointers( &NsrAnchor1, &NsrAnchor2 ))
            {
                MismatchCount++;
            }
        }

        FoundNsrAnchor2 = TRUE;
        AnchorCount++;
    }

    NSR_ANCHOR NsrAnchor3;
    if (ReadAnchorVolumeDescriptorPointer( LastSector, &NsrAnchor3 ))
    {
        if (FoundNsrAnchor1) {

            if (!CompareAnchorVolumeDescriptorPointers( &NsrAnchor1, &NsrAnchor3 )) {
                MismatchCount++;
            }

        } else if (FoundNsrAnchor2) {

            if (!CompareAnchorVolumeDescriptorPointers( &NsrAnchor2, &NsrAnchor3 )) {
                MismatchCount++;
            }

        }

        AnchorCount++;
    }

    //  If we found at least one of the anchors, or we found more and they are the same, then the
    //  anchors are ok.
    //
    if ((AnchorCount > 0) && (MismatchCount == 0)) {

        Result = TRUE;

    }

    //  UNDONE, CBiks, 06/08/2000
    //      Make sure these cases are handled properly.
    //
    ASSERT( (FoundNsrAnchor1 == TRUE) && (Result == TRUE) );

    DbgPrint( "Read Main VDS extent: %7lu, length: %6lu\n",
        _NsrAnchor.Main.Lsn, _NsrAnchor.Main.Len );

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\scanads.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ScanADs.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"

DEFINE_CONSTRUCTOR( SCAN_ALLOCTION_DESCRIPTORS, OBJECT );

BOOL
SCAN_ALLOCTION_DESCRIPTORS::Initialize
(
    PUDF_LVOL   UdfLVol,
    PICBFILE    FileIcbEntry
)
{
    BOOL Result = TRUE;

    _AdType = 0;
    _AllocationDescriptors = NULL;
    _AllocationDescriptorLength = 0;
    _AllocDescOffset = 0;
    _ReadBuffer = NULL;
    _SectorSize = 0;
    _UdfLVol = NULL;

    ASSERTMSG( "Unimplemented AD Type.\n",
        (FileIcbEntry->Icbtag.Flags & ICBTAG_F_ALLOC_MASK) == ICBTAG_F_ALLOC_SHORT );

    _AdType = FileIcbEntry->Icbtag.Flags & ICBTAG_F_ALLOC_MASK;

    _AllocationDescriptors = (LPBYTE)( FileIcbEntry ) + FeEasFieldOffset( FileIcbEntry ) + FeEaLength( FileIcbEntry );
    _AllocationDescriptorLength = FeAllocLength( FileIcbEntry );

    _UdfLVol = UdfLVol;
    _SectorSize = _UdfLVol->QuerySectorSize();

    _ReadBuffer = (LPBYTE) malloc( _SectorSize );

    return TRUE;
}

BOOL
SCAN_ALLOCTION_DESCRIPTORS::Next
(
    PULONG  StartBlockNum,
    PULONG  Length,
    PSHORT  Type
)
{
    BOOL Result = FALSE;

    if (_AllocDescOffset < _AllocationDescriptorLength) {

        PSHORTAD ShortAd = (PSHORTAD)( _AllocationDescriptors + _AllocDescOffset );

        *StartBlockNum = ShortAd->Start;
        *Length = ShortAd->Length.Length;
        *Type = ShortAd->Length.Type;

        if (*Length != 0) {

            if (*Type == NSRLENGTH_TYPE_CONTINUATION) {

                if (RoundUp( *Length, _SectorSize ) != 1) {

                    //  UDF 2.01/2.3.11 - The length of an extent of Allocation Descriptors shall not exceed
                    //      the logical block size.
                    //

                    Result = FALSE;

                } else {

                    Result = _UdfLVol->Read( *StartBlockNum, 1, _ReadBuffer );
                    if (Result) {

                        Result = _UdfLVol->MarkBlocksUsed( *StartBlockNum, 1 );

                        Result = VerifyDescriptor( _ReadBuffer, _SectorSize, DESTAG_ID_NSR_ALLOC, NULL );
                        if (Result) {

                            PNSR_ALLOC NsrAlloc = (PNSR_ALLOC) _ReadBuffer;

                            _AllocationDescriptors = _ReadBuffer + sizeof( NSR_ALLOC );
                            _AllocDescOffset = 0;
                            _AllocationDescriptorLength = NsrAlloc->AllocLen;
                
                            ShortAd = (PSHORTAD)( _AllocationDescriptors + _AllocDescOffset );

                            *StartBlockNum = ShortAd->Start;
                            *Length = ShortAd->Length.Length;
                            *Type = ShortAd->Length.Type;

                            _AllocDescOffset += sizeof( SHORTAD );

                        }

                    }

                }

            } else {

                _AllocDescOffset += sizeof( SHORTAD );

            }

        }

        Result = TRUE;

    }

    if (*Length == 0) {

        //  UNDONE, CBiks, 8/3/2000
        //      This code assumes a zero length means the end of the ADs.  Is that ok???
        //
        //  Try to catch the case where we reach the end of the AD's, but there are more blocks
        //  allocated that we have not read or marked as allocated.  For example, this code detects the
        //  end of the AD's because a length is zero, but the _AllocationDescriptorLength says there
        //  are more blocks allocated to this AD chain.  This should not happen because UDF says
        //  the AD's must all fit on one page...
        //

        ASSERTMSG( "End of AD's reached, but more blocks are allocated.",
            _AllocationDescriptorLength < _SectorSize );

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\scanfids.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ScanFIDs.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"
#include "ScanFIDs.hxx"

DEFINE_CONSTRUCTOR( SCAN_FIDS, OBJECT );

BOOL
SCAN_FIDS::Initialize
(
    PUDF_LVOL   UdfLVol,
    PICBFILE    FileIcbEntry
)
{
    BOOL Result = TRUE;

    _BytesRemainingInExtent = 0;
    _ReadBufferSize = 0;
    _ReadBuffer = NULL;
    _LogicalBlockNum = 0;
    _BufferOffset = 0;
    _BytesRemainingInBuffer = 0;

    _PreviousReadSize = 0;

    _SectorSize = 0;
    _UdfLVol = NULL;

    Result = _AllocationDescriptors.Initialize( UdfLVol, FileIcbEntry );
    if (Result) {

        _UdfLVol = UdfLVol;
        _SectorSize = _UdfLVol->QuerySectorSize();

        _ReadBufferSize = _SectorSize * 2;
        _ReadBuffer = (LPBYTE) malloc( _ReadBufferSize );

        ULONG   StartBlockNum;
        ULONG   Length;
        SHORT   Type;

        if (_AllocationDescriptors.Next( &StartBlockNum, &Length, &Type)) {

            if (Length > 0) {

                _BytesRemainingInExtent = Length;
                _LogicalBlockNum = StartBlockNum;

                UINT NumberOfBlocks = __min( 2, (_BytesRemainingInExtent + _SectorSize - 1) / _SectorSize );

                BOOL result = _UdfLVol->Read( StartBlockNum, NumberOfBlocks, _ReadBuffer );
                if (result) {

                    Result = _UdfLVol->MarkBlocksUsed( StartBlockNum, NumberOfBlocks );

                    _LogicalBlockNum += NumberOfBlocks;
                    _BufferOffset = 0;
                    _BytesRemainingInBuffer = __min( _ReadBufferSize, _BytesRemainingInExtent );

                }

            }

        }

    }

    return Result;
}

LPBYTE
SCAN_FIDS::ProbeRead
(
    ULONG ReadSize
)
{
    LPBYTE BufferPtr = NULL;

    if (ReadSize > _BytesRemainingInBuffer) {

        if (ReadSize > _BytesRemainingInExtent) {

            ULONG   StartBlockNum;
            ULONG   Length;
            SHORT   Type;

            if (_AllocationDescriptors.Next( &StartBlockNum, &Length, &Type)) {

                if (Length > 0) {

                    if (Type == NSRLENGTH_TYPE_RECORDED) {

                        _LogicalBlockNum = StartBlockNum;
                        _BytesRemainingInExtent += Length;

                    } else if (Type == NSRLENGTH_TYPE_UNRECORDED) {

                        BOOL result = _UdfLVol->MarkBlocksUsed( StartBlockNum, RoundUp( Length, _SectorSize ) );

                    } else {

                        ASSERTMSG( "Unsupported length type",
                            0 );

                    }

                }

            }

        }

        if (ReadSize < _BytesRemainingInExtent) {

            memmove( _ReadBuffer, _ReadBuffer + _SectorSize, _SectorSize );

            BOOL result = _UdfLVol->Read( _LogicalBlockNum, 1, _ReadBuffer + _SectorSize );

            if (result) {

                result = _UdfLVol->MarkBlocksUsed( _LogicalBlockNum, 1 );

                _LogicalBlockNum += 1;

                _BufferOffset -= _SectorSize;
                _BytesRemainingInBuffer = __min( _BytesRemainingInBuffer + _SectorSize, _BytesRemainingInExtent );

                BufferPtr = _ReadBuffer + _BufferOffset;

            }

        }

    }

    if (ReadSize <= _BytesRemainingInBuffer) {

        BufferPtr = _ReadBuffer + _BufferOffset;

    }

    return BufferPtr;
}

BOOL
SCAN_FIDS::Next
(
    PNSR_FID* NsrFid
)
{
    BOOL Result = FALSE;

    if (_PreviousReadSize != 0) {

        LPBYTE BufferPtr = ProbeRead( _PreviousReadSize );
        if (BufferPtr != NULL) {

            _BufferOffset += _PreviousReadSize;
            _BytesRemainingInBuffer -= _PreviousReadSize;
            _BytesRemainingInExtent -= _PreviousReadSize;
            _PreviousReadSize = 0;

        }

    }

    LPBYTE BufferPtr = ProbeRead( sizeof( DESTAG ) );
    if (BufferPtr != NULL) {

        Result = VerifyDescriptorTag( BufferPtr, sizeof( DESTAG ), DESTAG_ID_NSR_FID, NULL );
        if (Result) {

            BufferPtr = ProbeRead( sizeof( NSR_FID) );
            if (BufferPtr != NULL) {

                BufferPtr = ProbeRead( ISONsrFidSize( PNSR_FID( BufferPtr ) ) );

                Result = VerifyDescriptor( BufferPtr, ISONsrFidSize( PNSR_FID( BufferPtr ) ), DESTAG_ID_NSR_FID, NULL );
                if (Result) {

                    _PreviousReadSize = ISONsrFidSize( PNSR_FID( BufferPtr ) );
                    *NsrFid = PNSR_FID( BufferPtr );

                }

            }

        }

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\udfchk.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    udfsa.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"
#include "message.hxx"
#include "unicode.hxx"

#include "stdio.h"

BOOLEAN
UDF_SA::VerifyAndFix(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       DesiredLogFileSize,
    IN      USHORT      Algorithm,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine verifies and, if necessary, fixes a UDF volume.

Arguments:

    FixLevel            - Supplies the level of fixes that may be performed on
                            the disk.
    Message             - Supplies an outlet for messages.
    Flags               - Supplies flags to control behavior of chkdsk
                          (see ulib\inc\ifsentry.hxx for details)
    DesiredLogFileSize  - Supplies the desired logfile size in bytes, or 0 if
                            the logfile is to be resized to the default size.
    Algorithm           - Supplies the algorithm to use for index verification
    ExitStatus          - Returns an indication of how the checking went
    DriveLetter         - For autocheck, the letter for the volume we're checking

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!ReadVolumeRecognitionSequence()) {

        DbgPrint( "\tUDF_SA::VerifyAndFix() : ReadVolumeRecognitionSequence() failed\n\n" );

    }

    if (!GetAnchorVolumeDescriptorPointer( &_NsrAnchor )) {

        return FALSE;

    }

    PNSR_PVD PrimaryVolumeDescriptor;
    FindVolumeDescriptor( DESTAG_ID_NSR_PVD, (LPBYTE*) &PrimaryVolumeDescriptor );

    if ((PrimaryVolumeDescriptor->VolSetSeq == 1) && (PrimaryVolumeDescriptor->VolSetSeqMax == 1)) {

        PNSR_PART PartitionDescriptor;
        FindVolumeDescriptor( DESTAG_ID_NSR_PART, (LPBYTE*) &PartitionDescriptor );

        PNSR_LVOL LogicalVolumeDescriptor;
        FindVolumeDescriptor( DESTAG_ID_NSR_LVOL, (LPBYTE*) &LogicalVolumeDescriptor );

        USHORT UdfVersion = ((PUDF_SUFFIX_UDF) &LogicalVolumeDescriptor->DomainID.Suffix)->UdfRevision;

        if ((UdfVersion ==UDF_VERSION_100) || (UdfVersion == UDF_VERSION_101) || (UdfVersion == UDF_VERSION_102) ||
            (UdfVersion == UDF_VERSION_150) || (UDF_VERSION_200 == UdfVersion) || (UdfVersion == UDF_VERSION_201)) {

            DSTRING VolumeID;
            UncompressDString( (LPBYTE) LogicalVolumeDescriptor->VolumeID, sizeof( LogicalVolumeDescriptor->VolumeID ), &VolumeID );

            WCHAR PrintableVersion[ 32 ];
            wsprintf( PrintableVersion, L"%d.%02d", HIBYTE( UdfVersion ), LOBYTE( UdfVersion ) );

            Message->Set( MSG_UDF_VOLUME_INFO );
            Message->Display( "%W%ws", &VolumeID, PrintableVersion );


            //  UNDONE, CBiks, 7/15/2000
            //      Read the reserve VDS and make sure it's the same as the main.
            //

            //
            //
            //

            UDF_LVOL UdfLVol;

            UdfLVol.Initialize( this, Message, LogicalVolumeDescriptor, PartitionDescriptor );

            if (!UdfLVol.CheckFileStructure()) {

                DbgPrint( " checkVolume error: checkFileStructure fails\n" );
                return FALSE;

            }

        } else {

            Message->Set( MSG_UDF_VERSION_UNSUPPORTED );
            Message->Display( "%W", DriveLetter );

        }

        free( LogicalVolumeDescriptor );
        LogicalVolumeDescriptor = NULL;

        free( PartitionDescriptor );
        PartitionDescriptor = NULL;

    }

    free( PrimaryVolumeDescriptor );
    PrimaryVolumeDescriptor = NULL;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\udflvol.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    UdfLVol.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"
#include "ScanFIDs.hxx"
#include "unicode.hxx"

DEFINE_CONSTRUCTOR( UDF_LVOL, OBJECT );

VOID
UDF_LVOL::Construct (
    )
/*++

Routine Description:

    This routine sets a UDF_LVOL to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}

VOID
UDF_LVOL::Destroy(
    )
/*++

Routine Description:

    This routine returns an UDF_LVOL to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


UUDF_EXPORT
UDF_LVOL::~UDF_LVOL(
    )
/*++

Routine Description:

    Destructor for UDF_LVOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

BOOLEAN
UDF_LVOL::Initialize
(
    IN      PUDF_SA     UdfSA,
    IN OUT  PMESSAGE    Message,
    IN      PNSR_LVOL   LogicalVolumeDescriptor,
    IN      PNSR_PART   PartitionDescriptor
)
{
    BOOLEAN Result = FALSE;

    _UdfSA = UdfSA;
    _Message = Message;
    _LogicalVolumeDescriptor = LogicalVolumeDescriptor;
    _PartitionDescriptor = PartitionDescriptor;

    UINT BlocksRead = 0;
    USHORT TagID = DESTAG_ID_NOTSPEC;
    if (!_UdfSA->ReadDescriptor( _LogicalVolumeDescriptor->Integrity.Lsn, &BlocksRead, DESTAG_ID_NSR_LVINTEG, &TagID,
        (LPBYTE*)( &_LogicalVolumeIntegrityDescriptor ) )) {

        return FALSE;

    }

    ASSERTMSG( "Only a single LVID should be present.\n",
        _LogicalVolumeIntegrityDescriptor->Next.Len == 0 );

    if (_LogicalVolumeIntegrityDescriptor->Type != 1) {

        Message->DisplayMsg( MSG_UDF_VOLUME_NOT_CLOSED );

    }

    _LogicalVolumeIntegrityDescriptor->Type = 1;

    //Write( 


    //  As we run we build up a new allocation bitmap so we can see if the one on the disk is ok.
    //

    ULONG NewSpaceBitmapDescriptorByteCount = RoundUp( PartitionDescriptor->Length, CHAR_BIT );
    ULONG NewSpaceBitmapDescriptorSize = sizeof( NSR_SBD ) +  NewSpaceBitmapDescriptorByteCount;

    _NewSpaceBitmapDescriptor = (PNSR_SBD) malloc( NewSpaceBitmapDescriptorSize );
    if (_NewSpaceBitmapDescriptor == NULL) {

        //  UNDONE, CBiks, 8/4/2000
        //      Not enough memory for the bitmap - what should we really do?

        return FALSE;

    } else {

        memset( &_NewSpaceBitmapDescriptor->Destag, '\0', sizeof( DESTAG ) );
        _NewSpaceBitmapDescriptor->BitCount = PartitionDescriptor->Length;
        _NewSpaceBitmapDescriptor->ByteCount = NewSpaceBitmapDescriptorByteCount;

        for ( ULONG i = 0; i < _NewSpaceBitmapDescriptor->ByteCount; i++ ) {

            _NewSpaceBitmapDescriptor->Bits[ i ] = (UCHAR) 0xff;

        }

    }

    //
    //
    //

    if (!ReadSpaceBitmapDescriptor()) {

        return FALSE;

    }

    if (!ReadFileSetDescriptor()) {

        return FALSE;

    }

    return Result;
}

ULONG
UDF_LVOL::QuerySectorSize() CONST
{
    return _UdfSA->QuerySectorSize();
}

BOOL
UDF_LVOL::Read
(
    IN  ULONG       StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
)
{
    ULONGLONG AbsoluteSectorNum = TranslateBlockNum( StartingSector, 0 );
    return _UdfSA->Read( AbsoluteSectorNum, NumberOfSectors, Buffer );
}

BOOL
UDF_LVOL::Write
(
    IN  ULONG       StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
)
{
    ULONGLONG AbsoluteSectorNum = TranslateBlockNum( StartingSector, 0 );
    return _UdfSA->Write( AbsoluteSectorNum, NumberOfSectors, Buffer );
}

ULONGLONG
UDF_LVOL::TranslateBlockNum
(
    ULONG       Lbn,
    USHORT      Partition
)
{
    UINT PhysicalBlockAddress = Lbn;

    PPARTMAP_GENERIC CurrentPartMapHeader = (PPARTMAP_GENERIC)( &_LogicalVolumeDescriptor->MapTable );
    ULONG CurrentPartMapNum = 0;

    while ( CurrentPartMapNum < _LogicalVolumeDescriptor->MapTableCount ) {

        if ( CurrentPartMapNum == Partition ) {

            if ( CurrentPartMapHeader->Type == PARTMAP_TYPE_PHYSICAL ) {

                PPARTMAP_PHYSICAL PartMapPhysical = (PPARTMAP_PHYSICAL) CurrentPartMapHeader;

                if ( _PartitionDescriptor->Number == PartMapPhysical->Partition ) {

                    PhysicalBlockAddress += _PartitionDescriptor->Start;
                    break;
                }

            }

        }

        CurrentPartMapNum++;
        CurrentPartMapHeader = (PPARTMAP_GENERIC)( (LPBYTE)( CurrentPartMapHeader ) + CurrentPartMapHeader->Length );

    }

    return PhysicalBlockAddress;
}

BOOL
UDF_LVOL::ReadFileSetDescriptor()
{
    BOOL result = TRUE;

    PLONGAD FSDExtent = &_LogicalVolumeDescriptor->FSD;
    ULONG   BlocksToRead = RoundUp( FSDExtent->Length.Length, QuerySectorSize() );

    ULONGLONG ExtentPosition = TranslateBlockNum( FSDExtent->Start.Lbn, FSDExtent->Start.Partition  );

    SECTORCOUNT FSDBlockSize = 0;

    while (result && (FSDBlockSize < BlocksToRead)) {

        UINT    BlocksInThisDescriptor = 0;
        LPBYTE  Descriptor = NULL;
        USHORT  tagId = 0;

        result = _UdfSA->ReadDescriptor( ExtentPosition, &BlocksInThisDescriptor, DESTAG_ID_NOTSPEC, &tagId, &Descriptor );
        if (result) {

            switch (tagId) {

                case DESTAG_ID_NSR_FSD: {

                    _FileSetDescriptor = (PNSR_FSD) Descriptor;

                    FSDBlockSize += BlocksInThisDescriptor;
                    ExtentPosition += BlocksInThisDescriptor;

                    ASSERTMSG( "Only a single FSD should be present.",
                        (_FileSetDescriptor)->NextExtent.Length.Length == 0 );
                    break;

                }

                case DESTAG_ID_NSR_TERM: {

                    free( Descriptor );

                    FSDBlockSize += BlocksInThisDescriptor;
                    ExtentPosition += BlocksInThisDescriptor;
                    break;

                 }

                default: {

                    result = false;
                    break;

                }

            }

        }

    }

    if (result) {

        if (_FileSetDescriptor != NULL) {

            //  The File Set Descriptor is in the partition, so if it's ok, mark the space as used.
            //
            result = MarkBlocksUsed( FSDExtent->Start.Lbn, FSDBlockSize );

        } else {

            result = FALSE;

        }

    } else {

        if ((_FileSetDescriptor) != NULL) {
    
            free( _FileSetDescriptor );
            _FileSetDescriptor = NULL;

        }

    }

    return result;
}

BOOL
UDF_LVOL::ReadSpaceBitmapDescriptor()
{
    BOOL Result = TRUE;

    NSR_PART_H* phd = (NSR_PART_H*) &_PartitionDescriptor->ContentsUse;

    ASSERTMSG( "Unallocated Space Table unsupported", phd->UASTable.Length.Length == 0 );
    ASSERTMSG( "Freed Space Table unsupported", phd->FreedTable.Length.Length == 0 );
    ASSERTMSG( "Freed Bitmap unsupported", phd->FreedBitmap.Length.Length == 0 );

    if (phd->UASBitmap.Length.Length != 0) {

        ULONGLONG   ExtentPosition = TranslateBlockNum( phd->UASBitmap.Start, 0 );
        UINT        BlocksRead = 0;
        USHORT      TagId;

        Result = _UdfSA->ReadDescriptor( ExtentPosition, &BlocksRead, DESTAG_ID_NSR_SBP, &TagId, (LPBYTE*) &_SpaceBitmapDescriptor );
        if (Result) {

            if (_SpaceBitmapDescriptor->BitCount != _PartitionDescriptor->Length) {

                DbgPrint( "Space Bitmap Descriptor Error: Inconsistent Space Bitmap NumberOfBits and partition size: %lu, %lu.\n",
                    _SpaceBitmapDescriptor->BitCount, _PartitionDescriptor->Length );

                Result = FALSE;

            }

            if (Result) {

                //  The Space Bitmap Descriptor is in the partition, so if it's ok, mark the space as used.
                //
                Result = MarkBlocksUsed( phd->UASBitmap.Start, BlocksRead );

            } else {

                free( _SpaceBitmapDescriptor );
                _SpaceBitmapDescriptor = NULL;

            }

        }

    }

    return Result;
}

BOOL
UDF_LVOL::MarkBlocksUsed
(
    IN  ULONGLONG   StartingSector,
    IN  SECTORCOUNT NumberOfSectors
)
{
    BOOL Result = TRUE;

#if DBG
    static int  BreakOnSector = 0;
    static BOOL BreakOnSectorEnabled = FALSE;

    if (BreakOnSectorEnabled) {

        if ((BreakOnSector >= StartingSector) && (BreakOnSector < (StartingSector + NumberOfSectors)) ) {

            DebugBreak();

        }
    }
#endif DBG

    for ( ULONGLONG BlockNum = StartingSector; BlockNum < (StartingSector + NumberOfSectors); BlockNum++ ) {

        ASSERTMSG( "Cross linked clusters detected",
            (_NewSpaceBitmapDescriptor->Bits[ (BlockNum / CHAR_BIT) ] & (1 << (BlockNum % CHAR_BIT))) != 0 );

        _NewSpaceBitmapDescriptor->Bits[ (BlockNum / CHAR_BIT) ] &= ~(1 << (BlockNum % CHAR_BIT));

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\udfsa.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    udfsa.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>


DEFINE_EXPORTED_CONSTRUCTOR( UDF_SA, SUPERAREA, UUDF_EXPORT );

VOID
UDF_SA::Construct (
    )
/*++

Routine Description:

    This routine sets a UDF_SA to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}

VOID
UDF_SA::Destroy(
    )
/*++

Routine Description:

    This routine returns an UDF_SA to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


UUDF_EXPORT
UDF_SA::~UDF_SA(
    )
/*++

Routine Description:

    Destructor for UDF_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

UUDF_EXPORT
BOOLEAN
UDF_SA::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE            Message,
    IN      USHORT              FormatUDFRevision
    )
/*++

Routine Description:

    This routine returns an UDF_SA to a default initial state.

    If the caller needs to format this volume, then this method should
    be called with the Formatted parameter set to FALSE.

Arguments:

    None.

        Drive       - Supplies the drive where the super area resides.
        Message     - Supplies an outlet for messages
        Formatted   - Supplies a boolean which indicates whether or not
                      the volume is formatted.

Return Value:

    None.

--*/
{
    Destroy();

    DebugAssert(Drive);
    DebugAssert(Message);

    _FormatUDFRevision = FormatUDFRevision;

    return SUPERAREA::Initialize( &_hmem, Drive, 1, Message );
}

PARTITION_SYSTEM_ID
UDF_SA::QuerySystemId(
    ) CONST
/*++

Routine Description:

    This routine computes the system ID for the volume.

Arguments:

    None.

Return Value:

    The system ID for the volume.

--*/
{
        //  Unreferenced parameters
        (void)(this);

        return SYSID_IFS;
}

BOOLEAN
UDF_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine recovers a file on the disk.

Arguments:

    FullPathFileName    - Supplies the file name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return FALSE;
}

ULONG
UDF_SA::QuerySectorSize() CONST
{
    return _drive->QuerySectorSize();
}

BOOL
UDF_SA::Read
(
    IN  ULONGLONG   StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
)
{
    return _drive->Read( StartingSector, NumberOfSectors, Buffer );
}

BOOL
UDF_SA::Write
(
    IN  ULONGLONG   StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
)
{
    return _drive->Write( StartingSector, NumberOfSectors, Buffer );
}

BOOL
UDF_SA::ReadDescriptor
(
    ULONGLONG   blockNr,
    UINT*       pNrBlocksRead,
    USHORT      expectedTagId,
    USHORT*     pTagId,
    LPBYTE*     pMem
)
{
    *pTagId = DESTAG_ID_NOTSPEC;
    *pMem   = NULL;
    *pNrBlocksRead = 0;


    LPBYTE readbuffer = (LPBYTE) malloc( QuerySectorSize() );
    if ( readbuffer == NULL ) {

        return FALSE;

    }

    if (!Read( blockNr, 1, readbuffer )) {

        DbgPrint( "ReadDescriptor(): Error reading logical block %lu\n", blockNr);
        free( readbuffer );
        return FALSE;

    }

    *pNrBlocksRead = 1;

    /* Check unswapped head of descriptor for recognition and
     * determination of descriptor length.
     */
    if (!VerifyDescriptorTag( readbuffer, QuerySectorSize(), expectedTagId, pTagId )) {

        DbgPrint( "\tReadDescriptor: inspect descriptor error\n");
        free(readbuffer);
        return FALSE;

    }

    //  Get the length of the descriptor.
    //
    UINT DescriptorLength;
    if (!GetLengthOfDescriptor( readbuffer, &DescriptorLength )) {

        return FALSE;

    }

    UINT blocksToRead = RoundUp( DescriptorLength, QuerySectorSize() );

    if (blocksToRead != 1) {

        *pMem = readbuffer;     /* save for reallocation */

        readbuffer = (LPBYTE) realloc( readbuffer, blocksToRead * QuerySectorSize() );
        if ( readbuffer == NULL ) {

            free( *pMem );
            *pMem = NULL;
            return FALSE;

        }

        if (!Read( blockNr + 1, blocksToRead - 1, readbuffer + QuerySectorSize() )) {

            DbgPrint( "ReadDescriptor(): Error reading logical block %lu ...\n", blockNr+1);
            free( readbuffer );
            return FALSE;

        }

        *pNrBlocksRead = blocksToRead;
    }

    if (!VerifyDescriptor( readbuffer, blocksToRead * QuerySectorSize(), expectedTagId, pTagId )) {

        DbgPrint( "\tDescriptor error\n");
        free(readbuffer);
        return FALSE;

    }

    *pMem = readbuffer;
    return TRUE;
}

BOOL
UDF_SA::FindVolumeDescriptor
(
    USHORT      TagID,
    LPBYTE*     DescriptorFound
)
{
    return FindVolumeDescriptor( TagID, _NsrAnchor.Main.Lsn, _NsrAnchor.Main.Len, DescriptorFound );
}

BOOL
UDF_SA::FindVolumeDescriptor
(
    USHORT      TagID,
    ULONGLONG   ExtentStart,
    UINT        ExtentLength,
    LPBYTE*     DescriptorFound
)
{
    BOOL Result = FALSE;

    *DescriptorFound = NULL;

    LPBYTE ReadBuffer = (LPBYTE) malloc( QuerySectorSize() );
    if (ReadBuffer != NULL) {

        ULONGLONG CurrentBlock = ExtentStart;
        while ((CurrentBlock < (ExtentStart + ExtentLength)) && (*DescriptorFound == NULL)) {

            Result = Read( CurrentBlock, 1, ReadBuffer );
            if (Result) {

                USHORT TagIDRead;
                Result = VerifyDescriptor( ReadBuffer, QuerySectorSize(), DESTAG_ID_NOTSPEC, &TagIDRead );
                if (Result) {

                    UINT BytesToRead;
                    Result = GetLengthOfDescriptor( ReadBuffer, &BytesToRead );
                    if (Result) {

                        UINT BlocksToRead = RoundUp( BytesToRead, QuerySectorSize() );
                        if (TagIDRead == TagID) {

                            if (BlocksToRead > 1) {

                                ReadBuffer = (LPBYTE) realloc( ReadBuffer, QuerySectorSize() * BlocksToRead );
                                if (ReadBuffer != NULL) {

                                    Result = Read( CurrentBlock, BlocksToRead, ReadBuffer );

                                }

                            }

                            if (Result) {

                                *DescriptorFound = ReadBuffer;

                            }

                        } else {

                            if (TagIDRead == DESTAG_ID_NSR_VDP) {

                                PNSR_VDP VolumeDescriptorPointer = (PNSR_VDP) ReadBuffer;

                                DbgPrint( "Next VDS extent: %7lu, length: %6lu\n",
                                    VolumeDescriptorPointer->Next.Lsn, VolumeDescriptorPointer->Next.Len );

                                Result = FindVolumeDescriptor( TagID, VolumeDescriptorPointer->Next.Lsn, VolumeDescriptorPointer->Next.Len,
                                    DescriptorFound );

                            }

                            CurrentBlock += BlocksToRead;

                        }

                    }

                }

            }

        }

    }

    return Result;
}


VOID
UDF_SA::PrintFormatReport (
    IN OUT PMESSAGE                             Message,
    IN     PFILE_FS_SIZE_INFORMATION            FsSizeInfo,
    IN     PFILE_FS_VOLUME_INFORMATION          FsVolInfo
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\sources.inc ===
!IF 0

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

TARGETNAME=uudf
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(PROJECT_LIB_PATH)\patchbc.lib \
           $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib    \
           $(PROJECT_ROOT)\fs\utils\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib

USE_MSVCRT=1
DLLENTRY=InitializeUUDF
PRECOMPILED_INCLUDE= ..\pch.cxx
MSC_WARNING_LEVEL=/W3 /WX

SOURCES= ..\CheckFileStruct.cxx \
         ..\crc.cxx \
         ..\entry.cxx \
         ..\format.cxx \
         ..\ReadVol.cxx \
         ..\ReadVRS.cxx \
         ..\ScanADs.cxx \
         ..\ScanFIDs.cxx \
         ..\udfchk.cxx \
         ..\UdfLVol.cxx \
         ..\udfsa.cxx \
         ..\udfvol.cxx \
         ..\unicode.cxx \
         ..\uudf.cxx \
         ..\uudf.rc \
         ..\VerifySBDAllocation.cxx

INCLUDES=..\.;			\
	 ..\..\inc;		\
	 $(PROJECT_ROOT)\fs\utils\ulib\inc;	\
         $(PROJECT_ROOT)\fs\utils\ifsutil\inc;	\
	 $(PROJECT_ROOT)\fs\udfsrw;		\
	 $(DDK_INC_PATH)

C_DEFINES=/DUNICODE=1
!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console
DLLDEF=..\uudf.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\uudf.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        uudf.cxx

Abstract:

        This module contains run-time, global support for the
        UDF IFS Utilities library (UUDF).  This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Centis Biks (cbiks) 08-May-2000
        
Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

STATIC
BOOLEAN
DefineClassDescriptors(
    )
{
    return TRUE;
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    return TRUE;
}

extern "C"
BOOLEAN
InitializeUUDF (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Uudf by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#ifdef _AUTOCHECK_

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "UUDF initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_UUDF_MEM_LEAK)
    DebugPrint("UUDF.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
#if 0
            //
            // Get translated boot messages into FAT boot code.
            //
            if(!PatchNtfsBootCodeMessages()) {
                //
                // Internal error only, don't worry about translating it.
                //
                MessageBoxA(
                    NULL,
                    "Internal error: Translated boot messages are too long or missing.",
                    "ULIB.DLL (UNTFS.DLL)",
                    MB_ICONERROR | MB_SYSTEMMODAL | MB_OK
                    );

                DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
                return(FALSE);
            }
            #endif

            // Success, FALL THROUGH to thread attach case

        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrintTrace(("UNTFS.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Untfs initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_UNTFS_MEM_LEAK)
            DebugPrint("UNTFS.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrintTrace(("UNTFS.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrint("UNTFS.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrint("UNTFS.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif // _AUTOCHECK_

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\udfvol.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    udfvol.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include "message.hxx"
#include "rtmsg.h"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( UDF_VOL, VOL_LIODPDRV );

VOID
UDF_VOL::Construct (
    )

/*++

Routine Description:

    Constructor for UDF_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}

VOID
UDF_VOL::Destroy(
    )
/*++

Routine Description:

    This routine returns a NTFS_VOL object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}

UUDF_EXPORT
UDF_VOL::~UDF_VOL(
    )
/*++

Routine Description:

    Destructor for UDF_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UUDF_EXPORT
FORMAT_ERROR_CODE
UDF_VOL::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatUDFRevision
    )
/*++

Routine Description:

    This routine initializes a UDF_VOL object.

Arguments:

    NtDriveName         - Supplies the drive path for the volume.
    Message             - Supplies an outlet for messages.
    ExclusiveWrite      - Supplies whether or not the drive should be
                          opened for exclusive write.
    FormatUDFVersion    - Version of UDF to format this disk with.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_UdfSa, Message,
                                       ExclusiveWrite, FALSE,
                                       RemovableMedia);

    if (errcode != NoError) {
        Destroy();
        return errcode;
    }


    if (!Message) {
        Message = &msg;
    }


    if (!_UdfSa.Initialize(this, Message, FormatUDFRevision)) {
        Destroy();
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return GeneralError;
    }

    return NoError;
}

PVOL_LIODPDRV
UDF_VOL::QueryDupVolume(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine allocates a UDF_VOL and initializes it to 'NtDriveName'.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    A pointer to a newly allocated NTFS volume.

--*/
{
    PUDF_VOL   vol;

    // unreferenced parameters
    (void)(this);

    if (!(vol = NEW UDF_VOL)) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return NULL;
    }

    if (!vol->Initialize(NtDriveName, Message, ExclusiveWrite,
                         MediaType)) {
        DELETE(vol);
        return NULL;
    }

    return vol;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\verifysbdallocation.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    VerifySBDAllocation.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"

#include "unicode.hxx"
#include "crc.hxx"

//  UNDONE, CBiks, 08/15/2000
//      Put this in udf.h with a more sensible name.
//

const UCHAR DeveloperID[] = { 'M', 'i', 'c', 'r', 'o', 's', 'o', 'f', 't', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' };

BOOL
UDF_LVOL::FindAvailableSector
(
	PNSR_SBD    SBDOriginal,
	PNSR_SBD    SBDNew,
    PULONG      SectorAvailable
)
{
	BOOL    Result = FALSE;

    ULONG   Offset = 0;
    UCHAR   BitNum = 0x01;
    ULONG   Sector = 0;
    while (Sector < SBDNew->BitCount) {

        if (((SBDOriginal->Bits[ Offset ] & BitNum) != 0) && ((SBDNew->Bits[ Offset ] & BitNum) != 0)) {

            SBDNew->Bits[ Offset ] |= BitNum;
            *SectorAvailable = Sector;
            Result = TRUE;
            break;

        }

        BitNum <<= 1;
        if (BitNum == 0) {

            Offset += 1;
            BitNum = 1;

        }

        Sector += 1;

    }

    return Result;
}

BOOL
UDF_LVOL::CreateFID
(
    PICBFILE    IcbDirectoryParent,
    PICBEXTFILE IcbFile,
    PCWSTR      FileName,
    PNSR_FID*   NewNsrFID,
    ULONG       StartLbn,
    USHORT      StartPartition,
    ULONG       Length
)
{
	BOOL Result = TRUE;
    UCHAR AdType = IcbDirectoryParent->Icbtag.Flags & ICBTAG_F_ALLOC_MASK;

    //  The size of the FID is the actual constant size + one for the Compression ID of the file name
    //  plus the size of the file name in bytes rounded to the nearest 4 byte boundary.
    //
    ULONG FIDSize = LongAlign( sizeof( NSR_FID) + sizeof( UCHAR ) + (wcslen( FileName ) * sizeof( WCHAR )) );

    //  Sanity check the calculated length.
    //
    ASSERT( LOWORD( FIDSize ) == FIDSize );

    switch (AdType) {

        case ICBTAG_F_ALLOC_SHORT: {

            ASSERTMSG( "UNDONE, CBiks, 8/14/2000: Unimplemented FindAvailableFID() - ICBTAG_F_ALLOC_SHORT", 0 );
            break;

        }

        case ICBTAG_F_ALLOC_LONG: {

            ASSERTMSG( "UNDONE, CBiks, 8/14/2000: Unimplemented FindAvailableFID() - ICBTAG_F_ALLOC_LONG", 0 );
            break;

        }

        case ICBTAG_F_ALLOC_EXTENDED: {

            ASSERTMSG( "UNDONE, CBiks, 8/14/2000: Unimplemented FindAvailableFID() - ICBTAG_F_ALLOC_EXTENDED", 0 );
            break;

        }

        case ICBTAG_F_ALLOC_IMMEDIATE: {

            ULONG       AllocDescOffset = FeEasFieldOffset( IcbDirectoryParent ) + FeEaLength( IcbDirectoryParent );
            ULONG       AllocationDescriptorEnd = AllocDescOffset + FeAllocLength( IcbDirectoryParent );
            //PNSR_FID    NsrFid = (PNSR_FID)( (LPBYTE)( IcbDirectoryParent ) + AllocDescOffset );

            BOOL        FIDFound = FALSE;

            PNSR_FID    FreeNsrFid = NULL;
            ULONG       FreeFIDSector = 0;
            ULONG       FreeFIDOffset = 0;

            while (Result && (AllocDescOffset < AllocationDescriptorEnd)) {

                PNSR_FID NsrFid = (PNSR_FID)( (LPBYTE)( IcbDirectoryParent ) + AllocDescOffset );
                
                ASSERTMSG( "CreateFID(): Bogus FID in the FE.",
                    VerifyDescriptor( (LPBYTE) NsrFid, AllocationDescriptorEnd - AllocDescOffset, DESTAG_ID_NSR_FID, NULL ) );
                
                if (NsrFid->Flags & NSR_FID_F_DELETED) {

                    if (Result && (ISONsrFidSize( NsrFid ) >= FIDSize)) {

                        FreeNsrFid = NsrFid;
                        FreeFIDSector = IcbDirectoryParent->Destag.Lbn;
                        FreeFIDOffset = AllocDescOffset;

                        FIDFound = TRUE;
                        break;


                    }

                }

                AllocDescOffset += ISONsrFidSize( NsrFid );

            }

            if (!FIDFound) {

                if ((AllocDescOffset + FIDSize) < QuerySectorSize()) {

                    FreeNsrFid = (PNSR_FID)( (LPBYTE)( IcbDirectoryParent ) + AllocDescOffset );
                    FreeFIDSector = IcbDirectoryParent->Destag.Lbn;
                    FreeFIDOffset = AllocDescOffset;

                    FIDFound = TRUE;

                }

            }

            if (FIDFound) {

                FreeNsrFid->Destag.Ident = DESTAG_ID_NSR_FID;
                FreeNsrFid->Destag.Version = DESTAG_VER_NSR03;
                FreeNsrFid->Destag.Res5 = 0;
                FreeNsrFid->Destag.Serial = 0;
                FreeNsrFid->Destag.Lbn = FreeFIDSector;

                FreeNsrFid->Version = 1;
                FreeNsrFid->Flags = 0;

                FreeNsrFid->Icb.Length.Length =   Length;
                FreeNsrFid->Icb.Length.Type =     NSRLENGTH_TYPE_RECORDED;
                FreeNsrFid->Icb.Start.Lbn =       StartLbn;
                FreeNsrFid->Icb.Start.Partition = StartPartition;
                
                FreeNsrFid->Icb.ImpUse[6];
                FreeNsrFid->ImpUseLen = 0;

                //
                //  Put the unicode file name in the FID.  The name follows NSR_FID data structure after the implementation
                //  use bytes.
                //
                
                FreeNsrFid->FileIDLen = (UCHAR) CompressUnicode( FileName, wcslen( FileName ),
                    ((LPBYTE) FreeNsrFid) + sizeof( NSR_FID) + FreeNsrFid->ImpUseLen );

                ASSERTMSG( "CreateFID(): FID size calculation is wrong.\n",
                    FIDSize == LongAlign( sizeof( NSR_FID)  + FreeNsrFid->FileIDLen ) );

                //  Generate and store the CRC of the FID section.
                //
                FreeNsrFid->Destag.CRCLen = (USHORT)( FIDSize ) - sizeof( DESTAG );
                FreeNsrFid->Destag.CRC = CalculateCrc( (LPBYTE)( FreeNsrFid ) + sizeof( DESTAG ), FreeNsrFid->Destag.CRCLen );

                //  Finally, generate and store the checksum of the DESTAG.
                //
                FreeNsrFid->Destag.Checksum = CalculateTagChecksum( &FreeNsrFid->Destag );

#if DBG
                //
                //  Do some sanity checking on the FID to make sure it's ok.
                //
                
                UINT DebugDescriptorLength;
                BOOL DebugResult = GetLengthOfDescriptor( (LPBYTE) FreeNsrFid, &DebugDescriptorLength );
                ASSERTMSG( "Bad FID descriptor length calculation",
                     DebugResult && (DebugDescriptorLength == FIDSize) );

                ASSERTMSG( "CreateFID(): The NSR_FID created is not valid.",
                    VerifyDescriptor( (LPBYTE) FreeNsrFid, FIDSize, DESTAG_ID_NSR_FID, NULL ) );
#endif
                
                *NewNsrFID = FreeNsrFid;

                //
                //  Add the size of the new FID to the ICB's allocation descriptor length.
                //
                
                FeAllocLength( IcbDirectoryParent ) = FeAllocLength( IcbDirectoryParent ) + ISONsrFidSize( FreeNsrFid );

#if DBG
                //
                //  Do some debug sanity checking if the Root Directories FileEntry, just to make sure we get everything
                //  right.
                //
                
                DebugResult = GetLengthOfDescriptor( (LPBYTE) IcbDirectoryParent, &DebugDescriptorLength );

                ASSERTMSG( "GetLengthOfDescriptor() on updated Root Directory FileEntry failed.",
                     DebugResult );
                
                ASSERTMSG( "Updated FileEntry descriptor body length does not make sense.",
                    IcbDirectoryParent->Destag.CRCLen + ISONsrFidSize( FreeNsrFid ) == DebugDescriptorLength - sizeof( DESTAG ) );
#endif

                //
                //  Update the file size.  In the case of a directory this the size of the FIDs.
                //
                
                IcbDirectoryParent->InfoLength += (USHORT)( ISONsrFidSize( FreeNsrFid ) );

                //
                //  Extended File Entries also track the size of all streams, so we have to update that too.
                //
                
                if (FeIsExtended( IcbDirectoryParent )) {
                    ((PICBEXTFILE) IcbDirectoryParent)->ObjectSize += (USHORT)( ISONsrFidSize( FreeNsrFid ) );
                }
                
                //
                //  We're done updating the the parent directories (Extended) File Entry, so we can now update the CRC vaules.
                //

                IcbDirectoryParent->Destag.CRCLen += (USHORT)( ISONsrFidSize( FreeNsrFid ) );
                IcbDirectoryParent->Destag.CRC = CalculateCrc( (LPBYTE)( IcbDirectoryParent ) + sizeof( DESTAG ),
                    IcbDirectoryParent->Destag.CRCLen );
                IcbDirectoryParent->Destag.Checksum = CalculateTagChecksum( &IcbDirectoryParent->Destag );

#if DBG
                //
                //  Do some sanity checks on the update root directory Fille Entry.
                //
                
                ASSERTMSG( "CreateFID(): The File Entry updated is not valid.",
                    VerifyDescriptor( (LPBYTE) IcbDirectoryParent, QuerySectorSize(), IcbDirectoryParent->Destag.Ident, NULL ) );
#endif

                Result = Write( IcbDirectoryParent->Destag.Lbn, 1, (LPBYTE) IcbDirectoryParent );

            } else {

                ASSERTMSG( "UNDONE, CBiks, 8/14/2000: Implement code to convert ICBTAG_F_ALLOC_IMMEDIATE into ICBTAG_F_ALLOC_SHORT\n", 0 );

            }


            break;
        }

        default: {

            ASSERTMSG( "Invalid Allocation Descriptor Type", 0 );
            break;

        }

    }

    return Result;
}

BOOL
UDF_LVOL::CreateICBFileEntry
(
    PICBEXTFILE*    NewICBCheckFile,
    ULONG           StartSector,
    ULONG           EndSector,
	PNSR_SBD        SBDOriginal,
	PNSR_SBD        SBDNew
)
{
	BOOL Result = TRUE;

    USHORT ICBCheckFileSize = sizeof( ICBEXTFILE) + sizeof( SHORTAD );
    PICBEXTFILE ICBCheckFile = (PICBEXTFILE) calloc( 1, QuerySectorSize() );
    if (ICBCheckFile != NULL) {

        ULONG ICBSector;
        Result = FindAvailableSector( SBDOriginal, SBDNew, &ICBSector );
        if (Result) {

            ICBCheckFile->Destag.Ident =                DESTAG_ID_NSR_EXT_FILE;
            ICBCheckFile->Destag.Version =              DESTAG_VER_NSR03;
            ICBCheckFile->Destag.Res5 =                 0;
            ICBCheckFile->Destag.Serial =               0;
            ICBCheckFile->Destag.Lbn =                  ICBSector;

            //  Setup the ICBTag for Strategy 4 and SHORTAD's.
            //
            ICBCheckFile->Icbtag.StratType =            ICBTAG_STRAT_DIRECT;
            ICBCheckFile->Icbtag.FileType =             ICBTAG_FILE_T_FILE;
            ICBCheckFile->Icbtag.Flags =                ICBTAG_F_ALLOC_SHORT;
            ICBCheckFile->Icbtag.MaxEntries =           1;
            ICBCheckFile->Icbtag.PriorDirectCount =     0;
            ICBCheckFile->Icbtag.StratParm =            0;
            ICBCheckFile->Icbtag.Res10 =                0;
            ICBCheckFile->Icbtag.IcbParent.Lbn =        0;
            ICBCheckFile->Icbtag.IcbParent.Partition =  0;

            //  UDF 14.9.3 says OS's that do not have User/Group ID's should use arbitrary non-zero numbers.  Most of the disks I've seen have
            //  0xffffffff in these fields, so that's good enough for me.
            //
            ICBCheckFile->UID =                         0xffffffff;
            ICBCheckFile->GID =                         0xffffffff;

            //  Allow everyone to Read, Write, Set Attributes and Delete the .CHK file.
            //
            ICBCheckFile->Permissions = (ICBFILE_PERM_OTH_W | ICBFILE_PERM_OTH_R | ICBFILE_PERM_OTH_A | ICBFILE_PERM_OTH_D) |
                                        (ICBFILE_PERM_GRP_W | ICBFILE_PERM_GRP_R | ICBFILE_PERM_GRP_A | ICBFILE_PERM_GRP_D) |
                                        (ICBFILE_PERM_OWN_W | ICBFILE_PERM_OWN_R | ICBFILE_PERM_OWN_A | ICBFILE_PERM_OWN_D);

            //  There will only be a single FID attached to this File Entry.
            //
            ICBCheckFile->LinkCount =                   1;


            //  UDF 2.3.6 says these should all be zero.
            //
            ICBCheckFile->RecordFormat =                0;
            ICBCheckFile->RecordDisplay =               0;
            ICBCheckFile->RecordLength =                0;
            ICBCheckFile->BlocksRecorded =              0;

            //  Set the size if the file, and the size of all streams.
            //
            ICBCheckFile->InfoLength =                  (EndSector - StartSector) * QuerySectorSize();
            ICBCheckFile->ObjectSize =                  ICBCheckFile->InfoLength;

            //  ICBCheckFile->AccessTime;                TIMESTAMP   Last-Accessed Time
            //  ICBCheckFile->ModifyTime;                TIMESTAMP   Last-Modification Time
            //  ICBCheckFile->CreationTime;              TIMESTAMP   Creation Time
            //  ICBCheckFile->AttributeTime;             TIMESTAMP   Last-Attribute-Change Time

            //  UDF 14.9.15 This field shall contain 1 for the first instance of a file...
            //
            ICBCheckFile->Checkpoint =                  1;

            //  Set the unused field to zero to be nice.
            //
            ICBCheckFile->Reserved =                    0;

            //  No Extended attributes.
            //
            memset( &ICBCheckFile->IcbEA, '\0', sizeof( LONGAD ) );


            //  No Streams.
            //
            memset( &ICBCheckFile->IcbStream, '\0', sizeof( LONGAD ) );

            //
            PREGID RegID = &ICBCheckFile->ImpUseID;
            RegID->Flags = 0;

            ASSERT( sizeof( DeveloperID ) == sizeof( RegID->Identifier ) );
            memcpy( RegID->Identifier, DeveloperID, sizeof( RegID->Identifier ) );

            PUDF_SUFFIX_IMPLEMENTATION SuffixImplementation = (PUDF_SUFFIX_IMPLEMENTATION) &RegID->Suffix;
            SuffixImplementation->OSClass = OSCLASS_WINNT;
            SuffixImplementation->OSIdentifier = OSIDENTIFIED_WINNT_WINNT;
            memset( &SuffixImplementation->ImplementationUse, '\0', sizeof( SuffixImplementation->ImplementationUse ) );

            //  UNDONE, CBiks, 08/15/2000
            //      Set the Unique ID according to UDF 3.2.1.1 for Mac OS support.
            //
            ICBCheckFile->UniqueID = 0;

            //  No extended attributes for this file.
            //
            ICBCheckFile->EALength = 0;

            //  Create the single Allocation Descriptor pointing to the lost clusters.
            //
            ICBCheckFile->AllocLength = sizeof( SHORTAD );

            PSHORTAD AllocationDescriptors = (PSHORTAD)( (LPBYTE)( ICBCheckFile ) + sizeof( ICBEXTFILE) );
            AllocationDescriptors->Start = StartSector;
            AllocationDescriptors->Length.Length = ICBCheckFile->InfoLength;
            AllocationDescriptors->Length.Type = NSRLENGTH_TYPE_RECORDED;

            //  Generate and store the CRC of the Extended File Entry section.
            //
            ICBCheckFile->Destag.CRCLen = ICBCheckFileSize - sizeof( DESTAG );
            ICBCheckFile->Destag.CRC = CalculateCrc( (LPBYTE)( ICBCheckFile ) + sizeof( DESTAG ), ICBCheckFile->Destag.CRCLen );

            //
            //  Finally, generate and store the checksum of the DESTAG.
            //
            
            ICBCheckFile->Destag.Checksum = CalculateTagChecksum( &ICBCheckFile->Destag );

#if DBG
            UINT DebugDescriptorLength;
            BOOL DebugResult = GetLengthOfDescriptor( (LPBYTE) ICBCheckFile, &DebugDescriptorLength );
            ASSERTMSG( "Bad descriptor length calculation",
                 DebugResult && (DebugDescriptorLength == ICBCheckFileSize) );

            ASSERTMSG( "CreateLostClusterFile(): The ICBEXTFILE created is not valid.",
                VerifyDescriptor( (LPBYTE) ICBCheckFile, ICBCheckFileSize, DESTAG_ID_NSR_EXT_FILE, NULL ) );
#endif

            *NewICBCheckFile = ICBCheckFile;

        }

    } else {

        Result = FALSE;

    }

    return Result;
}

BOOL
UDF_LVOL::CreateLostClusterFile
(
    ULONG       StartSector,
    ULONG       EndSector,
	PNSR_SBD    SBDOriginal,
	PNSR_SBD    SBDNew
)
{
	BOOL Result = TRUE;

    static ULONG CheckFileNum = 0;

    WCHAR FileName[ MAX_PATH ];
    wsprintf( FileName, L"FILE%04d.CHK", CheckFileNum );

    DbgPrint( "Creating file %S for lost clusters: Partition sector = %i thru %i, Physical sector = %I64i thru %I64i\n",
        FileName,
        StartSector, EndSector,
        TranslateBlockNum( StartSector, 0 ), TranslateBlockNum( EndSector, 0 ) );

    PICBEXTFILE ICBCheckFile;
    Result = CreateICBFileEntry( &ICBCheckFile, StartSector, EndSector, SBDOriginal, SBDNew );
    if (Result) {

        Result = Write( ICBCheckFile->Destag.Lbn, 1, (LPBYTE) ICBCheckFile );
        if (Result) {
            PNSR_FID NsrFID;
            Result = CreateFID( _RootIcbFileEntry, ICBCheckFile, FileName, &NsrFID,
                ICBCheckFile->Destag.Lbn, 0, QuerySectorSize() );
            if (Result) {

            }

        }

    }

    CheckFileNum++;

    return Result;
}

BOOL
UDF_LVOL::VerifySBDAllocation
(
	PNSR_SBD    SBDOriginal,
	PNSR_SBD    SBDNew
)
{
	BOOL Result = TRUE;

    DbgPrint( "VerifySBDAllocation(): entry\n" );

    if (SBDOriginal->ByteCount != SBDNew->ByteCount) {

        DbgPrint( "\tByte counts don't match: Original = %x, New = %x\n",
            SBDOriginal->ByteCount, SBDNew->ByteCount );

    } else if (SBDOriginal->BitCount!= SBDNew->BitCount) {

        DbgPrint( "\tBit counts don't match: Original = %x, New = %x\n",
            SBDOriginal->BitCount, SBDNew->BitCount );

    } else {

        ULONG   Offset = 0;
        UCHAR   BitNum = 0x01;
        ULONG   Sector = 0;

        while (Sector < SBDNew->BitCount) {

            //  If the sectors were allocated in the original SB and not in the new one then we try to create
            //  FILE????.CHK entries for the lost clusters.
            //

            if (((SBDOriginal->Bits[ Offset ] & BitNum) == 0) && ((SBDNew->Bits[ Offset ] & BitNum) != 0)) {

                ULONG StartSector = Sector;
                ULONG EndSector = Sector;
                while (Sector < SBDNew->BitCount) {

                    if (((SBDOriginal->Bits[ Offset ] & BitNum) == 0) && ((SBDNew->Bits[ Offset ] & BitNum) != 0)) {

                        EndSector = Sector;

                    } else {

                        break;

                    }

                    BitNum <<= 1;
                    if (BitNum == 0) {

                        Offset += 1;
                        BitNum = 1;

                    }

                    Sector += 1;
                }

                Result = CreateLostClusterFile( StartSector, EndSector, SBDOriginal, SBDNew );

            }


            BitNum <<= 1;
            if (BitNum == 0) {

                Offset += 1;
                BitNum = 1;

            }

            Sector += 1;

        }

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\uudf\src\unicode.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    unicode.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

int
UncompressUnicode
(
    int         UDFCompressedBytes,
    LPBYTE      UDFCompressed,
    PWSTRING    UnicodeString
)
{
    int Result = -1;

    /* Use UDFCompressed to store current byte being read. */
    UCHAR CompressionID = UDFCompressed[0];

    /* First check for valid CompressionID. */
    if ((CompressionID) == 8 || (CompressionID == 16)) {

        if (CompressionID == 8) {

            UnicodeString->Resize( UDFCompressedBytes - 1 );

        } else {

            ASSERTMSG( "Unicode string length should be a multiple of two.\n",
                (UDFCompressedBytes % 2) == 1 );

            UnicodeString->Resize( (UDFCompressedBytes - 1) / sizeof( short ) );

        }

        int UnicodeLength = 0;
        int ByteIndex = 1;

        /* Loop through all the bytes. */
        while (ByteIndex < UDFCompressedBytes) {

            if (CompressionID == 16) {

                //  UNDONE, CBiks, 8/2/2000
                //      Test this code....
                //

                ASSERT( 0 );
                UnicodeString->SetChAt( (WCHAR) (UDFCompressed[ ByteIndex++ ] << 8) | UDFCompressed[ ByteIndex++ ], UnicodeLength );

            } else {

                UnicodeString->SetChAt( UDFCompressed[ ByteIndex ], UnicodeLength );
                ByteIndex++;

            }

            UnicodeLength++;

        }

        Result = UnicodeLength;

    }

    return Result;
}


/***********************************************************************
* DESCRIPTION:
* Takes a string of unicode wide characters and returns an OSTA CS0
* compressed unicode string. The unicode MUST be in the byte order of
* the compiler in order to obtain correct results.  Returns an error
* if the compression ID is invalid.
*
* NOTE: This routine assumes the implementation already knows, by
* the local environment, how many bits are appropriate and
* therefore does no checking to test if the input characters fit
* into that number of bits or not.
*
* RETURN VALUE
*
*    The total number of bytes in the compressed OSTA CS0 string,
*    including the compression ID.
*    A -1 is returned if the compression ID is invalid.
*/
int
CompressUnicode
(
    PCWCH       UnicodeString,
    size_t      UnicodeStringSize,
    LPBYTE      UDFCompressed
)
{
    UDFCompressed[0] = 16;

    int ByteIndex = 1;
    size_t UnicodeLength = 0;
    while (UnicodeLength < UnicodeStringSize) {

        UDFCompressed[ByteIndex++] = (UCHAR)( (UnicodeString[UnicodeLength] & 0xFF00) >> 8 );
        UDFCompressed[ByteIndex++] = (UCHAR)(  UnicodeString[UnicodeLength] & 0x00FF );

        UnicodeLength++;
    }

    return ByteIndex;
}

BOOL
UncompressDString
(
    LPBYTE      DString,
    size_t      DStringSize,
    PWSTRING    UnicodeString
)
{
    int Len = UncompressUnicode( DString[ DStringSize - 1 ], DString, UnicodeString );
    return (Len >= 0);
}

VOID
CompressDString
(
    UCHAR   CompressionID,
    PCWCH   UnicodeString,
    size_t  UnicodeStringSize,
    LPBYTE  UDFCompressed,
    size_t  UDFCompressedSize
)
{
    ASSERTMSG( "Unsupported compression ID",
        (CompressionID == 8 || CompressionID == 16) );

    ASSERT( UnicodeStringSize < UDFCompressedSize );

    UDFCompressed[0] = CompressionID;

    int byteIndex = 1;
    size_t unicodeIndex = 0;
    while (unicodeIndex < UnicodeStringSize) {

        if (CompressionID == 16) {

            UDFCompressed[byteIndex++] = (BYTE) ((UnicodeString[unicodeIndex] & 0xFF00) >> 8);

        }

        UDFCompressed[byteIndex++] = (BYTE) (UnicodeString[unicodeIndex] & 0x00FF);
        unicodeIndex++;

    }

    UDFCompressed[UDFCompressedSize - 1] = (BYTE) UnicodeStringSize + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\clb\dialogs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Dialogs.h

Abstract:


Author:

    David J. Gilman (davegi) 18-Feb-1993

Environment:

    User Mode

--*/

#define IDD_CLB                     1700
#define IDC_CHECK_VISIBLE           1701
#define IDC_CHECK_DISABLED          1702
#define IDC_CHECK_GROUP             1703
#define IDC_CHECK_TABSTOP           1704
#define IDC_CHECK_SORT              1705
#define IDC_CHECK_NOTIFY            1706
#define IDC_CHECK_VSCROLL           1707
#define IDC_CHECK_STANDARD          1710
#define IDC_CHECK_BORDER            1713
#define IDC_CHECK_POPOUT_HEADINGS   1714
#define IDC_CHECK_SPRINGY_COLUMNS   1715
#define IDC_CHECK_DISABLENOSCROLL   1708
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\clb\clb.c ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    Clb.c

Abstract:

    This file contains support for the ColumnListBox (clb.dll) custom control.

Author:

    David J. Gilman (davegi) 05-Feb-1993

Environment:

    User Mode

--*/

#include "clb.h"

#include <commctrl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

//
// Clb's module handle.
//

HINSTANCE
_hModule;

//
// Child IDs for the header and listbox controls.
//

#define ID_HEADER           ( 0x1234 )
#define ID_LISTBOX          ( 0xABCD )


//
// Separator used to parse headings.
//

#define HEADING_SEPARATOR   L";"

//
// Valid styles for each part of the Clb.
//

#define CLBS_CLB                (                                           \
                                      0                                     \
                                    | CLBS_BORDER                           \
                                    | LBS_OWNERDRAWFIXED                    \
                                    | WS_VISIBLE                            \
                                    | WS_DISABLED                           \
                                    | WS_GROUP                              \
                                    | WS_TABSTOP                            \
                                    | WS_CHILD                              \
                                )

#define CLBS_HEADER             (                                           \
                                      0                                     \
                                    | WS_VISIBLE                            \
                                    | CLBS_POPOUT_HEADINGS                  \
                                    | CLBS_SPRINGY_COLUMNS                  \
                                )

#define CLBS_LIST_BOX           (                                           \
                                      0                                     \
                                    | WS_VISIBLE                            \
                                    | CLBS_NOTIFY                           \
                                    | CLBS_SORT                             \
                                    | CLBS_DISABLENOSCROLL                  \
                                    | CLBS_VSCROLL                          \
                                )




//
// Window procedure for the CLB.
//

LRESULT
ClbWndProc(
          IN HWND hWnd,
          IN UINT message,
          IN WPARAM wParam,
          IN LPARAM lParam
          );

//
// Per CLB window information.
//
//      hWndHeader      - hWnd for header control.
//      hWndListBox     - hWnd for listbox control.
//      hFontListBox    - hFont for the list box control.
//      HeaderHeight    - height of the header window.
//      Columns         - number of columns in CLB.
//      Headings        - raw (semi-colon separated) column headings.
//      Right           - array of right edge coordinates.
//

typedef
struct
    _CLB_INFO {

    DECLARE_SIGNATURE

    HWND        hWndHeader;
    HWND        hWndListBox;

    HFONT       hFontListBox;
    DWORD       HeaderHeight;
    DWORD       Columns;
    WCHAR       Headings[ MAX_PATH ];
    LPLONG      Right;

}   CLB_INFO, *LPCLB_INFO;


//
// Helper macros to save and restore per Clb window information.
//

#define SaveClbInfo( p )                                                    \
    SetWindowLongPtr( hWnd, 0, ( LONG_PTR )( p ))

#define RestoreClbInfo( h )                                                 \
    ( LPCLB_INFO ) GetWindowLongPtr(( h ), 0 )

//
// Structures to support drawing and ersaing the drag line.
//

typedef
struct
    _LINE_POINTS {

    POINT   Src;
    POINT   Dst;

}   LINE_POINT, *LPLINE_POINT;

typedef
struct
    _DRAW_ERASE_LINE {

    LINE_POINT   Erase;
    LINE_POINT   Draw;

}   DRAW_ERASE_LINE, *LPDRAW_ERASE_LINE;

BOOL
DrawLine(
        IN HDC hDC,
        IN LPDRAW_ERASE_LINE DrawEraseLine
        )

/*++

Routine Description:

    DrawLine draws the Draw line in the supplied DrawEraseLine structure
    and then sets up that line so that EraseLine will erase it.

Arguments:

    hDC             - Supplies a handle to the DC where the line should be
                      drawn.
    DrawEraseLine   - Supplies a pointer to a DRAW_ERASE_LINE structure that
                      conatins the coordinates for the line to be drawn.

Return Value:

    BOOL - Returns TRUE if the line was succesfully drawn.

--*/

{
    BOOL    Success;

    DbgHandleAssert( hDC );
    DbgPointerAssert( DrawEraseLine );

    Success = Polyline( hDC, ( CONST LPPOINT ) &DrawEraseLine->Draw, 2 );
    DbgAssert( Success );

    DrawEraseLine->Erase = DrawEraseLine->Draw;

    return Success;
}

BOOL
EraseLine(
         IN HDC hDC,
         IN LPDRAW_ERASE_LINE DrawEraseLine
         )


/*++

Routine Description:

    EraseLine erasess the Erase line in the supplied DrawEraseLine structure.
    The EraseLine is set by the DrawLine routine.

Arguments:

    hDC             - Supplies a handle to the DC where the line should
                      be erased.
    DrawEraseLine   - Supplies a pointer to a DRAW_ERASE_LINE structure that
                      conatins the coordinates for the line to be erased.

Return Value:

    BOOL            - Returns TRUE if the line was succesfully erased.

--*/

{
    BOOL    Success;

    DbgHandleAssert( hDC );
    DbgPointerAssert( DrawEraseLine );

    Success = Polyline( hDC, ( CONST LPPOINT ) &DrawEraseLine->Erase, 2 );
    DbgAssert( Success );

    return Success;
}

BOOL
RedrawVerticalLine(
                  IN HDC hDC,
                  IN LONG x,
                  IN LPDRAW_ERASE_LINE DrawEraseLine
                  )

/*++

Routine Description:

    RedrawVerticalLine erases the old line and redraws a new one at the
    supplied x position. It is merely a warpper for DrawLine and EraseLine.

Arguments:

    hDC             - Supplies a handle to the DC where the line should
                      be erased.
    x               - Supplies the new x coordinate where the line should
                      be drawn.
    DrawEraseLine   - Supplies a pointer to a DRAW_ERASE_LINE structure that
                      conatins the coordinates for the line to be erased.

Return Value:

    BOOL            - Returns TRUE if the line was succesfully erased.

--*/

{
    BOOL    Success;

    DbgHandleAssert( hDC );
    DbgPointerAssert( DrawEraseLine );


    DrawEraseLine->Draw.Src.x = x;
    DrawEraseLine->Draw.Dst.x = x;

    Success = EraseLine( hDC, DrawEraseLine );
    DbgAssert( Success );

    Success = DrawLine( hDC, DrawEraseLine );
    DbgAssert( Success );

    return Success;
}

BOOL
ClbEntryPoint(
             IN HINSTANCE hInstanceDll,
             IN DWORD Reason,
             IN LPVOID Reserved
             )

/*++

Routine Description:

    This function registers the ColumndListBox class as a global class for
    any process that attaches to clb.dll.

Arguments:

    Standard DLL entry parameters.

Return Value:

    BOOL    - Returns TRUE if the class was succesfully registered.

--*/

{
    BOOL    Success;
    static
    DWORD   AttachedProcesses = 0;

    switch ( Reason ) {

        case DLL_PROCESS_ATTACH:
            {

                WNDCLASS    Wc;
                ATOM        Class;

                //
                // If this is the first process attaching to Clb, register the
                // window class.
                //

                if ( AttachedProcesses == 0 ) {

                    //
                    // Remember the module handle.
                    //

                    _hModule = hInstanceDll;


                    //
                    // Make sure that the Common Controls (comctl32.dll) Dll
                    // is loaded.
                    //

                    InitCommonControls( );

                    Wc.style            =   CS_GLOBALCLASS
                                            | CS_OWNDC;
                    Wc.lpfnWndProc      = ClbWndProc;
                    Wc.cbClsExtra       = 0;
                    Wc.cbWndExtra       = sizeof( LPCLB_INFO );
                    Wc.hInstance        = hInstanceDll;
                    Wc.hIcon            = NULL;
                    Wc.hCursor          = LoadCursor( NULL, IDC_ARROW );
                    Wc.hbrBackground    = NULL;
                    Wc.lpszMenuName     = NULL;
                    Wc.lpszClassName    = CLB_CLASS_NAME;

                    //
                    // If the class couldn't be registered, fail the linkage.
                    //

                    Class = RegisterClass( &Wc );
                    DbgAssert( Class != 0 );
                    if ( Class == 0 ) {
                        return FALSE;
                    }
                }

                //
                // Either the class was just succesfully registered or it was
                // registered by a prior process attachment, eother way increment
                // the count of attached processes.
                //

                AttachedProcesses++;

                return TRUE;
            }

        case DLL_PROCESS_DETACH:
            {

                DbgAssert( AttachedProcesses > 0 );

                AttachedProcesses--;

                if ( AttachedProcesses == 0 ) {

                    Success = UnregisterClass( CLB_CLASS_NAME, hInstanceDll );
                    DbgAssert( Success );

                }
                break;
            }
    }

    return TRUE;
}

BOOL
ClbAddData(
          IN HWND hWnd,
          IN int ControlId,
          IN LPCLB_ROW ClbRow
          )

/*++

Routine Description:

    ClbAddData adds a new row of data to the Clb control's List Box.

Arguments:

    hWnd        - Supplies the window handle for the parent window.
    ControlId   - Supplies the control id for this Clb for the supplied hWnd.
    ClbRow      - Supplies a pointer to a CLB_ROW object which contains user
                  define per row data along with an array of CLB_STRINGs.

Return Value:

    BOOL        - Returns TRUE if the data was successfully added.


--*/

{
    LPCLB_INFO      ClbInfo;
    LRESULT         LbErr;
    DWORD           i;
    HWND            hWndClb;
    LPCLB_ROW       TempRow;

    //
    // Validate arguments.
    //

    DbgHandleAssert( hWnd );
    DbgPointerAssert( ClbRow );

    //
    // Retrieve information for this ColumnListBox.
    //

    hWndClb = GetDlgItem( hWnd, ControlId );
    DbgHandleAssert( hWndClb );
    if (hWndClb == NULL)
        return FALSE;
    ClbInfo = RestoreClbInfo( hWndClb );
    DbgPointerAssert( ClbInfo );
    if (ClbInfo == NULL)
        return FALSE;
    DbgAssert( CheckSignature( ClbInfo ));

    //
    // Validate the count of strings.
    //

    DbgAssert( ClbRow->Count == ClbInfo->Columns );

    //
    // Capture the CLB_ROW object.
    //

    TempRow = AllocateObject( CLB_ROW, 1 );
    DbgPointerAssert( TempRow );
    if (TempRow == NULL)
        return FALSE;

    CopyMemory(
              TempRow,
              ClbRow,
              sizeof( CLB_ROW)
              );

    //
    // Capture the strings.
    //

    TempRow->Strings = AllocateObject( CLB_STRING, ClbInfo->Columns );
    DbgPointerAssert( TempRow->Strings );
    if (TempRow->Strings == NULL)
        return FALSE;

    for ( i = 0; i < ClbInfo->Columns; i++ ) {

        //
        // Copy the header.
        //

        CopyMemory(
                  &TempRow->Strings[ i ],
                  &ClbRow->Strings[ i ],
                  sizeof( CLB_STRING )
                  );

        //
        // Copy the string.
        //

        TempRow->Strings[ i ].String = _wcsdup( ClbRow->Strings[ i ].String );
    }

    //
    // Store the CLB_ROW object in the listbox.
    //

    LbErr = SendMessage(
                       ClbInfo->hWndListBox,
                       LB_ADDSTRING,
                       0,
                       ( LPARAM ) TempRow
                       );
    DbgAssert(( LbErr != LB_ERR ) && ( LbErr != LB_ERRSPACE ));

    return TRUE;
}

BOOL
ClbSetColumnWidths(
                  IN HWND hWnd,
                  IN int ControlId,
                  IN LPDWORD Widths
                  )

/*++

Routine Description:

    ClbSetColumnWidths sets the width of each column based on the supplied
    widths in characters. Note that the column on the far right extends to
    the edge of the Clb.

Arguments:

    hWnd        - Supplies the window handle for the parent window.
    ControlId   - Supplies the control id for this Clb for the supplied hWnd.
    Widths      - Supplies an array of widths, one less then the number of
                  columns, in characters.

Return Value:

    BOOL        - Returns TRUE if the widths were successfully adjusted.


--*/

{
    BOOL        Success;
    DWORD       Columns;
    LPCLB_INFO  ClbInfo;
    HWND        hWndClb;
    LONG        CharWidth;
    LONG        CharHeight;
    DWORD       i;
    LPLONG      WidthsInPixels;
    LONG        TotalPixels;
    HDC         hDCClientHeader;
    HD_ITEM     hdi;
    UINT        iRight;

    //
    // Validate arguments.
    //

    DbgHandleAssert( hWnd );
    DbgPointerAssert( Widths );

    //
    // Retrieve information for this ColumnListBox.
    //

    hWndClb = GetDlgItem( hWnd, ControlId );
    DbgHandleAssert( hWndClb );
    if (hWndClb == NULL)
        return FALSE;
    ClbInfo = RestoreClbInfo( hWndClb );
    DbgPointerAssert( ClbInfo );
    if (ClbInfo == NULL)
        return FALSE;
    DbgAssert( CheckSignature( ClbInfo ));

    //
    // Get thd HDC for the header.
    //

    hDCClientHeader = GetDC( ClbInfo->hWndHeader );
    DbgHandleAssert( hDCClientHeader );
    if (hDCClientHeader == NULL)
        return FALSE;

    //
    // Get the width of a character.
    //

    Success = GetCharMetrics(
                            hDCClientHeader,
                            &CharWidth,
                            &CharHeight
                            );
    DbgAssert( Success );

    //
    // Release the DC for the header.
    //

    Success = ReleaseDC( ClbInfo->hWndHeader, hDCClientHeader );
    DbgAssert( Success );

    //
    // Allocate an array of pixel widths, one for each column.
    //

    WidthsInPixels = AllocateObject( LONG, ClbInfo->Columns );
    DbgPointerAssert( WidthsInPixels );
    if (WidthsInPixels == NULL)
        return FALSE;

    //
    // Compute the width of each column (not including the rightmost) in pixels,
    // and the total number of pixels used by these columns.
    //

    TotalPixels = 0;
    for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {

        WidthsInPixels[ i ] = Widths[ i ] * CharWidth;
        TotalPixels += WidthsInPixels[ i ];
    }

    //
    // The caller did not specify the width of the rightmost column.
    //

    if ( Widths[ i ] == -1 ) {

        RECT    Rect;

        //
        // Set the width of the rightmost column to the remainder of the width
        // of the header window.
        //

        Success = GetClientRect(
                               ClbInfo->hWndHeader,
                               &Rect
                               );
        DbgAssert( Success );

        WidthsInPixels[ i ] = ( Rect.right - Rect.left ) - TotalPixels;

    } else {

        //
        // Set the width of the rightmost column to the value supplied
        // by the caller.
        //

        WidthsInPixels[ i ] = Widths[ i ] * CharWidth;
    }

    //
    // Tell the header window the width of each column.
    //

    hdi.mask = HDI_WIDTH;

    for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {

        hdi.cxy = WidthsInPixels[i];
        Success = Header_SetItem(ClbInfo->hWndHeader, i, &hdi);

        DbgAssert( Success );
    }

    //
    // Calc the array of right edges.
    //

    iRight = 0;

    for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {
        iRight += WidthsInPixels[i];
        ClbInfo->Right[i] = iRight;
    }

    //
    // Free the array of pixel widths.
    //

    Success = FreeObject( WidthsInPixels );
    DbgAssert( Success );

    return TRUE;
}

BOOL
AdjustClbHeadings(
                 IN HWND hWnd,
                 IN LPCLB_INFO ClbInfo,
                 IN LPCWSTR Headings OPTIONAL
                 )

/*++

Routine Description:

    AdjustClbHeadings adjust the number of columns, the widths an header text
    bbased on the optional Headings parameter. If Headings is NULL then the
    column widths are adjusted based on the old headings and the current size
    of the Clb. If Headings are supplied then they consist of ';' separated
    strings, each of which is a column heading. The number of columns and their
    widths is then computed based on these new headings.

Arguments:

    hWnd        - Supplies a window handle for this Clb.
    ClbInfo     - Supplies a pointer the CLB_INFO structure for this Clb.
    Headings    - Supplies an optional pointer to a ';' separated series of
                  column header strings.

Return Value:

    BOOL        - Returns TRUE if the adjustment was succesfully made.

--*/

{
    BOOL    Success;
    DWORD   Columns;
    DWORD   ColumnWidth;
    DWORD   i;
    TCHAR   Buffer[ MAX_PATH ];
    LPCWSTR Heading;
    RECT    ClientRectHeader;
    HD_ITEM hdi;
    UINT    iCount, j, iRight;


    DbgPointerAssert( ClbInfo );
    DbgAssert( ! (( ClbInfo->Columns == 0 ) && ( Headings == NULL )));


    //
    // If the user supplied headings, compute the new number of columns.
    //

    if ( ARGUMENT_PRESENT( Headings )) {

        //
        // Initialize the column counter.
        //

        Columns = 0;

        //
        // Make a copy of the new headings in the Clb object.
        //

        lstrcpy( ClbInfo->Headings, Headings );

        //
        // Make a copy of the heading string so that it can be tokenized.
        // i.e. wcstok destroys the string.
        //

        lstrcpy( Buffer, Headings );

        //
        // Grab the first token (heading).
        //

        Heading = _tcstok( Buffer, HEADING_SEPARATOR );

        //
        // For each heading...
        //

        while ( Heading != NULL ) {

            //
            // Increment the number of columns.
            //

            Columns++;

            //
            // Get the next heading.
            //

            Heading = _tcstok( NULL, HEADING_SEPARATOR );
        }
    } else {

        //
        // Same number of Columns as before.
        //

        Columns = ClbInfo->Columns;
    }

    //
    // If the number of columns in the Clb is zero (i.e. this is the first
    // time it is being initialized) allocate the right edge array. Otherwise
    // reallocate the existing array if the number of columns has changed.
    //

    if ( ClbInfo->Columns == 0 ) {

        ClbInfo->Right = AllocateObject( LONG, Columns );
        DbgPointerAssert( ClbInfo->Right );

    } else if ( Columns != ClbInfo->Columns ) {

        ClbInfo->Right = ReallocateObject( LONG, ClbInfo->Right, Columns );
        DbgPointerAssert( ClbInfo->Right );

    }

    if (ClbInfo->Right == NULL)
        return FALSE;

    //
    // Update the number of columns in the Clb (note this may be the same
    // number as before).
    //

    ClbInfo->Columns = Columns;

    //
    // Compute the default column width by dividing the available space by the
    // number of columns.
    //

    Success = GetClientRect( ClbInfo->hWndHeader, &ClientRectHeader );
    DbgAssert( Success );

    ColumnWidth =   ( ClientRectHeader.right - ClientRectHeader.left )
                    / ClbInfo->Columns;


    //
    // Initialize the array of right edges to the width of each column.
    //

    for ( i = 0; i < ClbInfo->Columns; i++ ) {

        ClbInfo->Right[ i ] = ColumnWidth;
    }

    //
    // Update the existing header items
    //

    iCount = Header_GetItemCount(ClbInfo->hWndHeader);

    j = 0;
    hdi.mask = HDI_WIDTH;

    while ((j < iCount) && (j < Columns)) {

        hdi.cxy = ClbInfo->Right[j];
        Header_SetItem (ClbInfo->hWndHeader, j, &hdi);
        j++;
    }

    //
    // Add new header items if necessary.
    //

    hdi.mask = HDI_WIDTH;
    for (; j < Columns; j++) {
        hdi.cxy = ClbInfo->Right[j];
        Header_InsertItem (ClbInfo->hWndHeader, j, &hdi);
    }


    //
    // Query the header for the array of right edges.
    //

    iRight = 0;

    for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {
        iRight += ClbInfo->Right[i];
        ClbInfo->Right[i] = iRight;
    }

    ClbInfo->Right[i] = ClientRectHeader.right;

    //
    // Copy and parse the headings so that each column's heading
    // can be set. These can be new or old headings.
    //

    lstrcpy( Buffer, ClbInfo->Headings );

    Heading = _tcstok( Buffer, HEADING_SEPARATOR );

    hdi.mask = HDI_TEXT | HDI_FORMAT;
    hdi.fmt  = HDF_STRING;
    for ( i = 0; i < ClbInfo->Columns; i++ ) {

        hdi.pszText = (LPTSTR)Heading;
        Header_SetItem (ClbInfo->hWndHeader, i, &hdi);
        Heading = _tcstok( NULL, HEADING_SEPARATOR );
    }

    return TRUE;
}

BOOL
CreateHeader(
            IN HWND hWnd,
            IN LPCLB_INFO ClbInfo,
            IN LPCREATESTRUCT lpcs
            )

/*++

Routine Description:

    Create the header portion of the Clb.

Arguments:

    hWnd        - Supplies a window handle for the parent (i.e. Clb) window.
    ClbInfo     - Supplies a pointer the CLB_INFO structure for this Clb.
    lpcs        - Supplies a pointer to a CREATESTRUCT structure.

Return Value:

    BOOL        - Returns TRUE if the header portion of the Clb was
                  succesfully created.

--*/

{
    BOOL      Success;
    RECT      WindowRectHeader, rcParent;
    HD_LAYOUT hdl;
    WINDOWPOS wp;


    DbgHandleAssert( hWnd );
    DbgPointerAssert( ClbInfo );
    DbgPointerAssert( lpcs );

    //
    // Create the header window using the appropriate supplied styles,
    // augmented by additional styles needed by Clb, relative to the upper
    // left corner of the Clb and with a default height.
    // The width is adjusted in the WM_SIZE message handler.
    //

    ClbInfo->hWndHeader = CreateWindow(
                                      WC_HEADER,
                                      NULL,
                                      (
                                      lpcs->style
                                      & CLBS_HEADER
                                      )
                                      | WS_CHILD,
                                      0,
                                      0,
                                      0,
                                      CW_USEDEFAULT,
                                      hWnd,
                                      ( HMENU ) ID_HEADER,
                                      NULL,
                                      NULL
                                      );
    DbgHandleAssert( ClbInfo->hWndHeader );
    if (ClbInfo->hWndHeader == NULL)
        return FALSE;

    //
    // Compute and save the height of the header window. This is used to
    // position the list box.
    //

    GetClientRect(hWnd, &rcParent);

    hdl.prc = &rcParent;
    hdl.pwpos = &wp;

    SendMessage(ClbInfo->hWndHeader, HDM_LAYOUT, 0, (LPARAM)&hdl);

    SetWindowPos(ClbInfo->hWndHeader, wp.hwndInsertAfter, wp.x, wp.y, wp.cx, wp.cy,
                 wp.flags);

    ClbInfo->HeaderHeight = wp.cy;

    return TRUE;
}

BOOL
CreateListBox(
             IN HWND hWnd,
             IN LPCLB_INFO ClbInfo,
             IN LPCREATESTRUCT lpcs
             )

/*++

Routine Description:

    Create the list box portion of the Clb.

Arguments:

    hWnd        - Supplies a window handle for the parent (i.e. Clb) window.
    ClbInfo     - Supplies a pointer the CLB_INFO structure for this Clb.
    lpcs        - Supplies a pointer to a CREATESTRUCT structure.

Return Value:

    BOOL        - Returns TRUE if the list box portion of the Clb was
                  succesfully created.

--*/

{
    BOOL    Success;
    LOGFONT LogFont;
    HDC     hDCClientListBox;
    CHARSETINFO csi;
    DWORD dw = GetACP();

    if (!TranslateCharsetInfo(&dw, &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = ANSI_CHARSET;

    DbgHandleAssert( hWnd );
    DbgPointerAssert( ClbInfo );
    DbgPointerAssert( lpcs );

    //
    //
    // Create the list box using the appropriate supplied styles,
    // augmented by additional styles needed by Clb, relative to the lower left
    // corner of the header window plus one. This additional row is reserved so
    // that a border can be drawn between the header and the list box. The size
    // is adjusted in the WM_SIZE message handler.
    //

    ClbInfo->hWndListBox = CreateWindow(
                                       L"LISTBOX",
                                       NULL,
                                       (
                                       lpcs->style
                                       & CLBS_LIST_BOX
                                       )
                                       | LBS_NOINTEGRALHEIGHT
                                       | LBS_OWNERDRAWFIXED
                                       | WS_CHILD,
                                       0,
                                       ClbInfo->HeaderHeight + 3,
                                       0,
                                       0,
                                       hWnd,
                                       ( HMENU ) ID_LISTBOX,
                                       NULL,
                                       NULL
                                       );
    DbgHandleAssert( ClbInfo->hWndListBox );
    if (ClbInfo->hWndListBox == NULL)
        return FALSE;

    //
    // Get thd HDC for the list box.
    //

    hDCClientListBox = GetDC( ClbInfo->hWndListBox );
    DbgHandleAssert( hDCClientListBox );
    if (hDCClientListBox == NULL)
        return FALSE;

    //
    // Set the default font for the list box to MS Shell Dlg.
    //

    LogFont.lfHeight            = MulDiv(
                                        -9,
                                        GetDeviceCaps(
                                                     hDCClientListBox,
                                                     LOGPIXELSY
                                                     )
                                        ,72
                                        );
    LogFont.lfWidth             = 0;
    LogFont.lfEscapement        = 0;
    LogFont.lfOrientation       = 0;
    LogFont.lfWeight            = FW_NORMAL;
    LogFont.lfItalic            = FALSE;
    LogFont.lfUnderline         = FALSE;
    LogFont.lfStrikeOut         = FALSE;
    LogFont.lfCharSet           = (BYTE)csi.ciCharset;
    LogFont.lfOutPrecision      = OUT_DEFAULT_PRECIS;
    LogFont.lfClipPrecision     = CLIP_DEFAULT_PRECIS;
    LogFont.lfQuality           = DEFAULT_QUALITY;
    LogFont.lfPitchAndFamily    = DEFAULT_PITCH | FF_DONTCARE;

    _tcscpy( LogFont.lfFaceName, TEXT( "MS Shell Dlg" ));

    ClbInfo->hFontListBox = CreateFontIndirect( &LogFont );
    DbgHandleAssert( ClbInfo->hFontListBox );
    if (ClbInfo->hFontListBox == NULL)
        return FALSE;

    SendMessage(
               ClbInfo->hWndListBox,
               WM_SETFONT,
               ( WPARAM ) ClbInfo->hFontListBox,
               MAKELPARAM( FALSE, 0 )
               );

    //
    // Release the DC for the list box.
    //

    Success = ReleaseDC( ClbInfo->hWndListBox, hDCClientListBox );
    DbgAssert( Success );

    return TRUE;
}

LRESULT
ClbWndProc(
          IN HWND hWnd,
          IN UINT message,
          IN WPARAM wParam,
          IN LPARAM lParam
          )

/*++

Routine Description:

    This function is the window procedure for the Clb custom control.

Arguments:

    Standard window procedure parameters.

Return Value:

    LRESULT - dependent on the supplied message.

--*/

{
    BOOL            Success;
    LPCLB_INFO      ClbInfo;

    if ( message == WM_NCCREATE ) {

        LONG    Long;

        //
        // Save the original styles.
        //

        Long = SetWindowLong(hWnd, GWLP_USERDATA,(( LPCREATESTRUCT ) lParam )->style);
        DbgAssert( Long == 0 );


        //
        // Get rid of any styles that are uninteresting to the Clb.
        //

        SetWindowLong(
                     hWnd,
                     GWL_STYLE,
                     (( LPCREATESTRUCT ) lParam )->style
                     & CLBS_CLB
                     );

        return TRUE;
    }


    if ( message == WM_CREATE ) {

        //
        // Assert that there is no prior per window information associated
        // with this Clb.
        //

        DbgAssert( RestoreClbInfo( hWnd ) == NULL );

        //
        // Restore the original styles.
        //

        (( LPCREATESTRUCT ) lParam )->style = GetWindowLong(
                                                           hWnd,
                                                           GWLP_USERDATA
                                                           );


        //
        // Allocate a CLB_INFO object for this Clb and initialize the Clb
        // relevant fields.
        //

        ClbInfo = AllocateObject( CLB_INFO, 1 );
        DbgPointerAssert( ClbInfo );
        if (ClbInfo == NULL)
            return FALSE;

        //
        // Set the number of columns to zero so that remainder of creation
        // understands the state of the Clb.
        //

        ClbInfo->Columns = 0;

        //
        // Create the header portion of the Clb.
        //

        Success = CreateHeader( hWnd, ClbInfo, ( LPCREATESTRUCT ) lParam );
        DbgAssert( Success );

        //
        // Create the list box portion of the Clb.
        //

        Success = CreateListBox( hWnd, ClbInfo, ( LPCREATESTRUCT ) lParam );
        DbgAssert( Success );

        //
        // Adjust the column number, widths based on the heading text.
        //

        Success = AdjustClbHeadings( hWnd, ClbInfo, (( LPCREATESTRUCT ) lParam )->lpszName );
        DbgAssert( Success );

        //
        // Everything was succesfully created so set the Clb's signature
        // and save it away as part of the per window data.
        //

        SetSignature( ClbInfo );

        SaveClbInfo( ClbInfo );

        return 0;
    }

    //
    // Get the ClbInfo object for this Clb and make sure that its already
    // been created i.e. WM_CREATE was already executed and thereby initialized
    // and saved a ClbInfo object.
    //

    ClbInfo = RestoreClbInfo( hWnd );

    if ( ClbInfo != NULL ) {

        //
        // Validate that this really is a ClbInfo object.
        //

        DbgAssert( CheckSignature( ClbInfo ));

        switch ( message ) {

            case WM_DESTROY:
                {
                    //
                    // Delete the font used in the list box.
                    //

                    Success = DeleteObject( ClbInfo->hFontListBox );
                    DbgAssert( Success );

                    //
                    // Delete the array of right habd edges.
                    //

                    Success = FreeObject( ClbInfo->Right );
                    DbgAssert( Success );

                    //
                    // Delete the CLB_INFO object for this window.
                    //

                    Success = FreeObject( ClbInfo );
                    DbgAssert( Success );

                    SaveClbInfo ( ClbInfo );
                    return 0;
                }

            case WM_PAINT:
                {
                    PAINTSTRUCT     ps;
                    RECT            Rect;
                    POINT           Points[ 2 ];
                    HDC             hDC;
                    HPEN            hPen;

                    hDC = BeginPaint( hWnd, &ps );
                    DbgAssert( hDC == ps.hdc );

                    Success = GetClientRect( hWnd, &Rect );
                    DbgAssert( Success );

                    Points[ 0 ].x = 0;
                    Points[ 0 ].y = ClbInfo->HeaderHeight + 1;
                    Points[ 1 ].x = Rect.right - Rect.left;
                    Points[ 1 ].y = ClbInfo->HeaderHeight + 1;

                    hPen = GetStockObject( BLACK_PEN );
                    DbgHandleAssert( hPen );

                    hPen = SelectObject( hDC, hPen );

                    Success = Polyline( hDC, Points, NumberOfEntries( Points ));
                    DbgAssert( Success );

                    hPen = SelectObject( hDC, hPen );

                    if (hPen) {
                        Success = DeleteObject( hPen );
                        DbgAssert( Success );
                    }

                    Success = EndPaint( hWnd, &ps );
                    DbgAssert( Success );

                    return 0;
                }

            case WM_COMMAND:

                switch ( LOWORD( wParam )) {

                    case ID_LISTBOX:

                        switch ( HIWORD( wParam )) {

                            case LBN_DBLCLK:
                            case LBN_KILLFOCUS:
                            case LBN_SELCHANGE:
                                {
                                    //
                                    // These messages come to ClbWndProc because it is the parent
                                    // of the list box, but they are really intended for the parent
                                    // of the Clb.
                                    //

                                    HWND    hWndParent;

                                    //
                                    // Forward the message to the Clb's parent if it has a parent.
                                    //

                                    hWndParent = GetParent( hWnd );
                                    DbgHandleAssert( hWndParent );

                                    if ( hWndParent != NULL ) {

                                        //
                                        // Replace the control id and handle with the Clb's.
                                        //

                                        *((WORD *)(&wParam)) = (WORD)GetDlgCtrlID( hWnd );

                                        DbgAssert( LOWORD( wParam ) != 0 );

                                        lParam = ( LPARAM ) hWnd;

                                        //
                                        // Forward the message...
                                        //

                                        return SendMessage(
                                                          hWndParent,
                                                          message,
                                                          wParam,
                                                          lParam
                                                          );
                                    }
                                }
                        }
                        break;

                }
                break;

                //
                // Forward to listbox.
                //

            case LB_GETCURSEL:
            case LB_SETCURSEL:
            case LB_FINDSTRING:
            case LB_GETITEMDATA:
            case LB_RESETCONTENT:
            case WM_CHAR:
            case WM_GETDLGCODE:
            case WM_KILLFOCUS:

                return SendMessage(
                                  ClbInfo->hWndListBox,
                                  message,
                                  wParam,
                                  lParam
                                  );

            case WM_SETFOCUS:
                {
                    SetFocus(
                            ClbInfo->hWndListBox
                            );

                    return 0;
                }

            case WM_COMPAREITEM:
                {
                    //
                    // This message comes to ClbWndProc because it is the parent
                    // of the list box, but is really intended for the parent
                    // of the Clb.
                    //

                    HWND    hWndParent;

                    //
                    // Forward the message to the Clb's parent if it has a parent.
                    //

                    hWndParent = GetParent( hWnd );
                    DbgHandleAssert( hWndParent );

                    if ( hWndParent != NULL ) {

                        int                     ControlId;
                        LPCOMPAREITEMSTRUCT     lpcis;

                        lpcis = ( LPCOMPAREITEMSTRUCT ) lParam;

                        ControlId = GetDlgCtrlID( hWnd );
                        DbgAssert( ControlId != 0 );

                        //
                        // Modify the COMPAREITEMSTRUCT so that it refers to the Clb.
                        //

                        lpcis->CtlID    = ControlId;
                        lpcis->hwndItem = hWnd;

                        //
                        // Forward the message...
                        //

                        return SendMessage(
                                          hWndParent,
                                          message,
                                          ( WPARAM ) ControlId,
                                          lParam
                                          );
                    }

                    break;
                }

            case WM_DELETEITEM:
                {
                    LPDELETEITEMSTRUCT  lpditms;
                    LPCLB_ROW           ClbRow;
                    DWORD               i;


                    DbgAssert( wParam == ID_LISTBOX );

                    //
                    // Retrieve the pointer to the DELETEITEMSTRUCT.
                    //

                    lpditms = ( LPDELETEITEMSTRUCT ) lParam;
                    DbgAssert(( lpditms->CtlType == ODT_LISTBOX )
                              &&( lpditms->CtlID == ID_LISTBOX ));

                    //
                    // If there is no data, just return.
                    //

                    if ( lpditms->itemData == 0 ) {

                        return TRUE;
                    }

                    //
                    // Retrieve the CLB_ROW object for this row.
                    //

                    ClbRow = ( LPCLB_ROW ) lpditms->itemData;

                    //
                    // For each column delete the string.
                    //

                    for ( i = 0; i < ClbInfo->Columns; i++ ) {

                        //
                        // Strings were copied with _tcsdup so they must be
                        // freed with free( ).
                        //

                        free( ClbRow->Strings[ i ].String );
                    }

                    //
                    // Free the CLB_STRING object.
                    //

                    Success = FreeObject( ClbRow->Strings );
                    DbgAssert( Success );

                    //
                    // Free the CLB_ROW object.
                    //

                    Success = FreeObject( ClbRow );
                    DbgAssert( Success );

                    return TRUE;
                }

            case WM_DRAWITEM:
                {
                    LPDRAWITEMSTRUCT    lpdis;
                    BOOL                DrawFocus;

                    DbgAssert( wParam == ID_LISTBOX );

                    //
                    // Retrieve the pointer to the DRAWITEMSTRUCT.
                    //

                    lpdis = ( LPDRAWITEMSTRUCT ) lParam;
                    DbgAssert(( lpdis->CtlType == ODT_LISTBOX )
                              &&( lpdis->CtlID == ID_LISTBOX ));

                    //
                    // If there is no data, just return.
                    //

                    if ( lpdis->itemData == 0 ) {

                        return TRUE;
                    }

                    if ( lpdis->itemAction & ( ODA_DRAWENTIRE | ODA_SELECT )) {

                        DWORD               i;
                        LPCLB_ROW           ClbRow;
                        COLORREF            TextColor;
                        COLORREF            BkColor;

                        //
                        // Retrieve the CLB_ROW object for this row.
                        //

                        ClbRow = ( LPCLB_ROW ) lpdis->itemData;

                        //
                        // If the item is selected, set the selection colors.
                        //

                        if ( lpdis->itemState & ODS_SELECTED ) {

                            BkColor     = COLOR_HIGHLIGHT;
                            TextColor   = COLOR_HIGHLIGHTTEXT;

                        } else {

                            BkColor     = COLOR_WINDOW;
                            TextColor   = COLOR_WINDOWTEXT;
                        }

                        BkColor = GetSysColor( BkColor );
                        TextColor = GetSysColor( TextColor );

                        BkColor = SetBkColor( lpdis->hDC, BkColor );
                        DbgAssert( BkColor != CLR_INVALID );

                        TextColor = SetTextColor( lpdis->hDC, TextColor );
                        DbgAssert( TextColor != CLR_INVALID );


                        //
                        // For each column display the text.
                        //

                        for ( i = 0; i < ClbInfo->Columns; i++ ) {

                            RECT    ClipOpaqueRect;
                            int     x;
                            int     Left;
                            UINT    GdiErr;

                            //
                            // Depending on the format, adjust the alignment reference
                            // point (x) and the clipping rectangles left edge so that
                            // there are five pixels between each column.
                            //

                            switch ( ClbRow->Strings[ i ].Format ) {

                                case CLB_LEFT:

                                    if ( i == 0 ) {

                                        x = 2;

                                    } else {

                                        x = ClbInfo->Right[ i - 1 ] + 2;
                                    }

                                    Left = x - 2;

                                    break;

                                case CLB_RIGHT:

                                    if ( i == 0 ) {

                                        Left = 0;

                                    } else {

                                        Left = ClbInfo->Right[ i - 1 ];
                                    }

                                    x = ClbInfo->Right[ i ] - 3;

                                    break;

                                default:

                                    DbgAssert( FALSE );
                            }


                            //
                            // Set the format for this column.
                            //

                            GdiErr = SetTextAlign(
                                                 lpdis->hDC,
                                                 ClbRow->Strings[ i ].Format
                                                 | TA_TOP
                                                 );
                            DbgAssert( GdiErr != GDI_ERROR );

                            //
                            // Clip each string to its column width less two pixels
                            // (for asthetics).
                            //

                            Success = SetRect(
                                             &ClipOpaqueRect,
                                             Left,
                                             lpdis->rcItem.top,
                                             ClbInfo->Right[ i ],
                                             lpdis->rcItem.bottom
                                             );
                            DbgAssert( Success );

                            Success = ExtTextOut(
                                                lpdis->hDC,
                                                x,
                                                lpdis->rcItem.top,
                                                ETO_CLIPPED
                                                | ETO_OPAQUE,
                                                &ClipOpaqueRect,
                                                ClbRow->Strings[ i ].String,
                                                ClbRow->Strings[ i ].Length,
                                                NULL
                                                );
                            DbgAssert( Success );

                            //
                            // If the item has the focus, draw the focus rectangle.
                            //

                            DrawFocus = lpdis->itemState & ODS_FOCUS;
                        }

                    } else {

                        //
                        // If the Clb has the focus, display a focus rectangle
                        // around the selected item.
                        //

                        DrawFocus = lpdis->itemAction & ODA_FOCUS;
                    }

                    //
                    // If needed, toggle the focus rectangle.
                    //

                    if ( DrawFocus ) {

                        Success = DrawFocusRect(
                                               lpdis->hDC,
                                               &lpdis->rcItem
                                               );
                        DbgAssert( Success );
                    }

                    return TRUE;
                }

            case WM_NOTIFY:
                {
                    HD_NOTIFY * lpNot;
                    HD_ITEM   *pHDI;

                    lpNot = (HD_NOTIFY *)lParam;
                    pHDI = lpNot->pitem;

                    switch ( lpNot->hdr.code) {

                        static
                        DRAW_ERASE_LINE DrawEraseLine;

                        static
                        HPEN            hPen;

                        static
                        HDC             hDCClientListBox;
                        HD_ITEM         hdi;
                        UINT            iRight;
                        UINT            i;
                        RECT            ClientRectHeader;


                        case HDN_BEGINTRACK:
                            {

                                RECT    ClientRectListBox;

                                //
                                // Get thd HDC for the list box.
                                //

                                hDCClientListBox = GetDC( ClbInfo->hWndListBox );
                                DbgHandleAssert( hDCClientListBox );
                                if (hDCClientListBox == NULL)
                                    return FALSE;

                                //
                                // Create the pen used to display the drag position and
                                // select it into the in list box client area DC. Also set
                                // the ROP2 code so that drawing with the pen twice in the
                                // same place will erase it. This is what allows the
                                // line to drag.
                                //

                                hPen = CreatePen( PS_DOT, 1, RGB( 255, 255, 255 ));
                                DbgHandleAssert( hPen );

                                hPen = SelectObject( hDCClientListBox, hPen );
                                SetROP2( hDCClientListBox, R2_XORPEN );

                                //
                                // Set up the DRAW_ERASE_LINE structure so that the drag line is
                                // drawn from the top to the bottom of the list box at the
                                // current drag position.
                                //

                                Success = GetClientRect(
                                                       ClbInfo->hWndListBox,
                                                       &ClientRectListBox
                                                       );
                                DbgAssert( Success );

                                //
                                // Draw the initial drag line from the top to the bottom
                                // of the list box equivalent with the header edge grabbed
                                // by the user.
                                //

                                DrawEraseLine.Draw.Src.x = ClbInfo->Right[ pHDI->cxy ];
                                DrawEraseLine.Draw.Src.y = 0;
                                DrawEraseLine.Draw.Dst.x = ClbInfo->Right[ pHDI->cxy ];
                                DrawEraseLine.Draw.Dst.y =   ClientRectListBox.bottom
                                                             - ClientRectListBox.top;

                                Success = DrawLine( hDCClientListBox, &DrawEraseLine );
                                DbgAssert( Success );

                                return 0;
                            }

                        case HDN_TRACK:
                            {

                                //DWORD           Columns;

                                //
                                // Get new drag position.
                                //

                                iRight = 0;
                                hdi.mask = HDI_WIDTH;

                                for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {
                                    if (i != (UINT)lpNot->iItem) {
                                        Header_GetItem(ClbInfo->hWndHeader, i, &hdi);
                                    } else {
                                        hdi.cxy = pHDI->cxy;
                                    }
                                    iRight += hdi.cxy;
                                    ClbInfo->Right[i] = iRight;
                                }

                                GetClientRect( ClbInfo->hWndHeader, &ClientRectHeader );
                                ClbInfo->Right[i] = ClientRectHeader.right;

                                //
                                // Erase the old line and draw the new one at the new
                                // drag position.
                                //

                                Success = RedrawVerticalLine(
                                                            hDCClientListBox,
                                                            ClbInfo->Right[lpNot->iItem],
                                                            &DrawEraseLine
                                                            );
                                DbgAssert( Success );

                                return 0;
                            }

                        case HDN_ENDTRACK:

                            //
                            // Replace the old pen and delete the one created
                            // during HBN_BEGINDRAG.
                            //

                            hPen = SelectObject( hDCClientListBox, hPen );

                            if (hPen) {
                                Success = DeleteObject( hPen );
                                DbgAssert( Success );
                            }

                            //
                            // Release the DC for the list box.
                            //

                            Success = ReleaseDC( ClbInfo->hWndListBox, hDCClientListBox );
                            DbgAssert( Success );

                            Success = RedrawWindow(
                                                  hWnd,
                                                  NULL,
                                                  NULL,
                                                  RDW_ERASE
                                                  | RDW_INVALIDATE
                                                  | RDW_UPDATENOW
                                                  | RDW_ALLCHILDREN
                                                  );
                            DbgAssert( Success );

                            return 0;
                    }

                    break;
                }

            case WM_SETTEXT:

                //
                // Adjust the column number and widths based on the heading text.
                //

                Success = AdjustClbHeadings( hWnd, ClbInfo, ( LPCWSTR ) lParam );
                DbgAssert( Success );

                return Success;

            case WM_SIZE:
                {
                    HDWP    hDWP;
                    LONG    Width;
                    LONG    Height;
                    LONG    Style;
                    LONG    VScrollWidth;

                    Width   = LOWORD( lParam );
                    Height  = HIWORD( lParam );

                    hDWP = BeginDeferWindowPos( 2 );
                    DbgHandleAssert( hDWP );
                    if (hDWP == NULL)
                        return FALSE;

                    //
                    // Retrieve the list box's styles.
                    //

                    Style = GetWindowLong(
                                         ClbInfo->hWndListBox,
                                         GWL_STYLE
                                         );

                    //
                    // If the list box has a vertical scroll bar compute its
                    // width so that the header window's width can be adjusted
                    // appropriately.
                    //

                    VScrollWidth =   ( Style & WS_VSCROLL )
                                     ?   GetSystemMetrics( SM_CXVSCROLL )
                                     + ( GetSystemMetrics( SM_CXBORDER ) * 2 )
                                     : 0;

                    //
                    // Size the header window to the width of the Clb and its
                    // default / original height.
                    //

                    hDWP = DeferWindowPos(
                                         hDWP,
                                         ClbInfo->hWndHeader,
                                         NULL,
                                         0,
                                         0,
                                         Width - VScrollWidth,
                                         ClbInfo->HeaderHeight,
                                         SWP_NOACTIVATE
                                         | SWP_NOMOVE
                                         | SWP_NOZORDER
                                         );
                    DbgHandleAssert( hDWP );
                    if (hDWP == NULL)
                        return FALSE;

                    //
                    // If the list box has a vertical scroll bar, bump the width
                    // and height by two so that its border overwrites the Clb
                    // border. This eliminates a double border (and a gap) between
                    // the right and bottom edges of the scroll bar and the Clb.
                    //

                    if ( Style & WS_VSCROLL ) {

                        Height += 2;
                        Width += 2;
                    }

                    //
                    // Size the list box so that it is the size of the Clb less
                    // the height of the header window less the height of the
                    // border.
                    //

                    hDWP = DeferWindowPos(
                                         hDWP,
                                         ClbInfo->hWndListBox,
                                         NULL,
                                         0,
                                         0,
                                         Width,
                                         Height
                                         - ClbInfo->HeaderHeight
                                         - 3,
                                         SWP_NOACTIVATE
                                         | SWP_NOMOVE
                                         | SWP_NOZORDER
                                         );
                    DbgHandleAssert( hDWP );
                    if (hDWP == NULL)
                        return FALSE;

                    Success = EndDeferWindowPos( hDWP );
                    DbgAssert( Success );

                    break;
                }

        }
    }

    return DefWindowProc( hWnd, message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\clb\clb.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Clb.h

Abstract:


Author:

    David J. Gilman (davegi) 05-Feb-1993

Environment:

    User Mode

--*/

#if ! defined( _CLB_ )

#define _CLB_

#ifndef _REGEDT32_
#include "wintools.h"
#endif  // _REGEDT32_

#include <commctrl.h>

//
// Class name for the CLB.
//

#define CLB_CLASS_NAME          TEXT( "ColumnListBox" )

//
// Clb Styles.
//

#define CLBS_NOTIFY             LBS_NOTIFY
#define CLBS_SORT               LBS_SORT
#define CLBS_DISABLENOSCROLL    LBS_DISABLENOSCROLL
#define CLBS_VSCROLL            WS_VSCROLL
#define CLBS_BORDER             WS_BORDER
#define CLBS_POPOUT_HEADINGS    SBT_POPOUT
#define CLBS_SPRINGY_COLUMNS    0
                                
#define CLBS_STANDARD           (                                           \
                                      0                                     \
                                    | CLBS_NOTIFY                           \
                                    | CLBS_SORT                             \
                                    | CLBS_VSCROLL                          \
                                    | CLBS_BORDER                           \
                                )

//
// Clb string formats.
//

typedef
enum
_CLB_FORMAT {

    CLB_LEFT    = TA_LEFT,
    CLB_RIGHT   = TA_RIGHT

}   CLB_FORMAT;

//
// Clb string object.
//

typedef
struct
_CLB_STRING {

    LPTSTR          String;
    DWORD           Length;
    CLB_FORMAT      Format;
    LPVOID          Data;

}   CLB_STRING, *LPCLB_STRING;

//
// Clb row object.
//

typedef
struct
_CLB_ROW {

    DWORD           Count;
    LPCLB_STRING    Strings;
    LPVOID          Data;

}   CLB_ROW, *LPCLB_ROW;

BOOL
ClbAddData(
    IN HWND hWnd,
    IN int ControlId,
    IN LPCLB_ROW ClbRow
    );

BOOL
ClbSetColumnWidths(
    IN HWND hWnd,
    IN int ControlId,
    IN LPDWORD Widths
    );

#endif // _CLB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\lib\makefile.inc ===
#
# Create wintools.h from wintools.x
#

wintools.h: wintools.x
    wcshdr <wintools.x >wintools.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\lib\controls.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Controls.c

Abstract:

    This module contains support manipulating controls.

Author:

    David J. Gilman (davegi) 11-Dec-1992

Environment:

    User Mode

--*/

#include "wintools.h"
DWORD
DialogPrintf(
    IN HWND hWnd,
    IN int ControlId,
    IN UINT FormatId,
    IN ...
    )

/*++

Routine Description:

    Display a printf style string in the specified control of the
    supplied dialog.

Arguments:

    hWnd        - Supplies  handle to the dialog that contains the control.
    ControlId   - Supplies the id of the control where the formatted text
                  will be displayed.
    FormatId    - Supplies a resource id for a printf style format string.
    ...         - Supplies zero or more values based on the format
                  descpritors supplied in Format.

Return Value:

    None.

--*/

{
    BOOL        Success;
    DWORD       Count;
    va_list     Args;

    DbgHandleAssert( hWnd );

    //
    // Retrieve the values and format the string.
    //

    va_start( Args, FormatId );

    if( IsDlgItemUnicode( hWnd, ControlId )) {

        WCHAR   Buffer[ MAX_CHARS ];

        Count = FormatMessageW(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    NULL,
                    FormatId,
                    0,
                    Buffer,
                    sizeof( Buffer ),
                    &Args
                    );
        DbgAssert( Count != 0 );

        //
        // Display the formatted text in the specified control.
        //

        Success = SetDlgItemTextW(
                        hWnd,
                        ControlId,
                        Buffer
                        );
        DbgAssert( Success );

    } else {

        CHAR    Buffer[ MAX_CHARS ];

        Count = FormatMessageA(
                    FORMAT_MESSAGE_FROM_HMODULE,
                    NULL,
                    FormatId,
                    0,
                    Buffer,
                    sizeof( Buffer ),
                    &Args
                    );
        DbgAssert( Count != 0 );

        //
        // Display the formatted text in the specified control.
        //

        Success = SetDlgItemTextA(
                        hWnd,
                        ControlId,
                        Buffer
                        );
        DbgAssert( Success );

    }

    va_end( Args );

    return Count;
}

BOOL
EnableControl(
    IN HWND hWnd,
    IN int ControlId,
    IN BOOL Enable
    )

/*++

Routine Description:

    Enable or diable the specified control based on the supplied flag.

Arguments:

    hWnd        - Supplies the window (dialog box) handle that contains the
                  control.
    ControlId   - Supplies the control id.
    Enable      - Supplies a flag which if TRUE causes the control to be enabled
                  and disables the control if FALSE.

Return Value:

    BOOL        - Returns TRUE if the control is succesfully enabled / disabled.

--*/

{
    HWND    hWndControl;
    BOOL    Success;

    DbgHandleAssert( hWnd );

    hWndControl = GetDlgItem( hWnd, ControlId );
    DbgHandleAssert( hWndControl );
    if( hWndControl == NULL ) {
        return FALSE;
    }

    if( Enable == IsWindowEnabled( hWndControl )) {

        return TRUE;
    }

    Success = EnableWindow( hWndControl, Enable );

    // if we are always returning true then there should not be any concern
    // as to what value EnableWindow returns.

    return TRUE;    // EnableWindow is returning 8 for TRUE return Success == Enable;
}

BOOL
IsDlgItemUnicode(
    IN HWND hWnd,
    IN int ControlId
    )

/*++

Routine Description:

    Determines if the supplied dialog item is a Unicode control.

Arguments:

    hWnd        - Supplies the window (dialog box) handle that contains the
                  control.
    ControlId   - Supplies the control id.

Return Value:

    BOOL        - Returns TRUE if the control is Unicode, FALSE if ANSI.

--*/

{
    HWND    hWndControl;

    DbgHandleAssert( hWnd );

    //
    // Get the handle for the supplied control so that it can be determined
    // if it is ANSI or UNICODE.
    //

    hWndControl = GetDlgItem( hWnd, ControlId );
    DbgHandleAssert( hWndControl );

    return IsWindowUnicode( hWndControl );
}

BOOL
SetDlgItemBigInt(
    IN HWND hWnd,
    IN int ControlId,
    IN UINT Value,
    IN BOOL Signed
    )

/*++

Routine Description:

Arguments:

    hWnd        - Supplies the window (dialog box) handle that contains the
                  control or the window handle where the font should be set.
    ControlId   - Supplies the control id or xero if the hWnd is a window
                  rather than a dialog handle.

Return Value:

    BOOL        -

--*/

{
    BOOL    Success;

    if( IsDlgItemUnicode( hWnd, ControlId )) {

        Success = SetDlgItemTextW(
                    hWnd,
                    ControlId,
                    FormatBigIntegerW(
                        Value,
                        Signed
                        )
                    );
        DbgAssert( Success );

    } else {

        DbgAssert( FALSE );
    }

    return Success;
}

BOOL
SetDlgItemHex(
    IN HWND hWnd,
    IN int ControlId,
    IN UINT Value
    )

/*++

Routine Description:

Arguments:

    hWnd        - Supplies the window (dialog box) handle that contains the
                  control or the window handle where the font should be set.
    ControlId   - Supplies the control id or xero if the hWnd is a window
                  rather than a dialog handle.

Return Value:

    BOOL        -

--*/

{
    BOOL    Success;
    DWORD   Count;

    if( IsDlgItemUnicode( hWnd, ControlId )) {

        WCHAR   Buffer[ MAX_PATH ];

        Count = wsprintfW( Buffer, L"0x%08.8X", Value );
        DbgAssert(( Count != 0 ) && ( Count < MAX_PATH ));

        Success = SetDlgItemTextW( hWnd, ControlId, Buffer );
        DbgAssert( Success );

    } else {

        CHAR    Buffer[ MAX_PATH ];

        Count = wsprintfA( Buffer, "0x%08.8X", Value );
        DbgAssert(( Count != 0 ) && ( Count < MAX_PATH ));

        Success = SetDlgItemTextA( hWnd, ControlId, Buffer );
        DbgAssert( Success );
    }

    return Success;
}

BOOL
SetFixedPitchFont(
    IN HWND hWnd,
    IN int ControlId
    )

/*++

Routine Description:

    Set the font for the supplied control to the system's fixed pitch font. If
    the ControlId parameter is 0, the font is set in the supplied hWnd.

Arguments:

    hWnd        - Supplies the window (dialog box) handle that contains the
                  control or the window handle where the font should be set.
    ControlId   - Supplies the control id or xero if the hWnd is a window
                  rather than a dialog handle.

Return Value:

    BOOL        - Returns TRUE if the font is succesfully set.

--*/

{
    HFONT   hFont;

    hFont = GetStockObject( SYSTEM_FIXED_FONT );
    DbgHandleAssert( hFont );

    if( ControlId == 0 ) {

        HDC hDC;

        hDC = GetDC( hWnd );
        DbgHandleAssert( hDC );
        if( hDC == NULL ) {
            return FALSE;
        }

        SelectObject( hDC, hFont );

    } else {

        SendDlgItemMessage(
            hWnd,
            ControlId,
            WM_SETFONT,
            ( WPARAM ) hFont,
            ( LPARAM ) FALSE
            );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\lib\debug.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Debug.c

Abstract:

    This module contains debugging support.


Author:

    David J. Gilman (davegi) 30-Jul-1992

Environment:

    User Mode

--*/

//
// Global flag bits.
//

struct
DEBUG_FLAGS {

    int DebuggerAttached:1;

}   WintoolsGlobalFlags;

#if DBG

#include <stdarg.h>
#include <stdio.h>

#include "wintools.h"

//
// Internal function prototypes.
//

LPCWSTR
DebugFormatStringW(
    IN DWORD Flags,
    IN LPCWSTR Format,
    IN va_list* Args
    );

VOID
DebugAssertW(
    IN LPCWSTR Expression,
    IN LPCSTR File,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Display an assertion failure message box which gives the user a choice
    as to whether the process should be aborted, the assertion ignored or
    a break exception generated.

Arguments:

    Expression  - Supplies a string representation of the failed assertion.
    File        - Supplies a pointer to the file name where the assertion
                  failed.
    LineNumber  - Supplies the line number in the file where the assertion
                  failed.

Return Value:

    None.

--*/

{
    LPCWSTR    Buffer;
    DWORD_PTR  Args[ ] = {

        ( DWORD_PTR ) Expression,
        ( DWORD_PTR ) GetLastError( ),
        ( DWORD_PTR ) File,
        ( DWORD_PTR ) LineNumber
    };

    DbgPointerAssert( Expression );
    DbgPointerAssert( File );

    //
    // Format the assertion string that describes the failure.
    //

    Buffer = DebugFormatStringW(
        FORMAT_MESSAGE_ARGUMENT_ARRAY,
        L"Assertion Failed : %1!s! (%2!d!)\nin file %3!hs! at line %4!d!\n",
        ( va_list* ) Args
        );

    //
    // If the debugger is attached flag is set, display the string on the
    // debugger and break. If not generate a pop-up and leave the choice
    // to the user.
    //

    if( WintoolsGlobalFlags.DebuggerAttached ) {

        OutputDebugString( Buffer );
        DebugBreak( );

    } else {

        int     Response;
        WCHAR   ModuleBuffer[ MAX_PATH ];
        DWORD   Length;

        //
        // Get the asserting module's file name.
        //

        Length = GetModuleFileName(
                        NULL,
                        ModuleBuffer,
                        sizeof( ModuleBuffer )
                        );

        //
        // Display the assertin message and gives the user the choice of:
        //  Abort:  - kills the process.
        //  Retry:  - generates a breakpoint exception.
        //  Ignore: - continues the process.
        //

        Response = MessageBox(
                        NULL,
                        Buffer,
                        ( Length != 0 )
                          ? ModuleBuffer
                          : L"Assertion Failure",
                          MB_ABORTRETRYIGNORE
                        | MB_ICONHAND
                        | MB_SETFOREGROUND
                        | MB_TASKMODAL
                        );

        switch( Response ) {

        //
        // Terminate the process.
        //

        case IDABORT:
            {
                ExitProcess( (UINT) -1 );
                break;
            }

        //
        // Ignore the failed assertion.
        //

        case IDIGNORE:
            {
                break;
            }

        //
        // Break into a debugger.
        //

        case IDRETRY:
            {
                DebugBreak( );
                break;
            }

        //
        // Break into a debugger because of a catastrophic failure.
        //

        default:
            {
                DebugBreak( );
                break;
            }
        }
    }
}

VOID
DebugPrintfW(
    IN LPCWSTR Format,
    IN ...
    )

/*++

Routine Description:

    Display a printf style string on the debugger.

Arguments:

    Format      - Supplies a FormatMessage style format string.
    ...         - Supplies zero or more values based on the format
                  descpritors supplied in Format.

Return Value:

    None.

--*/

{
    LPCWSTR    Buffer;
    va_list    Args;

    DbgPointerAssert( Format );

    //
    // Retrieve the values and format the string.
    //

    va_start( Args, Format );
    Buffer = DebugFormatStringW( 0, Format, &Args );
    va_end( Args );

    //
    // Display the string on the debugger.
    //

    OutputDebugString( Buffer );

}

LPCWSTR
DebugFormatStringW(
    IN DWORD Flags,
    IN LPCWSTR Format,
    IN va_list* Args
    )

/*++

Routine Description:

    Formats a string using the FormatMessage API.

Arguments:

    Flags    - Supplies flags which are used to control the FormatMessage API.
    Format   - Supplies a printf style format string.
    Args     - Supplies a list of arguments whose format is depndent on the
               flags valuse.

Return Value:

    LPCWSTR  - Returns a pointer to the formatted string.

--*/

{
    static
    WCHAR    Buffer[ MAX_CHARS ];

    DWORD    Count;

    DbgPointerAssert( Format );

    //
    // Format the string.
    //

    Count = FormatMessageW(
                  Flags
                | FORMAT_MESSAGE_FROM_STRING
                & ~FORMAT_MESSAGE_FROM_HMODULE,
                ( LPVOID ) Format,
                0,
                0,
                Buffer,
                sizeof( Buffer ),
                Args
                );
    DbgAssert( Count != 0 );

    //
    // Return the formatted string.
    //

    return Buffer;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\clb\dlgedit.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Dlgedit.c

Abstract:

    This file contains the intrfaces necessary to use the ColumnListBox
    (clb.dll) custom control with the Dialog Editor (dlgedit.exe).

Author:

    David J. Gilman (davegi) 05-Feb-1993

Environment:

    User Mode

--*/

#include "clb.h"
#include "dialogs.h"

#include <custcntl.h>

#include <wchar.h>

typedef
struct
    _ID_STYLE_MAP {

    UINT    Id;
    UINT    Style;

}   ID_STYLE_MAP, *LPID_STYLE_MAP;

//
// Module handle for Clb.dll.
//

extern
HINSTANCE   _hModule;

//
// Default values.
//

#define CLB_DESCRIPTION     L"ColumnListBox"
#define CLB_DEFAULT_TEXT    L"Column1;Column2;Column3"
#define CLB_DEFAULT_WIDTH   ( 96 )
#define CLB_DEFAULT_HEIGHT  ( 80 )

//
// Macro to initialize CCSTYLEFLAGW structure.
//

#define MakeStyle( s, m )                                                   \
    {( s ), ( m ), L#s }

//
// Table of supported styles.
//

CCSTYLEFLAGW
Styles[ ] = {

    MakeStyle( CLBS_NOTIFY,             0 ),
    MakeStyle( CLBS_SORT,               0 ),
    MakeStyle( CLBS_DISABLENOSCROLL,    0 ),
    MakeStyle( CLBS_VSCROLL,            0 ),
    MakeStyle( CLBS_BORDER,             0 ),
    MakeStyle( CLBS_POPOUT_HEADINGS,    0 ),
    MakeStyle( CLBS_SPRINGY_COLUMNS,    0 ),
    MakeStyle( LBS_OWNERDRAWFIXED,      0 )
};

//
// Table of check box ids and their represented styles.
//

ID_STYLE_MAP
StyleCheckBox[ ] = {

    IDC_CHECK_NOTIFY,                   CLBS_NOTIFY,
    IDC_CHECK_SORT,                     CLBS_SORT,
    IDC_CHECK_DISABLENOSCROLL,          CLBS_DISABLENOSCROLL,
    IDC_CHECK_VSCROLL,                  CLBS_VSCROLL,
    IDC_CHECK_BORDER,                   CLBS_BORDER,
    IDC_CHECK_POPOUT_HEADINGS,          CLBS_POPOUT_HEADINGS,
    IDC_CHECK_SPRINGY_COLUMNS,          CLBS_SPRINGY_COLUMNS,
    IDC_CHECK_VISIBLE,                  WS_VISIBLE,
    IDC_CHECK_DISABLED,                 WS_DISABLED,
    IDC_CHECK_GROUP,                    WS_GROUP,
    IDC_CHECK_TABSTOP,                  WS_TABSTOP
};

//
// Table of check box ids and their represented standard styles.
//

ID_STYLE_MAP
StandardStyleCheckBox[ ] = {

    IDC_CHECK_NOTIFY,                   CLBS_NOTIFY,
    IDC_CHECK_SORT,                     CLBS_SORT,
    IDC_CHECK_VSCROLL,                  CLBS_VSCROLL,
    IDC_CHECK_BORDER,                   CLBS_BORDER
};

BOOL
ClbStyleW(
         IN HWND hwndParent,
         IN LPCCSTYLEW pccs
         );

INT_PTR
ClbStylesDlgProc(
                IN HWND hWnd,
                IN UINT message,
                IN WPARAM wParam,
                IN LPARAM lParam
                )

/*++

Routine Description:

    ClbStylesDlgProc is the dialog procedure for the styles dialog. It lets
    a user select what styles should be applied to the Clb when it is created.

Arguments:

    Standard dialog procedure parameters.

Return Value:

    BOOL - dependent on the supplied message.

--*/

{
    BOOL        Success;

    static
    LPCCSTYLEW  pccs;

    switch ( message ) {

        case WM_INITDIALOG:
            {
                DWORD   i;

                //
                // Save the pointer to the Custom Control Style structure.
                //

                pccs = ( LPCCSTYLEW ) lParam;

                //
                // For each style bit, if the style bit is set, check
                // the associated button.
                //

                for ( i = 0; i < NumberOfEntries( StyleCheckBox ); i++ ) {

                    if ( pccs->flStyle & StyleCheckBox[ i ].Style ) {

                        Success = CheckDlgButton(
                                                hWnd,
                                                StyleCheckBox[ i ].Id,
                                                ( UINT ) ~0
                                                );
                        DbgAssert( Success );
                    }
                }

                //
                // If all of the styles making up the standard are checked, check
                // the standard button as well.
                //

                Success = CheckDlgButton(
                                        hWnd,
                                        IDC_CHECK_STANDARD,
                                        IsDlgButtonChecked( hWnd, IDC_CHECK_NOTIFY    )
                                        & IsDlgButtonChecked( hWnd, IDC_CHECK_SORT      )
                                        & IsDlgButtonChecked( hWnd, IDC_CHECK_VSCROLL   )
                                        & IsDlgButtonChecked( hWnd, IDC_CHECK_BORDER    )
                                        );
                DbgAssert( Success );

                return TRUE;
            }

        case WM_COMMAND:

            switch ( LOWORD( wParam )) {

                //
                // Update standard style checkboxes as soon as the standard style check
                // box is clicked.
                //

                case IDC_CHECK_STANDARD:
                    {
                        switch ( HIWORD( wParam )) {

                            case BN_CLICKED:
                                {
                                    UINT    Check;
                                    DWORD   i;

                                    //
                                    // If the standard style check box is checked, check all
                                    // of the standard styles checkboxes, otherwise clear
                                    // (uncheck) them.
                                    //

                                    Check =   ( IsDlgButtonChecked( hWnd, LOWORD(wParam )))
                                              ? ( UINT ) ~0
                                              : ( UINT ) 0;

                                    for ( i = 0; i < NumberOfEntries( StandardStyleCheckBox ); i++ ) {

                                        Success = CheckDlgButton(
                                                                hWnd,
                                                                StandardStyleCheckBox[ i ].Id,
                                                                Check
                                                                );
                                        DbgAssert( Success );
                                    }

                                    return TRUE;
                                }
                        }
                        break;
                    }
                    break;

                case IDC_CHECK_NOTIFY:
                case IDC_CHECK_SORT:
                case IDC_CHECK_VSCROLL:
                case IDC_CHECK_BORDER:
                    {
                        switch ( HIWORD( wParam )) {

                            case BN_CLICKED:
                                {
                                    //
                                    // If all of the styles making up the standard are checked, check
                                    // the standard button as well.
                                    //

                                    Success = CheckDlgButton(
                                                            hWnd,
                                                            IDC_CHECK_STANDARD,
                                                            IsDlgButtonChecked( hWnd, IDC_CHECK_NOTIFY    )
                                                            & IsDlgButtonChecked( hWnd, IDC_CHECK_SORT      )
                                                            & IsDlgButtonChecked( hWnd, IDC_CHECK_VSCROLL   )
                                                            & IsDlgButtonChecked( hWnd, IDC_CHECK_BORDER    )
                                                            );
                                    DbgAssert( Success );


                                    return TRUE;
                                }
                        }
                        break;
                    }
                    break;

                case IDOK:
                    {
                        DWORD   i;

                        //
                        // For each possible style, if the user checked the button, set
                        // the associated style bit.
                        //

                        for ( i = 0; i < NumberOfEntries( StyleCheckBox ); i++ ) {

                            switch ( IsDlgButtonChecked( hWnd, StyleCheckBox[ i ].Id )) {

                                case 0:

                                    //
                                    // Button was unchecked, disable the style.
                                    //

                                    pccs->flStyle &= ~StyleCheckBox[ i ].Style;

                                    break;

                                case 1:

                                    //
                                    // Button was checked, enable the style.
                                    //

                                    pccs->flStyle |= StyleCheckBox[ i ].Style;

                                    break;

                                default:

                                    DbgAssert( FALSE );

                                    break;
                            }
                        }

                        //
                        // Return TRUE via EndDialog which will cause Dlgedit
                        // to apply the style changes.
                        //

                        return EndDialog( hWnd, ( int ) TRUE );
                    }

                case IDCANCEL:

                    //
                    // Return FALSE via EndDialog which will cause Dlgedit
                    // to ignore the style changes.
                    //

                    return EndDialog( hWnd, ( int ) FALSE );

            }
            break;
    }

    return FALSE;
}

UINT
CustomControlInfoW(
                  IN LPCCINFOW CcInfo OPTIONAL
                  )

/*++

Routine Description:

    CustomControlInfoW is called by Dlgedit to query (a) the number of
    custom controls supported by this Dll and (b) characteristics about each of
    those controls.

Arguments:

    CcInfo  - Supplies an optional pointer to an array of CCINFOW structures.
              If the pointer is NULL CustomControlInfoW returns the number of
              controls supported by this Dll. Otherwise each member of the
              array is initialized.

Return Value:

    BOOL    - Returns TRUE if the file names were succesfully added.

--*/

{
    if ( CcInfo != NULL ) {

        //
        // Clb's class name.
        //

        wcscpy( CcInfo->szClass, CLB_CLASS_NAME );

        //
        // No options (i.e. text is allowed).
        //

        CcInfo->flOptions = 0;

        //
        // Quick and dirty description of Clb.
        //

        wcscpy( CcInfo->szDesc, CLB_DESCRIPTION );

        //
        // Clb's default width.
        //

        CcInfo->cxDefault = CLB_DEFAULT_WIDTH;

        //
        // Clb's default height.
        //

        CcInfo->cyDefault = CLB_DEFAULT_HEIGHT;

        //
        // Clb's default styles. LBS_OWNERDRAWFIXED is needed in order to make
        // certain messages work properly (e.g. LB_FINDSTRING).
        //

        CcInfo->flStyleDefault =   CLBS_STANDARD
                                   | LBS_OWNERDRAWFIXED
                                   | WS_VISIBLE
                                   | WS_TABSTOP
                                   | WS_CHILD;

        //
        // No extended styles.
        //

        CcInfo->flExtStyleDefault = 0;

        //
        // No control specific styles.
        //

        CcInfo->flCtrlTypeMask = 0;

        //
        // Clb's default text (column headings).
        //

        wcscpy( CcInfo->szTextDefault, CLB_DEFAULT_TEXT );

        //
        // Number of styles supported by Clb.
        //

        CcInfo->cStyleFlags = NumberOfEntries( Styles );

        //
        // Clb's array of styles (CCSTYLEGLAGW)
        //

        CcInfo->aStyleFlags = Styles;

        //
        // Clb's styles dialog function.
        //

        CcInfo->lpfnStyle = ClbStyleW;

        //
        // No SizeToText function.
        //

        CcInfo->lpfnSizeToText = NULL;

        //
        // Reserved, must be zero.
        //

        CcInfo->dwReserved1 = 0;
        CcInfo->dwReserved2 = 0;
    }

    //
    // Tell Dlgedit that clb.dll only supports 1 control.
    //

    return 1;
}

BOOL
ClbStyleW(
         IN HWND hWndParent,
         IN LPCCSTYLEW pccs
         )

/*++

Routine Description:

    ClbStyleW is the function that is exported to, and used by, Dlgedit so that
    Clb's styles can be editted.

Arguments:

    hWndParent  - Supplies ahandle to the dialog's parent (i.e. Dlgedit).
    pccs        - Supplies a pointer to the Custom Control Style structure.

Return Value:

    BOOL        - Returns the results of the styles dialog.

--*/

{
    return ( BOOL ) DialogBoxParam(
                                  _hModule,
                                  MAKEINTRESOURCE( IDD_CLB ),
                                  hWndParent,
                                  ClbStylesDlgProc,
                                  ( LPARAM ) pccs
                                  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\lib\console.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Console.c

Abstract:

    This module contains support for displaying output on the console.

Author:

    David J. Gilman (davegi) 25-Nov-1992

Environment:

    User Mode

--*/

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include "wintools.h"

//
//  BOOL
//  IsConsoleHandle(
//      IN HANDLE ConsoleHandle
//      );
//

#define IsConsoleHandle( h )                                                \
    ((( DWORD_PTR )( h )) & 1 )

//
// Function Prototypes
//

int
VConsolePrintfW(
               IN UINT Format,
               IN va_list Args
               );

int
ConsolePrintfW(
              IN UINT Format,
              IN ...
              )

/*++

Routine Description:

    Display a printf style resource string on the console.

Arguments:

    Format  - Supplies a resource number for a printf style format string.
    ...     - Supplies zero or more values based on the format
              descrpitors supplied in Format.

Return Value:

    int     - Returns the number of characters actually written.

--*/

{
    va_list     Args;
    int         CharsOut;

    //
    // Gain access to the replacement values.
    //

    va_start( Args, Format );

    //
    // Display the string and return the number of characters displayed.
    //

    CharsOut = VConsolePrintfW( Format, Args );

    va_end( Args );

    return CharsOut;
}

int
VConsolePrintfW(
               IN UINT Format,
               IN va_list Args
               )

/*++

Routine Description:

    Display a printf style resource string on the console.

Arguments:

    Format  - Supplies a resource number for a printf style format string.
    Args    - Supplies zero or more values based on the format
              descrpitors supplied in Format.

Return Value:

    int     - Returns the number of characters actually written.

--*/

{
    LPCWSTR     FormatString;
    BOOL        Success;
    WCHAR       Buffer[ MAX_CHARS ];
    DWORD       CharsIn;
    DWORD       CharsOut;
    HANDLE      Handle;

    //
    // Attempt to retrieve the actual string resource.
    //

    FormatString = GetString( Format );
    DbgPointerAssert( FormatString );
    if ( FormatString == NULL ) {
        return 0;
    }

    //
    // Format the supplied string with the supplied arguments.
    //

    CharsIn = vswprintf( Buffer, FormatString, Args );

    //
    // Attempt to retrieve the standard output handle.
    //

    Handle = GetStdHandle( STD_OUTPUT_HANDLE );
    DbgAssert( Handle != INVALID_HANDLE_VALUE );
    if ( Handle == INVALID_HANDLE_VALUE ) {
        return 0;
    }

    //
    // If the standard output handle is a console handle, write the string.
    //

    if ( IsConsoleHandle( Handle )) {

        Success = WriteConsoleW(
                               Handle,
                               Buffer,
                               CharsIn,
                               &CharsOut,
                               NULL
                               );
    } else {

        CHAR    TmpBuffer[ MAX_CHARS ];
        int     rc;

        //
        // davegi 11/25/92
        // This only exists because other tools can't handle Unicode data.
        //
        // The standard output handle is not a console handle so convert the
        // output to ANSI and then write it.
        //

        rc = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                Buffer,
                                CharsIn,
                                TmpBuffer,
                                sizeof( TmpBuffer ),
                                NULL,
                                NULL
                                );
        DbgAssert( rc != 0 );
        if ( rc == 0 ) {
            return 0;
        }

        Success = WriteFile(
                           Handle,
                           TmpBuffer,
                           CharsIn,
                           &CharsOut,
                           NULL
                           );
    }

    DbgAssert( Success );
    DbgAssert( CharsIn == CharsOut );

    //
    // Return the number of characters written.
    //

    if ( Success ) {

        return CharsOut;

    } else {

        return 0;
    }
}

VOID
ErrorExitW(
          IN UINT ExitCode,
          IN UINT Format,
          IN ...
          )

/*++

Routine Description:

    Display a printf style resource string on the console and the exit.

Arguments:

    ExistCode   - Supplies the exit code for the process.
    Format      - Supplies a resource number for a printf style format string.
    ...         - Supplies zero or more values based on the format
                  descrpitors supplied in Format.

Return Value:

    None.

--*/

{
    va_list     Args;

    //
    // Gain access to the replacement values.
    //

    va_start( Args, Format );

    //
    // Display the string and retunr the number of characters displayed.
    //

    VConsolePrintfW( Format, Args );

    va_end( Args );

    //
    // Exit the process with the supplied exit code.
    //

    ExitProcess( ExitCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\lib\string.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    String.c

Abstract:

    This module contains support for loading resource strings.

Author:

    David J. Gilman  (davegi) 11-Sep-1992
    Gregg R. Acheson (GreggA) 28-Feb-1994

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "wintools.h"

#include <search.h>
#include <string.h>

INT
StricmpW(
        IN LPCWSTR String1,
        IN LPCWSTR String2
        )

/*++

Routine Description:

    StricmpW performs a case insesitive string compare returning a result that
    is acceptable for WM_COMPAREITEM messages.

Arguments:

    String1 - Supplies the first string to compare.
    String2 - Supplies the second string to compare.

Return Value:

    INT     - Returns:
               -1   String1 precedes String2 in the sorted order.
                0   String1 and String2 are equivalent in the sorted order.
                1   String1 follows String2 in the sorted order.

--*/

{
    INT Compare;

    Compare = _wcsicmp( String1, String2 );

    if ( Compare < 0 ) {
        return -1;
    } else if ( Compare > 0 ) {
        return 1;
    } else {
        return 0;
    }
}

LPCSTR
GetStringA(
          IN UINT StringId
          )

/*++

Routine Description:

    GetStringA returns a pointer to the ANSI string corresponding to
    the supplied resource id.

Arguments:

    StringId    - Supplies a string resource id.

Return Value:

    LPCWSTR     - Returns a pointer to a static buffer that contains
                  the ANSI string.

--*/

{
    int     Length;

    static
    CHAR    Buffer[ MAX_CHARS ];

    //
    // Load the requested string making sure that it succesfully loaded
    // and fit in the buffer.
    //

    Length = LoadStringA(
                        NULL,
                        StringId,
                        Buffer,
                        sizeof( Buffer )
                        );
    DbgAssert( Length != 0 );
    DbgAssert( Length < sizeof( Buffer ));
    if (( Length == 0 ) || ( Length >= NumberOfCharacters( Buffer ))) {
        return NULL;
    }

    return Buffer;
}

LPCWSTR
GetStringW(
          IN UINT StringId
          )

/*++

Routine Description:

    GetStringW returns a pointer to the Unicode string corresponding to
    the supplied resource id.

Arguments:

    StringId    - Supplies a string resource id.

Return Value:

    LPCWSTR     - Returns a pointer to a static buffer that contains
                  the Unicode string.

--*/

{
    int     Length;

    static
    WCHAR   Buffer[ MAX_CHARS ];

    //
    // Load the requested string making sure that it succesfully loaded
    // and fit in the buffer.
    //

    Length = LoadStringW(
                        NULL,
                        StringId,
                        Buffer,
                        sizeof( Buffer )
                        );
    DbgAssert( Length != 0 );
    DbgAssert( Length < sizeof( Buffer ));
    if (( Length == 0 ) || ( Length >= NumberOfCharacters( Buffer ))) {
        return NULL;
    }

    return Buffer;
}

LPWSTR
FormatLargeIntegerW(
                   IN PLARGE_INTEGER Value,
                   IN BOOL Signed
                   )

/*++

Routine Description:

    Converts a large integer to a string inserting thousands separators
    as appropriate.

Arguments:

    LargeInteger  - Supplies the number to be formatted.
    Signed      - Supplies a flag which if TRUE indicates that the supplied
                  value is a signed number.

Return Value:

    LPWSTR      - Returns a pointer to the formatted string.

--*/

{
    static
    CHAR pIntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};

    static
    WCHAR   Buffer[ MAX_PATH ];

    WCHAR   SThousand[ MAX_PATH ];
    DWORD   SThousandChars;
    int     Index;
    DWORD   Count;
    WCHAR   wString[ MAX_PATH ];
    CHAR    aString[ MAX_PATH ];
    LONG    OutputLength = 95;

    CHAR   Result[ 100 ], *s;
    ULONG Shift, Digit;
    LONG_PTR  Length;
    LARGE_INTEGER TempValue=*Value;


    //
    // Convert the Large Integer to a UNICODE string
    //

    Shift = 0;
    s = &Result[ 99 ];
    *s = '\0';

    do {

        TempValue = RtlExtendedLargeIntegerDivide(TempValue,10L,&Digit);
        *--s = pIntegerChars[ Digit ];

    } while (TempValue.HighPart != 0 || TempValue.LowPart != 0);


    Length = &Result[ 99 ] - s;

    if (OutputLength < 0) {

        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {

            *--s = '0';
            Length++;

        }
    }

    if ((LONG)Length > OutputLength) {

        return NULL;

    } else {

        RtlMoveMemory( aString, s, Length );

        if ((LONG)Length < OutputLength) {

            aString[ Length ] = '\0';

        }
    }

    //
    // Convert to UNICODE
    //

    Length = wsprintf( wString, L"%S", aString );

    //
    // Get the thousand separator for this locale.
    //

    SThousandChars = GetLocaleInfoW(
                                   LOCALE_USER_DEFAULT,
                                   LOCALE_STHOUSAND,
                                   SThousand,
                                   NumberOfCharacters( SThousand )
                                   );

    DbgAssert( SThousandChars != 0 );
    if ( SThousandChars == 0 ) {
        return NULL;
    }

    DbgAssert( Length < NumberOfCharacters( Buffer ));

    Index = NumberOfCharacters( Buffer ) - 1;
    Count = 0;

    //
    // Copy the NUL character.
    //

    Buffer[ Index-- ] = wString[ Length-- ];

    //
    // Copy the string in reverse order, inserting the thousands separator
    // every three characters.
    //

    while ( Length >= 0L ) {

        Buffer[ Index-- ] = wString[ Length-- ];

        Count++;

        //
        // Protect against leading separators by making sure that the last
        // digit wasn't just copied.
        //

        if (( Count == 3 ) && ( Length >= 0L )) {

            //
            // Adjust the index by the length of the thousands separator less 2
            // - one for the NUL and one because the index was already backed
            // up by one above.
            //

            Index -= SThousandChars - 2;

            wcsncpy( &Buffer[ Index ], SThousand, SThousandChars - 1 );
            Index--;
            Count = 0;
        }
    }

    //
    // Move the string to the beginning of the buffer (use MoveMemory to
    // handle overlaps).
    //

    MoveMemory(
              Buffer,
              &Buffer[ Index + 1 ],
              ( wcslen( &Buffer[ Index + 1 ]) + 1) * sizeof( WCHAR )
              );

    return Buffer;
}

LPWSTR
FormatBigIntegerW(
                 IN DWORD BigInteger,
                 IN BOOL Signed
                 )

/*++

Routine Description:

    Converts an integer to a string inserting thousands separators
    as appropriate.

Arguments:

    BigInteger  - Supplies the number to be formatted.
    Signed      - Supplies a flag which if TRUE indicates that the supplied
                  value is a signed number.

Return Value:

    LPWSTR      - Returns a pointer to the formatted string.

--*/

{
    WCHAR   Buffer1[ MAX_PATH ];
    WCHAR   SThousand[ MAX_PATH ];
    DWORD   SThousandChars;
    int     Index1;
    int     Index;
    DWORD   Count;

    static
    WCHAR   Buffer[ MAX_PATH ];

    //
    // Get the thousand separator for this locale.
    //

    SThousandChars = GetLocaleInfoW(
                                   LOCALE_USER_DEFAULT,
                                   LOCALE_STHOUSAND,
                                   SThousand,
                                   NumberOfCharacters( SThousand )
                                   );
    DbgAssert( SThousandChars != 0 );
    if ( SThousandChars == 0 ) {
        return NULL;
    }

    //
    // Convert the number to a string.
    //

    Index1 = wsprintf( Buffer1, ( Signed ) ? L"%d" : L"%u", BigInteger );
    DbgAssert( Index1 < NumberOfCharacters( Buffer ));

    Index = NumberOfCharacters( Buffer ) - 1;
    Count = 0;

    //
    // Copy the NUL character.
    //

    Buffer[ Index-- ] = Buffer1[ Index1-- ];

    //
    // Copy the string in reverse order, inserting the thousands separator
    // every three characters.
    //

    while ( Index1 >= 0 ) {

        Buffer[ Index-- ] = Buffer1[ Index1-- ];

        Count++;

        //
        // Protect against leading separators by making sure that the last
        // digit wasn't just copied.
        //

        if (( Count == 3 ) && ( Index1 >= 0 )) {

            //
            // Adjust the index by the length of the thousands separator less 2
            // - one for the NUL and one because the index was already backed
            // up by one above.
            //

            Index -= SThousandChars - 2;
            wcsncpy( &Buffer[ Index ], SThousand, SThousandChars - 1 );
            Index--;
            Count = 0;
        }
    }

    //
    // Move the string to the beginning of the buffer (use MoveMemory to
    // handle overlaps).
    //

    MoveMemory(
              Buffer,
              &Buffer[ Index + 1 ],
              ( wcslen( &Buffer[ Index + 1 ]) + 1) * sizeof( WCHAR )
              );

    return Buffer;
}

DWORD
WFormatMessageA(
               IN LPSTR Buffer,
               IN DWORD BufferSize,
               IN UINT FormatId,
               IN ...
               )

/*++

Routine Description:

    Format a printf style string and place it the supplied ANSI buffer.

Arguments:

    Buffer      - Supplies a pointer to a buffer where the formatted string
                  will be stored.
    BufferSize  - Supplies the number of bytes in the supplied buffer.
    FormatId    - Supplies a resource id for a printf style format string.
    ...         - Supplies zero or more values based on the format
                  descpritors supplied in Format.

Return Value:

    DWORD       _ Returns the number of bytes stored in the supplied buffer.

--*/

{
    DWORD       Count;
    va_list     Args;

    DbgPointerAssert( Buffer );

    //
    // Retrieve the values and format the string.
    //

    va_start( Args, FormatId );

    Count = FormatMessageA(
                          FORMAT_MESSAGE_FROM_HMODULE,
                          NULL,
                          FormatId,
                          0,
                          Buffer,
                          BufferSize,
                          &Args
                          );
    DbgAssert( Count != 0 );

    va_end( Args );

    return Count;
}

DWORD
WFormatMessageW(
               IN LPWSTR Buffer,
               IN DWORD BufferSize,
               IN UINT FormatId,
               IN ...
               )

/*++

Routine Description:

    Format a printf style string and place it the supplied Unicode buffer.

Arguments:

    Buffer      - Supplies a pointer to a buffer where the formatted string
                  will be stored.
    BufferSize  - Supplies the number of bytes in the supplied buffer.
    FormatId    - Supplies a resource id for a printf style format string.
    ...         - Supplies zero or more values based on the format
                  descpritors supplied in Format.

Return Value:

    DWORD       _ Returns the number of bytes stored in the supplied buffer.

--*/

{
    DWORD       Count;
    va_list     Args;

    DbgPointerAssert( Buffer );

    //
    // Retrieve the values and format the string.
    //

    va_start( Args, FormatId );

    Count = FormatMessageW(
                          FORMAT_MESSAGE_FROM_HMODULE,
                          NULL,
                          FormatId,
                          0,
                          Buffer,
                          BufferSize,
                          &Args
                          );
    DbgAssert( Count != 0 );

    va_end( Args );

    return Count;
}

int
__cdecl
CompareTableEntries(
                   IN const void* TableEntry1,
                   IN const void* TableEntry2
                   )

/*++

Routine Description:

    Compare the key portion of two STRING_TABLE_ENTRY objects in order to
    determine if a match was found. This routine is used as a callback function
    for the CRT lfind() function.

Arguments:

    TableEntry1 - Supplies a pointer to the first STRING_TABLE_ENTRY object
                  whose Key is use in the comparison.
    TableEntry1 - Supplies a pointer to the second STRING_TABLE_ENTRY object
                  whose Key is use in the comparison.

Return Value:

    int         - Returns:

                    < 0 TableEntry1 less than TableEntry2
                    = 0 TableEntry1 identical to TableEntry2
                    > 0 TableEntry1 greater than TableEntry2

--*/

{
    return(         ((( LPSTRING_TABLE_ENTRY ) TableEntry1 )->Key.LowPart
                     ^    (( LPSTRING_TABLE_ENTRY ) TableEntry2 )->Key.LowPart )
                    |       ((( LPSTRING_TABLE_ENTRY ) TableEntry1 )->Key.HighPart
                             ^    (( LPSTRING_TABLE_ENTRY ) TableEntry2 )->Key.HighPart ));
}

LPSTRING_TABLE_ENTRY
SearchStringTable(
                 IN LPSTRING_TABLE_ENTRY StringTable,
                 IN DWORD Count,
                 IN int Class,
                 IN DWORD Value
                 )

/*++

Routine Description:

    SearchStringTable searches the supplied table of STRING_TABLE_ENTRY objects
    looking for a match based on the supplied Class and Value.

Arguments:

    StringTable - Supplies a table of STRING_TABLE_ENTRY objects that should
                  be searched.
    Count       - Supplies the number of entries in the StringTable.
    Class       - Supplies the class to be looked up.
    Value       - Supplies the value within the class to be looked up.

Return Value:

    LPSTRING_TABLE_ENTRY - Returns a pointer to the STRING_TABLE_ENTRY if found,
                           NULL otherwise.

--*/

{
    STRING_TABLE_ENTRY     TableEntry;
    LPSTRING_TABLE_ENTRY   Id;

    DbgPointerAssert( StringTable );

    //
    // Assume that entry will not be found.
    //

    Id = NULL;

    //
    // Set up the search criteria.
    //

    TableEntry.Key.LowPart  = Value;
    TableEntry.Key.HighPart = Class;

    //
    // Do the search.
    //

    Id = _lfind(
               &TableEntry,
               StringTable,
               &Count,
               sizeof( STRING_TABLE_ENTRY ),
               CompareTableEntries
               );

    //
    // Return a pointer to the found entry.
    //

    return Id;
}

UINT
GetStringId(
           IN LPSTRING_TABLE_ENTRY StringTable,
           IN DWORD Count,
           IN int Class,
           IN DWORD Value
           )

/*++

Routine Description:

    GetStringId returns the string resource id for the requested
    STRING_TABLE_ENTRY object.

Arguments:

    StringTable - Supplies a table of STRING_TABLE_ENTRY objects that should
                  be searched.
    Count       - Supplies the number of entries in the StringTable.
    Class       - Supplies the class to be looked up.
    Value       - Supplies the value within the class to be looked up.

Return Value:

    UINT        - Returns the string resource id for the entry that matches
                  the supplied Class and value.

--*/

{
    LPSTRING_TABLE_ENTRY   Id;

    DbgPointerAssert( StringTable );

    Id = SearchStringTable(
                          StringTable,
                          Count,
                          Class,
                          Value
                          );

    if (Id) {

        return( Id->Id);

    }

    else

        return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\wintools\lib\util.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Util.c

Abstract:

    This module contains miscellaneous utility functions.

Author:

    David J. Gilman (davegi) 11-Sep-1992

Environment:

    User Mode

--*/

#include <string.h>

#include "wintools.h"

LPCWSTR
BaseNameW(
    IN LPCWSTR Name
    )


/*++

Routine Description:

    Returns the base portion of a file name if it exists.

Arguments:

    Name        - Supplies the name where the base name should be extracted
                  from.

Return Value:

    LPCWSTR     - Returns the base name.

--*/

{
    LPWSTR  String;

    DbgPointerAssert( Name );

    //
    // If the name exists, look for the last '\' character and return the
    // remaining part of name.
    //

    if( Name ) {

        String = wcsrchr( Name, L'\\' );
        return( String ) ? String + 1 : Name;
    }

    //
    // No name, return NULL.
    //

    return NULL;
}

BOOL
GetCharMetricsW(
    IN HDC hDC,
    IN LPLONG CharWidth,
    IN LPLONG CharHeight
    )

/*++

Routine Description:

    Return the width and height of a character.

Arguments:

    hDC         - Supplies a handle to the DC where the characters are to be
                  displayed.
    CharWidth   - Supplies a pointer where the character width is returned.
    CharHeight  - Supplies a pointer where the character height is returned.

Return Value:

    BOOL        - Returns TRUE if the character height and width are returned.

--*/

{
    BOOL        Success;
    TEXTMETRICW TextMetric;

    DbgHandleAssert( hDC );
    DbgPointerAssert( CharWidth );
    DbgPointerAssert( CharHeight );

    //
    // Attempt to retrieve the text metrics for the supplied DC.
    //

    Success = GetTextMetricsW( hDC, &TextMetric );
    DbgAssert( Success );
    if( Success ) {

        //
        // Compute the character width and height.
        //

        *CharWidth  = TextMetric.tmAveCharWidth;
        *CharHeight = TextMetric.tmHeight
                      + TextMetric.tmExternalLeading;
    }

    return Success;
}

BOOL
GetClientSize(
    IN HWND hWnd,
    IN LPLONG ClientWidth,
    IN LPLONG ClientHeight
    )

/*++

Routine Description:

    Return the width and height of the client area of a window.

Arguments:

    hWnd            - Supplies ahdnle to the window whose cient area size is of
                      interest
    ClientWidth     - Supplies a pointer where the window's client area width
                      is returned.
    ClientHeight    - Supplies a pointer where the window's client area height
                      is returned.

Return Value:

    BOOL            - Returns TRUE if the character height and width are
                      returned.

--*/

{
    RECT    Rect;
    BOOL    Success;

    DbgHandleAssert( hWnd );
    DbgPointerAssert( ClientWidth );
    DbgPointerAssert( ClientHeight );

    //
    // Attempt to retrieve the clieant area size for the supplied window.
    //

    Success = GetClientRect( hWnd, &Rect );
    DbgAssert( Success == TRUE );
    if( Success == TRUE ) {

        //
        // Return the client area width and height.
        //

        *ClientWidth    = Rect.right;
        *ClientHeight   = Rect.bottom;
    }

    return Success;
}

BOOL
SetScrollPosEx(
    IN HWND hWnd,
    IN INT fnBar,
    IN INT nPos,
    IN BOOL fRedraw,
    OUT PINT pnOldPos
    )

/*++

Routine Description:

    An extended version of the SetScrollPos API, that tests of the supplied
    window has scroll bars before positioning them and accounts for an
    ambiguity in the return value.

Arguments:

    hWnd        - See the SetScrollPos API.
    fnBar       - See the SetScrollPos API.
    nPos        - See the SetScrollPos API.
    fRedraw     - See the SetScrollPos API.
    pnOldPos    - Supplies an optional pointer which if present will be set to
                  the old scroll bar position.

Return Value:

    BOOL        - Returns TRUE if the scroll bar was successfully scrolled.

--*/

{
    INT     OldPos;
    LONG    Style;

    //
    // Get the window style to see if it has scroll bars to position.
    //

    Style = GetWindowLong( hWnd, GWL_STYLE );
    DbgAssert( Style != 0 );
    if( Style == 0 ) {
        return FALSE;
    }

    //
    // If the scroll bat being position is a control or if the supplied
    // windiw has scroll bars...
    //

    if(      ( fnBar == SB_CTL  )
        ||  (( fnBar == SB_HORZ ) && ( Style & WS_HSCROLL ))
        ||  (( fnBar == SB_VERT ) && ( Style & WS_VSCROLL ))) {

        //
        // Position the scroll bar.
        //

        OldPos = SetScrollPos(
                    hWnd,
                    fnBar,
                    nPos,
                    fRedraw
                    );

        //
        // SetScrollPos has an ambiguity in that it returns 0 for error which
        // means it can't be distinguished from an old position of 0. Therefore
        // special case the scenario of changing positions from 0->0 or 0->1.
        //

        if(( OldPos == 0 ) && (( nPos == 0 ) || ( nPos == 1 ))) {
            return TRUE;
        }

        DbgAssert( OldPos != 0 );
        if( OldPos == 0 ) {
            return FALSE;
        }

        //
        // If requested return the old position.
        //

        if( ARGUMENT_PRESENT( pnOldPos )) {
            *pnOldPos = OldPos;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\xcopy\argument.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    Argument

Abstract:

    Argument processing for the XCopy directory copy utility

Author:

    Ramon Juan San Andres (ramonsa) 01-May-1991

Notes:

    The arguments accepted  by the XCopy utility are:

    Source directory.-  Source path.

    Dest. directory.-   Destination path.

    Archive switch.-    Copy files that have their archive bit set

    Date.-              Copy files modified on or after the specifiec
                        date.

    Empty switch.-      Copy directories even if empty. Subdir switch
                        must also be set.

    Modify switch.-     Same as Archive switch, but turns off archive
                        bit in the source file after copying.

    Prompt switch.-     Prompts before copying each file.

    Subdir switch.-     Copies also subdirectories, unless they are empty.
                        (Empty directories are copied if the Empty switch
                        is set).

    Verify switch.-     Verifies each copy.

    Wait switch.-       Wait before starting to copy the files.

    Owner switch. -     Copy ownership and permissions

    Audit switch. -     Copy auditing information.

Revision History:


--*/


#include "ulib.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "dir.hxx"
#include "xcopy.hxx"
#include "stringar.hxx"
#include "file.hxx"
#include "filestrm.hxx"

//
// Switch characters. Used for maintaining DOS5 compatibility when
// displaying error messages
//
#define SWITCH_CHARACTERS  "dDaAeEmMpPsSvVwW?"

//
// Static variables
//

PARRAY              LexArray;
PPATH_ARGUMENT      FirstPathArgument       =   NULL;
PPATH_ARGUMENT      FirstQuotedPathArgument =   NULL;
PPATH_ARGUMENT      SecondPathArgument      =   NULL;
PPATH_ARGUMENT      SecondQuotedPathArgument =  NULL;
PFLAG_ARGUMENT      ArchiveArgument         =   NULL;
PTIMEINFO_ARGUMENT  DateArgument            =   NULL;
PFLAG_ARGUMENT      DecryptArgument         =   NULL;
PFLAG_ARGUMENT      EmptyArgument           =   NULL;
PFLAG_ARGUMENT      ModifyArgument          =   NULL;
PFLAG_ARGUMENT      PromptArgument          =   NULL;
PFLAG_ARGUMENT      OverWriteArgument       =   NULL;
PFLAG_ARGUMENT      NotOverWriteArgument    =   NULL;
PFLAG_ARGUMENT      SubdirArgument          =   NULL;
PFLAG_ARGUMENT      VerifyArgument          =   NULL;
PFLAG_ARGUMENT      WaitArgument            =   NULL;
PFLAG_ARGUMENT      HelpArgument            =   NULL;
PFLAG_ARGUMENT      ContinueArgument        =   NULL;

PFLAG_ARGUMENT      IntelligentArgument     =   NULL;
PFLAG_ARGUMENT      VerboseArgument         =   NULL;
PFLAG_ARGUMENT      OldArgument             =   NULL;
PFLAG_ARGUMENT      HiddenArgument          =   NULL;
PFLAG_ARGUMENT      ReadOnlyArgument        =   NULL;
PFLAG_ARGUMENT      SilentArgument          =   NULL;
PFLAG_ARGUMENT      NoCopyArgument          =   NULL;
PFLAG_ARGUMENT      StructureArgument       =   NULL;
PFLAG_ARGUMENT      UpdateArgument          =   NULL;
PFLAG_ARGUMENT      CopyAttrArgument        =   NULL;
PFLAG_ARGUMENT      UseShortArgument        =   NULL;
PFLAG_ARGUMENT      RestartableArgument     =   NULL;
PFLAG_ARGUMENT      OwnerArgument           =   NULL;
PFLAG_ARGUMENT      AuditArgument           =   NULL;

PSTRING_ARGUMENT    ExclusionListArgument   =   NULL;

PSTRING_ARGUMENT    InvalidSwitchArgument   =   NULL;


BOOLEAN        HelpSwitch;

//
// Prototypes
//


VOID
XCOPY::SetArguments(
    )

/*++

Routine Description:

    Obtains the arguments for the XCopy utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    PATH_ARGUMENT       LocalFirstPathArgument;
    PATH_ARGUMENT       LocalFirstQuotedPathArgument;
    PATH_ARGUMENT       LocalSecondPathArgument;
    PATH_ARGUMENT       LocalSecondQuotedPathArgument;
    FLAG_ARGUMENT       LocalArchiveArgument;
    TIMEINFO_ARGUMENT   LocalDateArgument;
    FLAG_ARGUMENT       LocalOldArgument;
    FLAG_ARGUMENT       LocalDecryptArgument;
    FLAG_ARGUMENT       LocalEmptyArgument;
    FLAG_ARGUMENT       LocalModifyArgument;
    FLAG_ARGUMENT       LocalPromptArgument;
    FLAG_ARGUMENT       LocalOverWriteArgument;
    FLAG_ARGUMENT       LocalNotOverWriteArgument;
    FLAG_ARGUMENT       LocalSubdirArgument;
    FLAG_ARGUMENT       LocalVerifyArgument;
    FLAG_ARGUMENT       LocalWaitArgument;
    FLAG_ARGUMENT       LocalHelpArgument;
    FLAG_ARGUMENT       LocalContinueArgument;
    FLAG_ARGUMENT       LocalIntelligentArgument;
    FLAG_ARGUMENT       LocalVerboseArgument;
    FLAG_ARGUMENT       LocalHiddenArgument;
    FLAG_ARGUMENT       LocalReadOnlyArgument;
    FLAG_ARGUMENT       LocalSilentArgument;
    FLAG_ARGUMENT       LocalNoCopyArgument;
    FLAG_ARGUMENT       LocalStructureArgument;
    FLAG_ARGUMENT       LocalUpdateArgument;
    FLAG_ARGUMENT       LocalCopyAttrArgument;
    FLAG_ARGUMENT       LocalUseShortArgument;
    FLAG_ARGUMENT       LocalRestartableArgument;
    FLAG_ARGUMENT       LocalOwnerArgument;
    FLAG_ARGUMENT       LocalAuditArgument;
    STRING_ARGUMENT     LocalExclusionListArgument;


    STRING_ARGUMENT     LocalInvalidSwitchArgument;
    ARRAY               LocalLexArray;

    //
    // Set the static global pointers
    //
    FirstPathArgument         = &LocalFirstPathArgument;
    FirstQuotedPathArgument   = &LocalFirstQuotedPathArgument;
    SecondPathArgument        = &LocalSecondPathArgument;
    SecondQuotedPathArgument  = &LocalSecondQuotedPathArgument;
    ArchiveArgument           = &LocalArchiveArgument;
    DateArgument              = &LocalDateArgument;
    OldArgument               = &LocalOldArgument;
    DecryptArgument           = &LocalDecryptArgument;
    EmptyArgument             = &LocalEmptyArgument;
    ModifyArgument            = &LocalModifyArgument;
    PromptArgument            = &LocalPromptArgument;
    OverWriteArgument         = &LocalOverWriteArgument;
    NotOverWriteArgument      = &LocalNotOverWriteArgument;
    SubdirArgument            = &LocalSubdirArgument;
    VerifyArgument            = &LocalVerifyArgument;
    WaitArgument              = &LocalWaitArgument;
    HelpArgument              = &LocalHelpArgument;
    ContinueArgument          = &LocalContinueArgument;
    IntelligentArgument       = &LocalIntelligentArgument;
    VerboseArgument           = &LocalVerboseArgument;
    HiddenArgument            = &LocalHiddenArgument;
    ReadOnlyArgument          = &LocalReadOnlyArgument;
    SilentArgument            = &LocalSilentArgument;
    NoCopyArgument            = &LocalNoCopyArgument;
    StructureArgument         = &LocalStructureArgument;
    UpdateArgument            = &LocalUpdateArgument;
    CopyAttrArgument          = &LocalCopyAttrArgument;
    UseShortArgument          = &LocalUseShortArgument;
    ExclusionListArgument     = &LocalExclusionListArgument;
    InvalidSwitchArgument     = &LocalInvalidSwitchArgument;
    LexArray                  = &LocalLexArray;
    RestartableArgument       = &LocalRestartableArgument;
    OwnerArgument             = &LocalOwnerArgument;
    AuditArgument             = &LocalAuditArgument;

    //
    // Parse the arguments
    //
    GetArgumentsCmd();

    //
    // Verify the arguments
    //
    CheckArgumentConsistency();

    LocalLexArray.DeleteAllMembers();
}


VOID
GetSourceAndDestinationPath(
    IN OUT  PPATH_ARGUMENT      FirstPathArgument,
    IN OUT  PPATH_ARGUMENT      FirstQuotedPathArgument,
    IN OUT  PPATH_ARGUMENT      SecondPathArgument,
    IN OUT  PPATH_ARGUMENT      SecondQuotedPathArgument,
    IN OUT  PARGUMENT_LEXEMIZER ArgLex,
    OUT     PPATH*              SourcePath,
    OUT     PPATH*              DestinationPath
    )
/*++

Routine Description:

    This routine computes the Source and Destination path from
    the given list of arguments.

Arguments:

    FirstPathArgument           - Supplies the first unquoted path argument.
    FirstQuotedPathArgument     - Supplies the first quoted path argument.
    SecondPathArgument          - Supplies the second unquoted path argument.
    SecondQuotedPathArgument    - Supplies the second quoted path argument.
    ArgLex                      - Supplies the argument lexemizer.
    SourcePath                  - Returns the source path.
    DestinationPath             - Returns the destination path.

Return Value:

    None.

--*/
{
    BOOLEAN         f, qf, s, qs;
    PPATH_ARGUMENT  source, destination;
    ULONG           i;
    PWSTRING        string, qstring;

    f = FirstPathArgument->IsValueSet();
    qf = FirstQuotedPathArgument->IsValueSet();
    s = SecondPathArgument->IsValueSet();
    qs = SecondQuotedPathArgument->IsValueSet();
    source = NULL;
    destination = NULL;
    *SourcePath = NULL;
    *DestinationPath = NULL;

    if (f && !qf && s && !qs) {

        source = FirstPathArgument;
        destination = SecondPathArgument;

    } else if (!f && qf && !s && qs) {

        source = FirstQuotedPathArgument;
        destination = SecondQuotedPathArgument;

    } else if (f && qf && !s && !qs) {

        string = FirstPathArgument->GetLexeme();
        qstring = FirstQuotedPathArgument->GetLexeme();

        for (i = 0; i < ArgLex->QueryLexemeCount(); i++) {
            if (!ArgLex->GetLexemeAt(i)->Strcmp(string)) {
                source = FirstPathArgument;
                destination = FirstQuotedPathArgument;
                break;
            }

            if (!ArgLex->GetLexemeAt(i)->Strcmp(qstring)) {
                source = FirstQuotedPathArgument;
                destination = FirstPathArgument;
                break;
            }
        }
    } else if (f && !qf && !s && !qs) {
        source = FirstPathArgument;
    } else if (!f && qf && !s && !qs) {
        source = FirstQuotedPathArgument;
    }

    if (source) {
        if (!(*SourcePath = NEW PATH) ||
            !(*SourcePath)->Initialize(source->GetPath(),
                                       VerboseArgument->IsValueSet())) {

            *SourcePath = NULL;
        }
    }

    if (destination) {
        if (!(*DestinationPath = NEW PATH) ||
            !(*DestinationPath)->Initialize(destination->GetPath(),
                                            VerboseArgument->IsValueSet())) {

            *DestinationPath = NULL;
        }
    }
}



VOID
XCOPY::GetArgumentsCmd(
   )

/*++

Routine Description:

    Obtains the arguments from the Command line

Arguments:

    None.

Return Value:

    None.

--*/

{

    ARRAY               ArgArray;
    PATH_ARGUMENT       ProgramNameArgument;
    DSTRING             CmdLine;
    DSTRING             InvalidParms;
    WCHAR               Ch;
    PWSTRING            InvalidSwitch;
    PARGUMENT_LEXEMIZER ArgLex;

    //
    // Prepare for parsing
    //
    if (//
        // Initialize the arguments
        //
        !(CmdLine.Initialize( GetCommandLine() ))                   ||
        !(ArgArray.Initialize( 15, 15 ))                            ||
        !(ProgramNameArgument.Initialize( "*" ))                    ||
        !(FirstPathArgument->Initialize( "*",  FALSE ))             ||
        !(FirstQuotedPathArgument->Initialize( "\"*\"", FALSE ))    ||
        !(SecondPathArgument->Initialize( "*", FALSE))              ||
        !(SecondQuotedPathArgument->Initialize( "\"*\"", FALSE))    ||
        !(ArchiveArgument->Initialize( "/A" ))                      ||
        !(DateArgument->Initialize( "/D:*" ))                       ||
        !(OldArgument->Initialize( "/D" ))                          ||
        !(DecryptArgument->Initialize( "/G" ))                      ||
        !(EmptyArgument->Initialize( "/E" ))                        ||
        !(ModifyArgument->Initialize( "/M" ))                       ||
        !(PromptArgument->Initialize( "/P" ))                       ||
        !(OverWriteArgument->Initialize( "/Y" ))                    ||
        !(NotOverWriteArgument->Initialize( "/-Y" ))                ||
        !(SubdirArgument->Initialize( "/S" ))                       ||
        !(VerifyArgument->Initialize( "/V" ))                       ||
        !(WaitArgument->Initialize( "/W" ))                         ||
        !(HelpArgument->Initialize( "/?" ))                         ||
        !(ContinueArgument->Initialize( "/C" ))                     ||
        !(IntelligentArgument->Initialize( "/I" ))                  ||
        !(VerboseArgument->Initialize( "/F" ))                      ||
        !(HiddenArgument->Initialize( "/H" ))                       ||
        !(ReadOnlyArgument->Initialize( "/R" ))                     ||
        !(SilentArgument->Initialize( "/Q" ))                       ||
        !(NoCopyArgument->Initialize( "/L" ))                       ||
        !(StructureArgument->Initialize( "/T" ))                    ||
        !(UpdateArgument->Initialize( "/U" ))                       ||
        !(CopyAttrArgument->Initialize( "/K" ))                     ||
        !(UseShortArgument->Initialize( "/N" ))                     ||
        !(RestartableArgument->Initialize( "/Z" ))                  ||
        !(OwnerArgument->Initialize( "/O" ))                        ||
        !(AuditArgument->Initialize( "/X" ))                        ||
        !(ExclusionListArgument->Initialize("/EXCLUDE:*"))          ||
        !(InvalidSwitchArgument->Initialize( "/*" ))                ||
        //
        // Put the arguments in the argument array
        //
        !(ArgArray.Put( &ProgramNameArgument ))                     ||
        !(ArgArray.Put( ArchiveArgument ))                          ||
        !(ArgArray.Put( DateArgument ))                             ||
        !(ArgArray.Put( OldArgument ))                              ||
        !(ArgArray.Put( DecryptArgument ))                          ||
        !(ArgArray.Put( EmptyArgument ))                            ||
        !(ArgArray.Put( ModifyArgument ))                           ||
        !(ArgArray.Put( PromptArgument ))                           ||
        !(ArgArray.Put( OverWriteArgument ))                        ||
        !(ArgArray.Put( NotOverWriteArgument ))                     ||
        !(ArgArray.Put( SubdirArgument ))                           ||
        !(ArgArray.Put( VerifyArgument ))                           ||
        !(ArgArray.Put( WaitArgument ))                             ||
        !(ArgArray.Put( HelpArgument ))                             ||
        !(ArgArray.Put( ContinueArgument ))                         ||
        !(ArgArray.Put( IntelligentArgument ))                      ||
        !(ArgArray.Put( VerboseArgument ))                          ||
        !(ArgArray.Put( HiddenArgument ))                           ||
        !(ArgArray.Put( ReadOnlyArgument ))                         ||
        !(ArgArray.Put( SilentArgument ))                           ||
        !(ArgArray.Put( RestartableArgument ))                      ||
        !(ArgArray.Put( OwnerArgument ))                            ||
        !(ArgArray.Put( AuditArgument ))                            ||
        !(ArgArray.Put( NoCopyArgument ))                           ||
        !(ArgArray.Put( StructureArgument ))                        ||
        !(ArgArray.Put( UpdateArgument ))                           ||
        !(ArgArray.Put( CopyAttrArgument ))                         ||
        !(ArgArray.Put( UseShortArgument ))                         ||
        !(ArgArray.Put( ExclusionListArgument ))                    ||
        !(ArgArray.Put( InvalidSwitchArgument ))                    ||
        !(ArgArray.Put( FirstQuotedPathArgument ))                  ||
        !(ArgArray.Put( SecondQuotedPathArgument ))                 ||
        !(ArgArray.Put( FirstPathArgument ))                        ||
        !(ArgArray.Put( SecondPathArgument ))
        )  {

        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR);
    }

    //
    // Parse the arguments
    //
    ArgLex = ParseArguments( &CmdLine, &ArgArray );

    if ( InvalidSwitchArgument->IsValueSet() ) {

        InvalidSwitch = InvalidSwitchArgument->GetString();

        InvalidParms.Initialize( SWITCH_CHARACTERS );

        Ch = InvalidSwitch->QueryChAt(0);

        if ( Ch == 'd' || Ch == 'D' ) {
            Ch = InvalidSwitch->QueryChAt(1);
            if ( Ch == INVALID_CHAR ) {
                DisplayMessageAndExit( XCOPY_ERROR_INVALID_NUMBER_PARAMETERS,
                                       NULL,
                                       EXIT_MISC_ERROR );
            } else if ( Ch != ':' || InvalidSwitch->QueryChCount() == 2 ) {
                DisplayMessageAndExit( XCOPY_ERROR_INVALID_SWITCH_SWITCH,
                                       InvalidSwitchArgument->GetLexeme(),
                                       EXIT_MISC_ERROR );
            }
        } else if ( Ch == '/' ) {
            Ch = InvalidSwitch->QueryChAt(1);
            if ( Ch == ':' && InvalidSwitchArgument->GetString()->QueryChAt(2) == INVALID_CHAR ) {
                InvalidSwitchArgument->GetLexeme()->Truncate(1);
            }
        }

        Ch = InvalidSwitch->QueryChAt(0);

        if ( InvalidParms.Strchr( Ch ) != INVALID_CHNUM ) {
            DisplayMessageAndExit( XCOPY_ERROR_INVALID_PARAMETER,
                                   InvalidSwitchArgument->GetLexeme(),
                                   EXIT_MISC_ERROR );
        } else {
            DisplayMessageAndExit( XCOPY_ERROR_INVALID_SWITCH_SWITCH,
                                   InvalidSwitchArgument->GetLexeme(),
                                   EXIT_MISC_ERROR );
        }
    }

    //
    // Set the switches
    //
    _EmptySwitch    =   EmptyArgument->QueryFlag();
    _ModifySwitch   =   ModifyArgument->QueryFlag();

    //
    // ModifySwitch implies ArchiveSwitch
    //
    if ( _ModifySwitch ) {
        _ArchiveSwitch = TRUE;
    } else {
        _ArchiveSwitch =  ArchiveArgument->QueryFlag();
    }

    //
    //  Set the switches
    //
    _PromptSwitch       =   PromptArgument->QueryFlag();
    _OverWriteSwitch    =   QueryOverWriteSwitch();
    _SubdirSwitch       =   SubdirArgument->QueryFlag();
    _VerifySwitch       =   VerifyArgument->QueryFlag();
    _WaitSwitch         =   WaitArgument->QueryFlag();
    _ContinueSwitch     =   ContinueArgument->QueryFlag();
    _IntelligentSwitch  =   IntelligentArgument->QueryFlag();
    _CopyIfOldSwitch    =   OldArgument->QueryFlag();
    _DecryptSwitch      =   DecryptArgument->QueryFlag();
    _VerboseSwitch      =   VerboseArgument->QueryFlag();
    _HiddenSwitch       =   HiddenArgument->QueryFlag();
    _ReadOnlySwitch     =   ReadOnlyArgument->QueryFlag();
    _SilentSwitch       =   SilentArgument->QueryFlag();
    _DontCopySwitch     =   NoCopyArgument->QueryFlag();
    _StructureOnlySwitch=   StructureArgument->QueryFlag();
    _UpdateSwitch       =   UpdateArgument->QueryFlag();
    _CopyAttrSwitch     =   CopyAttrArgument->QueryFlag();
    _UseShortSwitch     =   UseShortArgument->QueryFlag();
    _RestartableSwitch  =   RestartableArgument->QueryFlag();
    _OwnerSwitch        =   OwnerArgument->QueryFlag();
    _AuditSwitch        =   AuditArgument->QueryFlag();
    HelpSwitch          =   HelpArgument->QueryFlag();


    //
    // Set the source and destination paths.  Argument checking is
    // done somewhere else, so it is ok. to set the source path to
    // NULL here.
    //
    GetSourceAndDestinationPath(FirstPathArgument,
                                FirstQuotedPathArgument,
                                SecondPathArgument,
                                SecondQuotedPathArgument,
                                ArgLex,
                                &_SourcePath,
                                &_DestinationPath);

    DELETE(ArgLex);

    //
    // Set the date argument
    //

    if ( DateArgument->IsValueSet() ) {

        if ((_Date = NEW TIMEINFO) == NULL ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }

        _Date->Initialize( DateArgument->GetTimeInfo() );

        //
        //  The command-line date argument is specified in local time so
        //  that it corresponds to the output of 'dir'.  We want to compare
        //  it to file timestamps that we query from the file system, so
        //  convert the argument from local to universal time.
        //

        _Date->ConvertToUTC();

    } else {

        _Date = NULL;
    }

    if( ExclusionListArgument->IsValueSet() ) {

        InitializeExclusionList( ExclusionListArgument->GetString() );
    }
}

PARGUMENT_LEXEMIZER
XCOPY::ParseArguments(
    IN PWSTRING CmdLine,
    OUT PARRAY     ArgArray
    )

/*++

Routine Description:

    Parses a group of arguments

Arguments:

    CmdLine  -  Supplies pointer to a command line to parse
    ArgArray -  Supplies pointer to array of arguments

Return Value:

    Returns the argument lexemizer used which then needs to be freed
    by the client.

Notes:

--*/

{
    PARGUMENT_LEXEMIZER  ArgLex;

    //
    // Initialize lexeme array and the lexemizer.
    //
    if ( !(ArgLex = NEW ARGUMENT_LEXEMIZER) ||
         !(LexArray->Initialize( 9, 9 )) ||
         !(ArgLex->Initialize( LexArray )) ) {

        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY,
                               NULL,
                               EXIT_MISC_ERROR );
    }

    //
    // Set our parsing preferences
    //
    ArgLex->PutMultipleSwitch( "/?ABMDPSEVWCIFHRQLKTUNZOXY" );
    ArgLex->PutSwitches( "/" );
    ArgLex->SetCaseSensitive( FALSE );
    ArgLex->PutSeparators( " \t" );
    ArgLex->PutStartQuotes( "\"" );
    ArgLex->PutEndQuotes( "\"" );
    ArgLex->SetAllowSwitchGlomming( TRUE );
    ArgLex->SetNoSpcBetweenDstAndSwitch( TRUE );

    //
    // Parse the arguments
    //
    if ( !(ArgLex->PrepareToParse( CmdLine ))) {

        DisplayMessageAndExit( XCOPY_ERROR_PARSE,
                               NULL,
                               EXIT_MISC_ERROR );

    }

    if ( !ArgLex->DoParsing( ArgArray ) ) {

        DisplayMessageAndExit( XCOPY_ERROR_INVALID_NUMBER_PARAMETERS,
                               NULL,
                               EXIT_MISC_ERROR );
    }

    return ArgLex;
}

VOID
XCOPY::CheckArgumentConsistency (
    )

/*++

Routine Description:

   Checks the consistency of the arguments

Arguments:

   none

Return Value:

   none

Notes:

--*/

{
    PFSN_DIRECTORY      DirSrc = NULL;
    PFSN_DIRECTORY      DirDst = NULL;
    PWSTRING            DevSrc = NULL;
    PWSTRING            DevDst = NULL;
    PATH                PathSrc, PathSrc1;
    PATH                PathDst, PathDst1;
    DSTRING             Slash;

    if ( HelpSwitch ) {
        //
        // Help requested
        //
        Usage();
        DisplayMessageAndExit( 0,
                               NULL,
                               EXIT_NORMAL );
    }


    //
    // Make sure that we have a source path
    //
    if ( _SourcePath == NULL ) {

        DisplayMessageAndExit( XCOPY_ERROR_INVALID_NUMBER_PARAMETERS,
                               NULL,
                               EXIT_MISC_ERROR );
    }

    //
    //  The empty switch implies Subdir switch (note that DOS
    //  requires Subdir switch explicitly).
    //
    //
    if ( _EmptySwitch ) {
        _SubdirSwitch = TRUE;
    }


    //
    //  The StructureOnly switch imples the subdir switch
    //
    if ( _StructureOnlySwitch ) {
        _SubdirSwitch = TRUE;
    }

    //
    //  Copying audit info implies copying the rest of the security
    //  info.
    //

    _OwnerSwitch = _OwnerSwitch || _AuditSwitch;

    //
    //  Restartable copy is not available with security because
    //  secure copy uses BackupRead/Write instead of CopyFileEx.
    //

    if (_OwnerSwitch && _RestartableSwitch) {

        DisplayMessageAndExit( XCOPY_ERROR_Z_X_CONFLICT, NULL, EXIT_MISC_ERROR );
    }

    //
    // If destination path is null, then the destination path is the
    // current directory
    //
    if ( _DestinationPath == NULL ) {

        if ( ((_DestinationPath = NEW PATH) == NULL ) ||
            !_DestinationPath->Initialize( (LPWSTR)L".", TRUE ) ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }
    }

    _DestinationPath->TruncateNameAtColon();

    if ( !PathSrc1.Initialize( _SourcePath, TRUE )      ||
         !PathDst1.Initialize( _DestinationPath, TRUE ) ||
         !(DevSrc = PathSrc1.QueryDevice())             ||
         !(DevDst = PathDst1.QueryDevice())             ||
         !PathSrc.Initialize( DevSrc )                  ||
         !PathDst.Initialize( DevDst )                  ||
         !Slash.Initialize( "\\" )                      ||
         !PathSrc.AppendBase( &Slash )                  ||
         !PathDst.AppendBase( &Slash )                  ||
         !(DirSrc = SYSTEM::QueryDirectory( &PathSrc )) ||
         !(DirDst = SYSTEM::QueryDirectory( &PathDst )) ) {
        DisplayMessageAndExit( XCOPY_ERROR_INVALID_DRIVE, NULL, EXIT_MISC_ERROR );
    }
    DELETE( DevSrc );
    DELETE( DevDst );
    DELETE( DirSrc );
    DELETE( DirDst );
}

BOOLEAN
XCOPY::AddToExclusionList(
    IN  PWSTRING   ExclusionListFileName
    )
/*++

Routine Description:

    This method adds the contents of the specified file to
    the exclusion list.

Arguments:

    ExclusionListFileName   --  Supplies the name of a file which
                                contains the exclusion list.

Return Value:

    TRUE upon successful completion.

--*/
{
    PATH            ExclusionPath;
    PDSTRING        String;
    PFSN_FILE       File;
    PFILE_STREAM    Stream;
    CHNUM           Position;

    DebugPtrAssert( ExclusionListFileName );

    if( !ExclusionPath.Initialize( ExclusionListFileName ) ||
        (File = SYSTEM::QueryFile( &ExclusionPath )) == NULL ||
        (Stream = File->QueryStream( READ_ACCESS )) == NULL ) {

        DisplayMessageAndExit( MSG_COMP_UNABLE_TO_READ,
                               ExclusionListFileName,
                               EXIT_MISC_ERROR );
    }

    while( !Stream->IsAtEnd() &&
           (String = NEW DSTRING) != NULL &&
           Stream->ReadLine ( String ) ) {

        if( String->QueryChCount() == 0 ) {

            continue;
        }

        // Convert the string to upper-case and remove
        // trailing whitespace (blanks and tabs).
        //
        String->Strupr();
        Position = String->QueryChCount() - 1;

        while( Position != 0 &&
               (String->QueryChAt( Position ) == ' ' ||
                String->QueryChAt( Position ) == '\t') ) {

            Position -= 1;
        }

        if( String->QueryChAt( Position ) != ' ' &&
            String->QueryChAt( Position ) != '\t' ) {

            Position++;
        }

        if( Position != String->QueryChCount() ) {

            String->Truncate( Position );
        }

        if( String->QueryChCount() != 0 && !_ExclusionList->Put( String ) ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY,
                                   NULL,
                                   EXIT_MISC_ERROR );
        }
    }

    DELETE( Stream );
    DELETE( File );
    return TRUE;
}

BOOLEAN
XCOPY::InitializeExclusionList(
    IN  PWSTRING   ListOfFiles
    )
/*++

Routine Description:

    This method reads the exclusion list and initializes the
    exclusion list array.

Arguments:

    ListOfFiles --  Supplies a string containing a list of file
                    names, separated by '+' (e.g. file1+file2+file3)

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CurrentName;
    CHNUM   LastPosition, Position;

    DebugPtrAssert( ListOfFiles );

    if( (_ExclusionList = NEW STRING_ARRAY) == NULL ||
        !_ExclusionList->Initialize() ||
        (_Iterator = _ExclusionList->QueryIterator()) == NULL ) {

        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
    }

    LastPosition = 0;

    while( LastPosition != ListOfFiles->QueryChCount() ) {

        Position = ListOfFiles->Strchr( '+', LastPosition );

        if( Position == INVALID_CHNUM ) {

            Position = ListOfFiles->QueryChCount();
        }

        if( Position != LastPosition ) {

            if( !CurrentName.Initialize( ListOfFiles,
                                         LastPosition,
                                         Position - LastPosition ) ) {

                DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY,
                                       NULL,
                                       EXIT_MISC_ERROR );
            }

            AddToExclusionList( &CurrentName );
        }

        // Advance past any separators.
        //
        while( Position < ListOfFiles->QueryChCount() &&
               ListOfFiles->QueryChAt( Position ) == '+' ) {

            Position += 1;
        }

        LastPosition = Position;
    }

    return TRUE;
}

BOOLEAN
XCOPY::QueryOverWriteSwitch(
    )
{
    PCHAR       env;
    DSTRING     env_str;

    if (OverWriteArgument->IsValueSet() && NotOverWriteArgument->IsValueSet()) {
        return (OverWriteArgument->QueryArgPos() > NotOverWriteArgument->QueryArgPos());
    } else if (OverWriteArgument->IsValueSet())
        return OverWriteArgument->QueryFlag();
    else if (NotOverWriteArgument->IsValueSet())
        return !NotOverWriteArgument->QueryFlag();
    else {
        env = getenv("COPYCMD");
        if (env == NULL)
            return FALSE;   // use default
        else {
            if (!env_str.Initialize(env))
                return FALSE;   // to be on the safe side
            if (env_str.Stricmp(OverWriteArgument->GetPattern()) == 0)
                return TRUE;
            return FALSE;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\xcopy\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=utils
MINORCOMP=xcopy

TARGETNAME=xcopy
TARGETPATH=obj
TARGETTYPE=PROGRAM

LINKER_STACKCOMMITSIZE=16384

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\argument.cxx    \
        ..\support.cxx     \
        ..\xcopy.cxx \
        ..\xcopy.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\xcopy\support.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Support

Abstract:

	Miscelaneous support functions for the XCopy directory copy
	utility.  All functions that are not involved directly in the
	copy process go here.

Author:

	Ramon Juan San Andres (ramonsa) 02-May-1991

Revision History:

--*/



#include "ulib.hxx"
#include "system.hxx"
#include "xcopy.hxx"





VOID
XCOPY::DisplayMessageAndExit (
	IN	MSGID		MsgId,
	IN	PWSTRING	String,
	IN	ULONG		ExitCode
	)

/*++

Routine Description:

	Displays a message and exits the program with the supplied error code.
	We support a maximum of one string parameter for the message.

Arguments:

	MsgId		-	Supplies the Id of the message to display.
	String		-	Supplies a string parameter for the message.
	ExitCode	-	Supplies the exit code with which to exit.

Return Value:

    None.

Notes:

--*/

{
	//
	//	XCopy first displays the error message (if any) and then
	//	displays the number of files copied.
	//
	if ( MsgId != 0 ) {
		if ( String ) {
			DisplayMessage( MsgId, ERROR_MESSAGE, "%W", String );
		} else {
			DisplayMessage( MsgId, ERROR_MESSAGE );
		}
	}

    if ( _DontCopySwitch ) {
        DisplayMessage( XCOPY_MESSAGE_FILES, NORMAL_MESSAGE, "%d", _FilesCopied );
    } else if ( !_StructureOnlySwitch ) {
        DisplayMessage( XCOPY_MESSAGE_FILES_COPIED, NORMAL_MESSAGE, "%d", _FilesCopied );
    }
	ExitProgram( ExitCode );

}

PWSTRING
XCOPY::QueryMessageString (
	IN MSGID	MsgId
	)
/*++

Routine Description:

	Obtains a string object initialized to the contents of some message

Arguments:

	MsgId	-	Supplies ID of the message

Return Value:

	PWSTRING	-	Pointer to initialized string object

Notes:

--*/

{

	PWSTRING	String;

    if ( ((String = NEW DSTRING) == NULL )  ||
		 !(SYSTEM::QueryResourceString( String, MsgId, "" )) ) {

		DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
	}

	return String;

}

VOID
XCOPY::ExitWithError(
	IN	DWORD		ErrorCode
	)

/*++

Routine Description:

	Displays a message based on a WIN32 error code, and exits.

Arguments:

	ErrorCode	-	Supplies Windows error code

Return Value:

	none

--*/

{
	MSGID	ReadWriteMsgId = 0;

	switch ( ErrorCode ) {

	case ERROR_DISK_FULL:
		ReadWriteMsgId = XCOPY_ERROR_DISK_FULL;
		break;

	case ERROR_WRITE_PROTECT:
		ReadWriteMsgId = XCOPY_ERROR_WRITE_PROTECT;
		break;

	case ERROR_ACCESS_DENIED:
		ReadWriteMsgId =  XCOPY_ERROR_ACCESS_DENIED;
		break;

	case ERROR_SHARING_VIOLATION:
		ReadWriteMsgId =  XCOPY_ERROR_SHARING_VIOLATION;
		break;

	case ERROR_TOO_MANY_OPEN_FILES:
		ReadWriteMsgId =  XCOPY_ERROR_TOO_MANY_OPEN_FILES;
		break;

	case ERROR_LOCK_VIOLATION:
		ReadWriteMsgId =  XCOPY_ERROR_LOCK_VIOLATION;
		break;

	case ERROR_CANNOT_MAKE:
		ReadWriteMsgId =  XCOPY_ERROR_CANNOT_MAKE;
		break;

	default:
		break;
	}

	if ( ReadWriteMsgId != 0 ) {
		DisplayMessageAndExit(	ReadWriteMsgId, NULL, EXIT_READWRITE_ERROR );
	}

	Fatal(	EXIT_MISC_ERROR, XCOPY_ERROR_EXTENDED, "%d", ErrorCode );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\cdfs_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cdfs_rec.c

Abstract:

    This module contains the mini-file system recognizer for CDFS.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_CDFS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CdfsRecFsControl)
#endif // ALLOC_PRAGMA


NTSTATUS
CdfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


 -*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    //
    // Begin by determining what function that is to be performed.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_MOUNT_VOLUME:

        //
        //  Always request the filesystem driver.
        //
        
        status = STATUS_FS_DRIVER_REQUIRED;
        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        status = FsRecLoadFileSystem( DeviceObject,
                                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Cdfs" );
        break;

    default:
        
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    //
    // Finally, complete the request and return the same status code to the
    // caller.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\fat_rec.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fat_rec.h

Abstract:

    This module contains the mini-file system recognizer for FAT.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {
    UCHAR  BytesPerSector[2];                       // offset = 0x000  0
    UCHAR  SectorsPerCluster[1];                    // offset = 0x002  2
    UCHAR  ReservedSectors[2];                      // offset = 0x003  3
    UCHAR  Fats[1];                                 // offset = 0x005  5
    UCHAR  RootEntries[2];                          // offset = 0x006  6
    UCHAR  Sectors[2];                              // offset = 0x008  8
    UCHAR  Media[1];                                // offset = 0x00A 10
    UCHAR  SectorsPerFat[2];                        // offset = 0x00B 11
    UCHAR  SectorsPerTrack[2];                      // offset = 0x00D 13
    UCHAR  Heads[2];                                // offset = 0x00F 15
    UCHAR  HiddenSectors[4];                        // offset = 0x011 17
    UCHAR  LargeSectors[4];                         // offset = 0x015 21
} PACKED_BIOS_PARAMETER_BLOCK;                      // sizeof = 0x019 25

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;
} BIOS_PARAMETER_BLOCK, *PBIOS_PARAMETER_BLOCK;

//
//  Define the boot sector
//

typedef struct _PACKED_BOOT_SECTOR {
    UCHAR Jump[3];                                  // offset = 0x000   0
    UCHAR Oem[8];                                   // offset = 0x003   3
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;          // offset = 0x00B  11
    UCHAR PhysicalDriveNumber;                      // offset = 0x024  36
    UCHAR Reserved;                                 // offset = 0x025  37
    UCHAR Signature;                                // offset = 0x026  38
    UCHAR Id[4];                                    // offset = 0x027  39
    UCHAR VolumeLabel[11];                          // offset = 0x02B  43
    UCHAR SystemId[8];                              // offset = 0x036  54
} PACKED_BOOT_SECTOR;                               // sizeof = 0x03E  62

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;

//
// Define the functions provided by this driver.
//

BOOLEAN
IsFatVolume(
    IN PPACKED_BOOT_SECTOR Buffer
    );

VOID
UnpackBiosParameterBlock(
    IN PPACKED_BIOS_PARAMETER_BLOCK Bios,
    OUT PBIOS_PARAMETER_BLOCK UnpackedBios
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\utils\xcopy\xcopy.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

        XCopy.cxx

Abstract:

        Xcopy is a DOS5-Compatible directory copy utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filter.hxx"
#include "stream.hxx"
#include "system.hxx"
#include "xcopy.hxx"
#include "bigint.hxx"
#include "ifssys.hxx"
#include "stringar.hxx"
#include "arrayit.hxx"

extern "C" {
   #include <ctype.h>
   #include "winbasep.h"
}


#define CTRL_C          (WCHAR)3



int __cdecl
main (
        )

/*++

Routine Description:

        Main function of the XCopy utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    //
    //  Initialize stuff
    //
    DEFINE_CLASS_DESCRIPTOR( XCOPY );

    //
    //  Now do the copy
    //
    {
        __try {

            XCOPY XCopy;

            //
            //  Initialize the XCOPY object.
            //
            if ( XCopy.Initialize() ) {

                __try {
                //
                //  Do the copy
                //

                    XCopy.DoCopy();

                } __except ((_exception_code() == STATUS_STACK_OVERFLOW) ?
                            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

                    // display may not work due to out of stack space

                    XCopy.DisplayMessageAndExit(XCOPY_ERROR_STACK_SPACE, NULL, EXIT_MISC_ERROR);

                }
            }

        } __except ((_exception_code() == STATUS_STACK_OVERFLOW) ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

            // may not be able to display anything if initialization failed
            // in additional to out of stack space
            // so just send a message to the debug port

            DebugPrintTrace(("XCOPY: Out of stack space\n"));
            return EXIT_MISC_ERROR;

        }
    }

    return EXIT_NORMAL;
}



DEFINE_CONSTRUCTOR( XCOPY,      PROGRAM );

VOID
XCOPY::Construct (
    )
{
    _Keyboard           = NULL;
    _TargetPath         = NULL;
    _SourcePath         = NULL;
    _DestinationPath    = NULL;
    _Date               = NULL;
    _FileNamePattern    = NULL;
    _ExclusionList      = NULL;
    _Iterator           = NULL;
}




BOOLEAN
XCOPY::Initialize (
        )

/*++

Routine Description:

        Initializes the XCOPY object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Initialize program object
        //
        if( !PROGRAM::Initialize( XCOPY_MESSAGE_USAGE ) ) {

            return FALSE;
        }

        //
        //      Allocate resources
        //
        InitializeThings();

        //
        //      Parse the arguments
        //
        SetArguments();


        return TRUE;
}

XCOPY::~XCOPY (
        )

/*++

Routine Description:

        Destructs an XCopy object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Deallocate the global structures previously allocated
        //
        DeallocateThings();

        //
        //      Exit without error
        //
        if( _Standard_Input  != NULL &&
            _Standard_Output != NULL ) {

            DisplayMessageAndExit( 0, NULL, EXIT_NORMAL );
        }

}

VOID
XCOPY::InitializeThings (
        )

/*++

Routine Description:

        Initializes the global variables that need initialization

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

        //
        //      Get a keyboard, because we will need to switch back and
        //      forth between raw and cooked mode and because we need
        //      to enable ctrl-c handling (so that we can exit with
        //      the right level if the program is interrupted).
        //
        if ( !( _Keyboard = KEYBOARD::Cast(GetStandardInput()) )) {
                //
                //      Not reading from standard input, we will get
                //      the real keyboard.
                //
                _Keyboard = NEW KEYBOARD;

                if( !_Keyboard ) {

                    exit(4);
                }

                _Keyboard->Initialize();

        }

        //
        //      Set Ctrl-C handler
        //
        _Keyboard->EnableBreakHandling();

        //
        //      Initialize our internal data
        //
        _FilesCopied                = 0;
        _CanRemoveEmptyDirectories  = TRUE;
        _TargetIsFile               = FALSE;
        _TargetPath                 = NULL;
        _SourcePath                 = NULL;
        _DestinationPath            = NULL;
        _Date                       = NULL;
        _FileNamePattern            = NULL;
        _ExclusionList              = NULL;
        _Iterator                   = NULL;

        // The following switches are being used by DisplayMessageAndExit
        // before any of those boolean _*Switch is being initialized

        _DontCopySwitch             = FALSE;
        _StructureOnlySwitch        = TRUE;
}

VOID
XCOPY::DeallocateThings (
        )

/*++

Routine Description:

        Deallocates the stuff that was initialized in InitializeThings()

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Deallocate local data
        //
        DELETE( _TargetPath );
        DELETE( _SourcePath );
        DELETE( _DestinationPath );
        DELETE( _Date );
        DELETE( _FileNamePattern );
        DELETE( _Iterator );

        if( _ExclusionList ) {

            _ExclusionList->DeleteAllMembers();
        }

        DELETE( _ExclusionList );

        //
        //      Reset Ctrl-C handleing
        //
        _Keyboard->DisableBreakHandling();

        //
        //      If standard input is not the keyboard, we get rid of
        //      the keyboard object.
        //
        if ( !(_Keyboard == KEYBOARD::Cast(GetStandardInput()) )) {
                DELETE( _Keyboard );
        }
}


STATIC BOOLEAN
GetTokenHandle(
    IN OUT PHANDLE TokenHandle
    )
/*++

Routine Description:

    This routine opens the current process object and returns a
    handle to its token.

Arguments:


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    HANDLE ProcessHandle;
    BOOL Result;

    ProcessHandle = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
        GetCurrentProcessId());

    if (ProcessHandle == NULL)
        return(FALSE);


    Result = OpenProcessToken(ProcessHandle,
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TokenHandle);

    CloseHandle(ProcessHandle);

    return Result != FALSE;
}

STATIC BOOLEAN
SetPrivs(
    IN HANDLE TokenHandle,
    IN LPTSTR lpszPriv
)
/*++

Routine Description:

    This routine enables the given privilege in the given token.

Arguments:



Return Value:

    FALSE                       - Failure.
    TRUE                        - Success.

--*/
{
    LUID SetPrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges;


    //
    // First, find out the value of the privilege
    //

    if (!LookupPrivilegeValue(NULL, lpszPriv, &SetPrivilegeValue)) {
        return FALSE;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = SetPrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(TokenHandle, FALSE, &TokenPrivileges,
        sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
XCOPY::DoCopy (
        )

/*++

Routine Description:

        This is the function that performs the XCopy.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    PFSN_DIRECTORY      SourceDirectory         = NULL;
    PFSN_DIRECTORY      DestinationDirectory    = NULL;
    PFSN_DIRECTORY      PartialDirectory        = NULL;
    PATH                PathToDelete;
    WCHAR               Char;
    CHNUM               CharsInPartialDirectoryPath;
    BOOLEAN             DirDeleted;
    BOOLEAN             CopyingManyFiles;
    PATH                TmpPath;
    PFSN_FILTER         FileFilter              = NULL;
    PFSN_FILTER         DirectoryFilter         = NULL;
    WIN32_FIND_DATA     FindData;
    PWSTRING Device                  = NULL;
    HANDLE              FindHandle;

    //
    //      Make sure that we won't try to copy to ourselves
    //
    if ( _SubdirSwitch && IsCyclicalCopy( _SourcePath, _DestinationPath ) ) {

        DisplayMessageAndExit( XCOPY_ERROR_CYCLE, NULL, EXIT_MISC_ERROR );
    }

    AbortIfCtrlC();

    //
    //  Get the source directory object and the filename that we will be
    //  matching.
    //
    GetDirectoryAndFilters( _SourcePath, &SourceDirectory, &FileFilter, &DirectoryFilter, &CopyingManyFiles );

    //
    //      Make sure that we won't try to copy to ourselves
    //
    if ( _SubdirSwitch && IsCyclicalCopy( (PPATH)SourceDirectory->GetPath(), _DestinationPath ) ) {

        DisplayMessageAndExit( XCOPY_ERROR_CYCLE, NULL, EXIT_MISC_ERROR );
    }

    DebugPtrAssert( SourceDirectory );
    DebugPtrAssert( FileFilter );
    DebugPtrAssert( DirectoryFilter );

    if ( _WaitSwitch ) {

        //      Pause before we start copying.
        //
        DisplayMessage( XCOPY_MESSAGE_WAIT );

        AbortIfCtrlC();

        //
        //      All input is in raw mode.
        //
        _Keyboard->DisableLineMode();
        if( GetStandardInput()->IsAtEnd() ) {
            // Insufficient input--treat as CONTROL-C.
            //
            Char = ' ';
        } else {
            GetStandardInput()->ReadChar( &Char );
        }
        _Keyboard->EnableLineMode();

        if ( Char == CTRL_C ) {
            exit ( EXIT_TERMINATED );
        } else {
            GetStandardOutput()->WriteChar( Char );
            GetStandardOutput()->WriteChar( (WCHAR)'\r');
            GetStandardOutput()->WriteChar( (WCHAR)'\n');
        }
    }

    //
    //  Get the destination directory and the file pattern.
    //
    GetDirectoryAndFilePattern( _DestinationPath, CopyingManyFiles, &_TargetPath, &_FileNamePattern );

    DebugPtrAssert( _TargetPath );
    DebugPtrAssert( _FileNamePattern );

    //
    //      Get as much of the destination directory as possible.
    //
    if ( !_DontCopySwitch ) {
        PartialDirectory = SYSTEM::QueryDirectory( _TargetPath, TRUE );

        if (PartialDirectory == NULL ) {

            DisplayMessageAndExit( XCOPY_ERROR_CREATE_DIRECTORY, NULL, EXIT_MISC_ERROR );

        }

        //
        //  All the directories up to the parent of the target have to exist. If
        //  they don't, we have to create them.
        //
        if ( *(PartialDirectory->GetPath()->GetPathString()) ==
             *(_TargetPath->GetPathString()) ) {

            DestinationDirectory = PartialDirectory;

        } else {

            TmpPath.Initialize( _TargetPath );
            if( !_TargetIsFile ) {
                TmpPath.TruncateBase();
            }
            DestinationDirectory = PartialDirectory->CreateDirectoryPath( &TmpPath );
        }

        if( !DestinationDirectory ) {

            DisplayMessageAndExit( XCOPY_ERROR_INVALID_PATH, NULL, EXIT_MISC_ERROR );
        }


        //
        //  Determine if destination if floppy
        //
        Device = _TargetPath->QueryDevice();
        if ( Device ) {
            _DisketteCopy = (SYSTEM::QueryDriveType( Device ) == RemovableDrive);
            DELETE( Device );
        }
    }

    if (_OwnerSwitch) {

        HANDLE hToken;

        // Enable the privileges necessary to copy security information.

        if (!GetTokenHandle(&hToken)) {
            DisplayMessageAndExit(XCOPY_ERROR_NO_MEMORY,
                NULL, EXIT_MISC_ERROR );
        }
        SetPrivs(hToken, TEXT("SeBackupPrivilege"));
        SetPrivs(hToken, TEXT("SeRestorePrivilege"));
        SetPrivs(hToken, TEXT("SeSecurityPrivilege"));
        SetPrivs(hToken, TEXT("SeTakeOwnershipPrivilege"));
    }

    //
    //      Now traverse the source directory.
    //
    TmpPath.Initialize( _TargetPath );


    if (!_UpdateSwitch) {


        Traverse( SourceDirectory,
                  &TmpPath,
                  FileFilter,
                  DirectoryFilter,
                  !SourceDirectory->GetPath()->GetPathString()->Strcmp(
                      _SourcePath->GetPathString()));

    } else {

        PATH DestDirectoryPath;
        PFSN_DIRECTORY DestDirectory;

        DestDirectoryPath.Initialize(&TmpPath);
        DestDirectory = SYSTEM::QueryDirectory(&DestDirectoryPath);

        TmpPath.Initialize(SourceDirectory->GetPath());

        UpdateTraverse( DestDirectory,
                        &TmpPath,
                        FileFilter,
                        DirectoryFilter,
                        !SourceDirectory->GetPath()->GetPathString()->Strcmp(
                            _SourcePath->GetPathString()));

        DELETE(DestDirectory);
    }

    DELETE( _TargetPath);

    if (( _FilesCopied == 0 ) && _CanRemoveEmptyDirectories && !_DontCopySwitch ) {

        //
        //  Delete any directories that we created
        //
        if ( PartialDirectory != DestinationDirectory ) {

            if (!PathToDelete.Initialize( DestinationDirectory->GetPath() )) {
                    DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
            }

            CharsInPartialDirectoryPath = PartialDirectory->GetPath()->GetPathString()->QueryChCount();

            while ( PathToDelete.GetPathString()->QueryChCount() >
                            CharsInPartialDirectoryPath ) {

                    DirDeleted = DestinationDirectory->DeleteDirectory();

                    DebugAssert( DirDeleted );

                    DELETE( DestinationDirectory );

                    PathToDelete.TruncateBase();
                    DestinationDirectory = SYSTEM::QueryDirectory( &PathToDelete );
                    DebugPtrAssert( DestinationDirectory );
            }
        }

        //
        //  We display the "File not found" message only if there are no
        //  files that match our pattern, regardless of other factors such
        //  as attributes etc. This is just to maintain DOS5 compatibility.
        //
        TmpPath.Initialize( SourceDirectory->GetPath() );
        TmpPath.AppendBase( FileFilter->GetFileName() );
        if ((FindHandle = FindFirstFile( &TmpPath, &FindData )) == INVALID_HANDLE_VALUE ) {
                DisplayMessage( XCOPY_ERROR_FILE_NOT_FOUND, ERROR_MESSAGE, "%W", FileFilter->GetFileName() );
        }
        FindClose(FindHandle);

    }

    DELETE( SourceDirectory );
    if ( PartialDirectory != DestinationDirectory ) {
        DELETE( PartialDirectory );
    }
    DELETE( DestinationDirectory );
    DELETE( FileFilter );
    DELETE( DirectoryFilter );

    return TRUE;
}

BOOLEAN
XCOPY::Traverse (
    IN      PFSN_DIRECTORY  Directory,
    IN OUT  PPATH           DestinationPath,
    IN      PFSN_FILTER     FileFilter,
    IN      PFSN_FILTER     DirectoryFilter,
    IN      BOOLEAN         CopyDirectoryStreams
    )

/*++

Routine Description:

    Traverses a directory, calling the callback function for each node
    (directory of file) visited.  The traversal may be finished
    prematurely when the callback function returnes FALSE.

    The destination path is modified to reflect the directory structure
    being traversed.

Arguments:

    Directory               - Supplies pointer to directory to traverse

    DestinationPath         - Supplies pointer to path to be used with the
                                callback function.

    FileFilter              - Supplies a pointer to the file filter.

    DirectoryFilter         - Supplies a pointer to the directory filter.

    CopyDirectoryStreams    - Specifies to copy directory streams when
                                copying directories.

Return Value:

    BOOLEAN - TRUE if everything traversed
              FALSE otherwise.

--*/


{

    PFSN_DIRECTORY    TargetDirectory = NULL;
    PWSTRING          CurrentPathStr;
    PWSTRING          TargetPathStr;
    BOOLEAN           MemoryOk;
    PFSN_FILE         File;
    PFSN_DIRECTORY    Dir;
    PWSTRING          Name;
    BOOLEAN           Created = FALSE;
    PCPATH            TemplatePath = NULL;
    HANDLE            h;
    PWSTRING          CurrentFileName, PrevFileName;
    DWORD             GetNextError = ERROR_SUCCESS;

    DebugPtrAssert( Directory );
    DebugPtrAssert( DestinationPath );
    DebugPtrAssert( FileFilter );
    DebugPtrAssert( DirectoryFilter );


    //
    //  We only traverse this directory if it is not empty (unless the
    //  empty switch is set).
    //
    if ( _EmptySwitch || !Directory->IsEmpty() ) {

        //
        //      Create the target directory (if we are not copying to a file).
        //
        if ( !_TargetIsFile && !_DontCopySwitch ) {

            //
            //  The target directory may not exist, create the
            //  directory and remember that we might delete it if
            //  no files or subdirectories were created.
            //  Even if the directory exists, it may not have
            //  all the streams/ACLs in it.

            if (CopyDirectoryStreams) {
                TemplatePath = Directory->GetPath();
            }

            if (TemplatePath == NULL) {
                TargetDirectory = SYSTEM::QueryDirectory( DestinationPath );
            }

            if (!TargetDirectory) {
                TargetDirectory = MakeDirectory( DestinationPath, TemplatePath );

                if (TargetDirectory && !_CopyAttrSwitch) {
                    DWORD  dwError;
                    // always set the archive bit so that it gets backup
                    TargetDirectory->MakeArchived(&dwError);
                }
                Created = TRUE;
            }

            if ( !TargetDirectory ) {
                //
                //  If the Continue Switch is set, we just display an error message and
                //  continue, otherwise we exit with error.
                //
                if ( _ContinueSwitch ) {

                    DisplayMessage( XCOPY_ERROR_CREATE_DIRECTORY1, ERROR_MESSAGE, "%W", DestinationPath->GetPathString() );
                    return TRUE;

                } else {

                    DisplayMessageAndExit( XCOPY_ERROR_CREATE_DIRECTORY1,
                                           (PWSTRING)DestinationPath->GetPathString(),
                                            EXIT_MISC_ERROR );

                }
            }

            if( !_CopyAttrSwitch ) {

                TargetDirectory->ResetReadOnlyAttribute();
            }
        }

        //
        //      Iterate through all files and copy them as needed
        //

        MemoryOk = TRUE;
        h = NULL;
        CurrentFileName = PrevFileName = NULL;

        while ( MemoryOk &&
                (( File = (PFSN_FILE)Directory->GetNext( &h, &GetNextError )) != NULL )) {

            //
            // Don't know how expensive it is to check for infinite loop below
            //
            if (PrevFileName) {
                CurrentFileName = File->QueryName();

                if (PrevFileName && CurrentFileName) {
                    if (CurrentFileName->Strcmp(PrevFileName) == 0) {

                        // something went wrong
                        // GetNext should not return two files of the same name

                        DELETE(File);
                        DELETE(PrevFileName);
                        DELETE(CurrentFileName);

                        if (_ContinueSwitch) {
                            DisplayMessage( XCOPY_ERROR_INCOMPLETE_COPY, ERROR_MESSAGE );
                            break;
                        } else {
                            DisplayMessageAndExit( XCOPY_ERROR_INCOMPLETE_COPY, NULL, EXIT_MISC_ERROR );
                        }
                    }
                } else
                    MemoryOk = FALSE;

                DELETE(PrevFileName);
                PrevFileName = CurrentFileName;
                CurrentFileName = NULL;

                if (!MemoryOk)
                    break;

            } else
                PrevFileName = File->QueryName();

            if ( !FileFilter->DoesNodeMatch( (PFSNODE)File ) ) {
                DELETE(File);
                continue;
            }

            DebugAssert( !File->IsDirectory() );

            // If we're supposed to use the short name then convert fsnode.

            if (_UseShortSwitch && !File->UseAlternateName()) {
                DELETE(File);
                MemoryOk = FALSE;
                continue;
            }

            //
            //  Append the name portion of the node to the destination path.
            //
            Name = File->QueryName();
            DebugPtrAssert( Name );

            if ( Name ) {

                MemoryOk = DestinationPath->AppendBase( Name );
                DebugAssert( MemoryOk );

                DELETE( Name );

                if ( MemoryOk ) {
                    //
                    //  Copy the file
                    //
                    if ( !Copier( File, DestinationPath ) ) {
                        DELETE(File);
                        ExitProgram( EXIT_MISC_ERROR );
                    }

                    //
                    //  Restore the destination path
                    //
                    DestinationPath->TruncateBase();
                }

            } else {

                MemoryOk = FALSE;

            }

            DELETE(File);
        }

        DELETE(PrevFileName);
        DELETE(CurrentFileName);

        if ( MemoryOk && (_ContinueSwitch || (ERROR_SUCCESS == GetNextError) ||
                          (ERROR_NO_MORE_FILES == GetNextError))) {
            //
            //  If recursing, Traverse all the subdirectories
            //
            if ( _SubdirSwitch ) {

                MemoryOk = TRUE;
                h = NULL;

                if (Created) {
                    TargetPathStr = TargetDirectory->GetPath()->QueryFullPathString();
                    MemoryOk = (TargetPathStr != NULL);
                } else
                    TargetPathStr = NULL;

                CurrentFileName = PrevFileName = NULL;

                //
                //  Recurse thru all the subdirectories
                //
                while ( MemoryOk &&
                        (( Dir = (PFSN_DIRECTORY)Directory->GetNext( &h, &GetNextError )) != NULL )) {

                    //
                    // Don't know how expensive it is to check for infinite loop below
                    //
                    if (PrevFileName) {
                        CurrentFileName = Dir->QueryName();

                        if (PrevFileName && CurrentFileName) {
                            if (CurrentFileName->Strcmp(PrevFileName) == 0) {

                                // something went wrong
                                // GetNext should not return two files of the same name

                                DELETE(Dir);
                                DELETE(PrevFileName);
                                DELETE(CurrentFileName);

                                if (_ContinueSwitch) {
                                    DisplayMessage( XCOPY_ERROR_INCOMPLETE_COPY, ERROR_MESSAGE );
                                    break;
                                } else {
                                    DisplayMessageAndExit( XCOPY_ERROR_INCOMPLETE_COPY, NULL, EXIT_MISC_ERROR );
                                }
                            }
                        } else
                            MemoryOk = FALSE;

                        DELETE(PrevFileName);
                        PrevFileName = CurrentFileName;
                        CurrentFileName = NULL;

                        if (!MemoryOk)
                            break;

                    } else
                        PrevFileName = Dir->QueryName();

                    if ( !DirectoryFilter->DoesNodeMatch( (PFSNODE)Dir ) ) {
                        DELETE(Dir);
                        continue;
                    }

                    if (_ExclusionList != NULL &&
                        IsExcluded( Dir->GetPath() ) ) {
                        DELETE(Dir);
                        continue;
                    }

                    if (Created) {
                        CurrentPathStr = Dir->GetPath()->QueryFullPathString();
                        if (CurrentPathStr == NULL) {
                            DELETE(Dir);
                            MemoryOk = FALSE;
                            continue;
                        }
                        if (TargetPathStr->Stricmp(CurrentPathStr) == 0) {
                            DELETE(CurrentPathStr);
                            DELETE(Dir);
                            continue;
                        }
                        DELETE(CurrentPathStr);
                    }

                    DebugAssert( Dir->IsDirectory() );

                    // If we're using short names then convert this fsnode.

                    if (_UseShortSwitch && !Dir->UseAlternateName()) {
                        DELETE(Dir);
                        MemoryOk = FALSE;
                        continue;
                    }

                    //
                    //  Append the name portion of the node to the destination path.
                    //
                    Name = Dir->QueryName();
                    DebugPtrAssert( Name );

                    if ( Name ) {
                        MemoryOk = DestinationPath->AppendBase( Name );
                        DebugAssert( MemoryOk );

                        DELETE( Name );

                        _CanRemoveEmptyDirectories = (BOOLEAN)!_EmptySwitch;

                        if ( MemoryOk ) {

                            //
                            //  Recurse
                            //
                            Traverse( Dir,
                                      DestinationPath, FileFilter,
                                      DirectoryFilter, TRUE );

                            //
                            //  Restore the destination path
                            //
                            DestinationPath->TruncateBase();
                        }
                    } else {
                        MemoryOk = FALSE;
                    }
                    DELETE(Dir);
                }

                DELETE(PrevFileName);
                DELETE(CurrentFileName);

                if (TargetPathStr)
                    DELETE(TargetPathStr);
            }
        }

        if ( !MemoryOk ) {
            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }

        //
        //  If we created this directory but did not copy anything to it, we
        //  have to remove it.
        //

        if ( Created && TargetDirectory->IsEmpty() && !_EmptySwitch && !_StructureOnlySwitch) {

             SYSTEM::RemoveNode( (PFSNODE *)&TargetDirectory, TRUE );

        } else {

             DELETE( TargetDirectory );

        }

        if ((ERROR_NO_MORE_FILES != GetNextError) && (ERROR_SUCCESS != GetNextError))  {

            //
            //  Some other error when traversing a directory.  We will already have
            //  exited whatever loop we were inside due to the NULL file return.
            //

            SYSTEM::DisplaySystemError( GetNextError, !_ContinueSwitch);
        }
    }

    return TRUE;
}

BOOLEAN
XCOPY::UpdateTraverse (
    IN      PFSN_DIRECTORY  DestDirectory,
    IN OUT  PPATH           SourcePath,
    IN      PFSN_FILTER     FileFilter,
    IN      PFSN_FILTER     DirectoryFilter,
    IN      BOOLEAN         CopyDirectoryStreams
    )

/*++

Routine Description:

    Traverse routine for update.

    Like XCOPY::Traverse, except we traverse the *destination*
    directory, possibly updating files we find there.  The theory
    being that there will be fewer files in the destination than
    the source, so we can save time this way.

    The callback function is invoked on each node
    (directory or file) visited.  The traversal may be finished
    prematurely when the callback function returns FALSE.

Arguments:

    DestDirectory           - Supplies pointer to destination directory

    SourcePath              - Supplies pointer to path to be used with the
                                callback function.

    FileFilter              - Supplies a pointer to the file filter.

    DirectoryFilter         - Supplies a pointer to the directory filter.

    CopyDirectoryStreams    - Specifies to copy directory streams when
                                copying directories.

Return Value:

    BOOLEAN - TRUE if everything traversed
              FALSE otherwise.

--*/

{

    BOOLEAN             MemoryOk;
    PFSN_FILE           File;
    PFSN_DIRECTORY      Dir;
    PWSTRING            Name;
    BOOLEAN             Created = FALSE;
    PCPATH              TemplatePath = NULL;
    HANDLE              h;
    PWSTRING            CurrentFileName, PrevFileName;
    DWORD               GetNextError = ERROR_SUCCESS;

    DebugPtrAssert( SourcePath );
    DebugPtrAssert( FileFilter );
    DebugPtrAssert( DirectoryFilter );

    // Don't bother to traverse if
    // destination directory is null

    if (!DestDirectory)
        return TRUE;

    //
    //  We only traverse this directory if it is not empty (unless the
    //  empty switch is set).
    //
    if ( _EmptySwitch || !DestDirectory->IsEmpty() ) {

        //
        //      Iterate through all files and copy them as needed
        //

        MemoryOk = TRUE;
        h = NULL;
        CurrentFileName = PrevFileName = NULL;

        while (MemoryOk &&
               ((File = (PFSN_FILE)DestDirectory->GetNext( &h, &GetNextError )) != NULL)) {

            //
            // Don't know how expensive it is to check for infinite loop below
            //
            if (PrevFileName) {
                CurrentFileName = File->QueryName();

                if (PrevFileName && CurrentFileName) {
                    if (CurrentFileName->Strcmp(PrevFileName) == 0) {

                        // something went wrong
                        // GetNext should not return two files of the same name

                        DELETE(File);
                        DELETE(PrevFileName);
                        DELETE(CurrentFileName);

                        if (_ContinueSwitch) {
                            DisplayMessage( XCOPY_ERROR_INCOMPLETE_COPY, ERROR_MESSAGE );
                            break;
                        } else {
                            DisplayMessageAndExit( XCOPY_ERROR_INCOMPLETE_COPY, NULL, EXIT_MISC_ERROR );
                        }
                    }
                } else
                    MemoryOk = FALSE;

                DELETE(PrevFileName);
                PrevFileName = CurrentFileName;
                CurrentFileName = NULL;

                if (!MemoryOk)
                    break;

            } else
                PrevFileName = File->QueryName();

            if ( !FileFilter->DoesNodeMatch( (PFSNODE)File ) ) {
                DELETE(File);
                continue;
            }

            DebugAssert( !File->IsDirectory() );

            // If we're supposed to use the short name then convert fsnode.

            if (_UseShortSwitch && !File->UseAlternateName()) {
                DELETE(File);
                MemoryOk = FALSE;
                continue;
            }

            //
            //  Append the name portion of the node to the destination path.
            //
            Name = File->QueryName();
            DebugPtrAssert( Name );

            if ( Name ) {
                PFSN_FILE SourceFile;
                PATH DestinationPath;
                PATH TmpPath;

                TmpPath.Initialize(SourcePath);
                TmpPath.AppendBase(Name);

                SourceFile = SYSTEM::QueryFile(&TmpPath);

                DestinationPath.Initialize(DestDirectory->GetPath());

                MemoryOk = DestinationPath.AppendBase( Name );
                DebugAssert( MemoryOk );

                DELETE( Name );

                if ( MemoryOk && NULL != SourceFile ) {
                    //
                    //  Copy the file
                    //

                    if ( !Copier( SourceFile, &DestinationPath ) ) {
                        DELETE(SourceFile);
                        DELETE(File);
                        ExitProgram( EXIT_MISC_ERROR );
                    }
                }

                DELETE(SourceFile);

            } else {

                MemoryOk = FALSE;

            }
            DELETE(File);
        }

        DELETE(PrevFileName);
        DELETE(CurrentFileName);

        if ( MemoryOk && (_ContinueSwitch || (ERROR_SUCCESS == GetNextError) ||
                          (ERROR_NO_MORE_FILES == GetNextError))) {
            //
            //  If recursing, Traverse all the subdirectories
            //
            if ( _SubdirSwitch ) {

                MemoryOk = TRUE;
                h = NULL;
                CurrentFileName = PrevFileName = NULL;

                //
                //  Recurse thru all the subdirectories
                //
                while (MemoryOk &&
                       ((Dir = (PFSN_DIRECTORY)DestDirectory->GetNext( &h, &GetNextError )) != NULL)) {

                    //
                    // Don't know how expensive it is to check for infinite loop below
                    //
                    if (PrevFileName) {
                        CurrentFileName = Dir->QueryName();

                        if (PrevFileName && CurrentFileName) {
                            if (CurrentFileName->Strcmp(PrevFileName) == 0) {

                                // something went wrong
                                // GetNext should not return two files of the same name

                                DELETE(Dir);
                                DELETE(PrevFileName);
                                DELETE(CurrentFileName);

                                if (_ContinueSwitch) {
                                    DisplayMessage( XCOPY_ERROR_INCOMPLETE_COPY, ERROR_MESSAGE );
                                    break;
                                } else {
                                    DisplayMessageAndExit( XCOPY_ERROR_INCOMPLETE_COPY, NULL, EXIT_MISC_ERROR );
                                }
                            }
                        } else
                            MemoryOk = FALSE;

                        DELETE(PrevFileName);
                        PrevFileName = CurrentFileName;
                        CurrentFileName = NULL;

                        if (!MemoryOk)
                            break;

                    } else
                        PrevFileName = Dir->QueryName();

                    if ( !DirectoryFilter->DoesNodeMatch( (PFSNODE)Dir ) ) {
                        DELETE(Dir);
                        continue;
                    }

                    DebugAssert( Dir->IsDirectory() );

                    // If we're using short names then convert this fsnode.

                    if (_UseShortSwitch && !Dir->UseAlternateName()) {
                        DELETE(Dir);
                        MemoryOk = FALSE;
                        continue;
                    }

                    //
                    //  Append the name portion of the node to the destination
                    //  path.
                    //
                    Name = Dir->QueryName();
                    DebugPtrAssert( Name );

                    if ( Name ) {
                        MemoryOk = SourcePath->AppendBase( Name );
                        DebugAssert( MemoryOk );

                        DELETE( Name );

                        _CanRemoveEmptyDirectories = (BOOLEAN)!_EmptySwitch;

                        if ( MemoryOk ) {

                            if( _ExclusionList != NULL &&
                                IsExcluded( SourcePath ) ) {
                                SourcePath->TruncateBase();
                                DELETE(Dir);
                                continue;
                            }

                            //
                            //  Recurse
                            //

                            UpdateTraverse( Dir, SourcePath,
                                            FileFilter, DirectoryFilter, TRUE );

                        }

                        SourcePath->TruncateBase();

                    } else {
                        MemoryOk = FALSE;
                    }
                    DELETE(Dir);
                }
                DELETE(PrevFileName);
                DELETE(CurrentFileName);
            }
        }

        if ( !MemoryOk ) {
            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }
        else if ((ERROR_NO_MORE_FILES != GetNextError) && (ERROR_SUCCESS != GetNextError))  {

            //
            //  Some other error when traversing a directory.
            //

            SYSTEM::DisplaySystemError( GetNextError, !_ContinueSwitch);
        }
    }

    return TRUE;
}


XCOPY::ProgressCallBack(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData OPTIONAL
    )

/*++

Routine Description:

    Callback routine passed to CopyFileEx.

    Check to see if the user hit Ctrl-C and return appropriate
    value to CopyFileEx.

Arguments:

    TotalFileSize           - Total size of the file in bytes.

    TotalBytesTransferred   - Total number of bytes transferred.

    StreamSize              - Size of the stream being copied in bytes.

    StreamBytesTransferred  - Number of bytes in current stream transferred.

    dwStreamNumber          - Stream number of the current stream.

    dwCallBackReason        - CALLBACK_CHUNK_FINISHED if a block was transferred,
                              CALLBACK_STREAM_SWITCH if a stream completed copying.

    hSourceFile             - Handle to the source file.

    hDestinationFile        - Handle to the destination file.

    lpData                  - Pointer to opaque data that was passed to CopyFileEx.  Used
                              in this instance to pass the "this" pointer to an XCOPY object.

Return Value:

    DWORD                   - PROGRESS_STOP if a Ctrl-C was hit and the copy was restartable,
                              PROGESS_CANCEL otherwise.

--*/

{
    FILETIME LastWriteTime;

    //
    //  If the file was just created then roll back LastWriteTime a little so a subsequent
    //  xcopy /d /z
    //  will work if the copy was interrupted.
    //
    if ( dwStreamNumber == 1 && dwCallbackReason == CALLBACK_STREAM_SWITCH )
    {
        if ( GetFileTime(hSourceFile, NULL, NULL, &LastWriteTime) )
        {
            LastWriteTime.dwLowDateTime -= 1000;
            SetFileTime(hDestinationFile, NULL, NULL, &LastWriteTime);
        }
    }

    switch (dwCallbackReason) {
        case PRIVCALLBACK_STREAMS_NOT_SUPPORTED:
        case PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED:
        case PRIVCALLBACK_ENCRYPTION_NOT_SUPPORTED:
        case PRIVCALLBACK_EAS_NOT_SUPPORTED:
        case PRIVCALLBACK_SPARSE_NOT_SUPPORTED:
            return PROGRESS_CONTINUE;

        case PRIVCALLBACK_ENCRYPTION_FAILED:
            // GetLastError will return ERROR_NOT_SUPPORTED if PROGRESS_STOP is
            // returned.  The message is misleading so display our own error
            // message and return PROGRESS_CANCEL.
            ((XCOPY *)lpData)->DisplayMessage(XCOPY_ERROR_ENCRYPTION_FAILED);
            return PROGRESS_CANCEL;

        case PRIVCALLBACK_COMPRESSION_FAILED:
        case PRIVCALLBACK_SPARSE_FAILED:
        case PRIVCALLBACK_DACL_ACCESS_DENIED:
        case PRIVCALLBACK_SACL_ACCESS_DENIED:
        case PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED:
        case PRIVCALLBACK_OWNER_GROUP_FAILED:
            // display whatever GetLastError() contains
            return PROGRESS_STOP;

        case PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED:
            // GetLastError will return ERROR_NOT_SUPPORTED if PROGRESS_STOP is
            // returned.  The message is misleading so display our own error
            // message and return PROGRESS_CANCEL.
            ((XCOPY *)lpData)->DisplayMessage(XCOPY_ERROR_SECURITY_INFO_NOT_SUPPORTED);
            return PROGRESS_CANCEL;
    }

    // GetPFlagBreak returns a pointer to the flag indicating whether a Ctrl-C was hit
    if ( *((( XCOPY *) lpData)->_Keyboard->GetPFlagBreak()) )
        return ((XCOPY *) lpData)->_RestartableSwitch ? PROGRESS_STOP : PROGRESS_CANCEL;

    return PROGRESS_CONTINUE;
}

BOOLEAN
XCOPY::Copier (
        IN OUT  PFSN_FILE       File,
        IN      PPATH           DestinationPath
        )
/*++

Routine Description:

        This is the heart of XCopy. This is the guy who actually does
        the copying.

Arguments:

        File            -       Supplies pointer to the source File.
        DestinationPath -       Supplies path of the desired destination.

Return Value:

        BOOLEAN -       TRUE if copy successful.
                                FALSE otherwise

Notes:

--*/

{
    PATH                PathToCopy;
    PCWSTRING           Name;
    COPY_ERROR          CopyError;
    PFSN_FILE           TargetFile = NULL;
    BOOLEAN             Proceed;
    DWORD               Attempts;
    WCHAR               PathBuffer[MAX_PATH + 3];
    FSTRING             WriteBuffer;
    FSTRING             EndOfLine;
    DSTRING             ErrorMessage;
    PATH                CanonSourcePath;
    BOOLEAN             badCopy;
    ULONG               flags;
    PTIMEINFO           SourceFileTime, TargetFileTime;
    BOOLEAN             TargetFileEncrypted, TargetFileExist;


    EndOfLine.Initialize((PWSTR) L"\r\n");
    PathBuffer[0] = 0;
    WriteBuffer.Initialize(PathBuffer, MAX_PATH+3);


    //
    //  Maximum number of attempts to copy a file
    //
    #define MAX_ATTEMPTS    3

    AbortIfCtrlC();

    _CanRemoveEmptyDirectories = FALSE;

    if( _ExclusionList != NULL && IsExcluded( File->GetPath() ) ) {

        return TRUE;
    }

    if ( _TargetIsFile ) {

        //
        //  We replace the entire path
        //
        PathToCopy.Initialize( _TargetPath->GetPathString() );
        PathToCopy.AppendBase( _FileNamePattern );

    } else {

        //
        //  Set the correct target file name.
        //
        PathToCopy.Initialize( DestinationPath );
        if (!PathToCopy.ModifyName( _FileNamePattern )) {

            _Message.Set(MSG_COMP_UNABLE_TO_EXPAND);
            _Message.Display("%W%W", PathToCopy.QueryName(),
                                     _FileNamePattern);
            return FALSE;
        }
    }

    //
    //  If in Update or CopyIfOld mode, determine if the target file
    //  already exists and if it is older than the source file.
    //

    TargetFile = SYSTEM::QueryFile( &PathToCopy );
    if (TargetFile) {
        TargetFileEncrypted = TargetFile->IsEncrypted();
        TargetFileExist = TRUE;
    } else
        TargetFileEncrypted = TargetFileExist = FALSE;

    if ( _CopyIfOldSwitch || _UpdateSwitch ) {

        if ( TargetFile ) {

            //
            //  Target exists. If in CopyIfOld mode, copy only if target
            //  is older. If in Update mode, copy always.
            //
            if ( _CopyIfOldSwitch ) {
                SourceFileTime = File->QueryTimeInfo();
                TargetFileTime = TargetFile->QueryTimeInfo();
                if (SourceFileTime && TargetFileTime)
                    Proceed = (*SourceFileTime > *TargetFileTime);
                else {
                    DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                }
                DELETE(SourceFileTime);
                DELETE(TargetFileTime);
            } else {
                Proceed = TRUE;
            }

            if ( !Proceed ) {
                DELETE( TargetFile );
                return TRUE;
            }
        } else if ( _UpdateSwitch ) {
            //
            //  In update mode but target does not exist. We do not
            //  copy.
            //
            return TRUE;
        }
    }

    DELETE(TargetFile);

    //
    //      If the target is a file, we use that file path. Otherwise
    //      we figure out the correct path for the destination. Then
    //      we do the copy.
    //
    Name = File->GetPath()->GetPathString();

    //
    //      Make sure that we are not copying to ourselves
    //
    CanonSourcePath.Initialize(Name, TRUE);
    badCopy = (*(CanonSourcePath.GetPathString()) == *(PathToCopy.GetPathString()));

    if ( (!_PromptSwitch ||
          UserConfirmedCopy( File->GetPath()->GetPathString(),
                             _VerboseSwitch ? PathToCopy.GetPathString() : NULL )) &&
         (badCopy ||
          _OverWriteSwitch ||
          !TargetFileExist ||
          UserConfirmedOverWrite( &PathToCopy )) ) {

        //
        //  If we are not prompting, we display the file name (unless we
        //  are in silent mode ).
        //
        if ( !_PromptSwitch && !_SilentSwitch && !_StructureOnlySwitch ) {
            if ( _VerboseSwitch ) {

                DisplayMessage( XCOPY_MESSAGE_VERBOSE_COPY, NORMAL_MESSAGE, "%W%W", Name, PathToCopy.GetPathString() );

            } else {
                WriteBuffer.Resize(0);
                if (WriteBuffer.Strcat(Name) &&
                    WriteBuffer.Strcat(&EndOfLine)) {

                    GetStandardOutput()->WriteString(&WriteBuffer);

                } else {
                    DisplayMessage( XCOPY_ERROR_PATH_TOO_LONG, ERROR_MESSAGE );
                }
            }
        }

        //
        //      Make sure that we are not copying to ourselves
        //
        if (badCopy) {
            DisplayMessageAndExit( XCOPY_ERROR_SELF_COPY, NULL, EXIT_MISC_ERROR );
        }

        //
        //  Copy file (unless we are in display-only mode)
        //
        if ( _DontCopySwitch || _StructureOnlySwitch ) {

            _FilesCopied++;

        } else {

            Attempts  = 0;

            while ( TRUE ) {
                LPPROGRESS_ROUTINE Progress = NULL;
                PBOOL PCancelFlag = NULL;
                BOOLEAN bSuccess;
                //
                //  If copying to floppy, we must determine if there is
                //  enough disk space for the file, and if not then we
                //  must ask for another disk and create all the directory
                //  structure up to the parent directory.
                //
                if ( _DisketteCopy ) {

                    if (!CheckTargetSpace( File, &PathToCopy ))
                        return FALSE;
                }

                Progress = (LPPROGRESS_ROUTINE) ProgressCallBack;
                PCancelFlag = _Keyboard->GetPFlagBreak();

                flags = (_ReadOnlySwitch ? FSN_FILE_COPY_OVERWRITE_READ_ONLY : 0);
                flags |= (!_CopyAttrSwitch ? FSN_FILE_COPY_RESET_READ_ONLY : 0);
                flags |= (_RestartableSwitch ? FSN_FILE_COPY_RESTARTABLE : 0);
                flags |= (_OwnerSwitch ? FSN_FILE_COPY_COPY_OWNER : 0);
                flags |= (_AuditSwitch ? FSN_FILE_COPY_COPY_ACL : 0);
                flags |= (_DecryptSwitch ? FSN_FILE_COPY_ALLOW_DECRYPTED_DESTINATION : 0);

                bSuccess = File->Copy(&PathToCopy, &CopyError, flags,
                                      Progress, (VOID *)this,
                                      PCancelFlag);

                if (bSuccess) {

                    if (!_CopyAttrSwitch && (TargetFile = SYSTEM::QueryFile( &PathToCopy )) ) {
                        DWORD dwError;
                        TargetFile->MakeArchived(&dwError);
                        DELETE(TargetFile);
                    }

                    if ( _ModifySwitch ) {
                        File->ResetArchivedAttribute();
                    }

                    if( _VerifySwitch ) {

                        // Check that the new file is the same length as
                        // the old file.
                        //
                        if( (TargetFile = SYSTEM::QueryFile( &PathToCopy )) == NULL ||
                            TargetFile->QuerySize() != File->QuerySize() ) {

                            DELETE( TargetFile );

                            DisplayMessage( XCOPY_ERROR_VERIFY_FAILED, ERROR_MESSAGE );
                            if ( !_ContinueSwitch ) {
                                return FALSE;
                            }

                            break;
                        }

                        DELETE( TargetFile );
                    }

                    _FilesCopied++;

                    break;

                } else {

                    //
                    //  If the copy was cancelled mid-stream, exit.
                    //
                    AbortIfCtrlC();

                    if (CopyError == COPY_ERROR_REQUEST_ABORTED)
                        return FALSE;

                    if (CopyError == COPY_ERROR_ACCESS_DENIED &&
                        TargetFileExist && TargetFileEncrypted) {
                        Attempts = MAX_ATTEMPTS;
                    }

                    //
                    //  In case of error, wait for a little while and try
                    //  again, otherwise display the error.
                    //
                    if ( Attempts++ < MAX_ATTEMPTS ) {

                        Sleep( 100 );

                    } else {

                        switch ( CopyError ) {

                        case COPY_ERROR_ACCESS_DENIED:
                            DisplayMessage( XCOPY_ERROR_ACCESS_DENIED, ERROR_MESSAGE);
                            break;

                        case COPY_ERROR_SHARE_VIOLATION:
                            DisplayMessage( XCOPY_ERROR_SHARING_VIOLATION, ERROR_MESSAGE);
                            break;

                        default:

                            //
                            //  At this point we don't know if the copy left a
                            //  bogus file on disk. If the target file exist,
                            //  we assume that it is bogus so we delete it.
                            //
                            if ((TargetFile = SYSTEM::QueryFile( &PathToCopy )) &&
                                !_RestartableSwitch) {

                                TargetFile->DeleteFromDisk( TRUE );

                                DELETE( TargetFile );
                            }

                            switch ( CopyError ) {
                              case COPY_ERROR_DISK_FULL:
                                DisplayMessageAndExit( XCOPY_ERROR_DISK_FULL, NULL, EXIT_MISC_ERROR );
                                break;

                              default:
                                if (SYSTEM::QueryWindowsErrorMessage(CopyError, &ErrorMessage)) {
                                    DisplayMessage( XCOPY_ERROR_CANNOT_MAKE, ERROR_MESSAGE, "%W", &ErrorMessage );
                                }
                                break;
                            }

                            break;
                        }

                        if ( !_ContinueSwitch ) {
                            return FALSE;
                        }

                        break;
                    }
                }
            }
        }
    }

    DELETE( TargetFile );

    return TRUE;
}

PFSN_DIRECTORY
XCOPY::MakeDirectory (
        IN      PPATH           DestinationPath,
        IN      PCPATH          TemplatePath
        )
/*++

Routine Description:

        This is the heart of XCopy. This is the guy who actually does
        the copying.

Arguments:

        DestinationPath -       Supplies path of the desired directory
        TemplatePath    -       Supplies path of the source directory

Return Value:

        BOOLEAN -       TRUE if copy successful.  FALSE otherwise.

Notes:

--*/

{
    ULONG           flags;
    BOOLEAN         bSuccess;
    PFSN_DIRECTORY  rtn;
    DSTRING         ErrorMessage;
    COPY_ERROR      CopyError;


    flags  = (_RestartableSwitch ? FSN_FILE_COPY_RESTARTABLE : 0);
    flags |= (_OwnerSwitch ? FSN_FILE_COPY_COPY_OWNER : 0);
    flags |= (_AuditSwitch ? FSN_FILE_COPY_COPY_ACL : 0);

    rtn = SYSTEM::MakeDirectory( DestinationPath,
                                 TemplatePath,
                                 &CopyError,
                                 (LPPROGRESS_ROUTINE)ProgressCallBack,
                                 (VOID *)this,
                                 _Keyboard->GetPFlagBreak(),
                                 flags );

    if (rtn == NULL) {
        //
        //  If the copy was cancelled mid-stream, exit.
        //
        AbortIfCtrlC();

        switch ( CopyError ) {
          case COPY_ERROR_SUCCESS:
            DisplayMessage( XCOPY_ERROR_UNKNOWN, ERROR_MESSAGE);
            break;

          case COPY_ERROR_REQUEST_ABORTED:
            break;

          case COPY_ERROR_ACCESS_DENIED:
            DisplayMessage( XCOPY_ERROR_ACCESS_DENIED, ERROR_MESSAGE);
            break;

          case COPY_ERROR_SHARE_VIOLATION:
            DisplayMessage( XCOPY_ERROR_SHARING_VIOLATION, ERROR_MESSAGE);
            break;

          case COPY_ERROR_DISK_FULL:
            DisplayMessageAndExit( XCOPY_ERROR_DISK_FULL, NULL, EXIT_MISC_ERROR );
            break;

          default:
            if (SYSTEM::QueryWindowsErrorMessage(CopyError, &ErrorMessage))
                DisplayMessage( XCOPY_ERROR_CANNOT_MAKE, ERROR_MESSAGE, "%W", &ErrorMessage );
            break;
        }
    }

    return rtn;
}


BOOLEAN
XCOPY::CheckTargetSpace (
    IN OUT  PFSN_FILE   File,
    IN      PPATH       DestinationPath
    )
/*++

Routine Description:

    Makes sure that there is enought disk space in the target disk.
    Asks the user to change the disk if necessary.

Arguments:

    File            -   Supplies pointer to the source File.
    DestinationPath -   Supplies path of the desired destination.

Return Value:

    BOOLEAN -   TRUE if OK
                FALSE otherwise

--*/
{

    PFSN_FILE           TargetFile = NULL;
    BIG_INT             TargetSize;
    PWSTRING            TargetDrive;
    WCHAR               Resp;
    DSTRING             TargetRoot;
    DSTRING             Slash;
    PATH                TmpPath;
    PATH                TmpPath1;
    PFSN_DIRECTORY      PartialDirectory        = NULL;
    PFSN_DIRECTORY      DestinationDirectory    = NULL;
    BOOLEAN             DirDeleted              = NULL;
    PATH                PathToDelete;
    CHNUM               CharsInPartialDirectoryPath;
    BIG_INT             FreeSpace;
    BIG_INT             FileSize;

    if ( TargetFile = SYSTEM::QueryFile( DestinationPath ) ) {

        TargetSize = TargetFile->QuerySize();

        DELETE( TargetFile );

    } else {

        TargetSize = 0;
    }

    TargetDrive = DestinationPath->QueryDevice();

    FileSize = File->QuerySize();

    if ( TargetDrive ) {

        TargetRoot.Initialize( TargetDrive );

        if ( TargetRoot.QueryChAt( TargetRoot.QueryChCount()-1) != (WCHAR)'\\' ) {
            Slash.Initialize( "\\" );
            TargetRoot.Strcat( &Slash );
        }


        while ( TRUE ) {

            if ( IFS_SYSTEM::QueryFreeDiskSpace( &TargetRoot, &FreeSpace ) ) {

                FreeSpace = FreeSpace + TargetSize;

                // DebugPrintTrace(( "Disk Space: %d Needed: %d\n", FreeSpace.GetLowPart(), FileSize.GetLowPart() ));

                if ( FreeSpace < FileSize ) {

                    //
                    //  Not enough free space, ask for another
                    //  disk and create the directory structure.
                    //
                    DisplayMessage( XCOPY_MESSAGE_CHANGE_DISK, NORMAL_MESSAGE );
                    AbortIfCtrlC();

                    _Keyboard->DisableLineMode();
                    if ( GetStandardInput()->IsAtEnd() ) {
                        // Insufficient input--treat as CONTROL-C.
                        //
                        Resp = CTRL_C;
                    } else {
                        GetStandardInput()->ReadChar( &Resp );
                    }
                    _Keyboard->EnableLineMode();

                    if ( Resp == CTRL_C ) {
                        exit( EXIT_TERMINATED );
                    } else {
                        GetStandardOutput()->WriteChar( Resp );
                        GetStandardOutput()->WriteChar( '\r' );
                        GetStandardOutput()->WriteChar( '\n' );
                    }

                    //
                    //  Create directory structure in target
                    //
                    TmpPath.Initialize( DestinationPath );
                    TmpPath.TruncateBase();

                    PartialDirectory = SYSTEM::QueryDirectory( &TmpPath, TRUE );

                    if (PartialDirectory == NULL ) {
                        if (GetLastError() == COPY_ERROR_REQUEST_ABORTED) {
                            DELETE( TargetDrive );
                            return FALSE;
                        }
                        continue;
                    } else {

                        if ( *(PartialDirectory->GetPath()->GetPathString()) !=
                             *(TmpPath.GetPathString()) ) {

                            TmpPath1.Initialize( &TmpPath );
                            DestinationDirectory = PartialDirectory->CreateDirectoryPath( &TmpPath1 );
                            if ( !DestinationDirectory ) {
                                DisplayMessageAndExit( XCOPY_ERROR_CREATE_DIRECTORY, NULL, EXIT_MISC_ERROR );
                            }
                        } else {
                            DestinationDirectory = PartialDirectory;
                        }
                    }

                    //
                    //  If still not enough disk space, remove the directories
                    //  that we created and try again
                    //
                    IFS_SYSTEM::QueryFreeDiskSpace( TargetDrive, &FreeSpace );
                    FreeSpace = FreeSpace + TargetSize;

                    if ( FreeSpace < FileSize ) {

                        if ( PartialDirectory != DestinationDirectory ) {

                            if (!PathToDelete.Initialize( DestinationDirectory->GetPath() )) {
                                DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                            }

                            CharsInPartialDirectoryPath = PartialDirectory->GetPath()->GetPathString()->QueryChCount();

                            while ( PathToDelete.GetPathString()->QueryChCount() >
                                    CharsInPartialDirectoryPath ) {

                                DirDeleted = DestinationDirectory->DeleteDirectory();

                                DebugAssert( DirDeleted );

                                DELETE( DestinationDirectory );
                                DestinationDirectory = NULL;

                                PathToDelete.TruncateBase();
                                DestinationDirectory = SYSTEM::QueryDirectory( &PathToDelete );
                                DebugPtrAssert( DestinationDirectory );
                            }
                        }
                    }

                    if ( PartialDirectory != DestinationDirectory ) {
                        DELETE( PartialDirectory );
                        DELETE( DestinationDirectory );
                    } else {
                        DELETE( PartialDirectory );
                    }

                } else {
                    break;
                }

            } else {

                //
                //  Cannot determine free disk space!
                //
                if (GetLastError() == COPY_ERROR_REQUEST_ABORTED) {
                    DELETE( TargetDrive );
                    return FALSE;
                }
                break;
            }
        }

        DELETE( TargetDrive );
    }

    return TRUE;
}




VOID
XCOPY::GetDirectoryAndFilters (
    IN  PPATH           Path,
    OUT PFSN_DIRECTORY  *OutDirectory,
    OUT PFSN_FILTER     *FileFilter,
    OUT PFSN_FILTER     *DirectoryFilter,
    OUT PBOOLEAN        CopyingManyFiles
        )

/*++

Routine Description:

    Obtains a directory object and the filename to match

Arguments:

    Path                -   Supplies pointer to the path
    OutDirectory        -   Supplies pointer to pointer to directory
    FileFilter          -   Supplies filter for files
    DirectoryFilter     -   Supplies filter for directories
    CopyingManyFiles    -   Supplies pointer to flag which if TRUE means that
                            we are copying many files

Return Value:

    None.

Notes:

--*/

{

   PFSN_DIRECTORY    Directory;
   PFSN_FILE         File;
   PWSTRING          Prefix   =   NULL;
   PWSTRING          FileName =   NULL;
   PATH              PrefixPath;
   PATH              TmpPath;
   FSN_ATTRIBUTE     All   =  (FSN_ATTRIBUTE)0;
   FSN_ATTRIBUTE     Any   =  (FSN_ATTRIBUTE)0;
   FSN_ATTRIBUTE     None  =  (FSN_ATTRIBUTE)0;
   PFSN_FILTER       FilFilter;
   PFSN_FILTER       DirFilter;
   DSTRING           Name;



    //
    //      Create filters
    //
    if ( ( (FilFilter = NEW FSN_FILTER) == NULL ) ||
         ( (DirFilter = NEW FSN_FILTER) == NULL ) ||
         !FilFilter->Initialize()                 ||
         !DirFilter->Initialize() ) {
        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
    }

    if (( Directory = SYSTEM::QueryDirectory( Path )) != NULL ) {

        //
        //  Copying a directory. We will want everything in the directory
        //
        FilFilter->SetFileName( "*.*" );
        *CopyingManyFiles = TRUE;

    } else {

        //
        //  The path is not a directory. Get the prefix part (which SHOULD
        //  be a directory, and try to make a directory from it
        //
        *CopyingManyFiles = Path->HasWildCard();

        if ( !*CopyingManyFiles ) {

            //
            //  If the path is not a file, then this is an error
            //
            if ( !(File = SYSTEM::QueryFile( Path )) ) {

                if ((FileName = Path->QueryName()) == NULL ||
                    !Name.Initialize( FileName )) {
                    DisplayMessageAndExit( XCOPY_ERROR_INVALID_PATH, NULL, EXIT_MISC_ERROR );
                }
                DisplayMessageAndExit( XCOPY_ERROR_FILE_NOT_FOUND,
                                       &Name,
                                       EXIT_MISC_ERROR );

            }

            DELETE( File );
        }

        Prefix = Path->QueryPrefix();

        if ( !Prefix ) {

            //
            //  No prefix, use the drive part.
            //
            TmpPath.Initialize( Path, TRUE );

            Prefix = TmpPath.QueryDevice();

            if (Prefix == NULL) {
                DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                return;
            }
        }

        if ( !PrefixPath.Initialize( Prefix, FALSE ) ) {
            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }

        if (( Directory = SYSTEM::QueryDirectory( &PrefixPath )) != NULL ) {

            //
            //  Directory is ok, set the filter's filename criteria
            //  with the file (pattern) specified.
            //
            if ((FileName = Path->QueryName()) == NULL ) {
                DisplayMessageAndExit( XCOPY_ERROR_INVALID_PATH, NULL, EXIT_MISC_ERROR );
            }

            FilFilter->SetFileName( FileName );

        } else {

            //
            //  Something went wrong...
            //
            if ((FileName = Path->QueryName()) == NULL ||
                !Name.Initialize( FileName )) {
                DisplayMessageAndExit( XCOPY_ERROR_INVALID_PATH, NULL, EXIT_MISC_ERROR );
            }
            DisplayMessageAndExit( XCOPY_ERROR_FILE_NOT_FOUND,
                                   &Name,
                                   EXIT_MISC_ERROR );
        }

        DELETE( Prefix );
        DELETE( FileName );

    }

    //
    //  Ok, we have the directory object and the filefilter's path set.
    //

    //
    //  Set the file filter attribute criteria
    //
    None = (FSN_ATTRIBUTE)(None | FSN_ATTRIBUTE_DIRECTORY );
    if ( !_HiddenSwitch ) {
        None = (FSN_ATTRIBUTE)(None | FSN_ATTRIBUTE_HIDDEN | FSN_ATTRIBUTE_SYSTEM );
    }

    if (_ArchiveSwitch) {
        All = (FSN_ATTRIBUTE)(All | FSN_ATTRIBUTE_ARCHIVE);
    }

    FilFilter->SetAttributes( All, Any, None );

    //
    //  Set the file filter's time criteria
    //
    if ( _Date != NULL ) {
        FilFilter->SetTimeInfo( _Date,
                                FSN_TIME_MODIFIED,
                                (TIME_AT | TIME_AFTER) );
    }

    //
    //  Set the directory filter attribute criteria.
    //
    All     =   (FSN_ATTRIBUTE)0;
    Any     =   (FSN_ATTRIBUTE)0;
    None    =   (FSN_ATTRIBUTE)0;

    if ( !_HiddenSwitch ) {
        None = (FSN_ATTRIBUTE)(None | FSN_ATTRIBUTE_HIDDEN | FSN_ATTRIBUTE_SYSTEM );
    }

    if (_SubdirSwitch) {
            All = (FSN_ATTRIBUTE)(All | FSN_ATTRIBUTE_DIRECTORY);
    } else {
            None = (FSN_ATTRIBUTE)(None | FSN_ATTRIBUTE_DIRECTORY);
    }

    DirFilter->SetAttributes( All, Any, None );


    *FileFilter         =   FilFilter;
    *DirectoryFilter    =   DirFilter;
    *OutDirectory       =   Directory;

}

VOID
XCOPY::GetDirectoryAndFilePattern(
    IN  PPATH           Path,
    IN  BOOLEAN         CopyingManyFiles,
        OUT PPATH                       *OutDirectory,
    OUT PWSTRING        *OutFilePattern
        )

/*++

Routine Description:

        Gets the path of the destination directory and the pattern that
        will be used for filename conversion.

Arguments:

    Path                -   Supplies pointer to the path
    CopyingManyFiles    -   Supplies flag which if true means that we are copying many
                            files.
    OutDirectory        -   Supplies pointer to pointer to directory path
    OutFilePattern      -   Supplies pointer to pointer to file name
    IsDir   `           -   Supplies pointer to isdir flag

Return Value:

    None.

Notes:

--*/

{
    PPATH           Directory;
    PWSTRING        FileName;
    PWSTRING        Prefix = NULL;
    PWSTRING        Name = NULL;
    BOOLEAN         DeletePath = FALSE;
    PFSN_DIRECTORY  TmpDir;
    PATH            TmpPath;
    DSTRING         Slash;
    DSTRING         TmpPath1Str;
    PATH            TmpPath1;

    if ( !Path ) {

        //
        //      There is no path, we invent our own
        //
        if ( ((Path = NEW PATH) == NULL ) ||
             !Path->Initialize( (LPWSTR)L"*.*", FALSE)) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }
        DeletePath = TRUE;
    }

    TmpDir = SYSTEM::QueryDirectory( Path );

    if ( !TmpDir && (Path->HasWildCard() || IsFileName( Path, CopyingManyFiles ))) {

        //
        //      The path is not a directory, so we use the prefix as a
        //      directory path and the filename becomes the pattern.
        //
        if ( !TmpPath.Initialize( Path, TRUE )                          ||
             ((Prefix = TmpPath.QueryPrefix()) == NULL)                 ||
             !Slash.Initialize( "\\" )                                  ||
             !TmpPath1Str.Initialize( Prefix )                          ||
             !TmpPath1.Initialize( &TmpPath1Str, FALSE )                ||
             ((Name = TmpPath.QueryName())  == NULL)                    ||
             ((Directory = NEW PATH) == NULL)                           ||
             !Directory->Initialize( &TmpPath1, TRUE )                  ||
             ((FileName = NEW DSTRING) == NULL )                        ||
             !FileName->Initialize( Name ) ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );

        }

        DELETE( Prefix );
        DELETE( Name );

    } else {

        //
        //      The path specifies a directory, so we use all of it and the
        //      pattern is "*.*"
        //
        if ( ((Directory = NEW PATH) == NULL )      ||
             !Directory->Initialize( Path,TRUE )    ||
             ((FileName = NEW DSTRING) == NULL )    ||
             !FileName->Initialize( "*.*" ) ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );

        }
        DELETE( TmpDir );

    }

    *OutDirectory   = Directory;
    *OutFilePattern = FileName;

    //
    //      If we created the path, we have to delete it
    //
    if ( DeletePath ) {
        DELETE( Path );
    }
}

BOOL
XCOPY::IsCyclicalCopy(
        IN PPATH         PathSrc,
        IN PPATH         PathTrg
        )

/*++

Routine Description:

        Determines if there is a cycle between two paths

Arguments:

        PathSrc -       Supplies pointer to first path
        PathTrg -       Supplies pointer to second path

Return Value:

        TRUE if there is a cycle,
        FALSE otherwise

--*/

{
   PATH           SrcPath;
   PATH           TrgPath;
   PARRAY            ArraySrc, ArrayTrg;
   PARRAY_ITERATOR   IteratorSrc, IteratorTrg;
    PWSTRING     ComponentSrc, ComponentTrg;
   BOOLEAN        IsCyclical  =  FALSE;

        DebugAssert( PathSrc != NULL );

        if ( PathTrg != NULL ) {

                //
                //      Get canonicalized paths for both source and target
                //
                SrcPath.Initialize(PathSrc, TRUE );
                TrgPath.Initialize(PathTrg, TRUE );

                //
                //      Split the paths into their components
                //
                ArraySrc = SrcPath.QueryComponentArray();
                ArrayTrg = TrgPath.QueryComponentArray();

                DebugPtrAssert( ArraySrc );
                DebugPtrAssert( ArrayTrg );

                if ( !ArraySrc || !ArrayTrg ) {
                        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                }

                //
                //      Get iterators for the components
                //
                IteratorSrc = ( PARRAY_ITERATOR )ArraySrc->QueryIterator();
                IteratorTrg = ( PARRAY_ITERATOR )ArrayTrg->QueryIterator();

                DebugPtrAssert( IteratorSrc );
                DebugPtrAssert( IteratorTrg );

                if ( !IteratorSrc || !IteratorTrg ) {
                        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                }

                //
                //      There is a cycle if all of the source is along the target.
                //
                while ( TRUE )  {

            ComponentSrc = (PWSTRING)IteratorSrc->GetNext();

                        if ( !ComponentSrc ) {

                                //
                                //      The source path is along the target path. This is a
                                //      cycle.
                                //
                                IsCyclical = TRUE;
                                break;

                        }

            ComponentTrg = (PWSTRING)IteratorTrg->GetNext();

                        if ( !ComponentTrg ) {

                                //
                                //      The target path is along the source path. This is no
                                //      cycle.
                                //
                                break;

                        }

                        if ( *ComponentSrc != *ComponentTrg ) {

                                //
                                //      One path is not along the other. There is no cycle.
                                //
                                break;
                        }
                }

                DELETE( IteratorSrc );
                DELETE( IteratorTrg );

                ArraySrc->DeleteAllMembers();
                ArrayTrg->DeleteAllMembers();

                DELETE( ArraySrc );
                DELETE( ArrayTrg );

        }

        return IsCyclical;
}

BOOL
XCOPY::IsFileName(
    IN PPATH     Path,
    IN BOOLEAN   CopyingManyFiles
        )

/*++

Routine Description:

        Figures out if a name refers to a directory or a file.

Arguments:

    Path                -   Supplies pointer to the path
    CopyingManyFiles    -   Supplies flag which if TRUE means that we are
                            copying many files.

Return Value:

        BOOLEAN -       TRUE if name refers to file,
                                FALSE otherwise

Notes:

--*/

{

    PFSN_DIRECTORY  FsnDirectory;
    PFSN_FILE               FsnFile;
    WCHAR                   Resp;
    PWSTRING                DirMsg;
    PWSTRING                FilMsg;

    //
    //      If the path is an existing directory, then this is obviously
    //      not a file.
    //
    //
    if ((FsnDirectory = SYSTEM::QueryDirectory( Path )) != NULL ) {

            DELETE( FsnDirectory );
            return FALSE;
    }

    //
    //      If the path ends with a delimiter, then it is a directory.
    //      We remove the delimiter.
    //
    if ( Path->EndsWithDelimiter() ) {
            ((PWSTRING) Path->GetPathString())->Truncate( Path->GetPathString()->QueryChCount() - 1 );
            Path->Initialize( Path->GetPathString() );
            return FALSE;
    }

    //
    //      If the path is an existing file, then it is a file.
    //
    if ((FsnFile = SYSTEM::QueryFile( Path )) != NULL ) {

            DELETE( FsnFile );
            return _TargetIsFile = TRUE;
    }

    DirMsg = QueryMessageString(XCOPY_RESPONSE_DIRECTORY);
    FilMsg = QueryMessageString(XCOPY_RESPONSE_FILE);

    DebugPtrAssert( DirMsg );
    DebugPtrAssert( FilMsg );

    //
    //  If the path does not exist, we are copying many files, and we are intelligent,
    //  then the target is obviously a directory.
    //
    //  Otherwise we simply ask the user.
    //
    if ( _IntelligentSwitch && CopyingManyFiles ) {

        _TargetIsFile = FALSE;

    } else {

        while ( TRUE ) {

            DisplayMessage( XCOPY_MESSAGE_FILE_OR_DIRECTORY, NORMAL_MESSAGE, "%W", Path->GetPathString() );

            AbortIfCtrlC();

            _Keyboard->DisableLineMode();
            if( GetStandardInput()->IsAtEnd() ) {
                // Insufficient input--treat as CONTROL-C.
                //
                Resp = CTRL_C;
            } else {
                GetStandardInput()->ReadChar( &Resp );
            }
            _Keyboard->EnableLineMode();

            if ( Resp == CTRL_C ) {
                exit( EXIT_TERMINATED );
            } else {
                GetStandardOutput()->WriteChar( Resp );
                GetStandardOutput()->WriteChar( '\r' );
                GetStandardOutput()->WriteChar( '\n' );
            }

            Resp = (WCHAR)towupper( (wchar_t)Resp );

            if ( FilMsg->QueryChAt(0) == Resp ) {
                _TargetIsFile = TRUE;
                break;
            } else if ( DirMsg->QueryChAt(0) == Resp ) {
                _TargetIsFile = FALSE;
                break;
            }
        }
    }

        DELETE( DirMsg );
        DELETE( FilMsg );

        return _TargetIsFile;

}

BOOLEAN
XCOPY::UserConfirmedCopy (
        IN      PCWSTRING        SourcePath,
        IN      PCWSTRING        DestinationPath
        )

/*++

Routine Description:

        Gets confirmation from the user about a file to be copied

Arguments:

        SourcePath      -       Supplies the path to the file to be copied
        DestinationPath -       Supplies the destination path of the file to be created

Return Value:

        BOOLEAN -       TRUE if the user confirmed the copy
                        FALSE otherwise

--*/

{
    PWSTRING        YesMsg;
    PWSTRING        NoMsg;
    WCHAR           Resp;
    BOOLEAN         Confirmed;


    YesMsg = QueryMessageString(XCOPY_RESPONSE_YES);
    NoMsg = QueryMessageString(XCOPY_RESPONSE_NO);

    DebugPtrAssert( YesMsg );
    DebugPtrAssert( NoMsg );

    while ( TRUE ) {

        if (DestinationPath) {
            DisplayMessage( XCOPY_MESSAGE_CONFIRM3, NORMAL_MESSAGE, "%W%W",
                            SourcePath, DestinationPath );
        } else {
            DisplayMessage( XCOPY_MESSAGE_CONFIRM, NORMAL_MESSAGE, "%W", SourcePath );
        }

        AbortIfCtrlC();

        _Keyboard->DisableLineMode();

        if( GetStandardInput()->IsAtEnd() ) {
            // Insufficient input--treat as CONTROL-C.
            //
            Resp = NoMsg->QueryChAt( 0 );
            break;
        } else {
            GetStandardInput()->ReadChar( &Resp );
        }
        _Keyboard->EnableLineMode();

        if ( Resp == CTRL_C ) {
            exit( EXIT_TERMINATED );
        } else {
            GetStandardOutput()->WriteChar( Resp );
            GetStandardOutput()->WriteChar( '\r' );
            GetStandardOutput()->WriteChar( '\n' );
        }

        Resp = (WCHAR)towupper( (wchar_t)Resp );

        if ( YesMsg->QueryChAt( 0 ) == Resp ) {
            Confirmed = TRUE;
            break;
        }
        else if ( NoMsg->QueryChAt( 0 ) == Resp ) {
            Confirmed = FALSE;
            break;
        }
    }

    DELETE( YesMsg );
    DELETE( NoMsg );

    return Confirmed;


}

BOOLEAN
XCOPY::UserConfirmedOverWrite (
        IN      PPATH       DestinationFile
        )

/*++

Routine Description:

        Gets confirmation from the user about the overwriting of an existing file

Arguments:

        FsNode  -       Supplies pointer to FSNODE of file to be
                          copied

Return Value:

        BOOLEAN -       TRUE if the user confirmed the overwrite
                          FALSE otherwise

--*/

{
    PWSTRING        YesMsg;
    PWSTRING        NoMsg;
    PWSTRING        AllMsg;
    WCHAR           Resp;
    BOOLEAN         Confirmed;


    YesMsg = QueryMessageString(XCOPY_RESPONSE_YES);
    NoMsg = QueryMessageString(XCOPY_RESPONSE_NO);
    AllMsg = QueryMessageString(XCOPY_RESPONSE_ALL);

    DebugPtrAssert( YesMsg );
    DebugPtrAssert( NoMsg );
    DebugPtrAssert( AllMsg );

    while ( TRUE ) {

        DisplayMessage( XCOPY_MESSAGE_CONFIRM2, NORMAL_MESSAGE, "%W", DestinationFile->GetPathString() );

        AbortIfCtrlC();

        _Keyboard->DisableLineMode();

        if( GetStandardInput()->IsAtEnd() ) {
            // Insufficient input--treat as CONTROL-C.
            //
            exit( EXIT_TERMINATED );
            break;
        } else {
            GetStandardInput()->ReadChar( &Resp );
        }
        _Keyboard->EnableLineMode();

        if ( Resp == CTRL_C ) {
            exit( EXIT_TERMINATED );
        } else {
            GetStandardOutput()->WriteChar( Resp );
            GetStandardOutput()->WriteChar( '\r' );
            GetStandardOutput()->WriteChar( '\n' );
        }

        Resp = (WCHAR)towupper( (wchar_t)Resp );

        if ( YesMsg->QueryChAt( 0 ) == Resp ) {
            Confirmed = TRUE;
            break;
        }
        else if ( NoMsg->QueryChAt( 0 ) == Resp ) {
            Confirmed = FALSE;
            break;
        } else if ( AllMsg->QueryChAt(0) == Resp ) {
            Confirmed = _OverWriteSwitch = TRUE;
            break;
        }
    }

    DELETE( YesMsg );
    DELETE( NoMsg );
    DELETE( AllMsg );

    return Confirmed;


}

BOOLEAN
XCOPY::IsExcluded(
    IN PCPATH   Path
    )
/*++

Routine Description:

    This method determines whether the specified path should be
    excluded from the XCOPY.

Arguments:

    Path    --  Supplies the path of the file in question.

Return Value:

    TRUE if this file should be excluded, i.e. if any element of
    the exclusion list array appears as a substring of this path.

--*/
{
    PWSTRING    CurrentString;
    DSTRING     UpcasedPath;
    DSTRING     BackSlash;

    if( _ExclusionList == NULL ) {

        return FALSE;
    }

    if (!UpcasedPath.Initialize(Path->GetPathString()) ||
        !BackSlash.Initialize(L"\\")) {
        DebugPrint("XCOPY: Out of memory \n");
        return FALSE;
    }

    UpcasedPath.Strupr( );

    if (!Path-> EndsWithDelimiter() &&
        !UpcasedPath.Strcat(&BackSlash)) {
        DebugPrint("XCOPY: Out of memory \n");
        return FALSE;
    }

    _Iterator->Reset();

    while ((CurrentString = (PWSTRING)_Iterator->GetNext()) != NULL) {

        if (UpcasedPath.Strstr(CurrentString) != INVALID_CHNUM) {

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\fat_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fat_rec.c

Abstract:

    This module contains the mini-file system recognizer for FAT.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"
#include "fat_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_FAT)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,FatRecFsControl)
#pragma alloc_text(PAGE,IsFatVolume)
#pragma alloc_text(PAGE,UnpackBiosParameterBlock)
#endif // ALLOC_PRAGMA


NTSTATUS
FatRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT targetDevice;
    PPACKED_BOOT_SECTOR buffer;
    LARGE_INTEGER byteOffset;
    UNICODE_STRING driverName;
    ULONG bytesPerSector;
    BOOLEAN isDeviceFailure = FALSE;

    PAGED_CODE();

    //
    // Begin by determining what function that is to be performed.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_MOUNT_VOLUME:

        //
        // Attempt to mount a volume:  Determine whether or not the volume in
        // question is a FAT volume and, if so, let the I/O system know that it
        // is by returning a special status code so that this driver can get
        // called back to load the FAT file system.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        //
        // Attempt to determine whether or not the target volume being mounted
        // is a FAT volume.  Note that if an error occurs, and this is a floppy
        // drive, and the error occurred on the actual read from the device,
        // then the FAT file system will actually be loaded to handle the
        // problem since this driver is a place holder and does not need to
        // know all of the protocols for handling floppy errors.
        //

        targetDevice = irpSp->Parameters.MountVolume.DeviceObject;

        //
        //  First retrieve the sector size for this media.
        //

        if (FsRecGetDeviceSectorSize( targetDevice,
                                      &bytesPerSector )) {

            byteOffset.QuadPart = 0;
            buffer = NULL;

            if (FsRecReadBlock( targetDevice,
                                &byteOffset,
                                512,
                                bytesPerSector,
                                &buffer,
                                &isDeviceFailure ) &&
                IsFatVolume( buffer )) {
                    
                status = STATUS_FS_DRIVER_REQUIRED;
                
            }

            if (buffer != NULL) {
                ExFreePool( buffer );
            }
            
         } else {

             //
             //  Devices that can't get us this much ...
             //

             isDeviceFailure = TRUE;
         }
            
         //
         //  See if we should make the real filesystem take a shot at a wacky floppy.
         //
         
         if (isDeviceFailure) {
             if (targetDevice->Characteristics & FILE_FLOPPY_DISKETTE) {
                 status = STATUS_FS_DRIVER_REQUIRED;
             }
         }

         break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        status = FsRecLoadFileSystem( DeviceObject,
                                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Fastfat" );
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // Finally, complete the request and return the same status code to the
    // caller.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}


BOOLEAN
IsFatVolume(
    IN PPACKED_BOOT_SECTOR Buffer
    )

/*++

Routine Description:

    This routine looks at the buffer passed in which contains the FAT boot
    sector and determines whether or not it represents an actual FAT boot
    sector.

Arguments:

    Buffer - Pointer to buffer containing potential boot block.

Return Value:

    The function returns TRUE if the buffer contains a recognizable FAT boot
    sector, otherwise it returns FALSE.

--*/

{
    BIOS_PARAMETER_BLOCK bios;
    BOOLEAN result;

    PAGED_CODE();

    //
    // Begin by unpacking the Bios Parameter Block that is packed in the boot
    // sector so that it can be examined without incurring alignment faults.
    //

    UnpackBiosParameterBlock( &Buffer->PackedBpb, &bios );

    //
    // Assume that the sector represents a FAT boot block and then determine
    // whether or not it really does.
    //

    result = TRUE;

    if (bios.Sectors) {
        bios.LargeSectors = 0;
    }

    // FMR Jul.11.1994 NaokiM - Fujitsu -
    // FMR boot sector has 'IPL1' string at the beginnig.

    if (Buffer->Jump[0] != 0x49 && /* FMR */
        Buffer->Jump[0] != 0xe9 &&
        Buffer->Jump[0] != 0xeb) {

        result = FALSE;


    // FMR Jul.11.1994 NaokiM - Fujitsu -
    // Sector size of FMR partition is 2048.

    } else if (bios.BytesPerSector !=  128 &&
               bios.BytesPerSector !=  256 &&
               bios.BytesPerSector !=  512 &&
               bios.BytesPerSector != 1024 &&
               bios.BytesPerSector != 2048 && /* FMR */
               bios.BytesPerSector != 4096) {

        result = FALSE;

    } else if (bios.SectorsPerCluster !=  1 &&
               bios.SectorsPerCluster !=  2 &&
               bios.SectorsPerCluster !=  4 &&
               bios.SectorsPerCluster !=  8 &&
               bios.SectorsPerCluster != 16 &&
               bios.SectorsPerCluster != 32 &&
               bios.SectorsPerCluster != 64 &&
               bios.SectorsPerCluster != 128) {

        result = FALSE;

    } else if (!bios.ReservedSectors) {

        result = FALSE;

    } else if (!bios.Fats) {

        result = FALSE;

    //
    // Prior to DOS 3.2 might contains value in both of Sectors and
    // Sectors Large.
    //
    } else if (!bios.Sectors && !bios.LargeSectors) {

        result = FALSE;

    // FMR Jul.11.1994 NaokiM - Fujitsu -
    // 1. Media descriptor of FMR partitions is 0xfa.
    // 2. Media descriptor of partitions formated by FMR OS/2 is 0x00.
    // 3. Media descriptor of floppy disks formated by FMR DOS is 0x01.

    } else if (bios.Media != 0x00 && /* FMR */
               bios.Media != 0x01 && /* FMR */
               bios.Media != 0xf0 &&
               bios.Media != 0xf8 &&
               bios.Media != 0xf9 &&
               bios.Media != 0xfa && /* FMR */
               bios.Media != 0xfb &&
               bios.Media != 0xfc &&
               bios.Media != 0xfd &&
               bios.Media != 0xfe &&
               bios.Media != 0xff) {

        result = FALSE;

    } else if (bios.SectorsPerFat != 0 && bios.RootEntries == 0) {

        result = FALSE;
    }

    return result;
}


VOID
UnpackBiosParameterBlock(
    IN PPACKED_BIOS_PARAMETER_BLOCK Bios,
    OUT PBIOS_PARAMETER_BLOCK UnpackedBios
    )

/*++

Routine Description:

    This routine copies a packed Bios Parameter Block to an unpacked Bios
    Parameter Block.

Arguments:

    Bios - Pointer to the packed Bios Parameter Block.

    UnpackedBios - Pointer to the unpacked Bios Parameter Block.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Unpack the Bios Parameter Block.
    //

    CopyUchar2( &UnpackedBios->BytesPerSector, &Bios->BytesPerSector[0] );
    CopyUchar2( &UnpackedBios->BytesPerSector, &Bios->BytesPerSector[0] );
    CopyUchar1( &UnpackedBios->SectorsPerCluster, &Bios->SectorsPerCluster[0] );
    CopyUchar2( &UnpackedBios->ReservedSectors, &Bios->ReservedSectors[0] );
    CopyUchar1( &UnpackedBios->Fats, &Bios->Fats[0] );
    CopyUchar2( &UnpackedBios->RootEntries, &Bios->RootEntries[0] );
    CopyUchar2( &UnpackedBios->Sectors, &Bios->Sectors[0] );
    CopyUchar1( &UnpackedBios->Media, &Bios->Media[0] );
    CopyUchar2( &UnpackedBios->SectorsPerFat, &Bios->SectorsPerFat[0] );
    CopyUchar2( &UnpackedBios->SectorsPerTrack, &Bios->SectorsPerTrack[0] );
    CopyUchar2( &UnpackedBios->Heads, &Bios->Heads[0] );
    CopyUchar4( &UnpackedBios->HiddenSectors, &Bios->HiddenSectors[0] );
    CopyUchar4( &UnpackedBios->LargeSectors, &Bios->LargeSectors[0] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\fs_rec.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fs_rec.h

Abstract:

    This module contains the main header file for the mini-file system
    recognizer driver.

Author:

    Darryl E. Havens (darrylh) 22-nov-1993

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "ntifs.h"
#include "ntdddisk.h"
#include "ntddcdrm.h"

//
//  Define the debug trace levels.
//

#define FSREC_DEBUG_LEVEL_FSREC     0x00000001
#define FSREC_DEBUG_LEVEL_NTFS      0x00000002
#define FSREC_DEBUG_LEVEL_CDFS      0x00000004
#define FSREC_DEBUG_LEVEL_UDFS      0x00000008
#define FSREC_DEBUG_LEVEL_FAT       0x00000010

#define FSREC_POOL_TAG		    'crsF' 

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) (     \
//    (Flags) |= (SingleFlag)             \
//)
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) (   \
//    (Flags) &= ~(SingleFlag)            \
//)
//#endif

//
// Define the file system types for the device extension.
//

typedef enum _FILE_SYSTEM_TYPE {
    CdfsFileSystem = 1,
    FatFileSystem,
    HpfsFileSystem,
    NtfsFileSystem,
    UdfsFileSystem
} FILE_SYSTEM_TYPE, *PFILE_SYSTEM_TYPE;

//
// Define the device extension for this driver.
//

typedef enum _RECOGNIZER_STATE {
    Active,
    Transparent,
    FastUnload
} RECOGNIZER_STATE, *PRECOGNIZER_STATE;

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT CoRecognizer;
    FILE_SYSTEM_TYPE FileSystemType;
    RECOGNIZER_STATE State;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Define the functions provided by this driver.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FsRecCleanupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsRecShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsRecCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsRecCreateAndRegisterDO(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT HeadRecognizer OPTIONAL,
    OUT PDEVICE_OBJECT *NewRecognizer OPTIONAL,
    IN PWCHAR RecFileSystem,
    IN PWCHAR FileSystemName,
    IN FILE_SYSTEM_TYPE FileSystemType,
    IN DEVICE_TYPE DeviceType
    );

NTSTATUS
FsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FsRecUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
FsRecLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWCHAR DriverServiceKey
    );

BOOLEAN
FsRecGetDeviceSectorSize (
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG BytesPerSector
    );

BOOLEAN
FsRecGetDeviceSectors (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BytesPerSector,
    OUT PLARGE_INTEGER NumberOfSectors
    );

BOOLEAN
FsRecReadBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLARGE_INTEGER ByteOffset,
    IN ULONG MinimumBytes,
    IN ULONG BytesPerSector,
    OUT PVOID *Buffer,
    OUT PBOOLEAN IsDeviceFailure OPTIONAL
    );

#if DBG

extern LONG FsRecDebugTraceLevel;
extern LONG FsRecDebugTraceIndent;

BOOLEAN
FsRecDebugTrace (
    LONG IndentIncrement,
    ULONG TraceMask,
    PCHAR Format,
    ...
    );

#define DebugTrace(M) FsRecDebugTrace M

#else

#define DebugTrace(M) TRUE

#endif


//
//  Define the per-type recognizers.
//

NTSTATUS
CdfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\fs_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fs_rec.c

Abstract:

    This module contains the main functions for the mini-file system recognizer
    driver.

Author:

    Darryl E. Havens (darrylh) 22-nov-1993

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_FSREC)

#if DBG

#include <stdarg.h>
#include <stdio.h>

LONG FsRecDebugTraceLevel = 0;
LONG FsRecDebugTraceIndent = 0;

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,FsRecCreateAndRegisterDO)

#pragma alloc_text(PAGE,FsRecCleanupClose)
#pragma alloc_text(PAGE,FsRecCreate)
#pragma alloc_text(PAGE,FsRecFsControl)
#pragma alloc_text(PAGE,FsRecGetDeviceSectorSize)
#pragma alloc_text(PAGE,FsRecGetDeviceSectors)
#pragma alloc_text(PAGE,FsRecLoadFileSystem)
#pragma alloc_text(PAGE,FsRecReadBlock)
#pragma alloc_text(PAGE,FsRecUnload)
#pragma alloc_text(PAGE,FsRecShutdown)
#endif // ALLOC_PRAGMA

//
//  Mutex for serializing driver loads.
//

PKEVENT FsRecLoadSync;


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is invoked once when the driver is loaded to allow the driver
    to initialize itself.  The initialization for the driver consists of simply
    creating a device object for each type of file system recognized by this
    driver, and then registering each as active file systems.

Arguments:

    DriverObject - Pointer to the driver object for this driver.

    RegistryPath - Pointer to the registry service node for this driver.

Return Value:

    The function value is the final status of the initialization for the driver.

--*/

{
    PDEVICE_OBJECT UdfsMainRecognizerDeviceObject;
    PDEVICE_OBJECT FatMainRecognizerDeviceObject;
    NTSTATUS status;
    ULONG count = 0;

    PAGED_CODE();

    //
    // Mark the entire driver as pagable.
    //

    MmPageEntireDriver ((PVOID)DriverEntry);

    //
    // Begin by initializing the driver object so that it the driver is
    // prepared to provide services.
    //

    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = FsRecFsControl;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = FsRecCreate;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = FsRecCleanupClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = FsRecCleanupClose;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = FsRecShutdown;
    DriverObject->DriverUnload = FsRecUnload;

    FsRecLoadSync = ExAllocatePoolWithTag( NonPagedPool, sizeof(KEVENT), FSREC_POOL_TAG );

    if (FsRecLoadSync == NULL) {

	return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent( FsRecLoadSync, SynchronizationEvent, TRUE );

    //
    // Create and initialize each of the file system driver type device
    // objects.
    //

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       NULL,
                                       NULL,
                                       L"\\Cdfs",
                                       L"\\FileSystem\\CdfsRecognizer",
                                       CdfsFileSystem,
                                       FILE_DEVICE_CD_ROM_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       NULL,
                                       &UdfsMainRecognizerDeviceObject,
                                       L"\\UdfsCdRom",
                                       L"\\FileSystem\\UdfsCdRomRecognizer",
                                       UdfsFileSystem,
                                       FILE_DEVICE_CD_ROM_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       UdfsMainRecognizerDeviceObject,
                                       NULL,
                                       L"\\UdfsDisk",
                                       L"\\FileSystem\\UdfsDiskRecognizer",
                                       UdfsFileSystem,
                                       FILE_DEVICE_DISK_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       NULL,
                                       &FatMainRecognizerDeviceObject,
                                       L"\\FatDisk",
                                       L"\\FileSystem\\FatDiskRecognizer",
                                       FatFileSystem,
                                       FILE_DEVICE_DISK_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       FatMainRecognizerDeviceObject,
                                       NULL,
                                       L"\\FatCdrom",
                                       L"\\FileSystem\\FatCdRomRecognizer",
                                       FatFileSystem,
                                       FILE_DEVICE_CD_ROM_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       NULL,
                                       NULL,
                                       L"\\Ntfs",
                                       L"\\FileSystem\\NtfsRecognizer",
                                       NtfsFileSystem,
                                       FILE_DEVICE_DISK_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    if (count) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_IMAGE_ALREADY_LOADED;
    }
}


NTSTATUS
FsRecCleanupClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked when someone attempts to cleanup or close one of
    the system recognizer's registered device objects.

Arguments:

    DeviceObject - Pointer to the device object being closed.

    Irp - Pointer to the cleanup/close IRP.

Return Value:

    The final function value is STATUS_SUCCESS.

--*/

{
    PAGED_CODE();

    //
    // Simply complete the request successfully (note that IoStatus.Status in
    // Irp is already initialized to STATUS_SUCCESS).
    //

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}


NTSTATUS
FsRecCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked when someone attempts to open one of the file
    system recognizer's registered device objects.

Arguments:

    DeviceObject - Pointer to the device object being opened.

    Irp - Pointer to the create IRP.

Return Value:

    The final function value indicates whether or not the open was successful.

--*/

{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS status;

    PAGED_CODE();

    //
    // Simply ensure that the name of the "file" being opened is NULL, and
    // complete the request accordingly.
    //

    if (irpSp->FileObject->FileName.Length) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
    } else {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = FILE_OPENED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}


NTSTATUS
FsRecCreateAndRegisterDO (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT HeadRecognizer OPTIONAL,
    OUT PDEVICE_OBJECT *NewRecognizer OPTIONAL,
    IN PWCHAR RecFileSystem,
    IN PWCHAR FileSystemName,
    IN FILE_SYSTEM_TYPE FileSystemType,
    IN DEVICE_TYPE DeviceType
    )

/*++

Routine Description:

    This routine creates a device object for the specified file system type and
    registers it as an active file system.

Arguments:

    DriverObject - Pointer to the driver object for this driver.
    
    HeadRecognizer - Optionally supplies a pre-existing recognizer that the
        newly created DO should be jointly serialized and unregistered with.
        This is useful if a given filesystem exists on multiple device types
        and thus requires multiple recognizers.
    
    NewDeviceObject - Receives the created DO on success..

    RecFileSystem - Name of the file system to be recognized.

    FileSystemName - Name of file system device object to be registered.

    FileSystemType - Type of this file system recognizer device object.
    
    DeviceType - Type of media this file system recognizer device object will inspect.

Return Value:

    The final function value indicates whether or not the device object was
    successfully created and registered.

--*/

{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fsHandle;
    IO_STATUS_BLOCK ioStatus;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    if (NewRecognizer) {

        *NewRecognizer = NULL;
    }

    //
    // Begin by attempting to open the file system driver's device object.  If
    // it works, then the file system is already loaded, so don't load this
    // driver.  Otherwise, this mini-driver is the one that should be loaded.
    //

    RtlInitUnicodeString( &nameString, RecFileSystem );
    InitializeObjectAttributes( &objectAttributes,
                                &nameString,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwCreateFile( &fsHandle,
                           SYNCHRONIZE,
                           &objectAttributes,
                           &ioStatus,
                           (PLARGE_INTEGER) NULL,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           0,
                           (PVOID) NULL,
                           0 );

    if (NT_SUCCESS( status )) {
        ZwClose( fsHandle );
    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS( status )) {
        return STATUS_IMAGE_ALREADY_LOADED;
    }

    //
    // Attempt to create a device object for this driver.  This device object
    // will be used to represent the driver as an active file system in the
    // system.
    //

    RtlInitUnicodeString( &nameString, FileSystemName );

    status = IoCreateDevice( DriverObject,
                             sizeof( DEVICE_EXTENSION ),
                             &nameString,
                             DeviceType,
                             0,
                             FALSE,
                             &deviceObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    status = IoRegisterShutdownNotification (deviceObject);
    if (!NT_SUCCESS( status )) {
        IoDeleteDevice (deviceObject);
        return status;
    }

    //
    // Initialize the device extension for this device object.
    //

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FileSystemType = FileSystemType;
    deviceExtension->State = Active;

    //
    //  Is this a filesystem being jointly recognized by recognizers for
    //  different device types?
    //
    
    if (HeadRecognizer) {

        //
        //  Link into the list.
        //
        
        deviceExtension->CoRecognizer = ((PDEVICE_EXTENSION)HeadRecognizer->DeviceExtension)->CoRecognizer;
        ((PDEVICE_EXTENSION)HeadRecognizer->DeviceExtension)->CoRecognizer = deviceObject;
    
    } else {

        //
        //  Initialize the list of codependant recognizer objects.
        //
        
        deviceExtension->CoRecognizer = deviceObject;
    }
    
#if _PNP_POWER_
    deviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif

    //
    // Finally, register this driver as an active, loaded file system and
    // return to the caller.
    //

    if (NewRecognizer) {

        *NewRecognizer = deviceObject;
    }

    IoRegisterFileSystem( deviceObject );
    return STATUS_SUCCESS;
}


NTSTATUS
FsRecFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Simply vector to the appropriate FS control function given the type
    // of file system being interrogated.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Handle the inactive recognizer states directly.
    //
    
    if (deviceExtension->State != Active && irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {
        
        if (deviceExtension->State == Transparent) {

            status = STATUS_UNRECOGNIZED_VOLUME;
        
        } else {
        
            status = STATUS_FS_DRIVER_REQUIRED;
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    switch ( deviceExtension->FileSystemType ) {

        case FatFileSystem:

            status = FatRecFsControl( DeviceObject, Irp );
            break;

        case NtfsFileSystem:

            status = NtfsRecFsControl( DeviceObject, Irp );
            break;

        case CdfsFileSystem:

            status = CdfsRecFsControl( DeviceObject, Irp );
            break;

        case UdfsFileSystem:

            status = UdfsRecFsControl( DeviceObject, Irp );
            break;

        default:

            status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return status;
}


NTSTATUS
FsRecShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is the shutdown handle for each of the recognisers file systems

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Shutdown IRP

Return Value:

    The function value is the final status of the operation.


--*/
{
    PDEVICE_EXTENSION DeviceExtension;

    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (DeviceExtension->State != Transparent) {
        IoUnregisterFileSystem (DeviceObject);
        DeviceExtension->State = Transparent;
    }
    IoDeleteDevice (DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}


VOID
FsRecUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine cleans up the driver's data structures so that it can be
    unloaded.

Arguments:

    DriverObject - Pointer to the driver object for this driver.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool( FsRecLoadSync );

    return;
}


NTSTATUS
FsRecLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWCHAR DriverServiceName
    )

/*++


Routine Description:

    This routine performs the common work of loading a filesystem on behalf
    of one of our recognizers.

Arguments:

    DeviceObject - Pointer to the device object for the recognizer.

    DriverServiceName - Specifies the name of the node in the registry
        associated with the driver to be loaded.

Return Value:

    NTSTATUS.  The recognizer will be set into a transparent mode on return.
    
--*/

{
    UNICODE_STRING driverName;
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS status = STATUS_IMAGE_ALREADY_LOADED;

    PAGED_CODE();

    //
    //  Quickly check if the recognizer has already fired.
    //
    
    if (deviceExtension->State != Transparent) {
    
        //
        //  Serialize all threads trying to load this filesystem.
        //
        //  We need to do this for several reasons.  With the new behavior in
        //  IoRegisterFileSystem, we do not know ahead of time whether the
        //  filesystem has been loaded ahead or behind this recognizer in the
        //  scan queue.  This means that we cannot make this recognizer transparent
        //  before the real filesystem has become registered, or else if the
        //  filesystem loads behind us we may let threads go through that will
        //  not find it in that window of time.
        //
        //  The reason this is possible is that NtLoadDriver does not guarantee
        //  that if it returns STATUS_IMAGE_ALREADY_LOADED, that the driver in
        //  question has actually initialized itself, which *is* guaranteed if
        //  it returns STATUS_SUCCESS.  We have to keep these threads bottled
        //  up until they can rescan with the promise that what they need is there.
        //
        //  As a bonus, we can now guarantee that the recognizer goes away in
        //  all cases, not just when the driver successfully loads itself.
        //
        
        KeWaitForSingleObject( FsRecLoadSync,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
        KeEnterCriticalRegion();
    
        //
        //  Attempt the filesystem load precisely once for all recognizers
        //  of a given filesystem.
        //
        
        if (deviceExtension->State == Active) {

            //
            //  For bonus points, in the future we may want to log an event
            //  on failure.
            //

            RtlInitUnicodeString( &driverName, DriverServiceName );
            status = ZwLoadDriver( &driverName );

            //
            //  Now walk all codependant recognizers and instruct them to go
            //  into the fast unload state.  Since IO only expects the fsDO
            //  it is asking to load a filesystem to to unregister itself, if
            //  we unregistered all of the co-recognizers they would dangle.
            //  Unfortunately, this means that fsrec may wind up hanging around
            //  quite a bit longer than strictly neccesary.
            //
            //  Note: we come right back to the original DeviceObject at the
            //  end of this loop (important).  It is also very important that
            //  we only did this once since after we release the mutex the co-
            //  recognizers may begin going away in any order.
            //

            while (deviceExtension->State != FastUnload) {

                deviceExtension->State = FastUnload;

                DeviceObject = deviceExtension->CoRecognizer;
                deviceExtension = DeviceObject->DeviceExtension;
            } 
        }
        
        //
        //  Unregister this recognizer precisely once.
        //

        if (deviceExtension->State != Transparent) {
            
            IoUnregisterFileSystem( DeviceObject );
            deviceExtension->State = Transparent;
        }
        
        KeSetEvent( FsRecLoadSync, 0, FALSE );
        KeLeaveCriticalRegion();
    }
    
    return status;
}


BOOLEAN
FsRecGetDeviceSectors (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BytesPerSector,
    OUT PLARGE_INTEGER NumberOfSectors
    )

/*++

Routine Description:

    This routine returns information about the partition represented by the
    device object.

Arguments:

    DeviceObject - Pointer to the device object from which to read.

    BytesPerSector - The number of bytes per sector for the device being read.

    NumberOfSectors - Variable to receive the number of sectors for this
        partition.

Return Value:

    The function value is TRUE if the information was found, otherwise FALSE.

--*/

{
    GET_LENGTH_INFORMATION lengthInfo;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    NTSTATUS status;
    ULONG remainder;

    PAGED_CODE();

    //
    //  We only do this for disks right now. This is likely to change when we
    //  have to recognize CDUDF media.
    //

    if (DeviceObject->DeviceType != FILE_DEVICE_DISK) {

        return FALSE;
    }

    //
    // Get the number of sectors on this partition.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_LENGTH_INFO,
                                         DeviceObject,
                                         (PVOID) NULL,
                                         0,
                                         &lengthInfo,
                                         sizeof( lengthInfo ),
                                         FALSE,
                                         &event,
                                         &ioStatus );
    if (!irp) {
        return FALSE;
    }

    //
    //  Override verify logic - we don't care. The fact we're in the picture means
    //  someone is trying to mount new/changed media in the first place.
    //
    
    SetFlag( IoGetNextIrpStackLocation( irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    status = IoCallDriver( DeviceObject, irp );
    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    *NumberOfSectors = RtlExtendedLargeIntegerDivide( lengthInfo.Length,
                                                      BytesPerSector,
                                                      &remainder );

    return TRUE;
}


BOOLEAN
FsRecGetDeviceSectorSize (
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG BytesPerSector
    )

/*++

Routine Description:

    This routine returns the sector size of the underlying device.

Arguments:

    DeviceObject - Pointer to the device object from which to read.

    BytesPerSector - Variable to receive the number of bytes per sector for the
        device being read.

Return Value:

    The function value is TRUE if the information was found, otherwise FALSE.

--*/

{
    DISK_GEOMETRY diskGeometry;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    NTSTATUS status;
    ULONG ControlCode;

    PAGED_CODE();

    //
    //  Figure out what kind of device we have so we can use the right IOCTL.
    //

    switch (DeviceObject->DeviceType) {
        case FILE_DEVICE_CD_ROM:
            ControlCode = IOCTL_CDROM_GET_DRIVE_GEOMETRY;
            break;

        case FILE_DEVICE_DISK:
            ControlCode = IOCTL_DISK_GET_DRIVE_GEOMETRY;
            break;

        default:
            return FALSE;
    }

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );
    irp = IoBuildDeviceIoControlRequest( ControlCode,
                                         DeviceObject,
                                         (PVOID) NULL,
                                         0,
                                         &diskGeometry,
                                         sizeof( diskGeometry ),
                                         FALSE,
                                         &event,
                                         &ioStatus );

    if (!irp) {
        return FALSE;
    }

    //
    //  Override verify logic - we don't care. The fact we're in the picture means
    //  someone is trying to mount new/changed media in the first place.
    //
    
    SetFlag( IoGetNextIrpStackLocation( irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    
    status = IoCallDriver( DeviceObject, irp );
    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    //
    // Ensure that the drive actually knows how many bytes there are per
    // sector.  Floppy drives do not know if the media is unformatted.
    //

    if (!diskGeometry.BytesPerSector) {
        return FALSE;
    }

    //
    // Store the return values for the caller.
    //

    *BytesPerSector = diskGeometry.BytesPerSector;

    return TRUE;
}


BOOLEAN
FsRecReadBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLARGE_INTEGER ByteOffset,
    IN ULONG MinimumBytes,
    IN ULONG BytesPerSector,
    OUT PVOID *Buffer,
    OUT PBOOLEAN IsDeviceFailure OPTIONAL
    )

/*++

Routine Description:

    This routine reads a minimum numbers of bytes into a buffer starting at
    the byte offset from the base of the device represented by the device
    object.

Arguments:

    DeviceObject - Pointer to the device object from which to read.

    ByteOffset - Pointer to a 64-bit byte offset from the base of the device
        from which to start the read.

    MinimumBytes - Supplies the minimum number of bytes to be read.

    BytesPerSector - The number of bytes per sector for the device being read.

    Buffer - Variable to receive a pointer to the allocated buffer containing
        the bytes read.
        
    IsDeviceFailure - Variable to receive an indication whether a failure
        was a result of talking to the device.

Return Value:

    The function value is TRUE if the bytes were read, otherwise FALSE.

--*/

{
    #define RoundUp( x, y ) ( ((x + (y-1)) / y) * y )

    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE();

    if (IsDeviceFailure) {
        *IsDeviceFailure = FALSE;
    }
    
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Set the minimum number of bytes to read to the maximum of the bytes that
    // the caller wants to read, and the number of bytes in a sector.
    //

    if (MinimumBytes < BytesPerSector) {
        MinimumBytes = BytesPerSector;
    } else {
        MinimumBytes = RoundUp( MinimumBytes, BytesPerSector );
    }

    //
    // Allocate a buffer large enough to contain the bytes required, round the
    // request to a page boundary to solve any alignment requirements.
    //

    if (!*Buffer) {

        *Buffer = ExAllocatePoolWithTag( NonPagedPool,
					 (MinimumBytes + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1),
					 FSREC_POOL_TAG );
        if (!*Buffer) {
            return FALSE;
        }
    }

    //
    // Read the actual bytes off of the media.
    //

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        DeviceObject,
                                        *Buffer,
                                        MinimumBytes,
                                        ByteOffset,
                                        &event,
                                        &ioStatus );
    if (!irp) {
        return FALSE;
    }
    
    //
    //  Override verify logic - we don't care. The fact we're in the picture means
    //  someone is trying to mount new/changed media in the first place.
    //
    
    SetFlag( IoGetNextIrpStackLocation( irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    status = IoCallDriver( DeviceObject, irp );
    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS( status )) {

        if (IsDeviceFailure) {
            *IsDeviceFailure = TRUE;
        }
        return FALSE;
    }

    return TRUE;
}


#if DBG
BOOLEAN
FsRecDebugTrace (
    LONG IndentIncrement,
    ULONG TraceMask,
    PCHAR Format,
    ...
    )

/*++

Routine Description:

    This routine is a simple debug info printer that returns a constant boolean value.  This
    makes it possible to splice it into the middle of boolean expressions to discover which
    elements are firing.
    
    We will use this as our general debug printer.  See udfdata.h for how we use the DebugTrace
    macro to accomplish the effect.
    
Arguments:

    IndentIncrement - amount to change the indentation by.
    
    TraceMask - specification of what debug trace level this call should be noisy at.

Return Value:

    USHORT - The 16bit CRC

--*/

{
    va_list Arglist;
    LONG i;
    UCHAR Buffer[128];
    int Bytes;

#define Min(a, b)   ((a) < (b) ? (a) : (b))
    
    if (TraceMask == 0 || (FsRecDebugTraceLevel & TraceMask) != 0) {

        //
        //  Emit a preamble of our thread ID.
        //
        
        DbgPrint( "%p:", PsGetCurrentThread());

        if (IndentIncrement < 0) {
            
            FsRecDebugTraceIndent += IndentIncrement;
        }

        if (FsRecDebugTraceIndent < 0) {
            
            FsRecDebugTraceIndent = 0;
        }

        //
        //  Build the indent in big chunks since calling DbgPrint repeatedly is expensive.
        //
        
        for (i = FsRecDebugTraceIndent; i > 0; i -= (sizeof(Buffer) - 1)) {

            RtlFillMemory( Buffer, Min( i, (sizeof(Buffer) - 1 )), ' ');
            *(Buffer + Min( i, (sizeof(Buffer) - 1 ))) = '\0';
            
            DbgPrint( Buffer );
        }

        //
        // Format the output into a buffer and then print it.
        //

        va_start( Arglist, Format );
        Bytes = _vsnprintf( Buffer, sizeof(Buffer), Format, Arglist );
        va_end( Arglist );

        //
        // detect buffer overflow
        //

        if (Bytes == -1) {

            Buffer[sizeof(Buffer) - 1] = '\n';
        }

        DbgPrint( Buffer );

        if (IndentIncrement > 0) {

            FsRecDebugTraceIndent += IndentIncrement;
        }
    }

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\udfs_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    udfs_rec.c

Abstract:

    This module contains the mini-file system recognizer for UDFS.

Author:

    Dan Lovinger (danlo) 13-Feb-1997

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"
#include "udfs_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_UDFS)

//
//  Tables of tokens we have to parse up from mount-time on-disk structures
//

PARSE_KEYVALUE VsdIdentParseTable[] = {
    { VSD_IDENT_BEA01, VsdIdentBEA01 },
    { VSD_IDENT_TEA01, VsdIdentTEA01 },
    { VSD_IDENT_CDROM, VsdIdentCDROM },
    { VSD_IDENT_CD001, VsdIdentCD001 },
    { VSD_IDENT_CDW01, VsdIdentCDW01 },
    { VSD_IDENT_CDW02, VsdIdentCDW02 },
    { VSD_IDENT_NSR01, VsdIdentNSR01 },
    { VSD_IDENT_NSR02, VsdIdentNSR02 },
    { VSD_IDENT_BOOT2, VsdIdentBOOT2 },
    { VSD_IDENT_NSR03, VsdIdentNSR03 },
    { NULL,            VsdIdentBad }
    };

NTSTATUS
UdfsRecGetLastSessionStart(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG Psn
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,IsUdfsVolume)
#pragma alloc_text(PAGE,UdfsFindInParseTable)
#pragma alloc_text(PAGE,UdfsRecFsControl)
#pragma alloc_text(PAGE,UdfsRecGetLastSessionStart)
#endif // ALLOC_PRAGMA


//
//  This macro copies an unaligned src longword to a dst longword,
//  performing an little/big endian swap.
//

#define SwapCopyUchar4(Dst,Src) {                                        \
    *((UNALIGNED UCHAR *)(Dst)) = *((UNALIGNED UCHAR *)(Src) + 3);     \
    *((UNALIGNED UCHAR *)(Dst) + 1) = *((UNALIGNED UCHAR *)(Src) + 2); \
    *((UNALIGNED UCHAR *)(Dst) + 2) = *((UNALIGNED UCHAR *)(Src) + 1); \
    *((UNALIGNED UCHAR *)(Dst) + 3) = *((UNALIGNED UCHAR *)(Src));     \
}


NTSTATUS
UdfsRecGetLastSessionStart(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG Psn
    )
/*++

Routine Description:

    This function queries the underlying device for the address of the
    first track in the last session.  Does nothing for DISK devices.
    
Arguments:

    DeviceObject - Pointer to this driver's device object.

    Psn - receives physical sector number of first block in last session,
          0 for disk devices

Return Value:

    The function value is the final status of the operation.

 -*/
{
    KEVENT Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK ioStatus;
    CDROM_TOC_SESSION_DATA SessionData;
    PIRP Irp;

    *Psn = 0;
    
    if (DeviceObject->DeviceType != FILE_DEVICE_CD_ROM) {

        return STATUS_SUCCESS;
    }

    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IOCTL_CDROM_GET_LAST_SESSION,
                                         DeviceObject,
                                         (PVOID) NULL,
                                         0,
                                         &SessionData,
                                         sizeof( SessionData ),
                                         FALSE,
                                         &Event,
                                         &ioStatus );
    if (!Irp) {
    
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Override verify logic - we don't care. The fact we're in the picture means
    //  someone is trying to mount new/changed media in the first place.
    //
    
    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    Status = IoCallDriver( DeviceObject, Irp );
    
    if (Status == STATUS_PENDING) {
    
        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        Status = ioStatus.Status;
    }

    if (!NT_SUCCESS( Status )) {
    
        return Status;
    }

    if (SessionData.FirstCompleteSession != SessionData.LastCompleteSession)  {

        SwapCopyUchar4( Psn, &SessionData.TrackData[0].Address );
    }
    
    return STATUS_SUCCESS;
}



NTSTATUS
UdfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


 -*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    UNICODE_STRING driverName;
    ULONG bytesPerSector;
    PDEVICE_OBJECT targetDevice;

    PAGED_CODE();

    //
    // Begin by determining what function that is to be performed.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_MOUNT_VOLUME:

        //
        // Attempt to mount a volume:  There are two different cases here:
        //
        //     1)  The device is being opened for DASD access, that is, no
        //         file system is required, thus it is OK to allow RAW to
        //         to open it.
        //
        //     2)  We need to rummage the media to see if this is a UDF volume.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        targetDevice = irpSp->Parameters.MountVolume.DeviceObject;

        if (FsRecGetDeviceSectorSize( targetDevice,
                                      &bytesPerSector )) {
        
            if (IsUdfsVolume( targetDevice,
                              bytesPerSector )) {

                status = STATUS_FS_DRIVER_REQUIRED;
            }
        }

        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        status = FsRecLoadFileSystem( DeviceObject,
                                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Udfs" );
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // Finally, complete the request and return the same status code to the
    // caller.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}


BOOLEAN
IsUdfsVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize
    )

/*++

Routine Description:

    This routine walks the Volume Recognition Sequence to determine
    whether this volume contains an NSR02 (ISO 13346 Section 4) image.
    
    Note: this routine is pretty much diked out of UdfsRecognizeVolume
    in the real filesystem, modulo fitting it into the fs recognizer.

Arguments:

    DeviceObject - device we are checking

    SectorSize - size of a physical sector on this device

Return Value:

    Boolean TRUE if we found NSR02, FALSE otherwise.

--*/

{
    BOOLEAN FoundNSR;

    BOOLEAN FoundBEA;
    BOOLEAN Resolved;

    ULONG LastSessionStartPsn;

    PVSD_GENERIC VolumeStructureDescriptor = NULL;
    PVOID Buffer = NULL;
    ULONGLONG Offset;

    PAGED_CODE();

    DebugTrace(( +1, Dbg,
                 "IsUdfsVolume, DevObj %08x SectorSize %08x\n",
                 DeviceObject,
                 SectorSize ));

    //
    //  Find the start of the last session
    //

    if (!NT_SUCCESS( UdfsRecGetLastSessionStart( DeviceObject, 
                                                 &LastSessionStartPsn)))  {

        return FALSE;
    }

Retry:

    DebugTrace(( 0, Dbg, "IsUdfsVolume, Looking at session starting Psn == 0x%x\n", LastSessionStartPsn));

    Offset = (SectorSize * LastSessionStartPsn) + SectorAlignN( SectorSize, VRA_BOUNDARY_LOCATION );

    FoundNSR = 
    FoundBEA =
    Resolved = FALSE;

    while (!Resolved) {

        //
        //  The VRS descriptors are specified at 2kb regardless of sector size.  So
        //  we only want to read if we've processed all 2kb blocks in the last read
        //  sector (latest gen MO media has 4kb sectors) i.e. if we have landed
        //  on a sector aligned offset after processing the last descriptor.
        //
        
        if (0 == (Offset & (SectorSize - 1)))  {

            if (!FsRecReadBlock( DeviceObject,
                                 (PLARGE_INTEGER)&Offset,
                                 sizeof(VSD_GENERIC),
                                 SectorSize,
                                 &Buffer,
                                 NULL ))  {
                break;
            }

            VolumeStructureDescriptor = Buffer;
        }

        //
        //  Now check the type of the descriptor. All ISO 13346 VSDs are
        //  of Type 0, 9660 PVDs are Type 1, 9660 SVDs are Type 2, and 9660
        //  terminating descriptors are Type 255.
        //
    
        if (VolumeStructureDescriptor->Type == 0) {

            //
            //  In order to properly recognize the volume, we must know all of the
            //  Structure identifiers in ISO 13346 so that we can terminate if a
            //  badly formatted (or, shockingly, non 13346) volume is presented to us.
            //

            switch (UdfsFindInParseTable( VsdIdentParseTable,
                                         VolumeStructureDescriptor->Ident,
                                         VSD_LENGTH_IDENT )) {
                case VsdIdentBEA01:

                    //
                    //  Only one BEA may exist and its version must be 1 (2/9.2.3)
                    //

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got a BEA01\n" ));


                    if ((FoundBEA &&
                         DebugTrace(( 0, Dbg,
                                      "IsUdfsVolume, ... but it is a duplicate!\n" ))) ||

                        (VolumeStructureDescriptor->Version != 1 &&
                         DebugTrace(( 0, Dbg,
                                      "IsUdfsVolume, ... but it has a wacky version number %02x != 1!\n",
                                      VolumeStructureDescriptor->Version )))) {

                        Resolved = TRUE;
                        break;
                    }

                    FoundBEA = TRUE;
                    break;

                case VsdIdentTEA01:

                    //
                    //  If we reach the TEA it must be the case that we don't recognize
                    //

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got a TEA01\n" ));

                    Resolved = TRUE;
                    break;

                case VsdIdentNSR02:
                case VsdIdentNSR03:

                    //
                    //  We recognize NSR02 version 1 embedded after a BEA (3/9.1.3).  For
                    //  simplicity we will not bother being a complete nitpick and check
                    //  for a bounding TEA, although we will be optimistic in the case where
                    //  we fail to match the version.
                    //

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got an NSR02/3\n" ));

                    if ((FoundBEA ||
                         !DebugTrace(( 0, Dbg, "IsUdfsVolume, ... but we haven't seen a BEA01 yet!\n" ))) &&

                        (VolumeStructureDescriptor->Version == 1 ||
                         !DebugTrace(( 0, Dbg, "IsUdfsVolume, ... but it has a wacky version number %02x != 1\n",
                                       VolumeStructureDescriptor->Version )))) {

                        FoundNSR = Resolved = TRUE;
                        break;
                    }

                    break;

                case VsdIdentCD001:
                case VsdIdentCDW01:
                case VsdIdentNSR01:
                case VsdIdentCDW02:
                case VsdIdentBOOT2:

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got a valid but uninteresting 13346 descriptor\n" ));

                    //
                    //  Valid but uninteresting (to us) descriptors
                    //

                    break;

                default:

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got an invalid 13346 descriptor\n" ));

                    //
                    //  Stumbling across something we don't know, it must be that this
                    //  is not a valid 13346 image
                    //

                    Resolved = TRUE;
                    break;

            }

        } else if (!FoundBEA && (VolumeStructureDescriptor->Type < 3 ||
                                 VolumeStructureDescriptor->Type == 255)) {

            DebugTrace(( 0, Dbg, "IsUdfsVolume, got a 9660 descriptor\n" ));

            //
            //  Only HSG (CDROM) and 9660 (CD001) are possible, and they are only legal
            //  before the ISO 13346 BEA/TEA extent.  By design, an ISO 13346 VSD precisely
            //  overlaps a 9660 PVD/SVD in the appropriate fields.
            //
            //  Note that we aren't being strict about the structure of the 9660 descriptors
            //  since that really isn't very interesting.  We care more about the 13346.
            //  
            //

            switch (UdfsFindInParseTable( VsdIdentParseTable,
                                          VolumeStructureDescriptor->Ident,
                                          VSD_LENGTH_IDENT )) {
                case VsdIdentCDROM:
                case VsdIdentCD001:

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, ... seems we have 9660 here\n" ));

                    //
                    //  Note to our caller that we seem to have ISO 9660 here
                    //

                    break;

                default:

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, ... but it looks wacky\n" ));

                    //
                    //  This probably was a false alert, but in any case there is nothing
                    //  on this volume for us.
                    //

                    Resolved = TRUE;
                    break;
            }

        } else {

            //
            //  Something else must be recorded on this volume.
            //

            DebugTrace(( 0, Dbg, "IsUdfsVolume, got an unrecognizeable descriptor, probably not 13346/9660\n" ));
            break;
        }

        //
        //  Descriptor size is 2kb.  Sector size is always a power of 2.  So just
        //  increase offset by desc. size.  This may fall on another 2k block within
        //  the current sector.
        //

        Offset += sizeof(VSD_GENERIC);
        VolumeStructureDescriptor = (PVSD_GENERIC)(((PUCHAR)VolumeStructureDescriptor) + sizeof( VSD_GENERIC));
    }

    //
    //  If we were looking in the last session,  and failed to find anything,  then
    //  go back and try the first.
    //
    
    if (!FoundNSR && (0 != LastSessionStartPsn))  {

        LastSessionStartPsn = 0;

        goto Retry;
    }

    DebugTrace(( -1, Dbg, "IsUdfsVolume -> %c\n", ( FoundNSR ? 'T' : 'F' )));

    //
    //  Free up our temporary buffer
    //

    if (Buffer) {
    
        ExFreePool( Buffer );
    }

    return FoundNSR;
}


ULONG
UdfsFindInParseTable (
    IN PPARSE_KEYVALUE ParseTable,
    IN PCHAR Id,
    IN ULONG MaxIdLen
    )

/*++

Routine Description:

    This routine walks a table of string key/value information for a match of the
    input Id.  MaxIdLen can be set to get a prefix match.

Arguments:

    Table - This is the table being searched.

    Id - Key value.

    MaxIdLen - Maximum possible length of Id.

Return Value:

    Value of matching entry, or the terminating (NULL) entry's value.

--*/

{
    PAGED_CODE();

    while (ParseTable->Key != NULL) {

        if (RtlEqualMemory(ParseTable->Key, Id, MaxIdLen)) {

            break;
        }

        ParseTable++;
    }

    return ParseTable->Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\ntfs_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntfs_rec.c

Abstract:

    This module contains the mini-file system recognizer for NTFS.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"
#include "ntfs_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_NTFS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtfsRecFsControl)
#pragma alloc_text(PAGE,IsNtfsVolume)
#endif // ALLOC_PRAGMA


NTSTATUS
NtfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT targetDevice;
    PPACKED_BOOT_SECTOR buffer;
    LARGE_INTEGER byteOffset;
    LARGE_INTEGER secondByteOffset;
    LARGE_INTEGER lastByteOffset;
    UNICODE_STRING driverName;
    ULONG bytesPerSector;
    LARGE_INTEGER numberOfSectors;

    PAGED_CODE();

    //
    // Begin by determining what function that is to be performed.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_MOUNT_VOLUME:

        //
        // Attempt to mount a volume:  Determine whether or not the volume in
        // question is an NTFS volume and, if so, let the I/O system know that it
        // is by returning a special status code so that this driver can get
        // called back to load the NTFS file system.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        //
        // Attempt to determine whether or not the target volume being mounted
        // is an NTFS volume.
        //

        targetDevice = irpSp->Parameters.MountVolume.DeviceObject;

        if (FsRecGetDeviceSectorSize( targetDevice,
                                      &bytesPerSector ) &&
            FsRecGetDeviceSectors( targetDevice,
                                   bytesPerSector,
                                   &numberOfSectors )) {

            byteOffset.QuadPart = 0;
            buffer = NULL;
            secondByteOffset.QuadPart = numberOfSectors.QuadPart >> 1;
            secondByteOffset.QuadPart *= (LONG) bytesPerSector;
            lastByteOffset.QuadPart = (numberOfSectors.QuadPart - 1) * (LONG) bytesPerSector;

            if (FsRecReadBlock( targetDevice,
                                &byteOffset,
                                sizeof( PACKED_BOOT_SECTOR ),
                                bytesPerSector,
                                (PVOID *)&buffer,
                                NULL ))
            {

                if (IsNtfsVolume( buffer, bytesPerSector, &numberOfSectors )) {
                    status = STATUS_FS_DRIVER_REQUIRED;
                }

            } else {

                if (FsRecReadBlock( targetDevice,
                                    &secondByteOffset,
                                    sizeof( PACKED_BOOT_SECTOR ),
                                    bytesPerSector,
                                    (PVOID *)&buffer,
                                    NULL ) &&
                    IsNtfsVolume( buffer, bytesPerSector, &numberOfSectors )) {

                    status = STATUS_FS_DRIVER_REQUIRED;

                } else {

                    if (FsRecReadBlock( targetDevice,
                                        &lastByteOffset,
                                        sizeof( PACKED_BOOT_SECTOR ),
                                        bytesPerSector,
                                        (PVOID *)&buffer,
                                        NULL ) &&
                        IsNtfsVolume( buffer, bytesPerSector, &numberOfSectors )) {

                        status = STATUS_FS_DRIVER_REQUIRED;
                    }
                }
            }

            if (buffer != NULL) {
                ExFreePool( buffer );
            }
        }

        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        status = FsRecLoadFileSystem( DeviceObject,
                                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Ntfs" );
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // Finally, complete the request and return the same status code to the
    // caller.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}


BOOLEAN
IsNtfsVolume(
    IN PPACKED_BOOT_SECTOR BootSector,
    IN ULONG BytesPerSector,
    IN PLARGE_INTEGER NumberOfSectors
    )

/*++

Routine Description:

    This routine looks at the buffer passed in which contains the NTFS boot
    sector and determines whether or not it represents an NTFS volume.

Arguments:

    BootSector - Pointer to buffer containing a potential NTFS boot sector.

    BytesPerSector - Supplies the number of bytes per sector for the drive.

    NumberOfSectors - Supplies the number of sectors on the partition.

Return Value:

    The function returns TRUE if the buffer contains a recognizable NTFS boot
    sector, otherwise it returns FALSE.

--*/

{
    PAGED_CODE();

    //
    // Now perform all the checks, starting with the Name and Checksum.
    // The remaining checks should be obvious, including some fields which
    // must be 0 and other fields which must be a small power of 2.
    //

    if (BootSector->Oem[0] == 'N' &&
        BootSector->Oem[1] == 'T' &&
        BootSector->Oem[2] == 'F' &&
        BootSector->Oem[3] == 'S' &&
        BootSector->Oem[4] == ' ' &&
        BootSector->Oem[5] == ' ' &&
        BootSector->Oem[6] == ' ' &&
        BootSector->Oem[7] == ' '

            &&

        //
        // Check number of bytes per sector.  The low order byte of this
        // number must be zero (smallest sector size = 0x100) and the
        // high order byte shifted must equal the bytes per sector gotten
        // from the device and stored in the Vcb.  And just to be sure,
        // sector size must be less than page size.
        //

        BootSector->PackedBpb.BytesPerSector[0] == 0

            &&

        ((ULONG) (BootSector->PackedBpb.BytesPerSector[1] << 8) == BytesPerSector)

            &&

        BootSector->PackedBpb.BytesPerSector[1] << 8 <= PAGE_SIZE

            &&

        //
        //  Sectors per cluster must be a power of 2.
        //

        (BootSector->PackedBpb.SectorsPerCluster[0] == 0x1 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x2 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x4 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x8 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x10 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x20 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x40 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x80)

            &&

        //
        //  These fields must all be zero.  For both Fat and HPFS, some of
        //  these fields must be nonzero.
        //

        BootSector->PackedBpb.ReservedSectors[0] == 0 &&
        BootSector->PackedBpb.ReservedSectors[1] == 0 &&
        BootSector->PackedBpb.Fats[0] == 0 &&
        BootSector->PackedBpb.RootEntries[0] == 0 &&
        BootSector->PackedBpb.RootEntries[1] == 0 &&
        BootSector->PackedBpb.Sectors[0] == 0 &&
        BootSector->PackedBpb.Sectors[1] == 0 &&
        BootSector->PackedBpb.SectorsPerFat[0] == 0 &&
        BootSector->PackedBpb.SectorsPerFat[1] == 0 &&
        BootSector->PackedBpb.LargeSectors[0] == 0 &&
        BootSector->PackedBpb.LargeSectors[1] == 0 &&
        BootSector->PackedBpb.LargeSectors[2] == 0 &&
        BootSector->PackedBpb.LargeSectors[3] == 0

            &&

        //
        //  Number of Sectors cannot be greater than the number of sectors
        //  on the partition.
        //

        !( BootSector->NumberSectors.QuadPart > NumberOfSectors->QuadPart )

            &&

        //
        //  Check that both Lcn values are for sectors within the partition.
        //

        !( BootSector->MftStartLcn.QuadPart *
                    BootSector->PackedBpb.SectorsPerCluster[0] >
                NumberOfSectors->QuadPart )

            &&

        !( BootSector->Mft2StartLcn.QuadPart *
                    BootSector->PackedBpb.SectorsPerCluster[0] >
                NumberOfSectors->QuadPart )

            &&

        //
        //  Clusters per file record segment and default clusters for Index
        //  Allocation Buffers must be a power of 2.  A negative number indicates
        //  a shift value to get the actual size of the structure.
        //

        ((BootSector->ClustersPerFileRecordSegment >= -31 &&
          BootSector->ClustersPerFileRecordSegment <= -9) ||
         BootSector->ClustersPerFileRecordSegment == 0x1 ||
         BootSector->ClustersPerFileRecordSegment == 0x2 ||
         BootSector->ClustersPerFileRecordSegment == 0x4 ||
         BootSector->ClustersPerFileRecordSegment == 0x8 ||
         BootSector->ClustersPerFileRecordSegment == 0x10 ||
         BootSector->ClustersPerFileRecordSegment == 0x20 ||
         BootSector->ClustersPerFileRecordSegment == 0x40)

            &&

        ((BootSector->DefaultClustersPerIndexAllocationBuffer >= -31 &&
          BootSector->DefaultClustersPerIndexAllocationBuffer <= -9) ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x1 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x2 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x4 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x8 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x10 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x20 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x40)) {

        return TRUE;

    } else {

        //
        // This does not appear to be an NTFS volume.
        //

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\ntfs_rec.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntfs_rec.h

Abstract:

    This module contains the mini-file system recognizer for NTFS.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

//
//  The fundamental unit of allocation on an Ntfs volume is the
//  cluster.  Format guarantees that the cluster size is an integral
//  power of two times the physical sector size of the device.  Ntfs
//  reserves 64-bits to describe a cluster, in order to support
//  large disks.  The LCN represents a physical cluster number on
//  the disk, and the VCN represents a virtual cluster number within
//  an attribute.
//

typedef LARGE_INTEGER LCN;
typedef LCN *PLCN;

typedef LARGE_INTEGER VCN;
typedef VCN *PVCN;

typedef LARGE_INTEGER LBO;
typedef LBO *PLBO;

typedef LARGE_INTEGER VBO;
typedef VBO *PVBO;

//
//  The boot sector is duplicated on the partition.  The first copy
//  is on the first physical sector (LBN == 0) of the partition, and
//  the second copy is at <number sectors on partition> / 2.  If the
//  first copy can not be read when trying to mount the disk, the
//  second copy may be read and has the identical contents.  Format
//  must figure out which cluster the second boot record belongs in,
//  and it must zero all of the other sectors that happen to be in
//  the same cluster.  The boot file minimally contains with two
//  clusters, which are the two clusters which contain the copies of
//  the boot record.  If format knows that some system likes to put
//  code somewhere, then it should also align this requirement to
//  even clusters, and add that to the boot file as well.
//
//  Part of the sector contains a BIOS Parameter Block.  The BIOS in
//  the sector is packed (i.e., unaligned) so we'll supply an
//  unpacking macro to translate a packed BIOS into its unpacked
//  equivalent.  The unpacked BIOS structure is already defined in
//  ntioapi.h so we only need to define the packed BIOS.
//

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {

    UCHAR  BytesPerSector[2];                               //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                            //  offset = 0x002
    UCHAR  ReservedSectors[2];                              //  offset = 0x003 (zero)
    UCHAR  Fats[1];                                         //  offset = 0x005 (zero)
    UCHAR  RootEntries[2];                                  //  offset = 0x006 (zero)
    UCHAR  Sectors[2];                                      //  offset = 0x008 (zero)
    UCHAR  Media[1];                                        //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                                //  offset = 0x00B (zero)
    UCHAR  SectorsPerTrack[2];                              //  offset = 0x00D
    UCHAR  Heads[2];                                        //  offset = 0x00F
    UCHAR  HiddenSectors[4];                                //  offset = 0x011 (zero)
    UCHAR  LargeSectors[4];                                 //  offset = 0x015 (zero)

} PACKED_BIOS_PARAMETER_BLOCK;                              //  sizeof = 0x019

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

//
//  Define the boot sector.  Note that MFT2 is exactly three file
//  record segments long, and it mirrors the first three file record
//  segments from the MFT, which are MFT, MFT2 and the Log File.
//
//  The Oem field contains the ASCII characters "NTFS    ".
//
//  The Checksum field is a simple additive checksum of all of the
//  ULONGs which precede the Checksum ULONG.  The rest of the sector
//  is not included in this Checksum.
//

typedef struct _PACKED_BOOT_SECTOR {

    UCHAR Jump[3];                                                  //  offset = 0x000
    UCHAR Oem[8];                                                   //  offset = 0x003
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;                          //  offset = 0x00B
    UCHAR Unused[4];                                                //  offset = 0x024
    LARGE_INTEGER NumberSectors;                                    //  offset = 0x028
    LCN MftStartLcn;                                                //  offset = 0x030
    LCN Mft2StartLcn;                                               //  offset = 0x038
    CHAR ClustersPerFileRecordSegment;                              //  offset = 0x040
    UCHAR Reserved0[3];
    CHAR DefaultClustersPerIndexAllocationBuffer;                   //  offset = 0x044
    UCHAR Reserved1[3];
    LARGE_INTEGER SerialNumber;                                     //  offset = 0x048
    ULONG Checksum;                                                 //  offset = 0x050
    UCHAR BootStrap[0x200-0x054];                                   //  offset = 0x054

} PACKED_BOOT_SECTOR;                                               //  sizeof = 0x200

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;

//
// Define the functions provided by this driver.
//

BOOLEAN
IsNtfsVolume(
    IN PPACKED_BOOT_SECTOR BootSector,
    IN ULONG BytesPerSector,
    IN PLARGE_INTEGER NumberOfSectors
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\drivesup.c ===
#if !defined(NO_LEGACY_DRIVERS)
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    drivesup.c

Abstract:

    This module contains the subroutines for drive support.  This includes
    such things as how drive letters are assigned on a particular platform,
    how device partitioning works, etc.

Author:

    Darryl E. Havens (darrylh) 23-Apr-1992

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "bugcodes.h"

#include "ntddft.h"
#include "ntdddisk.h"
#include "ntdskreg.h"
#include "stdio.h"
#include "string.h"


VOID
HalpAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );

NTSTATUS
HalpReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT PDRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

NTSTATUS
HalpSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

NTSTATUS
HalpWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN PDRIVE_LAYOUT_INFORMATION PartitionBuffer
    );


NTKERNELAPI
VOID
FASTCALL
IoAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );


NTKERNELAPI
NTSTATUS
FASTCALL
IoReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT PDRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IoSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IoWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN PDRIVE_LAYOUT_INFORMATION PartitionBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpAssignDriveLetters)
#pragma alloc_text(PAGE, HalpReadPartitionTable)
#pragma alloc_text(PAGE, HalpSetPartitionInformation)
#pragma alloc_text(PAGE, HalpWritePartitionTable)
#endif


VOID
HalpAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    )
{

    //
    // Stub to call extensible routine in ke so that hal vendors
    // don't have to support.
    //

    IoAssignDriveLetters(
        LoaderBlock,
        NtDeviceName,
        NtSystemPath,
        NtSystemPathString
        );

}


NTSTATUS
HalpReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT PDRIVE_LAYOUT_INFORMATION *PartitionBuffer
    )
{
    //
    // Stub to call extensible routine in ke so that hal vendors
    // don't have to support.
    //

    return IoReadPartitionTable(
               DeviceObject,
               SectorSize,
               ReturnRecognizedPartitions,
               PartitionBuffer
               );
}

NTSTATUS
HalpSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    )
{
    //
    // Stub to call extensible routine in ke so that hal vendors
    // don't have to support.
    //

    return IoSetPartitionInformation(
               DeviceObject,
               SectorSize,
               PartitionNumber,
               PartitionType
               );

}


NTSTATUS
HalpWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN PDRIVE_LAYOUT_INFORMATION PartitionBuffer
    )
{

    //
    // Stub to call extensible routine in ke so that hal vendors
    // don't have to support.
    //

    return IoWritePartitionTable(
               DeviceObject,
               SectorSize,
               SectorsPerTrack,
               NumberOfHeads,
               PartitionBuffer
               );
}
#endif // NO_LEGACY_DRIVERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\acpidtct.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpidtct.c

Abstract:

    This file pulls the ACPI Root Ssytem Description
    Pointer out of the registry.  It was put there
    either by ntdetect.com or by one ARC firmware or
    another.

Author:

    Jake Oshins (jakeo) 6-Feb-1997

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"
#include "ntacpi.h"

#define rgzMultiFunctionAdapter L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"
#define rgzAcpiConfigurationData L"Configuration Data"
#define rgzAcpiIdentifier L"Identifier"
#define rgzBIOSIdentifier L"ACPI BIOS"

PHYSICAL_ADDRESS HalpAcpiRsdt;

// from ntrtl.h
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );


// internal definitions

NTSTATUS
HalpAcpiGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpAcpiFindRsdtPhase0)
#pragma alloc_text(PAGELK,HalpAcpiGetRegistryValue)
#pragma alloc_text(PAGELK,HalpAcpiFindRsdt)
#endif

NTSTATUS
HalpAcpiFindRsdtPhase0(
       IN PLOADER_PARAMETER_BLOCK LoaderBlock
       )
/*++

Routine Description:

    This function reads the Root System Description Pointer from
    the ACPI BIOS node in the arc tree.  It puts whatever it finds
    into HalpAcpiRsdt.

    This function is suitable for being called during Phase 0 or
    Phase 1 only.  The LoaderBlock is destroyed after that.

Arguments:

    IN PLOADER_PARAMETER_BLOCK LoaderBlock

Return Value:

    status

--*/
{
   PCONFIGURATION_COMPONENT_DATA RsdtComponent = NULL;
   PCONFIGURATION_COMPONENT_DATA Component = NULL;
   PCONFIGURATION_COMPONENT_DATA Resume = NULL;
   PCM_PARTIAL_RESOURCE_LIST Prl;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR Prd;
   ACPI_BIOS_MULTI_NODE UNALIGNED *Rsdp;

   while (Component = KeFindConfigurationNextEntry(LoaderBlock->ConfigurationRoot,AdapterClass,
                                                   MultiFunctionAdapter,NULL,&Resume)) {
      if (!(strcmp(Component->ComponentEntry.Identifier,"ACPI BIOS"))) {
         RsdtComponent = Component;
         break;
      }
      Resume = Component;
   }

   //if RsdtComponent is still NULL, we didn't find node
   if (!RsdtComponent) {
      DbgPrint("**** HalpAcpiFindRsdtPhase0: did NOT find RSDT\n");
      return STATUS_NOT_FOUND;
   }

   Prl = (PCM_PARTIAL_RESOURCE_LIST)(RsdtComponent->ConfigurationData);
   Prd = &Prl->PartialDescriptors[0];

   Rsdp = (PACPI_BIOS_MULTI_NODE)((PCHAR) Prd + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

   HalpAcpiRsdt.QuadPart = Rsdp->RsdtAddress.QuadPart;

   return STATUS_SUCCESS;
}


NTSTATUS
HalpAcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    )
/*++

Routine Description:

    This function looks into the registry to find the ACPI RSDT,
    which was stored there by ntdetect.com.

Arguments:

    RsdtPtr - Pointer to a buffer that contains the ACPI
              Root System Description Pointer Structure.
              The caller is responsible for freeing this
              buffer.  Note:  This is returned in non-paged
              pool.

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    UNICODE_STRING unicodeString, unicodeValueName, biosId;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hMFunc, hBus;
    WCHAR wbuffer[10];
    ULONG i, length;
    PWSTR p;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo;
    NTSTATUS status;
    BOOLEAN same;
    PCM_PARTIAL_RESOURCE_LIST prl;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE multiNode;
    ULONG multiNodeSize;

    PAGED_CODE();

    //
    // Look in the registry for the "ACPI BIOS bus" data
    //

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        DbgPrint("AcpiBios:Can not open MultifunctionAdapter registry key.\n");
        return status;
    }

    unicodeString.Buffer = wbuffer;
    unicodeString.MaximumLength = sizeof(wbuffer);
    RtlInitUnicodeString(&biosId, rgzBIOSIdentifier);

    for (i = 0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            DbgPrint("AcpiBios: ACPI BIOS MultifunctionAdapter registry key not found.\n");
            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Check the Indentifier to see if this is an ACPI BIOS entry
        //

        status = HalpAcpiGetRegistryValue (hBus, rgzAcpiIdentifier, &valueInfo);
        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) valueInfo->Data);
        unicodeValueName.Buffer = p;
        unicodeValueName.MaximumLength = (USHORT)valueInfo->DataLength;
        length = valueInfo->DataLength;

        //
        // Determine the real length of the ID string
        //

        while (length) {
            if (p[length / sizeof(WCHAR) - 1] == UNICODE_NULL) {
                length -= 2;
            } else {
                break;
            }
        }

        unicodeValueName.Length = (USHORT)length;
        same = RtlEqualUnicodeString(&biosId, &unicodeValueName, TRUE);
        ExFreePool(valueInfo);
        if (!same) {
            ZwClose (hBus);
            continue;
        }

        status = HalpAcpiGetRegistryValue(hBus, rgzAcpiConfigurationData, &valueInfo);
        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        prl = (PCM_PARTIAL_RESOURCE_LIST)(valueInfo->Data);
        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));


        break;
    }

    multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
                        ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY));

    *AcpiMulti = (PACPI_BIOS_MULTI_NODE)
                   ExAllocatePoolWithTag(NonPagedPool,
                           multiNodeSize,
                           'IPCA');
    if (*AcpiMulti == NULL) {
        ExFreePool(valueInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(*AcpiMulti, multiNode, multiNodeSize);

    ExFreePool(valueInfo);
    return STATUS_SUCCESS;
}

NTSTATUS
HalpAcpiGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                       keyValueLength,
                                       'IPCA');
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\chiphacks.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    chiphacks.c

Abstract:

    Implements utilities for finding and hacking
    various chipsets

Author:

    Jake Oshins (jakeo) 10/02/2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "chiphacks.h"
#include "stdio.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpGetChipHacks)
#pragma alloc_text(PAGE, HalpDoesChipNeedHack)
#pragma alloc_text(PAGE, HalpSetAcpiIrqHack)
#pragma alloc_text(PAGELK, HalpClearSlpSmiStsInICH)
#endif


NTSTATUS
HalpGetChipHacks(
    IN  USHORT  VendorId,
    IN  USHORT  DeviceId,
    IN  ULONG   Ssid OPTIONAL,
    OUT ULONG   *HackFlags
    )
/*++

Routine Description:

    This routine looks under HKLM\System\CurrentControlSet\Control\HAL
    to see if there is an entry for the PCI device being
    described.  If so, it returns a set of associated flags.

Arguments:

    VendorId    - PCI Vendor ID of chip
    DeviceId    - PCI Device ID of chip
    Ssid        - PCI subsystem ID of chip, if applicable
    HackFlags   - value read from registry
    
--*/
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    STRING              AString;
    NTSTATUS            Status;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    ULONG               disposition;
    ULONG               Length;
    CHAR                buffer[20] = {0};
    
    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Inf;
        UCHAR Data[3];
    } PartialInformation;

    PAGED_CODE();

    //
    // Open current control set
    //

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Control");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    Status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        return STATUS_UNSUCCESSFUL;
    }

    // Get the right key

    RtlInitUnicodeString (&UnicodeString,
                          L"HAL");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               BaseHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    Status = ZwCreateKey (&Handle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_NON_VOLATILE,
                          &disposition);
    
    if(!NT_SUCCESS(Status)) {
        goto GetChipHacksCleanup;
    }

    //
    // Look in the registry to see if the registry
    // contains an entry for this chip.  The first 
    // step is to build a string that defines the chip.
    //

    if (Ssid) {
        
        sprintf(buffer, "%04x%04x%08x",
                VendorId,
                DeviceId,
                Ssid);

    } else {

        sprintf(buffer, "%04x%04x",
                VendorId,
                DeviceId);

    }

    RtlInitAnsiString(&AString, buffer);

    RtlUpperString(&AString, &AString);

    Status = STATUS_NOT_FOUND;

    if (NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString,
                                                &AString,
                                                TRUE))) {

        Status = ZwQueryValueKey (Handle,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  &PartialInformation,
                                  sizeof (PartialInformation),
                                  &Length);

        if (NT_SUCCESS(Status)) {

            //
            // We found a value in the registry
            // that corresponds with the chip
            // we just ran across.
            //

            *HackFlags = *((PULONG)(PartialInformation.Inf.Data));
        }

        RtlFreeUnicodeString(&UnicodeString);
    }

GetChipHacksCleanup:
        
    if (Handle) ZwClose (Handle);
    if (BaseHandle) ZwClose (BaseHandle);

    return Status;
}

BOOLEAN
HalpDoesChipNeedHack(
    IN  USHORT  VendorId,
    IN  USHORT  DeviceId,
    IN  ULONG   Ssid OPTIONAL,
    IN  ULONG   HackFlags
    )
/*++

Routine Description:

    This routine is a wrapper for HalpGetChipHacks.

Arguments:

    VendorId    - PCI Vendor ID of chip
    DeviceId    - PCI Device ID of chip
    Ssid        - PCI subsystem ID of chip, if applicable
    HackFlags   - value to compare with registry
    
--*/
{
    ULONG flagsFromRegistry;
    NTSTATUS status;
    
    PAGED_CODE();

    status = HalpGetChipHacks(VendorId,
                              DeviceId,
                              Ssid,
                              &flagsFromRegistry);
    
    if (NT_SUCCESS(status)) {

        if (HackFlags & flagsFromRegistry) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
HalpStopOhciInterrupt(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber
    )
/*++

Routine Description:

    This routine shuts off the interrupt from an OHCI
    USB controller.  This may be necessary because
    a BIOS may enable the PCI interrupt from a USB controller
    in order to do "legacy USB support" where it translates
    USB keyboard and mouse traffic into something that DOS
    can use.  (Our loader and all of Win9x approximate DOS.)

Arguments:

    BusNumber   - Bus number of OHCI controller
    SlotNumber  - Slot number of OHCI controller
        
Note:

    This routine also may need to be called at raised IRQL
    when returning from hibernation.

--*/
{
    //
    // 7.1.2 HcControl Register
    //
    #define HcCtrl_InterruptRouting              0x00000100L

    //
    // 7.1.3 HcCommandStatus Register
    //
    #define HcCmd_OwnershipChangeRequest         0x00000008L

    //
    // 7.1.4 HcInterrruptStatus Register
    // 7.1.5 HcInterruptEnable  Register
    // 7.1.6 HcInterruptDisable Register
    //
    #define HcInt_SchedulingOverrun              0x00000001L
    #define HcInt_WritebackDoneHead              0x00000002L
    #define HcInt_StartOfFrame                   0x00000004L
    #define HcInt_ResumeDetected                 0x00000008L
    #define HcInt_UnrecoverableError             0x00000010L
    #define HcInt_FrameNumberOverflow            0x00000020L
    #define HcInt_RootHubStatusChange            0x00000040L
    #define HcInt_OwnershipChange                0x40000000L
    #define HcInt_MasterInterruptEnable          0x80000000L

    //
    // Host Controler Hardware Registers as accessed in memory
    //
    struct  {
       // 0 0x00 - 0,4,8,c
       ULONG                   HcRevision;
       ULONG                   HcControl;
       ULONG                   HcCommandStatus;
       ULONG                   HcInterruptStatus;   // use HcInt flags below
       // 1 0x10
       ULONG                   HcInterruptEnable;   // use HcInt flags below
       ULONG                   HcInterruptDisable;  // use HcInt flags below
    } volatile *ohci;
    
    PCI_COMMON_CONFIG   PciHeader;
    PHYSICAL_ADDRESS    BarAddr;

    HalGetBusData (
        PCIConfiguration,
        BusNumber,
        SlotNumber.u.AsULONG,
        &PciHeader,
        PCI_COMMON_HDR_LENGTH
        );

    if (PciHeader.Command & PCI_ENABLE_MEMORY_SPACE) {

        //
        // The controller is enabled.
        //

        BarAddr.HighPart = 0;
        BarAddr.LowPart = (PciHeader.u.type0.BaseAddresses[0] & PCI_ADDRESS_MEMORY_ADDRESS_MASK);
        
        if (BarAddr.LowPart != 0) {

            //
            // The BAR is populated.  So map an address for it.
            //
            
            ohci = HalpMapPhysicalMemory64(BarAddr, 2);

            //
            // Set the interrupt disable bit, but disable SMM control of the
            // host controller first.
            //

            if (ohci) {
                
                if (ohci->HcControl & HcCtrl_InterruptRouting) {

                    if ((ohci->HcControl == HcCtrl_InterruptRouting) &&
                        (ohci->HcInterruptEnable == 0)) {

                        // Major assumption:  If HcCtrl_InterruptRouting is
                        // set but no other bits in HcControl are set, i.e.
                        // HCFS==UsbReset, and no interrupts are enabled, then
                        // assume that the BIOS is not actually using the host
                        // controller.  In this case just clear the erroneously
                        // set HcCtrl_InterruptRouting.
                        //
                        ohci->HcControl = 0;  // Clear HcCtrl_InterruptRouting

                    } else {

                        ULONG msCount;

                        //
                        // A SMM driver does own the HC, it will take some time
                        // to get the SMM driver to relinquish control of the
                        // HC.  We will ping the SMM driver, and then wait
                        // repeatedly until the SMM driver has relinquished
                        // control of the HC.
                        //

                        // Disable the root hub status change to prevent an
                        // unhandled interrupt from being asserted after
                        // handoff.  (Not clear what platforms really require
                        // this...)
                        //
                        ohci->HcInterruptDisable = HcInt_RootHubStatusChange;

                        // The HcInt_MasterInterruptEnable and HcInt_OwnershipChange
                        // bits should already be set, but make sure they are.
                        //
                        ohci->HcInterruptEnable = HcInt_MasterInterruptEnable |
                                                  HcInt_OwnershipChange;

                        // Ping the SMM driver to relinquish control of the HC.
                        //
                        ohci->HcCommandStatus = HcCmd_OwnershipChangeRequest;

                        // Wait 500ms for the SMM driver to relinquish control.
                        //
                        for (msCount = 0; msCount < 500; msCount++) {

                            KeStallExecutionProcessor(1000);

                            if (!(ohci->HcControl & HcCtrl_InterruptRouting)) {
                                // SMM driver has relinquished control.
                                break;
                            }
                        }
                    }
                }

                ohci->HcInterruptDisable = HcInt_MasterInterruptEnable;

                //
                // Unmap the virtual address.
                //
    
                HalpUnmapVirtualAddress((PVOID)ohci, 2);
            }
        }
    }
}

VOID
HalpStopUhciInterrupt(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber,
    BOOLEAN             ResetHostController
    )
/*++

Routine Description:

    This routine shuts off the interrupt from an UHCI
    USB controller.  This may be necessary because
    a BIOS may enable the PCI interrupt from a USB controller
    in order to do "legacy USB support" where it translates
    USB keyboard and mouse traffic into something that DOS
    can use.  (Our loader and all of Win9x approximate DOS.)

Arguments:

    BusNumber   - Bus number of UHCI controller
    SlotNumber  - Slot number of UHCI controller
        
Note:

    This routine also may need to be called at raised IRQL
    when returning from hibernation.

--*/
{
    ULONG               Usb = 0;
    USHORT              cmd;
    PCI_COMMON_CONFIG   PciHeader;

    if (ResetHostController) {
        
        //
        // Clear out the host controller legacy support register
        // prior to handing the USB to the USB driver, because we
        // don't want any SMIs being generated.
        //

        Usb = 0x0000;

        HalSetBusDataByOffset (
            PCIConfiguration,
            BusNumber,
            SlotNumber.u.AsULONG,
            &Usb,
            0xc0,
            sizeof(ULONG)
            );

        //
        // Put the USB controller into reset, as it may share it's
        // PIRQD line with another USB controller on the chipset. 
        // This is not a problem unless the bios is running in legacy
        // mode and causing interrupts. In this case, the minute PIRQD
        // gets flipped by one usbuhci controller, the other could 
        // start generating unhandled interrupts and hang the system.
        // This is the case with the ICH2 chipset.
        //

        HalGetBusData (
            PCIConfiguration,
            BusNumber,
            SlotNumber.u.AsULONG,
            &PciHeader,
            PCI_COMMON_HDR_LENGTH
            );

        if (PciHeader.Command & PCI_ENABLE_IO_SPACE) {

            //
            // The controller is enabled.
            //

            Usb = (PciHeader.u.type0.BaseAddresses[4] & PCI_ADDRESS_IO_ADDRESS_MASK);

            if (Usb != 0 && Usb < 0x0000ffff) {

                // Valid I/O address. 

                //
                // If we are returning from suspend, don't put the controller 
                // into reset.
                //
                cmd = READ_PORT_USHORT(UlongToPtr(Usb));

                if (!(cmd & 0x0008)) {
                    //
                    // Put the controller in reset. Usbuhci will take it out of reset
                    // when it grabs it.
                    //
    
                    cmd = 0x0004;
    
                    WRITE_PORT_USHORT(UlongToPtr(Usb), cmd);
 
                    //
                    // Wait 10ms and then take the controller out of reset.
                    //

                    KeStallExecutionProcessor(10000);
 
                    cmd &= 0x0000;
    
                    WRITE_PORT_USHORT(UlongToPtr(Usb), cmd);
                 }
            }
        }
    } else {

        //
        // Shut off the interrupt for the USB controller, as it
        // is very frequently the reason that the machine freezes
        // during boot.  Anding the register with ~0xbf00 clears bit
        // 13, PIRQ Enable, which is the whole point.  The rest of
        // the bits just avoid writing registers that are "write
        // one to clear."
        //

        HalGetBusDataByOffset (
            PCIConfiguration,
            BusNumber,
            SlotNumber.u.AsULONG,
            &Usb,
            0xc0,
            sizeof(ULONG)
            );

        Usb &= ~0xbf00;

        HalSetBusDataByOffset (
            PCIConfiguration,
            BusNumber,
            SlotNumber.u.AsULONG,
            &Usb,
            0xc0,
            sizeof(ULONG)
            );
    
    }
}

VOID
HalpWhackICHUsbSmi(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber
    )
{
    ULONG   PmBase = 0;
    ULONG   SmiEn;

    //
    // ICH (and the like) have the PM_BASE register in
    // config space at offset 0x40.
    //
    
    HalGetBusDataByOffset (
        PCIConfiguration,
        BusNumber,
        SlotNumber.u.AsULONG,
        &PmBase,
        0x40,
        4);

    if (!PmBase) {
        return;
    }

    PmBase &= ~PCI_ADDRESS_IO_SPACE;

    //
    // At PM_BASE + 0x30 in I/O space, we have the SMI_EN
    // register.
    //

    SmiEn = READ_PORT_ULONG((PULONG)(((PUCHAR)PmBase) + 0x30));

    //
    // Clear bit 3, LEGACY_USB_EN.
    //

    SmiEn &= ~8;
    WRITE_PORT_ULONG((PULONG)(((PUCHAR)PmBase) + 0x30), SmiEn);

    return;
}

VOID
HalpSetAcpiIrqHack(
    ULONG   Value
    )
/*++

Routine Description:

    This routine sets the registry key that causes the
    ACPI driver to attempt to put all PCI interrupts
    on a single IRQ.  While putting this hack here may
    seem strange, the hack has to be applied before
    an INFs are processed.  And so much of the chip
    recognizing code already exists here, duplicating
    it in the ACPI driver would bloat the code and cause
    us to do another PCI bus scan and registry search
    during boot.

Arguments:

    Value   - This goes in the ACPI\Parameters\IRQDistribution
              key.
        
--*/
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    NTSTATUS            status;

    PAGED_CODE();

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Services\\ACPI\\Parameters");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey (&BaseHandle,
                          KEY_WRITE,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_NON_VOLATILE,
                          NULL);

    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString (&UnicodeString,
                          L"IRQDistribution");

    status = ZwSetValueKey (BaseHandle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &Value,
                            sizeof(ULONG));

    ASSERT(NT_SUCCESS(status));
    ZwClose(BaseHandle);
    return;
}

VOID
HalpClearSlpSmiStsInICH(
    VOID
    )
{
    PPCI_COMMON_CONFIG   PciHeader;
    UCHAR   buffer[0x44] = {0};
    ULONG   PmBase;
    UCHAR   SmiSts, SmiEn;
    
    PciHeader = (PPCI_COMMON_CONFIG)&buffer;

    //
    // ASUS has a BIOS bug that will leave the
    // SLP_SMI_STS bit set even when the SLP_SMI_EN
    // bit is clear.  The BIOS will furthermore
    // shut the machine down on the next SMI when 
    // this occurs.
    //

    
    //
    // Check for ICH.
    //

    HalGetBusDataByOffset (
        PCIConfiguration,
        0,
        0x1f,
        PciHeader,
        0,
        0x44);

    if ((PciHeader->VendorID == 0x8086) &&
        (PciHeader->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
        (PciHeader->SubClass == PCI_SUBCLASS_BR_ISA)) {

        //
        // This is an ICH.  Offset 0x40 will have an I/O BAR
        // which is the PM_BASE register.
        //

        PmBase = *(PULONG)PciHeader->DeviceSpecific;
        PmBase &= ~PCI_ADDRESS_IO_SPACE;

        SmiEn = READ_PORT_UCHAR(((PUCHAR)PmBase) + 0x30);

        if (!(SmiEn & 0x10)) {

            //
            // The SLP_SMI_EN bit in the SMI_EN register was
            // clear.
            //

            SmiSts = READ_PORT_UCHAR(((PUCHAR)PmBase) + 0x34);

            if (SmiSts & 0x10) {

                //
                // But the SLP_SMI_STS bit was set, implying
                // that the ASUS BIOS is about to keel over.
                // Clear the bit.
                //

                WRITE_PORT_UCHAR(((PUCHAR)PmBase) + 0x34, 0x10);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fsrec\udfs_rec.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    udfs_rec.h

Abstract:

    This module contains the mini-file system recognizer for UDFS.

Author:

    Dan Lovinger (danlo) 13-Feb-1997

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

//
//  NOTE CAREFULLY: the canonical location for this information is in the UDFS
//      driver source.
//

//
//  Aligning this byte offset to a sector boundary by rounding up will
//  yield the starting offset of the Volume Recognition Area (2/8.3)
//

#define VRA_BOUNDARY_LOCATION (32767 + 1)

/***    ISO 13346 Part 2: Volume and Boot Block Recognition
 *
 *
 */


/***    vsd_generic - Generic Volume Structure Descriptor (2/9.1)
 *
 */

typedef struct  VSD_GENERIC {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_GENERIC, *PVSD_GENERIC;

//  VSD_LENGTH_... - vsd field lengths

#define VSD_LENGTH_IDENT        5       // Length of regid_Identifier (bytes)

//  VSD_IDENT_... - Values for vsd_generic_Ident

#define VSD_IDENT_BEA01     "BEA01"     // Begin Extended Area
#define VSD_IDENT_TEA01     "TEA01"     // Terminate Extended Area
#define VSD_IDENT_CDROM     "CDROM"     // High Sierra Group (pre-ISO 9660)
#define VSD_IDENT_CD001     "CD001"     // ISO 9660
#define VSD_IDENT_CDW01     "CDW01"     // ECMA 168
#define VSD_IDENT_CDW02     "CDW02"     // ISO 13490
#define VSD_IDENT_NSR01     "NSR01"     // ECMA 167
#define VSD_IDENT_NSR02     "NSR02"     // ISO 13346
#define VSD_IDENT_BOOT2     "BOOT2"     // Boot Descriptor
#define VSD_IDENT_NSR03     "NSR03"     // ECMA 167 3rd Edition

typedef enum _VSD_IDENT {
    VsdIdentBad = 0,
    VsdIdentBEA01,
    VsdIdentTEA01,
    VsdIdentCDROM,
    VsdIdentCD001,
    VsdIdentCDW01,
    VsdIdentCDW02,
    VsdIdentNSR01,
    VsdIdentNSR02,
    VsdIdentBOOT2,
    VsdIdentNSR03
} VSD_IDENT, *PVSD_IDENT;

//
//  Following structure is used to build up static data for parse tables
//

typedef struct _PARSE_KEYVALUE {
    PCHAR Key;
    ULONG Value;
} PARSE_KEYVALUE, *PPARSE_KEYVALUE;

//
// Define the functions provided by this driver.
//

BOOLEAN
IsUdfsVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize
    );

ULONG
UdfsFindInParseTable (
    IN PPARSE_KEYVALUE ParseTable,
    IN PCHAR Id,
    IN ULONG MaxIdLen
    );

#define SectorAlignN(SECTORSIZE, L) (                                           \
    ((((ULONG)(L)) + ((SECTORSIZE) - 1)) & ~((SECTORSIZE) - 1))                 \
)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\bushnd.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    bushnd.c

Abstract:

    Functions which take either BusType-BusNumber or ConfigType-BusNumberm
    and route to a the appropiate registered handler.

Author:

    Ken Reneris (kenr) July-28-1994

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"


typedef struct _ARRAY {
    ULONG           ArraySize;
    PVOID           Element[];      // must be last field
} ARRAY, *PARRAY;

#define ARRAY_SIZE_IN_BYTES(a)  ( (a + 1) * sizeof(PARRAY) +        \
                                  FIELD_OFFSET(ARRAY, Element) )

typedef struct _HAL_BUS_HANDLER {
    LIST_ENTRY      AllHandlers;
    ULONG           ReferenceCount;
    BUS_HANDLER     Handler;
} HAL_BUS_HANDLER, *PHAL_BUS_HANDLER;

//
// Event to serialize with adding new buses
//

KEVENT      HalpBusDatabaseEvent;

//
// Lock to serialize routing functions from accessing handler arrays while
// new buses are added
//

KSPIN_LOCK  HalpBusDatabaseSpinLock;

//
// HalpBusTable - pointers to BusHandlers mapped by InterfaceType,BusNumber
//

PARRAY      HalpBusTable;

//
// HalpConfigTable - pointers to BusHandlers mapped by ConfigType,BusNumber
//

PARRAY      HalpConfigTable;

//
// List of all installed bus handlers
//

LIST_ENTRY  HalpAllBusHandlers;

//
// Lock is high_level since some routed functions can occurs at ISR time
//

#define LockBusDatabase(oldirql)                    \
    KeRaiseIrql(HIGH_LEVEL, oldirql);               \
    KiAcquireSpinLock(&HalpBusDatabaseSpinLock);

#define UnlockBusDatabase(oldirql)                  \
    KiReleaseSpinLock(&HalpBusDatabaseSpinLock);    \
    KeLowerIrql(oldirql);


#ifdef _PNP_POWER_
extern HAL_CALLBACKS    HalCallback;
#endif

//
// Internal prototypes
//

PARRAY
HalpAllocateArray (
    IN ULONG    Type
    );

VOID
HalpGrowArray (
    IN PARRAY   *CurrentArray,
    IN PARRAY   *NewArray
    );

NTSTATUS
HalpQueryInstalledBusInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    );

ULONG
HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpNoAdjustResourceList (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

NTSTATUS
HalpNoAssignSlotResources (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

NTSTATUS
HalpNoQueryBusSlots (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

PDEVICE_HANDLER_OBJECT
HalpNoReferenceDeviceHandler (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN ULONG                SlotNumber
    );

ULONG
HalpNoGetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

ULONG
HalpNoSetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

BOOLEAN
HaliTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

BOOLEAN
HaliFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitBusHandler)
#pragma alloc_text(PAGELK,HaliRegisterBusHandler)
#pragma alloc_text(PAGELK,HalpAllocateArray)
#pragma alloc_text(PAGELK,HalpGrowArray)
#pragma alloc_text(PAGE,HalAdjustResourceList)
#pragma alloc_text(PAGE,HalAssignSlotResources)
#pragma alloc_text(PAGE,HalpAssignSlotResources)
#pragma alloc_text(PAGE,HalGetInterruptVector)
#pragma alloc_text(PAGE,HalpNoAdjustResourceList)
#pragma alloc_text(PAGE,HalpNoAssignSlotResources)
#pragma alloc_text(PAGE,HalpNoQueryBusSlots)
#pragma alloc_text(PAGE,HalpNoReferenceDeviceHandler)
//#pragma alloc_text(PAGE,HaliQueryBusSlots)
#pragma alloc_text(PAGE,HalpQueryInstalledBusInformation)

#ifdef _PNP_POWER_
#pragma alloc_text(PAGELK,HaliSuspendHibernateSystem)
#endif

#endif

VOID
HalpInitBusHandler (
    VOID
    )
/*++

Routine Description:

    Initializes global BusHandler data

--*/
{
    //
    // Initialize bus handler spinlock used to synchronize against
    // buses additions while array lookups are done
    //

    KeInitializeSpinLock (&HalpBusDatabaseSpinLock);

    //
    // Initialize bus handler synchronzation event used to serialize
    // bus additions from < DPC_LVEL
    //

    KeInitializeEvent (&HalpBusDatabaseEvent, SynchronizationEvent, TRUE);

    //
    // Initialize global arrays
    //

    HalpBusTable    = HalpAllocateArray (0);
    HalpConfigTable = HalpAllocateArray (0);
    InitializeListHead (&HalpAllBusHandlers);

    //
    // Fill in HAL API handlers
    //

    HalRegisterBusHandler = HaliRegisterBusHandler;
    HalHandlerForBus = HaliHandlerForBus;
    HalHandlerForConfigSpace = HaliHandlerForConfigSpace;
    //HalQueryBusSlots = HaliQueryBusSlots;
    HalReferenceHandlerForBus = HaliReferenceHandlerForBus;
    HalReferenceBusHandler = HaliReferenceBusHandler;
    HalDereferenceBusHandler = HaliDereferenceBusHandler;

    HALPDISPATCH->HalPciTranslateBusAddress = HaliTranslateBusAddress;
#if !defined(NO_LEGACY_DRIVERS)    
    HALPDISPATCH->HalPciAssignSlotResources = HalpAssignSlotResources;
#endif // NO_LEGACY_DRIVERS
    
    //
    // Supply the "Bus Handler" version of this routine only
    // if this HAL didn't already provide a different version.
    //

    if (!HALPDISPATCH->HalFindBusAddressTranslation) {
        HALPDISPATCH->HalFindBusAddressTranslation =
            HaliFindBusAddressTranslation;
    }
}

NTSTATUS
HaliRegisterBusHandler (
    IN INTERFACE_TYPE          InterfaceType,
    IN BUS_DATA_TYPE           ConfigType,
    IN ULONG                   BusNumber,
    IN INTERFACE_TYPE          ParentBusType,
    IN ULONG                   ParentBusNumber,
    IN ULONG                   SizeofBusExtensionData,
    IN PINSTALL_BUS_HANDLER    InstallBusHandler,
    OUT PBUS_HANDLER           *ReturnedBusHandler
    )
/*++

Routine Description:

    Adds a BusHandler for InterfaceType,BusNumber and for ConfigType,BusNumber.

    Bus specific or Configuration space specific APIs are routed to the
    bus or configuration specific handlers added by this routine.

Arguments:

    InterfaceType   - Identifies the bus type
                      InterfaceTypeUndefined if no interface type for this
                      handler.

    ConfigType      - Identifies the configuration space type
                      ConfigurationSpaceUndefined if no configuration space
                      type for this handler.

    BusNumber       - Identifies the instance of the bus & config space.
                      -1 if the next available bus number for this bus
                      should be used.

    ParentBusType   - If this bus is a child of a bus, then ParentBusType
    ParentBusNumber   and ParentBusNumber identifies that bus.
                      ParentBusType is -1 if no parent bus.

    SizeofBusExetensionData - Sizeof bus specific exentsion data required.

    InstallBusHandler - Function to call to get the bus specific handlers
                        added to the bus handler structure.

Return Value:

    success; otherwise error code of failure.

--*/
{
    PHAL_BUS_HANDLER    Bus, *pBusHandler, OldHandler;
    PBUS_HANDLER        ParentHandler;
    KIRQL               OldIrql;
    NTSTATUS            Status;
    PARRAY              InterfaceArray, InterfaceBusNumberArray;
    PARRAY              ConfigArray, ConfigBusNumberArray;
    PVOID               CodeLockHandle;

    //
    // Must add the handler to at least one table
    //

    ASSERT (InterfaceType != InterfaceTypeUndefined || ConfigType != ConfigurationSpaceUndefined);

    Status = STATUS_SUCCESS;
    OldHandler = NULL;

    //
    // Allocate storage for new bus handler structure
    //

    Bus = (PHAL_BUS_HANDLER)
            ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof (HAL_BUS_HANDLER) + SizeofBusExtensionData,
                HAL_POOL_TAG
                );

    if (!Bus) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Lock pagable code down
    //

    CodeLockHandle = MmLockPagableCodeSection (&HaliRegisterBusHandler);

    //
    // Synchronize adding new bus handlers
    //

    *ReturnedBusHandler = &Bus->Handler;

    KeWaitForSingleObject (
        &HalpBusDatabaseEvent,
        WrExecutive,
        KernelMode,
        FALSE,
        NULL
        );


    //
    // If BusNumber not defined, use next available number for this BusType
    //

    if (BusNumber == -1) {
        ASSERT (InterfaceType != InterfaceTypeUndefined);

        BusNumber = 0;
        while (HaliHandlerForBus (InterfaceType, BusNumber)) {
            BusNumber++;
        }
    }

    //
    // Allocate memory for each array in case any index needs to grow
    //

    InterfaceArray          = HalpAllocateArray (InterfaceType);
    InterfaceBusNumberArray = HalpAllocateArray (BusNumber);
    ConfigArray             = HalpAllocateArray (ConfigType);
    ConfigBusNumberArray    = HalpAllocateArray (BusNumber);

    if (!Bus                            ||
        !InterfaceArray                 ||
        !InterfaceBusNumberArray        ||
        !ConfigArray                    ||
        !ConfigBusNumberArray) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(Status)) {

        //
        // Lookup parent handler (if any)
        //

        ParentHandler = HaliReferenceHandlerForBus (ParentBusType, ParentBusNumber);

        //
        // Initialize new bus handlers values
        //

        RtlZeroMemory (Bus, sizeof (HAL_BUS_HANDLER) + SizeofBusExtensionData);

        Bus->ReferenceCount = 1;

        Bus->Handler.BusNumber           = BusNumber;
        Bus->Handler.InterfaceType       = InterfaceType;
        Bus->Handler.ConfigurationType   = ConfigType;
        Bus->Handler.ParentHandler       = ParentHandler;

        //
        // Set to dumby handlers
        //

        Bus->Handler.GetBusData           = HalpNoBusData;
        Bus->Handler.SetBusData           = HalpNoBusData;
        Bus->Handler.AdjustResourceList   = HalpNoAdjustResourceList;
        Bus->Handler.AssignSlotResources  = HalpNoAssignSlotResources;

        if (SizeofBusExtensionData) {
            Bus->Handler.BusData = Bus + 1;
        }

        //
        // If bus has a parent, inherit handlers from parent as default
        //

        if (ParentHandler) {
            Bus->Handler.GetBusData           = ParentHandler->GetBusData;
            Bus->Handler.SetBusData           = ParentHandler->SetBusData;
            Bus->Handler.AdjustResourceList   = ParentHandler->AdjustResourceList;
            Bus->Handler.AssignSlotResources  = ParentHandler->AssignSlotResources;
            Bus->Handler.TranslateBusAddress  = ParentHandler->TranslateBusAddress;
            Bus->Handler.GetInterruptVector   = ParentHandler->GetInterruptVector;
        }

        //
        // Install bus specific handlers
        //

        if (InstallBusHandler) {
            Status = InstallBusHandler (&Bus->Handler);
        }

        if (NT_SUCCESS(Status)) {

            //
            // Might change addresses of some arrays synchronize
            // with routing handlers
            //

            LockBusDatabase (&OldIrql);

            //
            // Grow HalpBusTable if needed
            //

            HalpGrowArray (&HalpBusTable, &InterfaceArray);

            if (InterfaceType != InterfaceTypeUndefined) {

                //
                // Grow HalpBusTable if needed
                //

                HalpGrowArray (
                    (PARRAY *) &HalpBusTable->Element[InterfaceType],
                    &InterfaceBusNumberArray
                    );


                //
                // Get registered handler for InterfaceType,BusNumber
                //

                pBusHandler = &((PHAL_BUS_HANDLER)
                    ((PARRAY) HalpBusTable->Element[InterfaceType])->Element[BusNumber]);

                //
                // If handler already defiend, remove the old one
                //

                if (*pBusHandler) {
                    OldHandler = *pBusHandler;
                }

                //
                // Set new handler for supplied InterfaceType,BusNumber
                //

                *pBusHandler = Bus;
            }

            //
            // Grow HalpConfigTable if needed
            //

            HalpGrowArray (&HalpConfigTable, &ConfigArray);

            if (ConfigType != ConfigurationSpaceUndefined) {

                //
                // Grow HalpConfigTable if needed
                //

                HalpGrowArray (
                    (PARRAY *) &HalpConfigTable->Element[ConfigType],
                    &ConfigBusNumberArray
                    );

                //
                // Get registered handler for ConfigType,BusNumber
                //

                pBusHandler = &((PHAL_BUS_HANDLER)
                    ((PARRAY) HalpConfigTable->Element[ConfigType])->Element[BusNumber]);

                if (*pBusHandler) {
                    ASSERT (OldHandler == NULL ||  OldHandler == *pBusHandler);
                    OldHandler = *pBusHandler;
                }

                //
                // Set new handler for supplied ConfigType,BusNumber
                //

                *pBusHandler = Bus;
            }

            //
            // Add new bus handler to list of all installed handlers
            //

            InsertTailList (&HalpAllBusHandlers, &Bus->AllHandlers);

            //
            // Remove old bus handler
            //

            Bus = OldHandler;
            if (Bus) {
                RemoveEntryList (&Bus->AllHandlers);
            }

            //
            // Lookup array modification complete, release lock
            //

            UnlockBusDatabase (OldIrql);
        } else {
            if (ParentHandler) {
                HaliDereferenceBusHandler (ParentHandler);
            }
        }
    }

    //
    // Bus addition modifications complete, set event
    //

    KeSetEvent (&HalpBusDatabaseEvent, 0, FALSE);

    //
    // Unlock pagable code
    //

    MmUnlockPagableImageSection (CodeLockHandle);

    //
    // Free memory which is not in use
    //

    if (Bus) {
        ExFreePool (Bus);
    }

    if (InterfaceArray) {
        ExFreePool (InterfaceArray);
    }

    if (InterfaceBusNumberArray) {
        ExFreePool (InterfaceBusNumberArray);
    }

    if (ConfigArray) {
        ExFreePool (ConfigArray);
    }

    if (ConfigBusNumberArray) {
        ExFreePool (ConfigBusNumberArray);
    }

    return Status;
}

PARRAY
HalpAllocateArray (
    IN ULONG    ArraySize
    )
/*++

Routine Description:

    Allocate an array of size ArraySize.

Arguments:

    ArraySize   - Size of array in elements

Return Value:

    pointer to ARRAY

--*/
{
    PARRAY  Array;

    if (ArraySize == -1) {
        ArraySize = 0;
    }

    Array = ExAllocatePoolWithTag (
                NonPagedPool,
                ARRAY_SIZE_IN_BYTES(ArraySize),
                HAL_POOL_TAG
                );
    if (!Array) {

        //
        // This allocation was critical.
        //

        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     ARRAY_SIZE_IN_BYTES(ArraySize),
                     0,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    //
    // Initialize array
    //

    Array->ArraySize = ArraySize;
    RtlZeroMemory (Array->Element, sizeof(PVOID) * (ArraySize+1));
    return Array;
}

VOID
HalpGrowArray (
    IN PARRAY   *CurrentArray,
    IN PARRAY   *NewArray
    )
/*++

Routine Description:

    If NewArray is larger then CurrentArray, then the CurrentArray
    is grown to the sizeof NewArray by swapping the pointers and
    moving the arrays contents.

Arguments:

    CurrentArray - Address of the current array pointer
    NewArray     - Address of the new array pointer

--*/
{
    PVOID       Tmp;

    if (!*CurrentArray || (*NewArray)->ArraySize > (*CurrentArray)->ArraySize) {

        //
        // Copy current array ontop of new array
        //

        if (*CurrentArray) {
            RtlCopyMemory (&(*NewArray)->Element,
                           &(*CurrentArray)->Element,
                           sizeof(PVOID) * ((*CurrentArray)->ArraySize + 1)
                           );
        }


        //
        // swap current with new such that the new array is the current
        // one, and the old memory will be freed back to pool
        //

        Tmp = *CurrentArray;
        *CurrentArray = *NewArray;
        *NewArray = Tmp;
    }
}

PBUS_HANDLER
FASTCALL
HalpLookupHandler (
    IN PARRAY   Array,
    IN ULONG    Type,
    IN ULONG    Number,
    IN BOOLEAN  AddReference
    )
{
    PHAL_BUS_HANDLER    Bus;
    PBUS_HANDLER        Handler;
    KIRQL               OldIrql;

    LockBusDatabase (&OldIrql);

    //
    // Index by type
    //

    Handler = NULL;
    if (Array->ArraySize >= Type) {
        Array = (PARRAY) Array->Element[Type];

        //
        // Index by instance numberr
        //

        if (Array && Array->ArraySize >= Number) {
            Bus = (PHAL_BUS_HANDLER) Array->Element[Number];
            Handler = &Bus->Handler;

            if (AddReference) {
                Bus->ReferenceCount += 1;
            }
        }
    }

    UnlockBusDatabase (OldIrql);
    return Handler;
}

VOID
FASTCALL
HaliReferenceBusHandler (
    IN PBUS_HANDLER   Handler
    )
/*++

Routine Description:


--*/
{
    KIRQL               OldIrql;
    PHAL_BUS_HANDLER    Bus;


    LockBusDatabase (&OldIrql);

    Bus = CONTAINING_RECORD(Handler, HAL_BUS_HANDLER, Handler);
    Bus->ReferenceCount += 1;

    UnlockBusDatabase (OldIrql);
}

VOID
FASTCALL
HaliDereferenceBusHandler (
    IN PBUS_HANDLER   Handler
    )
/*++

Routine Description:


--*/
{
    KIRQL               OldIrql;
    PHAL_BUS_HANDLER    Bus;


    LockBusDatabase (&OldIrql);

    Bus = CONTAINING_RECORD(Handler, HAL_BUS_HANDLER, Handler);
    Bus->ReferenceCount -= 1;

    UnlockBusDatabase (OldIrql);

    // for now totally removing a bus is not supported
    ASSERT (Bus->ReferenceCount != 0);
}


PBUS_HANDLER
FASTCALL
HaliHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    )
/*++

Routine Description:

    Returns the BusHandler structure InterfaceType,BusNumber
    or NULL if no such handler exists.

--*/
{
    return HalpLookupHandler (HalpBusTable, (ULONG) InterfaceType, BusNumber, FALSE);
}

PBUS_HANDLER
FASTCALL
HaliHandlerForConfigSpace (
    IN BUS_DATA_TYPE  ConfigType,
    IN ULONG          BusNumber
    )
/*++

Routine Description:

    Returns the BusHandler structure ConfigType,BusNumber
    or NULL if no such handler exists.

--*/
{
    return HalpLookupHandler (HalpConfigTable, (ULONG) ConfigType, BusNumber, FALSE);
}


PBUS_HANDLER
FASTCALL
HaliReferenceHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    )
/*++

Routine Description:

    Returns the BusHandler structure InterfaceType,BusNumber
    or NULL if no such handler exists.

--*/
{
    return HalpLookupHandler (HalpBusTable, (ULONG) InterfaceType, BusNumber, TRUE);
}

PBUS_HANDLER
FASTCALL
HaliReferenceHandlerForConfigSpace (
    IN BUS_DATA_TYPE  ConfigType,
    IN ULONG          BusNumber
    )
/*++

Routine Description:

    Returns the BusHandler structure ConfigType,BusNumber
    or NULL if no such handler exists.

--*/
{
    return HalpLookupHandler (HalpConfigTable, (ULONG) ConfigType, BusNumber, TRUE);
}

NTSTATUS
HalpQueryInstalledBusInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    )
/*++

Routine Description:

    Returns an array HAL_BUS_INFORMATION, one for each
    bus handler installed.

Arguments:

    Buffer - output buffer
    BufferLength - length of buffer on input
    ReturnedLength - The length of data returned

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL - The ReturnedLength contains the buffersize
        currently needed.

--*/
{
    PHAL_BUS_INFORMATION    Info;
    PHAL_BUS_HANDLER        Handler;
    ULONG                   i, j;
    ULONG                   Length;
    NTSTATUS                Status;
    PARRAY                  Array;

    PAGED_CODE ();

    //
    // Synchronize adding new bus handlers
    //

    KeWaitForSingleObject (
        &HalpBusDatabaseEvent,
        WrExecutive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // Determine sizeof return buffer
    //

    Length = 0;
    for (i=0; i <= HalpBusTable->ArraySize; i++) {
        Array = (PARRAY) HalpBusTable->Element[i];
        if (Array) {
            Length += sizeof (HAL_BUS_INFORMATION) *
                      (Array->ArraySize + 1);
        }
    }

    //
    // Return size of buffer returning, or size of buffer needed
    //

    *ReturnedLength = Length;

    //
    // Fill in the return buffer
    //

    if (Length <= BufferLength) {

        Info = (PHAL_BUS_INFORMATION) Buffer;

        for (i=0; i <= HalpBusTable->ArraySize; i++) {
            Array = (PARRAY) HalpBusTable->Element[i];
            if (Array) {
                for (j=0; j <= Array->ArraySize; j++) {
                    Handler = (PHAL_BUS_HANDLER) Array->Element[j];

                    if (Handler) {
                        Info->BusType = Handler->Handler.InterfaceType;
                        Info->ConfigurationType = Handler->Handler.ConfigurationType;
                        Info->BusNumber = Handler->Handler.BusNumber;
                        Info->Reserved = 0;
                        Info += 1;
                    }
                }
            }
        }

        Status = STATUS_SUCCESS;

    } else {

        //
        // Return buffer too small
        //

        Status = STATUS_BUFFER_TOO_SMALL;
    }

    KeSetEvent (&HalpBusDatabaseEvent, 0, FALSE);
    return Status;
}

//
// Default dispatchers to BusHandlers
//

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    PBUS_HANDLER Handler;
    NTSTATUS     Status;

    Handler = HaliReferenceHandlerForConfigSpace (BusDataType, BusNumber);
    if (!Handler) {
        return 0;
    }

    Status = Handler->GetBusData (Handler, Handler, SlotNumber, Buffer, Offset, Length);
    HaliDereferenceBusHandler (Handler);
    return Status;
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    PBUS_HANDLER Handler;
    NTSTATUS     Status;

    Handler = HaliReferenceHandlerForConfigSpace (BusDataType, BusNumber);
    if (!Handler) {
        return 0;
    }

    Status = Handler->SetBusData (Handler, Handler, SlotNumber, Buffer, Offset, Length);
    HaliDereferenceBusHandler (Handler);
    return Status;
}

#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++

Routine Description:

    Dispatcher for AdjustResourceList

--*/
{
    PBUS_HANDLER Handler;
    NTSTATUS     Status;

    PAGED_CODE ();
    Handler = HaliReferenceHandlerForBus (
                (*pResourceList)->InterfaceType,
                (*pResourceList)->BusNumber
              );
    if (!Handler) {
        return STATUS_SUCCESS;
    }

    Status = Handler->AdjustResourceList (Handler, Handler, pResourceList);
    HaliDereferenceBusHandler (Handler);
    return Status;
}


NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
{
    PAGED_CODE ();
    if (BusType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part
        // of transitioning the HAL out of the bus
        // management business.
        //
        return HALPDISPATCH->HalPciAssignSlotResources(RegistryPath,
                                                       DriverClassName,
                                                       DriverObject,
                                                       DeviceObject,
                                                       BusType,
                                                       BusNumber,
                                                       SlotNumber,
                                                       AllocatedResources);
    } else {

        return HalpAssignSlotResources(RegistryPath,
                                       DriverClassName,
                                       DriverObject,
                                       DeviceObject,
                                       BusType,
                                       BusNumber,
                                       SlotNumber,
                                       AllocatedResources);
    }
}

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    PBUS_HANDLER Handler;
    NTSTATUS     Status;

    PAGED_CODE ();
    Handler = HaliReferenceHandlerForBus (BusType, BusNumber);
    if (!Handler) {
        return STATUS_NOT_FOUND;
    }

    Status = Handler->AssignSlotResources (
                Handler,
                Handler,
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                SlotNumber,
                AllocatedResources
            );

    HaliDereferenceBusHandler (Handler);
    return Status;
}


ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    Dispatcher for GetInterruptVector

--*/
{
    PBUS_HANDLER Handler;
    ULONG        Vector;

    PAGED_CODE ();
    Handler = HaliReferenceHandlerForBus (InterfaceType, BusNumber);
    *Irql = 0;
    *Affinity = 0;

    if (!Handler) {
        return 0;
    }

    Vector = Handler->GetInterruptVector (Handler, Handler,
              BusInterruptLevel, BusInterruptVector, Irql, Affinity);

    HaliDereferenceBusHandler (Handler);
    return Vector;
}
#endif // NO_LEGACY_DRIVERS


BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
{
    if (InterfaceType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part
        // of transitioning the HAL out of the bus
        // management business.
        //
        return HALPDISPATCH->HalPciTranslateBusAddress(InterfaceType,
                                                       BusNumber,
                                                       BusAddress,
                                                       AddressSpace,
                                                       TranslatedAddress);
    } else {
        return HaliTranslateBusAddress(InterfaceType,
                                       BusNumber,
                                       BusAddress,
                                       AddressSpace,
                                       TranslatedAddress);
    }
}

BOOLEAN
HaliTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    Dispatcher for TranslateBusAddress

--*/
{
    PBUS_HANDLER Handler;
    BOOLEAN      Status;

    Handler = HaliReferenceHandlerForBus (InterfaceType, BusNumber);
    if (!Handler || !Handler->TranslateBusAddress) {
        return FALSE;
    }

    Status = Handler->TranslateBusAddress (Handler, Handler,
              BusAddress, AddressSpace, TranslatedAddress);

    HaliDereferenceBusHandler (Handler);
    return Status;
}

//
// Null handlers
//

ULONG HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Stub handler for buses which do not have a configuration space

--*/
{
    return 0;
}

NTSTATUS
HalpNoAdjustResourceList (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++

Routine Description:

    Stub handler for buses which do not have a configuration space

--*/
{
    PAGED_CODE ();
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
HalpNoAssignSlotResources (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Stub handler for buses which do not have a configuration space

--*/
{
    PAGED_CODE ();
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
HalpNoQueryBusSlots (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    )
{
    PAGED_CODE ();
    return STATUS_NOT_SUPPORTED;
}

PDEVICE_HANDLER_OBJECT
HalpNoReferenceDeviceHandler (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN ULONG                SlotNumber
    )
{
    PAGED_CODE ();
    return NULL;
}

ULONG
HalpNoGetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    return 0;
}

ULONG
HalpNoSetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    return 0;
}

PBUS_HANDLER
HalpContextToBusHandler(
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    Convert a context into a pointer to a bus handler.   Not really
    a big deal as the context IS a pointer to a bus handler,... or
    possibly null in which case we want the first bus handler.

    For the sake of paranoia, we run down the list of bus handlers
    to find a match for the incoming context.  This is because context
    is supplied by something outside the HAL.

Arguments:

    Context             ULONG_PTR either NULL or a value from which
                        a pointer to a bus handler can be derived.

Return Value:

    Pointer to a bus handler or NULL if the incoming context was not
    valid.

--*/

{
    PLIST_ENTRY OldHalBusHandler;
    PLIST_ENTRY NewHalBusHandler;

    NewHalBusHandler = HalpAllBusHandlers.Flink;

    if (Context) {

        //
        // Caller supplied a handler, convert to a HAL_BUS_HANDLER.
        //

        OldHalBusHandler = &CONTAINING_RECORD((PBUS_HANDLER)Context,
                                              HAL_BUS_HANDLER,
                                              Handler)->AllHandlers;

        while (NewHalBusHandler != &HalpAllBusHandlers) {

            if (NewHalBusHandler == OldHalBusHandler) {

                //
                // Match.
                //

                break;
            }
            NewHalBusHandler = NewHalBusHandler->Flink;
        }
    }

    if (NewHalBusHandler == &HalpAllBusHandlers) {

        //
        // If at end of list, either the incoming value wasn't
        // on the list or this list is empty.
        //

#if DBG

        DbgPrint("HAL: HalpContextToBusHandler, invalid context.\n");

#endif

        return NULL;
    }

    return &CONTAINING_RECORD(NewHalBusHandler,
                              HAL_BUS_HANDLER,
                              AllHandlers)->Handler;

}
#if 0 // PLJ
PBUS_HANDLER
HalpGetNextBusHandler(
    IN PBUS_HANDLER Previous
    )
{
    PLIST_ENTRY OldHalBusHandler;
    PLIST_ENTRY NewHalBusHandler;
    PBUS_HANDLER Next;

    NewHalBusHandler = HalpAllBusHandlers.Flink;

    if (Previous != NULL) {

        //
        // Caller supplied a handler, convert to a HAL_BUS_HANDLER.
        //

        OldHalBusHandler = &CONTAINING_RECORD(Previous,
                                              HAL_BUS_HANDLER,
                                              Handler)->AllHandlers;

        //
        // Paranoia (should probably be DBG only but there isn't
        // that many handlers and we don't do this all that often.
        //

        {
            PLIST_ENTRY ThisIteration = NULL;

            while (NewHalBusHandler != &HalpAllBusHandlers) {

                ThisIteration = NewHalBusHandler;
                NewHalBusHandler = NewHalBusHandler->Flink;

                if (ThisIteration == OldHalBusHandler) {

                    //
                    // Match.
                    //

                    break;
                }
            }

            //
            // If at end of list, either the incoming value wasn't
            // on the list it was the last thing on the list, either
            // way, there is no next entry.
            //

#if DBG

            if (ThisIteration != OldHalBusHandler) {
                DbgPrint("HAL: HalpGetNextBusHandler, previous handler invalid.\n");
            }

#endif

        }
    }

    if (NewHalBusHandler == &HalpAllBusHandlers) {
        return NULL;
    }

    return &CONTAINING_RECORD(NewHalBusHandler,
                              HAL_BUS_HANDLER,
                              AllHandlers)->Handler;
}
#endif

BOOLEAN
HaliFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    )

/*++

Routine Description:

    This routine performs a very similar function to HalTranslateBusAddress
    except that InterfaceType and BusNumber are not known by the caller.
    This function will walk all busses known by the HAL looking for a
    valid translation for the input BusAddress of type AddressSpace.

    This function is recallable using the input/output Context parameter.
    On the first call to this routine for a given translation the ULONG_PTR
    Context should be NULL.  Note:  Not the address of it but the contents.

    If the caller decides the returned translation is not the desired
    translation, it calls this routine again passing Context in as it
    was returned on the previous call.  This allows this routine to
    traverse the bus structures until the correct translation is found
    and is provided because on multiple bus systems, it is possible for
    the same resource to exist in the independent address spaces of
    multiple busses.

    Note:  This routine is not called directly, it is called through
    the HALPDISPATCH table.  If a HAL implements a simpler version of
    this function (eg generic PC/AT boxes don't actually need translation,
    those HALs substitute their own version of this routine.   This
    routine is not otherwise exported from the HAL.

Arguments:

    BusAddress          Address to be translated.
    AddressSpace        0 = Memory
                        1 = IO (There are other possibilities).
                        N.B. This argument is a pointer, the value
                        will be modified if the translated address
                        is of a different address space type from
                        the untranslated bus address.
    TranslatedAddress   Pointer to where the translated address
                        should be stored.
    Context             Pointer to a ULONG_PTR. On the initial call,
                        for a given BusAddress, it should contain
                        0.  It will be modified by this routine,
                        on subsequent calls for the same BusAddress
                        the value should be handed in again,
                        unmodified by the caller.
    NextBus             FALSE if we should attempt this translation
                        on the same bus as indicated by Context,
                        TRUE if we should be looking for another
                        bus.

Return Value:

    TRUE    if translation was successful,
    FALSE   otherwise.

--*/

{
    PLIST_ENTRY HalBusHandler;
    PBUS_HANDLER Handler;

    //
    // First, make sure the context parameter was supplied. (paranoia).
    //

    if (!Context) {
        ASSERT(Context);
        return FALSE;
    }

    ASSERT(*Context || (NextBus == TRUE));

    //
    // Note: The Context is really a PBUS_HANDLER, but,
    // HalpContextToBusHandler is paranoid. If the incoming
    // Context isn't what we expect, we won't use it as a
    // pointer.
    //

    Handler = HalpContextToBusHandler(*Context);

    if (!Handler) {
        ASSERT(Handler);
        return FALSE;
    }

    if (NextBus == FALSE) {

        //
        // Attempt translation on THIS bus (and ONLY this bus).
        //

        ASSERT(Handler == (PBUS_HANDLER)*Context);

        if (HalTranslateBusAddress(
                Handler->InterfaceType,
                Handler->BusNumber,
                BusAddress,
                AddressSpace,
                TranslatedAddress)) {
            *Context = (ULONG_PTR)Handler;
            return TRUE;
        }

        return FALSE;
    }

    HalBusHandler = &CONTAINING_RECORD(Handler,
                                       HAL_BUS_HANDLER,
                                       Handler)->AllHandlers;
    //
    // Handler is either the bus that came in in Context or the
    // first bus if *Context was null.   If *Context wasn't NULL,
    // we want the next bus.
    //

    if (*Context) {
        HalBusHandler = HalBusHandler->Flink;
    }

    //
    // Examine each remaining bus looking for one that will translate
    // this address.
    //

    while (HalBusHandler != &HalpAllBusHandlers) {

        //
        // This is gross, having gone to all the trouble to find
        // the handler, it seems a pity to break it out into parameters
        // used to search for this handler.
        //
        // Use HalTranslateAddress to find out if this translation
        // works on this handler.
        //

        Handler = &CONTAINING_RECORD(HalBusHandler,
                                     HAL_BUS_HANDLER,
                                     AllHandlers)->Handler;

        if (HalTranslateBusAddress(
                Handler->InterfaceType,
                Handler->BusNumber,
                BusAddress,
                AddressSpace,
                TranslatedAddress)) {
            *Context = (ULONG_PTR)Handler;
            return TRUE;
        }

        //
        // Try next handler.
        //

        HalBusHandler = HalBusHandler->Flink;
    }

    //
    // Didn't find another handler this translation works with.  Set
    // the Context such that we don't do the scan again (unless the
    // caller resets it) and indicate failure.
    //

    *Context = 1;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\acpidtct.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\acpidtct.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\hals.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

!ENDIF

!if defined(BUILD_CHECKED_KERNEL)
NTDEBUG=ntsd
FREEBUILD=0
!endif

# Always build MP hals for checked builds.

!if !$(FREEBUILD)
NT_UP=0
!endif

VC7_SYMBOLS=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\chiphacks.c ===
//
// This file simply includes the common sources from the current HAL
// directory.
//

#include "..\chiphacks.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\cmosopregion.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixcmos.c

Abstract:

    Implements CMOS op region interface functionality
    
Author:

    brian guarraci (t-briang) 07-14-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "exboosts.h"
#include "wchar.h"
#include "xxacpi.h"

#ifdef ACPI_CMOS_ACTIVATE

//
// prototypes for the 2 HalpGet/Set ixcmos.asm functions
//
ULONG
HalpGetCmosData(
    IN ULONG        SourceLocation,
    IN ULONG        SourceAddress,
    IN PUCHAR       DataBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpSetCmosData(
    IN ULONG        SourceLocation,
    IN ULONG        SourceAddress,
    IN PUCHAR       DataBuffer,
    IN ULONG        ByteCount
    );
   


ULONG 
HalpcGetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            SourceAddress,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    );

ULONG 
HalpcSetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            SourceAddress,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    );

ULONG
HalpReadCmosDataByPort(
    IN ULONG        AddrPort,
    IN ULONG        DataPort,
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteCmosDataByPort(
    IN ULONG        AddrPort,
    IN ULONG        DataPort,
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN ULONG    ReturnBuffer,
    IN PUCHAR   ByteCount
    );

ULONG
HalpWriteCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN ULONG    ReturnBuffer,
    IN PUCHAR   ByteCount
    );

ULONG
HalpReadStdCmosData(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteStdCmosData(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadRtcStdPCAT(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteRtcStdPCAT(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadRtcIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteRtcIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadExtCmosIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteExtCmosIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadRtcDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteRtcDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadExtCmosDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteExtCmosDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );


//
// at the time of this writing, the largest known cmos ram address is 0xff
// that is, for a given cmos ram bank, the largest address is 0xff
//                     
typedef enum {
    LARGEST_KNOWN_CMOS_RAM_ADDRESS = 0xff
} CMOS_RAM_ADDR_LIMITS;


//
// Additional information about Standard CMOS/RTC can be acquired at:
//
// "ISA System Architecture" Mindshare, Inc. (ISBN:0-201-40996-8) Chaper 21.
//
// To put the registers and the RTC region in context, the following 
// constants describe the layout of the registers (0x00 - 0x0d).  
// Registers A-D are control registers which affect the state of the rtc.  
//                            
typedef enum {
    CMOS_RAM_STDPCAT_SECONDS = 0,
    CMOS_RAM_STDPCAT_SECONDS_ALARM,
    CMOS_RAM_STDPCAT_MINUTES,
    CMOS_RAM_STDPCAT_MINUTES_ALARM,
    CMOS_RAM_STDPCAT_HOURS,
    CMOS_RAM_STDPCAT_HOURS_ALARM,
    CMOS_RAM_STDPCAT_DAY_OF_WEEK,
    CMOS_RAM_STDPCAT_DATE_OF_MONTH,
    CMOS_RAM_STDPCAT_MONTH,
    CMOS_RAM_STDPCAT_YEAR,
    CMOS_RAM_STDPCAT_REGISTER_A,
    CMOS_RAM_STDPCAT_REGISTER_B,
    CMOS_RAM_STDPCAT_REGISTER_C,
    CMOS_RAM_STDPCAT_REGISTER_D
} CMOS_RAM_STDPCAT_REGISTERS;

//
// definition of bits with in the control registers
//
typedef enum {

    //
    // (Update In Progress)
    // when the rtc is updating the rtc registers, this bit is set
    //
    //
    CMOS_RAM_STDPCAT_REGISTER_A_UIP_BIT = 0x80,

    //
    // this bit must be set when updating the rtc
    //
    CMOS_RAM_STDPCAT_REGISTER_B_SET_BIT = 0x80

} CMOS_RAM_STDPCAT_REGISTER_BITS;


//
// Additional information about the Intel PIIX4 cmos/rtc chip
// can be acquired at: 
//
// http://developer.intel.com/design/intarch/DATASHTS/29056201.pdf
//
// To put the registers and the RTC region in context, the following 
// constants describe the layout of the 
//
//  Intel PIIX4 CMOS ram
// 
// for the 0x00 - 0x0d registers.  Registers A-D are control registers
// which affect the state of the rtc.  
// 
//   
//                            
typedef enum {
    CMOS_RAM_PIIX4_SECONDS = 0,
    CMOS_RAM_PIIX4_SECONDS_ALARM,
    CMOS_RAM_PIIX4_MINUTES,
    CMOS_RAM_PIIX4_MINUTES_ALARM,
    CMOS_RAM_PIIX4_HOURS,
    CMOS_RAM_PIIX4_HOURS_ALARM,
    CMOS_RAM_PIIX4_DAY_OF_WEEK,
    CMOS_RAM_PIIX4_DATE_OF_MONTH,
    CMOS_RAM_PIIX4_MONTH,
    CMOS_RAM_PIIX4_YEAR,
    CMOS_RAM_PIIX4_REGISTER_A,
    CMOS_RAM_PIIX4_REGISTER_B,
    CMOS_RAM_PIIX4_REGISTER_C,
    CMOS_RAM_PIIX4_REGISTER_D
} CMOS_RAM_PIIX4_REGISTERS;

//
// definition of bits with in the control registers
//
typedef enum {

    //
    // (Update In Progress)
    // when the rtc is updating the rtc registers, this bit is set
    //
    //
    CMOS_RAM_PIIX4_REGISTER_A_UIP_BIT = 0x80,

    //
    // this bit must be set when updating the rtc
    //
    CMOS_RAM_PIIX4_REGISTER_B_SET_BIT = 0x80

} CMOS_RAM_PIIX4_REGISTER_BITS;


//
// Additional information about the Dallas 1501 cmos/rtc chip
// can be acquired at: 
//
// http://www.dalsemi.com/datasheets/pdfs/1501-11.pdf
//
// To put the registers and the RTC region in context, the following 
// constants describe the layout of the 
//
//  Dallas 1501 CMOS ram
// 
// for the 0x00 - 0x0d registers.  Registers A-D are control registers
// which affect the state of the rtc.  
// 
//   
//                            
typedef enum {
    CMOS_RAM_DAL1501_SECONDS = 0,
    CMOS_RAM_DAL1501_MINUTES,
    CMOS_RAM_DAL1501_HOURS,
    CMOS_RAM_DAL1501_DAY,
    CMOS_RAM_DAL1501_DATE,
    CMOS_RAM_DAL1501_MONTH,
    CMOS_RAM_DAL1501_YEAR,
    CMOS_RAM_DAL1501_CENTURY,
    CMOS_RAM_DAL1501_ALARM_SECONDS,
    CMOS_RAM_DAL1501_ALARM_MINUTES,
    CMOS_RAM_DAL1501_ALARM_HOURS,
    CMOS_RAM_DAL1501_ALARM_DAYDATE,
    CMOS_RAM_DAL1501_WATCHDOG0,
    CMOS_RAM_DAL1501_WATCHDOG1,
    CMOS_RAM_DAL1501_REGISTER_A,
    CMOS_RAM_DAL1501_REGISTER_B,
    CMOS_RAM_DAL1501_RAM_ADDR_LSB,  // 0x00 - 0xff
    CMOS_RAM_DAL1501_RESERVED0,
    CMOS_RAM_DAL1501_RESERVED1,
    CMOS_RAM_DAL1501_RAM_DATA       // 0x00 - 0xff
} CMOS_RAM_DAL1501_REGISTERS;

typedef enum {

    //
    // The TE bit controls the update status of the external
    // RTC registers.  When it is 0, the registers are frozen
    // with the last RTC values.  If you modifiy the registers
    // while TE = 0, then when TE is set, the modifications
    // will transfer to the internal registers, hence modifying 
    // the RTC state.  In general, when TE is set, the external
    // registers then reflect the current RTC state.
    //
    CMOS_RAM_DAL1501_REGISTER_B_TE_BIT = 0x80


} CMOS_RAM_DAL1501_REGISTER_BITS;


#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

typedef enum {
    CmosStdAddrPort = 0x70,
    CmosStdDataPort = 0x71
};

typedef enum {
    CMOS_READ,
    CMOS_WRITE
} CMOS_ACCESS_TYPE;

typedef 
ULONG 
(*PCMOS_RANGE_HANDLER) (
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

typedef struct {
    ULONG               start;
    ULONG               stop;
    PCMOS_RANGE_HANDLER readHandler;
    PCMOS_RANGE_HANDLER writeHandler;
} CMOS_ADDR_RANGE_HANDLER, *PCMOS_ADDR_RANGE_HANDLER;


//
// define the discrete ranges so that the appropriate
// handlers can be used for each.
//
// Note: address ranges are inclusive
//
CMOS_ADDR_RANGE_HANDLER CmosRangeHandlersStdPCAT[] =
{   
    //
    // The RTC region
    //
    {0,     0x9,    HalpReadRtcStdPCAT,     HalpWriteRtcStdPCAT},       


    //
    // The standard CMOS RAM region
    //
    {0x0a,  0x3f,   HalpReadStdCmosData,    HalpWriteStdCmosData},     

    //
    // end of table
    //
    {0,     0,      0}
};

CMOS_ADDR_RANGE_HANDLER CmosRangeHandlersIntelPIIX4[] =
{   
    //
    // The RTC region
    //
    {0,     0x9,    HalpReadRtcIntelPIIX4,      HalpWriteRtcIntelPIIX4},

    //
    // The standard CMOS RAM region
    //
    {0x0a,  0x7f,   HalpReadStdCmosData,        HalpWriteStdCmosData},

    //
    // The extended CMOS SRAM region
    //
    {0x80,  0xff,   HalpReadExtCmosIntelPIIX4,  HalpWriteExtCmosIntelPIIX4},

    //
    // end of table
    //
    {0,     0,      0}
};

CMOS_ADDR_RANGE_HANDLER CmosRangeHandlersDal1501[] =
{   

    //
    // The RTC region
    //
    {0,     0x0b,    HalpReadRtcDal1501,         HalpWriteRtcDal1501},

    //
    // The standard CMOS RAM region
    //
    {0x0c,  0x0f,   HalpReadStdCmosData,        HalpWriteStdCmosData},
    
    //
    // NOTE: this table skips the standard CMOS range: 0x10 - 0x1f
    // because this area is reserved in the spec, and the is no
    // apparent reason why the op region should access this area.
    // Also, regs 0x10 and 0x13 are used to access the extended 
    // ram, hence there is no reason why the op region should access
    // this either.  Hence, all op region access beyond 0x0f are
    // interpretted as accesses into the Extended CMOS
    //

    //
    // The extended CMOS SRAM region
    //
    {0x10,  0x10f,  HalpReadExtCmosDal1501,     HalpWriteExtCmosDal1501},

    //
    // end of table
    //
    {0,     0,      0}
};


ULONG 
HalpCmosRangeHandler(
    IN CMOS_ACCESS_TYPE AccessType,
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            Address,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    )
{
    ULONG   bytes;          // bytes read in last operation
    ULONG   offset;         // the offset beyond the initial address
    ULONG   bufOffset;      // the index into the data buffer as we read in data
    ULONG   extAddr;        // the corrected address for accessing extended SRAM
    ULONG   range;          // the current address range we are checking for
    ULONG   bytesRead;      // total bytes successfully read
    ULONG   length;         // the length of the current operation read

    PCMOS_ADDR_RANGE_HANDLER rangeHandlers;   // the table we are using

    //
    // get the appropriate table
    //
    switch (CmosType) {
    case CmosTypeStdPCAT:       

        rangeHandlers = CmosRangeHandlersStdPCAT;   
        break;

    case CmosTypeIntelPIIX4:    

        rangeHandlers = CmosRangeHandlersIntelPIIX4;
        break;

    case CmosTypeDal1501:       

        rangeHandlers = CmosRangeHandlersDal1501;   
        break;

    default:
        break;
    }

    bytesRead   = 0;
    bufOffset   = 0;
    range       = 0;
    offset      = Address;
    length      = ByteCount;

    while (rangeHandlers[range].stop) {

        if (offset <= rangeHandlers[range].stop) {

            //
            // get the # of bytes to read in this region
            //
            // length = MIN(remaining # bytes remaining to read, # bytes to read in the current range)
            //
            length = MIN((ByteCount - bytesRead), (rangeHandlers[range].stop - offset + 1));

            //
            // Since the handler routines are only called from here, we can consolidate
            // the ASSERTIONS.  This is also nice, because we know which range in the
            // table we are dealing with, hence we know what the limits should be.
            //    
            // make sure both the offset into the range, 
            // and the operation's length are in bounds
            // 
            ASSERT(offset <= rangeHandlers[range].stop);
            ASSERT((offset + length) <= (rangeHandlers[range].stop + 1));


            switch (AccessType) {
            
            case CMOS_READ:
                bytes = (rangeHandlers[range].readHandler)(
                                                          offset,
                                                          &DataBuffer[bufOffset],
                                                          length);
                break;

            case CMOS_WRITE:
                bytes = (rangeHandlers[range].writeHandler)(
                                                           offset,
                                                           &DataBuffer[bufOffset],
                                                           length);
                break;

            default:
                break;
            }

            ASSERT(bytes == length);

            bytesRead += bytes;

            //
            // adjust offset based on the length of the last operation
            //
            offset += length;
            bufOffset += length;
        }

        //
        // if offset is at or beyond specified range, then we are done
        //
        if (offset >= (Address + ByteCount)) {
            break;
        }

        //
        // move to the next range
        //
        range++;
    }

    ASSERT(bytesRead == ByteCount);

    return bytesRead;
}

ULONG 
HalpcGetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            Address,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    )
{
    return HalpCmosRangeHandler(
                               CMOS_READ,
                               CmosType,
                               Address,
                               DataBuffer,
                               ByteCount
                               );
}

ULONG 
HalpcSetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            Address,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    )
{
    return HalpCmosRangeHandler(
                               CMOS_WRITE,
                               CmosType,
                               Address,
                               DataBuffer,
                               ByteCount
                               );
}


ULONG
HalpReadCmosDataByPort(
    IN ULONG        AddrPort,
    IN ULONG        DataPort,
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the requested number of bytes from CMOS using the 
       specified ports and stores the data read into the supplied buffer in 
       system memory.  If the requested data amount exceeds the allowable 
       extent of the source location, the return data is truncated.

    Arguments:

       AddrPort        : address in the ISA I/O space to put the address

       DataPort        : address in the ISA I/O space to put the data

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

    Note:

       This routine doesn't perform safety precautions when operating
       in the RTC region of the CMOS.  Use the appropriate RTC routine
       instead.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    ASSERT(SourceAddress <= LARGEST_KNOWN_CMOS_RAM_ADDRESS);
    ASSERT(upperAddrBound <= (LARGEST_KNOWN_CMOS_RAM_ADDRESS + 1));

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //
    HalpAcquireCmosSpinLock();

    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)AddrPort, (UCHAR)offset);

        ReturnBuffer[bufOffset] = READ_PORT_UCHAR((PUCHAR)DataPort);

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}

ULONG
HalpWriteCmosDataByPort(
    IN ULONG        AddrPort,
    IN ULONG        DataPort,
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the requested number of bytes from CMOS using the 
       specified ports and stores the data read into the supplied buffer in 
       system memory.  If the requested data amount exceeds the allowable 
       extent of the source location, the return data is truncated.

    Arguments:

       AddrPort        : address in the ISA I/O space to put the address

       DataPort        : address in the ISA I/O space to put the data

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

    Note:

       This routine doesn't perform safety precautions when operating
       in the RTC region of the CMOS.  Use the appropriate RTC routine
       instead.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    ASSERT(SourceAddress <= LARGEST_KNOWN_CMOS_RAM_ADDRESS);
    ASSERT(upperAddrBound <= (LARGEST_KNOWN_CMOS_RAM_ADDRESS + 1));

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //
    HalpAcquireCmosSpinLock();

    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)AddrPort, (UCHAR)offset);
        WRITE_PORT_UCHAR((PUCHAR)DataPort, (UCHAR)(ReturnBuffer[bufOffset]));

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}


ULONG
HalpReadStdCmosData(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
{
    return HalpReadCmosDataByPort(
                                 CmosStdAddrPort,
                                 CmosStdDataPort,
                                 SourceAddress,
                                 ReturnBuffer,
                                 ByteCount
                                 );
}

ULONG
HalpWriteStdCmosData(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
{
    return HalpWriteCmosDataByPort(
                                  CmosStdAddrPort,
                                  CmosStdDataPort,
                                  SourceAddress,
                                  ReturnBuffer,
                                  ByteCount
                                  );
}


ULONG
HalpReadRtcStdPCAT(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles reads into the standard PC/AT RTC range.

    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   uip;        // update in progress bit
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //
    HalpAcquireCmosSpinLock();

    //
    // According to "ISA System Architecture" 
    // by Mindshare, Inc. (ISBN:0-201-40996-8) Chaper 21.
    // the access method for reading standard PC/AT RTC is:
    //
    // 1. wait for the Update In Progress bit to clear
    //    this is bit 7 of register A
    // 
    // 2. read
    // 

    // 
    // wait until the rtc is done updating
    //
    do {
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_A);
        status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
        uip = status & CMOS_RAM_STDPCAT_REGISTER_A_UIP_BIT;
    } while (uip);

    //
    // read
    //
    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, (UCHAR)offset);

        ReturnBuffer[bufOffset] = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}

ULONG
HalpWriteRtcStdPCAT(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles writes into the standard PC/AT RTC range.

    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   uip;        // update in progress bit
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // According to "ISA System Architecture" 
    // by Mindshare, Inc. (ISBN:0-201-40996-8) Chapter 21.
    // the access method for writing to standard PC/AT RTC is:
    //
    // 1. wait for the Update In Progress bit (UIP) to clear,
    //    where UIP is bit 7 of register A
    // 
    // 2. set the SET bit to notify the RTC that the registers
    //    are being updated.  The SET bit is bit 7 of register B
    //    
    // 3. update the rtc registers
    // 
    // 4. clear the SET bit, notifying the RTC that we are done writing
    //

    // 
    // wait until the rtc is done updating
    //
    do {
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_A);
        status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
        uip = status & CMOS_RAM_STDPCAT_REGISTER_A_UIP_BIT;
    } while (uip);

    //
    // set the SET bit of register B
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status |= CMOS_RAM_STDPCAT_REGISTER_B_SET_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(status));

    //
    // update the rtc registers
    //
    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, (UCHAR)offset);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(ReturnBuffer[bufOffset]));

    }

    //
    // clear the SET bit of register B
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status &= ~CMOS_RAM_STDPCAT_REGISTER_B_SET_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(status));


    HalpReleaseCmosSpinLock();

    return bufOffset; 
}


ULONG
HalpReadRtcIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the RTC range for the Intel PIIX4 CMOS/RTC chip
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{

    //
    // Use the access method for the Standard PC/AT since it is 
    // equivalent to the Intel PIIX4 access method.
    //

    return HalpReadRtcStdPCAT(
                             SourceAddress,
                             ReturnBuffer,
                             ByteCount
                             );

}

ULONG
HalpWriteRtcIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles writes into the RTC range for the Intel PIIX4 CMOS/RTC chip

    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    
    //
    // Use the access method for the Standard PC/AT since it is 
    // equivalent to the Intel PIIX4 access method.
    //

    return HalpWriteRtcStdPCAT(
                              SourceAddress,
                              ReturnBuffer,
                              ByteCount
                              );
    
}

ULONG
HalpReadExtCmosIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the RTC registers for the Intel PIIX4 CMOS/RTC chip.
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    
    //
    // The Intel PIIX4 Extended SRAM is accessed using 
    // next pair of IO ports above the standard addr/data ports.
    // Hence, we can simply forward the request with the correct pair.
    // 
    
    return HalpReadCmosDataByPort(
                                 CmosStdAddrPort + 2,
                                 CmosStdDataPort + 2,
                                 SourceAddress,
                                 ReturnBuffer,
                                 ByteCount
                                 );
}

ULONG
HalpWriteExtCmosIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles writes into the RTC registers for the Intel PIIX4 CMOS/RTC chip.
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{

    //
    // The Intel PIIX4 Extended SRAM is accessed using 
    // next pair of IO ports above the standard addr/data ports.
    // Hence, we can simply forward the request with the correct pair.
    // 
    
    return HalpWriteCmosDataByPort(
                                  CmosStdAddrPort + 2,
                                  CmosStdDataPort + 2,
                                  SourceAddress,
                                  ReturnBuffer,
                                  ByteCount
                                  );
}


ULONG
HalpReadRtcDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the RTC registers for the Dallas 1501 CMOS/RTC chip.
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // NOTE: The recommended procedure for reading the Dallas 1501 RTC is to stop
    // external register updates while reading.  Internally, updates in the RTC 
    // continue as normal.  This procedure prevents reading the registers while 
    // they are in transition
    // 

    // 
    // Clear the TE bit of register B to stop external updates
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status &= ~CMOS_RAM_DAL1501_REGISTER_B_TE_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)status);

    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, (UCHAR)offset);
        
        ReturnBuffer[bufOffset] = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);

    }

    // 
    // Set the TE bit of register B to enable external updates
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status |= CMOS_RAM_DAL1501_REGISTER_B_TE_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)status);

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}

ULONG
HalpWriteRtcDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles writes into the RTC region for the Dallas 1501 CMOS/RTC chip.
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // NOTE: The recommended procedure for writing the Dallas 1501 RTC is to stop
    // external register updates while writing.  The modified register values
    // are transferred into the internal registers when the TE bit is set.  Operation
    // then continues normally.
    // 

    // 
    // Clear the TE bit of register B to stop external updates
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status &= ~CMOS_RAM_DAL1501_REGISTER_B_TE_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)status);

    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, (UCHAR)offset);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(ReturnBuffer[bufOffset]));

    }

    // 
    // Set the TE bit of register B to enable external updates
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status |= CMOS_RAM_DAL1501_REGISTER_B_TE_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)status);

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}



ULONG
HalpReadExtCmosDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // reading from Dallas 1501 SRAM is a 2 step process:
    // 1. First, we write the address to the RAM_ADDR_LSB register in the standard CMOS region.  
    // 2. Then we read the data byte from the RAM_DATA register in the standard CMOS region.
    //
    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        //
        // specify the offset into SRAM
        //
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_RAM_ADDR_LSB);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)offset);
        
        //
        // read the data from SRAM[offset]
        //
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_RAM_DATA);
        ReturnBuffer[bufOffset] = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}

ULONG
HalpWriteExtCmosDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // writing to Dallas 1501 SRAM is a 2 step process:
    // 1. First, we write the address to the RAM_ADDR_LSB register in the standard CMOS region.  
    // 2. Then we write the data byte to the RAM_DATA register in the standard CMOS region.
    //
    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        //
        // specify the offset into SRAM
        //
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_RAM_ADDR_LSB);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)offset);
        
        //
        // specify the data to be written into SRAM[offset]
        //
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_RAM_DATA);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(ReturnBuffer[bufOffset]));

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}


#endif // ACPI_CMOS_ACTIVATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\acpisetd.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved

Module Name:

    acpisetd.c

Abstract:

    This module detects an ACPI system.  It
    is included into setup so that setup
    can figure out which HAL to load

Author:

    Jake Oshins (jakeo) - Feb. 7, 1997.

Environment:

    Textmode setup.

Revision History:


--*/
VOID
BlPrint(
    PCHAR cp,
    ...
    );

ULONG
SlGetChar(
    VOID
    );

VOID
SlPrint(
    IN PCHAR FormatString,
    ...
    );

#define HalpBiosDbgPrint(_x_) if (HalpGoodBiosDebug) {SlPrint _x_; }
#define HalpGoodBiosPause() if (HalpGoodBiosDebug) {SlGetChar();}


#ifdef DEBUG
#undef DEBUG_PRINT
#define DEBUG_PRINT BlPrint
#else
#define DEBUG_PRINT
#endif

typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT
} ACPI_BIOS_INSTALLATION_CHECK, *PACPI_BIOS_INSTALLATION_CHECK;

#include "acpitabl.h"
#include "halp.h"

typedef
BOOLEAN
(* PFN_RULE)(
    PCHAR Section,
    ULONG KeyIndex
    );

extern BOOLEAN DisableACPI;

BOOLEAN MatchAcpiOemIdRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiOemTableIdRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiOemRevisionRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiRevisionRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiCreatorRevisionRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiCreatorIdRule(PCHAR Section, ULONG KeyIndex);

typedef struct _INF_RULE {
    PCHAR szRule;
    PFN_RULE pRule;
} INF_RULE, *PINF_RULE;

INF_RULE InfRule[] =
{
    {"AcpiOemId",       MatchAcpiOemIdRule},
    {"AcpiOemTableId",  MatchAcpiOemTableIdRule},
    {"AcpiOemRevision", MatchAcpiOemRevisionRule},
    {"AcpiRevision",    MatchAcpiRevisionRule},
    {"AcpiCreatorRevision", MatchAcpiCreatorRevisionRule},
    {"AcpiCreatorId",   MatchAcpiCreatorIdRule},
    {NULL, NULL}
};

ULONG
DetectMPACPI (
    OUT PBOOLEAN IsConfiguredMp
    );

ULONG
DetectApicACPI (
    OUT PBOOLEAN IsConfiguredMp
    );

ULONG
DetectPicACPI (
    OUT PBOOLEAN IsConfiguredMp
    );

VOID
HalpFindRsdp (
    VOID
    );

BOOLEAN
HalpValidateRsdp(
    VOID
    );

PVOID
HalpFindApic (
    VOID
    );

ULONG
HalpAcpiNumProcessors(
    VOID
    );

BOOLEAN
HalpMatchInfList(
    IN PCHAR Section
    );

BOOLEAN
HalpMatchDescription(
    PCHAR Section
    );

PRSDP   HalpRsdp = NULL;
PRSDT   HalpRsdt = NULL;
PXSDT   HalpXsdt = NULL;
BOOLEAN HalpSearchedForRsdp = FALSE;
PVOID   HalpApic = NULL;
BOOLEAN HalpSearchedForApic = FALSE;

BOOLEAN HalpGoodBiosDebug = FALSE;

// from boot\detect\i386\acpibios.h
//
// Acpi BIOS Installation check
//
#define ACPI_BIOS_START            0xE0000
#define ACPI_BIOS_END              0xFFFFF
#define ACPI_BIOS_HEADER_INCREMENT 16

#ifndef SETUP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DetectMPACPI)
#pragma alloc_text(INIT,DetectApicACPI)
#pragma alloc_text(INIT,DetectPicACPI)
#endif  // ALLOC_PRAGMA
#endif // SETUP


ULONG
DetectMPACPI(
    OUT PBOOLEAN IsConfiguredMp
    )

/*++

Routine Description:

    This function looks for an ACPI Root System Description
    table in the BIOS.  If it exists, this is an ACPI machine.

 Arguments:

   IsConfiguredMp - TRUE if this machine is a MP instance of the ACPI spec, else FALSE.

 Return Value:
   0 - if not a ACPI
   1 - if ACPI

*/
{

    *IsConfiguredMp = FALSE;

    DEBUG_PRINT("DetectMPACPI\n");

    //
    // Detect whether this is an ACPI machine.
    //
    if (HalpSearchedForRsdp == FALSE) {
        PCHAR AcpiDebug;

        //
        // Check whether ACPI detection debugging is enabled
        //
        if ( InfFile ) {
            AcpiDebug = SlGetIniValue(InfFile, "ACPIOptions", "Debug", "0");
            if (AcpiDebug[0] == '1') {
                HalpGoodBiosDebug = TRUE;
                SlPrint("Enabling GOOD BIOS DEBUG\n");
                SlGetChar();
            }
        }

        HalpFindRsdp();

        HalpSearchedForRsdp = TRUE;
    }

    if (!HalpValidateRsdp()) {
        return(FALSE);
    }

    DEBUG_PRINT("Found Rsdp: %x\n", HalpRsdp);

    if (HalpSearchedForApic == FALSE) {

        HalpApic = HalpFindApic();

        HalpSearchedForApic = TRUE;
    }

    if (HalpAcpiNumProcessors() < 2) {
        return FALSE;
    }

    *IsConfiguredMp = TRUE;
    return TRUE;
}


ULONG
DetectApicACPI(
    OUT PBOOLEAN IsConfiguredMp
    )
/*++

Routine Description:

   This function is called by setup after DetectACPI has returned
   false.  During setup time DetectACPI will return false, if the
   machine is an ACPI system, but only has one processor.   This
   function is used to detect such a machine at setup time.

 Arguments:

   IsConfiguredMp - FALSE

 Return Value:
   0 - if not a UP ACPI
   1 - if UP ACPI

--*/
{
    DEBUG_PRINT("DetectApicACPI\n");

    if (HalpSearchedForRsdp == FALSE) {
        PCHAR AcpiDebug;

        //
        // Check whether ACPI detection debugging is enabled
        //
        if ( InfFile ) {
            AcpiDebug = SlGetIniValue(InfFile, "ACPIOptions", "Debug", "0");
            if (AcpiDebug[0] == '1') {
                HalpGoodBiosDebug = TRUE;
            } else {
                HalpGoodBiosDebug = FALSE;
            }
        }

        HalpFindRsdp();

        HalpSearchedForRsdp = TRUE;
    }

    if (!HalpValidateRsdp()) {
        return FALSE;
    }

    if (HalpSearchedForApic == FALSE) {

        HalpApic = HalpFindApic();

        HalpSearchedForApic = TRUE;
    }

    if (!HalpApic) {
        return FALSE;
    }

    *IsConfiguredMp = FALSE;
    return TRUE;
}

ULONG
DetectPicACPI(
    OUT PBOOLEAN IsConfiguredMp
    )
/*++

Routine Description:

   This function is called by setup after DetectACPI has returned
   false.  During setup time DetectACPI will return false, if the
   machine is an ACPI system, but only has one processor.   This
   function is used to detect such a machine at setup time.

 Arguments:

   IsConfiguredMp - FALSE

 Return Value:
   0 - if not a PIC ACPI
   1 - if PIC ACPI

--*/
{
    *IsConfiguredMp = FALSE;

    if (HalpSearchedForRsdp == FALSE) {
        PCHAR AcpiDebug;

        //
        // Check whether ACPI detection debugging is enabled
        //
        if ( InfFile ) {
            AcpiDebug = SlGetIniValue(InfFile, "ACPIOptions", "Debug", "0");
            if (AcpiDebug[0] == '1') {
                HalpGoodBiosDebug = TRUE;
            } else {
                HalpGoodBiosDebug = FALSE;
            }
        }

        HalpFindRsdp();

        HalpSearchedForRsdp = TRUE;
    }

    if (HalpValidateRsdp()) {
        return TRUE;
    }

    return FALSE;
}

VOID
HalpFindRsdp (
    VOID
    )
#define EBDA_SEGMENT_PTR    0x40e
{
    ULONG romAddr, romEnd;
    PACPI_BIOS_INSTALLATION_CHECK header;
    UCHAR sum, node = 0;
    USHORT i, nodeSize;
    ULONG EbdaSegmentPtr;
    ULONG EbdaPhysicalAdd = 0;
    PUCHAR EbdaVirtualAdd = 0;
    enum PASS { PASS1 = 0, PASS2, MAX_PASSES } pass;

    //
    // Search on 16 byte boundaries for the signature of the
    // Root System Description Table structure.
    //
    for (pass = PASS1; pass < MAX_PASSES; pass++) {

        if (pass == PASS1) {

            //
            // On the first pass, we search the first 1K of the
            // Extended BIOS data area.  The EBDA segment address
            // is available at physical address 40:0E.
            //

            EbdaSegmentPtr = (ULONG) HalpMapPhysicalMemory( (PVOID) 0, 1);
            EbdaSegmentPtr += EBDA_SEGMENT_PTR;
            EbdaPhysicalAdd = *((PUSHORT)EbdaSegmentPtr);
            EbdaPhysicalAdd = EbdaPhysicalAdd << 4;

            if (EbdaPhysicalAdd) {
                EbdaVirtualAdd = HalpMapPhysicalMemory( (PVOID)EbdaPhysicalAdd, 2);
            }

            if (!EbdaVirtualAdd) {
                continue;
            }

            romAddr = (ULONG)EbdaVirtualAdd;
            romEnd  = romAddr + 1024;

        } else {
            //
            // On the second pass, we search (physical) memory 0xE0000
            // to 0xF0000.

            romAddr = (ULONG)HalpMapPhysicalMemory((PVOID)ACPI_BIOS_START,
                                                   (ACPI_BIOS_END - ACPI_BIOS_START) / PAGE_SIZE);

            romEnd  = romAddr + (ACPI_BIOS_END - ACPI_BIOS_START);
        }

        while (romAddr < romEnd) {

            header = (PACPI_BIOS_INSTALLATION_CHECK)romAddr;

            //
            // Signature to match is the string "RSD PTR ".
            //
            if (header->Signature[0] == 'R' && header->Signature[1] == 'S' &&
                header->Signature[2] == 'D' && header->Signature[3] == ' ' &&
                header->Signature[4] == 'P' && header->Signature[5] == 'T' &&
                header->Signature[6] == 'R' && header->Signature[7] == ' ' ) {

                sum = 0;
                for (i = 0; i < sizeof(ACPI_BIOS_INSTALLATION_CHECK); i++) {
                    sum += ((PUCHAR)romAddr)[i];
                }
                if (sum == 0) {
                    pass = MAX_PASSES; // leave 'for' loop
                    break;    // leave 'while' loop
                }
            }

            romAddr += ACPI_BIOS_HEADER_INCREMENT;
        }
    }

    if (romAddr >= romEnd) {
        HalpRsdp = NULL;
        HalpRsdt = NULL;
        HalpXsdt = NULL;
        HalpBiosDbgPrint(("NO ACPI BIOS FOUND!\n"));
        HalpGoodBiosPause();
        return;
    }

    HalpRsdp = (PRSDP)romAddr;
    HalpRsdt = HalpMapPhysicalRange((PVOID)HalpRsdp->RsdtAddress,
                                     sizeof(RSDT));
    HalpRsdt = HalpMapPhysicalRange((PVOID)HalpRsdp->RsdtAddress,
                                    HalpRsdt->Header.Length);
    HalpBiosDbgPrint(("Found RSDP at %08lx, RSDT at %08lx\n", HalpRsdp, HalpRsdt));

#ifdef ACPI_20_COMPLIANT
    if (HalpRsdp->Revision > 1) {

        //
        // ACPI 2.0 BIOS
        //

        HalpXsdt = HalpMapPhysicalRange((PVOID)HalpRsdp->XsdtAddress.LowPart,
                                        sizeof(XSDT));
        HalpXsdt = HalpMapPhysicalRange((PVOID)HalpRsdp->XsdtAddress.LowPart,
                                        HalpXsdt->Header.Length);
        HalpBiosDbgPrint(("Found XSDT at %08lx\n", HalpXsdt));
    }
#endif
    return;
}

PVOID
HalpFindApic (
    VOID
    )
{
    PMAPIC  mapicTable;
    ULONG   entry, rsdtEntries, rsdtLength;
    PVOID   physicalAddr;
    PDESCRIPTION_HEADER header;

    //
    // Calculate the number of entries in the RSDT.
    //

    if (HalpXsdt) {

        //
        // ACPI 2.0 BIOS
        //

        rsdtLength = HalpXsdt->Header.Length;
        rsdtEntries = NumTableEntriesFromXSDTPointer(HalpXsdt);

    } else {

        //
        // ACPI 1.0 BIOS
        //

        rsdtLength = HalpRsdt->Header.Length;
        rsdtEntries = NumTableEntriesFromRSDTPointer(HalpRsdt);
    }

    DEBUG_PRINT("rsdt length: %d\n", HalpRsdt->Header.Length);
    DEBUG_PRINT("rsdtEntries: %d\n", rsdtEntries);
    //
    // Look down the pointer in each entry to see if it points to
    // the table we are looking for.
    //
    for (entry = 0; entry < rsdtEntries; entry++) {

        physicalAddr = HalpXsdt ?
            (PVOID)HalpXsdt->Tables[entry].LowPart :
            (PVOID)HalpRsdt->Tables[entry];

        header = HalpMapPhysicalMemory(physicalAddr,2);
        if (!header) {
            return NULL;
        }

        DEBUG_PRINT("header: %x%x\n", ((ULONG)header) >> 16, (ULONG)header & 0xffff);
        DEBUG_PRINT("entry: %d\n", header->Signature);

        if (header->Signature == APIC_SIGNATURE) {
            break;
        }
    }

    //
    // We didn't find an APIC table.
    //
    if (entry >= rsdtEntries) {
        DEBUG_PRINT("Didn't find an APIC table\n");
        return NULL;
    }

    DEBUG_PRINT("returning: %x\n", header);
    return (PVOID)header;
}

ULONG
HalpAcpiNumProcessors(
    VOID
    )
{
    PUCHAR  TraversePtr;
    UCHAR   procCount = 0;

    if (!HalpApic) {
        return 1;
    }

    TraversePtr = (PUCHAR)((PMAPIC)HalpApic)->APICTables;

    DEBUG_PRINT("APIC table header length %d\n", ((PMAPIC)HalpApic)->Header.Length);
    DEBUG_PRINT("APIC table: %x%x  TraversePtr: %x%x\n",
            (ULONG)HalpApic >> 16,
            (ULONG)HalpApic & 0xffff,
            (ULONG)TraversePtr >> 16,
            (ULONG)TraversePtr & 0xffff);

    while (TraversePtr <= ((PUCHAR)HalpApic + ((PMAPIC)HalpApic)->Header.Length)) {

        if ((((PPROCLOCALAPIC)(TraversePtr))->Type == PROCESSOR_LOCAL_APIC)
           && (((PPROCLOCALAPIC)(TraversePtr))->Length == PROCESSOR_LOCAL_APIC_LENGTH)) {

            if(((PPROCLOCALAPIC)(TraversePtr))->Flags & PLAF_ENABLED) {

                //
                // This processor is enabled.
                //

                procCount++;
            }

            TraversePtr += ((PPROCLOCALAPIC)(TraversePtr))->Length;

        } else if ((((PIOAPIC)(TraversePtr))->Type == IO_APIC) &&
           (((PIOAPIC)(TraversePtr))->Length == IO_APIC_LENGTH)) {

            //
            // Found an I/O APIC entry.  Skipping it.
            //

            TraversePtr += ((PIOAPIC)(TraversePtr))->Length;

        } else if ((((PISA_VECTOR)(TraversePtr))->Type == ISA_VECTOR_OVERRIDE) &&
           (((PISA_VECTOR)(TraversePtr))->Length == ISA_VECTOR_OVERRIDE_LENGTH)) {

            //
            // Found an Isa Vector Override entry.  Skipping it.
            //

            TraversePtr += ISA_VECTOR_OVERRIDE_LENGTH;

        } else {

            //
            // Found random bits in the table.  Try the next byte and
            // see if we can make sense of it.
            //

            TraversePtr += 1;
        }
    }

    DEBUG_PRINT("returning %d processors\n", procCount);
    return procCount;
}


BOOLEAN
HalpValidateRsdp(
    VOID
    )
/*++

Routine Description:

    Given a pointer to the RSDP, this function validates that it
    is suitable for running NT. Currently this test includes:
        Checking for a known good version of a known BIOS
     OR Checking for a date of 1/1/99 or greater

Arguments:

Return Value:

    TRUE - The ACPI BIOS on this machine is good and can be used by NT

    FALSE - The ACPI BIOS on this machine is broken and will be ignored
            by NT.

--*/

{
    ULONG AcpiOptionValue = 2;
    PCHAR AcpiOption;
    PCHAR szMonth = "01", szDay = "01", szYear = "1999";
    ULONG Month, Day, Year;
    CHAR Temp[3];
    ULONG BiosDate, CheckDate;
    PUCHAR DateAddress;

    if (HalpRsdp == NULL) {
        HalpBiosDbgPrint(("Disabling ACPI since there is NO ACPI BIOS\n"));
        HalpGoodBiosPause();
        return(FALSE);
    }

    //
    // Check if the user has manually disabled ACPI with the F7 key
    //
    if (DisableACPI) {
        HalpBiosDbgPrint(("Disabling ACPI due to user pressing F7\n"));
        HalpGoodBiosPause();
        return(FALSE);
    }

    if (WinntSifHandle) {

        AcpiOption = SlGetIniValue(WinntSifHandle, "Unattended", "ForceHALDetection", "no");
        if (_stricmp(AcpiOption,"yes") == 0) {

            HalpBiosDbgPrint(("Unattend Files specifies ForceHALDetection.\n"));
            AcpiOptionValue = 2;

        } else {

            //
            // Check the setting for ACPIEnable.
            //    0 = Disable ACPI
            //    1 = Enable ACPI
            //    2 = Do normal good/bad BIOS detection
            //
            HalpBiosDbgPrint(("Unattend Files does not Contain ForceHALDetection.\n"));
            AcpiOption = SlGetIniValue(WinntSifHandle, "Data", "AcpiHAL", "3");
            if (AcpiOption[0] >= '0' && AcpiOption[0] <= '1') {

                HalpBiosDbgPrint(("Got AcpiHal value from WINNT.SIF\n"));
                AcpiOptionValue = AcpiOption[0] - '0';

            } else if (InfFile) {

                AcpiOption = SlGetIniValue(InfFile, "ACPIOptions", "ACPIEnable", "2");
                if (AcpiOption[0] >= '0' && AcpiOption[0] <= '2') {

                    HalpBiosDbgPrint(("No AcpiHal value from WINNT.SIF\n"));
                    HalpBiosDbgPrint(("Got ACPIEnable from TXTSETUP.SIF\n"));
                    AcpiOptionValue = AcpiOption[0] - '0';

                }

            }

        }

    } else if (InfFile) {

        AcpiOption = SlGetIniValue(InfFile, "ACPIOptions", "ACPIEnable", "2");
        if (AcpiOption[0] >= '0' && AcpiOption[0] <= '2') {

            HalpBiosDbgPrint(("No WINNT.SIF\n"));
            HalpBiosDbgPrint(("Got ACPIEnable from TXTSETUP.SIF\n"));
            AcpiOptionValue = AcpiOption[0] - '0';

        }

    }
    if (AcpiOptionValue == 0) {

        HalpBiosDbgPrint(("Force Disabling ACPI due to ACPIEnable == 0\n"));
        HalpGoodBiosPause();
        return(FALSE);

    } else if (AcpiOptionValue == 1) {

        HalpBiosDbgPrint(("Force Enabling ACPI due to ACPIEnable == 1\n"));
        HalpGoodBiosPause();
        return(TRUE);

    } else {

        HalpBiosDbgPrint(("System will detect ACPI due to ACPIEnable == 2\n"));
        HalpGoodBiosPause();

    }

    if ( InfFile ) {
    
        //
        // Check the Good BIOS list. If the BIOS is on this list, it is OK to
        // enable ACPI.
        //
        if (HalpMatchInfList("GoodACPIBios")) {
            HalpBiosDbgPrint(("Enabling ACPI since machine is on Good BIOS list\n"));
            HalpGoodBiosPause();
            return(TRUE);
        }
    
        //
        // The BIOS is not on our Known Good list. Check the BIOS date and see
        // if it is after our date at which we hope all BIOSes work.
        //
        szMonth = SlGetSectionKeyIndex(InfFile, "ACPIOptions", "ACPIBiosDate", 0);
        szDay = SlGetSectionKeyIndex(InfFile, "ACPIOptions", "ACPIBiosDate", 1);
        szYear = SlGetSectionKeyIndex(InfFile, "ACPIOptions", "ACPIBiosDate", 2);
    }

    if ((szMonth == NULL) ||
        (szDay == NULL) ||
        (szYear == NULL)) {
        HalpBiosDbgPrint(("No Good BIOS date present in INF file\n"));
    } else {
        RtlCharToInteger(szMonth, 16, &Month);
        RtlCharToInteger(szDay, 16, &Day);
        RtlCharToInteger(szYear, 16, &Year);
        CheckDate = (Year << 16) + (Month << 8) + Day;

        DateAddress = HalpMapPhysicalRange((PVOID)0xFFFF5, 8);
        Temp[2] = '\0';
        RtlCopyMemory(Temp, DateAddress+6, 2);
        RtlCharToInteger(Temp, 16, &Year);
        if (Year < 0x80) {
            Year += 0x2000;
        } else {
            Year += 0x1900;
        }

        RtlCopyMemory(Temp, DateAddress, 2);
        RtlCharToInteger(Temp, 16, &Month);

        RtlCopyMemory(Temp, DateAddress+3, 2);
        RtlCharToInteger(Temp, 16, &Day);

        BiosDate = (Year << 16) + (Month << 8) + Day;

        HalpBiosDbgPrint(("\n    Checking good date %08lx against BIOS date %08lx - ",CheckDate,BiosDate));
        if (BiosDate >= CheckDate) {
            HalpBiosDbgPrint(("GOOD!\n"));

            //
            // The date on the BIOS is new enough, now just make sure the machine
            // is not on the BAD BIOS list.
            //
            if ( InfFile ) {
                HalpBiosDbgPrint(("Checking BAD BIOS LIST\n"));
                if (HalpMatchInfList("NWACL")) {
                    HalpBiosDbgPrint(("Disabling ACPI since machine is on BAD BIOS list\n"));
                    HalpGoodBiosPause();
                    return(FALSE);
                } else {
                    HalpBiosDbgPrint(("Enabling ACPI since BIOS is new enough to work\n"));
                    HalpGoodBiosPause();
                    return(TRUE);
                }
            } else {
                return(TRUE);
            }
        } else {
            HalpBiosDbgPrint(("BAD!\n"));
        }

    }

    HalpBiosDbgPrint(("Disabling ACPI since machine is NOT on Good BIOS list\n"));
    HalpGoodBiosPause();
    return(FALSE);

}


PDESCRIPTION_HEADER
HalpFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    )
/*++

Routine Description:

    Given a table name, finds that table in the ACPI BIOS

Arguments:

    TableName - Supplies the table name

    TableLength - Supplies the length of the table to map

Return Value:

    Pointer to the table if found

    NULL if the table is not found

--*/

{
    ULONG Signature;
    PFADT Fadt;
    PDESCRIPTION_HEADER Header;
    ULONG TableCount;
    ULONG i;
    ULONG TableAddr;

    Signature = *((ULONG UNALIGNED *)TableName);
    if (Signature == RSDT_SIGNATURE) {
        return(&HalpRsdt->Header);
    } else if (Signature == XSDT_SIGNATURE) {
        return(&HalpXsdt->Header);
    } else if (Signature == DSDT_SIGNATURE) {
        Fadt = (PFADT)HalpFindACPITable("FACP", sizeof(FADT));
        if (Fadt == NULL) {
            return(NULL);
        }
        Header = HalpMapPhysicalRange((PVOID)Fadt->dsdt, TableLength);
        return(Header);
    } else {

        TableCount = HalpXsdt ?
            NumTableEntriesFromXSDTPointer(HalpXsdt) :
            NumTableEntriesFromRSDTPointer(HalpRsdt);

        for (i=0;i<TableCount;i++) {

            TableAddr = HalpXsdt ?
                HalpXsdt->Tables[i].LowPart :
                HalpRsdt->Tables[i];

            Header = HalpMapPhysicalRange((PVOID)TableAddr, sizeof(DESCRIPTION_HEADER));
            if (Header->Signature == Signature) {
                if (TableLength/PAGE_SIZE > sizeof(DESCRIPTION_HEADER)/PAGE_SIZE) {
                    //
                    // if we need to map more than just the DESCRIPTION_HEADER, do that before
                    // returning.
                    //
                    Header = HalpMapPhysicalRange((PVOID)TableAddr, TableLength);
                }
                return(Header);
            }
        }
    }

    return(NULL);
}


BOOLEAN
HalpMatchInfList(
    IN PCHAR Section
    )
/*++

Routine Description:

    This function determines if the computer matches any of the computer
    descriptions in an INF file list.

Arguments:

    Section - Section of INF that contains the list of descriptions

Return Value:

    TRUE - The computer matches one of the descriptions

    FALSE - The computer does not match any of the descriptions

--*/

{
    ULONG i;
    PCHAR ComputerName;

    for (i=0; ; i++) {
        ComputerName = SlGetKeyName(InfFile,
                                    Section,
                                    i);
        if (ComputerName == NULL) {
            break;
        }
        if (HalpMatchDescription(ComputerName)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


BOOLEAN
HalpMatchDescription(
    PCHAR Section
    )
/*++

Routine Description:

    This function processes an ACPI BIOS description to see if the
    BIOS matches all of the rules in the section

Arguments:

    Section - Supplies the section name of the INF to process

Return Value:

    TRUE - The BIOS matches all the rules

    FALSE - The BIOS failed one or more rules

--*/

{
    ULONG RuleNumber;
    PCHAR Rule;
    ULONG i;
    BOOLEAN Success;

    HalpBiosDbgPrint(("Matching against %s\n", Section));

    //
    // Check to see if the specified section exists
    //
    if (!SpSearchINFSection(InfFile, Section)) {
        HalpBiosDbgPrint(("\tERROR - no INF section %s\n", Section));
        HalpGoodBiosPause();
        return(FALSE);
    }

    for (RuleNumber=0; ;RuleNumber++) {
        Rule = SlGetKeyName(InfFile, Section, RuleNumber);
        if (Rule == NULL) {
            break;
        }
        for (i=0; InfRule[i].szRule != NULL;i++) {
            if (_stricmp(Rule, InfRule[i].szRule) == 0) {
                HalpBiosDbgPrint(("\tTesting Rule %s\n",Rule));
                Success = (*(InfRule[i].pRule))(Section, RuleNumber);
                if (!Success) {
                    HalpBiosDbgPrint(("\tFAILED!\n"));
                    HalpGoodBiosPause();
                    return(FALSE);
                }
                HalpBiosDbgPrint(("\tSucceeded\n"));
                break;
            }
        }
        if (InfRule[i].szRule == NULL) {
            //
            // rule in the INF was not found
            //
            HalpBiosDbgPrint(("\tRULE %s not found!\n",Rule));
            HalpGoodBiosPause();
            return(FALSE);
        }
    }

    HalpBiosDbgPrint(("Machine matches %s\n",Section));
    HalpGoodBiosPause();

    return(TRUE);
}


BOOLEAN
HalpCheckOperator(
    IN PCHAR Operator,
    IN ULONG Arg1,
    IN ULONG Arg2
    )
/*++

Routine Description:

    Given an operator and two ULONG arguments, this function
    returns the boolean result.

Arguments:

    Operator = Supplies the logical operator: =, ==, <=, >=, !=, <, >

    Arg1 - Supplies the first argument

    Arg2 - Supplies the second argument

Return Value:

    TRUE if Arg1 Operator Arg2

    FALSE otherwise

--*/

{
    BOOLEAN Success = FALSE;

    HalpBiosDbgPrint(("\t\tChecking %lx %s %lx - ",Arg1, Operator, Arg2));

    if ((strcmp(Operator, "=") == 0) ||
        (strcmp(Operator, "==") == 0)) {
        Success = (Arg1 == Arg2);
    } else if (strcmp(Operator, "!=") == 0) {
        Success = (Arg1 != Arg2);
    } else if (strcmp(Operator, "<") == 0) {
        Success = (Arg1 < Arg2);
    } else if (strcmp(Operator, "<=") == 0) {
        Success = (Arg1 <= Arg2);
    } else if (strcmp(Operator, ">") == 0) {
        Success = (Arg1 > Arg2);
    } else if (strcmp(Operator, ">=") == 0) {
        Success = (Arg1 >= Arg2);
    } else {
        //
        //      Invalid operator
        //
    }
    if (Success) {
        HalpBiosDbgPrint(("TRUE\n"));
    } else {
        HalpBiosDbgPrint(("FALSE\n"));
    }


    return(Success);
}


BOOLEAN
MatchAcpiOemIdRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI OEM ID rule from an INF file

    Examples:

        AcpiOemId="RSDT", "123456"

    is true if the RSDT has the OEM ID of 123456.

        AcpiOemId="DSDT", "768000"

    is true if the DSDT has the OEM ID of 768000.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR OemId;
    PDESCRIPTION_HEADER Header;
    CHAR ACPIOemId[6];
    ULONG IdLength;

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      0);
    OemId = SlGetSectionLineIndex(InfFile,
                                  Section,
                                  KeyIndex,
                                  1);
    if ((TableName == NULL) || (OemId == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    RtlZeroMemory(ACPIOemId, sizeof(ACPIOemId));
    IdLength = strlen(OemId);
    if (IdLength > sizeof(ACPIOemId)) {
        IdLength = sizeof(ACPIOemId);
    }
    RtlCopyMemory(ACPIOemId, OemId, IdLength);
    HalpBiosDbgPrint(("\t\tComparing OEM ID %s '%6.6s' with '%6.6s' - ",
                       TableName,
                       ACPIOemId,
                       Header->OEMID));
    if (RtlEqualMemory(ACPIOemId, Header->OEMID, sizeof(Header->OEMID))) {
        HalpBiosDbgPrint(("TRUE\n"));
        return(TRUE);
    } else {
        HalpBiosDbgPrint(("FALSE\n"));
        return(FALSE);
    }
}


BOOLEAN
MatchAcpiOemTableIdRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI OEM Table ID rule from an INF file

    Examples:

    AcpiOemTableId="RSDT", "12345678"

        is true if the RSDT has the Oem Table ID of 12345678.

    AcpiOemTableId="DSDT", "87654321"

        is true if the DSDT has the Oem Table ID of 87654321.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR OemTableId;
    PDESCRIPTION_HEADER Header;
    CHAR ACPIOemTableId[8];
    ULONG IdLength;

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      0);
    OemTableId = SlGetSectionLineIndex(InfFile,
                                       Section,
                                       KeyIndex,
                                       1);
    if ((TableName == NULL) || (OemTableId == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    RtlZeroMemory(ACPIOemTableId, sizeof(ACPIOemTableId));
    IdLength = strlen(OemTableId);
    if (IdLength > sizeof(ACPIOemTableId)) {
        IdLength = sizeof(ACPIOemTableId);
    }
    RtlCopyMemory(ACPIOemTableId, OemTableId, IdLength);
    HalpBiosDbgPrint(("\t\tComparing OEM TableID %s '%8.8s' with '%8.8s' - ",
                       TableName,
                       ACPIOemTableId,
                       Header->OEMTableID));
    if (RtlEqualMemory(ACPIOemTableId,
                       Header->OEMTableID,
                       sizeof(Header->OEMTableID))) {
        HalpBiosDbgPrint(("TRUE\n"));
        return(TRUE);
    } else {
        HalpBiosDbgPrint(("FALSE\n"));
        return(FALSE);
    }
}

BOOLEAN
MatchAcpiOemRevisionRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI Oem Revision rule from an INF file

    Examples:

    AcpiOemRevision="=","RSDT", 1234

        is true if the RSDT has the Oem Revision EQUAL to 1234.

    AcpiOemRevision=">","DSDT", 4321

        is true if the DSDT has the Oem Revision GREATER than 4321.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR szOemRevision;
    ULONG OemRevision;
    PCHAR Operator;
    PDESCRIPTION_HEADER Header;
    BOOLEAN Success;

    Operator = SlGetSectionLineIndex(InfFile,
                                     Section,
                                     KeyIndex,
                                     0);

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      1);
    szOemRevision = SlGetSectionLineIndex(InfFile,
                                          Section,
                                          KeyIndex,
                                          2);
    if ((Operator == NULL) || (TableName == NULL) || (szOemRevision == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }
    RtlCharToInteger(szOemRevision, 16, &OemRevision);

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    Success = HalpCheckOperator(Operator, Header->OEMRevision, OemRevision);
    return(Success);
}


BOOLEAN
MatchAcpiRevisionRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI Revision rule from an INF file

    Examples:

        AcpiRevision="=", "RSDT", 1234

    is true if the RSDT ACPI Revision is EQUAL to 1234.

        AcpiRevision=">", "DSDT", 4321

    is true if the DSDT ACPI Revision is GREATER than 4321.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR szRevision;
    ULONG Revision;
    PCHAR Operator;
    PDESCRIPTION_HEADER Header;
    BOOLEAN Success;

    Operator = SlGetSectionLineIndex(InfFile,
                                     Section,
                                     KeyIndex,
                                     0);

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      1);
    szRevision = SlGetSectionLineIndex(InfFile,
                                       Section,
                                       KeyIndex,
                                       2);
    if ((Operator == NULL) || (TableName == NULL) || (szRevision == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }
    RtlCharToInteger(szRevision, 16, &Revision);

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    Success = HalpCheckOperator(Operator, Header->Revision, Revision);
    return(Success);
}


BOOLEAN
MatchAcpiCreatorRevisionRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI Creator Revision rule from an INF file

    Examples:

        AcpiCreatorRevision="=", "RSDT", 1234

    is true if the RSDT ACPI Creator Revision is EQUAL to 1234.

        AcpiCreatorRevision=">", "DSDT", 4321

    is true if the DSDT ACPI Creator Revision is GREATER than 4321.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR szCreatorRevision;
    ULONG CreatorRevision;
    PCHAR Operator;
    PDESCRIPTION_HEADER Header;
    BOOLEAN Success;

    Operator = SlGetSectionLineIndex(InfFile,
                                     Section,
                                     KeyIndex,
                                     0);

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      1);
    szCreatorRevision = SlGetSectionLineIndex(InfFile,
                                              Section,
                                              KeyIndex,
                                              2);
    if ((Operator == NULL) || (TableName == NULL) || (szCreatorRevision == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }
    RtlCharToInteger(szCreatorRevision, 16, &CreatorRevision);

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    Success = HalpCheckOperator(Operator, Header->CreatorRev, CreatorRevision);
    return(Success);
}

BOOLEAN
MatchAcpiCreatorIdRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI Creator ID rule from an INF file

    Examples:

        AcpiCreatorId="RSDT", "MSFT"

    is true if the RSDT has the Creator ID of MSFT.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR CreatorId;
    PDESCRIPTION_HEADER Header;
    CHAR ACPICreatorId[6];
    ULONG IdLength;

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      0);
    CreatorId = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      1);
    if ((TableName == NULL) || (CreatorId == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    RtlZeroMemory(ACPICreatorId, sizeof(ACPICreatorId));
    IdLength = strlen(CreatorId);
    if (IdLength > sizeof(ACPICreatorId)) {
        IdLength = sizeof(ACPICreatorId);
    }
    RtlCopyMemory(ACPICreatorId, CreatorId, IdLength);
    if (RtlEqualMemory(ACPICreatorId, Header->CreatorID, sizeof(Header->CreatorID))) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\rangesup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
All rights reserved

Module Name:

    rangesup.c

Abstract:

    Supplies support function for dealing with SUPPORTED_RANGEs.

Author:

    Ken Reneris (kenr) March-27-1995

Environment:

    Kernel mode only.

Revision History:


*/

#include "halp.h"

#define STATIC

STATIC ULONG
HalpSortRanges (
    IN PSUPPORTED_RANGE     pRange1
    );

typedef struct tagNRParams {
    PIO_RESOURCE_DESCRIPTOR     InDesc;
    PIO_RESOURCE_DESCRIPTOR     OutDesc;
    PSUPPORTED_RANGE            CurrentPosition;
    LONGLONG                    Base;
    LONGLONG                    Limit;
    UCHAR                       DescOpt;
    BOOLEAN                     AnotherListPending;
} NRPARAMS, *PNRPARAMS;

STATIC PIO_RESOURCE_DESCRIPTOR
HalpGetNextSupportedRange (
    IN LONGLONG             MinimumAddress,
    IN LONGLONG             MaximumAddress,
    IN OUT PNRPARAMS        PNRParams
    );

//
// These following functions are usable at to initialize
// the supported_ranges information for a bus handler.
//    HalpMergeRanges           - merges two bus supported ranges
//    HalpMergeRangeList        - merges two single supported ranges lists
//    HalpCopyRanges            - copy a bus supported ranges to a new supported ranges structure
//    HalpAddRangeList          - adds a supported range list to another
//    HalpAddRange              - adds a single range to a supported range list
//    HalpRemoveRanges          - removes all ranges from one buses supported ranges from another
//    HalpRemoveRangeList       - removes all ranges in one supported range list from another
//    HalpRemoveRange           - removes a single range from a supported range list
//    HalpAllocateNewRangeList  - allocates a new, "blank" bus supported ranges structure
//    HalpFreeRangeList         - frees an entire bus supported ranges
//
//    HalpConsolidateRanges     - cleans up a supported ranges structure to be ready for usage
//
//
// These functions are used to intersect a buses supported ranges
// to an IO_RESOURCE_REQUIREMENTS_LIST:
//    HaliAdjustResourceListRange
//
// These functions are used internal to this module:
//    HalpSortRanges
//    HalpGetNextSupportedRange
//


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpMergeRanges)
#pragma alloc_text(INIT,HalpMergeRangeList)
#pragma alloc_text(INIT,HalpCopyRanges)
#pragma alloc_text(INIT,HalpAddRangeList)
#pragma alloc_text(INIT,HalpAddRange)
#pragma alloc_text(INIT,HalpRemoveRanges)
#pragma alloc_text(INIT,HalpRemoveRangeList)
#pragma alloc_text(INIT,HalpRemoveRange)
#pragma alloc_text(INIT,HalpConsolidateRanges)
#pragma alloc_text(PAGE,HalpAllocateNewRangeList)
#pragma alloc_text(PAGE,HalpFreeRangeList)
#pragma alloc_text(PAGE,HaliAdjustResourceListRange)
#pragma alloc_text(PAGE,HalpSortRanges)
#pragma alloc_text(PAGE,HalpGetNextSupportedRange)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
struct {
    ULONG       Offset;
} const HalpRangeList[] = {
    FIELD_OFFSET (SUPPORTED_RANGES, IO),
    FIELD_OFFSET (SUPPORTED_RANGES, Memory),
    FIELD_OFFSET (SUPPORTED_RANGES, PrefetchMemory),
    FIELD_OFFSET (SUPPORTED_RANGES, Dma),
    0,
    };
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#define RANGE_LIST(a,i) ((PSUPPORTED_RANGE) ((PUCHAR) a + HalpRangeList[i].Offset))


PSUPPORTED_RANGES
HalpMergeRanges (
    IN PSUPPORTED_RANGES    Parent,
    IN PSUPPORTED_RANGES    Child
    )
/*++
Routine Description:

    This function produces a NewList which is a subset of all overlapping
    ranges in Parent and Child for all range lists.

    The resulting SystemBaseAddresses and SystemAddressSpaces are taken
    from the Child supported ranges.

    Note: Resulting list needs consolidated

--*/
{
    PSUPPORTED_RANGES   NewList;
    PSUPPORTED_RANGES   List1;

    NewList = HalpAllocateNewRangeList();

    HalpMergeRangeList (&NewList->IO,     &Parent->IO,     &Child->IO);
    HalpMergeRangeList (&NewList->Dma,    &Parent->Dma,    &Child->Dma);
    HalpMergeRangeList (&NewList->Memory, &Parent->Memory, &Child->Memory);

    List1  = HalpAllocateNewRangeList();
    HalpAddRangeList (&List1->Memory, &Parent->Memory);
    HalpAddRangeList (&List1->Memory, &Parent->PrefetchMemory);
    HalpMergeRangeList (&NewList->PrefetchMemory, &List1->Memory, &Child->PrefetchMemory);
    HalpFreeRangeList (List1);

    return NewList;
}


VOID
HalpMergeRangeList (
    OUT PSUPPORTED_RANGE    NewList,
    IN PSUPPORTED_RANGE     Parent,
    IN PSUPPORTED_RANGE     Child
    )
/*++
Routine Description:

    Completes NewList to be a subset of all overlapping
    ranges in the Parent and Child list.

    The resulting SystemBaseAddresses and SystemAddressSpaces are
    taken from the Child supported ranges.

    Note: Resulting list needs consolidated

--*/
{
    BOOLEAN             HeadCompleted;
    PSUPPORTED_RANGE    List1, List2;
    LONGLONG            Base, Limit;

    HeadCompleted  = FALSE;

    for (List1 = Parent; List1; List1 = List1->Next) {
        for (List2 = Child; List2; List2 = List2->Next) {

            Base  = List1->Base;
            Limit = List1->Limit;

            //
            // Clip to range supported by List2
            //

            if (Base < List2->Base) {
                Base = List2->Base;
            }

            if (Limit > List2->Limit) {
                Limit = List2->Limit;
            }

            //
            // If valid range, add it
            //

            if (Base <= Limit) {
                if (HeadCompleted) {
                    NewList->Next = ExAllocatePoolWithTag (
                                        SPRANGEPOOL,
                                        sizeof (SUPPORTED_RANGE),
                                        HAL_POOL_TAG
                                        );
                    RtlZeroMemory (NewList->Next, sizeof (SUPPORTED_RANGE));
                    NewList = NewList->Next;
                    NewList->Next = NULL;
                }

                HeadCompleted  = TRUE;
                NewList->Base  = Base;
                NewList->Limit = Limit;
                NewList->SystemBase = List2->SystemBase;
                NewList->SystemAddressSpace = List2->SystemAddressSpace;
            }
        }
    }
}

PSUPPORTED_RANGES
HalpCopyRanges (
    PSUPPORTED_RANGES     Source
    )
/*++
Routine Description:

    Builds a copy of the Source list to the destination list.
    Note that an invalid entry lands at the begining of the copy, but
    that's OK - it will be pulled out at consolidation time.

    Note: Resulting list needs consolidated

--*/
{
    PSUPPORTED_RANGES   Dest;
    ULONG               i;

    Dest = HalpAllocateNewRangeList ();

    for (i=0; HalpRangeList[i].Offset; i++) {
        HalpAddRangeList (RANGE_LIST(Dest, i), RANGE_LIST(Source, i));
    }

    return Dest;
}

VOID
HalpAddRangeList (
    IN OUT PSUPPORTED_RANGE DRange,
    OUT PSUPPORTED_RANGE    SRange
    )
/*++
Routine Description:

    Adds ranges from SRange to DRange.

--*/
{
    while (SRange) {
        HalpAddRange (
            DRange,
            SRange->SystemAddressSpace,
            SRange->SystemBase,
            SRange->Base,
            SRange->Limit
            );

        SRange = SRange->Next;
    }
}


VOID
HalpAddRange (
    PSUPPORTED_RANGE    HRange,
    ULONG               AddressSpace,
    LONGLONG            SystemBase,
    LONGLONG            Base,
    LONGLONG            Limit
    )
/*++
Routine Description:

    Adds a range to the supported list.  Here we just add the range, if it's
    a duplicate it will be removed later at consolidation time.

--*/
{
    PSUPPORTED_RANGE  Range;

    Range = ExAllocatePoolWithTag (
                SPRANGEPOOL,
                sizeof (SUPPORTED_RANGE),
                HAL_POOL_TAG
                );
    RtlZeroMemory (Range, sizeof (SUPPORTED_RANGE));
    Range->Next  = HRange->Next;
    HRange->Next = Range;

    Range->Base = Base;
    Range->Limit = Limit;
    Range->SystemBase = SystemBase;
    Range->SystemAddressSpace = AddressSpace;
}

VOID
HalpRemoveRanges (
    IN OUT PSUPPORTED_RANGES    Minuend,
    IN PSUPPORTED_RANGES        Subtrahend
    )
/*++
Routine Description:

    Returns a list where all ranges from Subtrahend are removed from Minuend.

    Note: Resulting list needs consolidated

--*/
{

    HalpRemoveRangeList (&Minuend->IO,       &Subtrahend->IO);
    HalpRemoveRangeList (&Minuend->Dma,      &Subtrahend->Dma);
    HalpRemoveRangeList (&Minuend->Memory,   &Subtrahend->Memory);
    HalpRemoveRangeList (&Minuend->Memory,   &Subtrahend->PrefetchMemory);
    HalpRemoveRangeList (&Minuend->PrefetchMemory, &Subtrahend->PrefetchMemory);
    HalpRemoveRangeList (&Minuend->PrefetchMemory, &Subtrahend->Memory);
}

VOID
HalpRemoveRangeList (
    IN OUT PSUPPORTED_RANGE Minuend,
    IN PSUPPORTED_RANGE     Subtrahend
    )
/*++
Routine Description:

    Removes all ranges from Subtrahend from Minuend

    ranges in Source1 and Source1 list

--*/
{
    while (Subtrahend) {

        HalpRemoveRange (
            Minuend,
            Subtrahend->Base,
            Subtrahend->Limit
        );

        Subtrahend = Subtrahend->Next;
    }
}


VOID
HalpRemoveRange (
    PSUPPORTED_RANGE    HRange,
    LONGLONG            Base,
    LONGLONG            Limit
    )
/*++
Routine Description:

    Removes the range Base-Limit from the the HRange list

    Note: The returned list needs consolidated, as some entries
    may be turned into "null ranges".

--*/
{
    PSUPPORTED_RANGE    Range;

    //
    // If range isn't a range at all, then nothing to remove
    //

    if (Limit < Base) {
        return ;
    }


    //
    // Clip any area not to include this range
    //

    for (Range = HRange; Range; Range = Range->Next) {

        if (Range->Limit < Range->Base) {
            continue;
        }

        if (Range->Base < Base) {
            if (Range->Limit >= Base  &&  Range->Limit <= Limit) {
                // truncate
                Range->Limit = Base - 1;
            }

            if (Range->Limit > Limit) {

                //
                // Target area is contained totally within this area.
                // Split into two ranges
                //

                HalpAddRange (
                    HRange,
                    Range->SystemAddressSpace,
                    Range->SystemBase,
                    Limit + 1,
                    Range->Limit
                    );

                Range->Limit = Base - 1;

            }
        } else {
            // Range->Base >= Base
            if (Range->Base <= Limit) {
                if (Range->Limit <= Limit) {
                    //
                    // This range is totally within the target area.  Remove it.
                    // (make it invalid - it will get remove when colsolidated)
                    //

                    Range->Base  = 1;
                    Range->Limit = 0;

                } else {
                    // Bump begining
                    Range->Base = Limit + 1;
                }
            }
        }
    }
}

PSUPPORTED_RANGES
HalpConsolidateRanges (
    IN OUT PSUPPORTED_RANGES   Ranges
    )
/*++
Routine Description:

    Cleans the Range list.   Consolidates overlapping ranges, removes
    ranges which don't have any size, etc...

    The returned Ranges list is a clean as possible, and is now ready
    to be used.

--*/
{
    PSUPPORTED_RANGE    RangeList, List1, List2;
    LONGLONG            Base, Limit, SystemBase;
    ULONG               i, AddressSpace;
    LONGLONG            l;

    ASSERT (Ranges != NULL);

    for (i=0; HalpRangeList[i].Offset; i++) {
        RangeList = RANGE_LIST(Ranges, i);

        //
        // Sort the list by base address
        //

        for (List1 = RangeList; List1; List1 = List1->Next) {
            for (List2 = List1->Next; List2; List2 = List2->Next) {
                if (List2->Base < List1->Base) {
                    Base = List1->Base;
                    Limit = List1->Limit;
                    SystemBase = List1->SystemBase;
                    AddressSpace = List1->SystemAddressSpace;

                    List1->Base = List2->Base;
                    List1->Limit = List2->Limit;
                    List1->SystemBase = List2->SystemBase;
                    List1->SystemAddressSpace = List2->SystemAddressSpace;

                    List2->Base = Base;
                    List2->Limit = Limit;
                    List2->SystemBase = SystemBase;
                    List2->SystemAddressSpace = AddressSpace;
                }
            }
        }

        //
        // Check for adjacent/overlapping ranges and combined them
        //

        List1 = RangeList;
        while (List1  &&  List1->Next) {

            if (List1->Limit < List1->Base) {
                //
                // This range's limit is less then it's base.  This
                // entry doesn't reprent anything uasable, remove it.
                //

                List2 = List1->Next;

                List1->Next = List2->Next;
                List1->Base = List2->Base;
                List1->Limit = List2->Limit;
                List1->SystemBase = List2->SystemBase;
                List1->SystemAddressSpace = List2->SystemAddressSpace;

                ExFreePool (List2);
                continue;
            }

            l = List1->Limit + 1;
            if (l > List1->Limit  &&  l >= List1->Next->Base &&
                (List1->SystemBase == List1->Next->SystemBase)) {

                //
                // Overlapping.  Combine them.
                //

                List2 = List1->Next;
                List1->Next = List2->Next;
                if (List2->Limit > List1->Limit) {
                    List1->Limit = List2->Limit;
                    ASSERT (List1->SystemAddressSpace == List2->SystemAddressSpace);
                }

                ExFreePool (List2);
                continue ;
            }

            List1 = List1->Next;
        }

        //
        // If the last range is invalid, and it's not the only
        // thing in the list - remove it
        //

        if (List1 != RangeList  &&  List1->Limit < List1->Base) {
            for (List2=RangeList; List2->Next != List1; List2 = List2->Next) ;
            List2->Next = NULL;
            ExFreePool (List1);
        }
    }

    return Ranges;
}


PSUPPORTED_RANGES
HalpAllocateNewRangeList (
    VOID
    )
/*++

Routine Description:

    Allocates a range list

--*/
{
    PSUPPORTED_RANGES   RangeList;
    ULONG               i;

    RangeList = (PSUPPORTED_RANGES) ExAllocatePoolWithTag (
                                        SPRANGEPOOL,
                                        sizeof (SUPPORTED_RANGES),
                                        HAL_POOL_TAG
                                        );
    RtlZeroMemory (RangeList, sizeof (SUPPORTED_RANGES));
    RangeList->Version = BUS_SUPPORTED_RANGE_VERSION;

    for (i=0; HalpRangeList[i].Offset; i++) {
        // Limit set to zero, set initial base to 1
        RANGE_LIST(RangeList, i)->Base = 1;
    }
    return RangeList;
}


VOID
HalpFreeRangeList (
    PSUPPORTED_RANGES   Ranges
    )
/*++

Routine Description:

    Frees a range list which was allocated via HalpAllocateNewRangeList, and
    extended / modified via the generic support functions.


--*/
{
    PSUPPORTED_RANGE    Entry, NextEntry;
    ULONG               i;

    for (i=0; HalpRangeList[i].Offset; i++) {
        Entry = RANGE_LIST(Ranges, i)->Next;

        while (Entry) {
            NextEntry = Entry->Next;
            ExFreePool (Entry);
            Entry = NextEntry;
        }
    }

    ExFreePool (Ranges);
}


#if DBG
STATIC VOID
HalpDisplayAddressRange (
    PSUPPORTED_RANGE    Address,
    PUCHAR              String
    )
/*++

Routine Description:

    Debugging code.  Used only by HalpDisplayAllBusRanges

--*/
{
    ULONG       i;

    i = 0;
    while (Address) {
        if (i == 0) {
            DbgPrint (String);
            i = 3;
        }

        i -= 1;
        DbgPrint (" %x:%08x - %x:%08x ",
            (ULONG) (Address->Base >> 32),
            (ULONG) (Address->Base),
            (ULONG) (Address->Limit >> 32),
            (ULONG) (Address->Limit)
            );

        Address = Address->Next;
    }
}

VOID
HalpDisplayAllBusRanges (
    VOID
    )
/*++

Routine Description:

    Debugging code.  Displays the current supported range information
    for all the registered buses in the system.

--*/
{
    PSUPPORTED_RANGES   Addresses;
    PBUS_HANDLER        Bus;
    PUCHAR              p;
    ULONG               i, j;

    DbgPrint ("\nHAL - dumping all supported bus ranges");

    for (i=0; i < MaximumInterfaceType; i++) {
        for (j=0; Bus = HaliHandlerForBus (i, j); j++) {
            Addresses = Bus->BusAddresses;
            if (Addresses) {
                p = NULL;
                switch (Bus->InterfaceType) {
                    case Internal:  p = "Internal";     break;
                    case Isa:       p = "Isa";          break;
                    case Eisa:      p = "Eisa";         break;
                    case PCIBus:    p = "PCI";          break;
                }
                if (p) {
                    DbgPrint ("\n%s %d", p, Bus->BusNumber);
                } else {
                    DbgPrint ("\nBus-%d %d", Bus->InterfaceType, Bus->BusNumber);
                }
                HalpDisplayAddressRange (&Addresses->IO,            "\n  IO......:");
                HalpDisplayAddressRange (&Addresses->Memory,        "\n  Memory..:");
                HalpDisplayAddressRange (&Addresses->PrefetchMemory,"\n  PFMemory:");
                HalpDisplayAddressRange (&Addresses->Dma,           "\n  Dma.....:");
                DbgPrint ("\n");
            }
        }
    }
}
#endif

NTSTATUS
HaliAdjustResourceListRange (
    IN PSUPPORTED_RANGES                    SRanges,
    IN PSUPPORTED_RANGE                     InterruptRange,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++

Routine Description:

    This functions takes an IO_RESOURCE_REQUIREMENT_LIST and
    adjusts it such that all ranges in the list fit in the
    ranges specified by SRanges & InterruptRange.

    This function is used by some HALs to clip the possible
    settings to be contained on what the particular bus supports
    in reponse to a HalAdjustResourceList call.

Arguments:

    SRanges         - Valid IO, Memory, Prefetch Memory, and DMA ranges.
    InterruptRange  - Valid InterruptRanges

    pResourceList   - The resource requirements list which needs to
                      be adjusted to only contain the ranges as
                      described by SRanges & InterruptRange.

Return Value:

    STATUS_SUCCESS or an appropiate error return.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST  InCompleteList, OutCompleteList;
    PIO_RESOURCE_LIST               InResourceList, OutResourceList;
    PIO_RESOURCE_DESCRIPTOR         HeadOutDesc, SetDesc;
    NRPARAMS                        Pos;
    ULONG                           len, alt, cnt, i;
    ULONG                           icnt;

    //
    // Sanity check
    //

    if (!SRanges  ||  SRanges->Version != BUS_SUPPORTED_RANGE_VERSION) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If SupportedRanges aren't sorted, sort them and get the
    // number of ranges for each type
    //

    if (!SRanges->Sorted) {
        SRanges->NoIO = HalpSortRanges (&SRanges->IO);
        SRanges->NoMemory = HalpSortRanges (&SRanges->Memory);
        SRanges->NoPrefetchMemory = HalpSortRanges (&SRanges->PrefetchMemory);
        SRanges->NoDma = HalpSortRanges (&SRanges->Dma);
        SRanges->Sorted = TRUE;
    }

    icnt = HalpSortRanges (InterruptRange);

    InCompleteList = *pResourceList;
    len = InCompleteList->ListSize;

    //
    // Scan input list - verify revision #'s, and increase len varible
    // by amount output list may increase.
    //

    i = 1;
    InResourceList = InCompleteList->List;
    for (alt=0; alt < InCompleteList->AlternativeLists; alt++) {
        if (InResourceList->Version != 1 || InResourceList->Revision < 1) {
            return STATUS_INVALID_PARAMETER;
        }

        Pos.InDesc  = InResourceList->Descriptors;
        for (cnt = InResourceList->Count; cnt; cnt--) {
            switch (Pos.InDesc->Type) {
                case CmResourceTypeInterrupt:  i += icnt;           break;
                case CmResourceTypePort:       i += SRanges->NoIO;  break;
                case CmResourceTypeDma:        i += SRanges->NoDma; break;

                case CmResourceTypeMemory:
                    i += SRanges->NoMemory;
                    if (Pos.InDesc->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {
                        i += SRanges->NoPrefetchMemory;
                    }
                    break;

                default:
                    return STATUS_INVALID_PARAMETER;
            }

            // take one off for the original which is already accounted for in 'len'
            i -= 1;

            // Next descriptor
            Pos.InDesc++;
        }

        // Next Resource List
        InResourceList  = (PIO_RESOURCE_LIST) Pos.InDesc;
    }
    len += i * sizeof (IO_RESOURCE_DESCRIPTOR);

    //
    // Allocate output list
    //

    OutCompleteList = (PIO_RESOURCE_REQUIREMENTS_LIST)
                            ExAllocatePoolWithTag (PagedPool,
                                                   len,
                                                   ' laH');

    if (!OutCompleteList) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (OutCompleteList, len);

    //
    // Walk each ResourceList and build output structure
    //

    InResourceList   = InCompleteList->List;
    *OutCompleteList = *InCompleteList;
    OutResourceList  = OutCompleteList->List;

    for (alt=0; alt < InCompleteList->AlternativeLists; alt++) {
        OutResourceList->Version  = 1;
        OutResourceList->Revision = 1;

        Pos.InDesc  = InResourceList->Descriptors;
        Pos.OutDesc = OutResourceList->Descriptors;
        HeadOutDesc = Pos.OutDesc;

        for (cnt = InResourceList->Count; cnt; cnt--) {

            //
            // Limit desctiptor to be with the buses supported ranges
            //

            Pos.DescOpt = Pos.InDesc->Option;
            Pos.AnotherListPending = FALSE;

            switch (Pos.InDesc->Type) {
                case CmResourceTypePort:

                    //
                    // Get supported IO ranges
                    //

                    Pos.CurrentPosition = &SRanges->IO;
                    do {
                        SetDesc = HalpGetNextSupportedRange (
                                    Pos.InDesc->u.Port.MinimumAddress.QuadPart,
                                    Pos.InDesc->u.Port.MaximumAddress.QuadPart,
                                    &Pos
                                    );

                        if (SetDesc) {
                            SetDesc->u.Port.MinimumAddress.QuadPart = Pos.Base;
                            SetDesc->u.Port.MaximumAddress.QuadPart = Pos.Limit;
                        }

                    } while (SetDesc) ;
                    break;

                case CmResourceTypeInterrupt:
                    //
                    // Get supported Interrupt ranges
                    //

                    Pos.CurrentPosition = InterruptRange;
                    do {
                        SetDesc = HalpGetNextSupportedRange (
                                    Pos.InDesc->u.Interrupt.MinimumVector,
                                    Pos.InDesc->u.Interrupt.MaximumVector,
                                    &Pos
                                    );

                        if (SetDesc) {
                            SetDesc->u.Interrupt.MinimumVector = (ULONG) Pos.Base;
                            SetDesc->u.Interrupt.MaximumVector = (ULONG) Pos.Limit;
                        }
                    } while (SetDesc) ;
                    break;

                case CmResourceTypeMemory:
                    //
                    // Get supported memory ranges
                    //

                    if (Pos.InDesc->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {

                        //
                        // This is a Prefetchable range.
                        // First add in any supported prefetchable ranges, then
                        // add in any regualer supported ranges
                        //

                        Pos.AnotherListPending = TRUE;
                        Pos.CurrentPosition = &SRanges->PrefetchMemory;

                        do {
                            SetDesc = HalpGetNextSupportedRange (
                                        Pos.InDesc->u.Memory.MinimumAddress.QuadPart,
                                        Pos.InDesc->u.Memory.MaximumAddress.QuadPart,
                                        &Pos
                                        );

                            if (SetDesc) {
                                SetDesc->u.Memory.MinimumAddress.QuadPart = Pos.Base;
                                SetDesc->u.Memory.MaximumAddress.QuadPart = Pos.Limit;
                                SetDesc->Option |= IO_RESOURCE_PREFERRED;
                            }
                        } while (SetDesc) ;

                        Pos.AnotherListPending = FALSE;
                    }

                    //
                    // Add in supported bus memory ranges
                    //

                    Pos.CurrentPosition = &SRanges->Memory;
                    do {
                        SetDesc = HalpGetNextSupportedRange (
                                        Pos.InDesc->u.Memory.MinimumAddress.QuadPart,
                                        Pos.InDesc->u.Memory.MaximumAddress.QuadPart,
                                        &Pos
                                        );
                        if (SetDesc) {
                            SetDesc->u.Memory.MinimumAddress.QuadPart = Pos.Base;
                            SetDesc->u.Memory.MaximumAddress.QuadPart = Pos.Limit;
                        }
                    } while (SetDesc);
                    break;

                case CmResourceTypeDma:
                    //
                    // Get supported DMA ranges
                    //

                    Pos.CurrentPosition = &SRanges->Dma;
                    do {
                        SetDesc = HalpGetNextSupportedRange (
                                    Pos.InDesc->u.Dma.MinimumChannel,
                                    Pos.InDesc->u.Dma.MaximumChannel,
                                    &Pos
                                    );

                        if (SetDesc) {
                            SetDesc->u.Dma.MinimumChannel = (ULONG) Pos.Base;
                            SetDesc->u.Dma.MaximumChannel = (ULONG) Pos.Limit;
                        }
                    } while (SetDesc) ;
                    break;

#if DBG
                default:
                    DbgPrint ("HalAdjustResourceList: Unkown resource type\n");
                    break;
#endif
            }

            //
            // Next descriptor
            //

            Pos.InDesc++;
        }

        OutResourceList->Count = (ULONG)(Pos.OutDesc - HeadOutDesc);

        //
        // Next Resource List
        //

        InResourceList  = (PIO_RESOURCE_LIST) Pos.InDesc;
        OutResourceList = (PIO_RESOURCE_LIST) Pos.OutDesc;
    }

    //
    // Free input list, and return output list
    //

    ExFreePool (InCompleteList);

    OutCompleteList->ListSize = (ULONG) ((PUCHAR) OutResourceList - (PUCHAR) OutCompleteList);
    *pResourceList = OutCompleteList;
    return STATUS_SUCCESS;
}


STATIC PIO_RESOURCE_DESCRIPTOR
HalpGetNextSupportedRange (
    IN LONGLONG             MinimumAddress,
    IN LONGLONG             MaximumAddress,
    IN OUT PNRPARAMS        Pos
    )
/*++

Routine Description:

    Support function for HaliAdjustResourceListRange.
    Returns the next supported range in the area passed in.

Arguments:

    MinimumAddress
    MaximumAddress  - Min & Max address of a range which needs
                      to be clipped to match that of the supported
                      ranges of the current bus.

    Pos             - describes the current postion

Return Value:

    NULL is no more returned ranges

    Otherwise, the IO_RESOURCE_DESCRIPTOR which needs to be set
    with the matching range returned in Pos.

--*/
{
    LONGLONG        Base, Limit;

    //
    // Find next range which is supported
    //

    Base  = MinimumAddress;
    Limit = MaximumAddress;

    while (Pos->CurrentPosition) {
        Pos->Base  = Base;
        Pos->Limit = Limit;

        //
        // Clip to current range
        //

        if (Pos->Base < Pos->CurrentPosition->Base) {
            Pos->Base = Pos->CurrentPosition->Base;
        }

        if (Pos->Limit > Pos->CurrentPosition->Limit) {
            Pos->Limit = Pos->CurrentPosition->Limit;
        }

        //
        // set position to next range
        //

        Pos->CurrentPosition = Pos->CurrentPosition->Next;

        //
        // If valid range, return it
        //

        if (Pos->Base <= Pos->Limit) {
            *Pos->OutDesc = *Pos->InDesc;
            Pos->OutDesc->Option = Pos->DescOpt;

            //
            // next descriptor (if any) is an alternative
            // to the descriptor being returned now
            //

            Pos->OutDesc += 1;
            Pos->DescOpt |= IO_RESOURCE_ALTERNATIVE;
            return Pos->OutDesc - 1;
        }
    }


    //
    // There's no overlapping range.  If this descriptor is
    // not an alternative and this descriptor is not going to
    // be processed by another range list, then return
    // a descriptor which can't be satisified.
    //

    if (!(Pos->DescOpt & IO_RESOURCE_ALTERNATIVE) &&
        Pos->AnotherListPending == FALSE) {
#if DBG
        DbgPrint ("HAL: returning impossible range\n");
#endif
        Pos->Base  = MinimumAddress;
        Pos->Limit = Pos->Base - 1;
        if (Pos->Base == 0) {       // if wrapped, fix it
            Pos->Base  = 1;
            Pos->Limit = 0;
        }

        *Pos->OutDesc = *Pos->InDesc;
        Pos->OutDesc->Option = Pos->DescOpt;

        Pos->OutDesc += 1;
        Pos->DescOpt |= IO_RESOURCE_ALTERNATIVE;
        return Pos->OutDesc - 1;
    }

    //
    // No range found (or no more ranges)
    //

    return NULL;
}

STATIC ULONG
HalpSortRanges (
    IN PSUPPORTED_RANGE     RangeList
    )
/*++

Routine Description:

    Support function for HaliAdjustResourceListRange.
    Sorts a supported range list into decending order.

Arguments:

    pRange  - List to sort

Return Value:

--*/
{
    ULONG               cnt;
    LONGLONG            hldBase, hldLimit, hldSystemBase;
    PSUPPORTED_RANGE    Range1, Range2;

    //
    // Sort it
    //

    for (Range1 = RangeList; Range1; Range1 = Range1->Next) {
        for (Range2 = Range1->Next; Range2; Range2 = Range2->Next) {

            if (Range2->Base > Range1->Base) {
                hldBase  = Range1->Base;
                hldLimit = Range1->Limit;
                hldSystemBase = Range1->SystemBase;

                Range1->Base  = Range2->Base;
                Range1->Limit = Range2->Limit;
                Range1->SystemBase = Range2->SystemBase;

                Range2->Base  = hldBase;
                Range2->Limit = hldLimit;
                Range2->SystemBase = hldSystemBase;
            }
        }
    }

    //
    // Count the number of ranges
    //

    cnt = 0;
    for (Range1 = RangeList; Range1; Range1 = Range1->Next) {
        cnt += 1;
    }

    return cnt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\halnls.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\halnls.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\drivesup.c ===
#include "..\drivesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\dynsysres.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynsysres.c

Abstract:

    This module contain functions which support dynamic system
    resources e.g. processors, memory, and I/O.  Among other things,
    it will contain code necessary to configure the OS for the
    'capacity' of a partition rather than the boot resources.

Author:

    Adam Glass

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

#if defined(_WIN64)
#define HalpGetAcpiTablePhase0  HalpGetAcpiTable
#endif

PHYSICAL_ADDRESS HalpMaxHotPlugMemoryAddress;

VOID
HalpGetHotPlugMemoryInfo(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    PHYSICAL_ADDRESS Extent;
    PACPI_SRAT_ENTRY SratEntry;
    PACPI_SRAT_ENTRY SratEnd;
    PACPI_SRAT SratTable;

    SratTable = HalpGetAcpiTablePhase0(LoaderBlock, ACPI_SRAT_SIGNATURE);
    if (SratTable == NULL) {
        return;
    }

    //
    // The Static Resource Affinity Table (SRAT) exists.
    //
    // Scan it to determine if there are any hot plug memory regions.
    //

    SratEnd = (PACPI_SRAT_ENTRY)(((PUCHAR)SratTable) +
                                        SratTable->Header.Length);
    for (SratEntry = (PACPI_SRAT_ENTRY)(SratTable + 1);
         SratEntry < SratEnd;
         SratEntry = (PACPI_SRAT_ENTRY)(((PUCHAR) SratEntry) + SratEntry->Length)) {
        switch (SratEntry->Type) {
        case SratMemory:
            Extent.QuadPart = SratEntry->MemoryAffinity.Base.QuadPart +
                SratEntry->MemoryAffinity.Length;
            if (SratEntry->MemoryAffinity.Flags.HotPlug &&
                SratEntry->MemoryAffinity.Flags.Enabled &&
                (Extent.QuadPart > HalpMaxHotPlugMemoryAddress.QuadPart)) {
                HalpMaxHotPlugMemoryAddress = Extent;
            }
            break;
        }
    }
}

VOID
HalpDynamicSystemResourceConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    HalpGetHotPlugMemoryInfo(LoaderBlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\halp.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\halp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixfirm.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixfirm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixinfo.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixinfo.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixisa.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixisa.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixenvirv.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixenvirv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixhwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixhwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixhalt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xxacpi.c

Abstract:

    Implements various ACPI utility functions.

Author:

    Jake Oshins (jakeo) 12-Feb-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include <inbv.h>

extern PULONG KiBugCheckData;
SLEEP_STATE_CONTEXT     HalpShutdownContext;


VOID
HaliHaltSystem (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine has crashed and is to be
        halted

    N.B.

        Will NOT return.

--*/
{
    for (; ;) {
        HalpCheckPowerButton();
        HalpYieldProcessor();
    }
}


VOID
HalpCheckPowerButton (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine is spinning in the debugger,
    or has crashed and halted.

--*/
{
    USHORT                  Pm1Status, Pm1Control;
    SLEEP_STATE_CONTEXT     ShutdownContext;

    //
    // If there's been a bugcheck, or if the hal owns the display check
    // the fixed power button for an unconditional power off
    //

    if ((KiBugCheckData[0] || InbvCheckDisplayOwnership()) &&  HalpShutdownContext.AsULONG) {

        Pm1Status = READ_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1a_evt_blk_io_port);
        if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {
            Pm1Status |= READ_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1b_evt_blk_io_port);
        }

        //
        // If the fixed button has been pushed, power off the system
        //

        if (Pm1Status & PM1_PWRBTN_STS) {
            //
            // Only do this once
            //

            ShutdownContext = HalpShutdownContext;
            HalpShutdownContext.AsULONG = 0;

            //
            // Disable & eoi all wake events
            //

            AcpiEnableDisableGPEvents(FALSE);
            WRITE_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1a_evt_blk_io_port, Pm1Status);
            if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {
                WRITE_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1b_evt_blk_io_port, Pm1Status);
            }

            //
            // Power off
            //

            Pm1Control = READ_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port);
            Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | (ShutdownContext.bits.Pm1aVal << SLP_TYP_SHIFT) | SLP_EN);
            WRITE_PORT_USHORT ((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port, Pm1Control);

            if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port) {
                Pm1Control = READ_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port);
                Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | (ShutdownContext.bits.Pm1bVal << SLP_TYP_SHIFT) | SLP_EN);
                WRITE_PORT_USHORT ((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port, Pm1Control);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixisabus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixisabus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixmca.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixmca.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixisasup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixisasup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixnmi.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixnmi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixphwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixphwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixpcibus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixpcibus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixreboot.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixreboot.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixsleep.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixsleep.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixproc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixsproc.c

Abstract:

    Stub functions for UP hals.

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITCONST") // INITCONST is OK to use for data_seg
#endif // ALLOC_DATA_PRAGMA
const WCHAR   HalHardwareIdString[]  = L"acpipic_up";

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

const UCHAR HalName[] = "ACPI Compatible Eisa/Isa HAL"; // This is placed in .text for debugging
#define HalName        L"ACPI Compatible Eisa/Isa HAL"

BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpMcaInit (
    VOID
    );

VOID
HalpAcpiEnumerate (
    PUNICODE_STRING DriverName
    );

VOID HalpInitOtherBuses (VOID);
VOID HalpInitializePciBus (VOID);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitMP)
#pragma alloc_text(INIT,HalStartNextProcessor)
#pragma alloc_text(INIT,HalAllProcessorsStarted)
#pragma alloc_text(INIT,HalReportResourceUsage)
#pragma alloc_text(INIT,HalpInitOtherBuses)
#endif



BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    // do nothing
    return TRUE;
}


VOID
HalpResetAllProcessors (
    VOID
    )
{
    // Just return, that will invoke the standard PC reboot code
}


BOOLEAN
HalStartNextProcessor (
   IN PLOADER_PARAMETER_BLOCK   pLoaderBlock,
   IN PKPROCESSOR_STATE         pProcessorState
   )
{
    // no other processors
    return FALSE;
}

BOOLEAN
HalAllProcessorsStarted (
    VOID
    )
{
    if (HalpFeatureBits & HAL_NO_SPECULATION) {

        //
        // Processor doesn't perform speculative execeution,
        // remove fences in critical code paths
        //

        HalpRemoveFences ();
    }

    return TRUE;
}


VOID
HalReportResourceUsage (
    VOID
    )
{
    INTERFACE_TYPE  interfacetype;
    UNICODE_STRING  UHalName;

    HalInitSystemPhase2 ();

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();

    switch (HalpBusType) {
        case MACHINE_TYPE_ISA:  interfacetype = Isa;            break;
        case MACHINE_TYPE_EISA: interfacetype = Eisa;           break;
        case MACHINE_TYPE_MCA:  interfacetype = MicroChannel;   break;
        default:                interfacetype = Internal;       break;
    }

    RtlInitUnicodeString (&UHalName, HalName);
    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        interfacetype       // device space interface type
    );

#if 0
    //
    // Display all buses & ranges
    //

    HalpDisplayAllBusRanges ();
#endif
    
    HalpRegisterPciDebuggingDeviceInfo();
}


VOID
HalpInitOtherBuses (
    VOID
    )
{
    // no other internal buses supported
}

ULONG
FASTCALL
HalSystemVectorDispatchEntry (
    IN ULONG Vector,
    OUT PKINTERRUPT_ROUTINE **FlatDispatch,
    OUT PKINTERRUPT_ROUTINE *NoConnection
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixpciint.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpciint.c

Abstract:

    All PCI bus interrupt mapping is in this module, so that a real
    system which doesn't have all the limitations which PC PCI
    systems have can replaced this code easly.
    (bus memory & i/o address mappings can also be fix here)

Author:

    Ken Reneris

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

ULONG   PciIsaIrq;
ULONG   HalpEisaELCR;
BOOLEAN HalpDoingCrashDump;
BOOLEAN HalpPciLockSettings;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetPCIIntOnISABus)
#pragma alloc_text(PAGE,HalpAdjustPCIResourceList)
#pragma alloc_text(PAGE,HalpGetISAFixedPCIIrq)
#endif

VOID
HalpPCIPin2ISALine (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    On the current PC implementations, the bios has already filled in
    InterruptLine as it's ISA value and there's no portable way to
    change it.

    On a DBG build we adjust InterruptLine just to ensure driver's
    don't connect to it without translating it on the PCI bus.

--*/
{
    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    //
    // Set vector as a level vector.  (note: this code assumes the
    // irq is static and does not move).
    //

    if (PciData->u.type0.InterruptLine >= 1  &&
        PciData->u.type0.InterruptLine <= 15) {

        //
        // If this bit was on the in the PIC ELCR register,
        // then mark it in PciIsaIrq.   (for use in hal.dll,
        // such that we can assume the interrupt controller
        // has been properly marked as a level interrupt for
        // this IRQ.  Other hals probabily don't care.)
        //

        PciIsaIrq |= HalpEisaELCR & (1 << PciData->u.type0.InterruptLine);
    }
}



VOID
HalpPCIISALine2Pin (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++

    This functions maps the device's InterruptLine to it's
    device specific InterruptPin value.

    On the current PC implementations, this information is
    fixed by the BIOS.  Just make sure the value isn't being
    editted since PCI doesn't tell us how to dynically
    connect the interrupt.

--*/
{
    if (!PciNewData->u.type0.InterruptPin) {
        return ;
    }
}

#if !defined(SUBCLASSPCI)

VOID
HalpPCIAcquireType2Lock (
    PKSPIN_LOCK SpinLock,
    PKIRQL      Irql
    )
{
    if (!HalpDoingCrashDump) {
        *Irql = KfRaiseIrql (HIGH_LEVEL);
        KiAcquireSpinLock (SpinLock);
    } else {
        *Irql = HIGH_LEVEL;
    }
}


VOID
HalpPCIReleaseType2Lock (
    PKSPIN_LOCK SpinLock,
    KIRQL       Irql
    )
{
    if (!HalpDoingCrashDump) {
        KiReleaseSpinLock (SpinLock);
        KfLowerIrql (Irql);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixslpsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixslpsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixpnpdrv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixpnpdrv.c

Abstract:

    Implements functionality necessary for the
    HAL to become a PnP-style device driver
    after system initialization.  This is done
    so that the HAL can enumerate the ACPI driver
    in the way that the PnP stuff expects.

Author:

    Jake Oshins (jakeo) 27-Jan-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "exboosts.h"
#include "wchar.h"
#include "xxacpi.h"

//
// Cause the GUID to be defined.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
#include "initguid.h"
#include "wdmguid.h"
#include "halpnpp.h"
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

#if DBG
ULONG HalDebug = 0;
#endif

extern WCHAR HalHardwareIdString[];
#if defined(NT_UP) && defined(APIC_HAL)
extern WCHAR MpHalHardwareIdString[];
#endif

typedef enum {
    Hal = 0x80,
    AcpiDriver
} PDO_TYPE;

typedef enum {
    PdoExtensionType = 0xc0,
    FdoExtensionType
} EXTENSION_TYPE;

typedef struct _PDO_EXTENSION *PPDO_EXTENSION;
typedef struct _FDO_EXTENSION *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION{
    EXTENSION_TYPE                  ExtensionType;
    PPDO_EXTENSION                  Next;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    PFDO_EXTENSION                  ParentFdoExtension;
    PDO_TYPE                        PdoType;
} PDO_EXTENSION, *PPDO_EXTENSION;

#define ASSERT_PDO_EXTENSION(x) ASSERT((x)->ExtensionType == PdoExtensionType );

typedef struct _FDO_EXTENSION{
    EXTENSION_TYPE        ExtensionType;
    PPDO_EXTENSION        ChildPdoList;
    PDEVICE_OBJECT        PhysicalDeviceObject;  // PDO passed into AddDevice()
    PDEVICE_OBJECT        FunctionalDeviceObject;
    PDEVICE_OBJECT        AttachedDeviceObject;
} FDO_EXTENSION, *PFDO_EXTENSION;

#define ASSERT_FDO_EXTENSION(x) ASSERT((x)->ExtensionType == FdoExtensionType );

INT_ROUTE_INTERFACE_STANDARD PciIrqRoutingInterface = {0};

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    );

NTSTATUS
HalpQueryResourceRequirements(
    PDEVICE_OBJECT DeviceObject,
    PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
);

VOID
HalpMaskAcpiInterrupt(
    VOID
    );

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    );

// from xxacpi.c
NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

VOID
HalpMarkAcpiHal(
    VOID
    );

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

#ifdef ACPI_CMOS_ACTIVATE
VOID
HalpCmosNullReference(
    PVOID Context
    );

VOID
HalpCmosNullDereference(
    PVOID Context
    );
#endif // ACPI_CMOS_ACTIVATE

#define HAL_DRIVER_NAME  L"\\Driver\\ACPI_HAL"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliInitPnpDriver)
#pragma alloc_text(PAGE, HalpMarkAcpiHal)
#pragma alloc_text(PAGE, HalpOpenRegistryKey)
#pragma alloc_text(PAGE, HalpDriverEntry)
#pragma alloc_text(PAGE, HalpAddDevice)
#pragma alloc_text(PAGE, HalpDispatchPnp)
#pragma alloc_text(PAGELK, HalpDispatchPower)
#pragma alloc_text(PAGE, HalpDispatchWmi)
#pragma alloc_text(PAGE, HalpQueryDeviceRelations)
#pragma alloc_text(PAGE, HalpQueryIdPdo)
#pragma alloc_text(PAGE, HalpQueryIdFdo)
#pragma alloc_text(PAGE, HalpQueryCapabilities)
#pragma alloc_text(PAGE, HalpQueryResources)
#pragma alloc_text(PAGE, HalpQueryResourceRequirements)
#pragma alloc_text(PAGE, HalpQueryInterface)
#endif

PDRIVER_OBJECT HalpDriverObject;


NTSTATUS
HaliInitPnpDriver(
    VOID
    )
/*++

Routine Description:

    This routine starts the process of making the HAL into
    a "driver," which is necessary because we need to
    enumerate a Plug and Play PDO for the ACPI driver.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{

    UNICODE_STRING  DriverName;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitUnicodeString( &DriverName, HAL_DRIVER_NAME );

    Status = IoCreateDriver( &DriverName, HalpDriverEntry );

    HalpMarkAcpiHal();

    ASSERT( NT_SUCCESS( Status ));

    return Status;

}

VOID
HalpMarkAcpiHal(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG tmpValue;
    UNICODE_STRING unicodeString;
    HANDLE hCurrentControlSet, handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Open/create System\CurrentControlSet key.
    //

    RtlInitUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");
    status = HalpOpenRegistryKey (
                 &hCurrentControlSet,
                 NULL,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 FALSE
                 );
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\Pnp
    //

    RtlInitUnicodeString(&unicodeString, L"Control\\Pnp");
    status = HalpOpenRegistryKey (
                 &handle,
                 hCurrentControlSet,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 TRUE
                 );
    ZwClose(hCurrentControlSet);
    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&unicodeString, L"DisableFirmwareMapper");
    tmpValue = 1;
    ZwSetValueKey(handle,
                  &unicodeString,
                  0,
                  REG_DWORD,
                  &tmpValue,
                  sizeof(tmpValue)
                  );
    ZwClose(handle);
}

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    PnP Driver Object.  In this function, we need to remember the DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT detectedDeviceObject = NULL;
    ANSI_STRING    AKeyName;

    PAGED_CODE();

    //
    // File the pointer to our driver object away
    //
    HalpDriverObject = DriverObject;

    //
    // Fill in the driver object
    //
    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)HalpAddDevice;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = HalpDispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = HalpDispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = HalpDispatchWmi;

    status = IoReportDetectedDevice(DriverObject,
                                    InterfaceTypeUndefined,
                                    -1,
                                    -1,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    &detectedDeviceObject);

    ASSERT(detectedDeviceObject);
    if (!(NT_SUCCESS(status))) {
        return status;
    }

    HalpAddDevice(DriverObject,
                  detectedDeviceObject);

    return STATUS_SUCCESS;

}

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine handles AddDevice for an madeup PDO device.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{
    PDEVICE_OBJECT functionalDeviceObject;
    PDEVICE_OBJECT childDeviceObject;
    PDEVICE_OBJECT AttachedDevice;
    NTSTATUS       status;
    PFDO_EXTENSION FdoExtension;
    PPDO_EXTENSION PdoExtension;

    PAGED_CODE();

    //
    // We've been given the PhysicalDeviceObject.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(FDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &functionalDeviceObject     // store new device object here
                );

    if( !NT_SUCCESS( status )){

        DbgBreakPoint();
        return status;
    }

    //
    // Fill in the FDO extension
    //
    FdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;
    FdoExtension->ExtensionType = FdoExtensionType;
    FdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    FdoExtension->FunctionalDeviceObject = functionalDeviceObject;

    functionalDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);

    //
    // Now attach to the PDO we were given.
    //

    AttachedDevice = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                                 PhysicalDeviceObject );
    if(AttachedDevice == NULL){

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice( functionalDeviceObject );

        return STATUS_NO_SUCH_DEVICE;

    }

    FdoExtension->AttachedDeviceObject = AttachedDevice;

    //
    // Next, create a PDO for the ACPI driver.
    //
    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(PDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                FALSE,                      // not exclusive
                &childDeviceObject          // store new device object here
                );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Fill in the PDO extension
    //
    PdoExtension = (PPDO_EXTENSION)childDeviceObject->DeviceExtension;
    PdoExtension->ExtensionType = PdoExtensionType;
    PdoExtension->Next = NULL;
    PdoExtension->PhysicalDeviceObject = childDeviceObject;
    PdoExtension->ParentFdoExtension = FdoExtension;
    PdoExtension->PdoType = AcpiDriver;

    childDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);
    //
    // Record this as a child of the HAL
    //
    FdoExtension->ChildPdoList = PdoExtension;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpPassIrpFromFdoToPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    Given an FDO, pass the IRP to the next device object in the
    device stack.  This is the PDO if there are no lower level
    filters.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{

    PIO_STACK_LOCATION irpSp;       // our stack location
    PIO_STACK_LOCATION nextIrpSp;   // next guy's
    PFDO_EXTENSION     fdoExtension;

    //
    // Get the pointer to the device extension.
    //

    fdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Call the PDO driver with the request.
    //

    return IoCallDriver(fdoExtension->AttachedDeviceObject ,Irp);
}

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for madeup PDO device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG length;
    DEVICE_RELATION_TYPE relationType;
    EXTENSION_TYPE  extensionType;
    BOOLEAN passDown;
#if DBG
    PUCHAR objectTypeString;
#endif //DBG

    PAGED_CODE();

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    status = Irp->IoStatus.Status;
    switch (extensionType) {

    case PdoExtensionType:

#if DBG
        objectTypeString = "PDO";
#endif //DBG

        switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            HalPrint(("HAL: (%s) Start_Device Irp received\n",
                      objectTypeString));

            //
            // If we get a start device request for a PDO, we simply
            // return success.
            //

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:

            HalPrint(("(%s) Query_Stop_Device Irp received",
                       objectTypeString));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            HalPrint(("(%s) Cancel_Stop_Device Irp received",
                       objectTypeString));

            status = STATUS_SUCCESS;
            break;


        case IRP_MN_STOP_DEVICE:

            HalPrint(("HAL: (%s) Stop_Device Irp received\n",
                      objectTypeString));

            //
            // If we get a stop device request for a PDO, we simply
            // return success.
            //

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_RESOURCES:

            HalPrint(("HAL: (%s) Query_Resources Irp received\n",
                      objectTypeString));

            status = HalpQueryResources(DeviceObject,
                         (PCM_RESOURCE_LIST*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            HalPrint(("HAL: (%s) Query_Resource_Requirements Irp received\n",
                      objectTypeString));

            status = HalpQueryResourceRequirements(DeviceObject,
                         (PIO_RESOURCE_REQUIREMENTS_LIST*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            HalPrint(("(%s) Query_Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            HalPrint(("(%s) Cancel_Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:

            HalPrint(("HAL: (%s) Remove_device Irp for PDO %x\n",
                      objectTypeString,
                      DeviceObject));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalPrint(("HAL: (%s) Query_Device_Relations Irp received\n",
                      objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;


        case IRP_MN_QUERY_ID:

            HalPrint(("HAL: (%s) Query_Id Irp received\n",
                      objectTypeString));

            status = HalpQueryIdPdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_INTERFACE:

            HalPrint(("HAL: (%s) Query_Interface Irp received\n",
                  objectTypeString));

            status = HalpQueryInterface(
                DeviceObject,
                irpSp->Parameters.QueryInterface.InterfaceType,
                irpSp->Parameters.QueryInterface.Version,
                irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                irpSp->Parameters.QueryInterface.Size,
                irpSp->Parameters.QueryInterface.Interface,
                &Irp->IoStatus.Information
                );
            break;

        case IRP_MN_QUERY_CAPABILITIES:

            HalPrint(("HAL: (%s) Query_Capabilities Irp received\n",
                      objectTypeString));

            status = HalpQueryCapabilities(DeviceObject,
                                           irpSp->Parameters.DeviceCapabilities.Capabilities);

            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            HalPrint(("HAL: DEVICE_USAGE Irp received\n"));
            status = STATUS_SUCCESS;
            break;

        default:

            HalPrint(("HAL: (%s) Unsupported Irp (%d) received\n",
                      objectTypeString,
                      irpSp->MinorFunction));
            status = STATUS_NOT_SUPPORTED ;
            break;
        }

        break;  // end PDO cases

    case FdoExtensionType:

#if DBG
        objectTypeString = "FDO";
#endif //DBG
        passDown = TRUE;

        //
        // In case we don't touch this IRP, save the current status.
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalPrint(("HAL: (%s) Query_Device_Relations Irp received\n",
                  objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_INTERFACE:

            HalPrint(("HAL: (%s) Query_Interface Irp received\n",
                  objectTypeString));

            status = HalpQueryInterface(
                DeviceObject,
                irpSp->Parameters.QueryInterface.InterfaceType,
                irpSp->Parameters.QueryInterface.Version,
                irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                irpSp->Parameters.QueryInterface.Size,
                irpSp->Parameters.QueryInterface.Interface,
                &Irp->IoStatus.Information
                );

            break;

        case IRP_MN_QUERY_ID:

            HalPrint(("HAL: (%s) Query_Id Irp received\n",
                  objectTypeString));

            status = HalpQueryIdFdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        default:

            //
            // Ignore any PNP Irps unknown by the FDO but allow them
            // down to the PDO.
            //

            status = STATUS_NOT_SUPPORTED ;
            break;
        }

        if (passDown && (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED))) {

            //
            // Pass FDO IRPs down to the PDO.
            //
            // Set Irp status first.
            //
            if (status != STATUS_NOT_SUPPORTED) {

                Irp->IoStatus.Status = status;
            }

            HalPrint(("HAL: (%s) Passing down Irp (%x)\n",
                      objectTypeString, irpSp->MinorFunction));
            return HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
        }

        break;  // end FDO cases

    default:

        HalPrint(( "HAL: Received IRP for unknown Device Object\n"));
        status = STATUS_INVALID_DEVICE_REQUEST ;
        break;

    }

    //
    // Complete the Irp and return.
    //

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

    } else {

        status = Irp->IoStatus.Status ;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for madeup PDO device.
    Note: We don't actually handle any Power IRPs at this level so
    all we do is return the status from the incoming IRP.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;
    PIO_STACK_LOCATION irpSp;

    HalPrint(("Hal:  Power IRP for DevObj: %x\n", DeviceObject));


    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Simply store the appropriate status and complete the request.
    //

    Status = Irp->IoStatus.Status;

    PoStartNextPowerIrp(Irp);

    if (extensionType == FdoExtensionType) {

        switch (irpSp->MinorFunction) {
        case IRP_MN_SET_POWER:

            if (irpSp->Parameters.Power.Type == SystemPowerState) {

                switch (irpSp->Parameters.Power.State.SystemState) {
                case PowerSystemSleeping1:
                case PowerSystemSleeping2:
                case PowerSystemSleeping3:
                case PowerSystemHibernate:

                    //
                    // Allocate structures used for starting up
                    // processors while resuming from sleep.
                    //

                    HalpBuildResumeStructures();

                    HalpMaskAcpiInterrupt();

                    break;

                case PowerSystemWorking:

                    HalpUnmaskAcpiInterrupt();

                    //
                    // Free structures used for starting up
                    // processors while resuming from sleep.
                    //

                    HalpFreeResumeStructures();
                    
                    break;

                default:
                    break;
                }
            }

            //
            // Fall through.
            //

        case IRP_MN_QUERY_POWER:

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            //
            // Fall through.
            //

        default:

            Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
            break;
        }

    } else {

        switch (irpSp->MinorFunction) {
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            //
            // Fall through.
            //

        default:
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;
        }
    }

    return Status;
}

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    if (extensionType == FdoExtensionType) {
        Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
    } else {
        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description:

    This routine builds a DEVICE_RELATIONS structure that
    tells the PnP manager how many children we have.

Arguments:

    DeviceObject - FDO of ACPI_HAL

    RelationType - we only respond to BusRelations

    DeviceRelations - pointer to the structure

Return Value:

    status

--*/
{
    PFDO_EXTENSION  FdoExtension;
    PDEVICE_RELATIONS   relations = NULL;
    PDEVICE_OBJECT deviceObjectToReturn ;
    EXTENSION_TYPE  extensionType;
    NTSTATUS status ;

    PAGED_CODE();

    FdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;
    extensionType = FdoExtension->ExtensionType;
    status = STATUS_NOT_SUPPORTED ;

    switch(RelationType) {

        case BusRelations:

            if (extensionType == FdoExtensionType) {
                deviceObjectToReturn = FdoExtension->ChildPdoList->PhysicalDeviceObject ;
                status = STATUS_SUCCESS ;
            }
            break;

        case TargetDeviceRelation:

            if (extensionType == PdoExtensionType) {

                deviceObjectToReturn = DeviceObject ;
                status = STATUS_SUCCESS ;
            }
            break;
    }

    if (status == STATUS_NOT_SUPPORTED) {

        HalPrint(("HAL:  We don't support this kind of device relation\n"));

    } else if (NT_SUCCESS(status)) {

        ASSERT(*DeviceRelations == 0);

        relations = ExAllocatePoolWithTag(
            PagedPool,
            sizeof(DEVICE_RELATIONS),
            HAL_POOL_TAG
            );

        if (!relations) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            relations->Count = 1;
            relations->Objects[0] = deviceObjectToReturn ;

            ObReferenceObject(relations->Objects[0]);
            *DeviceRelations = relations;
        }
    }

    return status ;
}

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned, currently ignored

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString;
    ULONG stringLen;
    static WCHAR AcpiHardwareIdString[] = L"ACPI_HAL\\PNP0C08\0*PNP0C08";
    static WCHAR AcpiCompatibleString[] = L"*PNP0C08";
    static WCHAR AcpiInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        switch (PdoExtension->PdoType) {
        case AcpiDriver:
            sourceString = AcpiHardwareIdString;
            stringLen = sizeof(AcpiHardwareIdString);
            break;

        default:
            return STATUS_NOT_SUPPORTED;

        }
        break;

    case BusQueryCompatibleIDs:
        return STATUS_NOT_SUPPORTED;
        break;

    case BusQueryInstanceID:
        sourceString = AcpiInstanceIdString;
        stringLen = sizeof(AcpiInstanceIdString);
        break;

    default:
        return STATUS_NOT_SUPPORTED;
    }

    idString = ExAllocatePoolWithTag(PagedPool,
                                     stringLen + sizeof(UNICODE_NULL),
                                     HAL_POOL_TAG);

    if (!idString) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(idString,
                  sourceString, stringLen);

    *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

    *BusQueryId = idString;

    return STATUS_SUCCESS;
}
NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    UNICODE_STRING String;
    WCHAR Buffer[16];
    NTSTATUS Status;
    PWCHAR widechar;
    static WCHAR HalInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        //
        // For the UP version of the APIC HAL, we want to detect if there is more
        // than one processor installed. If so, we want to return the ID of
        // the MP HAL rather than the UP HAL. This will induce PNP to reconfigure
        // our devnode and setup the MP HAL for the next boot.
        //

        sourceString = HalHardwareIdString;
#if defined(NT_UP) && defined(APIC_HAL)
        if (HalpMpInfoTable.ProcessorCount > 1) {
            sourceString = MpHalHardwareIdString;
        }
#endif
        widechar = sourceString;
        while (*widechar != UNICODE_NULL) {
            widechar++;
        }
        stringLen =  (PUCHAR)widechar - ((PUCHAR)sourceString) + 2;

        break;

    case BusQueryInstanceID:

        sourceString = HalInstanceIdString;
        stringLen = sizeof(HalInstanceIdString);
        break;

    default:
        break;
    }
    if (sourceString) {

        //
        // Note that hardware IDs and compatible IDs must be terminated by
        // 2 NULLs.
        //

        idString = ExAllocatePoolWithTag(PagedPool,
                                         stringLen + sizeof(UNICODE_NULL),
                                         HAL_POOL_TAG);

        if (!idString) {
            HalPrint(( "HalpQueryIdFdo: couldn't allocate pool\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(idString,
                      sourceString, stringLen);

        *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

        *BusQueryId = idString;

        return STATUS_SUCCESS;
    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    )
/*++

Routine Description:

    This routine fills in the DEVICE_CAPABILITIES structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    Capabilities - pointer to the structure to be filled in.

Return Value:

    status

--*/
{
    PAGED_CODE();

    ASSERT(Capabilities->Version == 1);
    if (Capabilities->Version != 1) {

        return STATUS_NOT_SUPPORTED;

    }

    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = TRUE;
    Capabilities->SilentInstall = TRUE;
    Capabilities->RawDeviceOK = FALSE;
    Capabilities->Address = 0xffffffff;
    Capabilities->UINumber = 0xffffffff;
    Capabilities->D1Latency = 0;
    Capabilities->D2Latency = 0;
    Capabilities->D3Latency = 0;

    //
    // Default S->D mapping
    //
    Capabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
    Capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
    Capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST requirements;
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PCM_RESOURCE_LIST cmResList;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    if (PdoExtension->PdoType == AcpiDriver) {

        //
        // The whole point behind creating a boot config for the
        // ACPI PDO is that the PnP Manager will not terminate
        // its algorithm that tries to reserve boot configs for
        // all of ACPI's children.  So it is not necessary that
        // ACPI have a complicated list of resources in its boot
        // config.  We'll be happy with just the IRQ.
        //
        // N.B.  At the time of this writing, it should also be
        // true that the IRQ is the only resource that the ACPI
        // claims anyhow.
        //

        status = HalpQueryAcpiResourceRequirements(&requirements);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        cmResList = ExAllocatePoolWithTag(PagedPool,
                                          sizeof(CM_RESOURCE_LIST),
                                          HAL_POOL_TAG);

        if (!cmResList) {
            ExFreePool(requirements);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(cmResList, sizeof(CM_RESOURCE_LIST));

        cmResList->Count = 1;
        cmResList->List[0].InterfaceType = PNPBus;
        cmResList->List[0].BusNumber = -1;
        cmResList->List[0].PartialResourceList.Version = 1;
        cmResList->List[0].PartialResourceList.Revision = 1;
        cmResList->List[0].PartialResourceList.Count = 1;
        cmResList->List[0].PartialResourceList.PartialDescriptors[0].Type =
            CmResourceTypeInterrupt;

        ASSERT(requirements->AlternativeLists == 1);

        for (i = 0; i < requirements->List[0].Count; i++) {

            descriptor = &requirements->List[0].Descriptors[i];

            if (descriptor->Type == CmResourceTypeInterrupt) {

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].ShareDisposition =
                    descriptor->ShareDisposition;
                cmResList->List[0].PartialResourceList.PartialDescriptors[0].Flags =
                    descriptor->Flags;

                ASSERT(descriptor->u.Interrupt.MinimumVector ==
                       descriptor->u.Interrupt.MaximumVector);

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Level =
                    descriptor->u.Interrupt.MinimumVector;

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Vector =
                    descriptor->u.Interrupt.MinimumVector;

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Affinity = -1;

                *Resources = cmResList;

                ExFreePool(requirements);
                return STATUS_SUCCESS;
            }
        }

        ExFreePool(requirements);
        ExFreePool(cmResList);
        return STATUS_NOT_FOUND;

    } else {
        return STATUS_NOT_SUPPORTED;
    }
}


NTSTATUS
HalpQueryResourceRequirements(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_RESOURCE_REQUIREMENTS.

Arguments:

    DeviceObject - PDO of the child

    Requirements - pointer to be filled in with the devices
        resource requirements.

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    if (PdoExtension->PdoType == AcpiDriver) {

        return HalpQueryAcpiResourceRequirements(Requirements);

    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    InterfaceType - Pointer to the interface type GUID.

    Version - Supplies the requested interface version.

    InterfaceSpecificData - This is context that means something based on the
                            interface.

    InterfaceBufferSize - Supplies the length of the buffer for the interface
                          structure.

    Interface - Supplies a pointer where the interface informaiton should
                be returned.

    Length - This value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    if (IsEqualGUID(InterfaceType, (PVOID)&GUID_TRANSLATOR_INTERFACE_STANDARD)) {

        PTRANSLATOR_INTERFACE translator = (PTRANSLATOR_INTERFACE)Interface;

        //
        // Common initialization.
        //

        if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {
            *Length = sizeof(TRANSLATOR_INTERFACE);
            return STATUS_BUFFER_TOO_SMALL;
        }

        switch ((CM_RESOURCE_TYPE)InterfaceSpecificData) {

        case CmResourceTypeInterrupt:

            translator->Size = sizeof(TRANSLATOR_INTERFACE);
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->Context = DeviceObject;
            translator->InterfaceReference = HalTranslatorReference;
            translator->InterfaceDereference = HalTranslatorDereference;
            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                HalIrqTranslateResourceRequirementsRoot;

            *Length = sizeof(TRANSLATOR_INTERFACE);

            break;

        default:
            return STATUS_NOT_SUPPORTED ;
        }
        return STATUS_SUCCESS;
    }
#ifdef ACPI_CMOS_ACTIVATE
    else if (IsEqualGUID(InterfaceType, (PVOID) &GUID_ACPI_CMOS_INTERFACE_STANDARD)) {

        PACPI_CMOS_INTERFACE_STANDARD CmosInterface = (PACPI_CMOS_INTERFACE_STANDARD)Interface;

        //
        // Common initialization.
        //

        if (InterfaceBufferSize < sizeof(ACPI_CMOS_INTERFACE_STANDARD)) {

            *Length = sizeof(ACPI_CMOS_INTERFACE_STANDARD);
            return STATUS_BUFFER_TOO_SMALL;
        }

        switch ((CM_RESOURCE_TYPE)InterfaceSpecificData) {

        case CmResourceTypeNull:

            // standard header
            CmosInterface->Size =                   sizeof(ACPI_CMOS_INTERFACE_STANDARD);
            CmosInterface->Version =                1;
            CmosInterface->InterfaceReference =     HalpCmosNullReference;
            CmosInterface->InterfaceDereference =   HalpCmosNullReference;

            // cmos interface specific
            CmosInterface->ReadCmos =               HalpcGetCmosDataByType;
            CmosInterface->WriteCmos =              HalpcSetCmosDataByType;

            *Length = sizeof(ACPI_CMOS_INTERFACE_STANDARD);

            break;

        default:
            return STATUS_NOT_SUPPORTED ;
        }

        return STATUS_SUCCESS;
    }
#endif // ACPI_CMOS_ACTIVATE

    //
    // If we got here, we don't handle this interface type.
    //

    return STATUS_NOT_SUPPORTED ;
}


#ifdef ACPI_CMOS_ACTIVATE

//
// This section implements a CMOS access method
//
VOID
HalpCmosNullReference(
    PVOID Context
    )
{
    return;
}

VOID
HalpCmosNullDereference(
    PVOID Context
    )
{
    return;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixsysbus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixsysbus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixthrotl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixthrotl.c

Abstract:

    This module implements the code for throttling the processors

Author:

    Jake Oshins (jakeo) 17-July-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "pci.h"


VOID
FASTCALL
HalProcessorThrottle (
    IN UCHAR Throttle
    )
/*++

Routine Description:

    This function limits the speed of the processor.

Arguments:

    (ecx) = Throttle setting

Return Value:

    none

--*/
{
    PKPRCB      PrcB;
    PHALPMPRCB  HalPrcB;
    ULONG       ThrottleSetting;
    ULONG       Addr;
    ULONG       Mask;
    ULONG       i;
    ULONG       PblkAddr;

#if DBG
    // debug
    WRITE_PORT_UCHAR ((PUCHAR) 0x80, Throttle);
#endif


    PrcB = KeGetPcr()->Prcb;
    HalPrcB = (PHALPMPRCB) PrcB->HalReserved;
    PblkAddr = HalPrcB->PBlk.Addr;

    ThrottleSetting = READ_PORT_ULONG ((PULONG) PblkAddr);

    if (Throttle == HalpThrottleScale) {

        //
        // If this is a piix4 and we're no longer going to
        // throttle, set the break events (a piix4 thing) to
        // get any interrupt to wake a C2 to C3 stopped
        // processor.  (note that piix4 can only be set on a
        // UP system).  Then clear the bit to allow C2 and C3
        // idle handlers to work again.
        //

        if (HalpPiix4 == 1) {
            HalSetBusDataByOffset (
                PCIConfiguration,
                HalpPiix4BusNumber,
                HalpPiix4SlotNumber,
                &HalpPiix4DevActB,
                0x58,
                sizeof (ULONG)
                );

            HalPrcB->PBlk.AddrAndFlags &= ~PIIX4_THROTTLE_FIX;
        }

        //
        // Throttling is off
        //

        ThrottleSetting &= ~PBLK_THT_EN;
        WRITE_PORT_ULONG ((PULONG) PblkAddr, ThrottleSetting);

    } else {

        //
        // Throttling is on.
        //

        if (HalpPiix4 == 1) {

            //
            // These piix4's have the thottle setting backwards, so
            // invert the value
            //

            Throttle = (UCHAR) HalpThrottleScale - Throttle;
        
            //
            // Piix4 will hang on a high throttle setting, so make
            // sure we don't do that
            //

            if (Throttle < 3) {
                Throttle = 3;
            }

        
        }

        //
        // Shift the throttle and build a mask to be in the proper location
        // for this platform
        //

        Throttle = Throttle << HalpFixedAcpiDescTable.duty_offset;
        Mask = (HalpThrottleScale - 1) << HalpFixedAcpiDescTable.duty_offset;

        //
        // Set the rate
        //

        ThrottleSetting &= ~Mask;
        ThrottleSetting |= Throttle | PBLK_THT_EN;
        WRITE_PORT_ULONG ((PULONG) PblkAddr, ThrottleSetting);

        //
        // If this is a piix4 we need to disable all the break events
        // (a piix4 thing) and then read the level2 processor stop
        // register to get it to start throttling.  Oh yes, also set
        // the bit in the Paddr to stop doing C2 & C3 stops at the
        // same time.
        //

        if (HalpPiix4 == 1) {
            HalPrcB->PBlk.AddrAndFlags |= PIIX4_THROTTLE_FIX;

            i = HalpPiix4DevActB & ~0x23;
            HalSetBusDataByOffset (
                PCIConfiguration,
                HalpPiix4BusNumber,
                HalpPiix4SlotNumber,
                &i,
                0x58,
                sizeof(ULONG)
                );

            READ_PORT_UCHAR ((PUCHAR) PblkAddr + P_LVL2);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixthunk.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixthunk.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\ixusage.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixusage.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpclockc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpclockc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mmtimer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mmtimer.c

Abstract:

    This module contains the HAL's multimedia event timer support

Author:

    Eric Nelson (enelson) July 7, 2000

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "mmtimer.h"
#include "xxtimer.h"

//
// Event timer block context
//
static ETB_CONTEXT ETBContext = { 0,        // Number of event timers
                                  NULL,     // VA of event timer block
                                  { 0, 0 }, // PA of event timer block
                                  100,      // Clock period in nanoseconds
                                  100,      // System clock frequency in Hz
                                  100000,   // System clock period in ticks
                                  FALSE,    // Multi media HW initialized?
                                  FALSE };  // Change system clock frequency?

//
// Event timer block registers address usage
//
static ADDRESS_USAGE HalpmmTimerResource = {
    NULL, CmResourceTypeMemory, DeviceUsage, { 0, 0x400, 0, 0 }
};

//
// Offset is the difference between the multi media timer HW's main
// 32-bit counter register and the HAL's 64-bit software PerfCount:
//
// ASSERT(PerfCount == ETBContext.EventTimer->MainCounter + Offset);
//
static LONGLONG Offset = 0;
static ULONGLONG PerfCount = 0;

#define HAL_PRIMARY_PROCESSOR 0
#define MAX_ULONG 0xFFFFFFFF
#define __4GB 0x100000000

#define __1MHz     1000000
#define __10MHz   10000000
#define __1GHz  1000000000

#define HALF(n) ((n) / 2)

#if DBG || MMTIMER_DEV
static ULONG CounterReads = 0;
#endif

#define MIN_LOOP_QUANTUM 1
static ULONG MinLoopCount = MIN_LOOP_QUANTUM;
static UCHAR StallCount = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpmmTimer)
#pragma alloc_text(INIT, HalpmmTimerInit)
#pragma alloc_text(INIT, HalpmmTimerClockInit)
#pragma alloc_text(INIT, HalpmmTimerCalibratePerfCount)
#endif


BOOLEAN
HalpmmTimer(
    VOID
    )
/*++

Routine Description:

    This routine is used to determine if multi media timer HW is
    present, and has been initialized

    note: this routine should only used during HAL init

Arguments:

    None

Return Value:

    TRUE if the multi media timer HW is present, and has been initialized

--*/
{
    return ETBContext.Initialized;
}


ULONG
HalpmmTimerSetTimeIncrement(
    IN ULONG DesiredIncrement
    )
/*++

Routine Description:

    This routine initialize system time clock to generate an
    interrupt at every DesiredIncrement interval

Arguments:

     DesiredIncrement - Desired interval between every timer tick (in
                        100ns unit)

Return Value:

     The *REAL* time increment set

--*/
{
    //
    // For starters we will only support a default system clock
    // frequency of 10ms
    //
    // 100ns = 1/10MHz, and (1/SysClock) / (1/10MHz) == 10MHz/SysClock, .:.
    //
    return __10MHz / ETBContext.SystemClockFrequency;
}


VOID
HalpmmTimerClockInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the system clock using the multi media event
    timer to generate an interrupt every 10ms

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG MinSysClockFreq;
    ULONG MaxSysClockFreq;
    ETB_GEN_CONF GenConf;
    ETB_CONF_CAPS mmT0ConfCaps;

    //
    // Reset the main counter and its associated performance variables
    // to 0, nobody should be using them this early
    //
    GenConf.AsULONG = ETBContext.EventTimer->GeneralConfig;
    GenConf.GlobalIRQEnable = OFF;
    ETBContext.EventTimer->GeneralConfig = GenConf.AsULONG;
    ETBContext.EventTimer->MainCounter = 0;
    Offset = 0;
    PerfCount = 0;

    //
    // Initialize multi media context for a default system clock
    // freuqency of 100Hz, with a period of 10ms
    //
    ETBContext.SystemClockFrequency = 100;
    ETBContext.SystemClockTicks = __1GHz /
        (ETBContext.SystemClockFrequency * ETBContext.ClockPeriod);

    //
    // Setup timer 0 for periodc mode
    //
    mmT0ConfCaps.AsULONG =
        ETBContext.EventTimer->mmTimer[0].ConfigCapabilities;

    ASSERT(mmT0ConfCaps.PeriodicCapable == ON);

    mmT0ConfCaps.ValueSetConfig = ON;
    mmT0ConfCaps.IRQEnable = ON;
    mmT0ConfCaps.PeriodicModeEnable = ON;
    ETBContext.EventTimer->mmTimer[0].ConfigCapabilities =
        mmT0ConfCaps.AsULONG;

    //
    // Set comparator to the desired system clock frequency
    //
    ETBContext.EventTimer->mmTimer[0].Comparator = ETBContext.SystemClockTicks;

    //
    // Fire up the main counter
    //
    GenConf.AsULONG = ETBContext.EventTimer->GeneralConfig;
    GenConf.GlobalIRQEnable = ON;
    ETBContext.EventTimer->GeneralConfig = GenConf.AsULONG;

    //
    // Inform kernel of our supported system clock frequency range in
    // 100ns units, but for starters we will only support 10ms default
    //
    MinSysClockFreq = __10MHz / ETBContext.SystemClockFrequency;
    MaxSysClockFreq = MinSysClockFreq;
#ifndef MMTIMER_DEV
    KeSetTimeIncrement(MinSysClockFreq, MaxSysClockFreq);
#endif
}

#ifdef MMTIMER_DEV
static ULONG HalpmmTimerClockInts = 0;
#endif


VOID
HalpmmTimerClockInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    CLOCK, update our performance count and change system clock frequency
    if necessary

Arguments:

    None

 Return Value:

    None

--*/
{
    //
    // Update PerfCount
    //
    PerfCount += ETBContext.SystemClockTicks;

    //
    // If the 32-bit counter has wrapped, update Offset accordingly
    //
    if (PerfCount - Offset > MAX_ULONG) {
        Offset += __4GB;
    }

#ifdef MMTIMER_DEV
    HalpmmTimerClockInts++;
#endif

    //
    // Check if a new frequency has been requested
    //
    if (ETBContext.NewClockFrequency) {

        //
        // ???
        //

        ETBContext.NewClockFrequency = FALSE;
    }
}


VOID
HalpmmTimerInit(
    IN ULONG EventTimerBlockID,
    IN ULONG BaseAddress
    )
/*++

Routine Description:

    This routine initializes the multimedia event timer

Arguments:

    EventTimerBlockID - Various bits of info, including number of Event
                        Timers

    BaseAddress - Physical Base Address of 1st Event Timer Block
    
Return Value:

    None

--*/
{
    ULONG i;
    ETB_GEN_CONF GenConf;
    ETB_GEN_CAP_ID GenCaps;
    PHYSICAL_ADDRESS PhysAddr;
    PEVENT_TIMER_BLOCK EventTimer;

    TIMER_FUNCTIONS TimerFunctions = { HalpmmTimerStallExecProc,
                                       HalpmmTimerCalibratePerfCount,
                                       HalpmmTimerQueryPerfCount,
                                       HalpmmTimerSetTimeIncrement };

#if MMTIMER_DEV && PICACPI
    {
        UCHAR Data;
        
        //
        // (BUGBUG!) BIOS should enable the device
        //
        Data = 0x87;
        HalpPhase0SetPciDataByOffset(0,
                                     9,
                                     &Data,
                                     4,
                                     sizeof(Data));
    }
#endif

    //
    // Establish VA for Multimedia Timer HW Base Address
    //
    PhysAddr.QuadPart = BaseAddress;
    EventTimer = HalpMapPhysicalMemoryWriteThrough(PhysAddr, 1);

    //
    // Register address usage
    //    
    HalpmmTimerResource.Element[0].Start = BaseAddress;
    HalpRegisterAddressUsage(&HalpmmTimerResource);

    //
    // Read the General Capabilities and ID Register
    //
    GenCaps.AsULONG = EventTimer->GeneralCapabilities;

    //
    // Save context
    //
    ETBContext.TimerCount = GenCaps.TimerCount + 1; // Convert from zero-based
    ETBContext.BaseAddress.QuadPart = BaseAddress;
    ETBContext.EventTimer = EventTimer;
    ETBContext.NewClockFrequency = FALSE;

    //
    // Save clock period as nanoseconds, convert from femptoseconds so
    // we don't have to worry about nasty overflow
    //
#ifndef MMTIMER_DEV
    ETBContext.ClockPeriod = EventTimer->ClockPeriod / __1MHz;
#else
    ETBContext.ClockPeriod = 100; // Proto HW is 10MHz, with a period of 100ns
#endif

    //
    // Reset the main counter and its associated performance counter
    // variables
    //
    GenConf.AsULONG = EventTimer->GeneralConfig;
    GenConf.GlobalIRQEnable = ON;
    //GenConf.LegacyIRQRouteEnable = ON;
    EventTimer->MainCounter = 0;
    Offset = 0;
    PerfCount = 0;   
    EventTimer->GeneralConfig = GenConf.AsULONG;

    //
    // Set HAL timer functions to use Multimedia Timer HW
    //
    HalpSetTimerFunctions(&TimerFunctions);

    ETBContext.Initialized = TRUE; 
}


//ULONG
//HalpmmTimerTicks(
//    IN ULONG StartCount,
//    IN ULONG EndCount
//    )
///*++
//
//Routine Description:
//
//    Calculate the difference in ticks between StartCount and EndCount
//    taking into consideraton counter rollover
//
//Arguments:
//
//    StartCount - Value of main counter at time t0
//
//    EndCount - Value of main counter at end time t1
//
//Return Value:
//
//    Returns the positive number of ticks which have elapsed between time
//    t0, and t1
//
//--*/
//
#define HalpmmTimerTicks(StartCount, EndCount) (((EndCount) >= (StartCount)) ? (EndCount) - (StartCount): (EndCount) + (MAX_ULONG - (StartCount)) + 1)

#define WHACK_HIGH_DIFF 0xFFFF0000
#define ULONG_BITS 32


VOID
HalpmmTimerStallExecProc(
    IN ULONG MicroSeconds
    )
/*++

Routine Description:

    This function stalls execution for the specified number of microseconds

Arguments:

    MicroSeconds - Supplies the number of microseconds that execution is to be
                   stalled

 Return Value:

    None

--*/
{
    ULONG i;
#ifndef i386
    ULONG j;
    ULONG Mirror;
#endif
    ULONG EndCount;
    ULONG StartCount;
    ULONG TargetTicks;
    ULONG ElapsedTicks;
    ULONG CyclesStalled;    
    ULONG TicksPerMicroSec;

    ElapsedTicks = 0;
    CyclesStalled = 0;
#if DBG || MMTIMER_DEV
    CounterReads = 0;
#endif

    TicksPerMicroSec = 1000 / ETBContext.ClockPeriod;
    TargetTicks = MicroSeconds * TicksPerMicroSec;
    StartCount = ETBContext.EventTimer->MainCounter;

    //
    // BIAS: We've stalled for .5us already!
    //
    TargetTicks -= HALF(TicksPerMicroSec);

    //
    // Get a warm fuzzy for what it's like to stall for more than .5us
    //
    while (TRUE) {

#ifdef i386
        _asm { rep nop }
#endif

        i = MinLoopCount;
        CyclesStalled += i;

        while (i--) {
#ifdef i386
            _asm {
                xor eax, eax
                cpuid
            }
#else
            Mirror = 0;
            for (j = 0; j < ULONG_BITS; j++) {
                Mirror <<= 1;
                Mirror |= EndCount & 1;
                EndCount >>= 1;
            }
            EndCount = Mirror;
#endif // i386
        }

        EndCount = ETBContext.EventTimer->MainCounter;
#if DBG || MMTIMER_DEV
        CounterReads++;
#endif
        ElapsedTicks = HalpmmTimerTicks(StartCount, EndCount);

        if (ElapsedTicks >= HALF(TicksPerMicroSec)) {
            break;
        }

        MinLoopCount += MIN_LOOP_QUANTUM;
    }

#ifdef MMTIMER_DEV
    //
    // Something is whack, probably time went backwards!  Act as if we
    // hit our target of .5us and reset StartCount to the current value
    // less ElapsedTicks
    //
    if (ElapsedTicks > WHACK_HIGH_DIFF) {
        ElapsedTicks = HALF(TicksPerMicroSec);
        StartCount = EndCount - ElapsedTicks;
    }
#endif // 