pThisDev->pUsbInfo)->IrpSubmitUrb )
    {
        DEBUGMSG(DBG_ERR, (" IrUsb_CallUsbd failed to alloc IRP\n"));
		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb->IoStatus.Status = STATUS_PENDING;
    ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb->IoStatus.Information = 0;

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //
    pNextStack = IoGetNextIrpStackLocation( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb );
    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(
			((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb,      // irp to use
			UsbIoCompleteControl,			// routine to call when irp is done
			DEV_TO_CONTEXT(pThisDev),		// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventAsyncUrb );

    ntStatus = MyIoCallDriver(
			pThisDev,
			pUrbTargetDev,
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb
		);

    DEBUGMSG( DBG_OUT,(" IrUsb_CallUSBD () return from IoCallDriver USBD %x\n", ntStatus));

    if( (ntStatus == STATUS_PENDING) || (ntStatus == STATUS_SUCCESS) )
	{
        //
		// wait, but dump out on timeout
        //
		if( ntStatus == STATUS_PENDING )
		{
            ntStatus = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventAsyncUrb, NULL, 0 );

            if( ntStatus == STATUS_TIMEOUT ) 
			{
                DEBUGMSG( DBG_ERR,(" IrUsb_CallUSBD () TIMED OUT! return from IoCallDriver USBD %x\n", ntStatus));
				IrUsb_CancelIo( 
						pThisDev, 
						((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb, 
						&pThisDev->EventAsyncUrb 
					);
            }
			else
			{
				//
				// Update the status to reflect the real return code
				//
				ntStatus = pThisDev->StatusControl;
			}
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, ("IrUsb_CallUSBD IoCallDriver FAILED(%x)\n",ntStatus));
    }

    DEBUGMSG( DBG_OUT,("IrUsb_CallUSBD () URB status = %x  IRP status = %x\n", pUrb->UrbHeader.Status, ntStatus ));

done:
	((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb = NULL;

    DEBUGCOND( DBG_ERR, !NT_SUCCESS( ntStatus ), (" exit IrUsb_CallUSBD FAILED (%x)\n", ntStatus));
    DEBUGMSG( DBG_FUNC,("-IrUsb_CallUSBD\n"));

    return ntStatus;
}



/*****************************************************************************
*
*  Function:	IrUsb_ResetUSBD
*
*  Synopsis:	Passes a URB to the USBD class driver, forcing the latter to reset or part
*
*  Arguments:	pThisDev - pointer to the IR device
*				ForceUnload - flag to perform a reset or an unload
*	
*  Returns:		STATUS_SUCCESS if successful,
*				STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_ResetUSBD(
		IN PIR_DEVICE pThisDev,
		BOOLEAN ForceUnload
    )
{
    NTSTATUS			ntStatus;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;

    DEBUGMSG( DBG_FUNC,("+IrUsb_ResetUSBD\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    IRUSB_ASSERT( pThisDev );
    IRUSB_ASSERT( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb );  //shouldn't be multiple control calls pending

    //
    // issue a synchronous request (we'll wait )
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

    IRUSB_ASSERT( pUrbTargetDev );

	// make an irp sending to usbhub
	((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb = 
		IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb )
    {
        DEBUGMSG(DBG_ERR, (" IrUsb_ResetUSBD failed to alloc IRP\n"));
		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb->IoStatus.Status = STATUS_PENDING;
    ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb->IoStatus.Information = 0;

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //
    pNextStack = IoGetNextIrpStackLocation( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb );
    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	if( ForceUnload )
		pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_CYCLE_PORT;
	else
		pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_RESET_PORT;

    IoSetCompletionRoutine(
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb,      // irp to use
			UsbIoCompleteControl,			// routine to call when irp is done
			DEV_TO_CONTEXT(pThisDev),		// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventAsyncUrb );

    ntStatus = MyIoCallDriver(
			pThisDev,
			pUrbTargetDev,
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb
		);

    DEBUGMSG( DBG_OUT,(" IrUsb_ResetUSBD () return from IoCallDriver USBD %x\n", ntStatus));

    if( (ntStatus == STATUS_PENDING) || (ntStatus == STATUS_SUCCESS) )
	{
        //
		// wait, but dump out on timeout
        //
		if( ntStatus == STATUS_PENDING )
		{
            ntStatus = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventAsyncUrb, NULL, 0 );

            if( ntStatus == STATUS_TIMEOUT ) 
			{
                DEBUGMSG( DBG_ERR,(" IrUsb_ResetUSBD () TIMED OUT! return from IoCallDriver USBD %x\n", ntStatus));
				IrUsb_CancelIo( 
						pThisDev, 
						((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb, 
						&pThisDev->EventAsyncUrb 
					);
            }
			else
			{
				//
				// Update the status to reflect the real return code
				//
				ntStatus = pThisDev->StatusControl;
			}
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, ("IrUsb_ResetUSBD IoCallDriver FAILED(%x)\n",ntStatus));
    }

done:
	((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb = NULL;

    DEBUGCOND( DBG_ERR, !NT_SUCCESS( ntStatus ), (" exit IrUsb_ResetUSBD FAILED (%x)\n", ntStatus));
    DEBUGMSG( DBG_FUNC,("-IrUsb_ResetUSBD\n"));

    return ntStatus;
}


/*****************************************************************************
*
*  Function:   UsbIoCompleteControl
*
*  Synopsis:   General completetion routine just to insure cancel-ability of control calls
*              and keep track of pending irp count
*
*  Arguments:  pUsbDevObj - pointer to the  device object which
*                              completed the irp
*              pIrp          - the irp which was completed by the  device
*                              object
*              Context       - dev ext
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*
*****************************************************************************/
NTSTATUS
UsbIoCompleteControl(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE  pThisDev;
    NTSTATUS    status;

    DEBUGMSG(DBG_FUNC, ("+UsbIoCompleteControl\n"));

    //
    // The context given to IoSetCompletionRoutine is simply the the ir
    // device object pointer.
    //
    pThisDev = CONTEXT_TO_DEV( Context );

    status = pIrp->IoStatus.Status;

    switch( status )
    {
        case STATUS_SUCCESS:
            DEBUGMSG(DBG_OUT, (" UsbIoCompleteControl STATUS_SUCCESS\n"));
            break; // STATUS_SUCCESS

        case STATUS_TIMEOUT:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_TIMEOUT\n"));
            break;

        case STATUS_PENDING:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_PENDING\n"));
            break;

        case STATUS_DEVICE_DATA_ERROR:
			// can get during shutdown
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_DEVICE_DATA_ERROR\n"));
            break;

        case STATUS_UNSUCCESSFUL:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_UNSUCCESSFUL\n"));
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_INSUFFICIENT_RESOURCES\n"));
            break;

        case STATUS_INVALID_PARAMETER:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_INVALID_PARAMETER\n"));
            break;

        case STATUS_CANCELLED:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_CANCELLED\n"));
            break;

        case STATUS_DEVICE_NOT_CONNECTED:
			// can get during shutdown
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_DEVICE_NOT_CONNECTED\n"));
            break;

        case STATUS_DEVICE_POWER_FAILURE:
			// can get during shutdown
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_DEVICE_POWER_FAILURE\n"));
            break;

        default:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl UNKNOWN WEIRD STATUS = 0x%x, dec %d\n",status,status ));
            break;
    }

	IrUsb_DecIoCount( pThisDev );  //we track pending irp count

	if( pIrp == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb ) 
	{
		IRUSB_ASSERT( NULL != ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb );

		IoFreeIrp( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb );

		pThisDev->StatusControl = status; // save status because can't use irp after completion routine is hit!
		KeSetEvent( &pThisDev->EventAsyncUrb, 0, FALSE );  //signal we're done
	} 
	else 
	{
		DEBUGMSG( DBG_ERR, (" UsbIoCompleteControl UNKNOWN IRP\n"));
		IRUSB_ASSERT( 0 );
	}

    DEBUGCOND(DBG_ERR, !( NT_SUCCESS( status ) ), ("UsbIoCompleteControl BAD status = 0x%x\n", status));

    DEBUGMSG(DBG_FUNC, ("-UsbIoCompleteControl\n"));

	//
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the completion
    // routine (IofCompleteRequest) will stop working on the irp.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*****************************************************************************
*
*  Function:	IrUsb_ConfigureDevice
*
*  Synopsis:	Initializes a given instance of the device on the USB and
*				selects and saves the configuration.
*
*  Arguments:	pThisDev - pointer to the IR device
*	
*  Returns:		NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_ConfigureDevice(
		IN OUT PIR_DEVICE pThisDev
    )
{
    NTSTATUS	ntStatus;
    PURB		pUrb;
    ULONG		UrbSize;

    DEBUGMSG(DBG_FUNC,("+IrUsb_ConfigureDevice()\n"));

	IRUSB_ASSERT( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor == NULL );

    pUrb = (PURB)&((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->DescriptorUrb;
	
	//
	// When USB_CONFIGURATION_DESCRIPTOR_TYPE is specified for DescriptorType
	// in a call to UsbBuildGetDescriptorRequest(),
	// all interface, endpoint, class-specific, and vendor-specific descriptors
	// for the configuration also are retrieved.
	// The caller must allocate a buffer large enough to hold all of this
	// information or the data is truncated without error.
	// Therefore the 'siz' set below is just a 'good guess', and we may have to retry
	//
    UrbSize = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 512;  // Store size, may need to free

	//
	// We will break out of this 'retry loop' when UsbBuildGetDescriptorRequest()
	// has a big enough pThisDev->UsbConfigurationDescriptor buffer not to truncate
	//
	while( TRUE ) 
	{
		((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor = MyMemAlloc( UrbSize );

		if( !((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationDescriptor ) 
		{
		    MyMemFree( pUrb, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST) );
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		UsbBuildGetDescriptorRequest(
				pUrb,
				(USHORT) sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
				USB_CONFIGURATION_DESCRIPTOR_TYPE,
				0,
				0,
				((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor,
				NULL,
				UrbSize,
				NULL
			);

		ntStatus = IrUsb_CallUSBD( pThisDev, pUrb ); //Get Usb Config Descriptor; done in main thread

		DEBUGMSG(DBG_OUT,(" IrUsb_ConfigureDevice() Configuration Descriptor = %x, len %x\n",
						((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationDescriptor,
						pUrb->UrbControlDescriptorRequest.TransferBufferLength));
		//
		// if we got some data see if it was enough.
		// NOTE: we may get an error in URB because of buffer overrun
		if( (pUrb->UrbControlDescriptorRequest.TransferBufferLength > 0) &&
				(((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor->wTotalLength > UrbSize) &&
				NT_SUCCESS(ntStatus) ) 
		{ 
			MyMemFree( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor, UrbSize );
			UrbSize = ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor->wTotalLength;
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor = NULL;
		} 
		else 
		{
			break;  // we got it on the first try
		}

	} // end, while (retry loop )

	IRUSB_ASSERT( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationDescriptor );

    if( !NT_SUCCESS(ntStatus) ) 
	{
        DEBUGMSG( DBG_ERR,(" IrUsb_ConfigureDevice() Get Config Descriptor FAILURE (%x)\n", ntStatus));
        goto done;
    }

    //
    // We have the configuration descriptor for the configuration we want.
    // Now we issue the select configuration command to get
    // the  pipes associated with this configuration.
    //
    ntStatus = IrUsb_SelectInterface(
			pThisDev,
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor
		);

    if( !NT_SUCCESS(ntStatus) ) 
	{
        DEBUGMSG( DBG_ERR,(" IrUsb_ConfigureDevice() IrUsb_SelectInterface() FAILURE (%x)\n", ntStatus));
    } 
	
done:
    DEBUGMSG(DBG_FUNC,("-IrUsb_ConfigureDevice (%x)\n", ntStatus));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_SelectInterface
*
*  Synopsis:    Initializes the ST4200 interfaces;
*				This minidriver only supports one interface (with multiple endpoints).
*
*  Arguments:	pThisDev - pointer to IR device
*				pConfigurationDescriptor - pointer to USB configuration descriptor
*	
*  Returns:		NT status code
*
*  Notes:		
*
*****************************************************************************/
NTSTATUS
IrUsb_SelectInterface(
		IN OUT PIR_DEVICE pThisDev,
		IN PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor
    )
{
    NTSTATUS	ntStatus;
    PURB		pUrb = NULL;
    ULONG		i;
    USHORT		DescriptorSize;
    PUSB_INTERFACE_DESCRIPTOR		pInterfaceDescriptor = NULL;
	PUSBD_INTERFACE_INFORMATION		pInterface = NULL;

    DEBUGMSG(DBG_FUNC,("+IrUsb_SelectInterface\n"));

    IRUSB_ASSERT( pConfigurationDescriptor != NULL );
    IRUSB_ASSERT( pThisDev != NULL );
	
	//
    // IrUsb driver only supports one interface, we must parse
    // the configuration descriptor for the interface
    // and remember the pipes. Needs to be aupdated
    //
    pUrb = USBD_CreateConfigurationRequest( pConfigurationDescriptor, &DescriptorSize );

    if( pUrb ) 
	{
        DEBUGMSG(DBG_OUT,(" USBD_CreateConfigurationRequest created the urb\n"));

		//
		// USBD_ParseConfigurationDescriptorEx searches a given configuration
		// descriptor and returns a pointer to an interface that matches the
		// given search criteria. We only support one interface on this device
		//
        pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
				pConfigurationDescriptor,
				pConfigurationDescriptor,	// search from start of config descriptor
				-1,							// interface number not a criteria; we only support one interface
				-1,							// not interested in alternate setting here either
				-1,							// interface class not a criteria
				-1,							// interface subclass not a criteria
				-1							// interface protocol not a criteria
			);

		if( !pInterfaceDescriptor ) 
		{
			DEBUGMSG(DBG_ERR,("IrUsb_SelectInterface() ParseConfigurationDescriptorEx() failed\n  returning STATUS_INSUFFICIENT_RESOURCES\n"));
		    
			//
			// don't call the MyMemFree since the buffer was
		    //  alloced by USBD_CreateConfigurationRequest, not MyMemAlloc()
            //
			ExFreePool( pUrb );
			return STATUS_INSUFFICIENT_RESOURCES;
		}

        pInterface = &pUrb->UrbSelectConfiguration.Interface;

        DEBUGMSG(DBG_OUT,(" After USBD_CreateConfigurationRequest, before UsbBuildSelectConfigurationRequest\n" ));
        
		//
		// Now prepare the pipes
		//
		for( i=0; i<pInterface->NumberOfPipes; i++ ) 
		{
            //
            // perform any pipe initialization here; mainly set max xfer size
            // But Watch out! USB may change these when you select the interface;
            // In general USB doesn;t seem to like differing max transfer sizes on the pipes
            //
            pInterface->Pipes[i].MaximumTransferSize = STIR4200_FIFO_SIZE;
        }

        //
		// Initialize the device with the pipe structure found
		//
		UsbBuildSelectConfigurationRequest( pUrb, DescriptorSize, pConfigurationDescriptor );
        ntStatus = IrUsb_CallUSBD( pThisDev, pUrb ); //select config; done in main thread
        ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationHandle =
            pUrb->UrbSelectConfiguration.ConfigurationHandle;
    } 
	else 
	{
        DEBUGMSG(DBG_ERR,(" IrUsb_SelectInterface() USBD_CreateConfigurationRequest() failed\n  returning STATUS_INSUFFICIENT_RESOURCES\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( NT_SUCCESS(ntStatus) ) 
	{
        //
        // Save the configuration handle for this device
        //
        ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationHandle =
            pUrb->UrbSelectConfiguration.ConfigurationHandle;

		if( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface ) 
		{
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface = MyMemAlloc( pInterface->Length );
		}

        if( NULL != ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface ) 
		{
            ULONG j;

            //
            // save a copy of the interface information returned
            //
            RtlCopyMemory( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface, pInterface, pInterface->Length );

            //
            // Dump the interface to the debugger
            //
            DEBUGMSG(DBG_FUNC,("---------After Select Config \n"));
            DEBUGMSG(DBG_FUNC,("NumberOfPipes 0x%x\n", ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->NumberOfPipes));
            DEBUGMSG(DBG_FUNC,("Length 0x%x\n", ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->Length));
            DEBUGMSG(DBG_FUNC,("Alt Setting 0x%x\n", ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->AlternateSetting));
            DEBUGMSG(DBG_FUNC,("Interface Number 0x%x\n", ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->InterfaceNumber));
            DEBUGMSG(DBG_FUNC,("Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->Class,
                ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->SubClass,
                ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->Protocol));

            //
			// Find our Bulk in and out pipes, save their handles, Dump the pipe info
            //
			for( j=0; j<pInterface->NumberOfPipes; j++ ) 
			{
                PUSBD_PIPE_INFORMATION pipeInformation;

                pipeInformation = &((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->Pipes[j];

                //
				// Find the Bulk In and Out pipes ( these are probably the only two pipes )
                //
				if( UsbdPipeTypeBulk == pipeInformation->PipeType )
                {
                    // endpoint address with bit 0x80 set are input pipes, else output
                    if( USB_ENDPOINT_DIRECTION_IN( pipeInformation->EndpointAddress ) ) 
					{
                        pThisDev->BulkInPipeHandle = pipeInformation->PipeHandle;
                    }

                    if( USB_ENDPOINT_DIRECTION_OUT( pipeInformation->EndpointAddress ) ) 
					{
                        pThisDev->BulkOutPipeHandle = pipeInformation->PipeHandle;
                    }

                }

                DEBUGMSG(DBG_FUNC,("---------\n"));
                DEBUGMSG(DBG_FUNC,("PipeType 0x%x\n", pipeInformation->PipeType));
                DEBUGMSG(DBG_FUNC,("EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                DEBUGMSG(DBG_FUNC,("MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                DEBUGMSG(DBG_FUNC,("Interval 0x%x\n", pipeInformation->Interval));
                DEBUGMSG(DBG_FUNC,("Handle 0x%x\n", pipeInformation->PipeHandle));
                DEBUGMSG(DBG_FUNC,("MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize));
            }

            DEBUGMSG(DBG_FUNC,("---------\n"));
        }
    }

    //
	// we better have found input and output bulk pipes!
    //
	IRUSB_ASSERT( pThisDev->BulkInPipeHandle && pThisDev->BulkOutPipeHandle );
	if( !pThisDev->BulkInPipeHandle || !pThisDev->BulkOutPipeHandle )
	{
		DEBUGMSG(DBG_ERR,("IrUsb_SelectInterface() failed to get pipes\n"));
		ntStatus = STATUS_UNSUCCESSFUL;
	}

    if( pUrb ) 
	{
		//
		// don't call the MyMemFree since the buffer was
		//  alloced by USBD_CreateConfigurationRequest, not MyMemAlloc()
        //
		ExFreePool( pUrb );
    }

    DEBUGMSG(DBG_FUNC,("-IrUsb_SelectInterface (%x)\n", ntStatus));

    return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_StartDevice
*
*  Synopsis:	Initializes a given instance of the device on the USB.
*				USB client drivers such as us set up URBs (USB Request Packets) to send requests
*				to the host controller driver (HCD). The URB structure defines a format for all
*				possible commands that can be sent to a USB device.
*				Here, we request the device descriptor and store it, and configure the device.
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		NT status code
*
*  Notes:		
*
*****************************************************************************/
NTSTATUS
IrUsb_StartDevice(
		IN PIR_DEVICE pThisDev
	)
{
    NTSTATUS				ntStatus;
    PUSB_DEVICE_DESCRIPTOR	pDeviceDescriptor = NULL;
    PURB					pUrb;
    ULONG					DescriptorSize;

    DEBUGMSG( DBG_FUNC, ("+IrUsb_StartDevice()\n"));

    pUrb = MyMemAlloc( sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    DEBUGCOND( DBG_ERR,!pUrb, (" IrUsb_StartDevice() FAILED MyMemAlloc() for URB\n"));

    if( pUrb ) 
	{
        DescriptorSize = sizeof( USB_DEVICE_DESCRIPTOR );

        pDeviceDescriptor = MyMemAlloc( DescriptorSize );

        DEBUGCOND( DBG_ERR, !pDeviceDescriptor, (" IrUsb_StartDevice() FAILED MyMemAlloc() for deviceDescriptor\n"));

        if( pDeviceDescriptor ) 
		{
            //
			// Get all the USB descriptor data
			//
			UsbBuildGetDescriptorRequest(
					pUrb,
					(USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
					USB_DEVICE_DESCRIPTOR_TYPE,
					0,
					0,
					pDeviceDescriptor,
					NULL,
					DescriptorSize,
					NULL
				);

            ntStatus = IrUsb_CallUSBD( pThisDev, pUrb ); // build get descripttor req; main thread

            DEBUGCOND( DBG_ERR, !NT_SUCCESS(ntStatus), (" IrUsb_StartDevice() FAILED IrUsb_CallUSBD (pThisDev, pUrb)\n"));

            if( NT_SUCCESS(ntStatus) ) 
			{
                DEBUGMSG( DBG_FUNC,("Device Descriptor = %x, len %x\n",
                                pDeviceDescriptor,
                                pUrb->UrbControlDescriptorRequest.TransferBufferLength));

                DEBUGMSG( DBG_FUNC,("IR Dongle Device Descriptor:\n"));
                DEBUGMSG( DBG_FUNC,("-------------------------\n"));
                DEBUGMSG( DBG_FUNC,("bLength %d\n", pDeviceDescriptor->bLength));
                DEBUGMSG( DBG_FUNC,("bDescriptorType 0x%x\n", pDeviceDescriptor->bDescriptorType));
                DEBUGMSG( DBG_FUNC,("bcdUSB 0x%x\n", pDeviceDescriptor->bcdUSB));
                DEBUGMSG( DBG_FUNC,("bDeviceClass 0x%x\n", pDeviceDescriptor->bDeviceClass));
                DEBUGMSG( DBG_FUNC,("bDeviceSubClass 0x%x\n", pDeviceDescriptor->bDeviceSubClass));
                DEBUGMSG( DBG_FUNC,("bDeviceProtocol 0x%x\n", pDeviceDescriptor->bDeviceProtocol));
                DEBUGMSG( DBG_FUNC,("bMaxPacketSize0 0x%x\n", pDeviceDescriptor->bMaxPacketSize0));
                DEBUGMSG( DBG_FUNC,("idVendor 0x%x\n", pDeviceDescriptor->idVendor));
                DEBUGMSG( DBG_FUNC,("idProduct 0x%x\n", pDeviceDescriptor->idProduct));
                DEBUGMSG( DBG_FUNC,("bcdDevice 0x%x\n", pDeviceDescriptor->bcdDevice));
                DEBUGMSG( DBG_FUNC,("iManufacturer 0x%x\n", pDeviceDescriptor->iManufacturer));
                DEBUGMSG( DBG_FUNC,("iProduct 0x%x\n", pDeviceDescriptor->iProduct));
                DEBUGMSG( DBG_FUNC,("iSerialNumber 0x%x\n", pDeviceDescriptor->iSerialNumber));
                DEBUGMSG( DBG_FUNC,("bNumConfigurations 0x%x\n", pDeviceDescriptor->bNumConfigurations));
            }
        } 
		else 
		{
			// if we got here we failed to allocate deviceDescriptor
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if( NT_SUCCESS(ntStatus) ) 
		{
            ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbDeviceDescriptor = pDeviceDescriptor;
			pThisDev->IdVendor = ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbDeviceDescriptor->idVendor;
        }

        MyMemFree( pUrb, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST) );

    } 
	else 
	{
		//
		// if we got here we failed to allocate the urb
        //
		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

	//
	// Now that we have the descriptors, we can configure the device
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
        ntStatus = IrUsb_ConfigureDevice( pThisDev );

        DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" IrUsb_StartDevice IrUsb_ConfigureDevice() FAILURE (%x)\n", ntStatus));
    }

	//
	// Read all the initial registers
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
        ntStatus = St4200ReadRegisters( pThisDev, 0, STIR4200_MAX_REG );
        DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" IrUsb_StartDevice St4200ReadRegisters() FAILURE (%x)\n", ntStatus));
	}

	//
	// Get the current chip revision
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
		pThisDev->ChipRevision = pThisDev->StIrTranceiver.SensitivityReg & STIR4200_SENS_IDMASK;
	}
	
    //
    // Next we must get the Class-Specific Descriptor
    // Get the IR USB dongle's Class-Specific descriptor; this has many
    // characterisitics we must tell Ndis about, such as supported speeds,
    // BOFS required, rate sniff-supported flag, turnaround time, window size,
    // data size.
    //
	if( NT_SUCCESS(ntStatus) ) 
	{
		ntStatus = IrUsb_GetDongleCaps( pThisDev );
		if( !NT_SUCCESS( ntStatus ) ) 
		{
			DEBUGMSG( DBG_ERR,(" IrUsb_ConfigureDevice() IrUsb_GetClassDescriptor() FAILURE (%x)\n", ntStatus));
		} 
		else 
		{
			// fill out dongleCaps struct from class-specific descriptor info
			IrUsb_SetDongleCaps( pThisDev );
		}
	}

	//
	// Set the initial speed
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
		ntStatus = St4200SetSpeed( pThisDev );
        DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" IrUsb_StartDevice St4200SetSpeed() FAILURE (%x)\n", ntStatus));
	}

	//
	// All set and ready to roll
	//
    if( NT_SUCCESS(ntStatus) ) 
	{
		pThisDev->fDeviceStarted = TRUE;
    }

    DEBUGMSG( DBG_FUNC, ("-IrUsb_StartDevice (%x)\n", ntStatus));
    return ntStatus;
}



/*****************************************************************************
*
*  Function:	IrUsb_StopDevice
*
*  Synopsis:	Stops a given instance of a ST4200 device on the USB.
*				We basically just tell USB this device is now 'unconfigured'
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		NT status code
*
*  Notes:		
*
*****************************************************************************/
NTSTATUS
IrUsb_StopDevice(
		IN PIR_DEVICE pThisDev
    )
{
    NTSTATUS	ntStatus = STATUS_SUCCESS;
    PURB		pUrb;
    ULONG		DescriptorSize;

    DEBUGMSG( DBG_FUNC,("+IrUsb_StopDevice\n"));

    //
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle. This closes the configuration and puts the device in the 'unconfigured'
    // state.
    //
    DescriptorSize = sizeof( struct _URB_SELECT_CONFIGURATION );
    pUrb = MyMemAlloc( DescriptorSize );

    if( pUrb ) 
	{
        UsbBuildSelectConfigurationRequest(
				pUrb,
				(USHORT)DescriptorSize,
				NULL
			);

        ntStatus = IrUsb_CallUSBD( pThisDev, pUrb ); // build select config req; main thread

        DEBUGCOND( DBG_ERR,
			!NT_SUCCESS(ntStatus),(" IrUsb_StopDevice() FAILURE Configuration Closed status = %x usb status = %x.\n", ntStatus, pUrb->UrbHeader.Status));
        DEBUGCOND( DBG_WARN,
			NT_SUCCESS(ntStatus),(" IrUsb_StopDevice() SUCCESS Configuration Closed status = %x usb status = %x.\n", ntStatus, pUrb->UrbHeader.Status));

        MyMemFree( pUrb, sizeof(struct _URB_SELECT_CONFIGURATION) );
    } 
	else 
	{
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DEBUGMSG( DBG_FUNC,("-IrUsb_StopDevice  (%x) \n ", ntStatus));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	ResetPipeCallback
*
*  Synopsis:	Callback for resetting a pipe
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
ResetPipeCallback (
		IN PIR_WORK_ITEM pWorkItem
    )
{
	PIR_DEVICE	pThisDev;
	HANDLE		Pipe;
	NTSTATUS	ntStatus;

	pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;
	Pipe = (HANDLE)pWorkItem->pInfoBuf;

	if( Pipe == pThisDev->BulkInPipeHandle ) 
	{
		IRUSB_ASSERT( TRUE == pThisDev->fPendingReadClearStall );
		
		IrUsb_CancelPendingReadIo( pThisDev, TRUE );
		IrUsb_ResetPipe( pThisDev, Pipe );

		InterlockedExchange( &pThisDev->fPendingReadClearStall, FALSE );
	} 
	else if( Pipe == pThisDev->BulkOutPipeHandle ) 
	{
		IRUSB_ASSERT( TRUE == pThisDev->fPendingWriteClearStall );

		IrUsb_CancelPendingWriteIo( pThisDev );
		IrUsb_ResetPipe( pThisDev, Pipe );

		InterlockedExchange( &pThisDev->fPendingWriteClearStall, FALSE );
	}
#if DBG
	else 
	{
		IRUSB_ASSERT( 0 );
	}
#endif

	FreeWorkItem( pWorkItem );
}


/*****************************************************************************
*
*  Function:	IrUsb_ResetPipe
*
*  Synopsis:	This will reset the host pipe to Data0 and should also reset the device
*				endpoint to Data0 for Bulk and Interrupt pipes by issuing a Clear_Feature
*				Endpoint_Stall to the device endpoint.
*
*  Arguments:	pThisDev - pointer to IR device
*				Pipe - handle to the pipe to reset
*	
*  Returns:		NTSTATUS
*
*  Notes:		Must be called at IRQL PASSIVE_LEVEL
*
*****************************************************************************/
NTSTATUS
IrUsb_ResetPipe (
		IN PIR_DEVICE pThisDev,
		IN HANDLE Pipe
    )
{
    PURB        pUrb;
    NTSTATUS    ntStatus;

    DEBUGMSG(DBG_ERR, ("+IrUsb_ResetPipe()\n"));
	
	//
    // Allocate URB for RESET_PIPE request
    //
    pUrb = MyMemAlloc( sizeof(struct _URB_PIPE_REQUEST) );

    if( pUrb != NULL )
    {
#if 0
		NdisZeroMemory( pUrb, sizeof (struct _URB_PIPE_REQUEST) );

		DEBUGMSG(DBG_ERR, ("  IrUsb_ResetPipe before ABORT PIPE \n"));
		
		//
		// Initialize ABORT_PIPE request URB
        //
        pUrb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        pUrb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        pUrb->UrbPipeRequest.PipeHandle = (USBD_PIPE_HANDLE)Pipe;

        ntStatus = IrUsb_CallUSBD( pThisDev, pUrb );

		DEBUGCOND(DBG_ERR, !NT_SUCCESS(ntStatus),  (" IrUsb_ResetPipe ABORT PIPE FAILED \n"));
		DEBUGMSG(DBG_ERR, (" IrUsb_ResetPipe  before RESET_PIPE \n"));
#endif
		NdisZeroMemory( pUrb, sizeof (struct _URB_PIPE_REQUEST) );
		
		//
		// Initialize RESET_PIPE request URB
        //
        pUrb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        pUrb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        pUrb->UrbPipeRequest.PipeHandle = (USBD_PIPE_HANDLE)Pipe;
		
		//
        // Submit RESET_PIPE request URB
        //
        ntStatus = IrUsb_CallUSBD( pThisDev, pUrb );

		DEBUGCOND(DBG_ERR, !NT_SUCCESS(ntStatus),  (" IrUsb_ResetPipe RESET PIPE FAILED \n"));
		DEBUGCOND(DBG_ERR, NT_SUCCESS(ntStatus),  (" IrUsb_ResetPipe RESET PIPE SUCCEEDED \n"));
		
		//
        // Done with URB for RESET_PIPE request, free urb
        //
        MyMemFree( pUrb, sizeof(struct _URB_PIPE_REQUEST) );
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DEBUGMSG(DBG_ERR, ("-IrUsb_ResetPipe %08X\n", ntStatus));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	MyKeWaitForSingleObject
*
*  Synopsis:	Wait with a timeout in a loop
*				so we will never hang if we are asked to halt/reset the driver while
*				pollingthread is waiting for something.
*				If input IRP is not null, also cancel it on timeout
*
*  Arguments:	pThisDev - pointer to IR device
*				pEventWaitingFor - pointer to event to wait for
*				pIrpWaitingFor - pointer to Irp to cancel if timing out
*				timeout100ns - timeout
*	
*  Returns:		NT status code
*
*  Notes:		THIS FUNCTION MUST BE RE-ENTERABLE!
*
*****************************************************************************/
NTSTATUS 
MyKeWaitForSingleObject(
		IN PIR_DEVICE pThisDev,
		IN PVOID pEventWaitingFor,
		IN OUT PIRP pIrpWaitingFor,
		LONGLONG timeout100ns
	)
{
    NTSTATUS		status = STATUS_SUCCESS;
    LARGE_INTEGER	Timeout;

	DEBUGMSG( DBG_FUNC,("+MyKeWaitForSingleObject\n "));
	
	if( timeout100ns ) 
	{   
		//
		//if a non-zero timeout was passed in, use it
		//
		Timeout.QuadPart = - ( timeout100ns );

	} 
	else 
	{
		//Timeout.QuadPart = -10000 * 1000 * 3; // default to 3 second relative delay
		Timeout.QuadPart = -10000 * 1000; // default to 1 second relative delay
	}

	status = KeWaitForSingleObject( //keep this as standard wait
			pEventWaitingFor,
			Suspended,
			KernelMode,
			FALSE,
			&Timeout
		);

    if( pIrpWaitingFor && (status != STATUS_SUCCESS) )
    {
	    BOOLEAN CancelResult;
        
		//
		// if we get here we timed out and we were passed a PIRP to cancel
        //
		CancelResult = IoCancelIrp( pIrpWaitingFor );

        DEBUGCOND( DBG_FUNC, 
			CancelResult,(" MyKeWaitForSingleObject successfully cancelled IRP (%x),CancelResult = %x\n",pIrpWaitingFor, CancelResult));
        DEBUGCOND( DBG_ERR, 
			!CancelResult,(" MyKeWaitForSingleObject FAILED to cancel IRP (%x),CancelResult = %x\n",pIrpWaitingFor, CancelResult));
    }

	DEBUGCOND( DBG_OUT,( STATUS_TIMEOUT == status ),(" MyKeWaitForSingleObject TIMED OUT\n"));
    DEBUGCOND( DBG_OUT,( STATUS_ALERTED == status ),(" MyKeWaitForSingleObject ALERTED\n"));
    DEBUGCOND( DBG_OUT,( STATUS_USER_APC == status ),(" MyKeWaitForSingleObject USER APC\n"));

    DEBUGMSG( DBG_FUNC,("-MyKeWaitForSingleObject  (%x)\n", status));
    return status;
}


/*****************************************************************************
*
*  Function:	PassiveLevelThread
*
*  Synopsis:	Thread running at IRQL PASSIVE_LEVEL.
*
*  Arguments:	Context - pointer to IR device
*
*  Returns:		None
*
*  Notes:
*
*  Any work item that can be called must be serialized.
*  i.e. when IrUsbReset is called, NDIS will not make any other
*       requests of the miniport until NdisMResetComplete is called.
*
*****************************************************************************/
VOID
PassiveLevelThread(
		IN OUT PVOID Context
	)
{
    LARGE_INTEGER	Timeout;
	int				i;
	PIR_WORK_ITEM	pWorkItem;
    PIR_DEVICE		pThisDev = (PIR_DEVICE)Context;

    DEBUGMSG(DBG_WARN, ("+PassiveLevelThread\n"));  // change to FUNC later?
    DEBUGMSG(DBG_ERR, (" PassiveLevelThread: Starting\n"));

    KeSetPriorityThread( KeGetCurrentThread(), LOW_REALTIME_PRIORITY+1 );
    Timeout.QuadPart = -10000 * 1000 * 3; // 3 second relative delay
    while ( !pThisDev->fKillPassiveLevelThread )
    {
        //
        // The eventPassiveThread is an auto-clearing event, so
        // we don't need to reset the event.
        //
        KeWaitForSingleObject( //keep this as standard wait
                   &pThisDev->EventPassiveThread,
                   Suspended,
                   KernelMode,
                   FALSE,
                   &Timeout
			);

        for( i = 0; i < NUM_WORK_ITEMS; i++ )
        {
			if( pThisDev->WorkItems[i].fInUse ) 
			{
				pThisDev->WorkItems[i].Callback( &(pThisDev->WorkItems[i]) );
			}
        }
	} // while !fKill

    DEBUGMSG(DBG_ERR, (" PassiveLevelThread: HALT\n"));

    pThisDev->hPassiveThread = NULL;

    DEBUGMSG(DBG_WARN, ("-PassiveLevelThread\n")); // change to FUNC later?
    PsTerminateSystemThread( STATUS_SUCCESS );
}


/*****************************************************************************
*
*  Function:	PollingThread
*
*  Synopsis:	Thread running at IRQL PASSIVE_LEVEL.
*
*  Arguments:	Context - Pointer to IR device
*
*  Returns:		None
*
*  Algorithm:	
*				1) Call USBD for input data;
*				2) Call USBD for output data or sets a new speed;
*				
*  Notes:
*
*****************************************************************************/
VOID
PollingThread(
		IN OUT PVOID Context
    )
{
    PIR_DEVICE		pThisDev = (PIR_DEVICE)Context;
    NTSTATUS		Status;
 	PLIST_ENTRY		pListEntry;

	DEBUGMSG(DBG_WARN, ("+PollingThread\n"));  // change to FUNC later?
    DEBUGMSG(DBG_ERR, (" PollingThread: Starting\n"));

    KeSetPriorityThread( KeGetCurrentThread(), LOW_REALTIME_PRIORITY );

    while( !pThisDev->fKillPollingThread )
	{
        if( pThisDev->fProcessing )
        {
			ULONG FifoCount;
			PIRUSB_CONTEXT pThisContext;
			BOOLEAN SentPackets;

			//
			// First process the receive
			//
			if( ReceivePreprocessFifo( pThisDev, &FifoCount ) != STATUS_SUCCESS )
			{
				//
				// There is a USB error, stop banging on the chip for a while
				//
				NdisMSleep( 1000 );    
			}
			else if( FifoCount )
			{
				//
				// Indicate that we are now receiving
				//
				InterlockedExchange( (PLONG)&pThisDev->fCurrentlyReceiving, TRUE );

				//
				// Tell the protocol that the media is now busy
				//
				if( pThisDev->fIndicatedMediaBusy == FALSE ) 
				{
					InterlockedExchange( &pThisDev->fMediaBusy, TRUE );
					InterlockedExchange( &pThisDev->fIndicatedMediaBusy, TRUE );
					IndicateMediaBusy( pThisDev ); 
				}

				ReceiveProcessFifoData( pThisDev );
			}
			else if( pThisDev->currentSpeed == SPEED_9600 )
			{
				NdisMSleep( 10*1000 );    
			}

			//
			// Then process the contexts that are ready
			//
			SentPackets = FALSE;
			do 
			{
				pListEntry = ExInterlockedRemoveHeadList(  &pThisDev->SendBuiltQueue, &pThisDev->SendLock );
				if( pListEntry )
				{
					InterlockedDecrement( &pThisDev->SendBuiltCount );
					
					pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
					
					switch( pThisContext->ContextType )
					{
						//
						// Packet to send
						//
						case CONTEXT_NDIS_PACKET:
							//
							// make sure the receive is cleaned
							//
							ReceiveResetPointers( pThisDev );

							//
							// Send
							//
							SendPreprocessedPacketSend(	pThisDev, pThisContext );
							if( (pThisDev->ChipRevision >= CHIP_REVISION_7) &&
								(pThisDev->currentSpeed > MAX_MIR_SPEED) )
							{
								SentPackets = TRUE;
								SendCheckForOverflow( pThisDev );
							}
							else SendWaitCompletion( pThisDev );
							break;
						//
						// Set the new speed
						//
						case CONTEXT_SET_SPEED:
							//
							// make sure the receive is cleaned
							//
							ReceiveResetPointers( pThisDev );

							//
							// Force completion and set
							//
							if( SentPackets )
							{
								SentPackets = TRUE;
								SendWaitCompletion( pThisDev );
							}
							if( !pThisDev->fPendingHalt && !pThisDev->fPendingReset )
							{
								DEBUGMSG( DBG_ERR, (" Changing speed to: %d\n", pThisDev->linkSpeedInfo->BitsPerSec));
								St4200SetSpeed( pThisDev );
								InterlockedExchange( (PLONG)&pThisDev->currentSpeed, pThisDev->linkSpeedInfo->BitsPerSec );
#if defined(DIAGS)
								if( !pThisDev->DiagsActive )
#endif
									MyNdisMSetInformationComplete( pThisDev, STATUS_SUCCESS );
							} 
							else 
							{
								DEBUGMSG( DBG_ERR , (" St4200SetSpeed DUMPING OUT on TIMEOUT,HALT OR RESET\n"));
#if defined(DIAGS)
								if( !pThisDev->DiagsActive )
#endif
									MyNdisMSetInformationComplete( pThisDev, STATUS_UNSUCCESSFUL );
							}
							ExInterlockedInsertTailList(
									&pThisDev->SendAvailableQueue,
									&pThisContext->ListEntry,
									&pThisDev->SendLock
								);
							InterlockedIncrement( &pThisDev->SendAvailableCount );
							break;
#if defined(DIAGS)
						//
						// Diagnostic state is enabled
						//
						case CONTEXT_DIAGS_ENABLE:
							Diags_CompleteEnable( pThisDev, pThisContext );
							break;
						//
						// Diagnostic read of the registers
						//
						case CONTEXT_DIAGS_READ_REGISTERS:
							Diags_CompleteReadRegisters( pThisDev, pThisContext );
							break;
						//
						// Diagnostic write of the registers
						//
						case CONTEXT_DIAGS_WRITE_REGISTER:
							Diags_CompleteWriteRegister( pThisDev, pThisContext );
							break;
						//
						// Diagnostic bulk out
						//
						case CONTEXT_DIAGS_BULK_OUT:
							Diags_Bulk( pThisDev, pThisContext, TRUE );
							break;
						//
						// Diagnostic bulk in
						//
						case CONTEXT_DIAGS_BULK_IN:
							Diags_Bulk( pThisDev, pThisContext, FALSE );
							break;
						//
						// Diagnostic bulk out
						//
						case CONTEXT_DIAGS_SEND:
							Diags_Send( pThisDev, pThisContext );
							break;
#endif
					}
				}
			} while( pListEntry );
			
			//
			// Force to wait
			//
			if( SentPackets )
				SendWaitCompletion( pThisDev );
		} // end if
		else
		{
			NdisMSleep( 10*1000 );
		}
    } // end while

    DEBUGMSG(DBG_ERR, (" PollingThread: HALT\n"));

    pThisDev->hPollingThread = NULL;

	//
    // this thread will finish here
    // if the terminate flag is TRUE
    //
    DEBUGMSG(DBG_WARN, ("-PollingThread\n"));  // change to FUNC later?
	PsTerminateSystemThread( STATUS_SUCCESS );
}


/*****************************************************************************
*
*  Function:	AllocUsbInfo
*
*  Synopsis:	Allocates the USB portion of the device context.
*
*  Arguments:	pThisDev - pointer to current ir device object
*	
*  Returns:		TRUE - Success
*				FALSE - Failure
*
*  Notes:
*
*****************************************************************************/
BOOLEAN 
AllocUsbInfo(
		IN OUT PIR_DEVICE pThisDev 
	)
{
	UINT Size = sizeof( IRUSB_USB_INFO );

	pThisDev->pUsbInfo = MyMemAlloc( Size );

	if( NULL == pThisDev->pUsbInfo ) 
	{
		return FALSE;
	}

    NdisZeroMemory( (PVOID)pThisDev->pUsbInfo, Size );
	return TRUE;
}


/*****************************************************************************
*
*  Function:	AllocUsbInfo
*
*  Synopsis:	Deallocates the USB portion of the device context.
*
*  Arguments:	pThisDev - pointer to current ir device object
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID 
FreeUsbInfo(
		IN OUT PIR_DEVICE pThisDev 
	)
{
	if( NULL != pThisDev->pUsbInfo ) 
	{
		//
		// Free device descriptor structure
		//
		if ( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbDeviceDescriptor ) 
		{
			MyMemFree( 
					((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbDeviceDescriptor,  
					sizeof(USB_DEVICE_DESCRIPTOR) 
				);
		}

		//
		// Free up the Usb Interface structure
		//
		if( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface ) 
		{
			MyMemFree( 
					((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface,
					((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface->Length
				);
		}

		//
		// free up the USB config discriptor
		//
		if( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationDescriptor )
		{
			MyMemFree( 
					((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor, 
					sizeof(USB_CONFIGURATION_DESCRIPTOR) + 512
				);
		}

		MyMemFree( (PVOID)pThisDev->pUsbInfo, sizeof(IRUSB_USB_INFO) );
	}
}


/*****************************************************************************
*
*  Function:	IrUsb_InitSendStructures
*
*  Synopsis:	Allocates the send stuff
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		TRUE if successful
*				FALSE otherwise
*
*  Notes:
*
*****************************************************************************/
BOOLEAN
IrUsb_InitSendStructures(
		IN OUT PIR_DEVICE pThisDev
	)
{

	BOOLEAN			InitResult = TRUE;
	PUCHAR			pThisContext;  
	PIRUSB_CONTEXT	pCont;
	int				i;

    DEBUGMSG(DBG_FUNC, ("+IrUsb_InitSendStructures\n"));
    
	//
    // Initialize a notification event for signalling PassiveLevelThread.
    //
    KeInitializeEvent(
			&pThisDev->EventPassiveThread,
			SynchronizationEvent, // auto-clearing event
			FALSE                 // event initially non-signalled
		);

#if defined(DIAGS)
    KeInitializeEvent(
            &pThisDev->EventDiags,
            NotificationEvent,    // non-auto-clearing event
            FALSE                 // event initially non-signalled
        );
#endif
	
	((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb = NULL;

	//
	// set urblen to max possible urb size
	//
	pThisDev->UrbLen = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
	pThisDev->UrbLen = MAX( pThisDev->UrbLen, sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST));
	pThisDev->UrbLen = MAX( pThisDev->UrbLen, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST ));
	pThisDev->UrbLen = MAX( pThisDev->UrbLen, sizeof(struct _URB_SELECT_CONFIGURATION));

	//
	// allocate our send context structs
	//
	pThisDev->pSendContexts = MyMemAlloc( NUM_SEND_CONTEXTS * sizeof(IRUSB_CONTEXT) );

	if( NULL == pThisDev->pSendContexts ) 
	{
		InitResult = FALSE;
		goto done;
	}

	NdisZeroMemory( pThisDev->pSendContexts, NUM_SEND_CONTEXTS * sizeof(IRUSB_CONTEXT) );

	//
	//  Initialize list for holding pending read requests
    //
	InitializeListHead( &pThisDev->SendAvailableQueue );
    InitializeListHead( &pThisDev->SendBuiltQueue );
	InitializeListHead( &pThisDev->SendPendingQueue );
	KeInitializeSpinLock( &pThisDev->SendLock );

	//
	// Prepare the read/write specific queue
	//
	InitializeListHead( &pThisDev->ReadWritePendingQueue );

	pThisContext = pThisDev->pSendContexts;
	for ( i= 0; i < NUM_SEND_CONTEXTS; i++ ) 
	{
		pCont = (PIRUSB_CONTEXT)pThisContext;

		pCont->pThisDev = pThisDev;

		// Also put in the available queue
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pCont->ListEntry,
				&pThisDev->SendLock
			);

		pThisContext += sizeof( IRUSB_CONTEXT );

	} // for

	//
	// URB descriptor
	//
	pThisDev->pUrb = MyMemAlloc( pThisDev->UrbLen );

	if( NULL == pThisDev->pUrb )
	{
		DEBUGMSG(DBG_ERR, (" IrUsb_InitSendStructures failed to alloc urb\n"));

		InitResult = FALSE;
		goto done;
	}

	NdisZeroMemory( pThisDev->pUrb, pThisDev->UrbLen );

	//
	// Send buffers
	//
	pThisDev->pBuffer = MyMemAlloc( MAX_IRDA_DATA_SIZE );
	if( NULL == pThisDev->pBuffer )
	{
		DEBUGMSG(DBG_ERR, (" IrUsb_InitSendStructures failed to alloc info buf\n"));

		InitResult = FALSE;
		goto done;
	}

	pThisDev->pStagingBuffer = MyMemAlloc( MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE );
	if( NULL == pThisDev->pStagingBuffer )
	{
		DEBUGMSG(DBG_ERR, (" IrUsb_InitSendStructures failed to alloc staging buf\n"));

		InitResult = FALSE;
		goto done;
	}

	//
	// and send counts
	//
	pThisDev->SendAvailableCount = NUM_SEND_CONTEXTS;
	pThisDev->SendBuiltCount = 0;
	pThisDev->SendPendingCount = 0;
	pThisDev->ReadWritePendingCount = 0;
	pThisDev->SendFifoCount =  0;

done:
    DEBUGMSG(DBG_FUNC, ("-IrUsb_InitSendStructures\n"));
	return InitResult;
}


/*****************************************************************************
*
*  Function:	IrUsb_FreeSendStructures
*
*  Synopsis:	Deallocates the send stuff
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_FreeSendStructures(
		IN OUT PIR_DEVICE pThisDev
	)
{
    DEBUGMSG(DBG_FUNC, ("+IrUsb_FreeSendStructures\n"));

	if( NULL != pThisDev->pSendContexts ) 
	{
		MyMemFree( pThisDev->pSendContexts, NUM_SEND_CONTEXTS * sizeof(IRUSB_CONTEXT) );
		pThisDev->pSendContexts = NULL;

	} 
	
	if( NULL != pThisDev->pUrb )
	{
		MyMemFree( pThisDev->pUrb, pThisDev->UrbLen );
		pThisDev->pUrb = NULL;
	}

	if( NULL != pThisDev->pBuffer )
	{
		MyMemFree( pThisDev->pBuffer, MAX_IRDA_DATA_SIZE );
		pThisDev->pBuffer = NULL;
	}

	if( NULL != pThisDev->pStagingBuffer )
	{
		MyMemFree( pThisDev->pStagingBuffer, MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE );
		pThisDev->pStagingBuffer = NULL;
	}

    DEBUGMSG(DBG_FUNC, ("-IrUsb_FreeSendStructures\n"));
}


/*****************************************************************************
*
*  Function:	IrUsb_PrepareSetSpeed
*
*  Synopsis:	Prepares a context to set the new speed
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_PrepareSetSpeed(
		IN OUT PIR_DEVICE pThisDev
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

    DEBUGMSG( DBG_FUNC, ("+IrUsb_PrepareSetSpeed()\n"));

	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" IrUsb_PrepareSetSpeed failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_SET_SPEED;
	
	//
	// Queue the context and nothing else has to be done 
	//
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

done:
    DEBUGMSG( DBG_FUNC, ("-IrUsb_PrepareSetSpeed()\n"));
}


/*****************************************************************************
*
*  Function:	IrUsb_IncIoCount
*
*  Synopsis:	Tracks count of pending irps
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_IncIoCount(
		IN OUT PIR_DEVICE  pThisDev
	)
{
	InterlockedIncrement( &pThisDev->PendingIrpCount );
}


/*****************************************************************************
*
*  Function:	IrUsb_DecIoCount
*
*  Synopsis:	Tracks count of pending irps
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_DecIoCount(
		IN OUT PIR_DEVICE  pThisDev
	)
{
	InterlockedDecrement( &pThisDev->PendingIrpCount );
}


/*****************************************************************************
*
*  Function:	AllocXferUrb
*
*  Synopsis:	Allocates the transfer Urb for a USB transaction
*
*  Arguments:	None
*	
*  Returns:		Pointer to Urb
*
*  Notes:
*
*****************************************************************************/
PVOID
AllocXferUrb( 
		VOID 
	)
{
	return MyMemAlloc( sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER) );
}


/*****************************************************************************
*
*  Function:	FreeXferUrb
*
*  Synopsis:	Deallocates the transfer Urb for a USB transaction
*
*  Arguments:	pUrb - pointer to Urb
*	
*  Returns:		Pointer to Urb
*
*  Notes:
*
*****************************************************************************/
VOID
FreeXferUrb( 
		IN OUT PVOID pUrb 
	)
{
	MyMemFree( pUrb, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\send.c ===
/**************************************************************************************************************************
 *  SEND.C SigmaTel STIR4200 packet send module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 10/13/2000 
 *			Version 1.11
 *		Edited: 11/09/2000 
 *			Version 1.12
 *		Edited: 12/29/2000 
 *			Version 1.13
 *		Edited: 01/16/2001 
 *			Version 1.14
 *	
 *
 **************************************************************************************************************************/

#include <ndis.h>
#include <ntdef.h>
#include <windef.h>

#include "stdarg.h"
#include "stdio.h"

#include "debug.h"
#include "usbdi.h"
#include "usbdlib.h"

#include "ircommon.h"
#include "irusb.h"
#include "irndis.h"
#include "stir4200.h"


/*****************************************************************************
*
*  Function:   SendPacketPreprocess
*
*  Synopsis:   Prepares a packet in such a way that the polling thread can later send it
*              The only operations are initializing and queuing the context
*
*
*  Arguments:  pThisDev - pointer to current ir device object
*              pPacketToSend - pointer to packet to send
*
*  Returns:    NDIS_STATUS_PENDING - This is generally what we should
*                                    return. We will call NdisMSendComplete
*                                    when the USB driver completes the
*                                    send.
*              NDIS_STATUS_RESOURCES - No descriptor was available.
*
*  Unsupported returns:
*              NDIS_STATUS_SUCCESS - We should never return this since
*                                    packet has to be sent from the polling thread
*
*
*
*****************************************************************************/
NDIS_STATUS
SendPacketPreprocess(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pPacketToSend
	)
{
    NDIS_STATUS			status = NDIS_STATUS_PENDING ;
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

    DEBUGMSG(DBG_FUNC, ("+SendPacketPreprocess\n"));

	//
	// See if there are available send contexts
	//
	if( pThisDev->SendAvailableCount<=2 )
    {
        DEBUGMSG(DBG_ERR, (" SendPacketPreprocess not enough contexts\n"));

 		InterlockedIncrement( &pThisDev->packetsSentRejected );
		status = NDIS_STATUS_RESOURCES;
        goto done;
    }

	//
	// Dequeue a context
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
		//
		// This cannot happen
		//
		IRUSB_ASSERT( 0 );
		DEBUGMSG(DBG_ERR, (" SendPacketPreprocess failed to find a free context struct\n"));

 		InterlockedIncrement( &pThisDev->packetsSentRejected );
		status = NDIS_STATUS_RESOURCES;
        goto done;
    }

	InterlockedDecrement( &pThisDev->SendAvailableCount );
	
	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->pPacket = pPacketToSend;
	pThisContext->ContextType = CONTEXT_NDIS_PACKET;

	//
	// Store the time the packet was handed by the protocol
	//
	KeQuerySystemTime( &pThisContext->TimeReceived );

	//
	// Queue so that the polling thread can later handle it
	//
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

done:
    DEBUGMSG(DBG_FUNC, ("-SendPacketPreprocess\n"));
    return status;
}


/*****************************************************************************
*
*  Function:   SendPreprocessedPacketSend
*
*  Synopsis:   Send a packet to the USB driver and add the sent irp and io context to
*              To the pending send queue; this queue is really just needed for possible later error cancellation
*
*
*  Arguments:  pThisDev - pointer to current ir device object
*              pContext	- pointer to the context with the packet to send
*
*  Returns:    NDIS_STATUS_PENDING - This is generally what we should
*                                    return. We will call NdisMSendComplete
*                                    when the USB driver completes the
*                                    send.
*              STATUS_UNSUCCESSFUL - The packet was invalid.
*
*              NDIS_STATUS_SUCCESS - When blocking send are employed
*
*
*****************************************************************************/
NDIS_STATUS
SendPreprocessedPacketSend(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
    PIRP                pIrp;
    UINT                BytesToWrite;
	NDIS_STATUS			status;
    BOOLEAN             fConvertedPacket;
    ULONG				Counter;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
	PVOID				pPacketToSend;
	PIRUSB_CONTEXT		pThisContext = pContext;
	LARGE_INTEGER		CurrentTime, TimeDifference;
	PNDIS_IRDA_PACKET_INFO	pPacketInfo;

    DEBUGMSG(DBG_FUNC, ("+SendPreprocessedPacketSend\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	IRUSB_ASSERT( NULL != pThisContext );

	//
	// Stop if a halt/reset/suspend is going on
	//
	if( pThisDev->fPendingWriteClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall || !pThisDev->fProcessing ) 
	{
        DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend abort due to pending reset or halt\n"));
		status = NDIS_STATUS_RESET_IN_PROGRESS;

		//
		// Give the packet back to the protocol
		//
		NdisMSendComplete(
				pThisDev->hNdisAdapter,
				pThisContext->pPacket,
				status 
			);
 		InterlockedIncrement( &pThisDev->packetsSentRejected );

		//
		// Back to the available queue
		//
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
		goto done;
	}
		
	pUrb = pThisDev->pUrb;

	NdisZeroMemory( pUrb, pThisDev->UrbLen );

	pPacketToSend = pThisContext->pPacket;
	IRUSB_ASSERT( NULL != pPacketToSend );

	//
	// Indicate that we are not receiving
	//
	InterlockedExchange( (PLONG)&pThisDev->fCurrentlyReceiving, FALSE );

	//
	// Convert the packet to an ir frame and copy into our buffer
	// and send the irp.
	//
	if( pThisDev->currentSpeed<=MAX_SIR_SPEED )
	{
		fConvertedPacket = NdisToSirPacket(
				pThisDev,
				pPacketToSend,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pThisDev->pStagingBuffer,
				&BytesToWrite
			);
	}
	else if( pThisDev->currentSpeed<=MAX_MIR_SPEED )
	{
		fConvertedPacket = NdisToMirPacket(
				pThisDev,
				pPacketToSend,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pThisDev->pStagingBuffer,
				&BytesToWrite
			);
	}
	else
	{
		fConvertedPacket = NdisToFirPacket(
				pThisDev,
				pPacketToSend,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pThisDev->pStagingBuffer,
				&BytesToWrite
			);
	}
	
#if defined(SEND_LOGGING)
	if( pThisDev->SendFileHandle )
	{
		IO_STATUS_BLOCK IoStatusBlock;

		ZwWriteFile(
				pThisDev->SendFileHandle,
				NULL,
				NULL,
				NULL,
				&IoStatusBlock,
				pThisDev->Buffer,
				BytesToWrite,
				(PLARGE_INTEGER)&pThisDev->SendFilePosition,
				NULL
		   );

		pThisDev->SendFilePosition += BytesToWrite;
	}
#endif

	if( (fConvertedPacket == FALSE) || (BytesToWrite > NDIS_STATUS_INVALID_PACKET) )
	{
		DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() NdisToIrPacket failed. Couldn't convert packet!\n"));
		status = NDIS_STATUS_INVALID_LENGTH;

		//
		// Give the packet back to the protocol
		//
		NdisMSendComplete(
				pThisDev->hNdisAdapter,
				pThisContext->pPacket,
				status 
			);
 		InterlockedIncrement( &pThisDev->packetsSentInvalid );

		//
		// Back to the available queue
		//
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
		goto done;
	}

	//
	// Save the effective length
	//
	pThisDev->BufLen = BytesToWrite;
#if !defined(ONLY_ERROR_MESSAGES)
	DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() NdisToIrPacket success BytesToWrite = dec %d, \n", BytesToWrite));
#endif
	
	//
	// Verify the FIFO condition and possibly make sure we don't overflow
	//
	pThisDev->SendFifoCount += BytesToWrite;
	if( pThisDev->SendFifoCount >= (3*STIR4200_FIFO_SIZE/2) )
	{
		DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() Completing, size: %d\n", pThisDev->SendFifoCount));
		SendWaitCompletion( pThisDev );
		pThisDev->SendFifoCount = BytesToWrite;
	}

#if defined( WORKAROUND_STUCK_AFTER_GEAR_DOWN )
	if(	pThisDev->GearedDown )
	{
#define SIZE_FAKE_SEND 5		
		
		UCHAR pData[SIZE_FAKE_SEND]={0x55,0xaa,SIZE_FAKE_SEND-4,0x00,0xff};
		St4200FakeSend(
				pThisDev,
				pData,
				SIZE_FAKE_SEND
			);
		St4200FakeSend(
				pThisDev,
				pData,
				SIZE_FAKE_SEND
			);
		pThisDev->GearedDown = FALSE;
	}
#endif

	//
	// Enforce turnaround time
	//
	pPacketInfo = GetPacketInfo( pPacketToSend );
    if (pPacketInfo != NULL) 
	{
#if DBG
		//
		// See if we get a packet with 0 turnaround time specified
		// when we think we need need a turnaround time 
		//
		if( pPacketInfo->MinTurnAroundTime > 0 ) 
		{
			pThisDev->NumPacketsSentRequiringTurnaroundTime++;
		} 
		else 
		{
			pThisDev->NumPacketsSentNotRequiringTurnaroundTime++;
		}
#endif

		//
		// Deal with turnaroud time
		//
		KeQuerySystemTime( &CurrentTime );
		TimeDifference = RtlLargeIntegerSubtract( CurrentTime, pThisContext->TimeReceived );
		if( (ULONG)(TimeDifference.QuadPart/10) < pPacketInfo->MinTurnAroundTime )
		{
			ULONG TimeToWait = pPacketInfo->MinTurnAroundTime - (ULONG)(TimeDifference.QuadPart/10);

			//
			// Potential hack...
			//
			if( TimeToWait > 1000 )
			{
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() Enforcing turnaround time %d\n", TimeToWait));
#endif
				NdisMSleep( TimeToWait );
			}
		}
	}
	else 
	{
        //
        //  irda protocol is broken
        //
   		DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() pPacketInfo == NULL\n"));
    }

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend failed to alloc IRP\n"));
        status = NDIS_STATUS_FAILURE;

		//
		// Give the packet back to the protocol
		//
		NdisMSendComplete(
				pThisDev->hNdisAdapter,
				pThisContext->pPacket,
				status 
			);
        InterlockedIncrement( (PLONG)&pThisDev->packetsSentDropped );

		//
		// Back to the available queue
		//
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkOutPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_OUT ;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pThisDev->pBuffer;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)BytesToWrite;

    //
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
	
    IoSetCompletionRoutine(
			pIrp,							// irp to use
			SendCompletePacketSend,			// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

#ifdef SERIALIZE
	KeClearEvent( &pThisDev->EventSyncUrb );
#endif
	
	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->SendPendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendPendingCount );
	status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    IRUSB_ASSERT( status == STATUS_PENDING );

	status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, NULL, 0 );

	if( status == STATUS_TIMEOUT ) 
	{
		KIRQL OldIrql;

		DEBUGMSG( DBG_ERR,(" SendPreprocessedPacketSend() TIMED OUT! return from IoCallDriver USBD %x\n", status));
		KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
		RemoveEntryList( &pThisContext->ListEntry );
		KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
		InterlockedDecrement( &pThisDev->SendPendingCount );
		IrUsb_CancelIo( pThisDev, pIrp, &pThisDev->EventSyncUrb );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-SendPreprocessedPacketSend\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	SendWaitCompletion
*
*  Synopsis:	Waits for a send operation to be completed. A send is completed when the
*				entire frame has been transmitted ove the IR medium
*
*  Arguments:	pThisDev - pointer to current ir device object
*
*  Returns:		NT status code
*
*****************************************************************************/
NTSTATUS
SendWaitCompletion(
		IN OUT PIR_DEVICE pThisDev
	)
{
	NTSTATUS Status;
	LARGE_INTEGER CurrentTime, InitialTime;
	ULONG FifoCount, OldFifoCount = STIR4200_FIFO_SIZE;

	//
	// At low speed we simply force to wait
	//
	if( (pThisDev->currentSpeed <= MAX_MIR_SPEED) || (pThisDev->ChipRevision >= CHIP_REVISION_7) )
	{
		//
		// We force to wait until the end of transmit
		//
		KeQuerySystemTime( &InitialTime );
		while( TRUE )
		{
			//
			// Read the status register and check
			//
			if( (Status = St4200ReadRegisters( pThisDev, STIR4200_STATUS_REG, 3 )) == STATUS_SUCCESS )
			{
				//
				// bit set means still in transmit mode...
				//
				if( pThisDev->StIrTranceiver.StatusReg & STIR4200_STAT_FFDIR )     
				{
					KeQuerySystemTime( &CurrentTime );
					FifoCount = 
						((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
					if( ((CurrentTime.QuadPart-InitialTime.QuadPart) > (IRUSB_100ns_PER_ms*STIR4200_SEND_TIMEOUT) ) ||
						(FifoCount > OldFifoCount) )
					{
						pThisDev->PreFifoCount = 0;
						St4200DoubleResetFifo( pThisDev );
						break;
					}
					OldFifoCount = FifoCount;
				}
				else
				{
					pThisDev->PreFifoCount = 
						((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
					break;
				}
			}
			else break;
		}
	}
	//
	// In high speed we try to be smarter
	//
	else
	{
		if( (Status = St4200ReadRegisters( pThisDev, STIR4200_STATUS_REG, 3 )) == STATUS_SUCCESS )
		{
			//
			// bit set means still in transmit mode...
			//
			if( pThisDev->StIrTranceiver.StatusReg & STIR4200_STAT_FFDIR )     
			{
				ULONG Count;

				Count = ((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
				NdisStallExecution( (STIR4200_WRITE_DELAY*Count)/MAX_TOTAL_SIZE_WITH_ALL_HEADERS );
				pThisDev->PreFifoCount = 0;
			}
			else
			{
				pThisDev->PreFifoCount = 
					((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
			}
		}
	}

	pThisDev->SendFifoCount = 0;
	return Status;
}


/*****************************************************************************
*
*  Function:	SendCheckForOverflow
*
*  Synopsis:	Makes sure we are not going to overflow the TX FIFO
*
*  Arguments:	pThisDev - pointer to current ir device object
*
*  Returns:		NT status code
*
*****************************************************************************/
NTSTATUS
SendCheckForOverflow(
		IN OUT PIR_DEVICE pThisDev
	)
{
	NTSTATUS	Status = STATUS_SUCCESS;

	//
	// Check what we think we have in the FIFO
	//
	if( pThisDev->SendFifoCount > (3*STIR4200_FIFO_SIZE/4) )
	{
		//
		// Always one initial read
		//
		if( (Status = St4200ReadRegisters( pThisDev, STIR4200_FIFOCNT_LSB_REG, 2 )) == STATUS_SUCCESS )
		{
			pThisDev->SendFifoCount =
				(ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg);
#if !defined(ONLY_ERROR_MESSAGES)
			DEBUGMSG( DBG_ERR,(" SendCheckForOverflow() Count: %d\n", pThisDev->SendFifoCount));
#endif
		}
		else goto done;

		//
		// Force reads to get the real count, until condition is satisfied
		//
		while( pThisDev->SendFifoCount > (3*STIR4200_FIFO_SIZE/4) )
		{
			if( (Status = St4200ReadRegisters( pThisDev, STIR4200_FIFOCNT_LSB_REG, 2 )) == STATUS_SUCCESS )
			{
				pThisDev->SendFifoCount =
					(ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg);
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG( DBG_ERR,(" SendCheckForOverflow() Count: %d\n", pThisDev->SendFifoCount));
#endif
			}
			else goto done;
		}
	}

done:
	return Status;
}


/*****************************************************************************
*
*  Function:   SendCompletePacketSend
*
*  Synopsis:   Completes USB write operation
*
*  Arguments:  pUsbDevObj - pointer to the USB device object which
*                           completed the irp
*              pIrp       - the irp which was completed by the
*                           device object
*              Context    - the context given to IoSetCompletionRoutine
*                           before calling IoCallDriver on the irp
*                           The Context is a pointer to the ir device object.
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*****************************************************************************/
NTSTATUS
SendCompletePacketSend(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE          pThisDev;
    PVOID               pThisContextPacket;
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext = (PIRUSB_CONTEXT)Context;
	PIRP				pContextIrp;
	PURB                pContextUrb;
	ULONG				BufLen;
	ULONG				BytesTransfered;
	PLIST_ENTRY			pListEntry;

    DEBUGMSG(DBG_FUNC, ("+SendCompletePacketSend\n"));

    //
    // The context given to IoSetCompletionRoutine is an IRUSB_CONTEXT struct
    //
	IRUSB_ASSERT( NULL != pThisContext );				// we better have a non NULL buffer

    pThisDev = pThisContext->pThisDev;

	IRUSB_ASSERT( NULL != pThisDev );	

	pContextIrp = pThisContext->pIrp;
	pContextUrb = pThisDev->pUrb;
	BufLen = pThisDev->BufLen;

	pThisContextPacket = pThisContext->pPacket; //save ptr to packet to access after context freed

	//
	// Perform various IRP, URB, and buffer 'sanity checks'
	//
    IRUSB_ASSERT( pContextIrp == pIrp );				// check we're not a bogus IRP

    status = pIrp->IoStatus.Status;

	//
	// we should have failed, succeeded, or cancelled, but NOT be pending
	//
	IRUSB_ASSERT( STATUS_PENDING != status );

	//
	// Remove from the pending queue (only if NOT cancelled)
	//
	if( status != STATUS_CANCELLED )
	{
		KIRQL OldIrql;

		KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
		RemoveEntryList( &pThisContext->ListEntry );
		KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
		InterlockedDecrement( &pThisDev->SendPendingCount );
	}

    //
    // IoCallDriver has been called on this Irp;
    // Set the length based on the TransferBufferLength
    // value in the URB
    //
    pIrp->IoStatus.Information = pContextUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

	BytesTransfered = (ULONG)pIrp->IoStatus.Information; // save for below need-termination test

#if DBG
	if( STATUS_SUCCESS == status ) 
	{
		IRUSB_ASSERT( pIrp->IoStatus.Information == BufLen );
	}
#endif

    DEBUGMSG(DBG_OUT, (" SendCompletePacketSend  pIrp->IoStatus.Status = 0x%x\n", status));
    DEBUGMSG(DBG_OUT, (" SendCompletePacketSend  pIrp->IoStatus.Information = 0x%x, dec %d\n", pIrp->IoStatus.Information,pIrp->IoStatus.Information));

    //
    // Keep statistics.
    //
    if( status == STATUS_SUCCESS )
    {
#if DBG
		ULONG total = pThisDev->TotalBytesSent + BytesTransfered;
		InterlockedExchange( (PLONG)&pThisDev->TotalBytesSent, (LONG)total );
#endif
	    InterlockedIncrement( (PLONG)&pThisDev->packetsSent );
        DEBUGMSG(DBG_OUT, (" SendCompletePacketSend Sent a packet, packets sent = dec %d\n",pThisDev->packetsSent));
    }
    else
    {
        InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
        InterlockedIncrement( (PLONG)&pThisDev->packetsSentDropped );
        DEBUGMSG(DBG_ERR, (" SendCompletePacketSend DROPPED a packet, packets dropped = dec %d\n",pThisDev->packetsSentDropped));
    }

    //
    // Free the IRP  because we alloced it ourselves,
    //
    IoFreeIrp( pIrp );
	InterlockedIncrement( (PLONG)&pThisDev->NumWrites );

	//
	// Indicate to the protocol the status of the sent packet and return
	// ownership of the packet.
	//
	NdisMSendComplete(
			pThisDev->hNdisAdapter,
			pThisContextPacket,
			status 
		);

	//
	// Enqueue the completed packet
	//
	ExInterlockedInsertTailList(
			&pThisDev->SendAvailableQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	IrUsb_DecIoCount( pThisDev ); // we will track count of pending irps

	if( ( STATUS_SUCCESS != status )  && ( STATUS_CANCELLED != status ) ) 
	{
		if( !pThisDev->fPendingWriteClearStall && !pThisDev->fPendingClearTotalStall && 
			!pThisDev->fPendingHalt && !pThisDev->fPendingReset && pThisDev->fProcessing )
		{
			DEBUGMSG(DBG_ERR, (" SendCompletePacketSend error, will schedule a clear stall via URB_FUNCTION_RESET_PIPE (OUT)\n"));
			InterlockedExchange( (PLONG)&pThisDev->fPendingWriteClearStall, TRUE );
			ScheduleWorkItem( pThisDev,	ResetPipeCallback, pThisDev->BulkOutPipeHandle, 0 );
		}
	}

#ifdef SERIALIZE
	KeSetEvent( &pThisDev->EventSyncUrb, 0, FALSE );  //signal we're done
#endif
    DEBUGMSG(DBG_FUNC, ("-SendCompletePacketSend\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\receive.c ===
/**************************************************************************************************************************
 *  RECEIVE.C SigmaTel STIR4200 packet reception and decoding module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 07/13/2000 
 *			Version 1.00
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 10/13/2000 
 *			Version 1.11
 *		Edited: 11/09/2000 
 *			Version 1.12
 *		Edited: 12/29/2000 
 *			Version 1.13
 *		Edited: 01/16/2001 
 *			Version 1.14
 *		Edited: 02/20/2001
 *			Version 1.15
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntdef.h>
#include <windef.h>

#include "stdarg.h"
#include "stdio.h"

#include "debug.h"
#include "usbdi.h"
#include "usbdlib.h"

#include "ircommon.h"
#include "irusb.h"


/*****************************************************************************
*
*  Function:   ReceiveProcessFifoData
*
*  Synopsis:   Processes the received data and indicates packets to the protocol
*
*  Arguments:  pThisDev - pointer to current ir device object
*
*  Returns:    None
*
*
*****************************************************************************/
VOID
ReceiveProcessFifoData(
		IN OUT PIR_DEVICE pThisDev
	)
{
    ULONG		BytesProcessed;
	BOOLEAN		ReturnValue = TRUE;

	while( ReturnValue )
	{
		if( pThisDev->currentSpeed<=MAX_SIR_SPEED )
		{
			ReturnValue = ReceiveSirStepFSM( pThisDev, &BytesProcessed );
		}
		else if( pThisDev->currentSpeed<=MAX_MIR_SPEED )
		{
			ReturnValue = ReceiveMirStepFSM( pThisDev, &BytesProcessed );
		}
		else
		{
			ReturnValue = ReceiveFirStepFSM( pThisDev, &BytesProcessed );
		}
	}

	//
	// Indicate that we are no more receiving
	//
	InterlockedExchange( (PLONG)&pThisDev->fCurrentlyReceiving, FALSE );

}


/*****************************************************************************
*
*  Function:   ReceiveResetPointers
*
*  Synopsis:   Reset the receive pointers as the data is gone when we are sending
*
*  Arguments:  pThisDev - pointer to current ir device object
*
*  Returns:    None
*
*
*****************************************************************************/
VOID
ReceiveResetPointers(
		IN OUT PIR_DEVICE pThisDev
	)
{
	pThisDev->rcvState = STATE_INIT;
	pThisDev->readBufPos = 0;
}


/*****************************************************************************
*
*  Function:   ReceivePreprocessFifo
*
*  Synopsis:   Verifies if there is data to be received
*
*  Arguments:  MiniportAdapterContext - pointer to current ir device object
*			   pFifoCount - pinter to count to return
*
*  Returns:    NT status code
*
*
*****************************************************************************/
NTSTATUS
ReceivePreprocessFifo(
		IN OUT PIR_DEVICE pThisDev,
		OUT PULONG pFifoCount
	)
{
	NTSTATUS Status;

#ifdef WORKAROUND_POLLING_FIFO_COUNT
 	LARGE_INTEGER CurrentTime;
	BOOLEAN SlowReceive;
	ULONG OldFifoCount = 0;
	LONG Delay;
	
	//
    // Set the receive algorithm
	//
#if defined(SUPPORT_LA8)
	if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
		SlowReceive = FALSE;
	else
#endif
		SlowReceive = TRUE;

	if( SlowReceive )
	{
		Status = St4200GetFifoCount( pThisDev, pFifoCount );
		if( Status != STATUS_SUCCESS )
		{
			DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): USB failure\n"));
			return Status;
		}
	}
	else
	{
		*pFifoCount = 1;
	}

	//
	// Receive the data
	//
    if( *pFifoCount || pThisDev->fReadHoldingReg )
    {
		//
		// See if we need to take care of the fake empty FIFO
		//
#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
		if( *pFifoCount )
		{
#endif
			//
			// If we are in SIR read again until we see a stable value
			//
			if( (pThisDev->currentSpeed <= MAX_SIR_SPEED) && (pThisDev->currentSpeed != SPEED_9600) && SlowReceive )
			{
				//
				// Make also sure we don't ever wrap
				//
				while( (OldFifoCount != *pFifoCount) && (*pFifoCount < 9*STIR4200_FIFO_SIZE/10) )
				{
					OldFifoCount = *pFifoCount;
					St4200GetFifoCount( pThisDev, pFifoCount );
				}
			}

			//
			// If we are in FIR we need to delay
			//
			if( (pThisDev->currentSpeed > MAX_MIR_SPEED) && SlowReceive )
			{
				if( pThisDev->ChipRevision < CHIP_REVISION_7 )
				{
#if !defined(ONLY_ERROR_MESSAGES)
					DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): Delaying\n"));
#endif
					Delay = STIR4200_READ_DELAY - (STIR4200_READ_DELAY*(*pFifoCount))/STIR4200_ESC_PACKET_SIZE;
					if( Delay > 0 )
					{
						NdisStallExecution( (ULONG)Delay );
					}
				}
				else //if( pThisDev->dongleCaps.windowSize == 2 )
				{
					/*if( !(*pFifoCount%10) )
					{
						DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): Forcing wrap\n"));
						NdisMSleep( 1000 );
					}*/
					Delay = pThisDev->ReceiveAdaptiveDelay - 
						(pThisDev->ReceiveAdaptiveDelay*(*pFifoCount))/STIR4200_MULTIPLE_READ_THREHOLD;
					if( Delay > 0 )
					{
						NdisStallExecution( (ULONG)Delay );
					}
				}
			}
#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
		}
		//
		// Read after a successful bulk-in with count of zero
		//
		else
		{
			pThisDev->fReadHoldingReg = FALSE;
		}
#endif

		//
		// Perform the read
		//
		pThisDev->PreReadBuffer.DataLen = 0;
		Status = ReceivePacketRead( 
				pThisDev,
				&pThisDev->PreReadBuffer
			);

		if( Status == STATUS_SUCCESS )
		{
			*pFifoCount = pThisDev->PreReadBuffer.DataLen;

#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
			//
			// If we got data restore the flag
			//
			if( *pFifoCount )
			{
				pThisDev->fReadHoldingReg = TRUE;
			}
#endif

#if !defined(ONLY_ERROR_MESSAGES) && defined( WORKAROUND_FAKE_EMPTY_FIFO )
			if( *pFifoCount && !pThisDev->fReadHoldingReg )
				DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): Final byte(s) workaround\n"));
#endif

#if defined(RECEIVE_LOGGING)
			if( pThisDev->ReceiveFileHandle && *pFifoCount )
			{
				IO_STATUS_BLOCK IoStatusBlock;

				ZwWriteFile(
						pThisDev->ReceiveFileHandle,
						NULL,
						NULL,
						NULL,
						&IoStatusBlock,
						pThisDev->PreReadBuffer.pDataBuf,
						pThisDev->PreReadBuffer.DataLen,
						(PLARGE_INTEGER)&pThisDev->ReceiveFilePosition,
						NULL
				   );

				pThisDev->ReceiveFilePosition += pThisDev->PreReadBuffer.DataLen;
			}
#endif
		}
		else
		{
			DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): USB failure\n"));
			pThisDev->PreReadBuffer.DataLen = 0;
			*pFifoCount = 0;
		}
    }
#else
	Status = ReceivePacketRead( 
			pThisDev,
			&pThisDev->PreReadBuffer
		);

	if( Status == STATUS_SUCCESS )
		*pFifoCount = pThisDev->PreReadBuffer.DataLen;
#endif

	return Status;
}


/*****************************************************************************
*
*  Function:	ReceiveGetFifoData
*
*  Synopsis:	Load the preprocessed data if any is vailable, otherwise tries to read and load new data
*
*  Arguments:	pThisDev - pointer to current ir device object
*			  	pData - buffer to copy to
*				pBytesRead - pointer to return bytes read
*				BytesToRead - requested number of bytes
*
*  Returns:		Number of bytes in the FIFO
*
*
*****************************************************************************/
NTSTATUS
ReceiveGetFifoData(
		IN OUT PIR_DEVICE pThisDev,
		OUT PUCHAR pData,
		OUT PULONG pBytesRead,
		ULONG BytesToRead
	)
{
	NTSTATUS Status;

#ifdef WORKAROUND_POLLING_FIFO_COUNT
	LARGE_INTEGER CurrentTime;
	BOOLEAN SlowReceive;
    ULONG FifoCount = 0, OldFifoCount = 0;
	LONG Delay;

    //
	// Make sure if there is data in the preread buffer
	//
	if( pThisDev->PreReadBuffer.DataLen )
    {
		ULONG OutputBufferSize;
		
		IRUSB_ASSERT( pThisDev->PreReadBuffer.DataLen <= BytesToRead );

		//
		// Copy the data
		//
        RtlCopyMemory( pData, pThisDev->PreReadBuffer.pDataBuf, pThisDev->PreReadBuffer.DataLen );
		
#if !defined(WORKAROUND_BROKEN_MIR)
		//
		// Consider MIR
		//
		if( pThisDev->currentSpeed == SPEED_1152000 )
			ReceiveMirUnstuff(
					pThisDev,
					pData,
					pThisDev->PreReadBuffer.DataLen,
					pThisDev->pRawUnstuffedBuf,
					&OutputBufferSize
				);
#endif

		*pBytesRead = pThisDev->PreReadBuffer.DataLen;
		pThisDev->PreReadBuffer.DataLen = 0;
        return STATUS_SUCCESS;
    }
	//
	// Try to read if no data is already available
	//
    else
    {
		//
		// Set the receive algorithm
		//
#if defined(SUPPORT_LA8)
		if( pThisDev->ChipRevision >= CHIP_REVISION_8 ) 
			SlowReceive = FALSE;
		else
#endif
			SlowReceive = TRUE;

		if( SlowReceive )
		{
			Status = St4200GetFifoCount( pThisDev, &FifoCount );
			if( Status != STATUS_SUCCESS )
			{
				DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): USB failure\n"));
				return Status;
			}
		}
		else
		{
			FifoCount = 1; 
		}

		//
		// Receive the data
		//
		if( FifoCount || pThisDev->fReadHoldingReg )
		{
			//
			// See if we need to take care of the fake empty FIFO
			//
#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
			if( FifoCount )
			{
#endif
				//
				// If we are in SIR read again until we see a stable value
				//
#if defined( WORKAROUND_9600_ANTIBOUNCING )
				if( (pThisDev->currentSpeed <= MAX_SIR_SPEED) && SlowReceive )
				{
					if( pThisDev->currentSpeed != SPEED_9600 )
					{
						//
						// Make also sure we don't ever wrap
						//
						while( (OldFifoCount != FifoCount) && (FifoCount < 9*STIR4200_FIFO_SIZE/10) )
						{
							OldFifoCount = FifoCount;
							St4200GetFifoCount( pThisDev, &FifoCount );
						}
					}
					else
					{
						if( pThisDev->rcvState != STATE_INIT )
						{
							while( OldFifoCount != FifoCount )
							{
								OldFifoCount = FifoCount;
								St4200GetFifoCount( pThisDev, &FifoCount );
							}
						}
					}
				}
#else
				if( (pThisDev->currentSpeed <= MAX_SIR_SPEED) && ( pThisDev->currentSpeed != SPEED_9600) && SlowReceive )
				{
					while( OldFifoCount != FifoCount )
					{
						OldFifoCount = FifoCount;
						St4200GetFifoCount( pThisDev, &FifoCount );
					}
				}
#endif

				//
				// If we are in FIR we need to delay
				//
				if( (pThisDev->currentSpeed > MAX_MIR_SPEED) && SlowReceive )
				{
					if( pThisDev->ChipRevision <= CHIP_REVISION_6 ) 
					{
#if !defined(ONLY_ERROR_MESSAGES)
						DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): Delaying\n"));
#endif
						Delay = STIR4200_READ_DELAY - (STIR4200_READ_DELAY*FifoCount)/STIR4200_ESC_PACKET_SIZE;
						if( Delay > 0 )
						{
							NdisStallExecution( (ULONG)Delay );
						}
					}
					else //if( pThisDev->dongleCaps.windowSize == 2 )
					{
						/*if( !(FifoCount%10) )
						{
							DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): Forcing wrap\n"));
							NdisMSleep( 1000 );
						}*/
						Delay = pThisDev->ReceiveAdaptiveDelay - 
							(pThisDev->ReceiveAdaptiveDelay*FifoCount)/STIR4200_MULTIPLE_READ_THREHOLD;
						if( Delay > 0 )
						{
							NdisStallExecution( (ULONG)Delay );
						}
					}
				}
#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
			}
			else
			{
				// Force antibouncing to take care of OHCI
				if( pThisDev->currentSpeed <= MAX_SIR_SPEED )
				{
					if( pThisDev->rcvState != STATE_INIT )
					{
						OldFifoCount = 1;
						while( OldFifoCount != FifoCount )
						{
							OldFifoCount = FifoCount;
							St4200GetFifoCount( pThisDev, &FifoCount );
						}
					}
				}
				pThisDev->fReadHoldingReg = FALSE;
			}
#endif

			//
			// Perform the read
			//
			pThisDev->PreReadBuffer.DataLen = 0;
			Status = ReceivePacketRead( 
					pThisDev,
					&pThisDev->PreReadBuffer
				);

			if( Status == STATUS_SUCCESS )
			{
				IRUSB_ASSERT( pThisDev->PreReadBuffer.DataLen <= BytesToRead );
				
				//
				// Copy the data
				//
				RtlCopyMemory( pData, pThisDev->PreReadBuffer.pDataBuf, pThisDev->PreReadBuffer.DataLen );
				FifoCount = pThisDev->PreReadBuffer.DataLen;

#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
				//
				// If we got data restore the flag
				//
				if( FifoCount )
				{
					pThisDev->fReadHoldingReg = TRUE;
				}
#endif

#if !defined(ONLY_ERROR_MESSAGES) && defined( WORKAROUND_FAKE_EMPTY_FIFO )
				if( FifoCount && !pThisDev->fReadHoldingReg )
					DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): Final byte(s) workaround\n"));
#endif

#if defined(RECEIVE_LOGGING)
				if( pThisDev->ReceiveFileHandle && FifoCount )
				{
					IO_STATUS_BLOCK IoStatusBlock;

					ZwWriteFile(
							pThisDev->ReceiveFileHandle,
							NULL,
							NULL,
							NULL,
							&IoStatusBlock,
							pThisDev->PreReadBuffer.pDataBuf,
							pThisDev->PreReadBuffer.DataLen,
							(PLARGE_INTEGER)&pThisDev->ReceiveFilePosition,
							NULL
					   );

					pThisDev->ReceiveFilePosition += pThisDev->PreReadBuffer.DataLen;
				}
#endif
				pThisDev->PreReadBuffer.DataLen = 0;
			}
			else
			{
				DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): USB failure\n"));
				pThisDev->PreReadBuffer.DataLen = 0;
				FifoCount = 0;
			}
		}
	}

	*pBytesRead = FifoCount;
    return Status;
#else
    if( pThisDev->PreReadBuffer.DataLen )
    {
		IRUSB_ASSERT( pThisDev->PreReadBuffer.DataLen <= BytesToRead );

		//
		// Copy the data
		//
        RtlCopyMemory( pData, pThisDev->PreReadBuffer.pDataBuf, pThisDev->PreReadBuffer.DataLen );
		*pBytesRead = pThisDev->PreReadBuffer.DataLen;
		pThisDev->PreReadBuffer.DataLen = 0;
        return STATUS_SUCCESS;
    }
    else
    {
		Status = ReceivePacketRead( 
				pThisDev,
				&pThisDev->PreReadBuffer
			);

		if( Status == STATUS_SUCCESS )
		{
			RtlCopyMemory( pData, pThisDev->PreReadBuffer.pDataBuf, pThisDev->PreReadBuffer.DataLen );
			*pBytesRead = pThisDev->PreReadBuffer.DataLen;
			pThisDev->PreReadBuffer.DataLen = 0;
		}

		return Status;
    }
#endif
}


/*****************************************************************************
*
*  Function:    ReceiveFirStepFSM
*
*  Synopsis:	Step the receive FSM to read in a piece of an IrDA frame. 
*				Strip the BOFs and EOF, and eliminate escape sequences.
*
*  Arguments:	pIrDev - pointer to the current IR device object
*				pBytesProcessed - pointer to bytes processed
*
*  Returns:		TRUE after an entire frame has been read in
*				FALSE otherwise
*
*****************************************************************************/
BOOLEAN
ReceiveFirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	)
{
    ULONG           rawBufPos, rawBytesRead;
    BOOLEAN         FrameProcessed = FALSE, ForceExit = FALSE;
    UCHAR           ThisChar;
    PUCHAR          pRawBuf, pReadBuf;
	PRCV_BUFFER		pRecBuf;
    
	*pBytesProcessed = 0;

	if( !pIrDev->pCurrentRecBuf )
	{
		UINT Index;
		
		pRecBuf = ReceiveGetBuf( pIrDev, &Index, RCV_STATE_FULL );
		if( !pRecBuf )
		{
			//
			// no buffers available; stop
			//
			DEBUGMSG(DBG_ERR, (" ReceiveSirStepFSM out of buffers\n"));
			pIrDev->packetsReceivedNoBuffer ++;
			return FALSE;
		}

		pIrDev->pCurrentRecBuf = pRecBuf;
	}
	else
		pRecBuf = pIrDev->pCurrentRecBuf;

	pReadBuf = pRecBuf->pDataBuf;
    pRawBuf = pIrDev->pRawBuf;

    /***********************************************/
    /*   Read  in  and process groups of incoming  */
    /*   bytes from the FIFO.                      */
    /***********************************************/
    while( (pIrDev->rcvState != STATE_SAW_EOF) && 
		(pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE)) &&
		!ForceExit )
    {
        if( pIrDev->rcvState == STATE_CLEANUP )
        {
            /***********************************************/
            /*   We returned a complete packet last time,  */
            /*   but  we had read some extra bytes, which  */
            /*   we   stored   into   the   rawBuf  after  */
            /*   returning  the  previous complete buffer  */
            /*   to  the  user.  So  instead  of  calling  */
            /*   DoRcvDirect() in this first execution of  */
            /*   this  loop, we just use these previously  */
            /*   read bytes. (This is typically only 1 or  */
            /*   2 bytes).                                 */
            /***********************************************/
            rawBytesRead = pIrDev->rawCleanupBytesRead;
            pIrDev->rcvState = STATE_INIT;
        }
        else
        {
            if( ReceiveGetFifoData( pIrDev, pRawBuf, &rawBytesRead, STIR4200_FIFO_SIZE ) == STATUS_SUCCESS )
			{
				if( rawBytesRead == (ULONG)-1 )
				{
					/***********************************************/
					/*   Receive error...back to INIT state...     */
					/***********************************************/
					pIrDev->rcvState	= STATE_INIT;
					pIrDev->readBufPos	= 0;
					continue;
				}
				else if( rawBytesRead == 0 )
				{
					/***********************************************/
					/*   No more receive bytes...break out...      */
					/***********************************************/
					break;
				}
			}
			else
				break;
        }

        /***********************************************/
        /*   Let  the  receive  state machine process  */
        /*   this group of bytes.                      */
        /*                                             */
        /*   NOTE:  We  have  to loop once more after  */
        /*   getting  MAX_RCV_DATA_SIZE bytes so that  */
        /*   we  can  see the 'EOF'; hence <= and not  */
        /*   <.                                        */
        /***********************************************/
        for( rawBufPos = 0;
             ((pIrDev->rcvState != STATE_SAW_EOF) && (rawBufPos < rawBytesRead) && 
			 (pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE)));
             rawBufPos++ )
        {
            *pBytesProcessed += 1;
            ThisChar = pRawBuf[rawBufPos];
            switch( pIrDev->rcvState )
            {
				case STATE_INIT:
					switch( ThisChar )
					{
						case STIR4200_FIR_BOF:
							pIrDev->rcvState = STATE_GOT_FIR_BOF;
							break;
#if defined(WORKAROUND_XX_HANG)
						case 0x3F:
							if( (rawBufPos+1) < rawBytesRead )
							{
								if( pRawBuf[rawBufPos+1] == 0x3F )
								{
									DEBUGMSG(DBG_INT_ERR, 
										(" ReceiveFirStepFSM(): hang sequence in INIT state\n"));
									St4200ResetFifo( pIrDev );
								}
							}
							break;
#endif
#if defined(WORKAROUND_FF_HANG)
						case 0xFF:
							if( (rawBufPos+2) < rawBytesRead )
							{
								if( (pRawBuf[rawBufPos+2] == 0xFF) && (pRawBuf[rawBufPos+1] == 0xFF) &&
									(rawBytesRead>STIR4200_FIFO_OVERRUN_THRESHOLD) )
								{
									DEBUGMSG(DBG_INT_ERR, 
										(" ReceiveFirStepFSM(): overflow sequence in INIT state\n"));
									St4200ResetFifo( pIrDev );
									rawBufPos = rawBytesRead;
									ForceExit = TRUE;
								}
							}
							break;
#endif
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char in INIT state\n"));
							break;
					}
					break;

				case STATE_GOT_FIR_BOF:
					switch( ThisChar )
					{
						case STIR4200_FIR_BOF:
							pIrDev->rcvState = STATE_GOT_BOF;
							break;
#if defined(WORKAROUND_BAD_ESC)
						case STIR4200_FIR_ESC_CHAR:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char in BOF state, bufpos=%d, char=%X\n", pIrDev->readBufPos, (ULONG)ThisChar));
							if( rawBufPos < (rawBytesRead-1) )
							{
								pIrDev->rcvState = STATE_GOT_BOF;
								rawBufPos ++;
							}
							else
							{
								pIrDev->rcvState = STATE_INIT;
								pIrDev->readBufPos = 0;
							}
							break;
#endif
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char in BOF state, bufpos=%d, char=%X\n", pIrDev->readBufPos, (ULONG)ThisChar));
#if defined(WORKAROUND_BAD_SOF)
							pIrDev->rcvState = STATE_GOT_BOF;
							rawBufPos --;
#else
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
#endif
							break;
					}
					break;

				case STATE_GOT_BOF:
					switch( ThisChar )
					{
						case STIR4200_FIR_BOF:
							/***********************************************/
							/*   It's a mistake, but could still be valid data
							/***********************************************/
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): More than legal BOFs, bufpos=%d\n", pIrDev->readBufPos));
							pIrDev->rcvState = STATE_GOT_BOF;
							pIrDev->readBufPos = 0;                    
							break;
						case STIR4200_FIR_PREAMBLE:
							/***********************************************/
							/*   Garbage                                   */
							/***********************************************/
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char in BOF state, bufpos=%d, char=%X\n", pIrDev->readBufPos, (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;                     
							break;
						case STIR4200_FIR_ESC_CHAR:
							/***********************************************/
							/*   Start  of  data.  Our  first  data  byte  */
							/*   happens to be an ESC sequence.            */
							/***********************************************/
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							pIrDev->readBufPos = 0;
							break;
						default:
							pReadBuf[0] = ThisChar;
							pIrDev->rcvState = STATE_ACCEPTING;
							pIrDev->readBufPos = 1;
							break;
					}
					break;

				case STATE_ACCEPTING:
					switch( ThisChar )
					{
						case STIR4200_FIR_EOF:
#if defined( WORKAROUND_33_HANG )
							if( pIrDev->readBufPos < (IRDA_A_C_TOTAL_SIZE + FAST_IR_FCS_SIZE - 1) )
#else
							if( pIrDev->readBufPos < (IRDA_A_C_TOTAL_SIZE + FAST_IR_FCS_SIZE) )
#endif
							{
								DEBUGMSG(DBG_INT_ERR, 
									("ReceiveFirStepFSM(): WARNING: EOF encountered in short packet, bufpos=%d\n", pIrDev->readBufPos));
								pIrDev->packetsReceivedRunt ++;
								pIrDev->rcvState = STATE_INIT;
								pIrDev->readBufPos = 0;
							}
							else
							{
#if defined( WORKAROUND_MISSING_7E )
								// Force to get out if there is one EOF and we have no more data
								if( rawBufPos == (rawBytesRead-1) )
								{
#if !defined(ONLY_ERROR_MESSAGES)
									DEBUGMSG(DBG_INT_ERR, ("ReceiveFirStepFSM(): Using a single 7E EOF\n"));
#endif
									pIrDev->rcvState = STATE_SAW_EOF;
								}
								else
									pIrDev->rcvState = STATE_SAW_FIR_BOF;
#else
								pIrDev->rcvState = STATE_SAW_FIR_BOF;
#endif
							}
							break;
						case STIR4200_FIR_ESC_CHAR:
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							break;
						case STIR4200_FIR_PREAMBLE:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid preamble char in ACCEPTING state, bufpos=%d\n", pIrDev->readBufPos));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;                    
							break;
						default:
							pReadBuf[pIrDev->readBufPos++] = ThisChar;
							break;
					}
					break;

				case STATE_ESC_SEQUENCE:
					switch( ThisChar )
					{
						case STIR4200_FIR_ESC_DATA_7D:
							pReadBuf[pIrDev->readBufPos++] = 0x7d;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						case STIR4200_FIR_ESC_DATA_7E:
							pReadBuf[pIrDev->readBufPos++] = 0x7e;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						case STIR4200_FIR_ESC_DATA_7F:
							pReadBuf[pIrDev->readBufPos++] = 0x7f;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid escaped char=%X\n", (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
							break;
					}
					break;

				case STATE_SAW_FIR_BOF:
					switch( ThisChar )
					{
						case STIR4200_FIR_EOF:
							pIrDev->rcvState = STATE_SAW_EOF;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char=%X, expected EOF\n", (ULONG)ThisChar));
							pIrDev->rcvState = STATE_SAW_EOF;
#if !defined(WORKAROUND_MISSING_7E)
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
#endif
							break;
					}
					break;

				case STATE_SAW_EOF:
					default:
						DEBUGMSG(DBG_ERR, (" ReceiveFirStepFSM(): Illegal state, bufpos=%d\n", pIrDev->readBufPos));
						IRUSB_ASSERT( 0 );
						pIrDev->readBufPos = 0;
						pIrDev->rcvState = STATE_INIT;
						return FALSE;
            }
        }
    }

    // *  Set result and do any post-cleanup.
    switch( pIrDev->rcvState )
    {
		case STATE_SAW_EOF:
			/***********************************************/
			/*   We've  read  in the entire packet. Queue  */
			/*   it and return TRUE.                       */
			/***********************************************/
 			pRecBuf->DataLen = pIrDev->readBufPos;
			pIrDev->pCurrentRecBuf = NULL;
			ReceiveDeliverBuffer(
					pIrDev,
					pRecBuf
				);
			FrameProcessed = TRUE;
			if( rawBufPos < rawBytesRead )
			{
				/***********************************************/
				/*   This   is   ugly.   We  have  some  more  */
				/*   unprocessed  bytes  in  the  raw buffer.  */
				/*   Move  these  to the beginning of the raw  */
				/*   buffer  go  to  the CLEANUP state, which  */
				/*   indicates  that  these  bytes be used up  */
				/*   during the next call. (This is typically  */
				/*   only 1 or 2 bytes).                       */
				/*                                             */
				/*   Note:  We  can't just leave these in the  */
				/*   raw   buffer   because   we   might   be  */
				/*   supporting  connections  to multiple COM  */
				/*   ports.                                    */
				/*                                             */
				/***********************************************/
				RtlMoveMemory( pRawBuf, &pRawBuf[rawBufPos], rawBytesRead - rawBufPos );
				pIrDev->rawCleanupBytesRead = rawBytesRead - rawBufPos;
				pIrDev->rcvState   = STATE_CLEANUP;
			}
			else
			{
				pIrDev->rcvState = STATE_INIT;
			}
			pIrDev->readBufPos = 0;                                 
			break;
		default:
			if( pIrDev->readBufPos > (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE) )
			{
				DEBUGMSG( DBG_INT_ERR,(" ReceiveFirStepFSM() Overflow\n"));
				St4200ResetFifo( pIrDev );

				pIrDev->packetsReceivedOverflow ++;
				pIrDev->rcvState    = STATE_INIT;
				pIrDev->readBufPos  = 0;
				pIrDev->pCurrentRecBuf = NULL;
				InterlockedExchange( &pRecBuf->DataLen, 0 );
				InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			}
			else
			{
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG(DBG_INT_ERR, 
					(" ReceiveFirStepFSM(): returning with partial packet, read %d bytes\n", pIrDev->readBufPos));
#endif
			}
			FrameProcessed = FALSE;
			break;
    }
    return FrameProcessed;
}


#if !defined(WORKAROUND_BROKEN_MIR)
/*****************************************************************************
*
*  Function:    ReceiveMirUnstuff
*
*  Synopsis:	Software unstuffing for a MIR frmae
*
*  Arguments:	pIrDev - pointer to the current IR device object
*				pBytesProcessed - pointer to bytes processed
*
*  Returns:		TRUE after an entire frame has been read in
*
*****************************************************************************/
BOOLEAN
ReceiveMirUnstuff(
		IN OUT PIR_DEVICE pIrDev,
		IN PUCHAR pInputBuffer,
		ULONG InputBufferSize,
		OUT PUCHAR pOutputBuffer,
		OUT PULONG pOutputBufferSize
	)
{
	ULONG MirIncompleteBitCount = pIrDev->MirIncompleteBitCount;
	ULONG MirOneBitCount = pIrDev->MirOneBitCount;
	UCHAR MirIncompleteByte = pIrDev->MirIncompleteByte;
	ULONG ByteCounter, BitCounter;
	BOOL MirUnstuffNext = FALSE;

	*pOutputBufferSize = 0;

	if( MirOneBitCount == 5 )
	{
		MirUnstuffNext = TRUE;
	}

	//
	// Loop on the input buffer
	//
	for( ByteCounter=0; ByteCounter<InputBufferSize; ByteCounter++ )
	{
		//
		// Loop on the byte
		//
		for( BitCounter=0; BitCounter<8; BitCounter++ )
		{
			//
			// test for one
			//
			if( pInputBuffer[ByteCounter] & (0x01<<BitCounter) )
			{
				//
				// Sixth one, reset
				//
				if( MirUnstuffNext )
				{
					MirOneBitCount = 0;
					MirUnstuffNext = FALSE;

					pIrDev->MirFlagCount ++;
				}
				//
				// Increase the one count
				//
				else
				{
					MirOneBitCount ++;
					if( MirOneBitCount == 5 )
					{
						MirUnstuffNext = TRUE;
					}
				}

				//
				// Copy to the temp byte
				//
				MirIncompleteByte += 0x01<<MirIncompleteBitCount;
				
				//
				// Increase the output bit count
				// 
				MirIncompleteBitCount ++;
			}
			else
			{
				//
				// Increase the output bit count if we are not stuffing
				// 
				if( !MirUnstuffNext )
				{
					MirIncompleteBitCount ++;
				}

				//
				// Reset
				//
				MirOneBitCount = 0;
				MirUnstuffNext = FALSE;

				//
				// No copy needs to be done
				//
			}

			//
			// Flush to output buffer
			//
			if( MirIncompleteBitCount == 8 )
			{
				pOutputBuffer[*pOutputBufferSize] = MirIncompleteByte;
				(*pOutputBufferSize) ++;

				MirIncompleteBitCount = 0;
				MirIncompleteByte = 0;
			}

			//
			// Check for complete packet
			//
			if( pIrDev->MirFlagCount == 2 )
			{
				pIrDev->MirFlagCount = 0;

				pIrDev->MirIncompleteBitCount = 0;
				pIrDev->MirOneBitCount = 0;
				pIrDev->MirIncompleteByte = 0;

				return TRUE;
			}
		}
	}
	
	//
	// roll over
	//
	pIrDev->MirIncompleteBitCount = MirIncompleteBitCount;
	pIrDev->MirOneBitCount = MirOneBitCount;
	pIrDev->MirIncompleteByte = MirIncompleteByte;
	
	return FALSE;
}
#endif


/*****************************************************************************
*
*  Function:    ReceiveMirStepFSM
*
*  Synopsis:	Step the receive FSM to read in a piece of an IrDA frame. 
*				Strip the BOFs and EOF, and eliminate escape sequences.
*
*  Arguments:	pIrDev - pointer to the current IR device object
*				pBytesProcessed - pointer to bytes processed
*
*  Returns:		TRUE after an entire frame has been read in
*				FALSE otherwise
*
*****************************************************************************/
BOOLEAN
ReceiveMirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	)
{
    ULONG           rawBufPos, rawBytesRead;
    BOOLEAN         FrameProcessed = FALSE, ForceExit = FALSE;
    UCHAR           ThisChar;
    PUCHAR          pRawBuf, pReadBuf;
	PRCV_BUFFER		pRecBuf;
    
	*pBytesProcessed = 0;

	if( !pIrDev->pCurrentRecBuf )
	{
		UINT Index;

		pRecBuf = ReceiveGetBuf( pIrDev, &Index, RCV_STATE_FULL );
		if ( !pRecBuf)
		{
			//
			// no buffers available; stop
			//
			DEBUGMSG(DBG_ERR, (" ReceiveMirStepFSM out of buffers\n"));
			pIrDev->packetsReceivedNoBuffer ++;
			return FALSE;
		}

		pIrDev->pCurrentRecBuf = pRecBuf;
	}
	else
		pRecBuf = pIrDev->pCurrentRecBuf;

	pReadBuf = pRecBuf->pDataBuf;
    pRawBuf = pIrDev->pRawBuf;

    /***********************************************/
    /*   Read  in  and process groups of incoming  */
    /*   bytes from the FIFO.                      */
    /***********************************************/
    while( (pIrDev->rcvState != STATE_SAW_EOF) && 
		(pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + MEDIUM_IR_FCS_SIZE)) &&
		!ForceExit )
    {
        if( pIrDev->rcvState == STATE_CLEANUP )
        {
            /***********************************************/
            /*   We returned a complete packet last time,  */
            /*   but  we had read some extra bytes, which  */
            /*   we   stored   into   the   rawBuf  after  */
            /*   returning  the  previous complete buffer  */
            /*   to  the  user.  So  instead  of  calling  */
            /*   DoRcvDirect() in this first execution of  */
            /*   this  loop, we just use these previously  */
            /*   read bytes. (This is typically only 1 or  */
            /*   2 bytes).                                 */
            /***********************************************/
            rawBytesRead = pIrDev->rawCleanupBytesRead;
            pIrDev->rcvState = STATE_INIT;
        }
        else
        {
            if( ReceiveGetFifoData( pIrDev, pRawBuf, &rawBytesRead, STIR4200_FIFO_SIZE ) == STATUS_SUCCESS )
			{
				if( rawBytesRead == (ULONG)-1 )
				{
					/***********************************************/
					/*   Receive error...back to INIT state...     */
					/***********************************************/
					pIrDev->rcvState	= STATE_INIT;
					pIrDev->readBufPos	= 0;
					continue;
				}
				else if( rawBytesRead == 0 )
				{
					/***********************************************/
					/*   No more receive bytes...break out...      */
					/***********************************************/
					break;
				}
			}
			else
				break;
        }

        /***********************************************/
        /*   Let  the  receive  state machine process  */
        /*   this group of bytes.                      */
        /*                                             */
        /*   NOTE:  We  have  to loop once more after  */
        /*   getting  MAX_RCV_DATA_SIZE bytes so that  */
        /*   we  can  see the 'EOF'; hence <= and not  */
        /*   <.                                        */
        /***********************************************/
        for( rawBufPos = 0;
             ((pIrDev->rcvState != STATE_SAW_EOF) && (rawBufPos < rawBytesRead) && 
			 (pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + MEDIUM_IR_FCS_SIZE)));
             rawBufPos++ )
        {
            *pBytesProcessed += 1;
            ThisChar = pRawBuf[rawBufPos];
            switch( pIrDev->rcvState )
            {
				case STATE_INIT:
					switch( ThisChar )
					{
						case STIR4200_MIR_BOF:
							pIrDev->rcvState = STATE_GOT_MIR_BOF;
							break;
						case 0xFF:
							if( ((rawBufPos+2) < rawBytesRead) && (rawBufPos==0) )
							{
								if( (pRawBuf[rawBufPos+2] == 0xFF) && (pRawBuf[rawBufPos+1] == 0xFF) )
								{
									DEBUGMSG(DBG_INT_ERR, 
										(" ReceiveMirStepFSM(): overflow sequence in INIT state\n"));
									St4200ResetFifo( pIrDev );
									St4200SoftReset( pIrDev );
									//rawBufPos = rawBytesRead;
									//ForceExit = TRUE;
								}
							}
							break;
						default:
							break;
					}
					break;

				case STATE_GOT_MIR_BOF:
					switch( ThisChar )
					{
						case STIR4200_MIR_BOF:
							pIrDev->rcvState = STATE_GOT_BOF;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveMirStepFSM(): invalid char in BOF state, bufpos=%d\n", pIrDev->readBufPos));
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
							break;
					}
					break;

				case STATE_GOT_BOF:
					switch( ThisChar )
					{
						case STIR4200_MIR_BOF:
							/***********************************************/
							/*   It's a mistake, but could still be valid data
							/***********************************************/
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveMirStepFSM(): More than legal BOFs, bufpos=%d\n", pIrDev->readBufPos));
							pIrDev->readBufPos = 0;                    
							pIrDev->rcvState = STATE_GOT_BOF;
							break;
						case STIR4200_MIR_ESC_CHAR:
							/***********************************************/
							/*   Start  of  data.  Our  first  data  byte  */
							/*   happens to be an ESC sequence.            */
							/***********************************************/
							pIrDev->readBufPos = 0;
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							break;
						default:
							pReadBuf[0] = ThisChar;
							pIrDev->readBufPos = 1;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
					}
					break;

				case STATE_ACCEPTING:
					switch( ThisChar )
					{
						case STIR4200_MIR_EOF:
							if( pIrDev->readBufPos < (IRDA_A_C_TOTAL_SIZE + MEDIUM_IR_FCS_SIZE) )
							{
								DEBUGMSG(DBG_INT_ERR, 
									(" ReceiveMirStepFSM(): WARNING: EOF encountered in short packet, bufpos=%d\n", pIrDev->readBufPos));
								pIrDev->packetsReceivedRunt ++;
								pIrDev->rcvState = STATE_INIT;
								pIrDev->readBufPos = 0;
							}
							else
							{
								pIrDev->rcvState = STATE_SAW_FIR_BOF;
							}
							break;
						case STIR4200_MIR_ESC_CHAR:
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							break;
						default:
							pReadBuf[pIrDev->readBufPos++] = ThisChar;
							break;
					}
					break;

				case STATE_ESC_SEQUENCE:
					switch( ThisChar )
					{
						case STIR4200_MIR_ESC_DATA_7D:
							pReadBuf[pIrDev->readBufPos++] = 0x7d;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						case STIR4200_MIR_ESC_DATA_7E:
							pReadBuf[pIrDev->readBufPos++] = 0x7e;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid escaped char=%X\n", (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
							break;
					}
					break;

				case STATE_SAW_MIR_BOF:
					switch( ThisChar )
					{
						case STIR4200_MIR_EOF:
							pIrDev->rcvState = STATE_SAW_EOF;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveMirStepFSM(): invalid char=%X, expected EOF\n", (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
							break;
					}
					break;

				case STATE_SAW_EOF:
					default:
						DEBUGMSG(DBG_INT_ERR, 
							(" ReceiveMirStepFSM(): Illegal state, bufpos=%d\n", pIrDev->readBufPos));
						IRUSB_ASSERT( 0 );
						pIrDev->readBufPos = 0;
						pIrDev->rcvState = STATE_INIT;
						return FALSE;
            }
        }
    }

    // *  Set result and do any post-cleanup.
    switch( pIrDev->rcvState )
    {
		case STATE_SAW_EOF:
			/***********************************************/
			/*   We've  read  in the entire packet. Queue  */
			/*   it and return TRUE.                       */
			/***********************************************/
 			pRecBuf->DataLen = pIrDev->readBufPos;
			pIrDev->pCurrentRecBuf = NULL;
			ReceiveDeliverBuffer(
					pIrDev,
					pRecBuf
				);
			FrameProcessed = TRUE;
			if( rawBufPos < rawBytesRead )
			{
				/***********************************************/
				/*   This   is   ugly.   We  have  some  more  */
				/*   unprocessed  bytes  in  the  raw buffer.  */
				/*   Move  these  to the beginning of the raw  */
				/*   buffer  go  to  the CLEANUP state, which  */
				/*   indicates  that  these  bytes be used up  */
				/*   during the next call. (This is typically  */
				/*   only 1 or 2 bytes).                       */
				/*                                             */
				/*   Note:  We  can't just leave these in the  */
				/*   raw   buffer   because   we   might   be  */
				/*   supporting  connections  to multiple COM  */
				/*   ports.                                    */
				/*                                             */
				/***********************************************/
				RtlMoveMemory( pRawBuf, &pRawBuf[rawBufPos], rawBytesRead - rawBufPos );
				pIrDev->rawCleanupBytesRead = rawBytesRead - rawBufPos;
				pIrDev->rcvState   = STATE_CLEANUP;
			}
			else
			{
				pIrDev->rcvState = STATE_INIT;
			}
			pIrDev->readBufPos = 0;                                 
			break;
		default:
			if( pIrDev->readBufPos > (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + MEDIUM_IR_FCS_SIZE) )
			{
				DEBUGMSG( DBG_INT_ERR,(" ReceiveMirStepFSM() Overflow\n"));

				pIrDev->packetsReceivedOverflow ++;
				pIrDev->readBufPos  = 0;
				pIrDev->rcvState    = STATE_INIT;
				pIrDev->pCurrentRecBuf = NULL;
				InterlockedExchange( &pRecBuf->DataLen, 0 );
				InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			}
			else
			{
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG(DBG_INT_ERR, 
					(" ReceiveMirStepFSM(): returning with partial packet, read %d bytes\n", pIrDev->readBufPos));
#endif
			}
			FrameProcessed = FALSE;
			break;
    }
    return FrameProcessed;
}


/*****************************************************************************
*
*  Function:    ReceiveSirStepFSM
*
*  Synopsis:	Step the receive FSM to read in a piece of an IrDA frame. 
*				Strip the BOFs and EOF, and eliminate escape sequences.
*
*  Arguments:	pIrDev - pointer to the current IR device object
*				pBytesProcessed - pointer to bytes processed
*
*  Returns:		TRUE after an entire frame has been read in
*				FALSE otherwise
*
*****************************************************************************/
BOOLEAN     
ReceiveSirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	)
{
    ULONG           rawBufPos, rawBytesRead;
    BOOLEAN         FrameProcessed = FALSE, ForceExit = FALSE;
    UCHAR           ThisChar;
    PUCHAR          pRawBuf, pReadBuf;
	PRCV_BUFFER		pRecBuf;

    *pBytesProcessed = 0;

	if( !pIrDev->pCurrentRecBuf )
	{
		UINT Index;
		
		pRecBuf = ReceiveGetBuf( pIrDev, &Index, RCV_STATE_FULL );
		if ( !pRecBuf)
		{
			//
			// no buffers available; stop
			//
			DEBUGMSG(DBG_ERR, (" ReceiveSirStepFSM out of buffers\n"));
			pIrDev->packetsReceivedNoBuffer ++;
			return FALSE;
		}

		pIrDev->pCurrentRecBuf = pRecBuf;
	}
	else
		pRecBuf = pIrDev->pCurrentRecBuf;

	pReadBuf = pRecBuf->pDataBuf;
    pRawBuf = pIrDev->pRawBuf;

    // Read in and process groups of incoming bytes from the FIFO.
    // NOTE:  We have to loop once more after getting MAX_RCV_DATA_SIZE
    //        bytes so that we can see the 'EOF'; hence <= and not <.
    while( (pIrDev->rcvState != STATE_SAW_EOF) &&
           (pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + SLOW_IR_FCS_SIZE)) &&
		   !ForceExit )
    {
        if( pIrDev->rcvState == STATE_CLEANUP )
        {
            /***********************************************/
            /*   We returned a complete packet last time,  */
            /*   but  we had read some extra bytes, which  */
            /*   we   stored   into   the   rawBuf  after  */
            /*   returning  the  previous complete buffer  */
            /*   to  the  user.  So  instead  of  calling  */
            /*   DoRcvDirect() in this first execution of  */
            /*   this  loop, we just use these previously  */
            /*   read bytes. (This is typically only 1 or  */
            /*   2 bytes).                                 */
            /***********************************************/
            rawBytesRead		= pIrDev->rawCleanupBytesRead;
            pIrDev->rcvState    = STATE_INIT;
        }
        else
        {
            if( ReceiveGetFifoData( pIrDev, pRawBuf, &rawBytesRead, STIR4200_FIFO_SIZE ) == STATUS_SUCCESS )
			{
				if( rawBytesRead == (ULONG)-1 )
				{
					/***********************************************/
					/*   Receive error...back to INIT state...     */
					/***********************************************/
					DEBUGMSG( DBG_ERR,(" ReceiveSirStepFSM() Error in receiving packet\n"));
					pIrDev->rcvState	= STATE_INIT;
					pIrDev->readBufPos	= 0;
					continue;
				}
				else if( rawBytesRead == 0 )
				{
					/***********************************************/
					/*   No more receive bytes...break out...      */
					/***********************************************/
#if defined(WORKAROUND_MISSING_C1)
					if( (pIrDev->rcvState == STATE_ACCEPTING) && (pIrDev->ChipRevision <= CHIP_REVISION_7) )
					{
						pIrDev->rcvState = STATE_SAW_EOF;
						DEBUGMSG(DBG_INT_ERR, (" ReceiveSirStepFSM(): Missing C1 workaround\n"));
						pRecBuf->MissingC1Detected = TRUE;
					}
#endif
					break;
				}
			}
			else
				break;
        }

        /***********************************************/
        /*   Let  the  receive  state machine process  */
        /*   this group of bytes.                      */
        /*                                             */
        /*   NOTE:  We  have  to loop once more after  */
        /*   getting  MAX_RCV_DATA_SIZE bytes so that  */
        /*   we  can  see the 'EOF'; hence <= and not  */
        /*   <.                                        */
        /***********************************************/
        for( rawBufPos = 0; 
			((pIrDev->rcvState != STATE_SAW_EOF) && (rawBufPos < rawBytesRead) && 
			(pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + SLOW_IR_FCS_SIZE)));
			rawBufPos ++ )
        {
            *pBytesProcessed += 1;
            ThisChar = pRawBuf[rawBufPos];
            switch( pIrDev->rcvState )
            {
				case STATE_INIT:
					switch( ThisChar )
					{
#if defined(WORKAROUND_FF_HANG)
						case 0xFF:
							if( (rawBufPos+2) < rawBytesRead )
							{
								if( (pRawBuf[rawBufPos+2] == 0xFF) && (pRawBuf[rawBufPos+1] == 0xFF) &&
									(rawBytesRead>STIR4200_FIFO_OVERRUN_THRESHOLD) )
								{
									DEBUGMSG(DBG_INT_ERR, 
										(" ReceiveFirStepFSM(): overflow sequence in INIT state\n"));
									St4200DoubleResetFifo( pIrDev );
									rawBufPos = rawBytesRead;
									ForceExit = TRUE;
								}
							}
							break;
#endif
#if defined( WORKAROUND_E0_81_FLAG )
						// This will take care of wrong start flags at low rates
						case 0x81:
						case 0xe0:
#if !defined(ONLY_ERROR_MESSAGES)
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveSirStepFSM(): WORKAROUND_E0_81_FLAG\n"));
#endif
#endif
						case SLOW_IR_BOF:
							pIrDev->rcvState = STATE_GOT_BOF;
							break;
						case SLOW_IR_EOF:
						case SLOW_IR_ESC:
						default:
							/***********************************************/
							/*   Byte is garbage...scan past it....        */
							/***********************************************/
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveSirStepFSM(): invalid char in INIT state\n"));
							break;
					}
					break;

				case STATE_GOT_BOF:
					switch( ThisChar )
					{
						case SLOW_IR_BOF:
							break;
						case SLOW_IR_EOF:
							/***********************************************/
							/*   Garbage                                   */
							/***********************************************/
							DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Invalid char in BOF state\n"));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;                     
							break;
						case SLOW_IR_ESC:
							/***********************************************/
							/*   Start  of  data.  Our  first  data  byte  */
							/*   happens to be an ESC sequence.            */
							/***********************************************/
							pIrDev->rcvState    = STATE_ESC_SEQUENCE;
							pIrDev->readBufPos  = 0;
							break;
						default:
							pReadBuf[0] = ThisChar;
							pIrDev->rcvState   = STATE_ACCEPTING;
							pIrDev->readBufPos = 1;
							break;
					}
					break;

				case STATE_ACCEPTING:
					switch( ThisChar )
					{
						case SLOW_IR_BOF:
							//
							// Either a new packet is starting here and we're missing parts of the old one
							// or it's garbage
							//
#if !defined(WORKAROUND_MISSING_C1)
							DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Invalid char in ACCEPTING state\n"));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState    = STATE_INIT;
							pIrDev->readBufPos	= 0;
							break;
#else
							//
							// Take the packet and decrement the pointer in the FIFO decoding so that
							// the new packet can be processed
							//
							DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() C0 in ACCEPTING state, trying workaround\n"));
							rawBufPos --;
							pRecBuf->MissingC1Detected = TRUE;
#endif
						case SLOW_IR_EOF:
							if( pIrDev->readBufPos < (IRDA_A_C_TOTAL_SIZE + SLOW_IR_FCS_SIZE) )
							{
								pIrDev->packetsReceivedRunt ++;
								pIrDev->rcvState    = STATE_INIT;
								pIrDev->readBufPos  = 0;
#if defined(WORKAROUND_MISSING_C1)
								if( pRecBuf->MissingC1Detected )
									pRecBuf->MissingC1Detected = FALSE;
								else
									DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Error packet too small\n"));
#else
								DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Error packet too small\n"));
#endif
							}
							else
							{
								pIrDev->rcvState = STATE_SAW_EOF;
							}
							break;
						case SLOW_IR_ESC:
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							break;
						default:
							pReadBuf[pIrDev->readBufPos++] = ThisChar;
							break;
					}
					break;

				case STATE_ESC_SEQUENCE:
					switch( ThisChar )
					{
						case SLOW_IR_EOF:
						case SLOW_IR_BOF:
						case SLOW_IR_ESC:
							/***********************************************/
							/*   ESC + {EOF|BOF|ESC} is an abort sequence  */
							/***********************************************/
							pIrDev->rcvState    = STATE_INIT;
							pIrDev->readBufPos  = 0;
							break;
						case SLOW_IR_EOF ^ SLOW_IR_ESC_COMP:
						case SLOW_IR_BOF ^ SLOW_IR_ESC_COMP:
						case SLOW_IR_ESC ^ SLOW_IR_ESC_COMP:
							pReadBuf[pIrDev->readBufPos++]   = ThisChar ^ SLOW_IR_ESC_COMP;
							pIrDev->rcvState				= STATE_ACCEPTING;
							break;
						default:
							// junk
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveSirStepFSM(): invalid escaped char=%X\n", (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState    = STATE_INIT;
							pIrDev->readBufPos	= 0;
							break;
					}
					break;

				case STATE_SAW_EOF:
					default:
						DEBUGMSG(DBG_INT_ERR, 
							(" ReceiveSirStepFSM(): Illegal state, bufpos=%d\n", pIrDev->readBufPos));
						IRUSB_ASSERT( 0 );
						pIrDev->rcvState    = STATE_INIT;
						pIrDev->readBufPos  = 0;
						return FALSE;
            }
        }
    }

    // *  Set result and do any post-cleanup.
    switch( pIrDev->rcvState )
    {
		case STATE_SAW_EOF:
			// We've read in the entire packet.
			// Queue it and return TRUE.
			pRecBuf->DataLen = pIrDev->readBufPos;
			pIrDev->pCurrentRecBuf = NULL;
			ReceiveDeliverBuffer(
					pIrDev,
					pRecBuf
				);
			FrameProcessed = TRUE;
			if( rawBufPos < rawBytesRead )
			{
				/***********************************************/
				/*   This   is   ugly.   We  have  some  more  */
				/*   unprocessed  bytes  in  the  raw buffer.  */
				/*   Move  these  to the beginning of the raw  */
				/*   buffer  go  to  the CLEANUP state, which  */
				/*   indicates  that  these  bytes be used up  */
				/*   during the next call. (This is typically  */
				/*   only 1 or 2 bytes).                       */
				/*                                             */
				/*   Note:  We  can't just leave these in the  */
				/*   raw   buffer   because   we   might   be  */
				/*   supporting  connections  to multiple COM  */
				/*   ports.                                    */
				/*                                             */
				/***********************************************/
				RtlMoveMemory( pRawBuf, &pRawBuf[rawBufPos], rawBytesRead - rawBufPos );
				pIrDev->rawCleanupBytesRead = rawBytesRead - rawBufPos;
				pIrDev->rcvState   = STATE_CLEANUP;
#if defined( WORKAROUND_9600_ANTIBOUNCING )
				if( (pIrDev->currentSpeed == SPEED_9600) && (pIrDev->ChipRevision <= CHIP_REVISION_7) )
				{
#if !defined(ONLY_ERROR_MESSAGES)
					DEBUGMSG(DBG_INT_ERR, (" ReceiveSirStepFSM(): Delaying\n"));
#endif
					NdisMSleep( 10*1000 );
				}
#endif
			}
			else
			{
				pIrDev->rcvState = STATE_INIT;
			}
			pIrDev->readBufPos = 0;                                 
			break;
		default:
			if( pIrDev->readBufPos > (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + SLOW_IR_FCS_SIZE) )
			{
				DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Overflow\n"));

				pIrDev->packetsReceivedOverflow ++;
				pIrDev->rcvState    = STATE_INIT;
				pIrDev->readBufPos  = 0;
				pIrDev->pCurrentRecBuf = NULL;
				InterlockedExchange( &pRecBuf->DataLen, 0 );
				InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			}
			else
			{
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG(DBG_INT_ERR, (" ReceiveSirStepFSM(): returning with partial packet, read %d bytes\n", pIrDev->readBufPos));
#endif
			}
			FrameProcessed = FALSE;
			break;
    }
    return FrameProcessed;
}


/*****************************************************************************
*
*  Function:   ReceiveProcessReturnPacket
*
*  Synopsis:   Returns the packet to the free pool after preparing for reuse
*
*  Arguments:  pThisDev - pointer to the current ir device object
*              pReceiveBuffer - pointer to a RCV_BUFFER struct
*
*  Returns:    None
*
*
*****************************************************************************/
VOID 
ReceiveProcessReturnPacket(
		OUT PIR_DEVICE pThisDev,
		OUT PRCV_BUFFER pReceiveBuffer
	)
{
	PNDIS_BUFFER	pBuffer;

	DEBUGONCE(DBG_FUNC, ("+ReceiveProcessReturnPacket\n"));
	
	//
	// Deallocate the buffer
	//
	NdisUnchainBufferAtFront( (PNDIS_PACKET)pReceiveBuffer->pPacket, &pBuffer );
	IRUSB_ASSERT( pBuffer );
	if( pBuffer ) 
	{
		NdisFreeBuffer( pBuffer );
	}

	//
	// Get ready to reuse
	//
	InterlockedExchange( &pReceiveBuffer->DataLen, 0 );
	InterlockedExchange( &pReceiveBuffer->fInRcvDpc, FALSE );
	InterlockedExchange( (PULONG)&pReceiveBuffer->BufferState, RCV_STATE_FREE );

#if DBG
	if( InterlockedDecrement(&pThisDev->packetsHeldByProtocol)<0 )
	{
		IRUSB_ASSERT(0);
	}
#endif

	DEBUGMSG(DBG_FUNC, ("-ReceiveProcessReturnPacket\n"));
}


/*****************************************************************************
*
*  Function:    ReceiveDeliverBuffer
*
*  Synopsis:	Delivers the buffer to the protocol via
*				NdisMIndicateReceivePacket.
*
*  Arguments:	pThisDev - pointer to the current ir device object
*				pRecBuf - poiter to descriptor to deliver
*
*  Returns:		None
*
*
*****************************************************************************/
VOID
ReceiveDeliverBuffer(
		IN OUT PIR_DEVICE pThisDev,
		IN PRCV_BUFFER pRecBuf
	)
{
	PNDIS_BUFFER	pBuffer;
	NDIS_STATUS		Status;

    DEBUGMSG(DBG_FUNC, ("+ReceiveDeliverBuffer\n"));

    if( pThisDev->currentSpeed <= MAX_MIR_SPEED )
    {
        USHORT sirfcs;
		
		/***********************************************/
        /*   The packet we have already has had BOFs,  */
        /*   EOF,  and * escape-sequences removed. It  */
        /*   contains  an  FCS code at the end, which  */
        /*   we need to verify and then remove before  */
        /*   delivering the frame. We compute the FCS  */
        /*   on   the  packet  with  the  packet  FCS  */
        /*   attached;   this   should   produce  the  */
        /*   constant value GOOD_FCS.                  */
        /***********************************************/
        if( (sirfcs = ComputeFCS16(pRecBuf->pDataBuf, pRecBuf->DataLen)) != GOOD_FCS )
        {
#if !defined(WORKAROUND_EXTRA_BYTE) && !defined(WORKAROUND_MISSING_C1)
            //
            // FCS error...drop frame...               
            //
			DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
			pThisDev->packetsReceivedChecksum ++;
			InterlockedExchange( &pRecBuf->DataLen, 0 );
			InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			goto done;
#else
			//
			// Calculate again stripping off the last byte
			//
			if( pRecBuf->MissingC1Detected )
			{
				if( (sirfcs = ComputeFCS16(pRecBuf->pDataBuf, pRecBuf->DataLen-1)) != GOOD_FCS )
				{
#if defined(RECEIVE_ERROR_LOGGING)
					if( pThisDev->ReceiveErrorFileHandle )
					{
						IO_STATUS_BLOCK IoStatusBlock;

						ZwWriteFile(
								pThisDev->ReceiveErrorFileHandle,
								NULL,
								NULL,
								NULL,
								&IoStatusBlock,
								pRecBuf->pDataBuf,
								pRecBuf->DataLen,
								(PLARGE_INTEGER)&pThisDev->ReceiveErrorFilePosition,
								NULL
						   );

						pThisDev->ReceiveErrorFilePosition += pRecBuf->DataLen;
					}
#endif
					//
					// It is really junk
					//
					DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
					pThisDev->packetsReceivedChecksum ++;
					InterlockedExchange( &pRecBuf->DataLen, 0 );
					InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
					pRecBuf->MissingC1Detected = FALSE;
					goto done;
				}
				else
				{
					//
					// Readjust to get rid of the extra byte
					//
					pRecBuf->DataLen --;
					pRecBuf->MissingC1Detected = FALSE;
				}
			}
			else
			{
				//
				// Or maybe the first one
				//
				if( (sirfcs = ComputeFCS16(pRecBuf->pDataBuf+1, pRecBuf->DataLen-1)) != GOOD_FCS )
				{
#if defined(RECEIVE_ERROR_LOGGING)
					if( pThisDev->ReceiveErrorFileHandle )
					{
						IO_STATUS_BLOCK IoStatusBlock;

						ZwWriteFile(
								pThisDev->ReceiveErrorFileHandle,
								NULL,
								NULL,
								NULL,
								&IoStatusBlock,
								pRecBuf->pDataBuf,
								pRecBuf->DataLen,
								(PLARGE_INTEGER)&pThisDev->ReceiveErrorFilePosition,
								NULL
						   );

						pThisDev->ReceiveErrorFilePosition += pRecBuf->DataLen;
					}
#endif
					//
					// It is really junk
					//
					DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
					pThisDev->packetsReceivedChecksum ++;
					InterlockedExchange( &pRecBuf->DataLen, 0 );
					InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
					goto done;
				}
				//
				else
				{
					//
					// Readjust to get rid of the extra byte
					//
					pRecBuf->DataLen --;
					RtlMoveMemory( pRecBuf->pDataBuf, &pRecBuf->pDataBuf[1], pRecBuf->DataLen );
				}
			}
#endif
        }

        /***********************************************/
        /*   Remove FCS from end of packet...          */
        /***********************************************/
        pRecBuf->DataLen -= SLOW_IR_FCS_SIZE;
    }
    else
    {
        LONG firfcs;

#if !defined(WORKAROUND_33_HANG)
        if( (firfcs = ComputeFCS32(pRecBuf->dataBuf, pRecBuf->dataLen)) != FIR_GOOD_FCS )
        {
			/***********************************************/
            /*   FCS error...drop frame...                 */
            /***********************************************/
			DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->dataLen));
			pThisDev->packetsReceivedChecksum ++;
			InterlockedExchange( &pRecBuf->dataLen, 0 );
			InterlockedExchange( (PULONG)&pRecBuf->state, RCV_STATE_FREE );
			goto done;
        }
#else
        if( (firfcs = ComputeFCS32(pRecBuf->pDataBuf, pRecBuf->DataLen)) != FIR_GOOD_FCS )
        {
			NTSTATUS rc;
			
			//
			// Try again with the data stuffed with 0x33
			//
			if( pRecBuf->DataLen < (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE) )
			{
				pRecBuf->pDataBuf[pRecBuf->DataLen] = 0x33;
				pRecBuf->DataLen ++;

				if( (firfcs = ComputeFCS32(pRecBuf->pDataBuf, pRecBuf->DataLen)) != FIR_GOOD_FCS )
				{
#if defined(RECEIVE_ERROR_LOGGING)
					if( pThisDev->ReceiveErrorFileHandle )
					{
						IO_STATUS_BLOCK IoStatusBlock;

						ZwWriteFile(
								pThisDev->ReceiveErrorFileHandle,
								NULL,
								NULL,
								NULL,
								&IoStatusBlock,
								pRecBuf->pDataBuf,
								pRecBuf->DataLen,
								(PLARGE_INTEGER)&pThisDev->ReceiveErrorFilePosition,
								NULL
						   );

						pThisDev->ReceiveErrorFilePosition += pRecBuf->DataLen;
					}
#endif
					/***********************************************/
					/*   FCS error...drop frame...                 */
					/***********************************************/
					DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
					pThisDev->ReceiveAdaptiveDelayBoost += STIR4200_DELTA_DELAY;
					if( pThisDev->ReceiveAdaptiveDelayBoost <= STIR4200_MAX_BOOST_DELAY )
						pThisDev->ReceiveAdaptiveDelay += STIR4200_DELTA_DELAY;
					DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Delay: %d\n",pThisDev->ReceiveAdaptiveDelay));
					pThisDev->packetsReceivedChecksum ++;
					InterlockedExchange( &pRecBuf->DataLen, 0 );
					InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
					goto done;
				}
			}
			else
			{
#if defined(RECEIVE_ERROR_LOGGING)
				if( pThisDev->ReceiveErrorFileHandle )
				{
					IO_STATUS_BLOCK IoStatusBlock;

					ZwWriteFile(
							pThisDev->ReceiveErrorFileHandle,
							NULL,
							NULL,
							NULL,
							&IoStatusBlock,
							pRecBuf->pDataBuf,
							pRecBuf->DataLen,
							(PLARGE_INTEGER)&pThisDev->ReceiveErrorFilePosition,
							NULL
					   );

					pThisDev->ReceiveErrorFilePosition += pRecBuf->DataLen;
				}
#endif
				/***********************************************/
				/*   FCS error...drop frame...                 */
				/***********************************************/
				DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
				pThisDev->ReceiveAdaptiveDelayBoost += STIR4200_DELTA_DELAY;
				if( pThisDev->ReceiveAdaptiveDelayBoost <= STIR4200_MAX_BOOST_DELAY )
					pThisDev->ReceiveAdaptiveDelay += STIR4200_DELTA_DELAY;
				DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Delay: %d\n",pThisDev->ReceiveAdaptiveDelay));
				pThisDev->packetsReceivedChecksum ++;
				InterlockedExchange( &pRecBuf->DataLen, 0 );
				InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
				goto done;
			}

			//
			// Reset the USB of the part
			//
			if( pThisDev->ChipRevision <= CHIP_REVISION_7 )
			{
				St4200ResetFifo( pThisDev );
			}
        }
#endif

        /***********************************************/
        /*   Remove FCS from end of packet...          */
        /***********************************************/
        pRecBuf->DataLen -= FAST_IR_FCS_SIZE;
    }

	//
	// If in normal mode, give the packet to the protocol
	//
#if defined(DIAGS)
	if( !pThisDev->DiagsActive )
	{	
#endif
		NdisAllocateBuffer(
				&Status,
				&pBuffer,
				pThisDev->hBufferPool,
				(PVOID)pRecBuf->pDataBuf,		
				pRecBuf->DataLen		
			);
  
		if( Status != NDIS_STATUS_SUCCESS )
		{
			DEBUGMSG( DBG_ERR,(" ReceiveDeliverBuffer(): No packets available...\n"));
			InterlockedExchange( &pRecBuf->DataLen, 0);
			InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			goto done;
		}
		
		NdisChainBufferAtFront( (PNDIS_PACKET)pRecBuf->pPacket, pBuffer );

		//
		// Fix up some other packet fields.
		// Remember, we only account for A and C fields
		//  
		NDIS_SET_PACKET_HEADER_SIZE(
				(PNDIS_PACKET)pRecBuf->pPacket,
				IRDA_CONTROL_FIELD_SIZE + IRDA_ADDRESS_FIELD_SIZE
			);

	#if DBG
		InterlockedIncrement( &pThisDev->packetsHeldByProtocol );
		if( pThisDev->packetsHeldByProtocol > pThisDev->MaxPacketsHeldByProtocol ) 
		{
			pThisDev->MaxPacketsHeldByProtocol = pThisDev->packetsHeldByProtocol;  //keep record of our longest attained len
		}
	#endif
	#if !defined(ONLY_ERROR_MESSAGES)
		DEBUGMSG( DBG_INT_ERR,
			(" ReceiveDeliverBuffer() Handed packet to protocol, size: %d\n", pRecBuf->DataLen ));
	#endif

		//
		// Indicate the packet to NDIS
		//
		NDIS_SET_PACKET_STATUS( (PNDIS_PACKET)pRecBuf->pPacket, NDIS_STATUS_PENDING );
		InterlockedExchange( &pRecBuf->fInRcvDpc, TRUE );
		NdisMIndicateReceivePacket(
				pThisDev->hNdisAdapter,
				&((PNDIS_PACKET)pRecBuf->pPacket),
				1
			);

		//
		// Check to see if the packet is not pending (patch for 98)
		//
#if defined(LEGACY_NDIS5)
		Status = NDIS_GET_PACKET_STATUS( (PNDIS_PACKET)pRecBuf->pPacket );
		if( (Status == NDIS_STATUS_SUCCESS) || (Status == NDIS_STATUS_RESOURCES) )
		{
			ReceiveProcessReturnPacket( pThisDev, pRecBuf ) ;
		}
#endif
#if defined(DIAGS)
	}
	//
	// Do a diagnostic receive
	//
	else
	{
#if !defined(ONLY_ERROR_MESSAGES)
		DEBUGMSG( DBG_INT_ERR,
			(" ReceiveDeliverBuffer() Queued packet, size: %d\n", pRecBuf->DataLen ));
#endif
		//
		// Put the buffer in the diagnostic queue
		//
		ExInterlockedInsertTailList(
				&pThisDev->DiagsReceiveQueue,
				&pRecBuf->ListEntry,
				&pThisDev->DiagsReceiveLock
			);
	}
#endif

done:
    DEBUGMSG(DBG_FUNC, ("-ReceiveDeliverBuffer\n"));
}

/*****************************************************************************
*
*  Function:   StIrUsbReturnPacket
*
*  Synopsis:   The protocol returns ownership of a receive packet to
*              the ir device object.
*
*  Arguments:  Context         - a pointer to the current ir device obect.
*              pReturnedPacket - a pointer the packet which the protocol
*                                is returning ownership.
*
*  Returns:    None.
*
*
*
*****************************************************************************/
VOID
StIrUsbReturnPacket(
		IN OUT NDIS_HANDLE Context,
		IN OUT PNDIS_PACKET pReturnedPacket
	)
{
	PIR_DEVICE		pThisDev;
	PNDIS_BUFFER	pBuffer;
	PRCV_BUFFER		pRecBuffer;
	UINT			Index;
	BOOLEAN			found = FALSE;

	DEBUGONCE(DBG_FUNC, ("+StIrUsbReturnPacket\n"));

    //
    // The context is just the pointer to the current ir device object.
    //
    pThisDev = CONTEXT_TO_DEV( Context );

    NdisInterlockedIncrement( (PLONG)&pThisDev->packetsReceived );

	//
	// Search the queue to find the right packet.
	//
	for( Index=0; Index < NUM_RCV_BUFS; Index ++ )
	{
		pRecBuffer = &(pThisDev->rcvBufs[Index]);

		if( ((PNDIS_PACKET) pRecBuffer->pPacket) == pReturnedPacket )
		{
			if( pRecBuffer->fInRcvDpc )
			{
				ReceiveProcessReturnPacket( pThisDev, pRecBuffer );
				found = TRUE;
			}
			else
			{
				DEBUGMSG(DBG_ERR, (" StIrUsbReturnPacket, queues are corrupt\n"));
				IRUSB_ASSERT( 0 );
			}
			break;
		}
	}

    //
    // Ensure that the packet was found.
    //
	IRUSB_ASSERT( found );

	DEBUGMSG(DBG_FUNC, ("-StIrUsbReturnPacket\n"));
}


/*****************************************************************************
*
*  Function:    ReceiveGetBuf
*
*  Synopsis:    Gets a receive buffer
*
*  Arguments:   pThisDev - a pointer to the current ir device obect
*				pIndex - pointer to return the buffer index
*				state - state to set the buffer to
*
*  Returns:		buffer
*
*
*****************************************************************************/
PRCV_BUFFER
ReceiveGetBuf(
		IN PIR_DEVICE pThisDev,
		OUT PUINT pIndex,
		IN RCV_BUFFER_STATE BufferState  
	)
{
	UINT			Index;
	PRCV_BUFFER		pBuf = NULL;

	DEBUGMSG(DBG_FUNC, ("+ReceiveGetBuf()\n"));

	//
	// Look for a free buffer to return
	//
	for( Index=0; Index<NUM_RCV_BUFS; Index++ )
	{
		if( pThisDev->rcvBufs[Index].BufferState == RCV_STATE_FREE )
		{
			//
			// set to input state
			//
			InterlockedExchange( (PULONG)&pThisDev->rcvBufs[Index].BufferState, (ULONG)BufferState ); 
			*pIndex = Index;
			pBuf = &(pThisDev->rcvBufs[*pIndex]);
			break;
		}
	}

	DEBUGMSG(DBG_FUNC, ("-ReceiveGetBuf()\n"));
	return pBuf;
}


/*****************************************************************************
*
*  Function:   ReceivePacketRead
*
*  Synopsis:   Reads a packet from the US device
*              the inbound USB header,  check for overrun,
*              deliver to the protocol
*
*  Arguments:  pThisDev - pointer to the current ir device object
*              pRecBuf - pointer to a RCV_BUFFER struct
*
*  Returns:    NT status code
*
*
*****************************************************************************/
NTSTATUS 
ReceivePacketRead( 
		IN PIR_DEVICE pThisDev,
		OUT PFIFO_BUFFER pRecBuf
	)
{
    ULONG				UrbSize;
    ULONG				TransferLength;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    NTSTATUS			Status = STATUS_UNSUCCESSFUL;

    DEBUGMSG(DBG_FUNC, ("+ReceivePacketRead()\n"));

	IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    UrbSize = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    TransferLength = STIR4200_FIFO_SIZE;

	//
	// Stop if a halt/reset/suspend is going on
	//
	if( pThisDev->fPendingReadClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall || !pThisDev->fProcessing ) 
	{
		//
		// USB reset going on?
		//
		DEBUGMSG( DBG_ERR,(" ReceivePacketRead() rejecting a packet due to pendig halt/reset\n"));
		
		Status = STATUS_UNSUCCESSFUL;
		goto done;
	}

    pUrb = pThisDev->pUrb;

	//
    // Build our URB for USBD
	//
    NdisZeroMemory( pUrb, UrbSize );

    IRUSB_ASSERT( pThisDev->BulkInPipeHandle );

    //
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    KeClearEvent( &pThisDev->EventSyncUrb );

    pUrbTargetDev = pThisDev->pUsbDevObj;

    IRUSB_ASSERT( pUrbTargetDev );

	//
	// make an irp sending to usbhub
	//
	pRecBuf->pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pRecBuf->pIrp )
    {
        DEBUGMSG(DBG_ERR, ("  read failed to alloc IRP\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    ((PIRP)pRecBuf->pIrp)->IoStatus.Status = STATUS_PENDING;
    ((PIRP)pRecBuf->pIrp)->IoStatus.Information = 0;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)UrbSize;
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkInPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN ;
	
	//
    // short packet is not treated as an error.
    //
	pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;

    //
    // not using linked urb's
    //
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pRecBuf->pDataBuf;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = TransferLength;

    //
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( (PIRP)pRecBuf->pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(
			((PIRP)pRecBuf->pIrp),		// irp to use
			ReceiveCompletePacketRead,  // routine to call when irp is done
			pRecBuf,					// context to pass routine is the RCV_BUFFER
			TRUE,						// call on success
			TRUE,						// call on error
			TRUE						// call on cancel
		);

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	InterlockedExchange( (PLONG)&pRecBuf->BufferState, RCV_STATE_PENDING );
	Status = MyIoCallDriver( pThisDev, pUrbTargetDev, (PIRP)pRecBuf->pIrp ); // Start UsbRead()

    DEBUGMSG(DBG_FUNC, (" ReceivePacketRead() after IoCallDriver () status = 0x%x\n", Status));

	IRUSB_ASSERT( STATUS_SUCCESS != Status );

	//
	// Wait for completion
	//
	Status = MyKeWaitForSingleObject(
			pThisDev,
			&pThisDev->EventSyncUrb,	// event to wait on
			NULL,						// irp to cancel on halt/reset or timeout
			0 
		);

	if( Status == STATUS_TIMEOUT ) 
	{
		IrUsb_CancelIo( pThisDev, pRecBuf->pIrp, &pThisDev->EventSyncUrb );
	}
	else
	{
		//
		// Update the status to reflect the real return code
		//
		Status = pThisDev->StatusSendReceive;
	}

	IRUSB_ASSERT( NULL == pRecBuf->pIrp ); // Will be nulled by completion routine
    DEBUGMSG(DBG_FUNC, (" ReceivePacketRead() after KeWaitForSingleObject() Status = 0x%x\n", Status));

done:
    DEBUGMSG(DBG_FUNC, ("-ReceivePacketRead()\n"));
    return Status;
}


/*****************************************************************************
*
*  Function:   ReceiveCompletePacketRead
*
*  Synopsis:   Completes USB read operation
*
*  Arguments:  pUsbDevObj - pointer to the USB device object which
*                              completed the irp
*              pIrp - the irp which was completed by the
*                              device object
*              Context - the context given to IoSetCompletionRoutine
*                              before calling IoCallDriver on the irp
*                              The Context is a pointer to the ir device object.
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*
*****************************************************************************/
NTSTATUS
ReceiveCompletePacketRead(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE		pThisDev;
    NTSTATUS		status;
    ULONG_PTR		BytesRead;
	PFIFO_BUFFER	pFifoBuf;

    DEBUGMSG(DBG_FUNC, ("+ReceiveCompletePacketRead\n"));

    //
    // The context given to ReceiveCompletePacketRead is the receive buffer object
    //
	pFifoBuf = (PFIFO_BUFFER)Context;

    pThisDev = (PIR_DEVICE)pFifoBuf->pThisDev;

    IRUSB_ASSERT( pFifoBuf->pIrp == pIrp );

    IRUSB_ASSERT( NULL != pThisDev );

    //
    // We have a number of cases:
    //      1) The USB read timed out and we received no data.
    //      2) The USB read timed out and we received some data.
    //      3) The USB read was successful and fully filled our irp buffer.
    //      4) The irp was cancelled.
    //      5) Some other failure from the USB device object.
    //
    status = pIrp->IoStatus.Status;

    //
    // IoCallDriver has been called on this Irp;
    // Set the length based on the TransferBufferLength
    // value in the URB
    //
    pIrp->IoStatus.Information = pThisDev->pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

    BytesRead = pIrp->IoStatus.Information;

    DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead Bytes Read = 0x%x, dec %d\n", BytesRead,BytesRead ));

    switch( status )
    {
        case STATUS_SUCCESS:
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_SUCCESS\n"));

            if( BytesRead > 0 )
            {
				pFifoBuf->DataLen = (UINT)pIrp->IoStatus.Information;
            }
            break; // STATUS_SUCCESS

        case STATUS_TIMEOUT:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_TIMEOUT\n"));
            break;

        case STATUS_PENDING:
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_PENDING\n"));
            break;

        case STATUS_DEVICE_DATA_ERROR:
			// can get during shutdown
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_DEVICE_DATA_ERROR\n"));
            break;

        case STATUS_UNSUCCESSFUL:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_UNSUCCESSFUL\n"));
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_INSUFFICIENT_RESOURCES\n"));
            break;
        case STATUS_INVALID_PARAMETER:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_INVALID_PARAMETER\n"));
            break;

        case STATUS_CANCELLED:
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_CANCELLED\n"));
            break;

        case STATUS_DEVICE_NOT_CONNECTED:
			// can get during shutdown
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_DEVICE_NOT_CONNECTED\n"));
            break;

        case STATUS_DEVICE_POWER_FAILURE:
			// can get during shutdown
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_DEVICE_POWER_FAILURE\n"));
            break;

        default:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead UNKNOWN WEIRD STATUS = 0x%x, dec %d\n",status,status ));
            break;
    }

	//
	// change the status
	//
	if( STATUS_SUCCESS != status ) 
	{
		InterlockedExchange( (PLONG)&pFifoBuf->BufferState, RCV_STATE_FREE );
	}
	else
	{
		InterlockedExchange( (PLONG)&pFifoBuf->BufferState, RCV_STATE_FULL );
	}

    //
    // Free the IRP  and its mdl because they were  allocated by us
    //
	IoFreeIrp( pIrp );
    pFifoBuf->pIrp = NULL;
	InterlockedIncrement( (PLONG)&pThisDev->NumReads );

	//
	// we will track count of pending irps
	//
	IrUsb_DecIoCount( pThisDev ); 

	if( ( STATUS_SUCCESS != status )  && ( STATUS_CANCELLED != status ) && 
		( STATUS_DEVICE_NOT_CONNECTED != status ) )
	{
		PURB urb = pThisDev->pUrb;

		DEBUGMSG(DBG_ERR, (" USBD status = 0x%x\n", urb->UrbHeader.Status));
		DEBUGMSG(DBG_ERR, (" NT status = 0x%x\n",  status));

		if( !pThisDev->fPendingReadClearStall && !pThisDev->fPendingClearTotalStall && 
			!pThisDev->fPendingHalt && !pThisDev->fPendingReset && pThisDev->fProcessing )
		{
			DEBUGMSG(DBG_ERR, 
				(" ReceiveCompletePacketRead error, will schedule a clear stall via URB_FUNCTION_RESET_PIPE (IN)\n"));
			InterlockedExchange( &pThisDev->fPendingReadClearStall, TRUE );
			ScheduleWorkItem( pThisDev, ResetPipeCallback, pThisDev->BulkInPipeHandle, 0 );
		}
	}

	//
	// This will only work as long as we serialize the access to the hardware
	//
	pThisDev->StatusSendReceive = status;

	//
	// Signal completion
	//
	KeSetEvent( &pThisDev->EventSyncUrb, 0, FALSE );  

    //
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the completion
    // routine (IoCompleteRequest) will stop working on the irp.
    //
    DEBUGMSG(DBG_FUNC, ("-ReceiveCompletePacketRead\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\resource.c ===
/**************************************************************************************************************************
 *  RESOURCE.C SigmaTel STIR4200 memory allocation module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"


/*****************************************************************************
*
*  Function:   MyMemAlloc
*
*  Synopsis:   allocates a block of memory using NdisAllocateMemory
*
*  Arguments:  size - size of the block to allocate
*
*  Returns:    a pointer to the allocated block of memory
*
*
*****************************************************************************/
PVOID
MyMemAlloc( 
		UINT size 
	)
{
    PVOID			pMem;
    NDIS_STATUS     status;

    status = NdisAllocateMemoryWithTag( &pMem, size, IRUSB_TAG );

    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" Memory allocation failed\n"));
        pMem = NULL;
    }

    return pMem;
}


/*****************************************************************************
*
*  Function:   MyMemFree
*
*  Synopsis:   frees a block of memory allocated by MyMemAlloc
*
*  Arguments:  memptr - memory to free
*              size   - size of the block to free
*
*
*****************************************************************************/
VOID
MyMemFree(
		PVOID pMem,
		UINT size
	)
{
    NdisFreeMemory( pMem, size, 0 );
}


/*****************************************************************************
*
*  Function:   NewDevice
*
*  Synopsis:   allocates an IR device and zeros the memory
*
*  Arguments:  none
*
*  Returns:    initialized IR device or NULL (if alloc failed)
*
*
*****************************************************************************/
PIR_DEVICE
NewDevice()
{
    PIR_DEVICE	pNewDev;

    pNewDev = MyMemAlloc( sizeof(IR_DEVICE) );

    if( pNewDev != NULL )
    {
		NdisZeroMemory( (PVOID)pNewDev, sizeof(IR_DEVICE) );

		if( !AllocUsbInfo( pNewDev ) ) 
		{
			MyMemFree( pNewDev, sizeof(IR_DEVICE) );
			pNewDev = NULL;
		} 
	}

    return pNewDev;
}

/*****************************************************************************
*
*  Function:   FreeDevice
*
*  Synopsis:   frees an IR device structure
*
*  Arguments:  pThisDev - pointer to device to free
*
*  Returns:    none
*
*
*****************************************************************************/
VOID
FreeDevice(
		IN OUT PIR_DEVICE pThisDev
	)
{
	FreeUsbInfo( pThisDev );
    MyMemFree( (PVOID)pThisDev, sizeof(IR_DEVICE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\settings.c ===
/**************************************************************************************************************************
 *  SETTINGS.C SigmaTel STIR4200 baud rate information table
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 11/15/2000 
 *			Version 1.12
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"

BAUDRATE_INFO supportedBaudRateTable[NUM_BAUDRATES] = {
    {
        BAUDRATE_2400,
        SPEED_2400,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_2400, 
		0xDF

    },
    {
        BAUDRATE_9600,
        SPEED_9600,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_9600,
		0x77
    },
    {
        BAUDRATE_19200,
        SPEED_19200,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_19200,
		0x3B
    },
    {
        BAUDRATE_38400,
        SPEED_38400,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_38400,
		0x1D
    },
    {
        BAUDRATE_57600,
        SPEED_57600,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_57600,
		0x13
    },
    {
        BAUDRATE_115200,
        SPEED_115200,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_115200,
		0x09
    },
#if !defined(WORKAROUND_BROKEN_MIR)
    {
        BAUDRATE_576000,
        SPEED_576000,
		IR_MODE_MIR,
        NDIS_IRDA_SPEED_576K,
		0x15
    },
    {
        BAUDRATE_1152000,
        SPEED_1152000,
		IR_MODE_MIR,
        NDIS_IRDA_SPEED_1152K,
		0x01
    },
#endif
    {
        BAUDRATE_4000000,
        SPEED_4000000,
		IR_MODE_FIR,
        NDIS_IRDA_SPEED_4M,
		0x02
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\via\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f  $@ -d 04/30/2001 -v 5.1.2480.0

$(O)\viafir2k.inf: $(_INX)\viafir2k.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\irda\sigmatel\sys\stir4200.h ===
/**************************************************************************************************************************
 *  STIR4200.H - SigmaTel STIr4200 hardware (register) specific definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 06/29/2000 
 *			Version 0.97
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/10/2000 
 *			Version 1.12
 *		Edited: 12/29/2000 
 *			Version 1.13
 *		Edited: 01/16/2001 
 *			Version 1.14
 *	
 *
 **************************************************************************************************************************/

#ifndef __STIR4200_H__
#define __STIR4200_H__


#define STIR4200_FIFO_SIZE          4096

//
// Some useful macros
//
#define MAKEUSHORT(lo, hi)  ((unsigned short)(((unsigned char)(lo)) | ((unsigned short)((unsigned char)(hi))) << 8))
#define MAKEULONG(lo, hi)   ((unsigned long)(((unsigned short)(lo)) | ((unsigned long)((unsigned short)(hi))) << 16))
#ifndef LOWORD
	#define LOWORD(l)           ((unsigned short)(l))
#endif
#ifndef HIWORD
	#define HIWORD(l)           ((unsigned short)(((unsigned long)(l) >> 16) & 0xFFFF))
#endif
#ifndef LOBYTE
	#define LOBYTE(w)           ((unsigned char)(w))
#endif
#ifndef HIBYTE
	#define HIBYTE(w)           ((unsigned char)(((unsigned short)(w) >> 8) & 0xFF))
#endif


/**************************************************************************************************************************/
/*   STIr4200 Tranceiver Hardware Model Definitions                                                                                 */
/**************************************************************************************************************************/
typedef struct _STIR4200_TRANCEIVER
{
    UCHAR       FifoDataReg;
	UCHAR		ModeReg;
	UCHAR		BaudrateReg;
	UCHAR		ControlReg;
	UCHAR		SensitivityReg;
    UCHAR       StatusReg;
	UCHAR		FifoCntLsbReg;
	UCHAR		FifoCntMsbReg;
	UCHAR		DpllTuneReg;
	UCHAR		IrdigSetupReg;
	UCHAR		Reserved1Reg;
	UCHAR		Reserved2Reg;
	UCHAR		Reserved3Reg;
	UCHAR		Reserved4Reg;
	UCHAR		Reserved5Reg;
	UCHAR		TestReg;
} STIR4200_TRANCEIVER, *PSTIR4200_TRANCEIVER;

/**************************************************************************************************************************/
/*   STIr4200 Receiver State                                                                                 */
/**************************************************************************************************************************/
typedef enum
{
    STATE_INIT = 0,
    STATE_GOT_FIR_BOF,
    STATE_GOT_BOF,
    STATE_ACCEPTING,
    STATE_ESC_SEQUENCE,
    STATE_SAW_FIR_BOF,
    STATE_SAW_EOF,
    STATE_CLEANUP
} PORT_RCV_STATE;

#define STATE_GOT_MIR_BOF STATE_GOT_FIR_BOF
#define STATE_SAW_MIR_BOF STATE_SAW_FIR_BOF

/**************************************************************************************************************************/
/*   Register Offsets                                                                                                     */
/**************************************************************************************************************************/
#define STIR4200_FIFO_DATA_REG              0
#define STIR4200_MODE_REG                   1
#define STIR4200_BAUDRATE_REG               2
#define STIR4200_CONTROL_REG                3
#define STIR4200_SENSITIVITY_REG            4
#define STIR4200_STATUS_REG                 5
#define STIR4200_FIFOCNT_LSB_REG            6
#define STIR4200_FIFOCNT_MSB_REG            7
#define STIR4200_DPLLTUNE_REG               8
#define STIR4200_IRDIG_SETUP_REG            9
#define STIR4200_RESERVE1_REG               10
#define STIR4200_RESERVE2_REG               11
#define STIR4200_RESERVE3_REG               12
#define STIR4200_RESERVE4_REG               13
#define STIR4200_RESERVE5_REG               14
#define STIR4200_TEST_REG                   15
#define STIR4200_MAX_REG                    STIR4200_TEST_REG


/**************************************************************************************************************************/
/*   Register Bit Definitions                                                                                             */
/**************************************************************************************************************************/
#define STIR4200_MODE_PDLCK8	            0x01
#define STIR4200_MODE_RESET_OFF             0x02
#define STIR4200_MODE_AUTO_RESET            0x04
#define STIR4200_MODE_BULKIN_FIX            0x08
#define STIR4200_MODE_FIR                   0x80
#define STIR4200_MODE_MIR                   0x40
#define STIR4200_MODE_SIR                   0x20
#define STIR4200_MODE_ASK                   0x10
#define STIR4200_MODE_MASK                  (STIR4200_MODE_FIR | STIR4200_MODE_MIR | STIR4200_MODE_SIR | STIR4200_MODE_ASK)

#define STIR4200_CTRL_SDMODE                0x80
#define STIR4200_CTRL_RXSLOW                0x40
#define STIR4200_CTRL_DLOOP1                0x20
#define STIR4200_CTRL_TXPWD                 0x10
#define STIR4200_CTRL_RXPWD                 0x08
#define STIR4200_CTRL_SRESET                0x01

#define STIR4200_SENS_IDMASK                0x07
#define STIR4200_SENS_SPWIDTH               0x08
#define STIR4200_SENS_BSTUFF                0x10
#define STIR4200_SENS_RXDSNS_DEFAULT        0x20
#define STIR4200_SENS_RXDSNS_4012_SIR_9600	0x20
#define STIR4200_SENS_RXDSNS_4012_SIR		0x00
#define STIR4200_SENS_RXDSNS_4012_FIR		0x20
#define STIR4200_SENS_RXDSNS_INFI_SIR		0x07
#define STIR4200_SENS_RXDSNS_INFI_FIR		0x27

#define STIR4200_STAT_EOFRAME               0x80
#define STIR4200_STAT_FFUNDER               0x40
#define STIR4200_STAT_FFOVER                0x20
#define STIR4200_STAT_FFDIR                 0x10
#define STIR4200_STAT_FFCLR                 0x08
#define STIR4200_STAT_FFEMPTY               0x04
#define STIR4200_STAT_FFRXERR               0x02
#define STIR4200_STAT_FFTXERR               0x01

#define STIR4200_DPLL_DESIRED_4012			0x05
#define STIR4200_DPLL_DESIRED_4012_SIR		0x06
#define STIR4200_DPLL_DESIRED_4012_FIR		0x05
#define STIR4200_DPLL_DESIRED_4000			0x15
#define STIR4200_DPLL_DESIRED_VISHAY		0x15
#define STIR4200_DPLL_DESIRED_INFI			0x15
#define STIR4200_DPLL_DEFAULT				0x52

#define STIR4200_TEST_EN_OSC_SUSPEND		0x10

/**************************************************************************************************************************/
/*   Vendor Specific Device Requests                                                                                      */
/**************************************************************************************************************************/
#define STIR4200_WRITE_REGS_REQ             0
#define STIR4200_READ_REGS_REQ              1
#define STIR4200_READ_ROM_REQ               2
#define STIR4200_WRITE_REG_REQ              3
#define STIR4200_CLEAR_STALL_REQ            1


/**************************************************************************************************************************/
/*   STIr4200 Frame Header ID Definitions                                                                                 */
/**************************************************************************************************************************/
#define STIR4200_HEADERID_BYTE1             0x55
#define STIR4200_HEADERID_BYTE2             0xAA

typedef struct _STIR4200_FRAME_HEADER
{
    UCHAR       id1;                // header id byte 1
    UCHAR       id2;                // header id byte 2
    UCHAR       sizlsb;             // frame size LSB
    UCHAR       sizmsb;             // frame size MSB
} STIR4200_FRAME_HEADER, *PSTIR4200_FRAME_HEADER;

/**************************************************************************************************************************/
/*   STIr4200 Frame Definitions                                                                                           */
/**************************************************************************************************************************/
#define STIR4200_FIR_PREAMBLE               0x7f
#define STIR4200_FIR_PREAMBLE_SIZ           16
#define STIR4200_FIR_BOF                    0x7E
#define STIR4200_FIR_EOF                    0x7E
#define STIR4200_FIR_BOF_SIZ                2
#define STIR4200_FIR_EOF_SIZ                2
#define STIR4200_FIR_ESC_CHAR               0x7d
#define STIR4200_FIR_ESC_DATA_7D            0x5d
#define STIR4200_FIR_ESC_DATA_7E            0x5e
#define STIR4200_FIR_ESC_DATA_7F            0x5f

#define STIR4200_MIR_BOF                    0x7E
#define STIR4200_MIR_EOF                    0x7E
#define STIR4200_MIR_BOF_SIZ                2
#define STIR4200_MIR_EOF_SIZ                2
#define STIR4200_MIR_ESC_CHAR               0x7d
#define STIR4200_MIR_ESC_DATA_7D            0x5d
#define STIR4200_MIR_ESC_DATA_7E            0x5e

//
// A few workaroud definitions
//
#define STIR4200_READ_DELAY					3000
#define STIR4200_MULTIPLE_READ_DELAY		2500
#define STIR4200_DELTA_DELAY				250
#define STIR4200_MAX_BOOST_DELAY			1000
#define STIR4200_MULTIPLE_READ_THREHOLD		2048
#define STIR4200_WRITE_DELAY				2000
#define STIR4200_ESC_PACKET_SIZE			3072
#define STIR4200_SMALL_PACKET_MAX_SIZE		32
#define STIR4200_LARGE_PACKET_MIN_SIZE		1024
#define STIR4200_ACK_WINDOW					20
#define	STIR4200_FIFO_OVERRUN_THRESHOLD		100
#define	STIR4200_SEND_TIMEOUT				2000

/**************************************************************************************************************************/
/*   Prototypes of functions that access the hardware                                                                                           */
/**************************************************************************************************************************/

NTSTATUS        
St4200ResetFifo( 
		IN PVOID pDevice
	);

NTSTATUS        
St4200DoubleResetFifo( 
		IN PVOID pDevice
	);

NTSTATUS        
St4200SoftReset( 
		IN PVOID pDevice
	);

NTSTATUS        
St4200SetSpeed( 
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200SetIrMode( 
		IN OUT PVOID pDevice,
		ULONG mode 
	);

NTSTATUS        
St4200GetFifoCount( 
		IN PVOID pDevice,
		OUT PULONG pCountFifo
	);

NTSTATUS        
St4200TuneDpllAndSensitivity(
		IN OUT PVOID pDevice,
		ULONG Speed
	);

NTSTATUS        
St4200TurnOffReceiver(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200TurnOnReceiver(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200EnableOscillatorPowerDown(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200TurnOnSuspend(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200TurnOffSuspend(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200WriteMultipleRegisters(
		IN PVOID pDevice,
		UCHAR FirstRegister, 
		UCHAR RegistersToWrite
	);

NTSTATUS        
St4200WriteRegister(
		IN PVOID pDevice,
		UCHAR RegisterToWrite
	);

NTSTATUS
St4200ReadRegisters(
		IN OUT PVOID pDevice,
		UCHAR FirstRegister, 
		UCHAR RegistersToRead
	);

NTSTATUS        
St4200FakeSend(
		IN PVOID pDevice,
		PUCHAR pData,
		ULONG DataSize
	);

NTSTATUS
St4200CompleteReadWriteRequest(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	);

/**************************************************************************************************************************/

#endif      // __STIR4200_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\e100_557.h ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    e100_557.h  (82557.h)

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#ifndef _E100_557_H
#define _E100_557_H

//-------------------------------------------------------------------------
// D100 Stepping Defines
//-------------------------------------------------------------------------
#define D100_A_STEP                 0   // NEVER SHIPPED
#define D100_B_STEP                 1   // d100 first shipped silicon
#define D100_C_STEP                 2   // d100' (c-step) with vendor/id and hw fix
#define D101_A_STEP                 4   // first silicon of d101

//-------------------------------------------------------------------------
// E100 Stepping Defines - used in PoMgmt Decisions
//-------------------------------------------------------------------------
#define E100_82557_A_STEP   1
#define E100_82557_B_STEP   2
#define E100_82557_C_STEP   3
#define E100_82558_A_STEP   4
#define E100_82558_B_STEP   5
#define E100_82559_A_STEP   6
#define E100_82559_B_STEP   7
#define E100_82559_C_STEP   8
#define E100_82559ER_A_STEP 9

//-------------------------------------------------------------------------
// D100 PORT functions -- lower 4 bits
//-------------------------------------------------------------------------
#define PORT_SOFTWARE_RESET         0
#define PORT_SELFTEST               1
#define PORT_SELECTIVE_RESET        2
#define PORT_DUMP                   3


//-------------------------------------------------------------------------
// CSR field definitions -- Offsets from CSR base
//-------------------------------------------------------------------------
#define SCB_STATUS_LOW_BYTE         0x0
#define SCB_STATUS_HIGH_BYTE        0x1
#define SCB_COMMAND_LOW_BYTE        0x2
#define SCB_COMMAND_HIGH_BYTE       0x3
#define SCB_GENERAL_POINTER         0x4
#define CSR_PORT_LOW_WORD           0x8
#define CSR_PORT_HIGH_WORD          0x0a
#define CSR_FLASH_CONTROL_REG       0x0c
#define CSR_EEPROM_CONTROL_REG      0x0e
#define CSR_MDI_CONTROL_LOW_WORD    0x10
#define CSR_MDI_CONTROL_HIGH_WORD   0x12


//-------------------------------------------------------------------------
// SCB Status Word bit definitions
//-------------------------------------------------------------------------
//- Interrupt status fields
#define SCB_STATUS_MASK         BIT_12_15       // ACK Mask
#define SCB_STATUS_CX           BIT_15          // CU Completed Action Cmd
#define SCB_STATUS_FR           BIT_14          // RU Received A Frame
#define SCB_STATUS_CNA          BIT_13          // CU Became Inactive (IDLE)
#define SCB_STATUS_RNR          BIT_12          // RU Became Not Ready
#define SCB_STATUS_MDI          BIT_11          // MDI read or write done
#define SCB_STATUS_SWI          BIT_10          // Software generated interrupt

//- Interrupt ACK fields
#define SCB_ACK_MASK            (BIT_9 | BIT_12_15 | BIT_8)   // ACK Mask
#define SCB_ACK_CX              BIT_15          // CU Completed Action Cmd
#define SCB_ACK_FR              BIT_14          // RU Received A Frame
#define SCB_ACK_CNA             BIT_13          // CU Became Inactive (IDLE)
#define SCB_ACK_RNR             BIT_12          // RU Became Not Ready
#define SCB_ACK_MDI             BIT_11          // MDI read or write done
#define SCB_ACK_SWI             BIT_10          // Software generated interrupt
#define SCB_ACK_ER              BIT_9           // Early Receive interrupt
#define SCB_ACK_FCP             BIT_8           // Flow Control Pause interrupt

//- CUS Fields
#define SCB_CUS_MASK            (BIT_6 | BIT_7) // CUS 2-bit Mask
#define SCB_CUS_IDLE            0               // CU Idle
#define SCB_CUS_SUSPEND         BIT_6           // CU Suspended
#define SCB_CUS_ACTIVE          BIT_7           // CU Active

//- RUS Fields
#define SCB_RUS_IDLE            0               // RU Idle
#define SCB_RUS_MASK            BIT_2_5         // RUS 3-bit Mask
#define SCB_RUS_SUSPEND         BIT_2           // RU Suspended
#define SCB_RUS_NO_RESOURCES    BIT_3           // RU Out Of Resources
#define SCB_RUS_READY           BIT_4           // RU Ready
#define SCB_RUS_SUSP_NO_RBDS    (BIT_2 | BIT_5) // RU No More RBDs
#define SCB_RUS_NO_RBDS         (BIT_3 | BIT_5) // RU No More RBDs
#define SCB_RUS_READY_NO_RBDS   (BIT_4 | BIT_5) // RU Ready, No RBDs


//-------------------------------------------------------------------------
// SCB Command Word bit definitions
//-------------------------------------------------------------------------
//- CUC fields
#define SCB_CUC_MASK            BIT_4_6         // CUC 3-bit Mask
#define SCB_CUC_START           BIT_4           // CU Start
#define SCB_CUC_RESUME          BIT_5           // CU Resume
#define SCB_CUC_DUMP_ADDR       BIT_6           // CU Dump Counters Address
#define SCB_CUC_DUMP_STAT       (BIT_4 | BIT_6) // CU Dump statistics counters
#define SCB_CUC_LOAD_BASE       (BIT_5 | BIT_6) // Load the CU base
#define SCB_CUC_DUMP_RST_STAT   BIT_4_6         // CU Dump and reset statistics counters
#define SCB_CUC_STATIC_RESUME   (BIT_5 | BIT_7) // CU Static Resume

//- RUC fields
#define SCB_RUC_MASK            BIT_0_2         // RUC 3-bit Mask
#define SCB_RUC_START           BIT_0           // RU Start
#define SCB_RUC_RESUME          BIT_1           // RU Resume
#define SCB_RUC_ABORT           BIT_2           // RU Abort
#define SCB_RUC_LOAD_HDS        (BIT_0 | BIT_2) // Load RFD Header Data Size
#define SCB_RUC_LOAD_BASE       (BIT_1 | BIT_2) // Load the RU base
#define SCB_RUC_RBD_RESUME      BIT_0_2         // RBD resume

// Interrupt fields (assuming byte addressing)
#define SCB_INT_MASK            BIT_0           // Mask interrupts
#define SCB_SOFT_INT            BIT_1           // Generate a software interrupt


//-------------------------------------------------------------------------
// EEPROM bit definitions
//-------------------------------------------------------------------------
//- EEPROM control register bits
#define EN_TRNF                     0x10    // Enable turnoff
#define EEDO                        0x08    // EEPROM data out
#define EEDI                        0x04    // EEPROM data in (set for writing data)
#define EECS                        0x02    // EEPROM chip select (1=high, 0=low)
#define EESK                        0x01    // EEPROM shift clock (1=high, 0=low)

//- EEPROM opcodes
#define EEPROM_READ_OPCODE          06
#define EEPROM_WRITE_OPCODE         05
#define EEPROM_ERASE_OPCODE         07
#define EEPROM_EWEN_OPCODE          19      // Erase/write enable
#define EEPROM_EWDS_OPCODE          16      // Erase/write disable

//- EEPROM data locations
#define EEPROM_NODE_ADDRESS_BYTE_0  0
#define EEPROM_FLAGS_WORD_3         3
#define EEPROM_FLAG_10MC            BIT_0
#define EEPROM_FLAG_100MC           BIT_1

//-------------------------------------------------------------------------
// MDI Control register bit definitions
//-------------------------------------------------------------------------
#define MDI_DATA_MASK           BIT_0_15        // MDI Data port
#define MDI_REG_ADDR            BIT_16_20       // which MDI register to read/write
#define MDI_PHY_ADDR            BIT_21_25       // which PHY to read/write
#define MDI_PHY_OPCODE          BIT_26_27       // which PHY to read/write
#define MDI_PHY_READY           BIT_28          // PHY is ready for another MDI cycle
#define MDI_PHY_INT_ENABLE      BIT_29          // Assert INT at MDI cycle completion


//-------------------------------------------------------------------------
// MDI Control register opcode definitions
//-------------------------------------------------------------------------
#define MDI_WRITE               1               // Phy Write
#define MDI_READ                2               // Phy read


//-------------------------------------------------------------------------
// D100 Action Commands
//-------------------------------------------------------------------------
#define CB_NOP                  0
#define CB_IA_ADDRESS           1
#define CB_CONFIGURE            2
#define CB_MULTICAST            3
#define CB_TRANSMIT             4
#define CB_LOAD_MICROCODE       5
#define CB_DUMP                 6
#define CB_DIAGNOSE             7


//-------------------------------------------------------------------------
// Command Block (CB) Field Definitions
//-------------------------------------------------------------------------
//- CB Command Word
#define CB_EL_BIT               BIT_15          // CB EL Bit
#define CB_S_BIT                BIT_14          // CB Suspend Bit
#define CB_I_BIT                BIT_13          // CB Interrupt Bit
#define CB_TX_SF_BIT            BIT_3           // TX CB Flexible Mode
#define CB_CMD_MASK             BIT_0_2         // CB 3-bit CMD Mask

//- CB Status Word
#define CB_STATUS_MASK          BIT_12_15       // CB Status Mask (4-bits)
#define CB_STATUS_COMPLETE      BIT_15          // CB Complete Bit
#define CB_STATUS_OK            BIT_13          // CB OK Bit
#define CB_STATUS_UNDERRUN      BIT_12          // CB A Bit
#define CB_STATUS_FAIL          BIT_11          // CB Fail (F) Bit

//misc command bits
#define CB_TX_EOF_BIT           BIT_15          // TX CB/TBD EOF Bit

//-------------------------------------------------------------------------
// Config CB Parameter Fields
//-------------------------------------------------------------------------
#define CB_CFIG_BYTE_COUNT          22          // 22 config bytes
#define CB_SHORT_CFIG_BYTE_COUNT    8           // 8 config bytes

// byte 0 bit definitions
#define CB_CFIG_BYTE_COUNT_MASK     BIT_0_5     // Byte count occupies bit 5-0

// byte 1 bit definitions
#define CB_CFIG_RXFIFO_LIMIT_MASK   BIT_0_4     // RxFifo limit mask
#define CB_CFIG_TXFIFO_LIMIT_MASK   BIT_4_7     // TxFifo limit mask

// byte 3 bit definitions --
#define CB_CFIG_B3_MWI_ENABLE       BIT_0       // Memory Write Invalidate Enable Bit

// byte 4 bit definitions
#define CB_CFIG_RX_MIN_DMA_MASK     BIT_0_6     // Rx minimum DMA count mask

// byte 5 bit definitions
#define CB_CFIG_TX_MIN_DMA_MASK     BIT_0_6     // Tx minimum DMA count mask
#define CB_CFIG_DMBC_EN             BIT_7       // Enable Tx/Rx minimum DMA counts

// byte 6 bit definitions
#define CB_CFIG_LATE_SCB            BIT_0       // Update SCB After New Tx Start
#define CB_CFIG_TNO_INT             BIT_2       // Tx Not OK Interrupt
#define CB_CFIG_CI_INT              BIT_3       // Command Complete Interrupt
#define CB_CFIG_SAVE_BAD_FRAMES     BIT_7       // Save Bad Frames Enabled

// byte 7 bit definitions
#define CB_CFIG_DISC_SHORT_FRAMES   BIT_0       // Discard Short Frames
#define CB_CFIG_URUN_RETRY          BIT_1_2     // Underrun Retry Count

// byte 8 bit definitions
#define CB_CFIG_503_MII             BIT_0       // 503 vs. MII mode

// byte 9 bit definitions -- pre-defined all zeros

// byte 10 bit definitions
#define CB_CFIG_NO_SRCADR           BIT_3       // No Source Address Insertion
#define CB_CFIG_PREAMBLE_LEN        BIT_4_5     // Preamble Length
#define CB_CFIG_LOOPBACK_MODE       BIT_6_7     // Loopback Mode

// byte 11 bit definitions
#define CB_CFIG_LINEAR_PRIORITY     BIT_0_2     // Linear Priority

// byte 12 bit definitions
#define CB_CFIG_LINEAR_PRI_MODE     BIT_0       // Linear Priority mode
#define CB_CFIG_IFS_MASK            BIT_4_7     // CSMA level Interframe Spacing mask

// byte 13 bit definitions -- pre-defined all zeros

// byte 14 bit definitions -- pre-defined 0xf2

// byte 15 bit definitions
#define CB_CFIG_PROMISCUOUS         BIT_0       // Promiscuous Mode Enable
#define CB_CFIG_BROADCAST_DIS       BIT_1       // Broadcast Mode Disable
#define CB_CFIG_CRS_OR_CDT          BIT_7       // CRS Or CDT

// byte 16 bit definitions -- pre-defined all zeros

// byte 17 bit definitions -- pre-defined 0x40

// byte 18 bit definitions
#define CB_CFIG_STRIPPING           BIT_0       // Stripping Disabled
#define CB_CFIG_PADDING             BIT_1       // Padding Disabled
#define CB_CFIG_CRC_IN_MEM          BIT_2       // Transfer CRC To Memory

// byte 19 bit definitions
#define CB_CFIG_FORCE_FDX           BIT_6       // Force Full Duplex
#define CB_CFIG_FDX_ENABLE          BIT_7       // Full Duplex Enabled

// byte 20 bit definitions
#define CB_CFIG_MULTI_IA            BIT_6       // Multiple IA Addr

// byte 21 bit definitions
#define CB_CFIG_MULTICAST_ALL       BIT_3       // Multicast All


//-------------------------------------------------------------------------
// Receive Frame Descriptor Fields
//-------------------------------------------------------------------------

//- RFD Status Bits
#define RFD_RECEIVE_COLLISION   BIT_0           // Collision detected on Receive
#define RFD_IA_MATCH            BIT_1           // Indv Address Match Bit
#define RFD_RX_ERR              BIT_4           // RX_ERR pin on Phy was set
#define RFD_FRAME_TOO_SHORT     BIT_7           // Receive Frame Short
#define RFD_DMA_OVERRUN         BIT_8           // Receive DMA Overrun
#define RFD_NO_RESOURCES        BIT_9           // No Buffer Space
#define RFD_ALIGNMENT_ERROR     BIT_10          // Alignment Error
#define RFD_CRC_ERROR           BIT_11          // CRC Error
#define RFD_STATUS_OK           BIT_13          // RFD OK Bit
#define RFD_STATUS_COMPLETE     BIT_15          // RFD Complete Bit

//- RFD Command Bits
#define RFD_EL_BIT              BIT_15          // RFD EL Bit
#define RFD_S_BIT               BIT_14          // RFD Suspend Bit
#define RFD_H_BIT               BIT_4           // Header RFD Bit
#define RFD_SF_BIT              BIT_3           // RFD Flexible Mode

//- RFD misc bits
#define RFD_EOF_BIT             BIT_15          // RFD End-Of-Frame Bit
#define RFD_F_BIT               BIT_14          // RFD Buffer Fetch Bit
#define RFD_ACT_COUNT_MASK      BIT_0_13        // RFD Actual Count Mask
#define RFD_HEADER_SIZE         0x10            // Size of RFD Header (16 bytes)

//-------------------------------------------------------------------------
// Receive Buffer Descriptor Fields
//-------------------------------------------------------------------------
#define RBD_EOF_BIT             BIT_15          // RBD End-Of-Frame Bit
#define RBD_F_BIT               BIT_14          // RBD Buffer Fetch Bit
#define RBD_ACT_COUNT_MASK      BIT_0_13        // RBD Actual Count Mask

#define SIZE_FIELD_MASK         BIT_0_13        // Size of the associated buffer
#define RBD_EL_BIT              BIT_15          // RBD EL Bit


//-------------------------------------------------------------------------
// Size Of Dump Buffer
//-------------------------------------------------------------------------
#define DUMP_BUFFER_SIZE            600         // size of the dump buffer


//-------------------------------------------------------------------------
// Self Test Results
//-------------------------------------------------------------------------
#define CB_SELFTEST_FAIL_BIT        BIT_12
#define CB_SELFTEST_DIAG_BIT        BIT_5
#define CB_SELFTEST_REGISTER_BIT    BIT_3
#define CB_SELFTEST_ROM_BIT         BIT_2

#define CB_SELFTEST_ERROR_MASK ( \
                CB_SELFTEST_FAIL_BIT | CB_SELFTEST_DIAG_BIT | \
                CB_SELFTEST_REGISTER_BIT | CB_SELFTEST_ROM_BIT)


//-------------------------------------------------------------------------
// Driver Configuration Default Parameters for the 557
//  Note: If the driver uses any defaults that are different from the chip's
//        defaults, it will be noted below
//-------------------------------------------------------------------------
// Byte 0 (byte count) default
#define CB_557_CFIG_DEFAULT_PARM0   CB_CFIG_BYTE_COUNT

// Byte 1 (fifo limits) default
#define DEFAULT_TX_FIFO_LIMIT       0x08
#define DEFAULT_RX_FIFO_LIMIT       0x08
#define CB_557_CFIG_DEFAULT_PARM1   0x88

// Byte 2 (IFS) default
#define CB_557_CFIG_DEFAULT_PARM2   0x00

// Byte 3 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM3   0x00

// Byte 4 (Rx DMA min count) default
#define CB_557_CFIG_DEFAULT_PARM4   0x00

// Byte 5 (Tx DMA min count, DMA min count enable) default
#define CB_557_CFIG_DEFAULT_PARM5   0x00

// Byte 6 (Late SCB, TNO int, CI int, Save bad frames) default
#define CB_557_CFIG_DEFAULT_PARM6   0x32

// Byte 7 (Discard short frames, underrun retry) default
//          note: disc short frames will be enabled
#define DEFAULT_UNDERRUN_RETRY      0x01
#define CB_557_CFIG_DEFAULT_PARM7   0x01

// Byte 8 (MII or 503) default
//          note: MII will be the default
#define CB_557_CFIG_DEFAULT_PARM8   0x01

// Byte 9 - Power management for 82558B, 82559
#define CB_WAKE_ON_LINK_BYTE9 0x20
#define CB_WAKE_ON_ARP_PKT_BYTE9 0x40

#define CB_557_CFIG_DEFAULT_PARM9   0 

// Byte 10 (scr addr insertion, preamble, loopback) default
#define CB_557_CFIG_DEFAULT_PARM10  0x2e

// Byte 11 (linear priority) default
#define CB_557_CFIG_DEFAULT_PARM11  0x00

// Byte 12 (IFS,linear priority mode) default
#define CB_557_CFIG_DEFAULT_PARM12  0x60

// Byte 13 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM13  0x00

// Byte 14 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM14  0xf2

// Byte 15 (promiscuous, broadcast, CRS/CDT) default
#define CB_557_CFIG_DEFAULT_PARM15  0xea

// Byte 16 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM16  0x00

// Byte 17 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM17  0x40

// Byte 18 (Stripping, padding, Rcv CRC in mem) default
//          note: padding will be enabled
#define CB_557_CFIG_DEFAULT_PARM18  0xf2

// Byte 19 (reserved) default
//          note: full duplex is enabled if FDX# pin is 0
#define CB_557_CFIG_DEFAULT_PARM19  0x80

// Byte 20 (multi-IA) default
#define CB_557_CFIG_DEFAULT_PARM20  0x3f

// Byte 21 (multicast all) default
#define CB_557_CFIG_DEFAULT_PARM21  0x05


#pragma pack(1)

//-------------------------------------------------------------------------
// Ethernet Frame Structure
//-------------------------------------------------------------------------
//- Ethernet 6-byte Address
typedef struct _ETH_ADDRESS_STRUC {
    UCHAR       EthNodeAddress[ETHERNET_ADDRESS_LENGTH];
} ETH_ADDRESS_STRUC, *PETH_ADDRESS_STRUC;


//- Ethernet 14-byte Header
typedef struct _ETH_HEADER_STRUC {
    UCHAR       Destination[ETHERNET_ADDRESS_LENGTH];
    UCHAR       Source[ETHERNET_ADDRESS_LENGTH];
    USHORT      TypeLength;
} ETH_HEADER_STRUC, *PETH_HEADER_STRUC;


//- Ethernet Buffer (Including Ethernet Header) for Transmits
typedef struct _ETH_TX_BUFFER_STRUC {
    ETH_HEADER_STRUC    TxMacHeader;
    UCHAR               TxBufferData[(TCB_BUFFER_SIZE - sizeof(ETH_HEADER_STRUC))];
} ETH_TX_BUFFER_STRUC, *PETH_TX_BUFFER_STRUC;

typedef struct _ETH_RX_BUFFER_STRUC {
    ETH_HEADER_STRUC    RxMacHeader;
    UCHAR               RxBufferData[(RCB_BUFFER_SIZE - sizeof(ETH_HEADER_STRUC))];
} ETH_RX_BUFFER_STRUC, *PETH_RX_BUFFER_STRUC;



//-------------------------------------------------------------------------
// 82557 Data Structures
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
// Self test
//-------------------------------------------------------------------------
typedef struct _SELF_TEST_STRUC {
    ULONG       StSignature;            // Self Test Signature
    ULONG       StResults;              // Self Test Results
} SELF_TEST_STRUC, *PSELF_TEST_STRUC;


//-------------------------------------------------------------------------
// Control/Status Registers (CSR)
//-------------------------------------------------------------------------
typedef struct _CSR_STRUC {
    USHORT      ScbStatus;              // SCB Status register
    UCHAR       ScbCommandLow;          // SCB Command register (low byte)
    UCHAR       ScbCommandHigh;         // SCB Command register (high byte)
    ULONG       ScbGeneralPointer;      // SCB General pointer
    ULONG       Port;                   // PORT register
    USHORT      FlashControl;           // Flash Control register
    USHORT      EepromControl;          // EEPROM control register
    ULONG       MDIControl;             // MDI Control Register
    ULONG       RxDMAByteCount;         // Receive DMA Byte count register
} CSR_STRUC, *PCSR_STRUC;

//-------------------------------------------------------------------------
// Error Counters
//-------------------------------------------------------------------------
typedef struct _ERR_COUNT_STRUC {
    ULONG       XmtGoodFrames;          // Good frames transmitted
    ULONG       XmtMaxCollisions;       // Fatal frames -- had max collisions
    ULONG       XmtLateCollisions;      // Fatal frames -- had a late coll.
    ULONG       XmtUnderruns;           // Transmit underruns (fatal or re-transmit)
    ULONG       XmtLostCRS;             // Frames transmitted without CRS
    ULONG       XmtDeferred;            // Deferred transmits
    ULONG       XmtSingleCollision;     // Transmits that had 1 and only 1 coll.
    ULONG       XmtMultCollisions;      // Transmits that had multiple coll.
    ULONG       XmtTotalCollisions;     // Transmits that had 1+ collisions.
    ULONG       RcvGoodFrames;          // Good frames received
    ULONG       RcvCrcErrors;           // Aligned frames that had a CRC error
    ULONG       RcvAlignmentErrors;     // Receives that had alignment errors
    ULONG       RcvResourceErrors;      // Good frame dropped due to lack of resources
    ULONG       RcvOverrunErrors;       // Overrun errors - bus was busy
    ULONG       RcvCdtErrors;           // Received frames that encountered coll.
    ULONG       RcvShortFrames;         // Received frames that were to short
    ULONG       CommandComplete;        // A005h indicates cmd completion
} ERR_COUNT_STRUC, *PERR_COUNT_STRUC;


//-------------------------------------------------------------------------
// Command Block (CB) Generic Header Structure
//-------------------------------------------------------------------------
typedef struct _CB_HEADER_STRUC {
    USHORT      CbStatus;               // Command Block Status
    USHORT      CbCommand;              // Command Block Command
    ULONG       CbLinkPointer;          // Link To Next CB
} CB_HEADER_STRUC, *PCB_HEADER_STRUC;


//-------------------------------------------------------------------------
// NOP Command Block (NOP_CB)
//-------------------------------------------------------------------------
typedef struct _NOP_CB_STRUC {
    CB_HEADER_STRUC     NopCBHeader;
} NOP_CB_STRUC, *PNOP_CB_STRUC;


//-------------------------------------------------------------------------
// Individual Address Command Block (IA_CB)
//-------------------------------------------------------------------------
typedef struct _IA_CB_STRUC {
    CB_HEADER_STRUC     IaCBHeader;
    UCHAR               IaAddress[ETHERNET_ADDRESS_LENGTH];
} IA_CB_STRUC, *PIA_CB_STRUC;


//-------------------------------------------------------------------------
// Configure Command Block (CONFIG_CB)
//-------------------------------------------------------------------------
typedef struct _CONFIG_CB_STRUC {
    CB_HEADER_STRUC     ConfigCBHeader;
    UCHAR               ConfigBytes[CB_CFIG_BYTE_COUNT];
} CONFIG_CB_STRUC, *PCONFIG_CB_STRUC;


//-------------------------------------------------------------------------
// MultiCast Command Block (MULTICAST_CB)
//-------------------------------------------------------------------------
typedef struct _MULTICAST_CB_STRUC {
    CB_HEADER_STRUC     McCBHeader;
    USHORT              McCount;        // Number of multicast addresses
    UCHAR               McAddress[(ETHERNET_ADDRESS_LENGTH * MAX_MULTICAST_ADDRESSES)];
} MULTICAST_CB_STRUC, *PMULTICAST_CB_STRUC;

//-------------------------------------------------------------------------
// WakeUp Filter Command Block (FILTER_CB)
//-------------------------------------------------------------------------
typedef struct _FILTER_CB_STRUC {
    CB_HEADER_STRUC     FilterCBHeader;
    ULONG               Pattern[16];        
}FILTER_CB_STRUC , *PFILTER_CB_STRUC ;

//-------------------------------------------------------------------------
// Dump Command Block (DUMP_CB)
//-------------------------------------------------------------------------
typedef struct _DUMP_CB_STRUC {
    CB_HEADER_STRUC     DumpCBHeader;
    ULONG               DumpAreaAddress;        // Dump Buffer Area Address
} DUMP_CB_STRUC, *PDUMP_CB_STRUC;


//-------------------------------------------------------------------------
// Dump Area structure definition
//-------------------------------------------------------------------------
typedef struct _DUMP_AREA_STRUC {
    UCHAR       DumpBuffer[DUMP_BUFFER_SIZE];
} DUMP_AREA_STRUC, *PDUMP_AREA_STRUC;


//-------------------------------------------------------------------------
// Diagnose Command Block (DIAGNOSE_CB)
//-------------------------------------------------------------------------
typedef struct _DIAGNOSE_CB_STRUC {
    CB_HEADER_STRUC     DiagCBHeader;
} DIAGNOSE_CB_STRUC, *PDIAGNOSE_CB_STRUC;

//-------------------------------------------------------------------------
// Transmit Command Block (TxCB)
//-------------------------------------------------------------------------
typedef struct _GENERIC_TxCB {
    CB_HEADER_STRUC     TxCbHeader;
    ULONG               TxCbTbdPointer;         // TBD address
    USHORT              TxCbCount;              // Data Bytes In TCB past header
    UCHAR               TxCbThreshold;          // TX Threshold for FIFO Extender
    UCHAR               TxCbTbdNumber;
    ETH_TX_BUFFER_STRUC TxCbData;
    ULONG               pad0;
    ULONG               pad1;
    ULONG               pad2;
    ULONG               pad3;
} TXCB_STRUC, *PTXCB_STRUC;

//-------------------------------------------------------------------------
// Transmit Buffer Descriptor (TBD)
//-------------------------------------------------------------------------
typedef struct _TBD_STRUC {
    ULONG       TbdBufferAddress;       // Physical Transmit Buffer Address
    unsigned    TbdCount :14;
    unsigned             :1 ;           // always 0
    unsigned    EndOfList:1 ;           // EL bit in Tbd
    unsigned             :16;           // field that is always 0's in a TBD
} TBD_STRUC, *PTBD_STRUC;


//-------------------------------------------------------------------------
// Receive Frame Descriptor (RFD)
//-------------------------------------------------------------------------
typedef struct _RFD_STRUC {
    CB_HEADER_STRUC     RfdCbHeader;
    ULONG               RfdRbdPointer;  // Receive Buffer Descriptor Addr
    USHORT              RfdActualCount; // Number Of Bytes Received
    USHORT              RfdSize;        // Number Of Bytes In RFD
    ETH_RX_BUFFER_STRUC RfdBuffer;      // Data buffer in RFD
} RFD_STRUC, *PRFD_STRUC;


//-------------------------------------------------------------------------
// Receive Buffer Descriptor (RBD)
//-------------------------------------------------------------------------
typedef struct _RBD_STRUC {
    USHORT      RbdActualCount;         // Number Of Bytes Received
    USHORT      RbdFiller;
    ULONG       RbdLinkAddress;         // Link To Next RBD
    ULONG       RbdRcbAddress;          // Receive Buffer Address
    USHORT      RbdSize;                // Receive Buffer Size
    USHORT      RbdFiller1;
} RBD_STRUC, *PRBD_STRUC;

#pragma pack()

//-------------------------------------------------------------------------
// 82557 PCI Register Definitions
// Refer To The PCI Specification For Detailed Explanations
//-------------------------------------------------------------------------
//- Register Offsets
#define PCI_VENDOR_ID_REGISTER      0x00    // PCI Vendor ID Register
#define PCI_DEVICE_ID_REGISTER      0x02    // PCI Device ID Register
#define PCI_CONFIG_ID_REGISTER      0x00    // PCI Configuration ID Register
#define PCI_COMMAND_REGISTER        0x04    // PCI Command Register
#define PCI_STATUS_REGISTER         0x06    // PCI Status Register
#define PCI_REV_ID_REGISTER         0x08    // PCI Revision ID Register
#define PCI_CLASS_CODE_REGISTER     0x09    // PCI Class Code Register
#define PCI_CACHE_LINE_REGISTER     0x0C    // PCI Cache Line Register
#define PCI_LATENCY_TIMER           0x0D    // PCI Latency Timer Register
#define PCI_HEADER_TYPE             0x0E    // PCI Header Type Register
#define PCI_BIST_REGISTER           0x0F    // PCI Built-In SelfTest Register
#define PCI_BAR_0_REGISTER          0x10    // PCI Base Address Register 0
#define PCI_BAR_1_REGISTER          0x14    // PCI Base Address Register 1
#define PCI_BAR_2_REGISTER          0x18    // PCI Base Address Register 2
#define PCI_BAR_3_REGISTER          0x1C    // PCI Base Address Register 3
#define PCI_BAR_4_REGISTER          0x20    // PCI Base Address Register 4
#define PCI_BAR_5_REGISTER          0x24    // PCI Base Address Register 5
#define PCI_SUBVENDOR_ID_REGISTER   0x2C    // PCI SubVendor ID Register
#define PCI_SUBDEVICE_ID_REGISTER   0x2E    // PCI SubDevice ID Register
#define PCI_EXPANSION_ROM           0x30    // PCI Expansion ROM Base Register
#define PCI_INTERRUPT_LINE          0x3C    // PCI Interrupt Line Register
#define PCI_INTERRUPT_PIN           0x3D    // PCI Interrupt Pin Register
#define PCI_MIN_GNT_REGISTER        0x3E    // PCI Min-Gnt Register
#define PCI_MAX_LAT_REGISTER        0x3F    // PCI Max_Lat Register
#define PCI_NODE_ADDR_REGISTER      0x40    // PCI Node Address Register


//-------------------------------------------------------------------------
// PHY 100 MDI Register/Bit Definitions
//-------------------------------------------------------------------------
// MDI register set
#define MDI_CONTROL_REG             0x00        // MDI control register
#define MDI_STATUS_REG              0x01        // MDI Status regiser
#define PHY_ID_REG_1                0x02        // Phy indentification reg (word 1)
#define PHY_ID_REG_2                0x03        // Phy indentification reg (word 2)
#define AUTO_NEG_ADVERTISE_REG      0x04        // Auto-negotiation advertisement
#define AUTO_NEG_LINK_PARTNER_REG   0x05        // Auto-negotiation link partner ability
#define AUTO_NEG_EXPANSION_REG      0x06        // Auto-negotiation expansion
#define AUTO_NEG_NEXT_PAGE_REG      0x07        // Auto-negotiation next page transmit
#define EXTENDED_REG_0              0x10        // Extended reg 0 (Phy 100 modes)
#define EXTENDED_REG_1              0x14        // Extended reg 1 (Phy 100 error indications)
#define NSC_CONG_CONTROL_REG        0x17        // National (TX) congestion control
#define NSC_SPEED_IND_REG           0x19        // National (TX) speed indication
#define PHY_EQUALIZER_REG           0x1A        // Register for the Phy Equalizer values

// MDI Control register bit definitions
#define MDI_CR_COLL_TEST_ENABLE     BIT_7       // Collision test enable
#define MDI_CR_FULL_HALF            BIT_8       // FDX =1, half duplex =0
#define MDI_CR_RESTART_AUTO_NEG     BIT_9       // Restart auto negotiation
#define MDI_CR_ISOLATE              BIT_10      // Isolate PHY from MII
#define MDI_CR_POWER_DOWN           BIT_11      // Power down
#define MDI_CR_AUTO_SELECT          BIT_12      // Auto speed select enable
#define MDI_CR_10_100               BIT_13      // 0 = 10Mbs, 1 = 100Mbs
#define MDI_CR_LOOPBACK             BIT_14      // 0 = normal, 1 = loopback
#define MDI_CR_RESET                BIT_15      // 0 = normal, 1 = PHY reset

// MDI Status register bit definitions
#define MDI_SR_EXT_REG_CAPABLE      BIT_0       // Extended register capabilities
#define MDI_SR_JABBER_DETECT        BIT_1       // Jabber detected
#define MDI_SR_LINK_STATUS          BIT_2       // Link Status -- 1 = link
#define MDI_SR_AUTO_SELECT_CAPABLE  BIT_3       // Auto speed select capable
#define MDI_SR_REMOTE_FAULT_DETECT  BIT_4       // Remote fault detect
#define MDI_SR_AUTO_NEG_COMPLETE    BIT_5       // Auto negotiation complete
#define MDI_SR_10T_HALF_DPX         BIT_11      // 10BaseT Half Duplex capable
#define MDI_SR_10T_FULL_DPX         BIT_12      // 10BaseT full duplex capable
#define MDI_SR_TX_HALF_DPX          BIT_13      // TX Half Duplex capable
#define MDI_SR_TX_FULL_DPX          BIT_14      // TX full duplex capable
#define MDI_SR_T4_CAPABLE           BIT_15      // T4 capable

// Auto-Negotiation advertisement register bit definitions
#define NWAY_AD_SELCTOR_FIELD       BIT_0_4     // identifies supported protocol
#define NWAY_AD_ABILITY             BIT_5_12    // technologies that are supported
#define NWAY_AD_10T_HALF_DPX        BIT_5       // 10BaseT Half Duplex capable
#define NWAY_AD_10T_FULL_DPX        BIT_6       // 10BaseT full duplex capable
#define NWAY_AD_TX_HALF_DPX         BIT_7       // TX Half Duplex capable
#define NWAY_AD_TX_FULL_DPX         BIT_8       // TX full duplex capable
#define NWAY_AD_T4_CAPABLE          BIT_9       // T4 capable
#define NWAY_AD_REMOTE_FAULT        BIT_13      // indicates local remote fault
#define NWAY_AD_RESERVED            BIT_14      // reserved
#define NWAY_AD_NEXT_PAGE           BIT_15      // Next page (not supported)

// Auto-Negotiation link partner ability register bit definitions
#define NWAY_LP_SELCTOR_FIELD       BIT_0_4     // identifies supported protocol
#define NWAY_LP_ABILITY             BIT_5_9     // technologies that are supported
#define NWAY_LP_REMOTE_FAULT        BIT_13      // indicates partner remote fault
#define NWAY_LP_ACKNOWLEDGE         BIT_14      // acknowledge
#define NWAY_LP_NEXT_PAGE           BIT_15      // Next page (not supported)

// Auto-Negotiation expansion register bit definitions
#define NWAY_EX_LP_NWAY             BIT_0       // link partner is NWAY
#define NWAY_EX_PAGE_RECEIVED       BIT_1       // link code word received
#define NWAY_EX_NEXT_PAGE_ABLE      BIT_2       // local is next page able
#define NWAY_EX_LP_NEXT_PAGE_ABLE   BIT_3       // partner is next page able
#define NWAY_EX_PARALLEL_DET_FLT    BIT_4       // parallel detection fault
#define NWAY_EX_RESERVED            BIT_5_15    // reserved


// PHY 100 Extended Register 0 bit definitions
#define PHY_100_ER0_FDX_INDIC       BIT_0       // 1 = FDX, 0 = half duplex
#define PHY_100_ER0_SPEED_INDIC     BIT_1       // 1 = 100mbs, 0= 10mbs
#define PHY_100_ER0_WAKE_UP         BIT_2       // Wake up DAC
#define PHY_100_ER0_RESERVED        BIT_3_4     // Reserved
#define PHY_100_ER0_REV_CNTRL       BIT_5_7     // Revsion control (A step = 000)
#define PHY_100_ER0_FORCE_FAIL      BIT_8       // Force Fail is enabled
#define PHY_100_ER0_TEST            BIT_9_13    // Revsion control (A step = 000)
#define PHY_100_ER0_LINKDIS         BIT_14      // Link integrity test is disabled
#define PHY_100_ER0_JABDIS          BIT_15      // Jabber function is disabled


// PHY 100 Extended Register 1 bit definitions
#define PHY_100_ER1_RESERVED        BIT_0_8     // Reserved
#define PHY_100_ER1_CH2_DET_ERR     BIT_9       // Channel 2 EOF detection error
#define PHY_100_ER1_MANCH_CODE_ERR  BIT_10      // Manchester code error
#define PHY_100_ER1_EOP_ERR         BIT_11      // EOP error
#define PHY_100_ER1_BAD_CODE_ERR    BIT_12      // bad code error
#define PHY_100_ER1_INV_CODE_ERR    BIT_13      // invalid code error
#define PHY_100_ER1_DC_BAL_ERR      BIT_14      // DC balance error
#define PHY_100_ER1_PAIR_SKEW_ERR   BIT_15      // Pair skew error

// PHY TX Register/Bit definitions
#define PHY_TX_STATUS_CTRL_REG      0x10
#define PHY_TX_POLARITY_MASK        BIT_8       // register 10h bit 8 (the polarity bit)
#define PHY_TX_NORMAL_POLARITY      0           // register 10h bit 8 =0 (normal polarity)

#define PHY_TX_SPECIAL_CTRL_REG     0x11
#define AUTO_POLARITY_DISABLE       BIT_4       // register 11h bit 4 (0=enable, 1=disable)

#define PHY_TX_REG_18               0x18        // Error counter register
// National Semiconductor TX phy congestion control register bit definitions
#define NSC_TX_CONG_TXREADY         BIT_10      // Makes TxReady an input
#define NSC_TX_CONG_ENABLE          BIT_8       // Enables congestion control
#define NSC_TX_CONG_F_CONNECT       BIT_5       // Enables congestion control

// National Semiconductor TX phy speed indication register bit definitions
#define NSC_TX_SPD_INDC_SPEED       BIT_6       // 0 = 100mb, 1=10mb

#endif  // _E100_557_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\e100_def.h ===
#ifndef _E100_DEF_H_
#define _E100_DEF_H_

//-------------------------------------------------------------------------
// NON_TRANSMIT_CB -- Generic Non-Transmit Command Block
//-------------------------------------------------------------------------
typedef struct _NON_TRANSMIT_CB
{
    union
    {
        MULTICAST_CB_STRUC  Multicast;
        CONFIG_CB_STRUC     Config;
        IA_CB_STRUC         Setup;
        DUMP_CB_STRUC       Dump;
        FILTER_CB_STRUC     Filter;
    }   NonTxCb;

} NON_TRANSMIT_CB, *PNON_TRANSMIT_CB;

//-------------------------------------------------------------------------
// WMI header file e100_wmi.h, generated by wmimofck utility from e100.bmf
//-------------------------------------------------------------------------

//#include "e100_wmi.h"

#endif //_E100_DEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp.h

Abstract:
    Miniport generic portion header file

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       03-04-99    created

Notes:

--*/

#ifndef _MP_H
#define _MP_H

#ifdef NDIS50_MINIPORT
#define MP_NDIS_MAJOR_VERSION       5
#define MP_NDIS_MINOR_VERSION       0
#endif

#ifdef NDIS51_MINIPORT
#define MP_NDIS_MAJOR_VERSION       5
#define MP_NDIS_MINOR_VERSION       1
#endif

#define ALIGN_16                   16

#ifndef MIN
#define MIN(a, b)   ((a) > (b) ? b: a)
#endif



//--------------------------------------
// Queue structure and macros
//--------------------------------------
typedef struct _QUEUE_ENTRY
{
    struct _QUEUE_ENTRY *Next;
} QUEUE_ENTRY, *PQUEUE_ENTRY;

typedef struct _QUEUE_HEADER
{
    PQUEUE_ENTRY Head;
    PQUEUE_ENTRY Tail;
} QUEUE_HEADER, *PQUEUE_HEADER;

#define InitializeQueueHeader(QueueHeader)                 \
    {                                                      \
        (QueueHeader)->Head = (QueueHeader)->Tail = NULL;  \
    }

#define IsQueueEmpty(QueueHeader) ((QueueHeader)->Head == NULL)

#define RemoveHeadQueue(QueueHeader)                  \
    (QueueHeader)->Head;                              \
    {                                                 \
        PQUEUE_ENTRY pNext;                           \
        ASSERT((QueueHeader)->Head);                  \
        pNext = (QueueHeader)->Head->Next;            \
        (QueueHeader)->Head = pNext;                  \
        if (pNext == NULL)                            \
            (QueueHeader)->Tail = NULL;               \
    }

#define InsertHeadQueue(QueueHeader, QueueEntry)                \
    {                                                           \
        ((PQUEUE_ENTRY)QueueEntry)->Next = (QueueHeader)->Head; \
        (QueueHeader)->Head = (PQUEUE_ENTRY)(QueueEntry);       \
        if ((QueueHeader)->Tail == NULL)                        \
            (QueueHeader)->Tail = (PQUEUE_ENTRY)(QueueEntry);   \
    }

#define InsertTailQueue(QueueHeader, QueueEntry)                     \
    {                                                                \
        ((PQUEUE_ENTRY)QueueEntry)->Next = NULL;                     \
        if ((QueueHeader)->Tail)                                     \
            (QueueHeader)->Tail->Next = (PQUEUE_ENTRY)(QueueEntry);  \
        else                                                         \
            (QueueHeader)->Head = (PQUEUE_ENTRY)(QueueEntry);        \
        (QueueHeader)->Tail = (PQUEUE_ENTRY)(QueueEntry);            \
    }

//--------------------------------------
// Common fragment list structure
// Identical to the scatter gather frag list structure
// This is created to simplify the NIC-specific portion code
//--------------------------------------
#define MP_FRAG_ELEMENT SCATTER_GATHER_ELEMENT 
#define PMP_FRAG_ELEMENT PSCATTER_GATHER_ELEMENT 

typedef struct _MP_FRAG_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    MP_FRAG_ELEMENT Elements[NIC_MAX_PHYS_BUF_COUNT];
} MP_FRAG_LIST, *PMP_FRAG_LIST;
                     

//--------------------------------------
// Some utility macros        
//--------------------------------------
#ifndef min
#define min(_a, _b)     (((_a) < (_b)) ? (_a) : (_b))
#endif

#ifndef max
#define max(_a, _b)     (((_a) > (_b)) ? (_a) : (_b))
#endif

#define MP_ALIGNMEM(_p, _align) ((_align == 0) ?  (_p) : ((((ULONG_PTR)(_p) % _align) == 0) ? (_p) : ((PUCHAR)(_p) + _align)))
#define MP_ALIGNMEM_PHYS(_p, _align) ((_align == 0) ?  (_p) : ((((ULONG)(_p) % _align) == 0) ? (_p) : ((ULONG)(_p) + _align)))
#define MP_ALIGNMEM_PA(_p, _align) ((_align == 0) ?  (_p).QuadPart : ((((_p).QuadPart % _align) == 0) ? (_p).QuadPart : ((_p).QuadPart + _align)))

#define GetListHeadEntry(ListHead)  ((ListHead)->Flink)
#define GetListTailEntry(ListHead)  ((ListHead)->Blink)
#define GetListFLink(ListEntry)     ((ListEntry)->Flink)

#define IsSListEmpty(ListHead)  (((PSINGLE_LIST_ENTRY)ListHead)->Next == NULL)

#define MP_EXIT goto exit

//--------------------------------------
// Memory manipulation macros        
//--------------------------------------

/*++
VOID
MP_MEMSET(
    IN  PVOID       Pointer,
    IN  ULONG       Length,
    IN  UCHAR       Value
    )
--*/
#define MP_MEMSET(Pointer, Length, Value)   NdisFillMemory(Pointer, Length, Value)

/*++
VOID
MP_MEMCOPY(
    IN  POPAQUE     Destn,
    IN  POPAQUE     Source,
    IN  ULONG       Length
    )
--*/
#define MP_MEMCOPY(Destn, Source, Length) NdisMoveMemory((Destn), (Source), (Length))


/*++
ULONG
MP_MEMCOPY(
    IN  PVOID       Destn,
    IN  PVOID       Source,
    IN  ULONG       Length
    )
--*/
#define MPMemCmp(Destn, Source, Length)   \
    RtlCompareMemory((PUCHAR)(Destn), (PUCHAR)(Source), (ULONG)(Length))

#if DBG

/*++
PVOID
MP_ALLOCMEM(
    IN  ULONG   Size
    )
--*/
#define MP_ALLOCMEM(pptr, size, flags, highest) \
    MPAuditAllocMem(pptr, size, flags, highest, _FILENUMBER, __LINE__);

#define MP_ALLOCMEMTAG(pptr, size) \
    MPAuditAllocMemTag(pptr, size, _FILENUMBER, __LINE__);

/*++
VOID
MP_FREEMEM(
    IN  PVOID   Pointer
    )
--*/
#define MP_FREEMEM(ptr, size, flags) MPAuditFreeMem(ptr, size, flags)

#else // DBG

#define MP_ALLOCMEM(pptr, size, flags, highest) \
    NdisAllocateMemory(pptr, size, flags, highest)

#define MP_ALLOCMEMTAG(pptr, size) \
    NdisAllocateMemoryWithTag(pptr, size, NIC_TAG)

#define MP_FREEMEM(ptr, size, flags) NdisFreeMemory(ptr, size, flags)

#endif 

#define MP_FREE_NDIS_STRING(str)                        \
    MP_FREEMEM((str)->Buffer, (str)->MaximumLength, 0); \
    (str)->Length = 0;                                  \
    (str)->MaximumLength = 0;                           \
    (str)->Buffer = NULL;

//--------------------------------------
// Macros for flag and ref count operations       
//--------------------------------------
#define MP_SET_FLAG(_M, _F)         ((_M)->Flags |= (_F))   
#define MP_CLEAR_FLAG(_M, _F)       ((_M)->Flags &= ~(_F))
#define MP_CLEAR_FLAGS(_M)          ((_M)->Flags = 0)
#define MP_TEST_FLAG(_M, _F)        (((_M)->Flags & (_F)) != 0)
#define MP_TEST_FLAGS(_M, _F)       (((_M)->Flags & (_F)) == (_F))

#define MP_INC_REF(_A)              NdisInterlockedIncrement(&(_A)->RefCount)
#define MP_DEC_REF(_A)              NdisInterlockedDecrement(&(_A)->RefCount); ASSERT(_A->RefCount >= 0)
#define MP_GET_REF(_A)              ((_A)->RefCount)

#define MP_INC_RCV_REF(_A)          ((_A)->RcvRefCount++)
#define MP_DEC_RCV_REF(_A)          ((_A)->RcvRefCount--)
#define MP_GET_RCV_REF(_A)          ((_A)->RcvRefCount)
   

#define MP_LBFO_INC_REF(_A)         NdisInterlockedIncrement(&(_A)->RefCountLBFO)
#define MP_LBFO_DEC_REF(_A)         NdisInterlockedDecrement(&(_A)->RefCountLBFO); ASSERT(_A->RefCountLBFO >= 0)
#define MP_LBFO_GET_REF(_A)         ((_A)->RefCountLBFO)


//--------------------------------------
// Coalesce Tx buffer for local data copying                     
//--------------------------------------
typedef struct _MP_TXBUF
{
    SINGLE_LIST_ENTRY       SList;
    PNDIS_BUFFER            NdisBuffer;

    ULONG                   AllocSize;
    PVOID                   AllocVa;
    NDIS_PHYSICAL_ADDRESS   AllocPa; 

    PUCHAR                  pBuffer;
    NDIS_PHYSICAL_ADDRESS   BufferPa;
    ULONG                   BufferSize;

} MP_TXBUF, *PMP_TXBUF;

//--------------------------------------
// TCB (Transmit Control Block)
//--------------------------------------
typedef struct _MP_TCB
{
    struct _MP_TCB    *Next;
    ULONG             Flags;
    ULONG             Count;
    PNDIS_PACKET      Packet;

    PMP_TXBUF         MpTxBuf;
    PHW_TCB           HwTcb;            // ptr to HW TCB VA
    ULONG             HwTcbPhys;        // ptr to HW TCB PA
    PHW_TCB           PrevHwTcb;        // ptr to previous HW TCB VA

    PTBD_STRUC        HwTbd;            // ptr to first TBD 
    ULONG             HwTbdPhys;        // ptr to first TBD PA

    ULONG             PhysBufCount;                                 
    ULONG             BufferCount;   
    PNDIS_BUFFER      FirstBuffer;                              
    ULONG             PacketLength;


} MP_TCB, *PMP_TCB;

//--------------------------------------
// RFD (Receive Frame Descriptor)
//--------------------------------------
typedef struct _MP_RFD
{
    LIST_ENTRY              List;
    PNDIS_PACKET            NdisPacket;
    PNDIS_BUFFER            NdisBuffer;         // Pointer to Buffer

    PHW_RFD                 HwRfd;              // ptr to hardware RFD
    NDIS_PHYSICAL_ADDRESS   HwRfdPa;            // physical address of RFD   
    ULONG                   HwRfdPhys;          // lower part of HwRfdPa 
    
    ULONG                   Flags;
    UINT                    PacketSize;         // total size of receive frame
} MP_RFD, *PMP_RFD;

//--------------------------------------
// Structure for pended OIS query request
//--------------------------------------
typedef struct _MP_QUERY_REQUEST
{
    IN NDIS_OID Oid;
    IN PVOID InformationBuffer;
    IN ULONG InformationBufferLength;
    OUT PULONG BytesWritten;
    OUT PULONG BytesNeeded;
} MP_QUERY_REQUEST, *PMP_QUERY_REQUEST;

//--------------------------------------
// Structure for pended OIS set request
//--------------------------------------
typedef struct _MP_SET_REQUEST
{
    IN NDIS_OID Oid;
    IN PVOID InformationBuffer;
    IN ULONG InformationBufferLength;
    OUT PULONG BytesRead;
    OUT PULONG BytesNeeded;
} MP_SET_REQUEST, *PMP_SET_REQUEST;

//--------------------------------------
// Structure for Power Management Info
//--------------------------------------
typedef struct _MP_POWER_MGMT
{


    // List of Wake Up Patterns
    LIST_ENTRY              PatternList;

    // IP address   
    union 
    {
        IPAddr              u32;
        UCHAR               u8[4];
    
    }IPAddress;

    // Number of outstanding Rcv Packet.
    UINT                    OutstandingRecv;
    // Current Power state of the adapter
    UINT                    PowerState;

    // Is PME_En on this adapter
    BOOLEAN                 PME_En;

    // Wake-up capabailities of the adapter
    BOOLEAN                 bWakeFromD0;
    BOOLEAN                 bWakeFromD1;
    BOOLEAN                 bWakeFromD2;
    BOOLEAN                 bWakeFromD3Hot;
    BOOLEAN                 bWakeFromD3Aux;
    // Pad
    BOOLEAN                 Pad[2];

} MP_POWER_MGMT, *PMP_POWER_MGMT;

typedef struct _MP_WAKE_PATTERN 
{
    // Link to the next Pattern
    LIST_ENTRY      linkListEntry;

    // E100 specific signature of the pattern
    ULONG           Signature;

    // Size of this allocation
    ULONG           AllocationSize;

    // Pattern - This contains the NDIS_PM_PACKET_PATTERN
    UCHAR           Pattern[1];
    
} MP_WAKE_PATTERN , *PMP_WAKE_PATTERN ;

//--------------------------------------
// Macros specific to miniport adapter structure 
//--------------------------------------
#define MP_TCB_RESOURCES_AVAIABLE(_M) ((_M)->nBusySend < (_M)->NumTcb)

#define MP_SHOULD_FAIL_SEND(_M)   ((_M)->Flags & fMP_ADAPTER_FAIL_SEND_MASK) 
#define MP_IS_NOT_READY(_M)       ((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK)
#define MP_IS_READY(_M)           !((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK)

#define MP_SET_PACKET_RFD(_p, _rfd)  *((PMP_RFD *)&(_p)->MiniportReserved[0]) = _rfd
#define MP_GET_PACKET_RFD(_p)        *((PMP_RFD *)&(_p)->MiniportReserved[0])
#define MP_GET_PACKET_MR(_p)         (&(_p)->MiniportReserved[0]) 

#define MP_SET_HARDWARE_ERROR(adapter)    MP_SET_FLAG(adapter, fMP_ADAPTER_HARDWARE_ERROR) 
#define MP_SET_NON_RECOVER_ERROR(adapter) MP_SET_FLAG(adapter, fMP_ADAPTER_NON_RECOVER_ERROR)

#define MP_OFFSET(field)   ((UINT)FIELD_OFFSET(MP_ADAPTER,field))
#define MP_SIZE(field)     sizeof(((PMP_ADAPTER)0)->field)

#if OFFLOAD


// The offload capabilities of the miniport
typedef struct _NIC_TASK_OFFLOAD
{
    ULONG   ChecksumOffload:1;
    ULONG   LargeSendOffload:1;
    ULONG   IpSecOffload:1;

}NIC_TASK_OFFLOAD;

// Checksum offload capabilities
typedef struct _NIC_CHECKSUM_OFFLOAD
{
    ULONG   DoXmitTcpChecksum:1;
    ULONG   DoRcvTcpChecksum:1;
    ULONG   DoXmitUdpChecksum:1;
    ULONG   DoRcvUdpChecksum:1;
    ULONG   DoXmitIpChecksum:1;
    ULONG   DoRcvIpChecksum:1;
    
}NIC_CHECKSUM_OFFLOAD;

// LargeSend offload information
typedef struct _NIC_LARGE_SEND_OFFLOAD
{
    NDIS_TASK_TCP_LARGE_SEND LargeSendInfo;
}NIC_LARGE_SEND_OFFLOAD;

// IpSec offload information

//
// shared memory for offloading
typedef struct _OFFLOAD_SHARED_MEM
{
    PVOID  StartVa;
    NDIS_PHYSICAL_ADDRESS  PhyAddr;
}OFFLOAD_SHARED_MEM;

#endif


//--------------------------------------
// The miniport adapter structure
//--------------------------------------
typedef struct _MP_ADAPTER MP_ADAPTER, *PMP_ADAPTER;
typedef struct _MP_ADAPTER
{
    LIST_ENTRY              List;
    
    // Handle given by NDIS when the Adapter registered itself.
    NDIS_HANDLE             AdapterHandle;

    //flags 
    ULONG                   Flags;

    // configuration 
    UCHAR                   PermanentAddress[ETH_LENGTH_OF_ADDRESS];
    UCHAR                   CurrentAddress[ETH_LENGTH_OF_ADDRESS];
    BOOLEAN                 bOverrideAddress;

    NDIS_EVENT              ExitEvent;

    // SEND                       
    PMP_TCB                 CurrSendHead;
    PMP_TCB                 CurrSendTail;
    LONG                    nBusySend;
    LONG                    nWaitSend;
    LONG                    nCancelSend;
    QUEUE_HEADER            SendWaitQueue;
    QUEUE_HEADER            SendCancelQueue;
    SINGLE_LIST_ENTRY       SendBufList;

    LONG                    NumTcb;             // Total number of TCBs
    LONG                    RegNumTcb;          // 'NumTcb'
    LONG                    NumTbd;
    LONG                    NumBuffers;

    NDIS_HANDLE             SendBufferPool;

    PUCHAR                  MpTcbMem;
    ULONG                   MpTcbMemSize;

    PUCHAR                  MpTxBufMem;
    ULONG                   MpTxBufMemSize;

    PUCHAR                  HwSendMemAllocVa;
    ULONG                   HwSendMemAllocSize;
    NDIS_PHYSICAL_ADDRESS   HwSendMemAllocPa;

    // Map register variables (for win9x)
    UINT                    CurrMapRegHead;
    UINT                    CurrMapRegTail;

    // command unit status flags
    BOOLEAN                 TransmitIdle;
    BOOLEAN                 ResumeWait;

    // RECV
    LIST_ENTRY              RecvList;
    LIST_ENTRY              RecvPendList;
    LONG                    nReadyRecv;
    LONG                    RefCount;

    LONG                    NumRfd;
    LONG                    CurrNumRfd;
    LONG                    MaxNumRfd;
    ULONG                   HwRfdSize;
    BOOLEAN                 bAllocNewRfd;
    LONG                    RfdShrinkCount;

    NDIS_HANDLE             RecvPacketPool;
    NDIS_HANDLE             RecvBufferPool;

    // spin locks
    NDIS_SPIN_LOCK          Lock;

    // lookaside lists                               
    NPAGED_LOOKASIDE_LIST   RecvLookaside;

    // Packet Filter and look ahead size.
    ULONG                   PacketFilter;
    ULONG                   ulLookAhead;
    USHORT                  usLinkSpeed;
    USHORT                  usDuplexMode;

    // multicast list
    UINT                    MCAddressCount;
    UCHAR                   MCList[NIC_MAX_MCAST_LIST][ETH_LENGTH_OF_ADDRESS];

    // Packet counts
    ULONG64                 GoodTransmits;
    ULONG64                 GoodReceives;
    ULONG                   NumTxSinceLastAdjust;

    // Count of transmit errors
    ULONG                   TxAbortExcessCollisions;
    ULONG                   TxLateCollisions;
    ULONG                   TxDmaUnderrun;
    ULONG                   TxLostCRS;
    ULONG                   TxOKButDeferred;
    ULONG                   OneRetry;
    ULONG                   MoreThanOneRetry;
    ULONG                   TotalRetries;

    // Count of receive errors
    ULONG                   RcvCrcErrors;
    ULONG                   RcvAlignmentErrors;
    ULONG                   RcvResourceErrors;
    ULONG                   RcvDmaOverrunErrors;
    ULONG                   RcvCdtFrames;
    ULONG                   RcvRuntErrors;

    ULONG                   IoBaseAddress;    
    ULONG                   IoRange;           
    ULONG                   InterruptLevel;
    NDIS_PHYSICAL_ADDRESS   MemPhysAddress;

    PVOID                   PortOffset;
    PHW_CSR                 CSRAddress;
    NDIS_MINIPORT_INTERRUPT Interrupt;

    // Revision ID
    UCHAR                   RevsionID;

    USHORT                  SubVendorID;
    USHORT                  SubSystemID;

    ULONG                   CacheFillSize;
    ULONG                   Debug;

    PUCHAR                  HwMiscMemAllocVa;
    ULONG                   HwMiscMemAllocSize;
    NDIS_PHYSICAL_ADDRESS   HwMiscMemAllocPa;

    PSELF_TEST_STRUC        SelfTest;           // 82558 SelfTest
    ULONG                   SelfTestPhys;

    PNON_TRANSMIT_CB        NonTxCmdBlock;      // 82558 (non transmit) Command Block
    ULONG                   NonTxCmdBlockPhys;

    PDUMP_AREA_STRUC        DumpSpace;          // 82558 dump buffer area
    ULONG                   DumpSpacePhys;

    PERR_COUNT_STRUC        StatsCounters;
    ULONG                   StatsCounterPhys;

    UINT                    PhyAddress;         // Address of the phy component 
    UCHAR                   Connector;          // 0=Auto, 1=TPE, 2=MII

    USHORT                  AiTxFifo;           // TX FIFO Threshold
    USHORT                  AiRxFifo;           // RX FIFO Threshold
    UCHAR                   AiTxDmaCount;       // Tx dma count
    UCHAR                   AiRxDmaCount;       // Rx dma count
    UCHAR                   AiUnderrunRetry;    // The underrun retry mechanism
    UCHAR                   AiForceDpx;         // duplex setting
    USHORT                  AiTempSpeed;        // 'Speed', user over-ride of line speed
    USHORT                  AiThreshold;        // 'Threshold', Transmit Threshold
    BOOLEAN                 MWIEnable;          // Memory Write Invalidate bit in the PCI command word
    UCHAR                   Congest;            // Enables congestion control
    UCHAR                   SpeedDuplex;        // New reg value for speed/duplex

    NDIS_MEDIA_STATE        MediaState;

    NDIS_DEVICE_POWER_STATE CurrentPowerState;
    NDIS_DEVICE_POWER_STATE NextPowerState;

    UCHAR                   OldParameterField;

    // WMI support
    ULONG                   CustomDriverSet;
    ULONG                   HwErrCount;

    // Minimize init-time 
    BOOLEAN                 bQueryPending;
    BOOLEAN                 bSetPending;
    BOOLEAN                 bResetPending;
    NDIS_MINIPORT_TIMER     LinkDetectionTimer;
    MP_QUERY_REQUEST        QueryRequest;
    MP_SET_REQUEST          SetRequest;
    
    BOOLEAN                 bLinkDetectionWait;
    BOOLEAN                 bLookForLink;
    UCHAR                   CurrentScanPhyIndex;
    UCHAR                   LinkDetectionWaitCount;
    UCHAR                   FoundPhyAt;
    USHORT                  EepromAddressSize;

    MP_POWER_MGMT           PoMgmt;

#if LBFO
    PMP_ADAPTER             PrimaryAdapter;
    LONG                    NumSecondary;
    PMP_ADAPTER             NextSecondary;
    NDIS_SPIN_LOCK          LockLBFO;
    LONG                    RefCountLBFO;
    NDIS_STRING             BundleId;           // BundleId
#endif 
   
    NDIS_SPIN_LOCK          SendLock;
    NDIS_SPIN_LOCK          RcvLock;
    ULONG                   RcvRefCount;  // number of packets that have not been returned back
    NDIS_EVENT              AllPacketsReturnedEvent;

#if OFFLOAD    
    // Add for checksum offloading
    ULONG                   SharedMemRefCount;  
    ULONG                   OffloadSharedMemSize;
    OFFLOAD_SHARED_MEM      OffloadSharedMem;
    NIC_TASK_OFFLOAD        NicTaskOffload;
    NIC_CHECKSUM_OFFLOAD    NicChecksumOffload;
    NDIS_TASK_TCP_LARGE_SEND LargeSendInfo;
    BOOLEAN                 OffloadEnable;
    
    NDIS_ENCAPSULATION_FORMAT   EncapsulationFormat;
#endif

} MP_ADAPTER, *PMP_ADAPTER;

//--------------------------------------
// Stall execution and wait with timeout
//--------------------------------------
/*++
    _condition  - condition to wait for 
    _timeout_ms - timeout value in milliseconds
    _result     - TRUE if condition becomes true before it times out
--*/
#define MP_STALL_AND_WAIT(_condition, _timeout_ms, _result)     \
{                                                               \
    int counter;                                                \
    _result = FALSE;                                            \
    for(counter = _timeout_ms * 50; counter != 0; counter--)    \
    {                                                           \
        if(_condition)                                          \
        {                                                       \
            _result = TRUE;                                     \
            break;                                              \
        }                                                       \
        NdisStallExecution(20);                                 \
    }                                                           \
}

__inline VOID MP_STALL_EXECUTION(
   IN UINT MsecDelay)
{
    // Delay in 100 usec increments
    MsecDelay *= 10;
    while (MsecDelay)
    {
        NdisStallExecution(100);
        MsecDelay--;
    }
}



#if LBFO
#define MP_GET_ADAPTER_HANDLE(_A) (_A)->PrimaryAdapter->AdapterHandle

typedef struct _MP_GLOBAL_DATA
{
    LIST_ENTRY AdapterList;
    NDIS_SPIN_LOCK Lock;
    ULONG ulIndex;
} MP_GLOBAL_DATA, *PMP_GLOBAL_DATA;
#else
#define MP_GET_ADAPTER_HANDLE(_A) (_A)->AdapterHandle
#endif

__inline NDIS_STATUS MP_GET_STATUS_FROM_FLAGS(PMP_ADAPTER Adapter)
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    if(MP_TEST_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS))
    {
        Status = NDIS_STATUS_RESET_IN_PROGRESS;      
    }
    else if(MP_TEST_FLAG(Adapter, fMP_ADAPTER_HARDWARE_ERROR))
    {
        Status = NDIS_STATUS_DEVICE_FAILED;
    }
    else if(MP_TEST_FLAG(Adapter, fMP_ADAPTER_NO_CABLE))
    {
        Status = NDIS_STATUS_NO_CABLE;
    }

    return Status;
}   

//--------------------------------------
// Miniport routines in MP_MAIN.C
//--------------------------------------

NDIS_STATUS DriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath);

VOID MPAllocateComplete(
    NDIS_HANDLE MiniportAdapterContext,
    IN PVOID VirtualAddress,
    IN PNDIS_PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN PVOID Context);

BOOLEAN MPCheckForHang(
    IN NDIS_HANDLE MiniportAdapterContext);

VOID MPHalt(
    IN  NDIS_HANDLE MiniportAdapterContext);

NDIS_STATUS MPInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext);

VOID MPHandleInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext);

VOID MPIsr(
    OUT PBOOLEAN InterruptRecognized,
    OUT PBOOLEAN QueueMiniportHandleInterrupt,
    IN NDIS_HANDLE MiniportAdapterContext);

NDIS_STATUS MPQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded);

NDIS_STATUS MPReset(
    OUT PBOOLEAN AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext);

VOID MPReturnPacket(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN PNDIS_PACKET Packet);

VOID MPSendPackets(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets);

NDIS_STATUS MPSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded);

VOID MPShutdown(
    IN  NDIS_HANDLE MiniportAdapterContext);

#ifdef NDIS51_MINIPORT
VOID MPCancelSendPackets(
    IN  NDIS_HANDLE    MiniportAdapterContext,
    IN  PVOID             CancelId);

VOID MPPnPEventNotify(
    IN  NDIS_HANDLE                MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   PnPEvent,
    IN  PVOID                         InformationBuffer,
    IN  ULONG                         InformationBufferLength);
#endif   

NDIS_STATUS
MPSetPowerD0Private (
    IN MP_ADAPTER* pAdapter
    );

VOID
MPSetPowerLowPrivate(
    PMP_ADAPTER Adapter 
    );

VOID 
MpExtractPMInfoFromPciSpace(
    PMP_ADAPTER pAdapter,
    PUCHAR pPciConfig
    );

VOID
HwSetWakeUpConfigure(
    IN PMP_ADAPTER pAdapter, 
    PUCHAR pPoMgmtConfigType, 
    UINT WakeUpParameter
    );

BOOLEAN  
MPIsPoMgmtSupported(
   IN PMP_ADAPTER pAdapter
   );

VOID 
NICIssueSelectiveReset(
    PMP_ADAPTER Adapter);

NDIS_STATUS
MPCalculateE100PatternForFilter (
    IN PUCHAR pFrame,
    IN ULONG FrameLength,
    IN PUCHAR pMask,
    IN ULONG MaskLength,
    OUT PULONG pSignature
    );

VOID
MPRemoveAllWakeUpPatterns(
    PMP_ADAPTER pAdapter
    );


#if LBFO
VOID MPUnload(IN PDRIVER_OBJECT DriverObject);

VOID MpAddAdapterToList(PMP_ADAPTER Adapter);
VOID MpRemoveAdapterFromList(PMP_ADAPTER Adapter);
VOID MpPromoteSecondary(PMP_ADAPTER Adapter);
#endif


//
// Define different functions depending on OFFLOAD is on or not
// 
#if OFFLOAD
#define MpSendPacketsHandler  MPOffloadSendPackets

#define  MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb)  MP_OFFLOAD_FREE_SEND_PACKET(Adapter, pMpTcb)

#define  MpSendPacketFun(Adapter, Packet, bFromQueue) MpOffloadSendPacket(Adapter, Packet, bFromQueue)

#else    

#define MpSendPacketsHandler  MPSendPackets

#define  MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb)  MP_FREE_SEND_PACKET(Adapter, pMpTcb)

#define  MpSendPacketFun(Adapter, Packet, bFromQueue) MpSendPacket(Adapter, Packet,bFromQueue)

#endif // end OFFLOAD    


#endif  // _MP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_cmn.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_cmn.h

Abstract:
    Common definitions for the miniport and kd extension dll

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#ifndef _MP_CMN_H
#define _MP_CMN_H

// MP_TCB flags
#define fMP_TCB_IN_USE                         0x00000001
#define fMP_TCB_USE_LOCAL_BUF                  0x00000002
#define fMP_TCB_MULTICAST                      0x00000004  // a hardware workaround using multicast
               
// MP_RFD flags                           
#define fMP_RFD_RECV_PEND                      0x00000001
#define fMP_RFD_ALLOC_PEND                     0x00000002
#define fMP_RFD_RECV_READY                     0x00000004
#define fMP_RFD_RESOURCES                      0x00000008

// MP_ADAPTER flags               
#define fMP_ADAPTER_SCATTER_GATHER             0x00000001
#define fMP_ADAPTER_MAP_REGISTER               0x00000002
#define fMP_ADAPTER_RECV_LOOKASIDE             0x00000004
#define fMP_ADAPTER_INTERRUPT_IN_USE           0x00000008
#define fMP_ADAPTER_SECONDARY                  0x00000010

#if OFFLOAD
// MP_ SHARED flags
#define fMP_SHARED_MEM_IN_USE                  0x00000100
#endif

#define fMP_ADAPTER_NON_RECOVER_ERROR          0x00800000

#define fMP_ADAPTER_RESET_IN_PROGRESS          0x01000000
#define fMP_ADAPTER_NO_CABLE                   0x02000000 
#define fMP_ADAPTER_HARDWARE_ERROR             0x04000000
#define fMP_ADAPTER_REMOVE_IN_PROGRESS         0x08000000
#define fMP_ADAPTER_HALT_IN_PROGRESS           0x10000000

#define fMP_ADAPTER_LINK_DETECTION             0x20000000
                                 
#define fMP_ADAPTER_FAIL_SEND_MASK             0x1ff00000                
#define fMP_ADAPTER_NOT_READY_MASK             0x3ff00000    


#endif  // _MP_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\eeprom.c ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    eeprom.c

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop
#pragma warning (disable: 4244 4514)

#define EEPROM_MAX_SIZE        256

//*****************************************************************************
//
//            I/O based Read EEPROM Routines
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// Procedure:   EEpromAddressSize
//
// Description: determines the number of bits in an address for the eeprom
//              acceptable values are 64, 128, and 256
//
// Arguments:
//      Size -- size of the eeprom
//
// Returns:
//      bits in an address for that size eeprom
//-----------------------------------------------------------------------------

USHORT GetEEpromAddressSize(
    IN USHORT  Size)
{
    switch (Size)
    {
        case 64:    return 6;
        case 128:   return 7;
        case 256:   return 8;
    }

    return 0;
}

//-----------------------------------------------------------------------------
// Procedure:   GetEEpromSize
//
// Description: This routine determines the size of the EEPROM.
//
// Arguments:
//      Reg - EEPROM word to read.
//
// Returns:
//      Size of the EEPROM, or zero if error.
//-----------------------------------------------------------------------------

USHORT GetEEpromSize(
    IN PUCHAR CSRBaseIoAddress)
{
    USHORT x, data;
    USHORT size = 1;

    // select EEPROM, reset bits, set EECS
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~(EEDI | EEDO | EESK);
    x |= EECS;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);

    // write the read opcode
    ShiftOutBits(EEPROM_READ_OPCODE, 3, CSRBaseIoAddress);

    // experiment to discover the size of the eeprom.  request register zero
    // and wait for the eeprom to tell us it has accepted the entire address.
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));
    do
    {
        size *= 2;          // each bit of address doubles eeprom size
        x |= EEDO;          // set bit to detect "dummy zero"
        x &= ~EEDI;         // address consists of all zeros

        WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);
        NdisStallExecution(100);
        RaiseClock(&x, CSRBaseIoAddress);
        LowerClock(&x, CSRBaseIoAddress);

        // check for "dummy zero"
        x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));
        if (size > EEPROM_MAX_SIZE)
        {
            size = 0;
            break;
        }
    }
    while (x & EEDO);

    // Now read the data (16 bits) in from the selected EEPROM word
    data = ShiftInBits(CSRBaseIoAddress);

    EEpromCleanup(CSRBaseIoAddress);
    
    return size;
}

//-----------------------------------------------------------------------------
// Procedure:   ReadEEprom
//
// Description: This routine serially reads one word out of the EEPROM.
//
// Arguments:
//      Reg - EEPROM word to read.
//
// Returns:
//      Contents of EEPROM word (Reg).
//-----------------------------------------------------------------------------

USHORT ReadEEprom(
    IN PUCHAR CSRBaseIoAddress,
    IN USHORT Reg,
    IN USHORT AddressSize)
{
    USHORT x;
    USHORT data;

    // select EEPROM, reset bits, set EECS
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~(EEDI | EEDO | EESK);
    x |= EECS;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);

    // write the read opcode and register number in that order
    // The opcode is 3bits in length, reg is 6 bits long
    ShiftOutBits(EEPROM_READ_OPCODE, 3, CSRBaseIoAddress);
    ShiftOutBits(Reg, AddressSize, CSRBaseIoAddress);

    // Now read the data (16 bits) in from the selected EEPROM word
    data = ShiftInBits(CSRBaseIoAddress);

    EEpromCleanup(CSRBaseIoAddress);
    return data;
}

//-----------------------------------------------------------------------------
// Procedure:   ShiftOutBits
//
// Description: This routine shifts data bits out to the EEPROM.
//
// Arguments:
//      data - data to send to the EEPROM.
//      count - number of data bits to shift out.
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID ShiftOutBits(
    IN USHORT data,
    IN USHORT count,
    IN PUCHAR CSRBaseIoAddress)
{
    USHORT x,mask;

    mask = 0x01 << (count - 1);
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~(EEDO | EEDI);

    do
    {
        x &= ~EEDI;
        if(data & mask)
            x |= EEDI;

        WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);
        NdisStallExecution(100);
        RaiseClock(&x, CSRBaseIoAddress);
        LowerClock(&x, CSRBaseIoAddress);
        mask = mask >> 1;
    } while(mask);

    x &= ~EEDI;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);
}

//-----------------------------------------------------------------------------
// Procedure:   ShiftInBits
//
// Description: This routine shifts data bits in from the EEPROM.
//
// Arguments:
//
// Returns:
//      The contents of that particular EEPROM word
//-----------------------------------------------------------------------------

USHORT ShiftInBits(
    IN PUCHAR CSRBaseIoAddress)
{
    USHORT x,d,i;
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~( EEDO | EEDI);
    d = 0;

    for(i=0; i<16; i++)
    {
        d = d << 1;
        RaiseClock(&x, CSRBaseIoAddress);

        x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

        x &= ~(EEDI);
        if(x & EEDO)
            d |= 1;

        LowerClock(&x, CSRBaseIoAddress);
    }

    return d;
}

//-----------------------------------------------------------------------------
// Procedure:   RaiseClock
//
// Description: This routine raises the EEPOM's clock input (EESK)
//
// Arguments:
//      x - Ptr to the EEPROM control register's current value
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID RaiseClock(
    IN OUT USHORT *x,
    IN PUCHAR CSRBaseIoAddress)
{
    *x = *x | EESK;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), *x);
    NdisStallExecution(100);
}


//-----------------------------------------------------------------------------
// Procedure:   LowerClock
//
// Description: This routine lower's the EEPOM's clock input (EESK)
//
// Arguments:
//      x - Ptr to the EEPROM control register's current value
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID LowerClock(
    IN OUT USHORT *x,
    IN PUCHAR CSRBaseIoAddress)
{
    *x = *x & ~EESK;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), *x);
    NdisStallExecution(100);
}

//-----------------------------------------------------------------------------
// Procedure:   EEpromCleanup
//
// Description: This routine returns the EEPROM to an idle state
//
// Arguments:
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID EEpromCleanup(
    IN PUCHAR CSRBaseIoAddress)
{
    USHORT x;
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~(EECS | EEDI);
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);

    RaiseClock(&x, CSRBaseIoAddress);
    LowerClock(&x, CSRBaseIoAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_dbg.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_dbg.c

Abstract:
    This module contains all debug-related code.

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"

#if DBG

/**
Constants
**/

#define _FILENUMBER     'GBED'

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16

ULONG               MPDebugLevel = MP_WARN;
ULONG               MPAllocCount = 0;       // the number of outstanding allocs
NDIS_SPIN_LOCK      MPMemoryLock;           // spinlock for the debug mem list
LIST_ENTRY          MPMemoryList;
BOOLEAN             MPInitDone = FALSE;     // debug mem list init flag 

NDIS_STATUS MPAuditAllocMem(
    PVOID           *pPointer,
    UINT            Size,
    UINT            Flags,
    NDIS_PHYSICAL_ADDRESS HighestAddr,
    ULONG           FileNumber,
    ULONG           LineNumber
    )
{
    NDIS_STATUS     Status;
    PMP_ALLOCATION  pAllocInfo;

    if (!MPInitDone)
    {
        NdisAllocateSpinLock(&MPMemoryLock);
        InitializeListHead(&MPMemoryList);
        MPInitDone = TRUE;
    }

    //
    // Ensure Flags is non-zero, 
    // otherwise NdisAllocateMemoryWithTag should be used
    //
    ASSERT(Flags);                  

    Status = NdisAllocateMemory(
                 (PVOID *)(&pAllocInfo), 
                 (UINT)(Size + sizeof(MP_ALLOCATION)), 
                 Flags,
                 HighestAddr);

    if (pAllocInfo == (PMP_ALLOCATION)NULL)
    {
        DBGPRINT(MP_LOUD,
            ("MPAuditAllocMemCore: file %d, line %d, Size %d failed!\n",
            FileNumber, LineNumber, Size));
        *pPointer = NULL;
    }
    else
    {
        *pPointer = (PVOID)&(pAllocInfo->UserData);
        MP_MEMSET(*pPointer, Size, 0xc);

        pAllocInfo->Signature = 'DOOG';
        pAllocInfo->FileNumber = FileNumber;
        pAllocInfo->LineNumber = LineNumber;
        pAllocInfo->Size = Size;
        pAllocInfo->Location = pPointer;
        pAllocInfo->Flags = Flags;

        NdisAcquireSpinLock(&MPMemoryLock);
        InsertTailList(&MPMemoryList, &pAllocInfo->List);
        MPAllocCount++;
        NdisReleaseSpinLock(&MPMemoryLock);
    }

    DBGPRINT(MP_LOUD,
        ("MPAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x"PTR_FORMAT"] <- 0x"PTR_FORMAT"\n",
        (CHAR)(FileNumber & 0xff),
        (CHAR)((FileNumber >> 8) & 0xff),
        (CHAR)((FileNumber >> 16) & 0xff),
        (CHAR)((FileNumber >> 24) & 0xff),
        LineNumber, Size, pPointer, *pPointer));

    return(Status);
}

NDIS_STATUS MPAuditAllocMemTag(
    PVOID *  pPointer,
    UINT     Size,
    ULONG    FileNumber,
    ULONG    LineNumber
    )
{
    NDIS_STATUS     Status;
    PMP_ALLOCATION  pAllocInfo;

    if (!MPInitDone)
    {
        NdisAllocateSpinLock(&MPMemoryLock);
        InitializeListHead(&MPMemoryList);
        MPInitDone = TRUE;
    }

    Status = NdisAllocateMemoryWithTag(
                 (PVOID *)(&pAllocInfo), 
                 (UINT)(Size + sizeof(MP_ALLOCATION)), 
                 NIC_TAG);

    if (pAllocInfo == (PMP_ALLOCATION)NULL)
    {
        *pPointer = NULL;

        DBGPRINT(MP_LOUD,
            ("MPAuditAllocMemCore: file %d, line %d, Size %d failed!\n",
            FileNumber, LineNumber, Size));
    }
    else
    {
        *pPointer = (PVOID)&(pAllocInfo->UserData);
        MP_MEMSET(*pPointer, Size, 0xc);

        pAllocInfo->Signature = 'DOOG';
        pAllocInfo->FileNumber = FileNumber;
        pAllocInfo->LineNumber = LineNumber;
        pAllocInfo->Size = Size;
        pAllocInfo->Location = pPointer;
        pAllocInfo->Flags = 0;

        NdisAcquireSpinLock(&MPMemoryLock);
        InsertTailList(&MPMemoryList, &pAllocInfo->List);
        MPAllocCount++;
        NdisReleaseSpinLock(&MPMemoryLock);
    }

    DBGPRINT(MP_LOUD,
        ("MPAuditAllocMemTag: file %c%c%c%c, line %d, %d bytes, [0x"PTR_FORMAT"] <- 0x"PTR_FORMAT"\n",
        (CHAR)(FileNumber & 0xff),
        (CHAR)((FileNumber >> 8) & 0xff),
        (CHAR)((FileNumber >> 16) & 0xff),
        (CHAR)((FileNumber >> 24) & 0xff),
        LineNumber, Size, pPointer, *pPointer));

    return(Status);
}

VOID MPAuditFreeMem(
    IN PVOID  Pointer, 
    IN UINT   Size,
    IN UINT   Flags
    )
{
    PMP_ALLOCATION  pAllocInfo;

    pAllocInfo = CONTAINING_RECORD(Pointer, MP_ALLOCATION, UserData);

    ASSERT(pAllocInfo->Signature == (ULONG)'DOOG');
    ASSERT(pAllocInfo->Size == Size);
    ASSERT(pAllocInfo->Flags == Flags);

    NdisAcquireSpinLock(&MPMemoryLock);
    pAllocInfo->Signature = (ULONG)'DEAD';
    RemoveEntryList(&pAllocInfo->List);
    MPAllocCount--;
    NdisReleaseSpinLock(&MPMemoryLock);

    NdisFreeMemory(pAllocInfo, Size + sizeof(MP_ALLOCATION), Flags);
}

VOID mpDbgPrintUnicodeString(
    IN  PUNICODE_STRING UnicodeString
    )
{
    UCHAR Buffer[256];

    USHORT i;

    for (i = 0; (i < UnicodeString->Length / 2) && (i < 255); i++) 
    {
        Buffer[i] = (UCHAR)UnicodeString->Buffer[i];
    }

    Buffer[i] = '\0';

    DbgPrint("%s", Buffer);
}



// Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
// For example, with 'ulGroup' of 1, 2, and 4:
//
// 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
// 0000 0000 0000 0000 0000 0000 0000 0000 |................|
// 00000000 00000000 00000000 00000000 |................|
//
// If 'fAddress' is true, the memory address dumped is prepended to each
// line.
//
VOID
Dump(
    IN CHAR*   p,
    IN ULONG   cb,
    IN BOOLEAN fAddress,
    IN ULONG   ulGroup 
    )
{
    INT cbLine;

    while (cb)
    {

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}


VOID
DumpLine(
    IN CHAR*   p,
    IN ULONG   cb,
    IN BOOLEAN fAddress,
    IN ULONG   ulGroup 
    )
{

    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress) 
    {
        DbgPrint( "E100: %p: ", p );
    }
    else 
    {
        DbgPrint( "E100: " );
    }

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\e100_sup.h ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
     e100_sup.h     (inlinef.h)

This driver runs on the following hardware:
     - 82558 based PCI 10/100Mb ethernet adapters
     (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
     Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
     - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

//-----------------------------------------------------------------------------
// Procedure:   WaitScb
//
// Description: This routine checks to see if the D100 has accepted a command.
//              It does so by checking the command field in the SCB, which will
//              be zeroed by the D100 upon accepting a command.  The loop waits
//              for up to 600 milliseconds for command acceptance.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//      TRUE if the SCB cleared within 600 milliseconds.
//      FALSE if it didn't clear within 600 milliseconds
//-----------------------------------------------------------------------------
__inline BOOLEAN WaitScb(
    IN PMP_ADAPTER Adapter)
{
    BOOLEAN     bResult;
    
    HW_CSR volatile *pCSRAddress = Adapter->CSRAddress;

    MP_STALL_AND_WAIT(pCSRAddress->ScbCommandLow == 0, 600, bResult);
    if(!bResult)
    {
        DBGPRINT(MP_ERROR, ("WaitScb failed, ScbCommandLow=%x\n", pCSRAddress->ScbCommandLow));
        if(pCSRAddress->ScbCommandLow != 0x80)
        {
            ASSERT(FALSE); 
        }
        MP_SET_HARDWARE_ERROR(Adapter);
    }

    return bResult;
}

//-----------------------------------------------------------------------------
// Procedure:   D100IssueScbCommand
//
// Description: This general routine will issue a command to the D100.
//
// Arguments:
//      Adapter - ptr to Adapter object instance.
//      ScbCommand - The command that is to be issued
//      WaitForSCB - A boolean value indicating whether or not a wait for SCB
//                   must be done before the command is issued to the chip
//
// Returns:
//      TRUE if the command was issued to the chip successfully
//      FALSE if the command was not issued to the chip
//-----------------------------------------------------------------------------
__inline NDIS_STATUS D100IssueScbCommand(
    IN PMP_ADAPTER Adapter,
    IN UCHAR ScbCommandLow,
    IN BOOLEAN WaitForScb)
{
    if(WaitForScb == TRUE)
    {
        if(!WaitScb(Adapter))
        {
            return(NDIS_STATUS_HARD_ERRORS);
        }
    }

    Adapter->CSRAddress->ScbCommandLow = ScbCommandLow;

    return(NDIS_STATUS_SUCCESS);
}

// routines.c           
BOOLEAN MdiRead(
    IN PMP_ADAPTER Adapter,
    IN ULONG       RegAddress,
    IN ULONG       PhyAddress,
    IN BOOLEAN     Recoverable,
    IN OUT PUSHORT DataValue);

VOID MdiWrite(
    IN PMP_ADAPTER Adapter,
    IN ULONG       RegAddress,
    IN ULONG       PhyAddress,
    IN USHORT      DataValue);

NDIS_STATUS D100SubmitCommandBlockAndWait(IN PMP_ADAPTER Adapter);
VOID DumpStatsCounters(IN PMP_ADAPTER Adapter);
NDIS_MEDIA_STATE NICGetMediaState(IN PMP_ADAPTER Adapter);
VOID NICIssueSelectiveReset(PMP_ADAPTER Adapter);
VOID NICIssueFullReset(PMP_ADAPTER Adapter);

// physet.c

VOID ResetPhy(IN PMP_ADAPTER Adapter);
NDIS_STATUS PhyDetect(IN PMP_ADAPTER Adapter);
NDIS_STATUS ScanAndSetupPhy(IN PMP_ADAPTER Adapter);
VOID SelectPhy(
    IN PMP_ADAPTER Adapter,
    IN UINT SelectPhyAddress,
    IN BOOLEAN WaitAutoNeg);
NDIS_STATUS SetupPhy(
    IN PMP_ADAPTER Adapter);

VOID FindPhySpeedAndDpx(
    IN PMP_ADAPTER Adapter,
    IN UINT PhyId);


// eeprom.c
USHORT GetEEpromAddressSize(
    IN USHORT Size);

USHORT GetEEpromSize(
    IN PUCHAR CSRBaseIoAddress);

USHORT ReadEEprom(
    IN PUCHAR CSRBaseIoAddress,
    IN USHORT Reg,
    IN USHORT AddressSize);

VOID ShiftOutBits(
    IN USHORT data,
    IN USHORT count,
    IN PUCHAR CSRBaseIoAddress);

USHORT ShiftInBits(
    IN PUCHAR CSRBaseIoAddress);

VOID RaiseClock(
    IN OUT USHORT *x,
    IN PUCHAR CSRBaseIoAddress);

VOID LowerClock(
    IN OUT USHORT *x,
    IN PUCHAR CSRBaseIoAddress);

VOID EEpromCleanup(
    IN PUCHAR CSRBaseIoAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\e100_equ.h ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    e100_equ.h  (equates.h)

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#ifndef _E100_EQU_H
#define _E100_EQU_H

//-------------------------------------------------------------------------
// OEM Message Tags
//-------------------------------------------------------------------------
#define stringTag       0xFEFA      // Length Byte After String
#define lStringTag      0xFEFB      // Length Byte Before String
#define zStringTag      0xFEFC      // Zero-Terminated String Tag
#define nStringTag      0xFEFD      // No Length Byte Or 0-Term

//-------------------------------------------------------------------------
// Adapter Types Supported
//-------------------------------------------------------------------------
#define FLASH32_EISA    (0 * 4)
#define FLASH32_PCI     (1 * 4)
#define D29C_EISA       (2 * 4)
#define D29C_PCI        (3 * 4)
#define D100_PCI        (4 * 4)

//-------------------------------------------------------------------------
// Phy related constants
//-------------------------------------------------------------------------
#define PHY_503                 0
#define PHY_100_A               0x000003E0
#define PHY_100_C               0x035002A8
#define PHY_TX_ID               0x015002A8
#define PHY_NSC_TX              0x5c002000
#define PHY_OTHER               0xFFFF

#define PHY_MODEL_REV_ID_MASK   0xFFF0FFFF
#define PARALLEL_DETECT         0
#define N_WAY                   1

#define RENEGOTIATE_TIME        35 // (3.5 Seconds)

#define CONNECTOR_AUTO          0
#define CONNECTOR_TPE           1
#define CONNECTOR_MII           2

//-------------------------------------------------------------------------
// Ethernet Frame Sizes
//-------------------------------------------------------------------------
#define ETHERNET_ADDRESS_LENGTH         6
#define ETHERNET_HEADER_SIZE            14
#define MINIMUM_ETHERNET_PACKET_SIZE    60
#define MAXIMUM_ETHERNET_PACKET_SIZE    1514

#define MAX_MULTICAST_ADDRESSES         32
#define TCB_BUFFER_SIZE                 0XE0 // 224
#define COALESCE_BUFFER_SIZE            2048
#define ETH_MAX_COPY_LENGTH             0x80 // 128

// Make receive area 1536 for 16 bit alignment.
//#define RCB_BUFFER_SIZE       MAXIMUM_ETHERNET_PACKET_SIZE
#define RCB_BUFFER_SIZE                 1520 // 0x5F0

//- Area reserved for all Non Transmit command blocks
#define MAX_NON_TX_CB_AREA              512

//-------------------------------------------------------------------------
// Ndis/Adapter driver constants
//-------------------------------------------------------------------------
#define MAX_PHYS_DESC                   16
#define MAX_RECEIVE_DESCRIPTORS         1024 // 0x400
#define NUM_RMD                         10

//--------------------------------------------------------------------------
// System wide Equates
//--------------------------------------------------------------------------
#define MAX_NUMBER_OF_EISA_SLOTS        15
#define MAX_NUMBER_OF_PCI_SLOTS         15

//--------------------------------------------------------------------------
//    Equates Added for NDIS 4
//--------------------------------------------------------------------------
#define  NUM_BYTES_PROTOCOL_RESERVED_SECTION    16
#define  MAX_NUM_ALLOCATED_RFDS                 64
#define  MIN_NUM_RFD                            4
#define  MAX_ARRAY_SEND_PACKETS                 8
// limit our receive routine to indicating this many at a time
#define  MAX_ARRAY_RECEIVE_PACKETS              16
#define  MAC_RESERVED_SWRFDPTR                  0
#define  MAX_PACKETS_TO_ADD                     32

//-------------------------------------------------------------------------
//- Miscellaneous Equates
//-------------------------------------------------------------------------
#define CR      0x0D        // Carriage Return
#define LF      0x0A        // Line Feed

#ifndef FALSE
#define FALSE       0
#define TRUE        1
#endif

#define DRIVER_NULL ((ULONG)0xffffffff)
#define DRIVER_ZERO 0

//-------------------------------------------------------------------------
// Bit Mask definitions
//-------------------------------------------------------------------------
#define BIT_0       0x0001
#define BIT_1       0x0002
#define BIT_2       0x0004
#define BIT_3       0x0008
#define BIT_4       0x0010
#define BIT_5       0x0020
#define BIT_6       0x0040
#define BIT_7       0x0080
#define BIT_8       0x0100
#define BIT_9       0x0200
#define BIT_10      0x0400
#define BIT_11      0x0800
#define BIT_12      0x1000
#define BIT_13      0x2000
#define BIT_14      0x4000
#define BIT_15      0x8000
#define BIT_24      0x01000000
#define BIT_28      0x10000000

#define BIT_0_2     0x0007
#define BIT_0_3     0x000F
#define BIT_0_4     0x001F
#define BIT_0_5     0x003F
#define BIT_0_6     0x007F
#define BIT_0_7     0x00FF
#define BIT_0_8     0x01FF
#define BIT_0_13    0x3FFF
#define BIT_0_15    0xFFFF
#define BIT_1_2     0x0006
#define BIT_1_3     0x000E
#define BIT_2_5     0x003C
#define BIT_3_4     0x0018
#define BIT_4_5     0x0030
#define BIT_4_6     0x0070
#define BIT_4_7     0x00F0
#define BIT_5_7     0x00E0
#define BIT_5_9     0x03E0
#define BIT_5_12    0x1FE0
#define BIT_5_15    0xFFE0
#define BIT_6_7     0x00c0
#define BIT_7_11    0x0F80
#define BIT_8_10    0x0700
#define BIT_9_13    0x3E00
#define BIT_12_15   0xF000

#define BIT_16_20   0x001F0000
#define BIT_21_25   0x03E00000
#define BIT_26_27   0x0C000000

// in order to make our custom oids hopefully somewhat unique
// we will use 0xFF (indicating implementation specific OID)
//               A0 (first byte of non zero intel unique identifier)
//               C9 (second byte of non zero intel unique identifier)
//               XX (the custom OID number - providing 255 possible custom oids)
#define OID_CUSTOM_DRIVER_SET       0xFFA0C901
#define OID_CUSTOM_DRIVER_QUERY     0xFFA0C902
#define OID_CUSTOM_ARRAY            0xFFA0C903
#define OID_CUSTOM_STRING           0xFFA0C904

#define CMD_BUS_MASTER              BIT_2

#endif  // _E100_EQU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_def.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_def.h

Abstract:
    NIC specific definitions

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#ifndef _MP_DEF_H
#define _MP_DEF_H

// memory tag for this driver   
#define NIC_TAG                         ((ULONG)'001E')
#define NIC_DBG_STRING                  ("**E100**") 

// packet and header sizes
#define NIC_MAX_PACKET_SIZE             1514
#define NIC_MIN_PACKET_SIZE             60
#define NIC_HEADER_SIZE                 14

// multicast list size                          
#define NIC_MAX_MCAST_LIST              32

// update the driver version number every time you release a new driver
// The high word is the major version. The low word is the minor version. 
#define NIC_VENDOR_DRIVER_VERSION       0x00010006

// NDIS version in use by the NIC driver. 
// The high byte is the major version. The low byte is the minor version. 
#ifdef NDIS51_MINIPORT
#define NIC_DRIVER_VERSION              0x0501
#else
#define NIC_DRIVER_VERSION              0x0500
#endif

// media type, we use ethernet, change if necessary
#define NIC_MEDIA_TYPE                  NdisMedium802_3

// interface type, we use PCI
#define NIC_INTERFACE_TYPE              NdisInterfacePci
#define NIC_INTERRUPT_MODE              NdisInterruptLevelSensitive 

// NIC PCI Device and vendor IDs 
#define NIC_PCI_DEVICE_ID               0x1229
#define NIC_PCI_VENDOR_ID               0x8086

// buffer size passed in NdisMQueryAdapterResources                            
// We should only need three adapter resources (IO, interrupt and memory),
// Some devices get extra resources, so have room for 10 resources 
#define NIC_RESOURCE_BUF_SIZE           (sizeof(NDIS_RESOURCE_LIST) + \
                                        (10*sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)))

// IO space length
#define NIC_MAP_IOSPACE_LENGTH          sizeof(CSR_STRUC)

// PCS config space including the Device Specific part of it/
#define NIC_PCI_E100_HDR_LENGTH         0xe2

// define some types for convenience
// TXCB_STRUC, RFD_STRUC and CSR_STRUC are hardware specific structures

// hardware TCB (Transmit Control Block) structure
typedef TXCB_STRUC                      HW_TCB; 
typedef PTXCB_STRUC                     PHW_TCB;

// hardware RFD (Receive Frame Descriptor) structure                         
typedef RFD_STRUC                       HW_RFD;  
typedef PRFD_STRUC                      PHW_RFD;               

// hardware CSR (Control Status Register) structure                         
typedef CSR_STRUC                       HW_CSR;                                       
typedef PCSR_STRUC                      PHW_CSR;                                      

// change to your company name instead of using Microsoft
#define NIC_VENDOR_DESC                 "Microsoft"

// number of TCBs per processor - min, default and max
#define NIC_MIN_TCBS                    1
#define NIC_DEF_TCBS                    32
#define NIC_MAX_TCBS                    64

// max number of physical fragments supported per TCB
#define NIC_MAX_PHYS_BUF_COUNT          8     

// number of RFDs - min, default and max
#define NIC_MIN_RFDS                    4
#define NIC_DEF_RFDS                    20
#define NIC_MAX_RFDS                    1024

// only grow the RFDs up to this number
#define NIC_MAX_GROW_RFDS               128 

// How many intervals before the RFD list is shrinked?
#define NIC_RFD_SHRINK_THRESHOLD        10

// local data buffer size (to copy send packet data into a local buffer)
#define NIC_BUFFER_SIZE                 1520

// max lookahead size
#define NIC_MAX_LOOKAHEAD               (NIC_MAX_PACKET_SIZE - NIC_HEADER_SIZE)

// max number of send packets the MiniportSendPackets function can accept                            
#define NIC_MAX_SEND_PACKETS            10

// supported filters
#define NIC_SUPPORTED_FILTERS (     \
    NDIS_PACKET_TYPE_DIRECTED       | \
    NDIS_PACKET_TYPE_MULTICAST      | \
    NDIS_PACKET_TYPE_BROADCAST      | \
    NDIS_PACKET_TYPE_PROMISCUOUS    | \
    NDIS_PACKET_TYPE_ALL_MULTICAST)

// Threshold for a remove 
#define NIC_HARDWARE_ERROR_THRESHOLD    5

// The CheckForHang intervals before we decide the send is stuck
#define NIC_SEND_HANG_THRESHOLD         5        

// NDIS_ERROR_CODE_ADAPTER_NOT_FOUND                                                     
#define ERRLOG_READ_PCI_SLOT_FAILED     0x00000101L
#define ERRLOG_WRITE_PCI_SLOT_FAILED    0x00000102L
#define ERRLOG_VENDOR_DEVICE_NOMATCH    0x00000103L

// NDIS_ERROR_CODE_ADAPTER_DISABLED
#define ERRLOG_BUS_MASTER_DISABLED      0x00000201L

// NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION
#define ERRLOG_INVALID_SPEED_DUPLEX     0x00000301L
#define ERRLOG_SET_SECONDARY_FAILED     0x00000302L

// NDIS_ERROR_CODE_OUT_OF_RESOURCES
#define ERRLOG_OUT_OF_MEMORY            0x00000401L
#define ERRLOG_OUT_OF_SHARED_MEMORY     0x00000402L
#define ERRLOG_OUT_OF_MAP_REGISTERS     0x00000403L
#define ERRLOG_OUT_OF_BUFFER_POOL       0x00000404L
#define ERRLOG_OUT_OF_NDIS_BUFFER       0x00000405L
#define ERRLOG_OUT_OF_PACKET_POOL       0x00000406L
#define ERRLOG_OUT_OF_NDIS_PACKET       0x00000407L
#define ERRLOG_OUT_OF_LOOKASIDE_MEMORY  0x00000408L

// NDIS_ERROR_CODE_HARDWARE_FAILURE
#define ERRLOG_SELFTEST_FAILED          0x00000501L
#define ERRLOG_INITIALIZE_ADAPTER       0x00000502L
#define ERRLOG_REMOVE_MINIPORT          0x00000503L

// NDIS_ERROR_CODE_RESOURCE_CONFLICT
#define ERRLOG_MAP_IO_SPACE             0x00000601L
#define ERRLOG_QUERY_ADAPTER_RESOURCES  0x00000602L
#define ERRLOG_NO_IO_RESOURCE           0x00000603L
#define ERRLOG_NO_INTERRUPT_RESOURCE    0x00000604L
#define ERRLOG_NO_MEMORY_RESOURCE       0x00000605L

// NIC specific macros                                        
#define NIC_RFD_GET_STATUS(_HwRfd) ((_HwRfd)->RfdCbHeader.CbStatus)
#define NIC_RFD_STATUS_COMPLETED(_Status) ((_Status) & RFD_STATUS_COMPLETE)
#define NIC_RFD_STATUS_SUCCESS(_Status) ((_Status) & RFD_STATUS_OK)
#define NIC_RFD_GET_PACKET_SIZE(_HwRfd) (((_HwRfd)->RfdActualCount) & RFD_ACT_COUNT_MASK)
#define NIC_RFD_VALID_ACTUALCOUNT(_HwRfd) ((((_HwRfd)->RfdActualCount) & (RFD_EOF_BIT | RFD_F_BIT)) == (RFD_EOF_BIT | RFD_F_BIT))

// Constants for various purposes of NdisStallExecution

#define NIC_DELAY_POST_RESET            20
// Wait 5 milliseconds for the self-test to complete
#define NIC_DELAY_POST_SELF_TEST_MS     5

                                      
// delay used for link detection to minimize the init time
// change this value to match your hardware 
#define NIC_LINK_DETECTION_DELAY        100




#endif  // _MP_DEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_dbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_dbg.h

Abstract:
    Debug definitions and macros

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#ifndef _MP_DBG_H
#define _MP_DBG_H

//
// Message verbosity: lower values indicate higher urgency
//
#define MP_OFF          0
#define MP_ERROR        1
#define MP_WARN         2
#define MP_TRACE        3
#define MP_INFO         4
#define MP_LOUD         5

// Define a macro so DbgPrint can work on win9x, 32-bit/64-bit NT's
#ifdef _WIN64
#define PTR_FORMAT      "%p"
#else
#define PTR_FORMAT      "%x"
#endif
                            
#if DBG

extern ULONG MPDebugLevel;

#define DBGPRINT(Level, Fmt) \
{ \
    if (Level <= MPDebugLevel) \
    { \
        DbgPrint(NIC_DBG_STRING); \
        DbgPrint Fmt; \
    } \
}

#define DBGPRINT_RAW(Level, Fmt) \
{ \
    if (Level <= MPDebugLevel) \
    { \
      DbgPrint Fmt; \
    } \
}

#define DBGPRINT_S(Status, Fmt) \
{ \
    ULONG dbglevel; \
    if(Status == NDIS_STATUS_SUCCESS || Status == NDIS_STATUS_PENDING) dbglevel = MP_TRACE; \
    else dbglevel = MP_ERROR; \
    DBGPRINT(dbglevel, Fmt); \
}

#define DBGPRINT_UNICODE(Level, UString) \
{ \
    if (Level <= MPDebugLevel) \
    { \
        DbgPrint(NIC_DBG_STRING); \
      mpDbgPrintUnicodeString(UString); \
   } \
}

#undef ASSERT
#define ASSERT(x) if(!(x)) { \
    DBGPRINT(MP_ERROR, ("Assertion failed: %s:%d %s\n", __FILE__, __LINE__, #x)); \
    DbgBreakPoint(); }

//
// The MP_ALLOCATION structure stores all info about MPAuditAllocMem
//
typedef struct _MP_ALLOCATION
{
    LIST_ENTRY              List;
    ULONG                   Signature;
    ULONG                   FileNumber;
    ULONG                   LineNumber;
    ULONG                   Size;
    PVOID                   *Location;   // where the returned pointer was put
    UINT                    Flags;
    union {
        ULONGLONG           Alignment;        
        UCHAR               UserData;
    };
} MP_ALLOCATION, *PMP_ALLOCATION;


NDIS_STATUS MPAuditAllocMem(
    PVOID                   *pPointer,
    UINT                    Size,
    UINT                    Flags,
    NDIS_PHYSICAL_ADDRESS   HighestAddr,    
    ULONG                   FileNumber,
    ULONG                   LineNumber);

NDIS_STATUS MPAuditAllocMemTag(
    PVOID       *pPointer,
    UINT        Size,
    ULONG       FileNumber,
    ULONG       LineNumber);

VOID MPAuditFreeMem(
    PVOID       Pointer,
    UINT        Size,
    UINT        Flags);

VOID mpDbgPrintUnicodeString(
    IN  PUNICODE_STRING UnicodeString);


VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );




#else   // !DBG

#define DBGPRINT(Level, Fmt)
#define DBGPRINT_RAW(Level, Fmt)
#define DBGPRINT_S(Status, Fmt)
#define DBGPRINT_UNICODE(Level, UString)
#define Dump(p,cb,fAddress,ulGroup)

#undef ASSERT
#define ASSERT(x)

#endif  // DBG

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif  // _MP_DBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_init.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_init.c

Abstract:
    This module contains miniport initialization related routines

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"

#if DBG
#define _FILENUMBER     'TINI'
#endif

typedef struct _MP_REG_ENTRY
{
    NDIS_STRING RegName;                // variable name text
    BOOLEAN     bRequired;              // 1 -> required, 0 -> optional
    UINT        FieldOffset;            // offset to MP_ADAPTER field
    UINT        FieldSize;              // size (in bytes) of the field
    UINT        Default;                // default value to use
    UINT        Min;                    // minimum value allowed
    UINT        Max;                    // maximum value allowed
} MP_REG_ENTRY, *PMP_REG_ENTRY;

MP_REG_ENTRY NICRegTable[] = {
// reg value name                           Offset in MP_ADAPTER            Field size                  Default Value           Min             Max
#if DBG                                                                                                                          
    {NDIS_STRING_CONST("Debug"),            0, MP_OFFSET(Debug),            MP_SIZE(Debug),             MP_WARN,                0,              0xffffffff},
#endif
    {NDIS_STRING_CONST("NumRfd"),           0, MP_OFFSET(NumRfd),           MP_SIZE(NumRfd),            32,                     NIC_MIN_RFDS,   NIC_MAX_RFDS},
    {NDIS_STRING_CONST("NumTcb"),           0, MP_OFFSET(NumTcb),           MP_SIZE(NumTcb),            NIC_DEF_TCBS,           1,              NIC_MAX_TCBS},
    {NDIS_STRING_CONST("NumCoalesce"),      0, MP_OFFSET(NumBuffers),       MP_SIZE(NumBuffers),        8,                      1,              32},
    {NDIS_STRING_CONST("PhyAddress"),       0, MP_OFFSET(PhyAddress),       MP_SIZE(PhyAddress),        0xFF,                   0,              0xFF},
    {NDIS_STRING_CONST("Connector"),        0, MP_OFFSET(Connector),        MP_SIZE(Connector),         0,                      0,              0x2},
    {NDIS_STRING_CONST("TxFifo"),           0, MP_OFFSET(AiTxFifo),         MP_SIZE(AiTxFifo),          DEFAULT_TX_FIFO_LIMIT,  0,              15},
    {NDIS_STRING_CONST("RxFifo"),           0, MP_OFFSET(AiRxFifo),         MP_SIZE(AiRxFifo),          DEFAULT_RX_FIFO_LIMIT,  0,              15},
    {NDIS_STRING_CONST("TxDmaCount"),       0, MP_OFFSET(AiTxDmaCount),     MP_SIZE(AiTxDmaCount),      0,                      0,              63},
    {NDIS_STRING_CONST("RxDmaCount"),       0, MP_OFFSET(AiRxDmaCount),     MP_SIZE(AiRxDmaCount),      0,                      0,              63},
    {NDIS_STRING_CONST("UnderrunRetry"),    0, MP_OFFSET(AiUnderrunRetry),  MP_SIZE(AiUnderrunRetry),   DEFAULT_UNDERRUN_RETRY, 0,              3},
    {NDIS_STRING_CONST("Threshold"),        0, MP_OFFSET(AiThreshold),      MP_SIZE(AiThreshold),       200,                    0,              200},
    {NDIS_STRING_CONST("MWIEnable"),        0, MP_OFFSET(MWIEnable),        MP_SIZE(MWIEnable),         1,                      0,              1},
    {NDIS_STRING_CONST("Congest"),          0, MP_OFFSET(Congest),          MP_SIZE(Congest),           0,                      0,              0x1},
    {NDIS_STRING_CONST("SpeedDuplex"),      0, MP_OFFSET(SpeedDuplex),      MP_SIZE(SpeedDuplex),       0,                      0,              4}
};

#define NIC_NUM_REG_PARAMS (sizeof (NICRegTable) / sizeof(MP_REG_ENTRY))

#if LBFO
NDIS_STRING strBundleId = NDIS_STRING_CONST("BundleId");        
#endif


NDIS_STATUS MpFindAdapter(
    IN  PMP_ADAPTER  Adapter,
    IN  NDIS_HANDLE  WrapperConfigurationContext
    )
/*++
Routine Description:

    Find the adapter and get all the assigned resources

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_ADAPTER_NOT_FOUND (event is logged as well)    

--*/    
{

#define NIC_PCI_E100_HDR_LENGTH 0xe2
    
    NDIS_STATUS         Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
    ULONG               ErrorCode;
    ULONG               ErrorValue;

    ULONG               ulResult;
    UCHAR               buffer[NIC_PCI_E100_HDR_LENGTH ];
    PPCI_COMMON_CONFIG  pPciConfig = (PPCI_COMMON_CONFIG) buffer;
    USHORT              usPciCommand;
       
    UCHAR               resBuf[NIC_RESOURCE_BUF_SIZE];
    PNDIS_RESOURCE_LIST resList = (PNDIS_RESOURCE_LIST)resBuf;
    UINT                bufSize = NIC_RESOURCE_BUF_SIZE;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDesc;
    ULONG               index;
    BOOLEAN             bResPort = FALSE, bResInterrupt = FALSE, bResMemory = FALSE;

    DBGPRINT(MP_TRACE, ("---> MpFindAdapter\n"));

    do
    {
        //
        // Find our adapter - read in the device and vendor IDs
        //
        ulResult = NdisReadPciSlotInformation(
                       Adapter->AdapterHandle,
                       0,          // not used
                       FIELD_OFFSET(PCI_COMMON_CONFIG, VendorID),
                       buffer,
                       NIC_PCI_E100_HDR_LENGTH );

        if (ulResult != NIC_PCI_E100_HDR_LENGTH )
        {
            DBGPRINT(MP_ERROR, 
                ("NdisReadPciSlotInformation (PCI_COMMON_CONFIG) ulResult=%d\n", ulResult));

            ErrorCode = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
            ErrorValue = ERRLOG_READ_PCI_SLOT_FAILED;
                   
            break;
        }

        //     
        // Right type of adapter?
        //
        if (pPciConfig->VendorID != NIC_PCI_VENDOR_ID || 
            pPciConfig->DeviceID != NIC_PCI_DEVICE_ID)
        {
            DBGPRINT(MP_ERROR, ("VendorID/DeviceID don't match - %x/%x\n", 
                pPciConfig->VendorID, pPciConfig->DeviceID));

            ErrorCode = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
            ErrorValue = ERRLOG_VENDOR_DEVICE_NOMATCH;

            break;
        }

        DBGPRINT(MP_INFO, ("Adapter is found - VendorID/DeviceID=%x/%x\n", 
            pPciConfig->VendorID, pPciConfig->DeviceID));

        // save info from config space
        Adapter->RevsionID = pPciConfig->RevisionID;
        Adapter->SubVendorID = pPciConfig->u.type0.SubVendorID;
        Adapter->SubSystemID = pPciConfig->u.type0.SubSystemID;
        
        MpExtractPMInfoFromPciSpace (Adapter, (PUCHAR)pPciConfig);
        
        // --- HW_START   

        usPciCommand = pPciConfig->Command;
        if ((usPciCommand & PCI_ENABLE_WRITE_AND_INVALIDATE) && (Adapter->MWIEnable))
            Adapter->MWIEnable = TRUE;
        else
            Adapter->MWIEnable = FALSE;

        // Enable bus matering if it isn't enabled by the BIOS
        if (!(usPciCommand & PCI_ENABLE_BUS_MASTER))
        {
            DBGPRINT(MP_WARN, ("Bus master is not enabled by BIOS! usPciCommand=%x\n", 
                usPciCommand));

            usPciCommand |= CMD_BUS_MASTER;

            ulResult = NdisWritePciSlotInformation(
                           Adapter->AdapterHandle,
                           0,
                           FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                           &usPciCommand,
                           sizeof(USHORT));
            if (ulResult != sizeof(USHORT))
            {
                DBGPRINT(MP_ERROR, 
                    ("NdisWritePciSlotInformation (Command) ulResult=%d\n", ulResult));

                ErrorCode = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
                ErrorValue = ERRLOG_WRITE_PCI_SLOT_FAILED;

                break;
            }

            ulResult = NdisReadPciSlotInformation(
                           Adapter->AdapterHandle,
                           0,
                           FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                           &usPciCommand,
                           sizeof(USHORT));
            if (ulResult != sizeof(USHORT))
            {
                DBGPRINT(MP_ERROR, 
                    ("NdisReadPciSlotInformation (Command) ulResult=%d\n", ulResult));

                ErrorCode = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
                ErrorValue = ERRLOG_READ_PCI_SLOT_FAILED;

                break;
            }

            if (!(usPciCommand & PCI_ENABLE_BUS_MASTER))
            {
                DBGPRINT(MP_ERROR, ("Failed to enable bus master! usPciCommand=%x\n", 
                    usPciCommand));

                ErrorCode = NDIS_ERROR_CODE_ADAPTER_DISABLED;
                ErrorValue = ERRLOG_BUS_MASTER_DISABLED;

                break;
            }
        }

        DBGPRINT(MP_INFO, ("Bus master is enabled. usPciCommand=%x\n", usPciCommand));

        // --- HW_END

        //     
        // Adapter is found. Now get the assigned resources
        //
        NdisMQueryAdapterResources(
            &Status, 
            WrapperConfigurationContext, 
            resList, 
            &bufSize);
    
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorCode = NDIS_ERROR_CODE_RESOURCE_CONFLICT;
            ErrorValue = ERRLOG_QUERY_ADAPTER_RESOURCES;
            break;
        }

        for (index=0; index < resList->Count; index++)
        {
            pResDesc = &resList->PartialDescriptors[index];

            switch(pResDesc->Type)
            {
                case CmResourceTypePort:
                    Adapter->IoBaseAddress = NdisGetPhysicalAddressLow(pResDesc->u.Port.Start); 
                    Adapter->IoRange = pResDesc->u.Port.Length;
                    bResPort = TRUE;

                    DBGPRINT(MP_INFO, ("IoBaseAddress = 0x%x\n", Adapter->IoBaseAddress));
                    DBGPRINT(MP_INFO, ("IoRange = x%x\n", Adapter->IoRange));
                    break;

                case CmResourceTypeInterrupt:
                    Adapter->InterruptLevel = pResDesc->u.Interrupt.Level;
                    bResInterrupt = TRUE;
                    
                    DBGPRINT(MP_INFO, ("InterruptLevel = x%x\n", Adapter->InterruptLevel));
                    break;

                case CmResourceTypeMemory:
                    // Our CSR memory space should be 0x1000, other memory is for 
                    // flash address, a boot ROM address, etc.
                    if (pResDesc->u.Memory.Length == 0x1000)
                    {
                        Adapter->MemPhysAddress = pResDesc->u.Memory.Start;
                        bResMemory = TRUE;
                        
                        DBGPRINT(MP_INFO, 
                            ("MemPhysAddress(Low) = 0x%0x\n", NdisGetPhysicalAddressLow(Adapter->MemPhysAddress)));
                        DBGPRINT(MP_INFO, 
                            ("MemPhysAddress(High) = 0x%0x\n", NdisGetPhysicalAddressHigh(Adapter->MemPhysAddress)));
                    }
                    break;
            }
        } 
        
        if (!bResPort || !bResInterrupt || !bResMemory)
        {
            Status = NDIS_STATUS_RESOURCE_CONFLICT;
            ErrorCode = NDIS_ERROR_CODE_RESOURCE_CONFLICT;
            
            if (!bResPort)
            {
                ErrorValue = ERRLOG_NO_IO_RESOURCE;
            }
            else if (!bResInterrupt)
            {
                ErrorValue = ERRLOG_NO_INTERRUPT_RESOURCE;
            }
            else 
            {
                ErrorValue = ERRLOG_NO_MEMORY_RESOURCE;
            }
            
            break;
        }
        
        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            ErrorCode,
            1,
            ErrorValue);
    }

    DBGPRINT_S(Status, ("<--- MpFindAdapter, Status=%x\n", Status));

    return Status;

}

NDIS_STATUS NICReadAdapterInfo(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Read the mac addresss from the adapter

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_ADDRESS

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    USHORT          usValue; 
    int             i;

    DBGPRINT(MP_TRACE, ("--> NICReadAdapterInfo\n"));

    Adapter->EepromAddressSize = 
        GetEEpromAddressSize(GetEEpromSize(Adapter->PortOffset));
    DBGPRINT(MP_WARN, ("EepromAddressSize = %d\n", Adapter->EepromAddressSize));
        
               
    // Read node address from the EEPROM
    for (i=0; i<6; i += 2)
    {
        usValue = ReadEEprom(Adapter->PortOffset,
                      (USHORT)(EEPROM_NODE_ADDRESS_BYTE_0 + (i/2)),
                      Adapter->EepromAddressSize);

        *((PUSHORT)(&Adapter->PermanentAddress[i])) = usValue;
    }

    DBGPRINT(MP_INFO, ("Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n", 
        Adapter->PermanentAddress[0], Adapter->PermanentAddress[1], 
        Adapter->PermanentAddress[2], Adapter->PermanentAddress[3], 
        Adapter->PermanentAddress[4], Adapter->PermanentAddress[5]));

    if (ETH_IS_MULTICAST(Adapter->PermanentAddress) || 
        ETH_IS_BROADCAST(Adapter->PermanentAddress))
    {
        DBGPRINT(MP_ERROR, ("Permanent address is invalid\n")); 

        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_NETWORK_ADDRESS,
            0);
        Status = NDIS_STATUS_INVALID_ADDRESS;         
    }
    else
    {
        if (!Adapter->bOverrideAddress)
        {
            ETH_COPY_NETWORK_ADDRESS(Adapter->CurrentAddress, Adapter->PermanentAddress);
        }

        DBGPRINT(MP_INFO, ("Current Address = %02x-%02x-%02x-%02x-%02x-%02x\n", 
            Adapter->CurrentAddress[0], Adapter->CurrentAddress[1],
            Adapter->CurrentAddress[2], Adapter->CurrentAddress[3],
            Adapter->CurrentAddress[4], Adapter->CurrentAddress[5]));
    }

    DBGPRINT_S(Status, ("<-- NICReadAdapterInfo, Status=%x\n", Status));

    return Status;
}

NDIS_STATUS MpAllocAdapterBlock(
    OUT PMP_ADAPTER     *pAdapter)
/*++
Routine Description:

    Allocate MP_ADAPTER data block and do some initialization

Arguments:

    Adapter     Pointer to receive pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE

--*/    
{
    PMP_ADAPTER     Adapter;
    NDIS_HANDLE     PacketPoolHandle;
    NDIS_HANDLE     BufferPoolHandle;
    PNDIS_PACKET    Packet;
    PNDIS_BUFFER    Buffer;
    NDIS_STATUS     Status;
    LONG            index;

    DBGPRINT(MP_TRACE, ("--> NICAllocAdapter\n"));

    *pAdapter = NULL;

    do
    {
        // Allocate MP_ADAPTER block
        Status = MP_ALLOCMEMTAG(&Adapter, sizeof(MP_ADAPTER));
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MP_ERROR, ("Failed to allocate memory - ADAPTER\n"));
            break;
        }

        // Clean up the memory block
        NdisZeroMemory(Adapter, sizeof(MP_ADAPTER));

        MP_INC_REF(Adapter);

        // Init lists, spinlocks, etc.
        InitializeQueueHeader(&Adapter->SendWaitQueue);
        InitializeQueueHeader(&Adapter->SendCancelQueue);

        InitializeListHead(&Adapter->RecvList);
        InitializeListHead(&Adapter->RecvPendList);
        InitializeListHead(&Adapter->PoMgmt.PatternList);

        NdisInitializeEvent(&Adapter->ExitEvent);
        NdisInitializeEvent(&Adapter->AllPacketsReturnedEvent);
        MP_INC_RCV_REF(Adapter);

        NdisAllocateSpinLock(&Adapter->Lock);
        NdisAllocateSpinLock(&Adapter->SendLock);
        NdisAllocateSpinLock(&Adapter->RcvLock);

    } while (FALSE);

    *pAdapter = Adapter;

    DBGPRINT_S(Status, ("<-- NICAllocAdapter, Status=%x\n", Status));

    return Status;

}

VOID MpFreeAdapter(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Free all the resources and MP_ADAPTER data block

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None                                                    

--*/    
{
    PMP_TXBUF       pMpTxBuf;
    PMP_RFD         pMpRfd;

    DBGPRINT(MP_TRACE, ("--> NICFreeAdapter\n"));

    // No active and waiting sends
    ASSERT(Adapter->nBusySend == 0);
    ASSERT(Adapter->nWaitSend == 0);
    ASSERT(IsQueueEmpty(&Adapter->SendWaitQueue));
    ASSERT(IsQueueEmpty(&Adapter->SendCancelQueue));

    // No other pending operations
    ASSERT(IsListEmpty(&Adapter->RecvPendList));
    ASSERT(Adapter->bAllocNewRfd == FALSE);
    ASSERT(!MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION));
    ASSERT(MP_GET_REF(Adapter) == 0);

    //
    // Free hardware resources
    //      
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE))
    {
        NdisMDeregisterInterrupt(&Adapter->Interrupt);
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE);
    }

    if (Adapter->CSRAddress)
    {
        NdisMUnmapIoSpace(
            Adapter->AdapterHandle,
            Adapter->CSRAddress,
            NIC_MAP_IOSPACE_LENGTH);
        Adapter->CSRAddress = NULL;
    }

    if (Adapter->PortOffset)
    {
        NdisMDeregisterIoPortRange(
            Adapter->AdapterHandle,
            Adapter->IoBaseAddress,
            Adapter->IoRange,
            Adapter->PortOffset);
        Adapter->PortOffset = NULL;
    }

    //               
    // Free RECV memory/NDIS buffer/NDIS packets/shared memory
    //
    ASSERT(Adapter->nReadyRecv == Adapter->CurrNumRfd);

    while (!IsListEmpty(&Adapter->RecvList))
    {
        pMpRfd = (PMP_RFD)RemoveHeadList(&Adapter->RecvList);
        NICFreeRfd(Adapter, pMpRfd);
    }

    // Free receive buffer pool
    if (Adapter->RecvBufferPool)
    {
        NdisFreeBufferPool(Adapter->RecvBufferPool);
        Adapter->RecvBufferPool = NULL;
    }

    // Free receive packet pool
    if (Adapter->RecvPacketPool)
    {
        NdisFreePacketPool(Adapter->RecvPacketPool);
        Adapter->RecvPacketPool = NULL;
    }
    
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE))
    {
        NdisDeleteNPagedLookasideList(&Adapter->RecvLookaside);
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE);
    }
            
    //               
    // Free SEND memory/NDIS buffer/NDIS packets/shared memory
    //
    while (!IsSListEmpty(&Adapter->SendBufList))
    {
        pMpTxBuf = (PMP_TXBUF)PopEntryList(&Adapter->SendBufList);
        ASSERT(pMpTxBuf);

        // Free the shared memory associated with each MP_TXBUF
        if (pMpTxBuf->AllocVa)
        {
            NdisMFreeSharedMemory(
                Adapter->AdapterHandle,
                pMpTxBuf->AllocSize,
                TRUE,
                pMpTxBuf->AllocVa,
                pMpTxBuf->AllocPa);
            pMpTxBuf->AllocVa = NULL;      
        }

        // Free the NDIS buffer
        if (pMpTxBuf->NdisBuffer)
        {
            NdisFreeBuffer(pMpTxBuf->NdisBuffer);
            pMpTxBuf->NdisBuffer = NULL;
        }
    }

    // Free the send buffer pool
    if (Adapter->SendBufferPool)
    {
        NdisFreeBufferPool(Adapter->SendBufferPool);
        Adapter->SendBufferPool = NULL;
    }
    
    // Free the memory for MP_TXBUF structures
    if (Adapter->MpTxBufMem)
    {
        MP_FREEMEM(Adapter->MpTxBufMem, Adapter->MpTxBufMemSize, 0);
        Adapter->MpTxBufMem = NULL;
    }

    // Free the shared memory for HW_TCB structures
    if (Adapter->HwSendMemAllocVa)
    {
        NdisMFreeSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwSendMemAllocSize,
            FALSE,
            Adapter->HwSendMemAllocVa,
            Adapter->HwSendMemAllocPa);
        Adapter->HwSendMemAllocVa = NULL;
    }

    // Free the shared memory for other command data structures                       
    if (Adapter->HwMiscMemAllocVa)
    {
        NdisMFreeSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwMiscMemAllocSize,
            FALSE,
            Adapter->HwMiscMemAllocVa,
            Adapter->HwMiscMemAllocPa);
        Adapter->HwMiscMemAllocVa = NULL;
    }


    // Free the memory for MP_TCB structures
    if (Adapter->MpTcbMem)
    {
        MP_FREEMEM(Adapter->MpTcbMem, Adapter->MpTcbMemSize, 0);
        Adapter->MpTcbMem = NULL;
    }

    // Free map registers. This must be after all the shared memory is freed
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER))
    {
        NdisMFreeMapRegisters(Adapter->AdapterHandle);
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER);
    }

    //Free all the wake up patterns on this adapter
    MPRemoveAllWakeUpPatterns(Adapter);
    
    NdisFreeSpinLock(&Adapter->Lock);

#if LBFO
    if (Adapter->BundleId.MaximumLength)
    {
        MP_FREE_NDIS_STRING(&Adapter->BundleId);
    }
#endif

#if OFFLOAD    
    // Free the shared memory for offload tasks
    if (Adapter->OffloadSharedMem.StartVa)
    {
        NdisMFreeSharedMemory(
                Adapter->AdapterHandle,
                Adapter->OffloadSharedMemSize,
                FALSE,
                Adapter->OffloadSharedMem.StartVa,
                Adapter->OffloadSharedMem.PhyAddr);
        Adapter->OffloadSharedMem.StartVa = NULL;
    }

#endif

    MP_FREEMEM(Adapter, sizeof(MP_ADAPTER), 0);  

    DBGPRINT(MP_TRACE, ("<-- NICFreeAdapter\n"));
}

NDIS_STATUS NICReadRegParameters(
    IN  PMP_ADAPTER     Adapter,
    IN  NDIS_HANDLE     WrapperConfigurationContext)
/*++
Routine Description:

    Read the following from the registry
    1. All the parameters
    2. NetworkAddres
    3. LBFO - BundleId

Arguments:

    Adapter                         Pointer to our adapter
    WrapperConfigurationContext     For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_RESOURCES                                       

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    NDIS_HANDLE     ConfigurationHandle;
    PMP_REG_ENTRY   pRegEntry;
    UINT            i;
    UINT            value;
    PUCHAR          pointer;
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;
    PUCHAR          NetworkAddress;
    UINT            Length;

    DBGPRINT(MP_TRACE, ("--> NICReadRegParameters\n"));

    // Open the registry for this adapter
    NdisOpenConfiguration(
        &Status,
        &ConfigurationHandle,
        WrapperConfigurationContext);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(MP_ERROR, ("NdisOpenConfiguration failed\n"));
        DBGPRINT_S(Status, ("<-- NICReadRegParameters, Status=%x\n", Status));
        return Status;
    }

    // read all the registry values 
    for (i = 0, pRegEntry = NICRegTable; i < NIC_NUM_REG_PARAMS; i++, pRegEntry++)
    {
        pointer = (PUCHAR) Adapter + pRegEntry->FieldOffset;

        DBGPRINT_UNICODE(MP_INFO, &pRegEntry->RegName);

        // Get the configuration value for a specific parameter.  Under NT the
        // parameters are all read in as DWORDs.
        NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigurationHandle,
            &pRegEntry->RegName,
            NdisParameterInteger);

        // If the parameter was present, then check its value for validity.
        if (Status == NDIS_STATUS_SUCCESS)
        {
            // Check that param value is not too small or too large
            if (ReturnedValue->ParameterData.IntegerData < pRegEntry->Min ||
                ReturnedValue->ParameterData.IntegerData > pRegEntry->Max)
            {
                value = pRegEntry->Default;
            }
            else
            {
                value = ReturnedValue->ParameterData.IntegerData;
            }

            DBGPRINT_RAW(MP_INFO, ("= 0x%x\n", value));
        }
        else if (pRegEntry->bRequired)
        {
            DBGPRINT_RAW(MP_ERROR, (" -- failed\n"));

            ASSERT(FALSE);

            Status = NDIS_STATUS_FAILURE;
            break;
        }
        else
        {
            value = pRegEntry->Default;
            DBGPRINT_RAW(MP_INFO, ("= 0x%x (default)\n", value));
            Status = NDIS_STATUS_SUCCESS;
        }

        // Store the value in the adapter structure.
        switch(pRegEntry->FieldSize)
        {
            case 1:
                *((PUCHAR) pointer) = (UCHAR) value;
                break;

            case 2:
                *((PUSHORT) pointer) = (USHORT) value;
                break;

            case 4:
                *((PULONG) pointer) = (ULONG) value;
                break;

            default:
                DBGPRINT(MP_ERROR, ("Bogus field size %d\n", pRegEntry->FieldSize));
                break;
        }
    }

    // Read NetworkAddress registry value 
    // Use it as the current address if any
    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisReadNetworkAddress(
            &Status,
            &NetworkAddress,
            &Length,
            ConfigurationHandle);

        // If there is a NetworkAddress override in registry, use it 
        if ((Status == NDIS_STATUS_SUCCESS) && (Length == ETH_LENGTH_OF_ADDRESS))
        {
            if (ETH_IS_MULTICAST(NetworkAddress) || ETH_IS_BROADCAST(NetworkAddress))
            {
                DBGPRINT(MP_ERROR, 
                    ("Overriding NetworkAddress is invalid - %02x-%02x-%02x-%02x-%02x-%02x\n", 
                    NetworkAddress[0], NetworkAddress[1], NetworkAddress[2],
                    NetworkAddress[3], NetworkAddress[4], NetworkAddress[5]));
            }
            else
            {
                ETH_COPY_NETWORK_ADDRESS(Adapter->CurrentAddress, NetworkAddress);
                Adapter->bOverrideAddress = TRUE;
            }
        }

        Status = NDIS_STATUS_SUCCESS;
    }

#if LBFO
    if (Status == NDIS_STATUS_SUCCESS)
    {
        // Read BundleIdentifier string
        NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigurationHandle,
            &strBundleId,
            NdisParameterString);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            ASSERT(ReturnedValue->ParameterType == NdisParameterString);

            if (ReturnedValue->ParameterData.StringData.Length !=0)
            {
                Status = MP_ALLOCMEMTAG(&Adapter->BundleId.Buffer, 
                             ReturnedValue->ParameterData.StringData.Length + sizeof(WCHAR));
                if (Status == NDIS_STATUS_SUCCESS)
                {
                    Adapter->BundleId.MaximumLength = 
                        ReturnedValue->ParameterData.StringData.Length + sizeof(WCHAR);
                    NdisUpcaseUnicodeString(
                        &Adapter->BundleId, 
                        &ReturnedValue->ParameterData.StringData);
                }
                else
                {
                    DBGPRINT(MP_ERROR, ("Failed to allocate memory - BundleIdentifier\n"));
                }
            }
        }
        else
        {
            // This parameter is optional, set status to SUCCESS
            Status = NDIS_STATUS_SUCCESS;
        }
    }
#endif   

    // Close the registry
    NdisCloseConfiguration(ConfigurationHandle);
    
    // Decode SpeedDuplex
    if (Status == NDIS_STATUS_SUCCESS && Adapter->SpeedDuplex)
    {
        switch(Adapter->SpeedDuplex)
        {
            case 1:
            Adapter->AiTempSpeed = 10; Adapter->AiForceDpx = 1;
            break;
            
            case 2:
            Adapter->AiTempSpeed = 10; Adapter->AiForceDpx = 2;
            break;
            
            case 3:
            Adapter->AiTempSpeed = 100; Adapter->AiForceDpx = 1;
            break;
            
            case 4:
            Adapter->AiTempSpeed = 100; Adapter->AiForceDpx = 2;
            break;
        }
    
    }

    DBGPRINT_S(Status, ("<-- NICReadRegParameters, Status=%x\n", Status));

    return Status;
}

NDIS_STATUS NICAllocAdapterMemory(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Allocate all the memory blocks for send, receive and others

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_RESOURCES

--*/    
{
    NDIS_STATUS     Status;
    PMP_TCB         pMpTCB;
    PMP_TXBUF       pMpTxbuf;
    PUCHAR          pMem;
    ULONG           MemPhys;
    LONG            index;
    LONG            MapRegisterCount;
    ULONG           ErrorValue = 0;
    UINT            MaxNumBuffers;
#if OFFLOAD
    
    BOOLEAN         OffloadSharedMemSuccess = FALSE;
    UINT            i;
#endif
    
    DBGPRINT(MP_TRACE, ("--> NICAllocMemory\n"));

    DBGPRINT(MP_INFO, ("NumTcb=%d\n", Adapter->NumTcb));
    Adapter->NumTbd = Adapter->NumTcb * NIC_MAX_PHYS_BUF_COUNT;

    do
    {
        //
        // Try to use the ScatterGather method first, this is the preferred way
        // Only use map registers if we can't do scatter gather (e.g. on win9x)
#if OFFLOAD          
        Status = NdisMInitializeScatterGatherDma(
                     Adapter->AdapterHandle,
                     FALSE,
                     LARGE_SEND_OFFLOAD_SIZE);
#else
        Status = NdisMInitializeScatterGatherDma(
                     Adapter->AdapterHandle,
                     FALSE,
                     NIC_MAX_PACKET_SIZE);
#endif        
        
        if (Status == NDIS_STATUS_SUCCESS)
        {
            MP_SET_FLAG(Adapter, fMP_ADAPTER_SCATTER_GATHER);
        }
        else
        {
            DBGPRINT(MP_WARN, ("Failed to init ScatterGather DMA, allocate map registers\n"));

            // We should limit the totoal map registers needed to 32            
            Adapter->NumTcb = 32 / NIC_MAX_PHYS_BUF_COUNT;  
            Adapter->NumTbd = Adapter->NumTcb * NIC_MAX_PHYS_BUF_COUNT;
            DBGPRINT(MP_WARN, ("NumTcb is reduced to %d", Adapter->NumTcb));

            while (Adapter->NumTcb > 0)
            {
                Status = NdisMAllocateMapRegisters(
                             Adapter->AdapterHandle,
                             0,
                             NDIS_DMA_32BITS,
                             Adapter->NumTbd,
                             NIC_MAX_PACKET_SIZE);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    break;   
                }

                // Reduce NumTcb and try again          
                Adapter->NumTcb--;
                DBGPRINT(MP_WARN, ("NumTcb is reduced to %d", Adapter->NumTcb));
                Adapter->NumTbd = Adapter->NumTcb * NIC_MAX_PHYS_BUF_COUNT;
            }

            if (Status == NDIS_STATUS_SUCCESS)
            {
                MP_SET_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER);
            }
            else
            {
                ErrorValue = ERRLOG_OUT_OF_MAP_REGISTERS;
                DBGPRINT(MP_ERROR, ("Failed to allocate map registers\n"));
                break;   
            }
        }

        //
        // Send + Misc
        //
        //
        // Allocate MP_TCB's
        // 
        Adapter->MpTcbMemSize = Adapter->NumTcb * sizeof(MP_TCB);
        Status = MP_ALLOCMEMTAG(&pMem, Adapter->MpTcbMemSize);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate MP_TCB's\n"));
            break;
        }
        NdisZeroMemory(pMem, Adapter->MpTcbMemSize);
        Adapter->MpTcbMem = pMem;
        //
        // Now the driver needs to allocate send buffer pool, the number 
        // of send buffers the driver needs is the larger one of Adapter->NumBuffer  
        // and Adapter->NumTcb.
        //
        MaxNumBuffers = Adapter->NumBuffers > Adapter->NumTcb ? Adapter->NumBuffers: Adapter->NumTcb;
        NdisAllocateBufferPool(
            &Status,
            &Adapter->SendBufferPool,
            MaxNumBuffers);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_BUFFER_POOL;
            DBGPRINT(MP_ERROR, ("Failed to allocate send buffer pool\n"));
            break;
        }

        // Allocate send buffers
        Adapter->MpTxBufMemSize = Adapter->NumBuffers * sizeof(MP_TXBUF);
        Status = MP_ALLOCMEMTAG(&pMem, Adapter->MpTxBufMemSize);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate MP_TXBUF's\n"));
            break;
        }
        NdisZeroMemory(pMem, Adapter->MpTxBufMemSize);
        Adapter->MpTxBufMem = pMem;

        pMpTxbuf = (PMP_TXBUF) pMem;         

    //
    // NdisMGetDmaAlignment is provided in XP (WINVER=0x0501) and higher
    // if you need to write a driver that runs on older versions of Windows
    // you need to compile with older versions of DDK which have WINVER < 0x0501
    // such as W2K DDK.
    //
#if (WINVER < 0x0501)
        Adapter->CacheFillSize = NdisGetCacheFillSize();
#else
        Adapter->CacheFillSize = NdisMGetDmaAlignment(Adapter->AdapterHandle);
#endif
        DBGPRINT(MP_INFO, ("CacheFillSize=%d\n", Adapter->CacheFillSize));

        for (index = 0; index < Adapter->NumBuffers; index++)
        {
            pMpTxbuf->AllocSize = NIC_MAX_PACKET_SIZE + Adapter->CacheFillSize;
            pMpTxbuf->BufferSize = NIC_MAX_PACKET_SIZE;

            NdisMAllocateSharedMemory(
                Adapter->AdapterHandle,
                pMpTxbuf->AllocSize,
                TRUE,                           // CACHED
                &pMpTxbuf->AllocVa,  
                &pMpTxbuf->AllocPa);

            if (!pMpTxbuf->AllocVa)
            {
                ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
                DBGPRINT(MP_ERROR, ("Failed to allocate a big buffer\n"));
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            // Align the buffer on the cache line boundary
            pMpTxbuf->pBuffer = MP_ALIGNMEM(pMpTxbuf->AllocVa, Adapter->CacheFillSize);
            pMpTxbuf->BufferPa.QuadPart = MP_ALIGNMEM_PA(pMpTxbuf->AllocPa, Adapter->CacheFillSize);

            NdisAllocateBuffer(
                &Status,
                &pMpTxbuf->NdisBuffer,
                Adapter->SendBufferPool,
                pMpTxbuf->pBuffer,
                pMpTxbuf->BufferSize);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                ErrorValue = ERRLOG_OUT_OF_NDIS_BUFFER;
                DBGPRINT(MP_ERROR, ("Failed to allocate NDIS buffer for a big buffer\n"));

                NdisMFreeSharedMemory(
                    Adapter->AdapterHandle,
                    pMpTxbuf->AllocSize,
                    TRUE,                           // CACHED
                    pMpTxbuf->AllocVa,   
                    pMpTxbuf->AllocPa);

                break;
            }

            PushEntryList(&Adapter->SendBufList, &pMpTxbuf->SList);

            pMpTxbuf++;
        }

        if (Status != NDIS_STATUS_SUCCESS) break;

        // HW_START

        // Allocate shared memory for send
        Adapter->HwSendMemAllocSize = Adapter->NumTcb * (sizeof(TXCB_STRUC) + 
                                          NIC_MAX_PHYS_BUF_COUNT * sizeof(TBD_STRUC));

        NdisMAllocateSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwSendMemAllocSize,
            FALSE,
            (PVOID) &Adapter->HwSendMemAllocVa,
            &Adapter->HwSendMemAllocPa);

        if (!Adapter->HwSendMemAllocVa)
        {
            ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate send memory\n"));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(Adapter->HwSendMemAllocVa, Adapter->HwSendMemAllocSize);

        // Allocate shared memory for other uses
        Adapter->HwMiscMemAllocSize =
            sizeof(SELF_TEST_STRUC) + ALIGN_16 +
            sizeof(DUMP_AREA_STRUC) + ALIGN_16 +
            sizeof(NON_TRANSMIT_CB) + ALIGN_16 +
            sizeof(ERR_COUNT_STRUC) + ALIGN_16;
        
        // Allocate the shared memory for the command block data structures.
        NdisMAllocateSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwMiscMemAllocSize,
            FALSE,
            (PVOID *) &Adapter->HwMiscMemAllocVa,
            &Adapter->HwMiscMemAllocPa);
        if (!Adapter->HwMiscMemAllocVa)
        {
            ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate misc memory\n"));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(Adapter->HwMiscMemAllocVa, Adapter->HwMiscMemAllocSize);

        pMem = Adapter->HwMiscMemAllocVa; 
        MemPhys = NdisGetPhysicalAddressLow(Adapter->HwMiscMemAllocPa);

        Adapter->SelfTest = (PSELF_TEST_STRUC)MP_ALIGNMEM(pMem, ALIGN_16);
        Adapter->SelfTestPhys = MP_ALIGNMEM_PHYS(MemPhys, ALIGN_16);
        pMem = (PUCHAR)Adapter->SelfTest + sizeof(SELF_TEST_STRUC);
        MemPhys = Adapter->SelfTestPhys + sizeof(SELF_TEST_STRUC);

        Adapter->NonTxCmdBlock = (PNON_TRANSMIT_CB)MP_ALIGNMEM(pMem, ALIGN_16);
        Adapter->NonTxCmdBlockPhys = MP_ALIGNMEM_PHYS(MemPhys, ALIGN_16);
        pMem = (PUCHAR)Adapter->NonTxCmdBlock + sizeof(NON_TRANSMIT_CB);
        MemPhys = Adapter->NonTxCmdBlockPhys + sizeof(NON_TRANSMIT_CB);

        Adapter->DumpSpace = (PDUMP_AREA_STRUC)MP_ALIGNMEM(pMem, ALIGN_16);
        Adapter->DumpSpacePhys = MP_ALIGNMEM_PHYS(MemPhys, ALIGN_16);
        pMem = (PUCHAR)Adapter->DumpSpace + sizeof(DUMP_AREA_STRUC);
        MemPhys = Adapter->DumpSpacePhys + sizeof(DUMP_AREA_STRUC);

        Adapter->StatsCounters = (PERR_COUNT_STRUC)MP_ALIGNMEM(pMem, ALIGN_16);
        Adapter->StatsCounterPhys = MP_ALIGNMEM_PHYS(MemPhys, ALIGN_16);

        // HW_END

        //
        // Recv
        //

        NdisInitializeNPagedLookasideList(
            &Adapter->RecvLookaside,
            NULL,
            NULL,
            0,
            sizeof(MP_RFD),
            NIC_TAG, 
            0);

        MP_SET_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE);

        // set the max number of RFDs
        // disable the RFD grow/shrink scheme if user specifies a NumRfd value 
        // larger than NIC_MAX_GROW_RFDS
        Adapter->MaxNumRfd = max(Adapter->NumRfd, NIC_MAX_GROW_RFDS);
        DBGPRINT(MP_INFO, ("NumRfd = %d\n", Adapter->NumRfd));
        DBGPRINT(MP_INFO, ("MaxNumRfd = %d\n", Adapter->MaxNumRfd));

        Adapter->HwRfdSize = sizeof(RFD_STRUC);      

        // alloc the recv packet pool

        NdisAllocatePacketPoolEx(
            &Status,
            &Adapter->RecvPacketPool,
            Adapter->NumRfd,
            Adapter->MaxNumRfd,
            sizeof(PVOID) * 4);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_PACKET_POOL;
            break;
        }

        // alloc the buffer pool
        NdisAllocateBufferPool(
            &Status,
            &Adapter->RecvBufferPool,
            Adapter->MaxNumRfd);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_BUFFER_POOL;
            break;
        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_OUT_OF_RESOURCES,
            1,
            ErrorValue);
    }
#if OFFLOAD
        // Allocate the shared memory for the offloading packet
        // this miniport use this shared memory when OFFLAOD is on
        for (i = 0; i < LARGE_SEND_MEM_SIZE_OPTION; i++)
        {
            NdisMAllocateSharedMemory(
                Adapter->AdapterHandle,
                LargeSendSharedMemArray[i],
                FALSE,
                (PVOID *)&(Adapter->OffloadSharedMem.StartVa),
                &(Adapter->OffloadSharedMem.PhyAddr));
            if (Adapter->OffloadSharedMem.StartVa)
            {
                Adapter->OffloadSharedMemSize = LargeSendSharedMemArray[i];
                OffloadSharedMemSuccess = TRUE;
                Adapter->OffloadEnable = TRUE;

                break;
            }
        }
        if (OffloadSharedMemSuccess == FALSE)
        {

            ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate offload used memory\n"));
            Adapter->OffloadEnable = FALSE;
        }
#endif

    DBGPRINT_S(Status, ("<-- NICAllocMemory, Status=%x\n", Status));

    return Status;

}

VOID NICInitSend(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Initialize send data structures

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None                                                    

--*/    
{
    PMP_TCB         pMpTcb;
    PHW_TCB         pHwTcb;
    ULONG           HwTcbPhys;
    LONG            TcbCount;

    PTBD_STRUC      pHwTbd;  
    ULONG           HwTbdPhys;     

    DBGPRINT(MP_TRACE, ("--> NICInitSend\n"));

    Adapter->TransmitIdle = TRUE;
    Adapter->ResumeWait = TRUE;

    // Setup the initial pointers to the SW and HW TCB data space
    pMpTcb = (PMP_TCB) Adapter->MpTcbMem;
    pHwTcb = (PHW_TCB) Adapter->HwSendMemAllocVa;
    HwTcbPhys = NdisGetPhysicalAddressLow(Adapter->HwSendMemAllocPa);

    // Setup the initial pointers to the TBD data space.
    // TBDs are located immediately following the TCBs
    pHwTbd = (PTBD_STRUC) (Adapter->HwSendMemAllocVa +
                 (sizeof(TXCB_STRUC) * Adapter->NumTcb));
    HwTbdPhys = HwTcbPhys + (sizeof(TXCB_STRUC) * Adapter->NumTcb);

    // Go through and set up each TCB
    for (TcbCount = 0; TcbCount < Adapter->NumTcb; TcbCount++)
    {
        pMpTcb->HwTcb = pHwTcb;                 // save ptr to HW TCB
        pMpTcb->HwTcbPhys = HwTcbPhys;      // save HW TCB physical address

        pMpTcb->HwTbd = pHwTbd;                 // save ptr to TBD array
        pMpTcb->HwTbdPhys = HwTbdPhys;      // save TBD array physical address

        if (TcbCount)
            pMpTcb->PrevHwTcb = pHwTcb - 1;
        else
            pMpTcb->PrevHwTcb   = (PHW_TCB)((PUCHAR)Adapter->HwSendMemAllocVa +
                                      ((Adapter->NumTcb - 1) * sizeof(HW_TCB)));

        pHwTcb->TxCbHeader.CbStatus = 0;        // clear the status 
        pHwTcb->TxCbHeader.CbCommand = CB_EL_BIT | CB_TX_SF_BIT | CB_TRANSMIT;


        // Set the link pointer in HW TCB to the next TCB in the chain.  
        // If this is the last TCB in the chain, then set it to the first TCB.
        if (TcbCount < Adapter->NumTcb - 1)
        {
            pMpTcb->Next = pMpTcb + 1;
            pHwTcb->TxCbHeader.CbLinkPointer = HwTcbPhys + sizeof(HW_TCB);
        }
        else
        {
            pMpTcb->Next = (PMP_TCB) Adapter->MpTcbMem;
            pHwTcb->TxCbHeader.CbLinkPointer = 
                NdisGetPhysicalAddressLow(Adapter->HwSendMemAllocPa);
        }

        pHwTcb->TxCbThreshold = (UCHAR) Adapter->AiThreshold;
        pHwTcb->TxCbTbdPointer = HwTbdPhys;

        pMpTcb++; 
        pHwTcb++;
        HwTcbPhys += sizeof(TXCB_STRUC);
        pHwTbd = (PTBD_STRUC)((PUCHAR)pHwTbd + sizeof(TBD_STRUC) * NIC_MAX_PHYS_BUF_COUNT);
        HwTbdPhys += sizeof(TBD_STRUC) * NIC_MAX_PHYS_BUF_COUNT;
    }

    // set the TCB head/tail indexes
    // head is the olded one to free, tail is the next one to use
    Adapter->CurrSendHead = (PMP_TCB) Adapter->MpTcbMem;
    Adapter->CurrSendTail = (PMP_TCB) Adapter->MpTcbMem;

    // set the map register head/tail indexes if used
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER))
    {
        Adapter->CurrMapRegHead = 0;
        Adapter->CurrMapRegTail = 0;
    }

    DBGPRINT(MP_TRACE, ("<-- NICInitSend, Status=%x\n"));
}

NDIS_STATUS NICInitRecv(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Initialize receive data structures

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_RESOURCES

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_RESOURCES;

    PMP_RFD         pMpRfd;      
    LONG            RfdCount;
    ULONG           ErrorValue = 0;

    DBGPRINT(MP_TRACE, ("--> NICInitRecv\n"));

    // Setup each RFD
    for (RfdCount = 0; RfdCount < Adapter->NumRfd; RfdCount++)
    {
        pMpRfd = NdisAllocateFromNPagedLookasideList(&Adapter->RecvLookaside);
        if (!pMpRfd)
        {
            ErrorValue = ERRLOG_OUT_OF_LOOKASIDE_MEMORY;
            continue;
        }

        // Allocate the shared memory for this RFD.
        NdisMAllocateSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwRfdSize,
            FALSE,
            &pMpRfd->HwRfd,
            &pMpRfd->HwRfdPa);

        if (!pMpRfd->HwRfd)
        {
            ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
            NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
            continue;
        }

        ErrorValue = NICAllocRfd(Adapter, pMpRfd);
        if (ErrorValue)
        {
            NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
            continue;
        }

        // Add this RFD to the RecvList
        Adapter->CurrNumRfd++;                      
        NICReturnRFD(Adapter, pMpRfd);
    }

    if (Adapter->CurrNumRfd > NIC_MIN_RFDS)
    {
        Status = NDIS_STATUS_SUCCESS;
    }

    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_OUT_OF_RESOURCES,
            1,
            ErrorValue);
        NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
    }

    DBGPRINT_S(Status, ("<-- NICInitRecv, Status=%x\n", Status));

    return Status;
}

ULONG NICAllocRfd(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_RFD         pMpRfd)
/*++
Routine Description:

    Allocate NDIS_PACKET and NDIS_BUFFER associated with a RFD

Arguments:

    Adapter     Pointer to our adapter
    pMpRfd      pointer to a RFD

Return Value:

    ERRLOG_OUT_OF_NDIS_PACKET
    ERRLOG_OUT_OF_NDIS_BUFFER

--*/    
{
    NDIS_STATUS         Status;
    PHW_RFD             pHwRfd;    
    ULONG               HwRfdPhys;  
    ULONG               ErrorValue = 0;

    do
    {
        pHwRfd = pMpRfd->HwRfd;
        pMpRfd->HwRfdPhys = NdisGetPhysicalAddressLow(pMpRfd->HwRfdPa);

        pMpRfd->Flags = 0;
        pMpRfd->NdisPacket = NULL;
        pMpRfd->NdisBuffer = NULL;

        NdisAllocatePacket(
            &Status,
            &pMpRfd->NdisPacket,
            Adapter->RecvPacketPool);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERT(pMpRfd->NdisPacket == NULL);
            ErrorValue = ERRLOG_OUT_OF_NDIS_PACKET;
            break;
        }

        // point our buffer for receives at this Rfd
        NdisAllocateBuffer(
            &Status,
            &pMpRfd->NdisBuffer,
            Adapter->RecvBufferPool,
            (PVOID)&pHwRfd->RfdBuffer.RxMacHeader,
            NIC_MAX_PACKET_SIZE);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERT(pMpRfd->NdisBuffer == NULL);
            ErrorValue = ERRLOG_OUT_OF_NDIS_BUFFER;
            break;
        }

        // Init each RFD header
        pHwRfd->RfdRbdPointer = DRIVER_NULL;
        pHwRfd->RfdSize = NIC_MAX_PACKET_SIZE;

        NDIS_SET_PACKET_HEADER_SIZE(pMpRfd->NdisPacket, NIC_HEADER_SIZE);

        NdisChainBufferAtFront(pMpRfd->NdisPacket, pMpRfd->NdisBuffer);

        // Save ptr to MP_RFD in the packet, used in MPReturnPackets 
        MP_SET_PACKET_RFD(pMpRfd->NdisPacket, pMpRfd);      

        return ErrorValue;

    } while (FALSE);

    if (ErrorValue)
    {
        if (pMpRfd->NdisPacket)
        {
            NdisFreePacket(pMpRfd->NdisPacket);
        }

        if (pMpRfd->HwRfd)
        {
            NdisMFreeSharedMemory(
                Adapter->AdapterHandle,
                Adapter->HwRfdSize,
                FALSE,
                pMpRfd->HwRfd,
                pMpRfd->HwRfdPa);
        }
    }

    return ErrorValue;

}

VOID NICFreeRfd(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_RFD         pMpRfd)
/*++
Routine Description:

    Free a RFD and assocaited NDIS_PACKET and NDIS_BUFFER

Arguments:

    Adapter     Pointer to our adapter
    pMpRfd      Pointer to a RFD

Return Value:

    None                                                    

--*/    
{
    ASSERT(pMpRfd->NdisBuffer);      
    ASSERT(pMpRfd->NdisPacket);  
    ASSERT(pMpRfd->HwRfd);    

    NdisFreeBuffer(pMpRfd->NdisBuffer);
    NdisFreePacket(pMpRfd->NdisPacket);
    pMpRfd->NdisBuffer = NULL;
    pMpRfd->NdisPacket = NULL;

    NdisMFreeSharedMemory(
        Adapter->AdapterHandle,
        Adapter->HwRfdSize,
        FALSE,
        pMpRfd->HwRfd,
        pMpRfd->HwRfdPa);
    pMpRfd->HwRfd = NULL;

    NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
}


NDIS_STATUS NICSelfTest(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Perform a NIC self-test

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_DEVICE_FAILED

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    ULONG           SelfTestCommandCode;

    DBGPRINT(MP_TRACE, ("--> NICSelfTest\n"));

    DBGPRINT(MP_INFO, ("SelfTest=%x, SelfTestPhys=%x\n", 
        Adapter->SelfTest, Adapter->SelfTestPhys));

    // Issue a software reset to the adapter
    HwSoftwareReset(Adapter);

    // Execute The PORT Self Test Command On The 82558.
    ASSERT(Adapter->SelfTestPhys != 0);
    SelfTestCommandCode = Adapter->SelfTestPhys;

    // Setup SELF TEST Command Code in D3 - D0
    SelfTestCommandCode |= PORT_SELFTEST;

    // Initialize the self-test signature and results DWORDS
    Adapter->SelfTest->StSignature = 0;
    Adapter->SelfTest->StResults = 0xffffffff;

    // Do the port command
    Adapter->CSRAddress->Port = SelfTestCommandCode;

    MP_STALL_EXECUTION(NIC_DELAY_POST_SELF_TEST_MS);

    // if The First Self Test DWORD Still Zero, We've timed out.  If the second
    // DWORD is not zero then we have an error.
    if ((Adapter->SelfTest->StSignature == 0) || (Adapter->SelfTest->StResults != 0))
    {
        DBGPRINT(MP_ERROR, ("StSignature=%x, StResults=%x\n", 
            Adapter->SelfTest->StSignature, Adapter->SelfTest->StResults));

        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_HARDWARE_FAILURE,
            1,
            ERRLOG_SELFTEST_FAILED);

        Status = NDIS_STATUS_DEVICE_FAILED;
    }

    DBGPRINT_S(Status, ("<-- NICSelfTest, Status=%x\n", Status));

    return Status;
}

NDIS_STATUS NICInitializeAdapter(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Initialize the adapter and set up everything

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/    
{
    NDIS_STATUS     Status;
    USHORT          EepromFlags;

    DBGPRINT(MP_TRACE, ("--> NICInitializeAdapter\n"));

    do
    {

        // set up our link indication variable
        // it doesn't matter what this is right now because it will be
        // set correctly if link fails
        Adapter->MediaState = NdisMediaStateConnected;

        Adapter->CurrentPowerState = NdisDeviceStateD0;
        Adapter->NextPowerState    = NdisDeviceStateD0;

        // Issue a software reset to the D100
        HwSoftwareReset(Adapter);

        // Load the CU BASE (set to 0, because we use linear mode)
        Adapter->CSRAddress->ScbGeneralPointer = 0;
        Status = D100IssueScbCommand(Adapter, SCB_CUC_LOAD_BASE, FALSE);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Wait for the SCB command word to clear before we set the general pointer
        if (!WaitScb(Adapter))
        {
            Status = NDIS_STATUS_HARD_ERRORS;
            break;
        }

        // Load the RU BASE (set to 0, because we use linear mode)
        Adapter->CSRAddress->ScbGeneralPointer = 0;
        Status = D100IssueScbCommand(Adapter, SCB_RUC_LOAD_BASE, FALSE);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Configure the adapter
        Status = HwConfigure(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) break;

        Status = HwSetupIAAddress(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) break;

        // Clear the internal counters
        HwClearAllCounters(Adapter);


    } while (FALSE);
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_HARDWARE_FAILURE,
            1,
            ERRLOG_INITIALIZE_ADAPTER);
    }

    DBGPRINT_S(Status, ("<-- NICInitializeAdapter, Status=%x\n", Status));

    return Status;
}    


VOID HwSoftwareReset(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Issue a software reset to the hardware    

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None                                                    

--*/    
{
    DBGPRINT(MP_TRACE, ("--> HwSoftwareReset\n"));

    // Issue a PORT command with a data word of 0
    Adapter->CSRAddress->Port = PORT_SOFTWARE_RESET;

    // wait after the port reset command
    NdisStallExecution(NIC_DELAY_POST_RESET);

    // Mask off our interrupt line -- its unmasked after reset
    NICDisableInterrupt(Adapter);

    DBGPRINT(MP_TRACE, ("<-- HwSoftwareReset\n"));
}


NDIS_STATUS HwConfigure(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Configure the hardware    

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/    
{
    NDIS_STATUS         Status;
    PCB_HEADER_STRUC    NonTxCmdBlockHdr = (PCB_HEADER_STRUC)Adapter->NonTxCmdBlock;
    UINT                i;

    DBGPRINT(MP_TRACE, ("--> HwConfigure\n"));

    // Init the packet filter to nothing.
    Adapter->PacketFilter = 0;
    
    //
    // Store the current setting for BROADCAST/PROMISCUOS modes
    Adapter->OldParameterField = CB_557_CFIG_DEFAULT_PARM15;
    
    // Setup the non-transmit command block header for the configure command.
    NonTxCmdBlockHdr->CbStatus = 0;
    NonTxCmdBlockHdr->CbCommand = CB_CONFIGURE;
    NonTxCmdBlockHdr->CbLinkPointer = DRIVER_NULL;

    // Fill in the configure command data.

    // First fill in the static (end user can't change) config bytes
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[0] = CB_557_CFIG_DEFAULT_PARM0;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[2] = CB_557_CFIG_DEFAULT_PARM2;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[3] = CB_557_CFIG_DEFAULT_PARM3;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[6] = CB_557_CFIG_DEFAULT_PARM6;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[9] = CB_557_CFIG_DEFAULT_PARM9;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[10] = CB_557_CFIG_DEFAULT_PARM10;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[11] = CB_557_CFIG_DEFAULT_PARM11;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[12] = CB_557_CFIG_DEFAULT_PARM12;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[13] = CB_557_CFIG_DEFAULT_PARM13;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[14] = CB_557_CFIG_DEFAULT_PARM14;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[16] = CB_557_CFIG_DEFAULT_PARM16;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[17] = CB_557_CFIG_DEFAULT_PARM17;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[18] = CB_557_CFIG_DEFAULT_PARM18;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[20] = CB_557_CFIG_DEFAULT_PARM20;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[21] = CB_557_CFIG_DEFAULT_PARM21;

    // Now fill in the rest of the configuration bytes (the bytes that contain
    // user configurable parameters).

    // Set the Tx and Rx Fifo limits
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[1] =
        (UCHAR) ((Adapter->AiTxFifo << 4) | Adapter->AiRxFifo);

    if (Adapter->MWIEnable)
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[3] |= CB_CFIG_B3_MWI_ENABLE;
    }

    // Set the Tx and Rx DMA maximum byte count fields.
    if ((Adapter->AiRxDmaCount) || (Adapter->AiTxDmaCount))
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[4] =
            Adapter->AiRxDmaCount;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[5] =
            (UCHAR) (Adapter->AiTxDmaCount | CB_CFIG_DMBC_EN);
    }
    else
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[4] =
            CB_557_CFIG_DEFAULT_PARM4;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[5] =
            CB_557_CFIG_DEFAULT_PARM5;
    }


    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[7] =
        (UCHAR) ((CB_557_CFIG_DEFAULT_PARM7 & (~CB_CFIG_URUN_RETRY)) |
        (Adapter->AiUnderrunRetry << 1)
        );

    // Setup for MII or 503 operation.  The CRS+CDT bit should only be set
    // when operating in 503 mode.
    if (Adapter->PhyAddress == 32)
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[8] =
            (CB_557_CFIG_DEFAULT_PARM8 & (~CB_CFIG_503_MII));
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[15] =
            (CB_557_CFIG_DEFAULT_PARM15 | CB_CFIG_CRS_OR_CDT);
    }
    else
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[8] =
            (CB_557_CFIG_DEFAULT_PARM8 | CB_CFIG_503_MII);
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[15] =
            ((CB_557_CFIG_DEFAULT_PARM15 & (~CB_CFIG_CRS_OR_CDT)) | CB_CFIG_BROADCAST_DIS);
    }


    // Setup Full duplex stuff

    // If forced to half duplex
    if (Adapter->AiForceDpx == 1)
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
            (CB_557_CFIG_DEFAULT_PARM19 &
            (~(CB_CFIG_FORCE_FDX| CB_CFIG_FDX_ENABLE)));

    // If forced to full duplex
    else if (Adapter->AiForceDpx == 2)
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
            (CB_557_CFIG_DEFAULT_PARM19 | CB_CFIG_FORCE_FDX);

    // If auto-duplex
    else
    {
        // We must force full duplex on if we are using PHY 0, and we are
        // supposed to run in FDX mode.  We do this because the D100 has only
        // one FDX# input pin, and that pin will be connected to PHY 1.
        if ((Adapter->PhyAddress == 0) && (Adapter->usDuplexMode == 2))
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
                (CB_557_CFIG_DEFAULT_PARM19 | CB_CFIG_FORCE_FDX);
        else
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
            CB_557_CFIG_DEFAULT_PARM19;
    }


    // display the config info to the debugger
    DBGPRINT(MP_INFO, ("   Issuing Configure command\n"));
    DBGPRINT(MP_INFO, ("   Config Block at virt addr "PTR_FORMAT", phys address %x\n",
        &NonTxCmdBlockHdr->CbStatus, Adapter->NonTxCmdBlockPhys));

    for (i=0; i < CB_CFIG_BYTE_COUNT; i++)
        DBGPRINT(MP_INFO, ("   Config byte %x = %.2x\n", 
            i, Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[i]));

    // Wait for the SCB command word to clear before we set the general pointer
    if (!WaitScb(Adapter))
    {
        Status = NDIS_STATUS_HARD_ERRORS;
    }
    else
    {
        ASSERT(Adapter->CSRAddress->ScbCommandLow == 0)
        Adapter->CSRAddress->ScbGeneralPointer = Adapter->NonTxCmdBlockPhys;
    
        // Submit the configure command to the chip, and wait for it to complete.
        Status = D100SubmitCommandBlockAndWait(Adapter);
    }

    DBGPRINT_S(Status, ("<-- HwConfigure, Status=%x\n", Status));

    return Status;
}


NDIS_STATUS HwSetupIAAddress(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Set up the individual MAC address                             

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_SUCCESS_HARD_ERRORS

--*/    
{
    NDIS_STATUS         Status;
    UINT                i;
    PCB_HEADER_STRUC    NonTxCmdBlockHdr = (PCB_HEADER_STRUC)Adapter->NonTxCmdBlock;

    DBGPRINT(MP_TRACE, ("--> HwSetupIAAddress\n"));

    // Individual Address Setup
    NonTxCmdBlockHdr->CbStatus = 0;
    NonTxCmdBlockHdr->CbCommand = CB_IA_ADDRESS;
    NonTxCmdBlockHdr->CbLinkPointer = DRIVER_NULL;

    // Copy in the station's individual address
    for (i = 0; i < ETH_LENGTH_OF_ADDRESS; i++)
        Adapter->NonTxCmdBlock->NonTxCb.Setup.IaAddress[i] = Adapter->CurrentAddress[i];

    // Update the command list pointer.  We don't need to do a WaitSCB here
    // because this command is either issued immediately after a reset, or
    // after another command that runs in polled mode.  This guarantees that
    // the low byte of the SCB command word will be clear.  The only commands
    // that don't run in polled mode are transmit and RU-start commands.
    ASSERT(Adapter->CSRAddress->ScbCommandLow == 0)
    Adapter->CSRAddress->ScbGeneralPointer = Adapter->NonTxCmdBlockPhys;

    // Submit the IA configure command to the chip, and wait for it to complete.
    Status = D100SubmitCommandBlockAndWait(Adapter);

    DBGPRINT_S(Status, ("<-- HwSetupIAAddress, Status=%x\n", Status));

    return Status;
}

NDIS_STATUS HwClearAllCounters(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    This routine will clear the hardware error statistic counters
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/    
{
    NDIS_STATUS     Status;
    BOOLEAN         bResult;

    DBGPRINT(MP_TRACE, ("--> HwClearAllCounters\n"));

    do
    {
        // Load the dump counters pointer.  Since this command is generated only
        // after the IA setup has complete, we don't need to wait for the SCB
        // command word to clear
        ASSERT(Adapter->CSRAddress->ScbCommandLow == 0)
        Adapter->CSRAddress->ScbGeneralPointer = Adapter->StatsCounterPhys;

        // Issue the load dump counters address command
        Status = D100IssueScbCommand(Adapter, SCB_CUC_DUMP_ADDR, FALSE);
        if (Status != NDIS_STATUS_SUCCESS) break;

        // Now dump and reset all of the statistics
        Status = D100IssueScbCommand(Adapter, SCB_CUC_DUMP_RST_STAT, TRUE);
        if (Status != NDIS_STATUS_SUCCESS) break;

        // Now wait for the dump/reset to complete, timeout value 2 secs
        MP_STALL_AND_WAIT(Adapter->StatsCounters->CommandComplete == 0xA007, 2000, bResult);
        if (!bResult)
        {
            MP_SET_HARDWARE_ERROR(Adapter);
            Status = NDIS_STATUS_HARD_ERRORS;
            break;
        }

        // init packet counts
        Adapter->GoodTransmits = 0;
        Adapter->GoodReceives = 0;

        // init transmit error counts
        Adapter->TxAbortExcessCollisions = 0;
        Adapter->TxLateCollisions = 0;
        Adapter->TxDmaUnderrun = 0;
        Adapter->TxLostCRS = 0;
        Adapter->TxOKButDeferred = 0;
        Adapter->OneRetry = 0;
        Adapter->MoreThanOneRetry = 0;
        Adapter->TotalRetries = 0;

        // init receive error counts
        Adapter->RcvCrcErrors = 0;
        Adapter->RcvAlignmentErrors = 0;
        Adapter->RcvResourceErrors = 0;
        Adapter->RcvDmaOverrunErrors = 0;
        Adapter->RcvCdtFrames = 0;
        Adapter->RcvRuntErrors = 0;

    } while (FALSE);

    DBGPRINT_S(Status, ("<-- HwClearAllCounters, Status=%x\n", Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_main.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_main.c

Abstract:
    This module contains NDIS miniport handlers

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"

#if DBG
#define _FILENUMBER     "NIAM"
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif

//                 
// Global data for LBFO
//
#if LBFO
LIST_ENTRY g_AdapterList;
NDIS_SPIN_LOCK g_Lock;
#endif

NDIS_STATUS DriverEntry(
    IN  PDRIVER_OBJECT   DriverObject,
    IN  PUNICODE_STRING  RegistryPath
    )
/*++
Routine Description:

Arguments:

    DriverObject    -   pointer to the driver object
    RegistryPath    -   pointer to the driver registry path
     
Return Value:
    
    NDIS_STATUS - the value returned by NdisMRegisterMiniport 
    
--*/
{
    NDIS_STATUS                   Status;
    NDIS_HANDLE                   NdisWrapperHandle;
    NDIS_MINIPORT_CHARACTERISTICS MPChar;

    DBGPRINT(MP_TRACE, ("====> DriverEntry\n"));

    //
    // Notify the NDIS wrapper about this driver, get a NDIS wrapper handle back
    //
    NdisMInitializeWrapper(
        &NdisWrapperHandle,
        DriverObject,
        RegistryPath,
        NULL);

    if (NdisWrapperHandle == NULL)
    {
        Status = NDIS_STATUS_FAILURE;

        DBGPRINT_S(Status, ("<==== DriverEntry failed to InitWrapper, Status=%x\n", Status));
        return Status;
    }

#if LBFO
    //
    // Init the global data
    //
    InitializeListHead(&g_AdapterList);
    NdisAllocateSpinLock(&g_Lock);

    //
    // For regular miniports, there is NO need to have an Unload handler
    // For a LBFO miniport, register an Unload handler for global data cleanup
    // The unload handler has a more global scope, whereas the scope of the 
    // MiniportHalt function is restricted to a particular miniport instance.
    //
    NdisMRegisterUnloadHandler(NdisWrapperHandle, MPUnload);
#endif      

    //
    // Fill in the Miniport characteristics structure with the version numbers 
    // and the entry points for driver-supplied MiniportXxx 
    //
    NdisZeroMemory(&MPChar, sizeof(MPChar));

    MPChar.MajorNdisVersion         = MP_NDIS_MAJOR_VERSION;
    MPChar.MinorNdisVersion         = MP_NDIS_MINOR_VERSION;

    MPChar.CheckForHangHandler      = MPCheckForHang;
    MPChar.DisableInterruptHandler  = NULL;
    MPChar.EnableInterruptHandler   = NULL;
    MPChar.HaltHandler              = MPHalt;
    MPChar.InitializeHandler        = MPInitialize;
    MPChar.QueryInformationHandler  = MPQueryInformation;
    //MPChar.ReconfigureHandler         = NULL;
    MPChar.ResetHandler             = MPReset;
    MPChar.ReturnPacketHandler      = MPReturnPacket;
    
    MPChar.SendPacketsHandler       = MpSendPacketsHandler;
    
    MPChar.SetInformationHandler    = MPSetInformation;
    MPChar.AllocateCompleteHandler  = MPAllocateComplete;
    MPChar.HandleInterruptHandler   = MPHandleInterrupt;
    MPChar.ISRHandler               = MPIsr;

#ifdef NDIS51_MINIPORT
    MPChar.CancelSendPacketsHandler = MPCancelSendPackets;
    MPChar.PnPEventNotifyHandler    = MPPnPEventNotify;
    MPChar.AdapterShutdownHandler   = MPShutdown;
#endif

    DBGPRINT(MP_LOUD, ("Calling NdisMRegisterMiniport...\n"));

    Status = NdisMRegisterMiniport(
                 NdisWrapperHandle,
                 &MPChar,
                 sizeof(NDIS_MINIPORT_CHARACTERISTICS));

    DBGPRINT_S(Status, ("<==== DriverEntry, Status=%x\n", Status));

    return Status;
}


NDIS_STATUS MPInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
/*++
Routine Description:

    MiniportInitialize handler

Arguments:

    OpenErrorStatus         Not used
    SelectedMediumIndex     Place-holder for what media we are using
    MediumArray             Array of ndis media passed down to us to pick from
    MediumArraySize         Size of the array
    MiniportAdapterHandle   The handle NDIS uses to refer to us
    WrapperConfigurationContext For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    NDIS_STATUS     Status;
    PMP_ADAPTER     Adapter = NULL;
    NDIS_HANDLE     ConfigurationHandle;
    PVOID           NetworkAddress;
    UINT            index;
    UINT            uiPnpCommandValue;
    
#if DBG
    LARGE_INTEGER   TS, TD, TE;
#endif

    DBGPRINT(MP_TRACE, ("====> MPInitialize\n"));

#if DBG
    NdisGetCurrentSystemTime(&TS);
#endif    

    do
    {
        //
        // Find the media type we support
        //
        for (index = 0; index < MediumArraySize; ++index)
        {
            if (MediumArray[index] == NIC_MEDIA_TYPE) 
	    {
                break;
            }
        }

        if (index == MediumArraySize)
        {
            DBGPRINT(MP_ERROR, ("Expected media (%x) is not in MediumArray.\n", NIC_MEDIA_TYPE));
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            break;
        }

        *SelectedMediumIndex = index;

        //
        // Allocate MP_ADAPTER structure
        //
        Status = MpAllocAdapterBlock(&Adapter);
        if (Status != NDIS_STATUS_SUCCESS) 
        {
            break;
        }

        Adapter->AdapterHandle = MiniportAdapterHandle;

        //
        // Read the registry parameters
        //
        Status = NICReadRegParameters(
                     Adapter,
                     WrapperConfigurationContext);
        if (Status != NDIS_STATUS_SUCCESS) 
        {
            break;
        }

        //
        // Inform NDIS of the attributes of our adapter.
        // This has to be done before calling NdisMRegisterXxx or NdisXxxx function
        // that depends on the information supplied to NdisMSetAttributesEx
        // e.g. NdisMAllocateMapRegisters 
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE) Adapter,
            0,
            NDIS_ATTRIBUTE_DESERIALIZE | NDIS_ATTRIBUTE_BUS_MASTER | NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND ,
            NIC_INTERFACE_TYPE);

        //
        // Find the physical adapter
        //
        Status = MpFindAdapter(Adapter, WrapperConfigurationContext);
        if (Status != NDIS_STATUS_SUCCESS) break;

        //
        // Map bus-relative IO range to system IO space
        //
        Status = NdisMRegisterIoPortRange(
                     (PVOID *)&Adapter->PortOffset,
                     Adapter->AdapterHandle,
                     Adapter->IoBaseAddress,
                     Adapter->IoRange);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MP_ERROR, ("NdisMRegisterioPortRange failed\n"));
    
            NdisWriteErrorLogEntry(
                Adapter->AdapterHandle,
                NDIS_ERROR_CODE_BAD_IO_BASE_ADDRESS,
                0);
        
            break;
        }
        
        //
        // Read additional info from NIC such as MAC address
        //
        Status = NICReadAdapterInfo(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) break;
        
        //
        // Allocate all other memory blocks including shared memory
        //
        Status = NICAllocAdapterMemory(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) break;

        //
        // Init send data structures
        //
        NICInitSend(Adapter);

        //
        // Init receive data structures
        //
        Status = NICInitRecv(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) break;
        
        // Map bus-relative registers to virtual system-space
        Status = NdisMMapIoSpace(
                     (PVOID *) &(Adapter->CSRAddress),
                     Adapter->AdapterHandle,
                     Adapter->MemPhysAddress,
                     NIC_MAP_IOSPACE_LENGTH);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MP_ERROR, ("NdisMMapIoSpace failed\n"));
    
            NdisWriteErrorLogEntry(
                Adapter->AdapterHandle,
                NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                1,
                ERRLOG_MAP_IO_SPACE);
        
            break;
        }

        DBGPRINT(MP_INFO, ("CSRAddress="PTR_FORMAT"\n", Adapter->CSRAddress));

        //
        // Disable interrupts here which is as soon as possible
        //
        NICDisableInterrupt(Adapter);
                     
        //
        // Register the interrupt
        //
        Status = NdisMRegisterInterrupt(
                     &Adapter->Interrupt,
                     Adapter->AdapterHandle,
                     Adapter->InterruptLevel,
                     Adapter->InterruptLevel,
                     TRUE,       // RequestISR
                     TRUE,       // SharedInterrupt
                     NIC_INTERRUPT_MODE);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MP_ERROR, ("NdisMRegisterInterrupt failed\n"));
    
            NdisWriteErrorLogEntry(
                Adapter->AdapterHandle,
                NDIS_ERROR_CODE_INTERRUPT_CONNECT,
                0);
        
            break;
        }
        
        MP_SET_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE);

        //
        // Test our adapter hardware
        //
        Status = NICSelfTest(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) break;
        
        //
        // Init the hardware and set up everything
        //
        Status = NICInitializeAdapter(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) break;
        
#ifdef NDIS50_MINIPORT
        //
        // Register a shutdown handler for NDIS50 or earlier miniports
        // For NDIS51 miniports, set AdapterShutdownHandler as shown above
        //
        NdisMRegisterAdapterShutdownHandler(
            Adapter->AdapterHandle,
            (PVOID) Adapter,
            (ADAPTER_SHUTDOWN_HANDLER) MPShutdown);
#endif         

        //
        // Enable the interrupt
        //
        NICEnableInterrupt(Adapter);

        //
        // Minimize init-time
        //
        NdisMInitializeTimer(
            &Adapter->LinkDetectionTimer, 
            Adapter->AdapterHandle,
            MpLinkDetectionDpc, 
            Adapter);

        //
        // Set the link detection flag
        //
        MP_SET_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION);

        //
        // Increment the reference count so halt handler will wait 
        //
        MP_INC_REF(Adapter);
        NdisMSetTimer(&Adapter->LinkDetectionTimer, NIC_LINK_DETECTION_DELAY);
        
#if LBFO
        //
        // Add this adapter to the global miniport list
        //
        MpAddAdapterToList(Adapter);
#endif

    } while (FALSE);

    if (Adapter && Status != NDIS_STATUS_SUCCESS)
    {
        //
        // Undo everything if it failed
        //
        MP_DEC_REF(Adapter);
        MpFreeAdapter(Adapter);
    }

#if DBG
    NdisGetCurrentSystemTime(&TE);
    TD.QuadPart = TE.QuadPart - TS.QuadPart;
    TD.QuadPart /= 10000;       // Convert to ms
    DBGPRINT(MP_WARN, ("Init time = %d ms\n", TD.LowPart));
#endif    
    
    DBGPRINT_S(Status, ("<==== MPInitialize, Status=%x\n", Status));
    
    return Status;
}


BOOLEAN MPCheckForHang(
    IN  NDIS_HANDLE     MiniportAdapterContext
    )
/*++

Routine Description:
    
    MiniportCheckForHang handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    TRUE    This NIC needs a reset
    FALSE   Everything is fine

Note: 
    CheckForHang handler is called in the context of a timer DPC. 
    take advantage of this fact when acquiring/releasing spinlocks

--*/
{
    PMP_ADAPTER         Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    NDIS_MEDIA_STATE    CurrMediaState;
    NDIS_STATUS         Status;
    PMP_TCB             pMpTcb;
    
    //
    // Just skip this part if the adapter is doing link detection
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
    {
        return(FALSE);   
    }

    //
    // any nonrecoverable hardware error?
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_NON_RECOVER_ERROR))
    {
        DBGPRINT(MP_WARN, ("Non recoverable error - remove\n"));
        return (TRUE);
    }
            
    //
    // hardware failure?
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_HARDWARE_ERROR))
    {
        DBGPRINT(MP_WARN, ("hardware error - reset\n"));
        return(TRUE);
    }
          
    //
    // Is send stuck?                  
    //
    
    NdisDprAcquireSpinLock(&Adapter->SendLock);

    if (Adapter->nBusySend > 0)
    {
        pMpTcb = Adapter->CurrSendHead;
        pMpTcb->Count++;
        if (pMpTcb->Count > NIC_SEND_HANG_THRESHOLD)
        {
            NdisDprReleaseSpinLock(&Adapter->SendLock);
            DBGPRINT(MP_WARN, ("Send stuck - reset\n"));
            return(TRUE);
        }
    }
    
    NdisDprReleaseSpinLock(&Adapter->SendLock);
    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    //
    // Update the RFD shrink count                                          
    //
    if (Adapter->CurrNumRfd > Adapter->NumRfd)
    {
        Adapter->RfdShrinkCount++;          
    }



    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    NdisDprAcquireSpinLock(&Adapter->Lock);
    CurrMediaState = NICGetMediaState(Adapter);

    if (CurrMediaState != Adapter->MediaState)
    {
        DBGPRINT(MP_WARN, ("Media state changed to %s\n",
            ((CurrMediaState == NdisMediaStateConnected)? 
            "Connected": "Disconnected")));

        Adapter->MediaState = CurrMediaState;
        Status = (CurrMediaState == NdisMediaStateConnected) ? 
                 NDIS_STATUS_MEDIA_CONNECT : NDIS_STATUS_MEDIA_DISCONNECT;          
        if (Status == NDIS_STATUS_MEDIA_CONNECT)
        {
            MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);
        }
        else
        {
            MP_SET_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);
        }
        
        NdisDprReleaseSpinLock(&Adapter->Lock);
        
        // Indicate the media event
        NdisMIndicateStatus(Adapter->AdapterHandle, Status, (PVOID)0, 0);

        NdisMIndicateStatusComplete(Adapter->AdapterHandle);
    }
    else
    {
        NdisDprReleaseSpinLock(&Adapter->Lock);
    }
    return(FALSE);
}


VOID MPHalt(
    IN  NDIS_HANDLE     MiniportAdapterContext)
/*++

Routine Description:
    
    MiniportHalt handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    None
    
--*/
{
    BOOLEAN         bCancelled;
    LONG            Count;

    PMP_ADAPTER     Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    
    MP_SET_FLAG(Adapter, fMP_ADAPTER_HALT_IN_PROGRESS);
                                           
    DBGPRINT(MP_TRACE, ("====> MPHalt\n"));

    //
    // Call Shutdown handler to disable interrupt and turn the hardware off 
    // by issuing a full reset
    //
    MPShutdown(MiniportAdapterContext);
    
    //
    // Deregister interrupt as early as possible
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE))
    {
        NdisMDeregisterInterrupt(&Adapter->Interrupt);                           
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE);
    }

#if LBFO
    MpRemoveAdapterFromList(Adapter);

    //
    // For a regualr miniport, no send packets and OID requests should be outstanding 
    // when Halt handler is called. But for a LBFO miniport in secondary mode, 
    // some packets from primary miniport may be still around
    //

    NdisAcquireSpinLock(&Adapter->SendLock);
              
    //
    // Free the packets on SendWaitList                                                           
    //
    MpFreeQueuedSendPackets(Adapter);

    //
    // Free the packets being actively sent & stopped
    //
    MpFreeBusySendPackets(Adapter);
    
    NdisReleaseSpinLock(&Adapter->SendLock);

#endif

    //
    // Decrement the ref count which was incremented in MPInitialize
    //
    Count = MP_DEC_REF(Adapter);

    //
    // Possible non-zero ref counts mean one or more of the following conditions: 
    // 1) Pending async shared memory allocation;
    // 2) DPC's are not finished (e.g. link detection)
    //
    if (Count)
    {
        DBGPRINT(MP_WARN, ("RefCount=%d --- waiting!\n", MP_GET_REF(Adapter)));

        while (TRUE)
        {
            if (NdisWaitEvent(&Adapter->ExitEvent, 2000))
            {
                break;
            }

            DBGPRINT(MP_WARN, ("RefCount=%d --- rewaiting!\n", MP_GET_REF(Adapter)));
        }
    }
    
    NdisAcquireSpinLock(&Adapter->RcvLock);
    //
    // wait for all the received packets to return
    //
    MP_DEC_RCV_REF(Adapter);
    Count = MP_GET_RCV_REF(Adapter);
    
    NdisReleaseSpinLock(&Adapter->RcvLock);

    if (Count)
    {
        DBGPRINT(MP_WARN, ("RcvRefCount=%d --- waiting!\n", Count));

        while (TRUE)
        {
            if (NdisWaitEvent(&Adapter->AllPacketsReturnedEvent, 2000))
            {
                break;
            }

            DBGPRINT(MP_WARN, ("RcvRefCount=%d --- rewaiting!\n", MP_GET_RCV_REF(Adapter)));
        }
    }
        

#ifdef NDIS50_MINIPORT
    //
    // Deregister shutdown handler as it's being halted
    //
    NdisMDeregisterAdapterShutdownHandler(Adapter->AdapterHandle);
#endif   

    //
    // Reset the PHY chip.  We do this so that after a warm boot, the PHY will
    // be in a known state, with auto-negotiation enabled.
    //
    ResetPhy(Adapter);

    //
    // Free the entire adapter object, including the shared memory structures.
    //
    MpFreeAdapter(Adapter);

    DBGPRINT(MP_TRACE, ("<==== MPHalt\n"));
}

NDIS_STATUS MPReset(
    OUT PBOOLEAN        AddressingReset,
    IN  NDIS_HANDLE     MiniportAdapterContext)
/*++

Routine Description:
    
    MiniportReset handler
    
Arguments:

    AddressingReset         To let NDIS know whether we need help from it with our reset
    MiniportAdapterContext  Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_RESET_IN_PROGRESS
    NDIS_STATUS_HARD_ERRORS

Note:
    ResetHandler is called at DPC. take advantage of this fact when acquiring or releasing
    spinlocks
    
--*/
{
    NDIS_STATUS     Status;
    PNDIS_PACKET    Packet;
    
    PMP_ADAPTER     Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    BOOLEAN         bDone = TRUE;

    DBGPRINT(MP_TRACE, ("====> MPReset\n"));

    *AddressingReset = TRUE;

    NdisDprAcquireSpinLock(&Adapter->Lock);
    NdisDprAcquireSpinLock(&Adapter->SendLock);
    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    do
    {
        ASSERT(!MP_TEST_FLAG(Adapter, fMP_ADAPTER_HALT_IN_PROGRESS));
  
        //
        // Is this adapter already doing a reset?
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS))
        {
            Status = NDIS_STATUS_RESET_IN_PROGRESS;
            MP_EXIT;
        }

        MP_SET_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);

        //
        // Is this adapter doing link detection?                                      
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
        {
            DBGPRINT(MP_WARN, ("Reset is pended...\n"));
        
            Adapter->bResetPending = TRUE;
            Status = NDIS_STATUS_PENDING;
            MP_EXIT;
        }
        //
        // Is this adapter going to be removed
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_NON_RECOVER_ERROR))
        {
           Status = NDIS_STATUS_HARD_ERRORS;
           if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_REMOVE_IN_PROGRESS))
           {
               MP_EXIT;
           }
                      
           // This is an unrecoverable hardware failure. 
           // We need to tell NDIS to remove this miniport
           MP_SET_FLAG(Adapter, fMP_ADAPTER_REMOVE_IN_PROGRESS);
           MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);
           
           NdisDprReleaseSpinLock(&Adapter->RcvLock);
           NdisDprReleaseSpinLock(&Adapter->SendLock);
           NdisDprReleaseSpinLock(&Adapter->Lock);
           
           NdisWriteErrorLogEntry(
               Adapter->AdapterHandle,
               NDIS_ERROR_CODE_HARDWARE_FAILURE,
               1,
               ERRLOG_REMOVE_MINIPORT);
           
           NdisMRemoveMiniport(Adapter->AdapterHandle);
           
           DBGPRINT_S(Status, ("<==== MPReset, Status=%x\n", Status));
            
           return Status;
        }   
                

        //
        // Disable the interrupt and issue a reset to the NIC
        //
        NICDisableInterrupt(Adapter);
        NICIssueSelectiveReset(Adapter);


        //
        // release all the locks and then acquire back the send lock
        // we are going to clean up the send queues
        // which may involve calling Ndis APIs
        // release all the locks before grabbing the send lock to
        // avoid deadlocks
        //
        NdisDprReleaseSpinLock(&Adapter->RcvLock);
        NdisDprReleaseSpinLock(&Adapter->SendLock);
        NdisDprReleaseSpinLock(&Adapter->Lock);
        
        NdisDprAcquireSpinLock(&Adapter->SendLock);


        //
        // This is a deserialized miniport, we need to free all the send packets
        // Free the packets on SendWaitList                                                           
        //
        MpFreeQueuedSendPackets(Adapter);

        //
        // Free the packets being actively sent & stopped
        //
        MpFreeBusySendPackets(Adapter);

#if DBG
        if (MP_GET_REF(Adapter) > 1)
        {
            DBGPRINT(MP_WARN, ("RefCount=%d\n", MP_GET_REF(Adapter)));
        }
#endif

        NdisZeroMemory(Adapter->MpTcbMem, Adapter->MpTcbMemSize);

        //
        // Re-initialize the send structures
        //
        NICInitSend(Adapter);
        
        NdisDprReleaseSpinLock(&Adapter->SendLock);

        //
        // get all the locks again in the right order
        //
        NdisDprAcquireSpinLock(&Adapter->Lock);
        NdisDprAcquireSpinLock(&Adapter->SendLock);
        NdisDprAcquireSpinLock(&Adapter->RcvLock);

        //
        // Reset the RFD list and re-start RU         
        //
        NICResetRecv(Adapter);
        Status = NICStartRecv(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) 
        {
            // Are we having failures in a few consecutive resets?                  
            if (Adapter->HwErrCount < NIC_HARDWARE_ERROR_THRESHOLD)
            {
                // It's not over the threshold yet, let it to continue
                Adapter->HwErrCount++;
            }
            else
            {
                // This is an unrecoverable hardware failure. 
                // We need to tell NDIS to remove this miniport
                MP_SET_FLAG(Adapter, fMP_ADAPTER_REMOVE_IN_PROGRESS);
                MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);
                
                NdisDprReleaseSpinLock(&Adapter->RcvLock);
                NdisDprReleaseSpinLock(&Adapter->SendLock);
                NdisDprReleaseSpinLock(&Adapter->Lock);
                
                NdisWriteErrorLogEntry(
                    Adapter->AdapterHandle,
                    NDIS_ERROR_CODE_HARDWARE_FAILURE,
                    1,
                    ERRLOG_REMOVE_MINIPORT);
                     
                NdisMRemoveMiniport(Adapter->AdapterHandle);
                
                DBGPRINT_S(Status, ("<==== MPReset, Status=%x\n", Status));
                return(Status);
            }
            
            break;
        }
        
        Adapter->HwErrCount = 0;
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_HARDWARE_ERROR);

        NICEnableInterrupt(Adapter);

    } while (FALSE);

    MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);

    exit:

    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    NdisDprReleaseSpinLock(&Adapter->SendLock);
    NdisDprReleaseSpinLock(&Adapter->Lock);



    DBGPRINT_S(Status, ("<==== MPReset, Status=%x\n", Status));
    return(Status);
}

VOID MPReturnPacket(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PNDIS_PACKET    Packet
    )
/*++

Routine Description:
    
    MiniportReturnPacket handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    Packet                  Pointer to a packet being returned to the miniport

Return Value:

    None

Note:
    ReturnPacketHandler is called at DPC. take advantage of this fact when acquiring or releasing
    spinlocks
    
--*/
{
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;
    PMP_RFD         pMpRfd = MP_GET_PACKET_RFD(Packet);
    ULONG           Count;

    DBGPRINT(MP_TRACE, ("====> MPReturnPacket\n"));

    ASSERT(pMpRfd);

    ASSERT(MP_TEST_FLAG(pMpRfd, fMP_RFD_RECV_PEND));
    MP_CLEAR_FLAG(pMpRfd, fMP_RFD_RECV_PEND);

    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    RemoveEntryList((PLIST_ENTRY)pMpRfd);


    // Decrement the Power Mgmt Ref.
    Adapter->PoMgmt.OutstandingRecv --;

    if (Adapter->RfdShrinkCount < NIC_RFD_SHRINK_THRESHOLD)
    {
        NICReturnRFD(Adapter, pMpRfd);
    }
    else
    {
        ASSERT(Adapter->CurrNumRfd > Adapter->NumRfd);

        Adapter->RfdShrinkCount = 0;
        NICFreeRfd(Adapter, pMpRfd);
        Adapter->CurrNumRfd--;

        DBGPRINT(MP_TRACE, ("Shrink... CurrNumRfd = %d\n", Adapter->CurrNumRfd));
    }


    //
    // note that we get the ref count here, but check
    // to see if it is zero and signal the event -after-
    // releasign the SpinLock. otherwise, we may let the Halthandler
    // continue while we are holding a lock.
    //
    MP_DEC_RCV_REF(Adapter);
    Count =  MP_GET_RCV_REF(Adapter);

    NdisDprReleaseSpinLock(&Adapter->RcvLock);

    if (Count == 0)
        NdisSetEvent(&Adapter->AllPacketsReturnedEvent);

    DBGPRINT(MP_TRACE, ("<==== MPReturnPacket\n"));
}


VOID MPSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets)
/*++

Routine Description:
    
    MiniportSendPackets handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    PacketArray             Set of packets to send
    NumberOfPackets         Self-explanatory

Return Value:

    None

--*/
{
    PMP_ADAPTER     Adapter;
    NDIS_STATUS     Status;
    UINT            PacketCount;

    
#if LBFO
    PMP_ADAPTER     ThisAdapter;
#endif

    DBGPRINT(MP_TRACE, ("====> MPSendPackets\n"));

    Adapter = (PMP_ADAPTER)MiniportAdapterContext;

#if LBFO
    NdisAcquireSpinLock(&Adapter->LockLBFO);
    
    // Any secondary adapters?
    if (Adapter->NumSecondary)
    {
        // In this sample driver, we do very simple load balancing ...
        // Walk through the secondary miniport list, send the packets on a secondary 
        // miniport if it's ready
        // If none of the secondary miniports is ready, we'll use the primary miniport
        ThisAdapter = Adapter->NextSecondary; 
        while (ThisAdapter)
        {
            if (MP_IS_NOT_READY(ThisAdapter))
            {
                ThisAdapter = ThisAdapter->NextSecondary;
                continue;
            }
            
            //
            // Found a good secondary miniport to send packets on
            // Need to put a ref on this adapter so it won't go away
            //
            MP_LBFO_INC_REF(ThisAdapter);        
            NdisReleaseSpinLock(&Adapter->LockLBFO);
            
            NdisAcquireSpinLock(&ThisAdapter->SendLock);
        
            //
            // Send these packets      
            //
            for (PacketCount=0;PacketCount < NumberOfPackets; PacketCount++)
            {
                MpSendPacket(ThisAdapter, PacketArray[PacketCount], FALSE);
            }
            
            NdisReleaseSpinLock(&ThisAdapter->SendLock);

            //
            // Done with this adapter for now, deref it            
            //
            MP_LBFO_DEC_REF(ThisAdapter);        
            
            //
            // Sent all the packets on a secondary miniport, return
            //
            return;
        }
    }

    NdisReleaseSpinLock(&Adapter->LockLBFO);
    
#endif

    NdisAcquireSpinLock(&Adapter->SendLock);

    // Is this adapter ready for sending?
    if (MP_IS_NOT_READY(Adapter))
    {
        //
        // there  is link
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
        {
            for (PacketCount = 0; PacketCount < NumberOfPackets; PacketCount++)
            {
                
                InsertTailQueue(&Adapter->SendWaitQueue, 
                    MP_GET_PACKET_MR(PacketArray[PacketCount]));
                Adapter->nWaitSend++;
                DBGPRINT(MP_WARN, ("MpSendPackets: link detection - queue packet "PTR_FORMAT"\n", 
                    PacketArray[PacketCount]));
            }
            NdisReleaseSpinLock(&Adapter->SendLock);
            return;
        }
        
        //
        // Adapter is not ready and there is not link
        //
        Status = MP_GET_STATUS_FROM_FLAGS(Adapter);

        NdisReleaseSpinLock(&Adapter->SendLock);

        for (PacketCount = 0; PacketCount < NumberOfPackets; PacketCount++)
        {
            NdisMSendComplete(
                MP_GET_ADAPTER_HANDLE(Adapter),
                PacketArray[PacketCount],
                Status);
        }

        return;
    }

    //
    // Adapter is ready, send these packets      
    //
    for (PacketCount = 0; PacketCount < NumberOfPackets; PacketCount++)
    {
        //
        // queue is not empty or tcb is not available 
        //
        if (!IsQueueEmpty(&Adapter->SendWaitQueue) || 
            !MP_TCB_RESOURCES_AVAIABLE(Adapter))
        {
            InsertTailQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(PacketArray[PacketCount]));
            Adapter->nWaitSend++;
        }
        else
        {
            MpSendPacket(Adapter, PacketArray[PacketCount], FALSE);
        }
    }

    NdisReleaseSpinLock(&Adapter->SendLock);

    DBGPRINT(MP_TRACE, ("<==== MPSendPackets\n"));

    return;
}

VOID MPShutdown(
    IN  NDIS_HANDLE     MiniportAdapterContext)
/*++

Routine Description:
    
    MiniportShutdown handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;

    DBGPRINT(MP_TRACE, ("====> MPShutdown\n"));

    //
    // Disable interrupt and issue a full reset
    //
    NICDisableInterrupt(Adapter);
    NICIssueFullReset(Adapter);

    DBGPRINT(MP_TRACE, ("<==== MPShutdown\n"));
}

VOID MPAllocateComplete(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PVOID                   VirtualAddress,
    IN  PNDIS_PHYSICAL_ADDRESS  PhysicalAddress,
    IN  ULONG                   Length,
    IN  PVOID                   Context)
/*++

Routine Description:
    
    MiniportAllocateComplete handler
    This handler is needed because we make calls to NdisMAllocateSharedMemoryAsync
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    VirtualAddress          Pointer to the allocated memory block 
    PhysicalAddress         Physical address of the memory block       
    Length                  Length of the memory block                
    Context                 Context in NdisMAllocateSharedMemoryAsync              

Return Value:

    None
    
--*/
{
    ULONG           ErrorValue;
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;
    PMP_RFD         pMpRfd = (PMP_RFD)Context;

    DBGPRINT(MP_TRACE, ("==== MPAllocateComplete\n"));

    ASSERT(pMpRfd);
    ASSERT(MP_TEST_FLAG(pMpRfd, fMP_RFD_ALLOC_PEND));
    MP_CLEAR_FLAG(pMpRfd, fMP_RFD_ALLOC_PEND);

    NdisAcquireSpinLock(&Adapter->RcvLock);

    //
    // Is allocation successful?  
    //
    if (VirtualAddress)
    {
        pMpRfd->HwRfd = (PHW_RFD) VirtualAddress;
        pMpRfd->HwRfdPa = *PhysicalAddress;

        ErrorValue = NICAllocRfd(Adapter, pMpRfd);
        if (ErrorValue == 0)
        {
            // Add this RFD to the RecvList
            Adapter->CurrNumRfd++;                      
            NICReturnRFD(Adapter, pMpRfd);

            ASSERT(Adapter->CurrNumRfd <= Adapter->MaxNumRfd);
            DBGPRINT(MP_TRACE, ("CurrNumRfd=%d\n", Adapter->CurrNumRfd));
        }
        else
        {
            NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
        }
    }
    else
    {
        NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
    }

    Adapter->bAllocNewRfd = FALSE;
    MP_DEC_REF(Adapter);

    if (MP_GET_REF(Adapter) == 0)
    {
        NdisSetEvent(&Adapter->ExitEvent);
    }

    NdisReleaseSpinLock(&Adapter->RcvLock);
}

VOID MPIsr(
    OUT PBOOLEAN        InterruptRecognized,
    OUT PBOOLEAN        QueueMiniportHandleInterrupt,
    IN  NDIS_HANDLE     MiniportAdapterContext)
/*++

Routine Description:
    
    MiniportIsr handler
    
Arguments:

    InterruptRecognized             TRUE on return if the interrupt comes from this NIC    
    QueueMiniportHandleInterrupt    TRUE on return if MiniportHandleInterrupt should be called
    MiniportAdapterContext          Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER  Adapter = (PMP_ADAPTER)MiniportAdapterContext;

    DBGPRINT(MP_LOUD, ("====> MPIsr\n"));
    
    do 
    {
        //
        // If the adapter is in low power state, then it should not 
        // recognize any interrupt
        // 
        if (Adapter->CurrentPowerState > NdisDeviceStateD0)
        {
            *InterruptRecognized = FALSE;
            *QueueMiniportHandleInterrupt = FALSE;
            break;
        }
        //
        // We process the interrupt if it's not disabled and it's active                  
        //
        if (!NIC_INTERRUPT_DISABLED(Adapter) && NIC_INTERRUPT_ACTIVE(Adapter))
        {
            *InterruptRecognized = TRUE;
            *QueueMiniportHandleInterrupt = TRUE;
        
            //
            // Disable the interrupt (will be re-enabled in MPHandleInterrupt
            //
            NICDisableInterrupt(Adapter);
        }
        else
        {
            *InterruptRecognized = FALSE;
            *QueueMiniportHandleInterrupt = FALSE;
        }
    }
    while (FALSE);    

    DBGPRINT(MP_LOUD, ("<==== MPIsr\n"));
}


VOID MPHandleInterrupt(
    IN  NDIS_HANDLE  MiniportAdapterContext
    )
/*++

Routine Description:
    
    MiniportHandleInterrupt handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER  Adapter = (PMP_ADAPTER)MiniportAdapterContext;
    USHORT       IntStatus;

    NdisDprAcquireSpinLock(&Adapter->Lock);
    
    //
    // Acknowledge the interrupt(s) and get the interrupt status
    //
    NIC_ACK_INTERRUPT(Adapter, IntStatus);
    
    // Handle receive interrupt    
    //
    // if we have a Recv interrupt and have reported a media disconnect status
    // time to indicate the new status
    //

    if (NdisMediaStateDisconnected == Adapter->MediaState)
    {
        DBGPRINT(MP_WARN, ("Media state changed to Connected\n"));

        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);

        Adapter->MediaState = NdisMediaStateConnected;
        
        NdisDprReleaseSpinLock(&Adapter->Lock);
        //
        // Indicate the media event
        //
        NdisMIndicateStatus(Adapter->AdapterHandle, NDIS_STATUS_MEDIA_CONNECT, (PVOID)0, 0);

        NdisMIndicateStatusComplete(Adapter->AdapterHandle);

    }
    
    else
    {
        NdisDprReleaseSpinLock(&Adapter->Lock);
    }

    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    MpHandleRecvInterrupt(Adapter);

    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    
    //
    // Handle send interrupt    
    //
    NdisDprAcquireSpinLock(&Adapter->SendLock);

    MpHandleSendInterrupt(Adapter);

    NdisDprReleaseSpinLock(&Adapter->SendLock);

    //
    // Start the receive unit if it had stopped
    //
    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    NICStartRecv(Adapter);

    NdisDprReleaseSpinLock(&Adapter->RcvLock);

    
    //
    // Re-enable the interrupt (disabled in MPIsr)
    //
    NdisMSynchronizeWithInterrupt(
        &Adapter->Interrupt,
        NICEnableInterrupt,
        Adapter);
}

#ifdef NDIS51_MINIPORT
VOID MPCancelSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PVOID           CancelId)
/*++

Routine Description:
    
    MiniportCancelSendpackets handler - NDIS51 and later
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter
    CancelId                    All the packets with this Id should be cancelled

Return Value:

    None
    
--*/
{
    PQUEUE_ENTRY    pEntry, pPrevEntry, pNextEntry;
    PNDIS_PACKET    Packet;
    PVOID           PacketId;

    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;

    DBGPRINT(MP_TRACE, ("====> MPCancelSendPackets\n"));

    pPrevEntry = NULL;

    NdisAcquireSpinLock(&Adapter->SendLock);

    //
    // Walk through the send wait queue and complete the sends with matching Id
    //
    pEntry = Adapter->SendWaitQueue.Head;                        

    while (pEntry)
    {
        Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

        PacketId = NdisGetPacketCancelId(Packet);
        if (PacketId == CancelId)
        {
            Adapter->nWaitSend--;
        
            //
            // This packet has the right CancelId
            //
            pNextEntry = pEntry->Next;

            if (pPrevEntry == NULL)
            {
                Adapter->SendWaitQueue.Head = pNextEntry;
                if (pNextEntry == NULL)
                {
                    Adapter->SendWaitQueue.Tail = NULL;
                }
            }
            else
            {
                pPrevEntry->Next = pNextEntry;
                if (pNextEntry == NULL)
                {
                    Adapter->SendWaitQueue.Tail = pPrevEntry;
                }
            }

            pEntry = pEntry->Next;
            
            // Put this packet on SendCancelQueue
            InsertTailQueue(&Adapter->SendCancelQueue, MP_GET_PACKET_MR(Packet));
            Adapter->nCancelSend++;
        }
        else
        {
            // This packet doesn't have the right CancelId
            pPrevEntry = pEntry;
            pEntry = pEntry->Next;
        }
    }

    //
    // Get the packets from SendCancelQueue and complete them if any
    //
    while (!IsQueueEmpty(&Adapter->SendCancelQueue))
    {
        pEntry = RemoveHeadQueue(&Adapter->SendCancelQueue); 

        NdisReleaseSpinLock(&Adapter->SendLock);

        ASSERT(pEntry);
        Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

        NdisMSendComplete(
            MP_GET_ADAPTER_HANDLE(Adapter),
            Packet,
            NDIS_STATUS_REQUEST_ABORTED);
        
        NdisAcquireSpinLock(&Adapter->SendLock);
    } 

    NdisReleaseSpinLock(&Adapter->SendLock);

    DBGPRINT(MP_TRACE, ("<==== MPCancelSendPackets\n"));

}

VOID MPPnPEventNotify(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   PnPEvent,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength
    )
/*++

Routine Description:
    
    MiniportPnPEventNotify handler - NDIS51 and later
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter
    PnPEvent                    Self-explanatory 
    InformationBuffer           Self-explanatory 
    InformationBufferLength     Self-explanatory 

Return Value:

    None
    
--*/
{
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;

    DBGPRINT(MP_TRACE, ("====> MPPnPEventNotify\n"));

    switch (PnPEvent)
    {
        case NdisDevicePnPEventQueryRemoved:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventQueryRemoved\n"));
            break;

        case NdisDevicePnPEventRemoved:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventRemoved\n"));
            break;       

        case NdisDevicePnPEventSurpriseRemoved:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventSurpriseRemoved\n"));
            break;

        case NdisDevicePnPEventQueryStopped:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventQueryStopped\n"));
            break;

        case NdisDevicePnPEventStopped:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventStopped\n"));
            break;      
            
        case NdisDevicePnPEventPowerProfileChanged:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventPowerProfileChanged\n"));
            break;      
            
        default:
            DBGPRINT(MP_ERROR, ("MPPnPEventNotify: unknown PnP event %x \n", PnPEvent));
            break;         
    }

    DBGPRINT(MP_TRACE, ("<==== MPPnPEventNotify\n"));

}

#endif

#if LBFO
VOID MPUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:
    
    The Unload handler
    This handler is registered through NdisMRegisterUnloadHandler
    
Arguments:

    DriverObject        Not used

Return Value:

    None
    
--*/
{
    ASSERT(IsListEmpty(&g_AdapterList));

    NdisFreeSpinLock(&g_Lock);      
}

VOID MpAddAdapterToList(
    IN  PMP_ADAPTER  Adapter
    )
/*++

Routine Description:
    
    This function adds a new adapter to the global adapter list
    1. Not part of bundle (primary) if BundleId string is empty
    2. Primary if no adapter with the same BundleId
    3. Secondary if there is already one adapter with the same BundleId  
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter

Return Value:

    None
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER     ThisAdapter;
    PMP_ADAPTER     PrimaryAdapter = NULL;

    DBGPRINT(MP_WARN, ("Add adapter "PTR_FORMAT" ...", Adapter));

    //
    // Set the primary adapter to itself by default
    //
    Adapter->PrimaryAdapter = Adapter;

    //
    // Is this adapter part of a bundle? Just insert it in the list if not
    //
    if (Adapter->BundleId.Length == 0)
    {
        DBGPRINT_RAW(MP_WARN, ("not in a bundle\n"));
        NdisInterlockedInsertTailList(&g_AdapterList, &Adapter->List, &g_Lock);
        return;   
    }

    NdisAllocateSpinLock(&Adapter->LockLBFO);

    do
    {
        NdisAcquireSpinLock(&g_Lock);

        //
        // Search for the primary adapter if it exists. 
        // Skip searching if the list is empty 
        //
        if (IsListEmpty(&g_AdapterList))
        {
            DBGPRINT_RAW(MP_WARN, ("Primary\n"));
            break;
        }

        ThisAdapter = (PMP_ADAPTER)GetListHeadEntry(&g_AdapterList);

        while ((PLIST_ENTRY)ThisAdapter != &g_AdapterList)
        {
            if (!MP_TEST_FLAG(ThisAdapter, fMP_ADAPTER_SECONDARY) && 
                ThisAdapter->BundleId.Length == Adapter->BundleId.Length)
            {
                if (NdisEqualMemory(ThisAdapter->BundleId.Buffer, 
                    Adapter->BundleId.Buffer, Adapter->BundleId.Length))
                {
                    PrimaryAdapter = ThisAdapter;
                    break;
                }
            }

            ThisAdapter = (PMP_ADAPTER)GetListFLink((PLIST_ENTRY)ThisAdapter);   
        }

        //
        // Does a primary adapter exist? If not, this adapter will be primary.
        //
        if (PrimaryAdapter == NULL)
        {
            DBGPRINT_RAW(MP_WARN, ("Primary\n"));
            break;
        }

        //
        // Found the primary adapter, so set this adapter as secondary
        // Put a ref on the primary adapter so it won't go away while 
        // we are calling NdisMSetMiniportSecondary.
        //
        MP_LBFO_INC_REF(PrimaryAdapter);        

        NdisReleaseSpinLock(&g_Lock);

        //
        // We found the primary adapter with the same BundleIdentifier string
        // Set this adapter as scondary
        //
        Status = NdisMSetMiniportSecondary(
                     Adapter->AdapterHandle,
                     PrimaryAdapter->AdapterHandle);

        ASSERT(Status == NDIS_STATUS_SUCCESS);

        NdisAcquireSpinLock(&g_Lock);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            MP_SET_FLAG(Adapter, fMP_ADAPTER_SECONDARY);
            Adapter->PrimaryAdapter = PrimaryAdapter; 

            DBGPRINT_RAW(MP_WARN, ("Secondary, use primary adapter "PTR_FORMAT"\n", 
                PrimaryAdapter));

            //
            // Add this to the end of primary's secondary miniport list
            //
            NdisAcquireSpinLock(&PrimaryAdapter->LockLBFO);

            PrimaryAdapter->NumSecondary++;   
            ThisAdapter = PrimaryAdapter; 
            while (ThisAdapter->NextSecondary)
            {
                ThisAdapter = ThisAdapter->NextSecondary;
            }
            ThisAdapter->NextSecondary = Adapter;

            NdisReleaseSpinLock(&PrimaryAdapter->LockLBFO);
        }

        MP_LBFO_DEC_REF(PrimaryAdapter);        

    } while (FALSE);

    InsertTailList(&g_AdapterList, &Adapter->List);

    NdisReleaseSpinLock(&g_Lock);

    return;      
}

VOID MpRemoveAdapterFromList(
    IN  PMP_ADAPTER  Adapter
    )
/*++

Routine Description:
    
    This function removes the adapter from the global adapter list
    1. Not part of bundle (primary) if BundleId string is empty
    2. Secondary - Remove it from primary's secondary adapter list
    3. Primary - If a secondary adapter exists, promote the secondary
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER     PrimaryAdapter;
    PMP_ADAPTER     ThisAdapter;

    DBGPRINT(MP_WARN, ("Remove adapter "PTR_FORMAT" ...", Adapter));

    ASSERT(!IsListEmpty(&g_AdapterList));

    //
    // Is this adapter part of a bundle? Just remove it if not
    //
    if (Adapter->BundleId.Length == 0)
    {
        DBGPRINT_RAW(MP_WARN, ("not in a bundle\n"));

        NdisAcquireSpinLock(&g_Lock);
        RemoveEntryList(&Adapter->List);
        NdisReleaseSpinLock(&g_Lock);
        return;
    }

    NdisAcquireSpinLock(&g_Lock);

    //
    // Check to see if it's secondary adapter, need to remove it from primary 
    // adapter's secondary list so the primary adapter won't pass more packets 
    // to this adapter
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_SECONDARY))
    {
        //
        // This is a secondary adapter
        //
        PrimaryAdapter = Adapter->PrimaryAdapter;

        DBGPRINT_RAW(MP_WARN, ("Secondary, primary adapter = "PTR_FORMAT"\n", 
            PrimaryAdapter));

        NdisAcquireSpinLock(&PrimaryAdapter->LockLBFO);

        //
        // Remove it from the primary's secondary miniport list
        //
        ThisAdapter = PrimaryAdapter; 
        while (ThisAdapter)
        {
            if (ThisAdapter->NextSecondary == Adapter)
            {
                ThisAdapter->NextSecondary = Adapter->NextSecondary;
                PrimaryAdapter->NumSecondary--;   
                break;
            }

            ThisAdapter = ThisAdapter->NextSecondary;
        }
        
        NdisReleaseSpinLock(&PrimaryAdapter->LockLBFO);

        //
        // Remove this adapter from the list
        //
        RemoveEntryList(&Adapter->List);
    }

    //
    // Need to wait for the ref count to be zero ...
    // For a primary adapter, non-zero ref count means one or more adapters are 
    // trying to become this adapter's secondary adapters    
    // For a secondary adapter, non-zero ref count means the primary is actively 
    // sending some packets on this adapter
    //
    while (TRUE)
    {
        if (MP_LBFO_GET_REF(Adapter) == 0)
        {
            break;
        }
        
        NdisReleaseSpinLock(&g_Lock);
        NdisMSleep(100);
        NdisAcquireSpinLock(&g_Lock);
    }  
    
    if (!MP_TEST_FLAG(Adapter, fMP_ADAPTER_SECONDARY))
    {
        //
        // Remove this adapter from the list
        //
        RemoveEntryList(&Adapter->List);
    
        DBGPRINT_RAW(MP_WARN, ("Primary\n"));
        if (Adapter->NumSecondary > 0)
        {
            //
            // Promote a secondary adapter
            //
            MpPromoteSecondary(Adapter);
        }
    }

    NdisReleaseSpinLock(&g_Lock);

    NdisFreeSpinLock(&Adapter->LockLBFO);
}

VOID MpPromoteSecondary(
    IN  PMP_ADAPTER     Adapter)
/*++

Routine Description:
    
    This function promotes a secondary miniport and sets up this new primary's
    secondary adapter list
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter

Return Value:

    None
    
--*/
{
    NDIS_STATUS     Status;
    PMP_ADAPTER     ThisAdapter, FirstSecondary;
    PMP_ADAPTER     PromoteAdapter = NULL;

    //
    // Promote a secondary adapter
    //
    ThisAdapter = Adapter->NextSecondary; 
    while (ThisAdapter)
    {
        DBGPRINT(MP_WARN, ("Promote adapter "PTR_FORMAT"\n", ThisAdapter));

        Status = NdisMPromoteMiniport(ThisAdapter->AdapterHandle);
        ASSERT(Status == NDIS_STATUS_SUCCESS);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            PromoteAdapter = ThisAdapter;
            MP_CLEAR_FLAG(PromoteAdapter, fMP_ADAPTER_SECONDARY);
            break;
        }

        ThisAdapter = ThisAdapter->NextSecondary;
    }

    if (PromoteAdapter)
    {
        //
        // Remove the new primary from old primary's secondary miniport list
        //
        NdisAcquireSpinLock(&Adapter->LockLBFO);
        ThisAdapter = Adapter; 
        while (ThisAdapter)
        {
            if (ThisAdapter->NextSecondary == PromoteAdapter)
            {
                ThisAdapter->NextSecondary = PromoteAdapter->NextSecondary;
                Adapter->NumSecondary--;   
                break;
            }

            ThisAdapter = ThisAdapter->NextSecondary;
        }
        NdisReleaseSpinLock(&Adapter->LockLBFO);

        //
        // Set all adapters in the bundle to use the new primary
        //
        PromoteAdapter->PrimaryAdapter = PromoteAdapter;
        while (ThisAdapter)
        {
            ThisAdapter->PrimaryAdapter = PromoteAdapter;
            ThisAdapter = ThisAdapter->NextSecondary;
        }

        //
        // Set the new primary's secondary miniport list
        //
        NdisAcquireSpinLock(&PromoteAdapter->LockLBFO);
        PromoteAdapter->NextSecondary = Adapter->NextSecondary;
        PromoteAdapter->NumSecondary = Adapter->NumSecondary;
        NdisReleaseSpinLock(&PromoteAdapter->LockLBFO);
    }
    else
    {
        //
        // This shouldn't happen! 
        // Set each secondary's primary to point to itself
        //
        DBGPRINT(MP_ERROR, ("Failed to promote any seconday adapter\n"));
        ASSERT(FALSE);

        ThisAdapter = Adapter->NextSecondary; 
        while (ThisAdapter)
        {
            ThisAdapter->PrimaryAdapter = ThisAdapter;
            ThisAdapter = ThisAdapter->NextSecondary;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_req.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_req.c

Abstract:
    This module contains miniport OID related handlers

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"
#include "e100_wmi.h"

#if DBG
#define _FILENUMBER     'QERM'
#endif

#if OFFLOAD

//
// This miniport only supports one Encapsultion type: IEEE_802_3_Encapsulation
// one task version: NDIS_TASK_OFFLOAD_VERSION. Modify the code below OID_TCP_
// TASK_OFFLOAD in query and setting information functions to make it support
// more than one encapsulation type and task version
//
// Define the task offload the miniport currently supports.
// This miniport only supports two kinds of offload tasks:
// TCP/IP checksum offload and Segmentation large TCP packet offload
// Later if it can supports more tasks, just redefine this task array
// 
NDIS_TASK_OFFLOAD OffloadTasks[] = {
    {   
        NDIS_TASK_OFFLOAD_VERSION,
        sizeof(NDIS_TASK_OFFLOAD),
        TcpIpChecksumNdisTask,
        0,
        sizeof(NDIS_TASK_TCP_IP_CHECKSUM)
    },

    {   
        NDIS_TASK_OFFLOAD_VERSION,
        sizeof(NDIS_TASK_OFFLOAD),
        TcpLargeSendNdisTask,
        0,
        sizeof(NDIS_TASK_TCP_LARGE_SEND)
    }
};

//
// Get the number of offload tasks this miniport supports
// 
ULONG OffloadTasksCount = sizeof(OffloadTasks) / sizeof(OffloadTasks[0]);

//
// Specify TCP/IP checksum offload task, the miniport can only supports, for now,
// TCP checksum and IP checksum on the sending side, also it supports TCP and IP 
// options
// 
NDIS_TASK_TCP_IP_CHECKSUM TcpIpChecksumTask = {
    {1, 1, 1, 0, 1},
    {0, 0, 0, 0, 0},
    {0, 0, 0, 0},
    {0, 0, 0, 0}
};
//
// Specify Large Send offload task, the miniport supports TCP options and IP options,
// and the minimum segment count the protocol can offload is 1. At this point, we
// cannot specify the maximum offload size(here is 0), because it depends on the size
// of shared memory and the number of TCB used by the driver.
// 
NDIS_TASK_TCP_LARGE_SEND TcpLargeSendTask = {
    0,      //Currently the version is set to 0, later it may change
    0,
    1,
    TRUE,
    TRUE
};

#endif // OFFLOAD


ULONG VendorDriverVersion = NIC_VENDOR_DRIVER_VERSION;

NDIS_OID NICSupportedOids[] =
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_SUPPORTED_GUIDS,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,
    OID_GEN_PHYSICAL_MEDIUM,
    OID_GEN_NETWORK_LAYER_ADDRESSES,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_802_3_XMIT_DEFERRED,
    OID_802_3_XMIT_MAX_COLLISIONS,
    OID_802_3_RCV_OVERRUN,
    OID_802_3_XMIT_UNDERRUN,
    OID_802_3_XMIT_HEARTBEAT_FAILURE,
    OID_802_3_XMIT_TIMES_CRS_LOST,
    OID_802_3_XMIT_LATE_COLLISIONS,

#if OFFLOAD
    OID_TCP_TASK_OFFLOAD,
#endif 
    
/* powermanagement */

    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ADD_WAKE_UP_PATTERN,
    OID_PNP_REMOVE_WAKE_UP_PATTERN,
    OID_PNP_ENABLE_WAKE_UP,


/* custom oid WMI support */
    OID_CUSTOM_DRIVER_SET,
    OID_CUSTOM_DRIVER_QUERY,
    OID_CUSTOM_ARRAY,
    OID_CUSTOM_STRING
};

//
// WMI support
// check out the e100.mof file for examples of how the below
// maps into a .mof file for external advertisement of GUIDs
//
#define NIC_NUM_CUSTOM_GUIDS  4       

static const NDIS_GUID NICGuidList[NIC_NUM_CUSTOM_GUIDS] = {
    { // {F4A80276-23B7-11d1-9ED9-00A0C9010057} example of a uint set
        E100BExampleSetUINT_OIDGuid,
        OID_CUSTOM_DRIVER_SET,
        sizeof(ULONG),
        // Not setting fNDIS_GUID_ALLOW_WRITE flag means that we don't allow
        // users without administrator privilege to set this value, but we do 
        // allow any user to query this value
        (fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ)
    },
    { // {F4A80277-23B7-11d1-9ED9-00A0C9010057} example of a uint query
        E100BExampleQueryUINT_OIDGuid,
            OID_CUSTOM_DRIVER_QUERY,
            sizeof(ULONG),
            // setting fNDIS_GUID_ALLOW_READ flag means that we allow any
            // user to query this value.
            (fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ)
    },
    { // {F4A80278-23B7-11d1-9ED9-00A0C9010057} example of an array query
        E100BExampleQueryArrayOIDGuid,
            OID_CUSTOM_ARRAY,
            sizeof(UCHAR),  // size is size of each element in the array
            // setting fNDIS_GUID_ALLOW_READ flag means that we allow any
            // user to query this value.
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ)
    },
    { // {F4A80279-23B7-11d1-9ED9-00A0C9010057} example of a string query
        E100BExampleQueryStringOIDGuid,
            OID_CUSTOM_STRING,
            (ULONG) -1, // size is -1 for ANSI or NDIS_STRING string types
            // setting fNDIS_GUID_ALLOW_READ flag means that we allow any
            // user to query this value.
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ANSI_STRING | fNDIS_GUID_ALLOW_READ)
    }
};

/**
Local Prototypes
**/
VOID
MPSetPower(
    PMP_ADAPTER     Adapter ,
    NDIS_DEVICE_POWER_STATE   PowerState 
    );

VOID
MPFillPoMgmtCaps (
    IN PMP_ADAPTER Adapter, 
    IN OUT PNDIS_PNP_CAPABILITIES   pPower_Management_Capabilities, 
    IN OUT  PNDIS_STATUS pStatus,
    IN OUT  PULONG pulInfoLen
    );

NDIS_STATUS
MPAddWakeUpPattern(
    IN PMP_ADAPTER pAdapter,
    IN PVOID InformationBuffer, 
    IN UINT InformationBufferLength
    );

NDIS_STATUS
MPRemoveWakeUpPattern(
    IN PMP_ADAPTER pAdapter,
    IN PVOID InformationBuffer, 
    IN UINT InformationBufferLength
    );

BOOLEAN 
MPAreTwoPatternsEqual (
    PNDIS_PM_PACKET_PATTERN pNdisPattern1,
    PNDIS_PM_PACKET_PATTERN pNdisPattern2
    );

NDIS_STATUS 
MPSetNetworkAddress(
    IN PMP_ADAPTER pAdapter, 
    IN PVOID InformationBuffer, 
    IN ULONG InformationBufferLength, 
    IN PULONG BytesRead,
    IN PULONG BytesNeeded
    );

//
// Macros used to walk a doubly linked list. Only macros that are not defined in ndis.h
// The List Next macro will work on Single and Doubly linked list as Flink is a common
// field name in both
//

/*
PLIST_ENTRY
ListNext (
    IN PLIST_ENTRY
    );

PSINGLE_LIST_ENTRY
ListNext (
    IN PSINGLE_LIST_ENTRY
    );
*/
#define ListNext(_pL)                       (_pL)->Flink

/*
PLIST_ENTRY
ListPrev (
    IN LIST_ENTRY *
    );
*/
#define ListPrev(_pL)                       (_pL)->Blink


__inline 
BOOLEAN  
MPIsPoMgmtSupported(
   IN PMP_ADAPTER pAdapter
   )
{

    if (pAdapter->RevsionID  >= E100_82559_A_STEP   && 
         pAdapter->RevsionID <= E100_82559_C_STEP )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


NDIS_STATUS MPQueryInformation(
    IN  NDIS_HANDLE  MiniportAdapterContext,
    IN  NDIS_OID     Oid,
    IN  PVOID        InformationBuffer,
    IN  ULONG        InformationBufferLength,
    OUT PULONG       BytesWritten,
    OUT PULONG       BytesNeeded
    )
/*++
Routine Description:

    MiniportQueryInformation handler            

Arguments:

    MiniportAdapterContext  Pointer to the adapter structure
    Oid                     Oid for this query
    InformationBuffer       Buffer for information
    InformationBufferLength Size of this buffer
    BytesWritten            Specifies how much info is written
    BytesNeeded             In case the buffer is smaller than what we need, tell them how much is needed
    
Return Value:
    
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_BUFFER_TOO_SHORT
    
--*/
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER                 Adapter;

    NDIS_HARDWARE_STATUS        HardwareStatus = NdisHardwareStatusReady;
    NDIS_MEDIUM                 Medium = NIC_MEDIA_TYPE;
    NDIS_PHYSICAL_MEDIUM        PhysMedium = NdisPhysicalMediumUnspecified;
    UCHAR                       VendorDesc[] = NIC_VENDOR_DESC;
    NDIS_PNP_CAPABILITIES       Power_Management_Capabilities;

    ULONG                       ulInfo = 0;
    ULONG64                     ul64Info = 0;
    
    USHORT                      usInfo = 0;                                              
    UCHAR                       arrInfo[ETH_LENGTH_OF_ADDRESS];
    PVOID                       pInfo = (PVOID) &ulInfo;
    ULONG                       ulInfoLen = sizeof(ulInfo);
    ULONG                       ulBytesAvailable = ulInfoLen;
    PNDIS_TASK_OFFLOAD_HEADER   pNdisTaskOffloadHdr;

#if OFFLOAD   
    PNDIS_TASK_OFFLOAD          pTaskOffload;
    PNDIS_TASK_TCP_IP_CHECKSUM  pTcpIpChecksumTask;
    PNDIS_TASK_TCP_LARGE_SEND   pTcpLargeSendTask;
    ULONG                       ulHeadersLen;
    ULONG                       ulMaxOffloadSize;
    UINT                        i;
#endif
    
    DBGPRINT(MP_TRACE, ("====> MPQueryInformation\n"));

    Adapter = (PMP_ADAPTER) MiniportAdapterContext;

    //
    // Initialize the result
    //
    *BytesWritten = 0;
    *BytesNeeded = 0;

    //
    // Process different type of requests
    //
    switch(Oid)
    {
        case OID_GEN_SUPPORTED_LIST:
            pInfo = (PVOID) NICSupportedOids;
            ulBytesAvailable = ulInfoLen = sizeof(NICSupportedOids);
            break;

        case OID_GEN_HARDWARE_STATUS:
            pInfo = (PVOID) &HardwareStatus;
            ulBytesAvailable = ulInfoLen = sizeof(NDIS_HARDWARE_STATUS);
            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
            pInfo = (PVOID) &Medium;
            ulBytesAvailable = ulInfoLen = sizeof(NDIS_MEDIUM);
            break;

        case OID_GEN_PHYSICAL_MEDIUM:
            pInfo = (PVOID) &PhysMedium;
            ulBytesAvailable = ulInfoLen = sizeof(NDIS_PHYSICAL_MEDIUM);
            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_MAXIMUM_LOOKAHEAD:
            if (Adapter->ulLookAhead == 0)
            {
                Adapter->ulLookAhead = NIC_MAX_PACKET_SIZE - NIC_HEADER_SIZE;
            }
            ulInfo = Adapter->ulLookAhead;
            break;         

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            ulInfo = NIC_MAX_PACKET_SIZE - NIC_HEADER_SIZE;
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
            ulInfo = (ULONG) NIC_MAX_PACKET_SIZE;
            break;

        case OID_GEN_MAC_OPTIONS:
            // Notes: 
            // The protocol driver is free to access indicated data by any means. 
            // Some fast-copy functions have trouble accessing on-board device 
            // memory. NIC drivers that indicate data out of mapped device memory 
            // should never set this flag. If a NIC driver does set this flag, it 
            // relaxes the restriction on fast-copy functions. 

            // This miniport indicates receive with NdisMIndicateReceivePacket 
            // function. It has no MiniportTransferData function. Such a driver 
            // should set this flag. 

            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA | 
                     NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                     NDIS_MAC_OPTION_NO_LOOPBACK;
            
            break;

        case OID_GEN_LINK_SPEED:
        case OID_GEN_MEDIA_CONNECT_STATUS:
            if (InformationBufferLength < ulInfoLen)
            {
                break;
            }

            NdisAcquireSpinLock(&Adapter->Lock);
            if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
            {
                ASSERT(!Adapter->bQueryPending);
                Adapter->bQueryPending = TRUE;
                Adapter->QueryRequest.Oid = Oid;                       
                Adapter->QueryRequest.InformationBuffer = InformationBuffer;                       
                Adapter->QueryRequest.InformationBufferLength = InformationBufferLength;
                Adapter->QueryRequest.BytesWritten = BytesWritten;                       
                Adapter->QueryRequest.BytesNeeded = BytesNeeded;                       

                NdisReleaseSpinLock(&Adapter->Lock);

                DBGPRINT(MP_WARN, ("MPQueryInformation: OID 0x%08x is pended\n", Oid));

                Status = NDIS_STATUS_PENDING;   
                break;
            }
            else
            {
                
                NdisReleaseSpinLock(&Adapter->Lock);
                if (Oid == OID_GEN_LINK_SPEED)
                {
                    ulInfo = Adapter->usLinkSpeed * 10000;
                }
                else  // OID_GEN_MEDIA_CONNECT_STATUS
                {
                    NdisAcquireSpinLock(&Adapter->Lock);
                    ulInfo = NICGetMediaState(Adapter);
                        
                    NdisReleaseSpinLock(&Adapter->Lock);
                }
            }
            
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            ulInfo = NIC_MAX_PACKET_SIZE * Adapter->NumTcb;
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            ulInfo = NIC_MAX_PACKET_SIZE * Adapter->CurrNumRfd;
            break;

        case OID_GEN_VENDOR_ID:
            NdisMoveMemory(&ulInfo, Adapter->PermanentAddress, 3);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            pInfo = VendorDesc;
            ulBytesAvailable = ulInfoLen = sizeof(VendorDesc);
            break;

        case OID_GEN_VENDOR_DRIVER_VERSION:
            ulInfo = VendorDriverVersion;
            break;

        case OID_GEN_DRIVER_VERSION:
            usInfo = (USHORT) NIC_DRIVER_VERSION;
            pInfo = (PVOID) &usInfo;
            ulBytesAvailable = ulInfoLen = sizeof(USHORT);
            break;

            // WMI support
        case OID_GEN_SUPPORTED_GUIDS:
            pInfo = (PUCHAR) &NICGuidList;
            ulBytesAvailable = ulInfoLen =  sizeof(NICGuidList);
            break;

            // Task Offload
        case OID_TCP_TASK_OFFLOAD:
            
            DBGPRINT(MP_WARN, ("Query Offloading.\n"));
            
            //
            // If the miniport supports LBFO, it can't support task offload
            // 
#if LBFO
            return NDIS_STATUS_NOT_SUPPORTED;
#endif
           
#if OFFLOAD
            //
            // Because this miniport uses shared memory to do the offload tasks, if
            // allocation of memory is failed, then the miniport can't do the offloading
            // 
            if (Adapter->OffloadEnable == FALSE)
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // Calculate the information buffer length we need to write the offload
            // capabilities
            //
            ulInfoLen = sizeof(NDIS_TASK_OFFLOAD_HEADER) +
                        FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) +
                        sizeof(NDIS_TASK_TCP_IP_CHECKSUM) +
                        FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) +
                        sizeof(NDIS_TASK_TCP_LARGE_SEND);
            
            if (ulInfoLen > InformationBufferLength)
            {
                *BytesNeeded = ulInfoLen;
                Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                break;
            }

            //
            // check version and Encapsulation Type
            //
            pNdisTaskOffloadHdr = (PNDIS_TASK_OFFLOAD_HEADER)InformationBuffer;
            
            //
            // Assume the miniport only supports IEEE_802_3_Encapsulation type
            //
            if (pNdisTaskOffloadHdr->EncapsulationFormat.Encapsulation != IEEE_802_3_Encapsulation)
            {
                DBGPRINT(MP_WARN, ("Encapsulation  type is not supported.\n"));

                pNdisTaskOffloadHdr->OffsetFirstTask = 0;
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // Assume the miniport only supports task version of NDIS_TASK_OFFLOAD_VERSION
            // 
            if (pNdisTaskOffloadHdr->Size != sizeof(NDIS_TASK_OFFLOAD_HEADER)
                    || pNdisTaskOffloadHdr->Version != NDIS_TASK_OFFLOAD_VERSION)
            {
                DBGPRINT(MP_WARN, ("Size or Version is not correct.\n"));

                pNdisTaskOffloadHdr->OffsetFirstTask = 0;
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            //            
            // If no capabilities supported, OffsetFirstTask should be set to 0
            // Currently we support TCP/IP checksum and TCP large send, so set 
            // OffsetFirstTask to indicate the offset of the first offload task
            //
            pNdisTaskOffloadHdr->OffsetFirstTask = pNdisTaskOffloadHdr->Size; 

            //
            // Fill TCP/IP checksum and TCP large send task offload structures
            //
            pTaskOffload = (PNDIS_TASK_OFFLOAD)((PUCHAR)(InformationBuffer) + 
                                                         pNdisTaskOffloadHdr->Size);
            //
            // Fill all the offload capabilities the miniport supports.
            // 
            for (i = 0; i < OffloadTasksCount; i++)
            {
                pTaskOffload->Size = OffloadTasks[i].Size;
                pTaskOffload->Version = OffloadTasks[i].Version;
                pTaskOffload->Task = OffloadTasks[i].Task;
                pTaskOffload->TaskBufferLength = OffloadTasks[i].TaskBufferLength;

                //
                // Not the last task
                // 
                if (i != OffloadTasksCount - 1) 
                {
                    pTaskOffload->OffsetNextTask = FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) +
                                                pTaskOffload->TaskBufferLength;
                }
                else 
                {
                    pTaskOffload->OffsetNextTask = 0;
                }

                switch (OffloadTasks[i].Task) 
                {
                //
                // TCP/IP checksum task offload
                //
                case TcpIpChecksumNdisTask:
                    pTcpIpChecksumTask = (PNDIS_TASK_TCP_IP_CHECKSUM) pTaskOffload->TaskBuffer;
           
                    NdisMoveMemory(pTcpIpChecksumTask, 
                                   &TcpIpChecksumTask, 
                                   sizeof(TcpIpChecksumTask));
                    break;

                //
                // TCP large send task offload
                //
                case TcpLargeSendNdisTask:
                    pTcpLargeSendTask = (PNDIS_TASK_TCP_LARGE_SEND) pTaskOffload->TaskBuffer;
                    NdisMoveMemory(pTcpLargeSendTask, 
                                   &TcpLargeSendTask,
                                   sizeof(TcpLargeSendTask));

                    ulHeadersLen = TCP_IP_MAX_HEADER_SIZE + 
                            pNdisTaskOffloadHdr->EncapsulationFormat.EncapsulationHeaderSize;

                    ulMaxOffloadSize = (NIC_MAX_PACKET_SIZE - ulHeadersLen) * (ULONG)(Adapter->NumTcb);
                    //
                    // The maximum offload size depends on the size of allocated shared memory
                    // and the number of TCB available, because this driver doesn't use a queue
                    // to store the small packets splited from the large packet, so the number
                    // of small packets must be less than or equal to the number of TCB the 
                    // miniport has, so all the small packets can be sent out at one time.
                    // 
                    pTcpLargeSendTask->MaxOffLoadSize = (ulMaxOffloadSize > Adapter->OffloadSharedMemSize) ? 
                                                        Adapter->OffloadSharedMemSize: ulMaxOffloadSize;

                    //
                    // Store the maximum offload size 
                    // 
                    TcpLargeSendTask.MaxOffLoadSize = pTcpLargeSendTask->MaxOffLoadSize;
                    break;
                }

                //
                // Points to the next task offload
                //
                if (i != OffloadTasksCount) 
                {
                    pTaskOffload = (PNDIS_TASK_OFFLOAD)
                                   ((PUCHAR)pTaskOffload + pTaskOffload->OffsetNextTask);
                }
            }
            
            //
            // So far, everything is setup, so return to the caller
            //
            *BytesWritten = ulInfoLen;
            *BytesNeeded = 0;
            
            DBGPRINT (MP_WARN, ("Offloading is set.\n"));

            return NDIS_STATUS_SUCCESS;

#endif //OFFLOAD

            // neither LBFO nor OFFLOAD
            return NDIS_STATUS_NOT_SUPPORTED;
            
        case OID_802_3_PERMANENT_ADDRESS:
            pInfo = Adapter->PermanentAddress;
            ulBytesAvailable = ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_CURRENT_ADDRESS:
            pInfo = Adapter->CurrentAddress;
            ulBytesAvailable = ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            ulInfo = NIC_MAX_MCAST_LIST;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            ulInfo = NIC_MAX_SEND_PACKETS;
            break;

        case OID_PNP_CAPABILITIES:

            MPFillPoMgmtCaps (Adapter, 
                                &Power_Management_Capabilities, 
                                &Status,
                                &ulInfoLen);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                pInfo = (PVOID) &Power_Management_Capabilities;
            }
            else
            {
                pInfo = NULL;
            }

            break;

        case OID_PNP_QUERY_POWER:
            // Status is pre-set in this routine to Success

            Status = NDIS_STATUS_SUCCESS; 

            break;

            // WMI support
        case OID_CUSTOM_DRIVER_QUERY:
            // this is the uint case
            DBGPRINT(MP_INFO,("CUSTOM_DRIVER_QUERY got a QUERY\n"));
            ulInfo = ++Adapter->CustomDriverSet;
            break;

        case OID_CUSTOM_DRIVER_SET:
            DBGPRINT(MP_INFO,("CUSTOM_DRIVER_SET got a QUERY\n"));
            ulInfo = Adapter->CustomDriverSet;
            break;

            // this is the array case
        case OID_CUSTOM_ARRAY:
            DBGPRINT(MP_INFO,("CUSTOM_ARRAY got a QUERY\n"));
            NdisMoveMemory(&ulInfo, Adapter->PermanentAddress, 4);
            break;

            // this is the string case
        case OID_CUSTOM_STRING:
            DBGPRINT(MP_INFO, ("CUSTOM_STRING got a QUERY\n"));
            pInfo = (PVOID) VendorDesc;
            ulBytesAvailable = ulInfoLen = sizeof(VendorDesc);
            break;

        case OID_GEN_XMIT_OK:
        case OID_GEN_RCV_OK:
        case OID_GEN_XMIT_ERROR:
        case OID_GEN_RCV_ERROR:
        case OID_GEN_RCV_NO_BUFFER:
        case OID_GEN_RCV_CRC_ERROR:
        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:
        case OID_802_3_XMIT_DEFERRED:
        case OID_802_3_XMIT_MAX_COLLISIONS:
        case OID_802_3_RCV_OVERRUN:
        case OID_802_3_XMIT_UNDERRUN:
        case OID_802_3_XMIT_HEARTBEAT_FAILURE:
        case OID_802_3_XMIT_TIMES_CRS_LOST:
        case OID_802_3_XMIT_LATE_COLLISIONS:
            Status = NICGetStatsCounters(Adapter, Oid, &ul64Info);
            ulBytesAvailable = ulInfoLen = sizeof(ul64Info);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                if (InformationBufferLength < sizeof(ULONG))
                {
                    Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                    *BytesNeeded = ulBytesAvailable;
                    break;
                }

                ulInfoLen = MIN(InformationBufferLength, ulBytesAvailable);
                pInfo = &ul64Info;
            }
                    
            break;         
            
        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    if (Status == NDIS_STATUS_SUCCESS)
    {
        *BytesNeeded = ulBytesAvailable;
        if (ulInfoLen <= InformationBufferLength)
        {
            //
            // Copy result into InformationBuffer
            //
            *BytesWritten = ulInfoLen;
            if (ulInfoLen)
            {
                NdisMoveMemory(InformationBuffer, pInfo, ulInfoLen);
            }
        }
        else
        {
            //
            // too short
            //
            *BytesNeeded = ulInfoLen;
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
        }
    }

    DBGPRINT(MP_TRACE, ("<==== MPQueryInformation, OID=0x%08x, Status=%x\n", Oid, Status));

    return(Status);
}   

NDIS_STATUS NICGetStatsCounters(
    IN  PMP_ADAPTER  Adapter, 
    IN  NDIS_OID     Oid,
    OUT PULONG64     pCounter
    )
/*++
Routine Description:

    Get the value for a statistics OID

Arguments:

    Adapter     Pointer to our adapter 
    Oid         Self-explanatory   
    pCounter    Pointer to receive the value
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;

    DBGPRINT(MP_TRACE, ("--> NICGetStatsCounters\n"));

    *pCounter = 0; 

    DumpStatsCounters(Adapter);
            
    switch(Oid)
    {
        case OID_GEN_XMIT_OK:
            *pCounter = Adapter->GoodTransmits;
            break;

        case OID_GEN_RCV_OK:
            *pCounter = Adapter->GoodReceives;
            break;

        case OID_GEN_XMIT_ERROR:
            *pCounter = Adapter->TxAbortExcessCollisions +
                        Adapter->TxDmaUnderrun +
                        Adapter->TxLostCRS +
                        Adapter->TxLateCollisions;
            break;

        case OID_GEN_RCV_ERROR:
            *pCounter = Adapter->RcvCrcErrors +
                        Adapter->RcvAlignmentErrors +
                        Adapter->RcvResourceErrors +
                        Adapter->RcvDmaOverrunErrors +
                        Adapter->RcvRuntErrors;
            break;

        case OID_GEN_RCV_NO_BUFFER:
            *pCounter = Adapter->RcvResourceErrors;
            break;

        case OID_GEN_RCV_CRC_ERROR:
            *pCounter = Adapter->RcvCrcErrors;
            break;

        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
            *pCounter = Adapter->nWaitSend;
            break;

        case OID_802_3_RCV_ERROR_ALIGNMENT:
            *pCounter = Adapter->RcvAlignmentErrors;
            break;

        case OID_802_3_XMIT_ONE_COLLISION:
            *pCounter = Adapter->OneRetry;
            break;

        case OID_802_3_XMIT_MORE_COLLISIONS:
            *pCounter = Adapter->MoreThanOneRetry;
            break;

        case OID_802_3_XMIT_DEFERRED:
            *pCounter = Adapter->TxOKButDeferred;
            break;

        case OID_802_3_XMIT_MAX_COLLISIONS:
            *pCounter = Adapter->TxAbortExcessCollisions;
            break;

        case OID_802_3_RCV_OVERRUN:
            *pCounter = Adapter->RcvDmaOverrunErrors;
            break;

        case OID_802_3_XMIT_UNDERRUN:
            *pCounter = Adapter->TxDmaUnderrun;
            break;

        case OID_802_3_XMIT_HEARTBEAT_FAILURE:
            *pCounter = Adapter->TxLostCRS;
            break;

        case OID_802_3_XMIT_TIMES_CRS_LOST:
            *pCounter = Adapter->TxLostCRS;
            break;

        case OID_802_3_XMIT_LATE_COLLISIONS:
            *pCounter = Adapter->TxLateCollisions;
            break;

        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    DBGPRINT(MP_TRACE, ("<-- NICGetStatsCounters\n"));

    return(Status);
}

NDIS_STATUS NICSetPacketFilter(
    IN PMP_ADAPTER Adapter,
    IN ULONG PacketFilter
    )
/*++
Routine Description:

    This routine will set up the adapter so that it accepts packets 
    that match the specified packet filter.  The only filter bits   
    that can truly be toggled are for broadcast and promiscuous     

Arguments:
    
    Adapter         Pointer to our adapter
    PacketFilter    The new packet filter 
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    UCHAR           NewParameterField;
    UINT            i;
    BOOLEAN         bResult;

    DBGPRINT(MP_TRACE, ("--> NICSetPacketFilter, PacketFilter=%08x\n", PacketFilter));

    //
    // Need to enable or disable broadcast and promiscuous support depending
    // on the new filter
    //
    NewParameterField = CB_557_CFIG_DEFAULT_PARM15;

    if (PacketFilter & NDIS_PACKET_TYPE_BROADCAST) 
    {
        NewParameterField &= ~CB_CFIG_BROADCAST_DIS;
    }
    else 
    {
        NewParameterField |= CB_CFIG_BROADCAST_DIS;
    }

    if (PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS) 
    {
        NewParameterField |= CB_CFIG_PROMISCUOUS;
    }
    else 
    {
        NewParameterField &= ~CB_CFIG_PROMISCUOUS;
    }

    do
    {
        if ((Adapter->OldParameterField == NewParameterField ) &&
            !(PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST))
        {
            break;
        }

        //
        // Only need to do something to the HW if the filter bits have changed.
        //
        Adapter->OldParameterField = NewParameterField;
        ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbCommand = CB_CONFIGURE;
        ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbStatus = 0;
        ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbLinkPointer = DRIVER_NULL;

        //
        // First fill in the static (end user can't change) config bytes
        //
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[0] = CB_557_CFIG_DEFAULT_PARM0;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[2] = CB_557_CFIG_DEFAULT_PARM2;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[3] = CB_557_CFIG_DEFAULT_PARM3;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[6] = CB_557_CFIG_DEFAULT_PARM6;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[9] = CB_557_CFIG_DEFAULT_PARM9;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[10] = CB_557_CFIG_DEFAULT_PARM10;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[11] = CB_557_CFIG_DEFAULT_PARM11;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[12] = CB_557_CFIG_DEFAULT_PARM12;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[13] = CB_557_CFIG_DEFAULT_PARM13;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[14] = CB_557_CFIG_DEFAULT_PARM14;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[16] = CB_557_CFIG_DEFAULT_PARM16;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[17] = CB_557_CFIG_DEFAULT_PARM17;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[18] = CB_557_CFIG_DEFAULT_PARM18;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[20] = CB_557_CFIG_DEFAULT_PARM20;

        //
        // Set the Tx underrun retries
        //
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[7] =
            (UCHAR) (CB_557_CFIG_DEFAULT_PARM7 | (Adapter->AiUnderrunRetry << 1));

        //
        // Set the Tx and Rx Fifo limits
        //
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[1] =
            (UCHAR) ((Adapter->AiTxFifo << 4) | Adapter->AiRxFifo);

        //
        // set the MWI enable bit if needed
        //
        if (Adapter->MWIEnable)
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[3] |= CB_CFIG_B3_MWI_ENABLE;

        //
        // Set the Tx and Rx DMA maximum byte count fields.
        //
        if ((Adapter->AiRxDmaCount) || (Adapter->AiTxDmaCount))
        {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[4] =
                Adapter->AiRxDmaCount;
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[5] =
                (UCHAR) (Adapter->AiTxDmaCount | CB_CFIG_DMBC_EN);
        }
        else
        {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[4] =
                CB_557_CFIG_DEFAULT_PARM4;
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[5] =
                CB_557_CFIG_DEFAULT_PARM5;
        }

        //
        // Setup for MII or 503 operation.  The CRS+CDT bit should only be
        // set when operating in 503 mode.
        //
        if (Adapter->PhyAddress == 32)
        {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[8] =
                (CB_557_CFIG_DEFAULT_PARM8 & (~CB_CFIG_503_MII));
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[15] =
                (UCHAR) (NewParameterField | CB_CFIG_CRS_OR_CDT);
        }
        else
        {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[8] =
                (CB_557_CFIG_DEFAULT_PARM8 | CB_CFIG_503_MII);
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[15] =
                (UCHAR) (NewParameterField & (~CB_CFIG_CRS_OR_CDT));
        }

        //
        // Setup Full duplex stuff
        //

        //
        // If forced to half duplex
        //
        if (Adapter->AiForceDpx == 1) 
	{
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
                (CB_557_CFIG_DEFAULT_PARM19 &
                (~(CB_CFIG_FORCE_FDX| CB_CFIG_FDX_ENABLE)));
        }
        //
        // If forced to full duplex
        //
        else if (Adapter->AiForceDpx == 2)
	{
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
                (CB_557_CFIG_DEFAULT_PARM19 | CB_CFIG_FORCE_FDX);
        }
        //
        // If auto-duplex
        //
        else 
	{
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
                                                CB_557_CFIG_DEFAULT_PARM19;
        }

        //
        // if multicast all is being turned on, set the bit
        //
        if (PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) 
	{
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[21] =
                                 (CB_557_CFIG_DEFAULT_PARM21 | CB_CFIG_MULTICAST_ALL);
        }
        else 
	{
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[21] =
                                                CB_557_CFIG_DEFAULT_PARM21;
        }


        //
        // Wait for the SCB to clear before we check the CU status.
        //
        if (!WaitScb(Adapter))
        {
            Status = NDIS_STATUS_HARD_ERRORS;
            break;
        }

        //
        // If we have issued any transmits, then the CU will either be active,
        // or in the suspended state.  If the CU is active, then we wait for
        // it to be suspended.
        //
        if (Adapter->TransmitIdle == FALSE)
        {
            //
            // Wait for suspended state
            //
            MP_STALL_AND_WAIT((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) != SCB_CUS_ACTIVE, 5000, bResult);
            if (!bResult)
            {
                MP_SET_HARDWARE_ERROR(Adapter);
                Status = NDIS_STATUS_HARD_ERRORS;
                break;
            }

            //
            // Check the current status of the receive unit
            //
            if ((Adapter->CSRAddress->ScbStatus & SCB_RUS_MASK) != SCB_RUS_IDLE)
            {
                // Issue an RU abort.  Since an interrupt will be issued, the
                // RU will be started by the DPC.
                Status = D100IssueScbCommand(Adapter, SCB_RUC_ABORT, TRUE);
                if (Status != NDIS_STATUS_SUCCESS)
                {
                    break;
                }
            }
            
            if (!WaitScb(Adapter))
            {
                Status = NDIS_STATUS_HARD_ERRORS;
                break;
            }
           
            //
            // Restore the transmit software flags.  After the multicast
            // command is issued, the command unit will be idle, because the
            // EL bit will be set in the multicast commmand block.
            //
            Adapter->TransmitIdle = TRUE;
            Adapter->ResumeWait = TRUE;
        }
        
        //
        // Display config info
        //
        DBGPRINT(MP_INFO, ("Re-Issuing Configure command for filter change\n"));
        DBGPRINT(MP_INFO, ("Config Block at virt addr "PTR_FORMAT", phys address %x\n",
            &((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbStatus, Adapter->NonTxCmdBlockPhys));

        for (i = 0; i < CB_CFIG_BYTE_COUNT; i++)
            DBGPRINT(MP_INFO, ("  Config byte %x = %.2x\n", i, Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[i]));

        //
        // Submit the configure command to the chip, and wait for it to complete.
        //
        Adapter->CSRAddress->ScbGeneralPointer = Adapter->NonTxCmdBlockPhys;
        Status = D100SubmitCommandBlockAndWait(Adapter);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
        }

    } while (FALSE);

    DBGPRINT_S(Status, ("<-- NICSetPacketFilter, Status=%x\n", Status));

    return(Status);
}

NDIS_STATUS NICSetMulticastList(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    This routine will set up the adapter for a specified multicast address list
    
Arguments:
    
    Adapter     Pointer to our adapter
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_ACCEPTED
    
--*/
{
    NDIS_STATUS     Status;
    PUCHAR          McAddress;
    UINT            i, j;
    BOOLEAN         bResult;

    DBGPRINT(MP_TRACE, ("--> NICSetMulticastList\n"));

    //
    // Setup the command block for the multicast command.
    //
    for (i = 0; i < Adapter->MCAddressCount; i++)
    {
        DBGPRINT(MP_INFO, ("MC(%d) = %02x-%02x-%02x-%02x-%02x-%02x\n", 
            i,
            Adapter->MCList[i][0],
            Adapter->MCList[i][1],
            Adapter->MCList[i][2],
            Adapter->MCList[i][3],
            Adapter->MCList[i][4],
            Adapter->MCList[i][5]));

        McAddress = &Adapter->NonTxCmdBlock->NonTxCb.Multicast.McAddress[i*ETHERNET_ADDRESS_LENGTH];

        for (j = 0; j < ETH_LENGTH_OF_ADDRESS; j++)
            *(McAddress++) = Adapter->MCList[i][j];
    }

    Adapter->NonTxCmdBlock->NonTxCb.Multicast.McCount =
        (USHORT)(Adapter->MCAddressCount * ETH_LENGTH_OF_ADDRESS);
    ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbStatus = 0;
    ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbCommand = CB_MULTICAST;

    //
    // Wait for the SCB to clear before we check the CU status.
    //
    if (!WaitScb(Adapter))
    {
        Status = NDIS_STATUS_HARD_ERRORS;
        MP_EXIT;
    }

    //
    // If we have issued any transmits, then the CU will either be active, or
    // in the suspended state.  If the CU is active, then we wait for it to be
    // suspended.
    //
    if (Adapter->TransmitIdle == FALSE)
    {
        //
        // Wait for suspended state
        //
        MP_STALL_AND_WAIT((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) != SCB_CUS_ACTIVE, 5000, bResult);
        if (!bResult)
        {
            MP_SET_HARDWARE_ERROR(Adapter);
            Status = NDIS_STATUS_HARD_ERRORS;
        }

        //
        // Restore the transmit software flags.  After the multicast command is
        // issued, the command unit will be idle, because the EL bit will be
        // set in the multicast commmand block.
        //
        Adapter->TransmitIdle = TRUE;
        Adapter->ResumeWait = TRUE;
    }

    //
    // Update the command list pointer.
    //
    Adapter->CSRAddress->ScbGeneralPointer = Adapter->NonTxCmdBlockPhys;

    //
    // Submit the multicast command to the adapter and wait for it to complete.
    //
    Status = D100SubmitCommandBlockAndWait(Adapter);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    
    exit:

    DBGPRINT_S(Status, ("<-- NICSetMulticastList, Status=%x\n", Status));

    return(Status);

}

NDIS_STATUS MPSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    )
/*++
Routine Description:

    This is the handler for an OID set operation.
    The only operations that really change the configuration of the adapter are
    set PACKET_FILTER, and SET_MULTICAST.       
    
Arguments:
    
    MiniportAdapterContext  Pointer to the adapter structure
    Oid                     Oid for this query
    InformationBuffer       Buffer for information
    InformationBufferLength Size of this buffer
    BytesRead               Specifies how much info is read
    BytesNeeded             In case the buffer is smaller than what we need, tell them how much is needed
    
Return Value:

    NDIS_STATUS_SUCCESS        
    NDIS_STATUS_INVALID_LENGTH 
    NDIS_STATUS_INVALID_OID    
    NDIS_STATUS_NOT_SUPPORTED  
    NDIS_STATUS_NOT_ACCEPTED   
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER     Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    ULONG           PacketFilter;
    NDIS_DEVICE_POWER_STATE     NewPowerState;

#if OFFLOAD
    PNDIS_TASK_OFFLOAD_HEADER   pNdisTaskOffloadHdr;
    PNDIS_TASK_OFFLOAD          TaskOffload;
    PNDIS_TASK_OFFLOAD          TmpOffload;
    PNDIS_TASK_TCP_IP_CHECKSUM  pTcpIpChecksumTask;
    PNDIS_TASK_TCP_LARGE_SEND   pNdisTaskTcpLargeSend;
    UINT                        i;
#endif    

    
    DBGPRINT(MP_TRACE, ("====> MPSetInformation\n"));

    *BytesRead = 0;
    *BytesNeeded = 0;

    switch(Oid)
    {
        case OID_802_3_MULTICAST_LIST:
            //
            // Verify the length
            //
            if (InformationBufferLength % ETH_LENGTH_OF_ADDRESS != 0)
            {
                return(NDIS_STATUS_INVALID_LENGTH);
            }

            //
            // Save the number of MC list size
            //
            Adapter->MCAddressCount = InformationBufferLength / ETH_LENGTH_OF_ADDRESS;
            ASSERT(Adapter->MCAddressCount <= NIC_MAX_MCAST_LIST);

            //
            // Save the MC list
            //
            NdisMoveMemory(
                Adapter->MCList, 
                InformationBuffer, 
                InformationBufferLength);

            *BytesRead = InformationBufferLength;
            NdisDprAcquireSpinLock(&Adapter->Lock);
            NdisDprAcquireSpinLock(&Adapter->RcvLock);
            
            Status = NICSetMulticastList(Adapter);

            NdisDprReleaseSpinLock(&Adapter->RcvLock);
            NdisDprReleaseSpinLock(&Adapter->Lock);
            break;

        case OID_GEN_CURRENT_PACKET_FILTER:
            //
            // Verify the Length
            //
            if (InformationBufferLength != sizeof(ULONG))
            {
                return(NDIS_STATUS_INVALID_LENGTH);
            }

            *BytesRead = InformationBufferLength;

            PacketFilter = *(PULONG)InformationBuffer;

            //
            // any bits not supported?
            //
            if (PacketFilter & ~NIC_SUPPORTED_FILTERS)
            {
                return(NDIS_STATUS_NOT_SUPPORTED);
            }

            //
            // any filtering changes?
            //
            if (PacketFilter == Adapter->PacketFilter)
            {
                return(NDIS_STATUS_SUCCESS);
            }

            NdisDprAcquireSpinLock(&Adapter->Lock);
            NdisDprAcquireSpinLock(&Adapter->RcvLock);
            
            if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
            {
                ASSERT(!Adapter->bSetPending);
                Adapter->bSetPending = TRUE;
                Adapter->SetRequest.Oid = Oid;                       
                Adapter->SetRequest.InformationBuffer = InformationBuffer;                       
                Adapter->SetRequest.InformationBufferLength = InformationBufferLength;
                Adapter->SetRequest.BytesRead = BytesRead;                       
                Adapter->SetRequest.BytesNeeded = BytesNeeded;                       

                NdisDprReleaseSpinLock(&Adapter->RcvLock);
                NdisDprReleaseSpinLock(&Adapter->Lock);
                Status = NDIS_STATUS_PENDING;   
                break;
            }

            Status = NICSetPacketFilter(
                         Adapter,
                         PacketFilter);

            NdisDprReleaseSpinLock(&Adapter->RcvLock);
            NdisDprReleaseSpinLock(&Adapter->Lock);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Adapter->PacketFilter = PacketFilter;
            }

            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            //
            // Verify the Length
            //
            if (InformationBufferLength != 4)
            {
                return(NDIS_STATUS_INVALID_LENGTH);
            }

            Adapter->ulLookAhead = *(PULONG)InformationBuffer;          

            *BytesRead = 4;
            Status = NDIS_STATUS_SUCCESS;
            break;


        case OID_PNP_SET_POWER:

            DBGPRINT(MP_LOUD, ("SET: Power State change, "PTR_FORMAT"!!!\n", InformationBuffer));

            if (InformationBufferLength != sizeof(NDIS_DEVICE_POWER_STATE ))
            {
                return(NDIS_STATUS_INVALID_LENGTH);
            }

            NewPowerState = *(PNDIS_DEVICE_POWER_STATE    )InformationBuffer;

            //
            // Set the power state - Cannot fail this request
            //
            MPSetPower(Adapter ,NewPowerState );
        
            *BytesRead = sizeof(NDIS_DEVICE_POWER_STATE    );
            Status = NDIS_STATUS_SUCCESS; 
            break;

        case OID_PNP_ADD_WAKE_UP_PATTERN:
            //
            // call a function that would program the adapter's wake
            // up pattern, return success
            //
            DBGPRINT(MP_LOUD, ("SET: Add Wake Up Pattern, !!!\n"));

            if (MPIsPoMgmtSupported(Adapter) )
            {
                Status = MPAddWakeUpPattern(Adapter,InformationBuffer, InformationBufferLength); 

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    *BytesRead = InformationBufferLength;   
                }
            }
            else
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }
            break;

    
        case OID_PNP_REMOVE_WAKE_UP_PATTERN:
            DBGPRINT(MP_LOUD, ("SET: Got a WakeUpPattern REMOVE Call\n"));
            //
            // call a function that would remove the adapter's wake
            // up pattern, return success
            //
            if (MPIsPoMgmtSupported(Adapter) )
            {
                Status = MPRemoveWakeUpPattern(Adapter,InformationBuffer, InformationBufferLength );

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    *BytesRead = InformationBufferLength;
                }
            }
            else
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }
            break;

        case OID_PNP_ENABLE_WAKE_UP:
            DBGPRINT(MP_LOUD, ("SET: Got a EnableWakeUp Call, "PTR_FORMAT"\n",InformationBuffer));
            //
            // call a function that would enable wake up on the adapter
            // return success
            //
            if (MPIsPoMgmtSupported(Adapter) )
            {
                *BytesRead = InformationBufferLength;                         
                Status = NDIS_STATUS_SUCCESS; 
            }
            else
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }

            break;

            /* this OID is for showing how to work with driver specific (custom)
            OIDs and the NDIS 5 WMI interface using GUIDs
            */
        case OID_CUSTOM_DRIVER_SET:
            DBGPRINT(MP_INFO, ("OID_CUSTOM_DRIVER_SET got a set\n"));
            if (InformationBufferLength < sizeof(ULONG))
            {
                return(NDIS_STATUS_INVALID_LENGTH);
            }
            *BytesRead = 4;
            Adapter->CustomDriverSet = (ULONG) *(PULONG)(InformationBuffer);
            break;

#if OFFLOAD     
        
        case OID_TCP_TASK_OFFLOAD:
            //
            // Disable all the existing capabilities whenever task offload is updated
            //
            DisableOffload(Adapter);

            if (InformationBufferLength < sizeof(NDIS_TASK_OFFLOAD_HEADER))
            {   
                return NDIS_STATUS_INVALID_LENGTH;
            }

            *BytesRead = sizeof(NDIS_TASK_OFFLOAD_HEADER);
            //
            // Assume miniport only supports IEEE_802_3_Encapsulation 
            // Check to make sure that TCP/IP passed down the correct encapsulation type
            //
            pNdisTaskOffloadHdr = (PNDIS_TASK_OFFLOAD_HEADER)InformationBuffer;
            if (pNdisTaskOffloadHdr->EncapsulationFormat.Encapsulation != IEEE_802_3_Encapsulation)
            {
                pNdisTaskOffloadHdr->OffsetFirstTask = 0;    
                return NDIS_STATUS_FAILURE;
            }

            //
            // The length can't hold one task
            // 
            if (InformationBufferLength < 
                    (pNdisTaskOffloadHdr->OffsetFirstTask + sizeof(NDIS_TASK_OFFLOAD))) 
            {
                DBGPRINT(MP_WARN, ("response of task offload does not have sufficient space even for 1 offload task!!\n"));
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }

            //
            // Copy Encapsulation format into adapter, later the miniport may use it
            // to get Encapsulation header size
            //
            NdisMoveMemory(&(Adapter->EncapsulationFormat), 
                            &(pNdisTaskOffloadHdr->EncapsulationFormat),
                            sizeof(NDIS_ENCAPSULATION_FORMAT));
            
            ASSERT(pNdisTaskOffloadHdr->EncapsulationFormat.Flags.FixedHeaderSize == 1);
            
            //
            // Check to make sure we support the task offload requested
            //
            TaskOffload = (NDIS_TASK_OFFLOAD *) 
                          ( (PUCHAR)pNdisTaskOffloadHdr + pNdisTaskOffloadHdr->OffsetFirstTask);

            TmpOffload = TaskOffload;

            //
            // Check the task in the buffer and enable the offload capabilities
            // 
            while (TmpOffload) 
            {
                *BytesRead += FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer);
                
                switch (TmpOffload->Task)
                {
                
                case TcpIpChecksumNdisTask:
                    //
                    // Invalid information buffer length
                    // 
                    if (InformationBufferLength < *BytesRead + sizeof(NDIS_TASK_TCP_IP_CHECKSUM))
                    {
                        break;
                    }
                    //
                    //Check version 
                    //
                    for (i = 0; i < OffloadTasksCount; i++) 
                    {
                        if (OffloadTasks[i].Task == TmpOffload->Task &&
                            OffloadTasks[i].Version == TmpOffload->Version )
                        {
                            break;
                        }
                    }
                    // 
                    // Version is mismatched
                    // 
                    if (i == OffloadTasksCount) 
                    {
                         return NDIS_STATUS_NOT_SUPPORTED;
                    }
                        
                    //
                    // This miniport support TCP/IP checksum offload only with sending TCP
                    // and IP checksum with TCP/IP options. 
                    // check if the fields in NDIS_TASK_TCP_IP_CHECKSUM is set correctly
                    //
                    Adapter->NicTaskOffload.ChecksumOffload = 1;
                    
                    pTcpIpChecksumTask = (PNDIS_TASK_TCP_IP_CHECKSUM) TmpOffload->TaskBuffer;

                    if (pTcpIpChecksumTask->V4Transmit.TcpChecksum) 
                    {   
                        //
                        // If miniport doesn't support sending TCP checksum, we can't enable
                        // this capability
                        // 
                        if (TcpIpChecksumTask.V4Transmit.TcpChecksum == 0 )
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        
                        DBGPRINT (MP_WARN, ("Set Sending TCP offloading.\n"));    
                        //
                        // Enable sending TCP checksum
                        //
                        Adapter->NicChecksumOffload.DoXmitTcpChecksum = 1;
                    }

                    //
                    // left for recieve and other IP and UDP checksum offload
                    //
                    if (pTcpIpChecksumTask->V4Transmit.IpChecksum) 
                    {
                        //
                        // If the miniport doesn't support sending IP checksum, we can't enable
                        // this capabilities
                        // 
                        if (TcpIpChecksumTask.V4Transmit.IpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        
                        DBGPRINT (MP_WARN, ("Set Sending IP offloading.\n"));    
                        //
                        // Enable sending IP checksum
                        //
                        Adapter->NicChecksumOffload.DoXmitIpChecksum = 1;
                    }
                    if (pTcpIpChecksumTask->V4Receive.TcpChecksum)
                    {
                        //
                        // If the miniport doesn't support receiving TCP checksum, we can't
                        // enable this capability
                        // 
                        if (TcpIpChecksumTask.V4Receive.TcpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        DBGPRINT (MP_WARN, ("Set recieve TCP offloading.\n"));    
                        //
                        // Enable recieving TCP checksum
                        //
                        Adapter->NicChecksumOffload.DoRcvTcpChecksum = 1;
                    }
                    if (pTcpIpChecksumTask->V4Receive.IpChecksum)
                    {
                        //
                        // If the miniport doesn't support receiving IP checksum, we can't
                        // enable this capability
                        //
                        if (TcpIpChecksumTask.V4Receive.IpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        DBGPRINT (MP_WARN, ("Set Recieve IP offloading.\n"));    
                        //
                        // Enable recieving IP checksum
                        //
                        Adapter->NicChecksumOffload.DoRcvIpChecksum = 1;
                    }

                    if (pTcpIpChecksumTask->V4Transmit.UdpChecksum) 
                    {
                        //
                        // If the miniport doesn't support sending UDP checksum, we can't
                        // enable this capability
                        // 
                        if (TcpIpChecksumTask.V4Transmit.UdpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        
                        DBGPRINT (MP_WARN, ("Set Sending UDP offloading.\n"));    
                        //
                        // Enable sending UDP checksum
                        //
                        Adapter->NicChecksumOffload.DoXmitUdpChecksum = 1;
                    }
                    if (pTcpIpChecksumTask->V4Receive.UdpChecksum)
                    {
                        //
                        // IF the miniport doesn't support receiving UDP checksum, we can't
                        // enable this capability
                        // 
                        if (TcpIpChecksumTask.V4Receive.UdpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        DBGPRINT (MP_WARN, ("Set recieve UDP offloading.\n"));    
                        //
                        // Enable receiving UDP checksum
                        //
                        Adapter->NicChecksumOffload.DoRcvUdpChecksum = 1;
                    }
                    // 
                    // check for V6 setting, because this miniport doesn't support any of
                    // checksum offload for V6, so we just return NDIS_STATUS_NOT_SUPPORTED
                    // if the protocol tries to set these capabilities
                    //
                    if (pTcpIpChecksumTask->V6Transmit.TcpChecksum
                            || pTcpIpChecksumTask->V6Transmit.UdpChecksum
                            || pTcpIpChecksumTask->V6Receive.TcpChecksum
                            || pTcpIpChecksumTask->V6Receive.UdpChecksum)
                    {
                        return NDIS_STATUS_NOT_SUPPORTED;
                    }
                    
                    *BytesRead += sizeof(NDIS_TASK_TCP_IP_CHECKSUM);
                    break;

                case TcpLargeSendNdisTask: 
                    //
                    // Invalid information buffer length
                    // 
                    if (InformationBufferLength < *BytesRead + sizeof(NDIS_TASK_TCP_LARGE_SEND))
                    {
                        break;
                    }
                    //
                    // Check version
                    // 
                    for (i = 0; i < OffloadTasksCount; i++) 
                    {
                        if (OffloadTasks[i].Task == TmpOffload->Task &&
                            OffloadTasks[i].Version == TmpOffload->Version )
                        {
                            break;
                        }
                    }
                    if (i == OffloadTasksCount) 
                    {
                         return NDIS_STATUS_NOT_SUPPORTED;
                    }

                        
                    pNdisTaskTcpLargeSend = (PNDIS_TASK_TCP_LARGE_SEND) TmpOffload->TaskBuffer;

                    //
                    // Check maximum offload size, if the size is greater than the maximum
                    // size of the miniport can handle, return NDIS_STATUS_NOT_SUPPORTED.
                    //
                    if (pNdisTaskTcpLargeSend->MaxOffLoadSize > TcpLargeSendTask.MaxOffLoadSize
                        || pNdisTaskTcpLargeSend->MinSegmentCount < TcpLargeSendTask.MinSegmentCount)
                    {
                        return NDIS_STATUS_NOT_SUPPORTED;
                    }
                    
                    //
                    // If the miniport doesn't support TCP or IP options, but the protocol
                    // is setting such information, return NDIS_STATUS_NOT_SUPPORTED.
                    // 
                    if ((pNdisTaskTcpLargeSend->TcpOptions && !TcpLargeSendTask.TcpOptions)
                            || (pNdisTaskTcpLargeSend->IpOptions && !TcpLargeSendTask.IpOptions))
                    {
                        return NDIS_STATUS_NOT_SUPPORTED;
                    }
                    //
                    // Store the valid setting information into adapter
                    // 
                    Adapter->LargeSendInfo.MaxOffLoadSize = pNdisTaskTcpLargeSend->MaxOffLoadSize;
                    Adapter->LargeSendInfo.MinSegmentCount = pNdisTaskTcpLargeSend->MinSegmentCount;

                    Adapter->LargeSendInfo.TcpOptions = pNdisTaskTcpLargeSend->TcpOptions;
                    Adapter->LargeSendInfo.IpOptions = pNdisTaskTcpLargeSend->IpOptions;

                    //
                    // Everythins is OK, enable large send offload capabilities
                    // 
                    Adapter->NicTaskOffload.LargeSendOffload = 1;
                    
                    *BytesRead += sizeof(NDIS_TASK_TCP_LARGE_SEND);
                    break;

                default:
                    //
                    // Because this miniport doesn't implement IPSec offload, so it doesn't
                    // support IPSec offload. Tasks other then these 3 task are not supported
                    // 
                    return NDIS_STATUS_NOT_SUPPORTED;
                }

                //
                // Go on to the next offload structure
                //
                if (TmpOffload->OffsetNextTask) 
                {
                    TmpOffload = (PNDIS_TASK_OFFLOAD)
                                 ((PUCHAR) TmpOffload + TmpOffload->OffsetNextTask);
                }
                else 
                {
                    TmpOffload = NULL;
                }

            } // while

            break;
#endif

        // Used temporarily for Packet Wakeup. DELETE                
        case OID_GEN_NETWORK_LAYER_ADDRESSES:

            Status = MPSetNetworkAddress(Adapter, InformationBuffer, InformationBufferLength, BytesRead, BytesNeeded);
            


        default:
            Status = NDIS_STATUS_INVALID_OID;
            break;

    }

    if (Status == NDIS_STATUS_SUCCESS)
    {
        *BytesRead = InformationBufferLength;
    }

    DBGPRINT(MP_TRACE, ("<==== MPSetInformationSet, OID=0x%08x, Status=%x\n", Oid, Status));

    return(Status);
}


VOID
MPSetPowerD0(
    PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    This routine is called when the adapter receives a SetPower 
    to D0.
    
Arguments:
    
    Adapter                 Pointer to the adapter structure
    PowerState              NewPowerState
    
Return Value:

    
--*/
{

    MPSetPowerD0Private (Adapter);       
    Adapter->CurrentPowerState = NdisDeviceStateD0;
}

VOID
MPSetPowerLow(
    PMP_ADAPTER              Adapter ,
    NDIS_DEVICE_POWER_STATE  PowerState 
    )
/*++
Routine Description:

    This routine is called when the adapter receives a SetPower 
    to a PowerState > D0
    
Arguments:
    
    Adapter                 Pointer to the adapter structure
    PowerState              NewPowerState
    
Return Value:

    
--*/
{

    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    do
    {
        Adapter->NextPowerState = PowerState;

        //        
        // Stop sending packets. Create a new flag and make it part 
        // of the Send Fail Mask
        //

        //
        // Stop hardware from receiving packets - Set the RU to idle 
        //
        
        //
        // Check the current status of the receive unit
        //
        if ((Adapter->CSRAddress->ScbStatus & SCB_RUS_MASK) != SCB_RUS_IDLE)
        {
            //
            // Issue an RU abort.  Since an interrupt will be issued, the
            // RU will be started by the DPC.
            //
            Status = D100IssueScbCommand(Adapter, SCB_RUC_ABORT, TRUE);
        }

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Wait for outstanding Receive packets
        //
        while (Adapter->PoMgmt.OutstandingRecv != 0)
        {
            //
            // Sleep for 2 Ms;
            //
            NdisMSleep (2000);
        }

        //
        // Wait for all incoming sends to complete
        //

        //
        // Start Hardware specific part of the transition to low power state
        // Setting up wake-up patterns, filters, wake-up events etc
        //
        NdisMSynchronizeWithInterrupt(
                &Adapter->Interrupt,
                MPSetPowerLowPrivate,
                Adapter);

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return;
}


VOID
MPSetPower(
    PMP_ADAPTER     Adapter ,
    NDIS_DEVICE_POWER_STATE   PowerState 
    )
/*++
Routine Description:

    This routine is called when the adapter receives a SetPower 
    request. It redirects the call to an appropriate routine to
    Set the New PowerState
    
Arguments:
    
    Adapter                 Pointer to the adapter structure
    PowerState              NewPowerState
    
Return Value:

    
--*/
{
    if (PowerState == NdisDeviceStateD0)
    {
        MPSetPowerD0 (Adapter);
    }
    else
    {
        MPSetPowerLow (Adapter, PowerState);
    }
}




VOID
MPFillPoMgmtCaps (
    IN PMP_ADAPTER                 pAdapter, 
    IN OUT PNDIS_PNP_CAPABILITIES  pPower_Management_Capabilities, 
    IN OUT PNDIS_STATUS            pStatus,
    IN OUT PULONG                  pulInfoLen
    )
/*++
Routine Description:

    Fills in the Power  Managment structure depending the capabilities of 
    the software driver and the card.

    Currently this is only supported on 82559 Version of the driver

Arguments:
    
    Adapter                 Pointer to the adapter structure
    pPower_Management_Capabilities - Power management struct as defined in the DDK, 
    pStatus                 Status to be returned by the request,
    pulInfoLen              Length of the pPowerManagmentCapabilites
    
Return Value:

    Success or failure depending on the type of card
--*/

{

    BOOLEAN bIsPoMgmtSupported; 
    
    bIsPoMgmtSupported = MPIsPoMgmtSupported(pAdapter);

    if (bIsPoMgmtSupported == TRUE)
    {
        pPower_Management_Capabilities->Flags = NDIS_DEVICE_WAKE_UP_ENABLE ;
        pPower_Management_Capabilities->WakeUpCapabilities.MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
        pPower_Management_Capabilities->WakeUpCapabilities.MinPatternWakeUp = NdisDeviceStateD3;
        pPower_Management_Capabilities->WakeUpCapabilities.MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;
        *pulInfoLen = sizeof (*pPower_Management_Capabilities);
        *pStatus = NDIS_STATUS_SUCCESS;
    }
    else
    {
        NdisZeroMemory (pPower_Management_Capabilities, sizeof(*pPower_Management_Capabilities));
        *pStatus = NDIS_STATUS_NOT_SUPPORTED;
        *pulInfoLen = 0;
            
    }
}

NDIS_STATUS
MPAddWakeUpPattern(
    IN PMP_ADAPTER  pAdapter,
    IN PVOID        InformationBuffer, 
    IN UINT         InformationBufferLength
    )
/*++
Routine Description:

    This routine will allocate a local memory structure, copy the pattern, 
    insert the pattern into a linked list and return success

    We are gauranteed that we wll get only one request at a time, so this is implemented
    without locks.
    
Arguments:
    
    Adapter                 Adapter structure
    InformationBuffer       Wake up Pattern
    InformationBufferLength Wake Up Pattern Length
    
Return Value:

    Success - if successful.
    NDIS_STATUS_FAILURE - if memory allocation fails. 
    
--*/
{

    NDIS_STATUS         Status = NDIS_STATUS_FAILURE;
    PMP_WAKE_PATTERN    pWakeUpPattern = NULL;
    UINT                AllocationLength = 0;
    PNDIS_PM_PACKET_PATTERN pPmPattern = NULL;
    ULONG               Signature = 0;
    
    do
    {
        pPmPattern = (PNDIS_PM_PACKET_PATTERN) InformationBuffer;

        //
        // Calculate the e100 signature
        //
        Status = MPCalculateE100PatternForFilter (
            (PUCHAR)pPmPattern+ pPmPattern->PatternOffset,
            pPmPattern->PatternSize,
            (PUCHAR)pPmPattern +sizeof(NDIS_PM_PACKET_PATTERN),
            pPmPattern->MaskSize,
            &Signature );
        
        if ( Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Allocate the memory to hold the WakeUp Pattern
        //
        AllocationLength = sizeof (MP_WAKE_PATTERN) + InformationBufferLength;
        
        Status = NdisAllocateMemoryWithTag( &pWakeUpPattern, 
                                            AllocationLength ,
                                            NIC_TAG );

        if (Status != NDIS_STATUS_SUCCESS)
        {
            pWakeUpPattern = NULL;
            break;
        }

        //
        // Initialize pWakeUpPattern
        //
        NdisZeroMemory (pWakeUpPattern, AllocationLength);

        pWakeUpPattern->AllocationSize = AllocationLength;
        
        pWakeUpPattern->Signature = Signature;

        //
        // Copy the pattern into local memory
        //
        NdisMoveMemory (&pWakeUpPattern->Pattern[0],InformationBuffer, InformationBufferLength);
            
        //
        // Insert the pattern into the list 
        //
        NdisInterlockedInsertHeadList (&pAdapter->PoMgmt.PatternList, 
                                        &pWakeUpPattern->linkListEntry, 
                                        &pAdapter->Lock);

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return Status;
}

NDIS_STATUS
MPRemoveWakeUpPattern(
    IN PMP_ADAPTER  pAdapter,
    IN PVOID        InformationBuffer, 
    IN UINT         InformationBufferLength
    )
/*++
Routine Description:

    This routine will walk the list of wake up pattern and attempt to match the wake up pattern. 
    If it finds a copy , it will remove that WakeUpPattern     

Arguments:
    
    Adapter                 Adapter structure
    InformationBuffer       Wake up Pattern
    InformationBufferLength Wake Up Pattern Length
    
Return Value:

    Success - if successful.
    NDIS_STATUS_FAILURE - if memory allocation fails. 
    
--*/
{

    NDIS_STATUS              Status = NDIS_STATUS_FAILURE;
    PNDIS_PM_PACKET_PATTERN  pReqPattern = (PNDIS_PM_PACKET_PATTERN)InformationBuffer;
    PLIST_ENTRY              pPatternEntry = ListNext(&pAdapter->PoMgmt.PatternList) ;
    
    while (pPatternEntry != (&pAdapter->PoMgmt.PatternList))
    {
        BOOLEAN                  bIsThisThePattern = FALSE;
        PMP_WAKE_PATTERN         pWakeUpPattern = NULL;
        PNDIS_PM_PACKET_PATTERN  pCurrPattern = NULL;;

        //
        // initialize local variables
        //
        pWakeUpPattern = CONTAINING_RECORD(pPatternEntry, MP_WAKE_PATTERN, linkListEntry);

        pCurrPattern = (PNDIS_PM_PACKET_PATTERN)&pWakeUpPattern->Pattern[0];

        //
        // increment the iterator
        //
        pPatternEntry = ListNext (pPatternEntry);

        //
        // Begin Check : Is (pCurrPattern  == pReqPattern) 
        //
        bIsThisThePattern = MPAreTwoPatternsEqual (pReqPattern, pCurrPattern);

        if (bIsThisThePattern == TRUE)
        {
            //
            // we have a match - remove the entry
            //
            RemoveEntryList (&pWakeUpPattern->linkListEntry);

            //
            // Free the entry
            //
            NdisFreeMemory (pWakeUpPattern, pWakeUpPattern->AllocationSize, 0);
            
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

    } 
    
    return Status;
}



VOID
MPRemoveAllWakeUpPatterns(
    PMP_ADAPTER pAdapter
    )
/*++
Routine Description:

    This routine will walk the list of wake up pattern and free it 

Arguments:
    
    Adapter                 Adapter structure
    
Return Value:

    Success - if successful.
    
--*/
{

    PLIST_ENTRY  pPatternEntry = ListNext(&pAdapter->PoMgmt.PatternList) ;
    
    while (pPatternEntry != (&pAdapter->PoMgmt.PatternList))
    {
        PMP_WAKE_PATTERN  pWakeUpPattern = NULL;

        //
        // initialize local variables
        //
        pWakeUpPattern = CONTAINING_RECORD(pPatternEntry, MP_WAKE_PATTERN,linkListEntry);

        //
        // increment the iterator
        //
        pPatternEntry = ListNext (pPatternEntry);
       
        //
        // Remove the entry from the list
        //
        RemoveEntryList (&pWakeUpPattern->linkListEntry);

        //
        // Free the memory
        //
        NdisFreeMemory (pWakeUpPattern, pWakeUpPattern->AllocationSize, 0);
    } 
}

BOOLEAN 
MPAreTwoPatternsEqual (
    PNDIS_PM_PACKET_PATTERN pNdisPattern1,
    PNDIS_PM_PACKET_PATTERN pNdisPattern2
    )
/*++
Routine Description:

    This routine will compare two wake up patterns to see if they are equal

Arguments:
    
    pNdisPattern1 - Pattern1 
    pNdisPattern2 - Pattern 2
    
Return Value:

    True - if patterns are equal
    False - Otherwise
--*/
{
    BOOLEAN bEqual = FALSE;

    // Local variables used later in the compare section of this function
    PUCHAR  pMask1, pMask2;
    PUCHAR  pPattern1, pPattern2;
    UINT    MaskSize, PatternSize;

    do
    {
        bEqual = (pNdisPattern1->Priority == pNdisPattern2->Priority);

        if (bEqual == FALSE)
        {
            break;
        }

        bEqual = (pNdisPattern1->MaskSize == pNdisPattern2->MaskSize);
        if (bEqual == FALSE)
        {
            break;
        }

        //
        // Verify the Mask 
        //
        MaskSize = pNdisPattern1->MaskSize ; 
        pMask1 = (PUCHAR) pNdisPattern1 + sizeof (NDIS_PM_PACKET_PATTERN);
        pMask2 = (PUCHAR) pNdisPattern2 + sizeof (NDIS_PM_PACKET_PATTERN);
        
        bEqual = NdisEqualMemory (pMask1, pMask2, MaskSize);

        if (bEqual == FALSE)
        {
            break;
        }

        //
        // Verify the Pattern
        //
        bEqual = (pNdisPattern1->PatternSize == pNdisPattern2->PatternSize);
        
        if (bEqual == FALSE)
        {
            break;
        }

        PatternSize = pNdisPattern2->PatternSize;
        pPattern1 = (PUCHAR) pNdisPattern1 + pNdisPattern1->PatternOffset;
        pPattern2 = (PUCHAR) pNdisPattern2 + pNdisPattern2->PatternOffset;
        
        bEqual  = NdisEqualMemory (pPattern1, pPattern2, PatternSize );

        if (bEqual == FALSE)
        {
            break;
        }

    } while (FALSE);

    return bEqual;
}


NDIS_STATUS 
MPSetNetworkAddress(
    IN PMP_ADAPTER  pAdapter, 
    IN PVOID        InformationBuffer, 
    IN ULONG        InformationBufferLength, 
    IN PULONG       BytesRead,
    IN PULONG       BytesNeeded
    )
/*++

Routine Description:

    Called when the protocol above us wants to let us know about
    the network address(es) assigned to this interface. 
    . We pick the first IP address given to us.

Arguments:

    pAdapter                   - Pointer to the ELAN

    InformationBuffer       - Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead               - If the call is successful, returns the number
                              of bytes read from InformationBuffer.

    BytesNeeded             - If there is not enough data in InformationBuffer
                              to satisfy the OID, returns the amount of storage
                              needed.

Return Value:

--*/
{
    NETWORK_ADDRESS_LIST UNALIGNED *  pAddrList = NULL;
    NETWORK_ADDRESS UNALIGNED *       pAddr = NULL;
    NETWORK_ADDRESS_IP UNALIGNED *    pIpAddr= NULL;
    ULONG                             Size;
    NDIS_STATUS                       Status;

    //
    //  Initialize.
    //
    *BytesRead = 0;
    Status = NDIS_STATUS_SUCCESS;

    pAddrList = (NETWORK_ADDRESS_LIST UNALIGNED *)InformationBuffer;

    do
    {
        *BytesNeeded = sizeof(*pAddrList) -
                        FIELD_OFFSET(NETWORK_ADDRESS_LIST, Address) +
                        sizeof(NETWORK_ADDRESS) -
                        FIELD_OFFSET(NETWORK_ADDRESS, Address);

        if (InformationBufferLength < *BytesNeeded)
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (pAddrList->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
        {
            // Not interesting.
            break;
        }

        if (pAddrList->AddressCount <= 0)
        {
            Status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        pAddr = (NETWORK_ADDRESS UNALIGNED *)&pAddrList->Address[0];

        if ((pAddr->AddressLength > InformationBufferLength - *BytesNeeded) ||
            (pAddr->AddressLength == 0))
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        if (pAddr->AddressType != NDIS_PROTOCOL_ID_TCP_IP)
        {
            // Not interesting.
            break;
        }

        if (pAddr->AddressLength < sizeof(NETWORK_ADDRESS_IP))
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }
        
        pIpAddr = (NETWORK_ADDRESS_IP UNALIGNED *)&pAddr->Address[0];

        Size = sizeof(pIpAddr->in_addr);

        //
        //  Copy the network address in.
        //
        NdisMoveMemory(&pAdapter->PoMgmt.IPAddress.u32 , &pIpAddr->in_addr, sizeof(pIpAddr->in_addr));

        Status = NDIS_STATUS_SUCCESS;
        
        *BytesRead = InformationBufferLength;

    } while (FALSE);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_nic.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_nic.h

Abstract:
    Function prototypes for mp_nic.c, mp_init.c and mp_req.c

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#ifndef _MP_NIC_H
#define _MP_NIC_H

#define NIC_INTERRUPT_DISABLED(_adapter) \
   (_adapter->CSRAddress->ScbCommandHigh & SCB_INT_MASK)
   
#define NIC_INTERRUPT_ACTIVE(_adapter) \
   (_adapter->CSRAddress->ScbStatus & SCB_ACK_MASK)

#define NIC_ACK_INTERRUPT(_adapter, _value) { \
   _value = _adapter->CSRAddress->ScbStatus & SCB_ACK_MASK; \
   _adapter->CSRAddress->ScbStatus = _value; }        

#define NIC_IS_RECV_READY(_adapter) \
    ((_adapter->CSRAddress->ScbStatus & SCB_RUS_MASK) == SCB_RUS_READY)
    
__inline VOID NICDisableInterrupt(
    IN PMP_ADAPTER Adapter)
{
   Adapter->CSRAddress->ScbCommandHigh = SCB_INT_MASK;
}

__inline VOID NICEnableInterrupt(
    IN PMP_ADAPTER Adapter)
{
    Adapter->CSRAddress->ScbCommandHigh = 0;
}
    

//
//  MP_NIC.C
//                    
NDIS_STATUS MpSendPacket(
    IN  PMP_ADAPTER     Adapter,
    IN  PNDIS_PACKET    Packet,
    IN  BOOLEAN         bFromQueue);
   
NDIS_STATUS NICSendPacket(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_TCB         pMpTcb,
    IN  PMP_FRAG_LIST   pFragList);
                                
ULONG MpCopyPacket(
    IN  PNDIS_BUFFER    CurrBuffer,
    IN  PMP_TXBUF       pMpTxbuf); 

VOID MpStartPacketPhysicalMapping(
    IN  PMP_ADAPTER     Adapter, 
    IN  PNDIS_BUFFER    CurrBuffer,
    OUT PMP_FRAG_LIST   pFragList);
       
NDIS_STATUS NICStartSend(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_TCB         pMpTcb);
   
NDIS_STATUS MpHandleSendInterrupt(
    IN  PMP_ADAPTER     Adapter);
                   
VOID MpHandleRecvInterrupt(
    IN  PMP_ADAPTER     Adapter);
   
VOID NICReturnRFD(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_RFD         pMpRfd);
   
NDIS_STATUS NICStartRecv(
    IN  PMP_ADAPTER     Adapter);

VOID MpFreeQueuedSendPackets(
    IN  PMP_ADAPTER     Adapter);

void MpFreeBusySendPackets(
    IN  PMP_ADAPTER     Adapter);
                            
void NICResetRecv(
    IN  PMP_ADAPTER     Adapter);

VOID MpLinkDetectionDpc(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       FunctionContext,
    IN  PVOID       SystemSpecific2, 
    IN  PVOID       SystemSpecific3);

//
// MP_INIT.C
//                  
      
NDIS_STATUS MpFindAdapter(
    IN  PMP_ADAPTER     Adapter,
    IN  NDIS_HANDLE     WrapperConfigurationContext);

NDIS_STATUS NICReadAdapterInfo(
    IN  PMP_ADAPTER     Adapter);
              
NDIS_STATUS MpAllocAdapterBlock(
    OUT  PMP_ADAPTER    *pAdapter);
    
void MpFreeAdapter(
    IN  PMP_ADAPTER     Adapter);
                                         
NDIS_STATUS NICReadRegParameters(
    IN  PMP_ADAPTER     Adapter,
    IN  NDIS_HANDLE     WrapperConfigurationContext);
                                              
NDIS_STATUS NICAllocAdapterMemory(
    IN  PMP_ADAPTER     Adapter);
   
VOID NICInitSend(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS NICInitRecv(
    IN  PMP_ADAPTER     Adapter);

ULONG NICAllocRfd(
    IN  PMP_ADAPTER     Adapter, 
    IN  PMP_RFD         pMpRfd);
    
VOID NICFreeRfd(
    IN  PMP_ADAPTER     Adapter, 
    IN  PMP_RFD         pMpRfd);
   
NDIS_STATUS NICSelfTest(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS NICInitializeAdapter(
    IN  PMP_ADAPTER     Adapter);

VOID HwSoftwareReset(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS HwConfigure(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS HwSetupIAAddress(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS HwClearAllCounters(
    IN  PMP_ADAPTER     Adapter);

//
// MP_REQ.C
//                  
    
NDIS_STATUS NICGetStatsCounters(
    IN  PMP_ADAPTER     Adapter, 
    IN  NDIS_OID        Oid,
    OUT PULONG64        pCounter);
    
NDIS_STATUS NICSetPacketFilter(
    IN  PMP_ADAPTER     Adapter,
    IN  ULONG           PacketFilter);

NDIS_STATUS NICSetMulticastList(
    IN  PMP_ADAPTER     Adapter);
    
ULONG NICGetMediaConnectStatus(
    IN  PMP_ADAPTER     Adapter);
    


                    
#endif  // MP_NIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\mp_nic.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_nic.c

Abstract:
    This module contains miniport send/receive routines

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"

#if DBG
#define _FILENUMBER     'CINM'
#endif

__inline VOID MP_FREE_SEND_PACKET(
    IN  PMP_ADAPTER Adapter,
    IN  PMP_TCB     pMpTcb
    )
/*++
Routine Description:

    Recycle a MP_TCB and complete the packet if necessary
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpTcb      Pointer to MP_TCB        

Return Value:

    None

--*/
{
    
    PNDIS_PACKET  Packet;
    PNDIS_BUFFER  CurrBuffer;

    ASSERT(MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));

    Packet = pMpTcb->Packet;
    pMpTcb->Packet = NULL;
    pMpTcb->Count = 0;

    if (pMpTcb->MpTxBuf)
    {
        ASSERT(MP_TEST_FLAG(pMpTcb, fMP_TCB_USE_LOCAL_BUF));

        PushEntryList(&Adapter->SendBufList, &pMpTcb->MpTxBuf->SList);
        pMpTcb->MpTxBuf = NULL;
    }
    else if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER))
    {
        //
        // Complete physical mapping for each buffer in this packet
        //
        ASSERT(Packet);

        CurrBuffer = pMpTcb->FirstBuffer;
        while (CurrBuffer)
        {
            NdisMCompleteBufferPhysicalMapping(
                Adapter->AdapterHandle,
                CurrBuffer,
                Adapter->CurrMapRegHead);

            Adapter->CurrMapRegHead++;
            if (Adapter->CurrMapRegHead == (ULONG)Adapter->NumTbd)
                Adapter->CurrMapRegHead = 0;

            //
            // Get the next buffer
            //
            NdisGetNextBuffer(CurrBuffer, &CurrBuffer);
        }
    }

    MP_CLEAR_FLAGS(pMpTcb);

    Adapter->CurrSendHead = Adapter->CurrSendHead->Next;
    Adapter->nBusySend--;
    ASSERT(Adapter->nBusySend >= 0);

    if (Packet)
    {
        NdisReleaseSpinLock(&Adapter->SendLock);
        DBGPRINT(MP_TRACE, ("Calling NdisMSendComplete, Pkt= "PTR_FORMAT"\n", Packet));
        NdisMSendComplete(
            MP_GET_ADAPTER_HANDLE(Adapter),
            Packet,
            NDIS_STATUS_SUCCESS);

        NdisAcquireSpinLock(&Adapter->SendLock);
    }
}

NDIS_STATUS MpSendPacket(
    IN  PMP_ADAPTER   Adapter,
    IN  PNDIS_PACKET  Packet,
    IN  BOOLEAN       bFromQueue
    )
/*++
Routine Description:

    Do the work to send a packet
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    Packet      The packet
    bFromQueue  TRUE if it's taken from the send wait queue

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING         Put into the send wait queue
    NDIS_STATUS_HARD_ERRORS

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_PENDING;
    NDIS_STATUS     SendStatus;
    PMP_TCB         pMpTcb = NULL;
    PMP_TXBUF       pMpTxBuf = NULL;
    ULONG           BytesCopied;
    BOOLEAN         bCompletePacket = FALSE;
    
    // Mimiced frag list if map registers are used, on the local stack as it's not so big                                         
    MP_FRAG_LIST    FragList;
    
    // Pointer to either the scatter gather or the local mimiced frag list
    PMP_FRAG_LIST   pFragList;

    DBGPRINT(MP_TRACE, ("--> MpSendPacket, Pkt= "PTR_FORMAT"\n", Packet));

    pMpTcb = Adapter->CurrSendTail;
    ASSERT(!MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));

    NdisQueryPacket(
        Packet,
        &pMpTcb->PhysBufCount,
        &pMpTcb->BufferCount,
        &pMpTcb->FirstBuffer,
        &pMpTcb->PacketLength);

    ASSERT(pMpTcb->PhysBufCount);
    ASSERT(pMpTcb->FirstBuffer);
    ASSERT(pMpTcb->PacketLength);

    //
    // Check to see if we need to coalesce
    //
    if (pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE ||
        pMpTcb->PhysBufCount > NIC_MAX_PHYS_BUF_COUNT)
    {
        //
        // A local MP_TXBUF available (for local data copying)?
        //
        if (IsSListEmpty(&Adapter->SendBufList))
        {
            Adapter->nWaitSend++;
            if (bFromQueue)
            {
                InsertHeadQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(Packet));
            }
            else
            {
                InsertTailQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(Packet));
            }

            DBGPRINT(MP_TRACE, ("<-- MpSendPacket - queued, no buf\n"));
            return Status;
        }

        pMpTxBuf = (PMP_TXBUF) PopEntryList(&Adapter->SendBufList);   
        ASSERT(pMpTxBuf);

        //
        // Copy the buffers in this packet, enough to give the first buffer as they are linked
        //
        BytesCopied = MpCopyPacket(pMpTcb->FirstBuffer, pMpTxBuf);
        
#ifdef NDIS51_MINIPORT
        //
        // MpCopyPacket may return 0 if system resources are low or exhausted
        //
        if (BytesCopied == 0)
        {
            PushEntryList(&Adapter->SendBufList, &pMpTxBuf->SList);
        
            DBGPRINT(MP_ERROR, ("Calling NdisMSendComplete with NDIS_STATUS_RESOURCES, Pkt= "PTR_FORMAT"\n", Packet));
    
            NdisReleaseSpinLock(&Adapter->SendLock); 
            NdisMSendComplete(
                MP_GET_ADAPTER_HANDLE(Adapter),
                Packet,
                NDIS_STATUS_RESOURCES);
    
            NdisAcquireSpinLock(&Adapter->SendLock);  
            return NDIS_STATUS_RESOURCES;            
        }
#endif

        pMpTcb->MpTxBuf = pMpTxBuf; 

        //
        // Set up the frag list, only one fragment after it's coalesced
        //
        pFragList = &FragList;
        pFragList->NumberOfElements = 1;
        pFragList->Elements[0].Address = pMpTxBuf->BufferPa;
        pFragList->Elements[0].Length = (BytesCopied >= NIC_MIN_PACKET_SIZE) ? 
                                        BytesCopied : NIC_MIN_PACKET_SIZE;
        //
        // we can complete it from this routine because it's copied
        //
        bCompletePacket = TRUE;
        pMpTcb->Packet = NULL;
        MP_SET_FLAG(pMpTcb, fMP_TCB_USE_LOCAL_BUF);
    }
    else
    {
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_SCATTER_GATHER))
        {
            //
            // In scatter/gather case, use the frag list pointer saved 
            // in the packet info field
            //
            pFragList = (PMP_FRAG_LIST) NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, 
                                                           ScatterGatherListPacketInfo);
        }
        else
        {
            //
            // In the map register case, use the local frag list structure
            //
            pFragList = &FragList;

            //
            // Do the physical mapping to get all the fragment physical addresses
            //
            MpStartPacketPhysicalMapping(
                Adapter, 
                pMpTcb->FirstBuffer,
                pFragList);
        }

        pMpTcb->Packet = Packet;
    }

    MP_SET_FLAG(pMpTcb, fMP_TCB_IN_USE);

    //
    // Call the NIC specific send handler, it only needs to deal with the frag list
    //
    Status = NICSendPacket(Adapter, pMpTcb, pFragList);

    Adapter->nBusySend++;
    ASSERT(Adapter->nBusySend <= Adapter->NumTcb);
    Adapter->CurrSendTail = Adapter->CurrSendTail->Next;

    if (bCompletePacket)
    {
        DBGPRINT(MP_TRACE, ("Calling NdisMSendComplete, Pkt= "PTR_FORMAT"\n", Packet));

        NdisReleaseSpinLock(&Adapter->SendLock);  

        NdisMSendComplete( MP_GET_ADAPTER_HANDLE(Adapter), Packet, Status);

        NdisAcquireSpinLock(&Adapter->SendLock);   
    }

    DBGPRINT(MP_TRACE, ("<-- MpSendPacket\n"));
    return Status;

}  

ULONG MpCopyPacket(
    IN  PNDIS_BUFFER  CurrBuffer,
    IN  PMP_TXBUF     pMpTxBuf
    ) 
/*++
Routine Description:

    Copy the packet data to a local buffer
    Either the packet is too small or it has too many fragments
    Assumption: Send spinlock has been acquired 

Arguments:

    CurrBuffer  Pointer to the first NDIS_BUFFER    
    pMpTxBuf    Pointer to the local buffer (MP_TXBUF)

Return Value:

    Bytes copied

--*/
{
    UINT    CurrLength;
    PUCHAR  pSrc;
    PUCHAR  pDest;
    UINT    BytesCopied = 0;

    DBGPRINT(MP_TRACE, ("--> MpCopyPacket\n"));

    pDest = pMpTxBuf->pBuffer;

    while (CurrBuffer)
    {

#ifdef NDIS51_MINIPORT
        NdisQueryBufferSafe( CurrBuffer, &pSrc, &CurrLength, NormalPagePriority );
        if (pSrc == NULL)
        {
            return 0;
        }
#else
        NdisQueryBuffer( CurrBuffer, &pSrc, &CurrLength );
#endif            

        if (CurrLength)
        {
            //
            // Copy the data.
            //
            NdisMoveMemory(pDest, pSrc, CurrLength);
            BytesCopied += CurrLength;
            pDest += CurrLength;
        }

        NdisGetNextBuffer( CurrBuffer, &CurrBuffer);
    }
    
    //
    // Zero out the padding bytes
    //
    if (BytesCopied < NIC_MIN_PACKET_SIZE)
    {
        NdisZeroMemory(pDest, NIC_MIN_PACKET_SIZE - BytesCopied);
    }
    

    NdisAdjustBufferLength(pMpTxBuf->NdisBuffer, BytesCopied);

    NdisFlushBuffer(pMpTxBuf->NdisBuffer, TRUE);

    ASSERT(BytesCopied <= pMpTxBuf->BufferSize);

    DBGPRINT(MP_TRACE, ("<-- MpCopyPacket\n"));

    return BytesCopied;
}

VOID MpStartPacketPhysicalMapping(
    IN  PMP_ADAPTER     Adapter, 
    IN  PNDIS_BUFFER    CurrBuffer,
    OUT PMP_FRAG_LIST   pFragList
    )
/*++
Routine Description:

    Call NdisMStartBufferPhysicalMapping on each NDIS buffer
    Get the physical address for each fragment and save them in the fragment list
    We use the same fragment list as the scatter gather so the driver writers only need
    to deal one type. 
    Assumption: spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    CurrBuffer  Pointer to the first NDIS_BUFFER    
    pFragList   The pointer to the frag list to be filled

Return Value:

    None

--*/
{
    NDIS_PHYSICAL_ADDRESS_UNIT PhysAddrUnits[NIC_MAX_PHYS_BUF_COUNT];   
    UINT            ArraySize, i;
    ULONG           ElementIndex = 0;

    DBGPRINT(MP_TRACE, ("--> MpStartPacketPhysicalMapping\n"));

    while (CurrBuffer)
    {
        NdisMStartBufferPhysicalMapping(
            Adapter->AdapterHandle,
            CurrBuffer,
            Adapter->CurrMapRegTail,
            TRUE,
            PhysAddrUnits,
            &ArraySize);

        Adapter->CurrMapRegTail++;
        if (Adapter->CurrMapRegTail == (ULONG)Adapter->NumTbd)
        {
            Adapter->CurrMapRegTail = 0;
        }

        for (i = 0; i < ArraySize; i++)
        {
            pFragList->Elements[ElementIndex].Address = PhysAddrUnits[i].PhysicalAddress;
            pFragList->Elements[ElementIndex].Length = PhysAddrUnits[i].Length;
            ElementIndex++; 
        }

        //
        // Flush the current buffer because it could be cached
        //
        NdisFlushBuffer(CurrBuffer, TRUE);

        //
        // point to the next buffer
        //
        NdisGetNextBuffer(CurrBuffer, &CurrBuffer);
    }

    pFragList->NumberOfElements = ElementIndex;
    ASSERT(pFragList->NumberOfElements);   

    DBGPRINT(MP_TRACE, ("<-- MpStartPacketPhysicalMapping\n"));

}

NDIS_STATUS NICSendPacket(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_TCB         pMpTcb,
    IN  PMP_FRAG_LIST   pFragList
    )
/*++
Routine Description:

    NIC specific send handler
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpTcb      Pointer to MP_TCB
    pFragList   The pointer to the frag list to be filled

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/
{
    NDIS_STATUS  Status;
    ULONG        index;
    UCHAR        TbdCount = 0;

    PHW_TCB      pHwTcb = pMpTcb->HwTcb;
    PTBD_STRUC   pHwTbd = pMpTcb->HwTbd;

    DBGPRINT(MP_TRACE, ("--> NICSendPacket\n"));

    for (index = 0; index < pFragList->NumberOfElements; index++)
    {
        if (pFragList->Elements[index].Length)
        {
            pHwTbd->TbdBufferAddress = NdisGetPhysicalAddressLow(pFragList->Elements[index].Address);
            pHwTbd->TbdCount = pFragList->Elements[index].Length;

            pHwTbd++;                    
            TbdCount++;   
        }
    }

    pHwTcb->TxCbHeader.CbStatus = 0;
    pHwTcb->TxCbHeader.CbCommand = CB_S_BIT | CB_TRANSMIT | CB_TX_SF_BIT;

    pHwTcb->TxCbTbdPointer = pMpTcb->HwTbdPhys;
    pHwTcb->TxCbTbdNumber = TbdCount;
    pHwTcb->TxCbCount = 0;
    pHwTcb->TxCbThreshold = (UCHAR) Adapter->AiThreshold;

    Status = NICStartSend(Adapter, pMpTcb);

    DBGPRINT(MP_TRACE, ("<-- NICSendPacket\n"));

    return Status;
}

NDIS_STATUS NICStartSend(
    IN  PMP_ADAPTER  Adapter,
    IN  PMP_TCB      pMpTcb
    )
/*++
Routine Description:

    Issue a send command to the NIC
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpTcb      Pointer to MP_TCB

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/
{
    NDIS_STATUS     Status;

    DBGPRINT(MP_TRACE, ("--> NICStartSend\n"));

    //
    // If the transmit unit is idle (very first transmit) then we must
    // setup the general pointer and issue a full CU-start
    //
    if (Adapter->TransmitIdle)
    {
        
        DBGPRINT(MP_INFO,  ("CU is idle -- First TCB added to Active List\n"));

        //
        // Wait for the SCB to clear before we set the general pointer
        //
        if (!WaitScb(Adapter))
        {
            Status = NDIS_STATUS_HARD_ERRORS;
            MP_EXIT;
        }

        //
        // Don't try to start the transmitter if the command unit is not
        // idle ((not idle) == (Cu-Suspended or Cu-Active)).
        //
        if ((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) != SCB_CUS_IDLE)
        {
            DBGPRINT(MP_ERROR, ("Adapter = "PTR_FORMAT", CU Not IDLE\n", Adapter));
            MP_SET_HARDWARE_ERROR(Adapter);
            NdisStallExecution(25);
        }

        Adapter->CSRAddress->ScbGeneralPointer = pMpTcb->HwTcbPhys;

        Status = D100IssueScbCommand(Adapter, SCB_CUC_START, FALSE);

        Adapter->TransmitIdle = FALSE;
        Adapter->ResumeWait = TRUE;
    }
    else
    {
        //
        // If the command unit has already been started, then append this
        // TCB onto the end of the transmit chain, and issue a CU-Resume.
        //
        DBGPRINT(MP_LOUD, ("adding TCB to Active chain\n"));

        //
        // Clear the suspend bit on the previous packet.
        //
        pMpTcb->PrevHwTcb->TxCbHeader.CbCommand &= ~CB_S_BIT;

        //
        // Issue a CU-Resume command to the device.  We only need to do a
        // WaitScb if the last command was NOT a RESUME.
        //
        Status = D100IssueScbCommand(Adapter, SCB_CUC_RESUME, Adapter->ResumeWait);
    }

    exit:
                      
    DBGPRINT(MP_TRACE, ("<-- NICStartSend\n"));

    return Status;
}

NDIS_STATUS MpHandleSendInterrupt(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Interrupt handler for sending processing
    Re-claim the send resources, complete sends and get more to send from the send wait queue
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS
    NDIS_STATUS_PENDING

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PMP_TCB         pMpTcb;

#if DBG
    LONG            i;
#endif

    DBGPRINT(MP_TRACE, ("---> MpHandleSendInterrupt\n"));

    //
    // Any packets being sent? Any packet waiting in the send queue?
    //
    if (Adapter->nBusySend == 0 &&
        IsQueueEmpty(&Adapter->SendWaitQueue))
    {
        ASSERT(Adapter->CurrSendHead == Adapter->CurrSendTail);
        DBGPRINT(MP_TRACE, ("<--- MpHandleSendInterrupt\n"));
        return Status;
    }

    //
    // Check the first TCB on the send list
    //
    while (Adapter->nBusySend > 0)
    {

#if DBG
        pMpTcb = Adapter->CurrSendHead;
        for (i = 0; i < Adapter->nBusySend; i++)
        {
            pMpTcb = pMpTcb->Next;   
        }

        if (pMpTcb != Adapter->CurrSendTail)
        {
            DBGPRINT(MP_ERROR, ("nBusySend= %d\n", Adapter->nBusySend));
            DBGPRINT(MP_ERROR, ("CurrSendhead= "PTR_FORMAT"\n", Adapter->CurrSendHead));
            DBGPRINT(MP_ERROR, ("CurrSendTail= "PTR_FORMAT"\n", Adapter->CurrSendTail));
            ASSERT(FALSE);
        }
#endif      

        pMpTcb = Adapter->CurrSendHead;

        //
        // Is this TCB completed?
        //
        if (pMpTcb->HwTcb->TxCbHeader.CbStatus & CB_STATUS_COMPLETE)
        {
            //
            // Check if this is a multicast hw workaround packet
            //
            if ((pMpTcb->HwTcb->TxCbHeader.CbCommand & CB_CMD_MASK) != CB_MULTICAST)
            {
                MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb);
                
            }
            else
            {
                MP_CLEAR_FLAGS(pMpTcb);
                pMpTcb->Count = 0;
                Adapter->CurrSendHead = Adapter->CurrSendHead->Next;

                Adapter->nBusySend--;

#if OFFLOAD
                NdisInterlockedDecrement(&Adapter->SharedMemRefCount);
                if (Adapter->SharedMemRefCount == 0)
                {
                  //  DbgPrint("Clear the flag\n");
                    MP_CLEAR_FLAG(Adapter, fMP_SHARED_MEM_IN_USE);
                }
#endif                
                ASSERT(Adapter->nBusySend >= 0);
            }
        }
        else
        {
            break;
        }
    }

    //
    // If we queued any transmits because we didn't have any TCBs earlier,
    // dequeue and send those packets now, as long as we have free TCBs.
    //
    if (MP_IS_READY(Adapter))
    {
        while (!IsQueueEmpty(&Adapter->SendWaitQueue) &&
            MP_TCB_RESOURCES_AVAIABLE(Adapter))
        {
            PNDIS_PACKET Packet;
            PQUEUE_ENTRY pEntry; 
            
#if OFFLOAD
            if (MP_TEST_FLAG(Adapter, fMP_SHARED_MEM_IN_USE))
            {
                break;
            }
#endif
            
            pEntry = RemoveHeadQueue(&Adapter->SendWaitQueue); 
            
            ASSERT(pEntry);
            
            Adapter->nWaitSend--;

            Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

            DBGPRINT(MP_INFO, ("MpHandleSendInterrupt - send a queued packet\n"));
            
            Status = MpSendPacketFun(Adapter, Packet, TRUE);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }
    }

    DBGPRINT(MP_TRACE, ("<--- MpHandleSendInterrupt\n"));
    return Status;
}

VOID MpHandleRecvInterrupt(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Interrupt handler for receive processing
    Put the received packets into an array and call NdisMIndicateReceivePacket
    If we run low on RFDs, allocate another one
    Assumption: Rcv spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_RFD         pMpRfd;
    PHW_RFD         pHwRfd;

    PNDIS_PACKET    PacketArray[NIC_DEF_RFDS];              
    PNDIS_PACKET    PacketFreeArray[NIC_DEF_RFDS];
    UINT            PacketArrayCount;
    UINT            PacketFreeCount;
    UINT            Index;
    UINT            LoopIndex = 0;
    UINT            LoopCount = NIC_MAX_RFDS / NIC_DEF_RFDS + 1;    // avoid staying here too long

    BOOLEAN         bContinue = TRUE;
    BOOLEAN         bAllocNewRfd = FALSE;
    USHORT          PacketStatus;
#if OFFLOAD
    UINT            i;

#endif

    
    DBGPRINT(MP_TRACE, ("---> MpHandleRecvInterrupt\n"));

    ASSERT(Adapter->nReadyRecv >= NIC_MIN_RFDS);
    
    while (LoopIndex++ < LoopCount && bContinue)
    {
        PacketArrayCount = 0;
        PacketFreeCount = 0;

        //
        // Process up to the array size RFD's
        //
        while (PacketArrayCount < NIC_DEF_RFDS)
        {
            if (IsListEmpty(&Adapter->RecvList))
            {
                ASSERT(Adapter->nReadyRecv == 0);
                bContinue = FALSE;  
                break;
            }

            //
            // Get the next MP_RFD to process
            //
            pMpRfd = (PMP_RFD)GetListHeadEntry(&Adapter->RecvList);

            //
            // Get the associated HW_RFD
            //
            pHwRfd = pMpRfd->HwRfd;
            
            //
            // Is this packet completed?
            //
            PacketStatus = NIC_RFD_GET_STATUS(pHwRfd);
            if (!NIC_RFD_STATUS_COMPLETED(PacketStatus))
            {
                bContinue = FALSE;
                break;
            }
            
            //
            // HW specific - check if actual count field has been updated
            //
            if (!NIC_RFD_VALID_ACTUALCOUNT(pHwRfd))
            {
                bContinue = FALSE;
                break;
            }

            //
            // Remove the RFD from the head of the List
            //
            RemoveEntryList((PLIST_ENTRY)pMpRfd);
            Adapter->nReadyRecv--;
            ASSERT(Adapter->nReadyRecv >= 0);
            
            ASSERT(MP_TEST_FLAG(pMpRfd, fMP_RFD_RECV_READY));
            MP_CLEAR_FLAG(pMpRfd, fMP_RFD_RECV_READY);

            //
            // A good packet? drop it if not.
            //
            if (!NIC_RFD_STATUS_SUCCESS(PacketStatus))
            {
                DBGPRINT(MP_WARN, ("Receive failure = %x\n", PacketStatus));
                NICReturnRFD(Adapter, pMpRfd);
                continue;
            }

            //
            // Do not receive any packets until a filter has been set
            //
            if (!Adapter->PacketFilter)
            {
                NICReturnRFD(Adapter, pMpRfd);
                continue;
            }

            //
            // Do not receive any packets until we are at D0
            //
            if (Adapter->CurrentPowerState != NdisDeviceStateD0)
            {
                NICReturnRFD(Adapter, pMpRfd);
                continue;
            }

            //
            // Get the packet size
            //
            pMpRfd->PacketSize = NIC_RFD_GET_PACKET_SIZE(pHwRfd);
            
            NdisAdjustBufferLength(pMpRfd->NdisBuffer, pMpRfd->PacketSize);
            NdisFlushBuffer(pMpRfd->NdisBuffer, FALSE);

            // we don't mess up the buffer chain, no need to make this call in this case                                  
            // NdisRecalculatePacketCounts(pMpRfd->ReceivePacket);

            //
            // set the status on the packet, either resources or success
            //
            if (Adapter->nReadyRecv >= MIN_NUM_RFD)
            {
                // NDIS_STATUS_SUCCESS
                NDIS_SET_PACKET_STATUS(pMpRfd->NdisPacket, NDIS_STATUS_SUCCESS);
                MP_SET_FLAG(pMpRfd, fMP_RFD_RECV_PEND);
                
                InsertTailList(&Adapter->RecvPendList, (PLIST_ENTRY)pMpRfd);
                MP_INC_RCV_REF(Adapter);

            }
            else
            {
                //
                // NDIS_STATUS_RESOURCES
                //
                NDIS_SET_PACKET_STATUS(pMpRfd->NdisPacket, NDIS_STATUS_RESOURCES);
                MP_SET_FLAG(pMpRfd, fMP_RFD_RESOURCES);
                
                PacketFreeArray[PacketFreeCount] = pMpRfd->NdisPacket;
                PacketFreeCount++;

                //
                // Reset the RFD shrink count - don't attempt to shrink RFD
                //
                Adapter->RfdShrinkCount = 0;
                
                //
                // Remember to allocate a new RFD later
                //
                bAllocNewRfd = TRUE;
            }

            PacketArray[PacketArrayCount] = pMpRfd->NdisPacket;
            PacketArrayCount++;
        }

        //
        // if we didn't process any receives, just return from here
        //
        if (PacketArrayCount == 0) break;

        //
        // Update the number of outstanding Recvs
        //
        Adapter->PoMgmt.OutstandingRecv += PacketArrayCount;

        NdisDprReleaseSpinLock(&Adapter->RcvLock);


        NdisMIndicateReceivePacket(
            Adapter->AdapterHandle,
            PacketArray,
            PacketArrayCount);

        NdisDprAcquireSpinLock(&Adapter->RcvLock);

        //
        // NDIS won't take ownership for the packets with NDIS_STATUS_RESOURCES.
        // For other packets, NDIS always takes the ownership and gives them back 
        // by calling MPReturnPackets
        //
        for (Index = 0; Index < PacketFreeCount; Index++)
        {

            //
            // Get the MP_RFD saved in this packet, in NICAllocRfd
            //
            pMpRfd = MP_GET_PACKET_RFD(PacketFreeArray[Index]);
            
            ASSERT(MP_TEST_FLAG(pMpRfd, fMP_RFD_RESOURCES));
            MP_CLEAR_FLAG(pMpRfd, fMP_RFD_RESOURCES);

            //
            // Decrement the number of outstanding Recvs
            //
            Adapter->PoMgmt.OutstandingRecv --;
    
            NICReturnRFD(Adapter, pMpRfd);
        }
    }
    
    //
    // If we ran low on RFD's, we need to allocate a new RFD
    //
    if (bAllocNewRfd)
    {
        //
        // Allocate one more RFD only if no pending new RFD allocation AND
        // it doesn't exceed the max RFD limit
        //
        if (!Adapter->bAllocNewRfd && Adapter->CurrNumRfd < Adapter->MaxNumRfd)
        {
            PMP_RFD TempMpRfd;
            NDIS_STATUS TempStatus;

            TempMpRfd = NdisAllocateFromNPagedLookasideList(&Adapter->RecvLookaside);
            if (TempMpRfd)
            {
                MP_INC_REF(Adapter);
                Adapter->bAllocNewRfd = TRUE;

                MP_SET_FLAG(TempMpRfd, fMP_RFD_ALLOC_PEND); 

                //
                // Allocate the shared memory for this RFD.
                //
                TempStatus = NdisMAllocateSharedMemoryAsync(
                                 Adapter->AdapterHandle,
                                 Adapter->HwRfdSize,
                                 FALSE,
                                 TempMpRfd);

                //
                // The return value will be either NDIS_STATUS_PENDING or NDIS_STATUS_FAILURE
                //
                if (TempStatus == NDIS_STATUS_FAILURE)
                {
                    MP_CLEAR_FLAGS(TempMpRfd);
                    NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, TempMpRfd);

                    Adapter->bAllocNewRfd = FALSE;
                    MP_DEC_REF(Adapter);
                }
            }
        }
    }

    ASSERT(Adapter->nReadyRecv >= NIC_MIN_RFDS);

    DBGPRINT(MP_TRACE, ("<--- MpHandleRecvInterrupt\n"));
}

VOID NICReturnRFD(
    IN  PMP_ADAPTER  Adapter,
    IN  PMP_RFD		pMpRfd
    )
/*++
Routine Description:

    Recycle a RFD and put it back onto the receive list 
    Assumption: Rcv spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpRfd      Pointer to the RFD 

Return Value:

    None
    
--*/
{
    PMP_RFD   pLastMpRfd;
    PHW_RFD   pHwRfd = pMpRfd->HwRfd;

    ASSERT(pMpRfd->Flags == 0);
    MP_SET_FLAG(pMpRfd, fMP_RFD_RECV_READY);
    
    //
    // HW_SPECIFIC_START
    //
    pHwRfd->RfdCbHeader.CbStatus = 0;
    pHwRfd->RfdActualCount = 0;
    pHwRfd->RfdCbHeader.CbCommand = (RFD_EL_BIT);
    pHwRfd->RfdCbHeader.CbLinkPointer = DRIVER_NULL;

    //
    // We don't use any of the OOB data besides status
    // Otherwise, we need to clean up OOB data
    // NdisZeroMemory(NDIS_OOB_DATA_FROM_PACKET(pMpRfd->NdisPacket),14);
    //
    // Append this RFD to the RFD chain
    if (!IsListEmpty(&Adapter->RecvList))
    {
        pLastMpRfd = (PMP_RFD)GetListTailEntry(&Adapter->RecvList);

        // Link it onto the end of the chain dynamically
        pHwRfd = pLastMpRfd->HwRfd;
        pHwRfd->RfdCbHeader.CbLinkPointer = pMpRfd->HwRfdPhys;
        pHwRfd->RfdCbHeader.CbCommand = 0;
    }

    //
    // HW_SPECIFIC_END
    //

    //
    // The processing on this RFD is done, so put it back on the tail of
    // our list
    //
    InsertTailList(&Adapter->RecvList, (PLIST_ENTRY)pMpRfd);
    Adapter->nReadyRecv++;
    ASSERT(Adapter->nReadyRecv <= Adapter->CurrNumRfd);
}

NDIS_STATUS NICStartRecv(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Start the receive unit if it's not in a ready state                    
    Assumption: Rcv spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRROS
    
--*/
{
    PMP_RFD         pMpRfd;
    NDIS_STATUS     Status;

    DBGPRINT(MP_TRACE, ("---> NICStartRecv\n"));

    //
    // If the receiver is ready, then don't try to restart.
    //
    if (NIC_IS_RECV_READY(Adapter))
    {
        DBGPRINT(MP_LOUD, ("Receive unit already active\n"));
        return NDIS_STATUS_SUCCESS;
    }

    DBGPRINT(MP_LOUD, ("Re-start receive unit...\n"));
    ASSERT(!IsListEmpty(&Adapter->RecvList));
    
    //
    // Get the MP_RFD head
    //
    pMpRfd = (PMP_RFD)GetListHeadEntry(&Adapter->RecvList);

    //
    // If more packets are received, clean up RFD chain again
    //
    if (NIC_RFD_GET_STATUS(pMpRfd->HwRfd))
    {
        MpHandleRecvInterrupt(Adapter);
        ASSERT(!IsListEmpty(&Adapter->RecvList));

        //
        // Get the new MP_RFD head
        //
        pMpRfd = (PMP_RFD)GetListHeadEntry(&Adapter->RecvList);
    }

    //
    // Wait for the SCB to clear before we set the general pointer
    //
    if (!WaitScb(Adapter))
    {
        Status = NDIS_STATUS_HARD_ERRORS;
        MP_EXIT;
    }

    if (Adapter->CurrentPowerState > NdisDeviceStateD0)
    {
        Status = NDIS_STATUS_HARD_ERRORS;
        MP_EXIT;
    }
    //
    // Set the SCB General Pointer to point the current Rfd
    //
    Adapter->CSRAddress->ScbGeneralPointer = pMpRfd->HwRfdPhys;

    //
    // Issue the SCB RU start command
    //
    Status = D100IssueScbCommand(Adapter, SCB_RUC_START, FALSE);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        // wait for the command to be accepted
        if (!WaitScb(Adapter))
        {
            Status = NDIS_STATUS_HARD_ERRORS;
        }
    }        
    
    exit:

    DBGPRINT_S(Status, ("<--- NICStartRecv, Status=%x\n", Status));
    return Status;
}

VOID MpFreeQueuedSendPackets(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Free and complete the pended sends on SendWaitQueue
    Assumption: spinlock has been acquired 
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

     None

--*/
{
    PQUEUE_ENTRY    pEntry;
    PNDIS_PACKET    Packet;
    NDIS_STATUS     Status = MP_GET_STATUS_FROM_FLAGS(Adapter);

    DBGPRINT(MP_TRACE, ("--> MpFreeQueuedSendPackets\n"));

    while (!IsQueueEmpty(&Adapter->SendWaitQueue))
    {
        pEntry = RemoveHeadQueue(&Adapter->SendWaitQueue); 
        Adapter->nWaitSend--;
        NdisReleaseSpinLock(&Adapter->SendLock);

        ASSERT(pEntry);
        Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

        NdisMSendComplete(
            MP_GET_ADAPTER_HANDLE(Adapter),
            Packet,
            Status);

        NdisAcquireSpinLock(&Adapter->SendLock);
    }

    DBGPRINT(MP_TRACE, ("<-- MpFreeQueuedSendPackets\n"));

}

void MpFreeBusySendPackets(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Free and complete the stopped active sends
    Assumption: Send spinlock has been acquired 
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

     None

--*/
{
    PMP_TCB  pMpTcb;

    DBGPRINT(MP_TRACE, ("--> MpFreeBusySendPackets\n"));

    //
    // Any packets being sent? Check the first TCB on the send list
    //
    while (Adapter->nBusySend > 0)
    {
        pMpTcb = Adapter->CurrSendHead;

        //
        // Is this TCB completed?
        //
        if ((pMpTcb->HwTcb->TxCbHeader.CbCommand & CB_CMD_MASK) != CB_MULTICAST)
        {
            MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb);
        }
        else
        {
            break;
        }
    }

    DBGPRINT(MP_TRACE, ("<-- MpFreeBusySendPackets\n"));
}

VOID NICResetRecv(
    IN  PMP_ADAPTER   Adapter
    )
/*++
Routine Description:

    Reset the receive list                    
    Assumption: Rcv spinlock has been acquired 
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

     None

--*/
{
    PMP_RFD   pMpRfd;      
    PHW_RFD   pHwRfd;    
    LONG      RfdCount;

    DBGPRINT(MP_TRACE, ("--> NICResetRecv\n"));

    ASSERT(!IsListEmpty(&Adapter->RecvList));
    
    //
    // Get the MP_RFD head
    //
    pMpRfd = (PMP_RFD)GetListHeadEntry(&Adapter->RecvList);
    for (RfdCount = 0; RfdCount < Adapter->nReadyRecv; RfdCount++)
    {
        pHwRfd = pMpRfd->HwRfd;
        pHwRfd->RfdCbHeader.CbStatus = 0;

        pMpRfd = (PMP_RFD)GetListFLink(&pMpRfd->List);
    }

    DBGPRINT(MP_TRACE, ("<-- NICResetRecv\n"));
}

VOID MpLinkDetectionDpc(
    IN  PVOID	SystemSpecific1,
    IN  PVOID	FunctionContext,
    IN  PVOID	SystemSpecific2, 
    IN  PVOID	    SystemSpecific3
    )
/*++

Routine Description:
    
    Timer function for postponed link negotiation
    
Arguments:

    SystemSpecific1     Not used
    FunctionContext     Pointer to our adapter
    SystemSpecific2     Not used
    SystemSpecific3     Not used

Return Value:

    None
    
--*/
{
    PMP_ADAPTER Adapter = (PMP_ADAPTER)FunctionContext;
    NDIS_STATUS Status;

    //
    // Handle the link negotiation.
    //
    if (Adapter->bLinkDetectionWait)
    {
        Status = ScanAndSetupPhy(Adapter);
    }
    else
    {
        Status = PhyDetect(Adapter);
    }
    
    if (Status == NDIS_STATUS_PENDING)
    {
        // Wait for 100 ms   
        Adapter->bLinkDetectionWait = TRUE;
        NdisMSetTimer(&Adapter->LinkDetectionTimer, NIC_LINK_DETECTION_DELAY);
        return;
    }

    //
    // Reset some variables for link detection
    //
    Adapter->bLinkDetectionWait = FALSE;
    
    DBGPRINT(MP_WARN, ("MpLinkDetectionDpc - negotiation done\n"));

    NdisDprAcquireSpinLock(&Adapter->Lock);
    MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION);
    NdisDprReleaseSpinLock(&Adapter->Lock);

    //
    // Any OID query request?                                                        
    //
    if (Adapter->bQueryPending)
    {
        
        switch(Adapter->QueryRequest.Oid)
        {
            case OID_GEN_LINK_SPEED:
                *((PULONG) Adapter->QueryRequest.InformationBuffer) = Adapter->usLinkSpeed * 10000;
                *((PULONG) Adapter->QueryRequest.BytesWritten) = sizeof(ULONG);

                break;

            case OID_GEN_MEDIA_CONNECT_STATUS:
            default:
                ASSERT(Adapter->QueryRequest.Oid == OID_GEN_MEDIA_CONNECT_STATUS);
                *((PULONG) Adapter->QueryRequest.InformationBuffer) = NICGetMediaState(Adapter); 
                *((PULONG) Adapter->QueryRequest.BytesWritten) = sizeof(ULONG);
        }

        Adapter->bQueryPending = FALSE;
        NdisMQueryInformationComplete(Adapter->AdapterHandle, NDIS_STATUS_SUCCESS);
    }

    //
    // Any OID set request?                             
    //
    if (Adapter->bSetPending)
    {
        ULONG    PacketFilter; 

        ASSERT(Adapter->SetRequest.Oid == OID_GEN_CURRENT_PACKET_FILTER);

        PacketFilter = *((PULONG)Adapter->SetRequest.InformationBuffer);

        NdisDprAcquireSpinLock(&Adapter->Lock);

        Status = NICSetPacketFilter(
                     Adapter,
                     PacketFilter);

        NdisDprReleaseSpinLock(&Adapter->Lock);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            Adapter->PacketFilter = PacketFilter;
        }

        Adapter->bSetPending = FALSE;
        NdisMSetInformationComplete(Adapter->AdapterHandle, Status);
    }

    NdisDprAcquireSpinLock(&Adapter->Lock);
    //
    // Any pendingf reset?
    //
    if (Adapter->bResetPending)
    {
        // The link detection may have held some requests and caused reset. 
        // Complete the reset with NOT_READY status
        Adapter->bResetPending = FALSE;
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);
        
        NdisDprReleaseSpinLock(&Adapter->Lock);

        NdisMResetComplete(
            Adapter->AdapterHandle, 
            NDIS_STATUS_ADAPTER_NOT_READY,
            FALSE);
    }
    else
    {
        NdisDprReleaseSpinLock(&Adapter->Lock);
    }

    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    //
    // Start the NIC receive unit                                                     
    //
    Status = NICStartRecv(Adapter);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
    }
    
    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    NdisDprAcquireSpinLock(&Adapter->SendLock);

    //
    // Send packets which have been queued while link detection was going on. 
    //
    if (MP_IS_READY(Adapter))
    {
        while (!IsQueueEmpty(&Adapter->SendWaitQueue) &&
            Adapter->nBusySend < Adapter->NumTcb)
        {
            PNDIS_PACKET Packet;
            PQUEUE_ENTRY pEntry = RemoveHeadQueue(&Adapter->SendWaitQueue); 
            ASSERT(pEntry);
            
            Adapter->nWaitSend--;

            Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

            DBGPRINT(MP_INFO, ("MpLinkDetectionDpc - send a queued packet\n"));

            Status = MpSendPacket(Adapter, Packet, TRUE);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }
    }

    MP_DEC_REF(Adapter);

    if (MP_GET_REF(Adapter) == 0)
    {
        NdisSetEvent(&Adapter->ExitEvent);
    }

    NdisReleaseSpinLock(&Adapter->SendLock);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\offload.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

   Offload.c

Abstract:
   This file contains all the functions needed by TCP/IP checksum and segmentation
   of Large TCP packets task offloading. Actually thses functions should be 
   implemented by hardware, and the purpose of this file is just to demonstrate 
   how to use OID_TCP_TASK_OFFLOAD to enable/disable task offload capabilities.

Revision History
   Who           When                What
   ------        ---------           ----------
                 02-19-2001          Create
                 
Notes:

--*/

#include "precomp.h"

#ifdef OFFLOAD

#define PROTOCOL_TCP         6

//
// This miniport uses shared memory to handle offload tasks, so it tries to allocate
// shared memory of 64K, 32K, 16K. First it tries to allocate 64K, if fails, then
// it tries 32K and so on. If successed, than keeps the size in adapter, which is used
// to decide the maximum offload size in large send. If all the tries fail, then this
// miniport cann't support any offload task.
// 
ULONG LargeSendSharedMemArray[LARGE_SEND_MEM_SIZE_OPTION] = {64*1024, 32*1024, 16*1024};

//
// if x is aabb(where aa, bb are hex bytes), we want net_short (x) to be bbaa.
// 
USHORT net_short(
    ULONG NaturalData
    )
{
    USHORT ShortData = (USHORT)NaturalData;

    return (ShortData << 8) | (ShortData >> 8);
}

//
// if x is aabbccdd (where aa, bb, cc, dd are hex bytes)
// we want net_long(x) to be ddccbbaa.  A small and fast way to do this is
// to first byteswap it to get bbaaddcc and then swap high and low words.
//
ULONG net_long(
    ULONG NaturalData
    )
{
    ULONG ByteSwapped;

    ByteSwapped = ((NaturalData & 0x00ff00ff) << 8) |
                  ((NaturalData & 0xff00ff00) >> 8);

    return (ByteSwapped << 16) | (ByteSwapped >> 16);
}


//
// calculate the checksum for pseudo-header
//
#define PHXSUM(s,d,p,l) (UINT)( (UINT)*(USHORT *)&(s) + \
                        (UINT)*(USHORT *)((char *)&(s) + sizeof(USHORT)) + \
                        (UINT)*(USHORT *)&(d) + \
                        (UINT)*(USHORT *)((char *)&(d) + sizeof(USHORT)) + \
                        (UINT)((USHORT)net_short((p))) + \
                        (UINT)((USHORT)net_short((USHORT)(l))) )


#define IP_HEADER_LENGTH(pIpHdr)   \
        ( (ULONG)((pIpHdr->iph_verlen & 0x0F) << 2) )

#define TCP_HEADER_LENGTH(pTcpHdr) \
        ( (USHORT)(((*((PUCHAR)(&(pTcpHdr->tcp_flags))) & 0xF0) >> 4) << 2) )


/*++
Routine Description:
    
   Copy data in a packet to the specified location 
    
Arguments:
    
    BytesToCopy          The number of bytes need to copy
    CurrentBuffer        The buffer to start to copy
    StartVa              The start address to copy the data to
    Offset               The start offset in the buffer to copy the data
    HeadersLength        The length of the headers which has already been copied.

Return Value:
 
    The number of bytes actually copied
  

--*/  

ULONG MpCopyData(
    ULONG          BytesToCopy, 
    PNDIS_BUFFER  *CurrentBuffer, 
    PVOID          StartVa, 
    PULONG         Offset,
    ULONG          HeadersLength
    )
{
    ULONG    CurrLength;
    PUCHAR   pSrc;
    PUCHAR   pDest;
    ULONG    BytesCopied = 0;
    ULONG    CopyLength;
    
    DBGPRINT(MP_TRACE, ("--> MpCopyData\n"));
    pDest = StartVa;
    while (*CurrentBuffer && BytesToCopy != 0)
    {
#ifdef NDIS51_MINIPORT
        NdisQueryBufferSafe(
            *CurrentBuffer, 
            &pSrc,
            &CurrLength,
            NormalPagePriority);
        if (pSrc == NULL)
        {
            BytesCopied = 0;
            break;
        }
#else
        NdisQueryBuffer( *CurrentBuffer, &pSrc, &CurrLength);
#endif
        // 
        //  Current buffer length is greater than the offset to the buffer
        //  
        if (CurrLength > *Offset)
        { 
            pSrc += *Offset;
            CurrLength -= *Offset;
            CopyLength = CurrLength > BytesToCopy ? BytesToCopy : CurrLength;
            
            NdisMoveMemory(pDest, pSrc, CopyLength);
            BytesCopied += CopyLength;

            if (CurrLength > BytesToCopy)
            {
                *Offset += BytesToCopy;
                break;
            }

            BytesToCopy -= CopyLength;
            pDest += CopyLength;
            *Offset = 0;
        }
        else
        {
            *Offset -= CurrLength;
        }
        NdisGetNextBuffer( *CurrentBuffer, CurrentBuffer);
    
    }
    ASSERT(BytesCopied + HeadersLength <= NIC_MAX_PACKET_SIZE);
    //
    // Zero out the padding bytes if necessary
    //
    if (BytesCopied + HeadersLength < NIC_MIN_PACKET_SIZE)
    {
        NdisZeroMemory(pDest, NIC_MIN_PACKET_SIZE - (BytesCopied + HeadersLength));
    }    
    DBGPRINT(MP_TRACE, ("<-- MpCopyData\n"));
    return BytesCopied;
}



/*++
Routine Description:
    
    Dump packet information for debug purpose
    
Arguments:
    
    pPkt      Pointer to the packet

Return Value:
 
    None
  

--*/  
VOID e100DumpPkt (
    IN PNDIS_PACKET Packet
    )
{
    PNDIS_BUFFER pPrevBuffer;
    PNDIS_BUFFER pBuffer;

    do
    {
        //
        // Get first buffer of the packet
        //
        pBuffer = Packet->Private.Head;
        pPrevBuffer = NULL;

        //
        // Scan the buffer chain
        //
        while (pBuffer != NULL) 
        {
            PVOID pVa = NULL;
            ULONG BufLen = 0;

            BufLen = NdisBufferLength (pBuffer);

            pVa = NdisBufferVirtualAddress(pBuffer);

            pPrevBuffer = pBuffer;
            pBuffer = pBuffer->Next;
            
            if (pVa == NULL)
            {
                continue;
            }

            DBGPRINT(MP_WARN, ("Mdl %p, Va %p. Len %x\n", pPrevBuffer, pVa, BufLen));
            Dump( (CHAR* )pVa, BufLen, 0, 1 );                           
        }

    } while (FALSE);
}


/*++
Routine Description:
    
    Calculate the IP checksum
    
Arguments:
    
    Packet       Pointer to the packet
    IpHdrOffset  Offset of IP header from the beginning of the packet

Return Value:
 
    None
  

--*/  
VOID CalculateIpChecksum(
    PUCHAR       StartVa,
    ULONG        IpHdrOffset
    )
{
    
    IPHeader      *pIpHdr;
    ULONG          IpHdrLen;
    ULONG          TempXsum = 0;
    
   
    pIpHdr = (IPHeader *)(StartVa + IpHdrOffset);
    IpHdrLen = IP_HEADER_LENGTH(pIpHdr);

    XSUM(TempXsum, StartVa, IpHdrLen, IpHdrOffset);
    pIpHdr->iph_xsum = ~(USHORT)TempXsum;
}



/*++
Routine Description:
    
    Calculate the UDP checksum 
    
Arguments:
    
    Packet       Pointer to the packet
    IpHdrOffset  Offset of IP header from the beginning of the packet

Return Value:
 
    None
  

--*/  
VOID CalculateUdpChecksum(
    PNDIS_PACKET pPacket, 
    ULONG  IpHdrOffset
    )
{
    DBGPRINT(MP_WARN, ("UdpChecksum is not handled\n"));
}




/*++
Routine Description:
    
    Calculate the TCP checksum 
    
Arguments:
    
    Packet       Pointer to the packet
    IpHdrOffset  Offset of IP header from the beginning of the packet

Return Value:
 
    None
  

--*/  
VOID CalculateTcpChecksum(
    PVOID  StartVa,
    ULONG  PacketLength,
    ULONG  IpHdrOffset
    )
{
    ULONG        Offset;
    IPHeader     *pIpHdr;
    ULONG        IpHdrLength;
    TCPHeader    *pTcpHdr;
    USHORT       PseudoXsum;
    ULONG        TmpXsum;
 
    
    DBGPRINT(MP_TRACE, ("===> CalculateTcpChecksum\n"));
    
    //
    // Find IP header and get IP header length in byte
    // MDL won't split headers
    //
    Offset = IpHdrOffset;
    pIpHdr = (IPHeader *) ((PUCHAR)StartVa + Offset);
    IpHdrLength = IP_HEADER_LENGTH(pIpHdr);
  
    //
    // If that is not tcp protocol, we can not do anything.
    // So just return to the caller
    //
    if (((pIpHdr->iph_verlen & 0xF0) >> 4) != 4 && pIpHdr->iph_protocol != PROTOCOL_TCP)
    {
        return;
    }
   
    //
    // Locate the TCP header
    //
    Offset += IpHdrLength;
    pTcpHdr = (TCPHeader *) ((PUCHAR)StartVa + Offset);

    //
    // Calculate the checksum for the tcp header and payload
    //
    PseudoXsum = pTcpHdr->tcp_xsum;
 
    pTcpHdr->tcp_xsum = 0;
    TmpXsum = PseudoXsum;
    XSUM(TmpXsum, StartVa, PacketLength - Offset, Offset);
    
    //
    // Now we got the checksum, need to put the checksum back to MDL
    //
    pTcpHdr->tcp_xsum = (USHORT)(~TmpXsum);
    
    DBGPRINT(MP_TRACE, ("<=== CalculateTcpChecksum\n"));
}


/*++
Routine Description:
    
    Do the checksum offloading 
    
Arguments:
    
    Packet       Pointer to the packet
    IpHdrOffset  Offset of IP header from the beginning of the packet

Return Value:
 
    None
  

--*/  
VOID CalculateChecksum(
    PVOID        StartVa,
    ULONG        PacketLength,
    PNDIS_PACKET Packet,
    ULONG        IpHdrOffset
    )
{ 
    ULONG                             ChecksumPktInfo;
    PNDIS_TCP_IP_CHECKSUM_PACKET_INFO pChecksumPktInfo;
    
    //
    // Check for protocol
    //
    if (NDIS_PROTOCOL_ID_TCP_IP != NDIS_GET_PACKET_PROTOCOL_TYPE(Packet))
    {
        DBGPRINT(MP_TRACE, ("Packet's protocol is wrong.\n"));
        return;
    }

    //
    // Query per packet information 
    //
    ChecksumPktInfo = PtrToUlong(
                         NDIS_PER_PACKET_INFO_FROM_PACKET( Packet,
                                                           TcpIpChecksumPacketInfo));

  
    // DBGPRINT(MP_WARN, ("Checksum info: %lu\n", ChecksumPktInfo));
    
    pChecksumPktInfo = (PNDIS_TCP_IP_CHECKSUM_PACKET_INFO) & ChecksumPktInfo;
    
    //
    // Check per packet information
    //
    if (pChecksumPktInfo->Transmit.NdisPacketChecksumV4 == 0)
    {
        
        DBGPRINT(MP_TRACE, ("NdisPacketChecksumV4 is not set.\n"));
        return;
    }
    
    //
    // do tcp checksum
    //
    if (pChecksumPktInfo->Transmit.NdisPacketTcpChecksum)
    {
        CalculateTcpChecksum(StartVa, PacketLength, IpHdrOffset);
    }

    //
    // do udp checksum
    //
    if (pChecksumPktInfo->Transmit.NdisPacketUdpChecksum)
    {
        CalculateUdpChecksum(Packet, IpHdrOffset);
    }

    //
    // do ip checksum
    //
    if (pChecksumPktInfo->Transmit.NdisPacketIpChecksum)
    {
        CalculateIpChecksum(StartVa, IpHdrOffset);
    }
    
}

/*++

Routine Description:
    
    MiniportSendPackets handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    PacketArray             Set of packets to send
    NumOfPackets         Self-explanatory

Return Value:

    None

--*/
VOID MPOffloadSendPackets(
    IN  NDIS_HANDLE    MiniportAdapterContext,
    IN  PPNDIS_PACKET  PacketArray,
    IN  UINT           NumOfPackets
    )
{
    PMP_ADAPTER  Adapter;
    NDIS_STATUS  Status;
    UINT         PacketCount;
    ULONG        IpHdrOffset;
    

    DBGPRINT(MP_TRACE, ("====> MPOffloadSendPackets\n"));

    Adapter = (PMP_ADAPTER)MiniportAdapterContext;


    NdisAcquireSpinLock(&Adapter->SendLock);

    //
    // Is this adapter ready for sending?
    //
    if (MP_IS_NOT_READY(Adapter))
    {
        //
        // There is link
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
        {
            for (PacketCount = 0; PacketCount < NumOfPackets; PacketCount++)
            {
                InsertTailQueue(&Adapter->SendWaitQueue, 
                                MP_GET_PACKET_MR( PacketArray[PacketCount] )
                               );
                
                Adapter->nWaitSend++;
                DBGPRINT(MP_WARN, ("MpOffloadSendPackets: link detection - queue packet "PTR_FORMAT"\n", PacketArray[PacketCount]));
            }
            NdisReleaseSpinLock(&Adapter->SendLock);
            return;
        }
        
        //
        // Adapter is not ready and there is not link
        //
        Status = MP_GET_STATUS_FROM_FLAGS(Adapter);

        NdisReleaseSpinLock(&Adapter->SendLock);

        for (PacketCount = 0; PacketCount < NumOfPackets; PacketCount++)
        {
            NdisMSendComplete(
                MP_GET_ADAPTER_HANDLE(Adapter),
                PacketArray[PacketCount],
                Status);
        }

        return;
    }

    //
    // Adapter is ready, send these packets      
    //
    for (PacketCount = 0; PacketCount < NumOfPackets; PacketCount++)
    {
        //
        // queue is not empty or tcb is not available 
        //
        if (!IsQueueEmpty(&Adapter->SendWaitQueue) || 
            !MP_TCB_RESOURCES_AVAIABLE(Adapter) ||
            MP_TEST_FLAG(Adapter, fMP_SHARED_MEM_IN_USE))
        {
            InsertTailQueue(&Adapter->SendWaitQueue, 
                            MP_GET_PACKET_MR( PacketArray[PacketCount] )
                           );
            Adapter->nWaitSend++;
        }
        else
        {
            MpOffloadSendPacket(Adapter, PacketArray[PacketCount], FALSE);
        }
    }

    NdisReleaseSpinLock(&Adapter->SendLock);

    DBGPRINT(MP_TRACE, ("<==== MPOffloadSendPackets\n"));

    return;
}

/*++
Routine Description:

    Do the work to send a packet
    Assumption: Send spinlock has been acquired and shared mem is available 

Arguments:

    Adapter     Pointer to our adapter
    Packet      The packet
    bFromQueue  TRUE if it's taken from the send wait queue

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING         Put into the send wait queue
    NDIS_STATUS_HARD_ERRORS

--*/
NDIS_STATUS MpOffloadSendPacket(
    IN  PMP_ADAPTER   Adapter,
    IN  PNDIS_PACKET  Packet,
    IN  BOOLEAN       bFromQueue
    )
{
    NDIS_STATUS             Status = NDIS_STATUS_PENDING;
    PMP_TCB                 pMpTcb = NULL;
    ULONG                   BytesCopied;
    ULONG                   NumOfPackets;

    // Mimiced frag list if map registers are used, on the local stack as it's not so big                                         
    MP_FRAG_LIST            FragList;
    
    // Pointer to either the scatter gather or the local mimiced frag list
    PMP_FRAG_LIST           pFragList;
    NDIS_PHYSICAL_ADDRESS   SendPa;
    ULONG                   BytesToCopy;
    ULONG                   Offset;
    PNDIS_PACKET_EXTENSION  PktExt;
    ULONG                   mss;
    PNDIS_BUFFER            NdisBuffer;
    ULONG                   PacketLength;
    PVOID                   CopyStartVa;
    ULONG                   IpHdrOffset;
    PUCHAR                  StartVa;
    PNDIS_BUFFER            FirstBuffer;
    
    DBGPRINT(MP_TRACE, ("--> MpOffloadSendPacket, Pkt= "PTR_FORMAT"\n", Packet));

    //
    //Check is shared memory available,  just double check
    //
    if (MP_TEST_FLAG(Adapter, fMP_SHARED_MEM_IN_USE))
    {
        DBGPRINT(MP_WARN, ("Shared mem is in use.\n"));
        if (bFromQueue)
        {
            InsertHeadQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(Packet));
        }
        else
        {
            InsertTailQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(Packet));
        }
        DBGPRINT(MP_TRACE, ("<-- MpOffloadSendPacket\n"));
        return Status;
    }

    MP_SET_FLAG(Adapter, fMP_SHARED_MEM_IN_USE);
    //
    // Get maximum segment size
    // 
    PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);       
    mss = PtrToUlong(PktExt->NdisPacketInfo[TcpLargeSendPacketInfo]);
    
    //
    // Copy NIC_MAX_PACKET_SIZE bytes of data from NDIS buffer 
    // to the shared memory
    //
    NdisQueryPacket( Packet, NULL, NULL, &FirstBuffer, &PacketLength );
    Offset = 0;
    NdisBuffer = FirstBuffer;
    BytesToCopy = NIC_MAX_PACKET_SIZE;
    CopyStartVa = Adapter->OffloadSharedMem.StartVa;
    BytesCopied = MpCopyData(BytesToCopy, &NdisBuffer, CopyStartVa, &Offset, 0); 

#ifdef NDIS51_MINIPORT
    //
    // MpCopyPacket may return 0 if system resources are low or exhausted
    //
    if (BytesCopied == 0)
    {
        
        DBGPRINT(MP_ERROR, ("Calling NdisMSendComplete with NDIS_STATUS_RESOURCES, Pkt= "PTR_FORMAT"\n", Packet));
    
        NdisReleaseSpinLock(&Adapter->SendLock); 
        NdisMSendComplete(
                MP_GET_ADAPTER_HANDLE(Adapter),
                Packet,
                NDIS_STATUS_RESOURCES);
    
        NdisAcquireSpinLock(&Adapter->SendLock);    
        MP_CLEAR_FLAG(Adapter, fMP_SHARED_MEM_IN_USE);
            
        return NDIS_STATUS_RESOURCES;            
    }
#endif

    StartVa = CopyStartVa;
    SendPa = Adapter->OffloadSharedMem.PhyAddr;
    IpHdrOffset = Adapter->EncapsulationFormat.EncapsulationHeaderSize;
    
    // 
    // Check if large send capability is on and this is a large packet
    // 
    if (Adapter->NicTaskOffload.LargeSendOffload && mss > 0)
    {
        ULONG       IpHeaderLen;
        ULONG       TcpHdrOffset;
        ULONG       HeadersLen;
        IPHeader *  IpHdr;
        TCPHeader * TcpHdr;
        USHORT      TcpHeaderLen;
        ULONG       IpSegmentLen;
        ULONG       TcpDataLen;
        ULONG       LastPacketDataLen;
        int         SeqNum;
        BOOLEAN     IsFinSet = FALSE;
        BOOLEAN     IsPushSet = FALSE;
        BOOLEAN     IsFirstSlot = TRUE;
        ULONG       TmpXsum;
        ULONG       BytesSent = 0;
        ULONG       TmpPxsum;
        

        IpHdr = (IPHeader *)((PUCHAR)CopyStartVa + IpHdrOffset);
        IpHeaderLen = IP_HEADER_LENGTH(IpHdr);
        
        // 
        // The packet must be a TCP packet
        //
        ASSERT(IpHdr->iph_protocol == PROTOCOL_TCP);
        
        TcpHdrOffset = IpHdrOffset + IpHeaderLen;
        
        TcpHdr = (TCPHeader *)((PUCHAR)CopyStartVa + TcpHdrOffset);
        
        TcpHeaderLen = TCP_HEADER_LENGTH(TcpHdr);
        HeadersLen = TcpHdrOffset + TcpHeaderLen;
       
        //
        // This length include IP, TCP headers and TCP data
        //
        IpSegmentLen = net_short(IpHdr->iph_length);

        //
        // get the pseudo-header 1's complement sum
        //
        TmpPxsum = TcpHdr->tcp_xsum;
        
        ASSERT(IpSegmentLen == PacketLength - IpHdrOffset);
        
        IsFinSet = (BOOLEAN)(TcpHdr->tcp_flags & TCP_FLAG_FIN);
        IsPushSet = (BOOLEAN)(TcpHdr->tcp_flags & TCP_FLAG_PUSH);
        SeqNum = net_long(TcpHdr->tcp_seq);
        TcpDataLen = IpSegmentLen - TcpHeaderLen - IpHeaderLen;

        ASSERT(TcpDataLen <= Adapter->LargeSendInfo.MaxOffLoadSize)
        
        NumOfPackets = TcpDataLen / mss + 1;
        
        ASSERT (NumOfPackets >= Adapter->LargeSendInfo.MinSegmentCount);
        
        LastPacketDataLen = TcpDataLen % mss;
        NdisBuffer = FirstBuffer;
        BytesSent = 0;

        //
        // The next copy start with offset of (mss+HeadersLen) corresponding to first buf
        // 
        BytesCopied = (BytesCopied >= mss + HeadersLen)? (mss + HeadersLen):BytesCopied;
        Offset = BytesCopied;

        //
        // Send out all the packets from the large TCP packet
        // 
        while (NumOfPackets--)
        {
            TmpXsum = 0;
           
            //
            // Is the first packet?
            // 
            if (IsFirstSlot) 
            {
                if (NumOfPackets == 0)
                {
                    PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = UlongToPtr(BytesCopied);
                }
                else 
                {
                    if (IsFinSet)
                    {
                        TcpHdr->tcp_flags &= ~TCP_FLAG_FIN;
                    }
                    if (IsPushSet)
                    {                        
                        TcpHdr->tcp_flags &= ~TCP_FLAG_PUSH;
                    }
                }
                BytesCopied -= HeadersLen;
                IsFirstSlot = FALSE;
            }
            //
            // Not the first packet
            // 
            else
            {
                //
                // copy headers
                //
                NdisMoveMemory (StartVa, CopyStartVa, HeadersLen);
                
                IpHdr = (IPHeader *)((PUCHAR)StartVa + IpHdrOffset);
                TcpHdr = (TCPHeader *) ((PUCHAR)StartVa + TcpHdrOffset);
            
                //
                // Last packet
                //
                if (NumOfPackets == 0)
                {
                    BytesToCopy = LastPacketDataLen;
                    PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = 
                                                   UlongToPtr(BytesSent + LastPacketDataLen);
                }
                else 
                {
                    BytesToCopy = mss;
                    // clear flag
                    if (IsFinSet)
                    {
                        TcpHdr->tcp_flags &= ~TCP_FLAG_FIN;
                    }
                    if (IsPushSet)
                    {
                        TcpHdr->tcp_flags &= ~TCP_FLAG_PUSH;
                    }
                }
                BytesCopied = MpCopyData(
                                    BytesToCopy,        
                                    &NdisBuffer, 
                                    StartVa + HeadersLen, 
                                    &Offset,
                                    HeadersLen);
                
#ifdef NDIS51_MINIPORT
                //
                // MpCopyData may return 0 if system resources are low or exhausted
                //
                if (BytesCopied == 0)
                {
        
                    PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = UlongToPtr(BytesSent);

                    DBGPRINT(MP_WARN, ("Calling NdisMSendComplete with NDIS_STATUS_SUCCESS(Part of the data is sent), Pkt= "PTR_FORMAT"\n", Packet));
    
                    NdisReleaseSpinLock(&Adapter->SendLock); 
                    NdisMSendComplete(
                                MP_GET_ADAPTER_HANDLE(Adapter),
                                Packet,
                                NDIS_STATUS_SUCCESS);
    
                    NdisAcquireSpinLock(&Adapter->SendLock);    
                    return NDIS_STATUS_RESOURCES;            
                }
#endif
            } 
            
            IpHdr->iph_length = net_short(TcpHeaderLen + IpHeaderLen + BytesCopied);
            TcpHdr->tcp_seq = net_long(SeqNum);
            SeqNum += BytesCopied;

            //
            // calculate ip checksum and tcp checksum
            //
            IpHdr->iph_xsum = 0;
            XSUM(TmpXsum, StartVa, IpHeaderLen, IpHdrOffset);
            IpHdr->iph_xsum = ~(USHORT)(TmpXsum);

            TmpXsum = TmpPxsum + net_short((USHORT)(BytesCopied + TcpHeaderLen));
            TcpHdr->tcp_xsum = 0;
            XSUM(TmpXsum, StartVa, BytesCopied + TcpHeaderLen, TcpHdrOffset);
            TcpHdr->tcp_xsum = ~(USHORT)(TmpXsum);

            BytesSent += BytesCopied;
            BytesCopied += HeadersLen;
            
            //
            // get TCB for the slot
            //
            pMpTcb = Adapter->CurrSendTail;
            ASSERT(!MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));
            
            //
            // Set up the frag list, only one fragment after it's coalesced
            //
            pFragList = &FragList;
            pFragList->NumberOfElements = 1;
            pFragList->Elements[0].Address = SendPa;
            pFragList->Elements[0].Length = (BytesCopied >= NIC_MIN_PACKET_SIZE) ?
                                             BytesCopied : NIC_MIN_PACKET_SIZE;            
            pMpTcb->Packet = NULL;
                
            MP_SET_FLAG(pMpTcb, fMP_TCB_IN_USE);
            
            //
            // Call the NIC specific send handler, it only needs to deal with the frag list
            //
            Status = NICSendPacket(Adapter, pMpTcb, pFragList);
                
            Adapter->nBusySend++;
            NdisInterlockedIncrement(&Adapter->SharedMemRefCount);
       
            //
            // Update the CopyVa and SendPa
            //
            SendPa.QuadPart += BytesCopied;
            StartVa += BytesCopied;
            
            Adapter->CurrSendTail = Adapter->CurrSendTail->Next;
            
            //
            // out of resouces, which will send complete part of the packet
            //
            if (Adapter->nBusySend >= Adapter->NumTcb)
            {
                PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = UlongToPtr(BytesSent);
                break;
            }
        } // while
    }
    // 
    // This is not a large packet or large send capability is not on
    //
    else
    {
        //
        // get TCB for the slot
        //
        pMpTcb = Adapter->CurrSendTail;
        ASSERT(!MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));
        //
        // Set up the frag list, only one fragment after it's coalesced
        //
        pFragList = &FragList;
        pFragList->NumberOfElements = 1;
        pFragList->Elements[0].Address = SendPa;
        pFragList->Elements[0].Length = (BytesCopied >= NIC_MIN_PACKET_SIZE) ?
                                         BytesCopied : NIC_MIN_PACKET_SIZE;
        pMpTcb->Packet = NULL;

        if (Adapter->NicChecksumOffload.DoXmitTcpChecksum
            && Adapter->NicTaskOffload.ChecksumOffload)
        {
            CalculateChecksum(CopyStartVa, 
                                  BytesCopied,
                                  Packet, 
                                  Adapter->EncapsulationFormat.EncapsulationHeaderSize);
        }
        MP_SET_FLAG(pMpTcb, fMP_TCB_IN_USE);
        //
        // Call the NIC specific send handler, it only needs to deal with the frag list
        //
        Status = NICSendPacket(Adapter, pMpTcb, pFragList);

        Adapter->nBusySend++;
        NdisInterlockedIncrement(&Adapter->SharedMemRefCount);
        
        ASSERT(Adapter->nBusySend <= Adapter->NumTcb);
        Adapter->CurrSendTail = Adapter->CurrSendTail->Next;
        
    }
    

    NdisReleaseSpinLock(&Adapter->SendLock);

    DBGPRINT(MP_TRACE, ("Calling NdisMSendComplete, Pkt= "PTR_FORMAT"\n", Packet));

    NdisMSendComplete( MP_GET_ADAPTER_HANDLE(Adapter), Packet, Status);

    NdisAcquireSpinLock(&Adapter->SendLock);
    DBGPRINT(MP_TRACE, ("<-- MpOffloadSendPacket\n"));
    return Status;

}  



/*++
Routine Description:

    Recycle a MP_TCB and complete the packet if necessary
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpTcb      Pointer to MP_TCB        

Return Value:

    None

--*/
VOID MP_OFFLOAD_FREE_SEND_PACKET(
    IN  PMP_ADAPTER  Adapter,
    IN  PMP_TCB      pMpTcb
    )
{
    PNDIS_BUFFER    CurrBuffer;

    ASSERT(MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));

    pMpTcb->Packet = NULL;
    pMpTcb->Count = 0;

    MP_CLEAR_FLAGS(pMpTcb);

    Adapter->CurrSendHead = Adapter->CurrSendHead->Next;
    Adapter->nBusySend--;
    NdisInterlockedDecrement(&Adapter->SharedMemRefCount);

    if (Adapter->SharedMemRefCount == 0)
    {
        MP_CLEAR_FLAG(Adapter, fMP_SHARED_MEM_IN_USE);
    }
    ASSERT(Adapter->nBusySend >= 0);

}

    

/*++
Routine Description:

    Disable the existing capabilities before protocol is setting the
    new capabilities

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None

--*/
VOID DisableOffload(
    IN PMP_ADAPTER Adapter
    )
{
    //
    // Disable the capabilities of the miniports
    // 
    NdisZeroMemory(&(Adapter->NicTaskOffload), sizeof(NIC_TASK_OFFLOAD));
    NdisZeroMemory(&(Adapter->NicChecksumOffload), sizeof(NIC_CHECKSUM_OFFLOAD));
}

#endif // OFFLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\physet.c ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    physet.c

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop
#pragma warning (disable: 4514)

//-----------------------------------------------------------------------------
// Procedure:   PhyDetect
//
// Description: This routine will detect what phy we are using, set the line
//              speed, FDX or HDX, and configure the phy if necessary.
//
//              The following combinations are supported:
//              - TX or T4 PHY alone at PHY address 1
//              - T4 or TX PHY at address 1 and MII PHY at address 0
//              - 82503 alone (10Base-T mode, no full duplex support)
//              - 82503 and MII PHY (TX or T4) at address 0
//
//              The sequence / priority of detection is as follows:
//                  If there is a PHY Address override use that address.
//                  else scan based on the 'Connector' setting.
//                      Switch Connector
//                          0 = AutoScan
//                          1 = Onboard TPE only
//                          2 = MII connector only
//
//              Each of the above cases is explained below.
//
//              AutoScan means:
//                Look for link on addresses 1, 0, 2..31 (in that order).  Use the first
//                address found that has link.
//                If link is not found then use the first valid PHY found in the same scan
//                order 1,0,2..31.  NOTE: this means that NO LINK or Multi-link cases will
//                default to the onboard PHY (address 1).
//
//              Onboard TPE only:
//                Phy address is set to 1 (No Scanning).
//
//              MII connector only means:
//                Look for link on addresses 0, 2..31 (again in that order, Note address 1 is
//                NOT scanned).   Use the first address found that has link.
//                If link is not found then use the first valid Phy found in the same scan
//                order 0, 2..31.
//                In the AutoScan case above we should always find a valid PHY at address 1,
//                there is no such guarantee here, so, If NO Phy is found then the driver
//                should default to address 0 and continue to load.  Note: External
//                transceivers should be at address 0 but our early Nitro3 testing found
//                transceivers at several non-zero addresses (6,10,14).
//
//
//   NWAY
//              Additionally auto-negotiation capable (NWAY) and parallel
//              detection PHYs are supported. The flow-chart is described in
//              the 82557 software writer's manual.
//
//   NOTE:  1.  All PHY MDI registers are read in polled mode.
//          2.  The routines assume that the 82557 has been RESET and we have
//              obtained the virtual memory address of the CSR.
//          3.  PhyDetect will not RESET the PHY.
//          4.  If FORCEFDX is set, SPEED should also be set. The driver will
//              check the values for inconsistency with the detected PHY
//              technology.
//          5.  PHY 1 (the PHY on the adapter) MUST be at address 1.
//          6.  Driver ignores FORCEFDX and SPEED overrides if a 503 interface
//              is detected.
//
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Result:
// Returns:
//  NDIS_STATUS_SUCCESS
//  NDIS_STATUS_FAILURE
//-----------------------------------------------------------------------------

NDIS_STATUS PhyDetect(
    IN PMP_ADAPTER Adapter
    )
{
    USHORT  MdiControlReg; 
    USHORT  MdiStatusReg;

    //
    // Check for a phy address over-ride of 32 which indicates a 503
    //
    if (Adapter->PhyAddress == 32)
    {
        //
        // 503 interface over-ride
        //
        DBGPRINT(MP_INFO, ("   503 serial component over-ride\n"));

        Adapter->PhyAddress = 32;

        //
        // Record the current speed and duplex.  We will be in half duplex
        // mode unless the user used the force full duplex over-ride.
        //
        Adapter->usLinkSpeed = 10;
        Adapter->usDuplexMode = (USHORT) Adapter->AiForceDpx;
        if (!Adapter->usDuplexMode)
        {
            Adapter->usDuplexMode = 1;
        }

        return(NDIS_STATUS_SUCCESS);
    }

    //
    // Check for other phy address over-rides.
    //   If the Phy Address is between 0-31 then there is an over-ride.
    //   Or the connector was set to 1
    //
    if ((Adapter->PhyAddress < 32) || (Adapter->Connector == CONNECTOR_TPE))
    {
            
        //
        // User Override nothing to do but setup Phy and leave
        //
        if ((Adapter->PhyAddress > 32) && (Adapter->Connector == CONNECTOR_TPE))
        {
            Adapter->PhyAddress = 1;  // Connector was forced

            // Isolate all other PHYs and unisolate this one
            SelectPhy(Adapter, Adapter->PhyAddress, FALSE);

        }

        DBGPRINT(MP_INFO, 
            ("   Phy address Override to address %d\n", Adapter->PhyAddress));

#if DBG
        //
        // Read the MDI control register at override address.
        //
        MdiRead(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiControlReg);

        //
        // Read the status register at override address.
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
        //
        // Read the status register again because of sticky bits
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

        //
        // check if we found a valid phy
        //
        if (!((MdiControlReg == 0xffff) || ((MdiStatusReg == 0) && (MdiControlReg == 0))))
        {
            //
            // we have a valid phy1
            //
            DBGPRINT(MP_INFO, ("   Over-ride address %d has a valid Phy.\n", Adapter->PhyAddress));

            //
            // Read the status register again
            //
            MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

            //
            // If there is a valid link then use this Phy.
            //
            if (MdiStatusReg & MDI_SR_LINK_STATUS)
            {
                DBGPRINT(MP_INFO, ("   Phy at address %d has link\n", Adapter->PhyAddress));
            }

        }
        else
        {
            //
            // no PHY at over-ride address
            //
            DBGPRINT(MP_INFO, ("   Over-ride address %d has no Phy!!!!\n", Adapter->PhyAddress));
        }
#endif
        return(SetupPhy(Adapter));
    }
    else // Need to scan - No address over-ride and Connector is AUTO or MII
    {
        Adapter->CurrentScanPhyIndex = 0;
        Adapter->LinkDetectionWaitCount = 0;
        Adapter->FoundPhyAt = 0xff;
        Adapter->bLookForLink = TRUE;
        
        return(ScanAndSetupPhy(Adapter));
    
    } // End else scan

    return(NDIS_STATUS_FAILURE);
}

NDIS_STATUS ScanAndSetupPhy(
    IN PMP_ADAPTER Adapter
    )
{
    USHORT MdiControlReg = 0; 
    USHORT MdiStatusReg = 0;

    if (Adapter->bLinkDetectionWait)
    {
        goto NEGOTIATION_WAIT;
    }
           
    SCAN_PHY_START:
    
    //
    // For each PhyAddress 0 - 31
    //
    DBGPRINT(MP_INFO, ("   Index=%d, bLookForLink=%d\n", 
        Adapter->CurrentScanPhyIndex, Adapter->bLookForLink));

    if (Adapter->bLookForLink)
    {
        //
        // Phy Addresses must be tested in the order 1,0,2..31.
        //
        switch(Adapter->CurrentScanPhyIndex)
        {
            case 0:
                Adapter->PhyAddress = 1;
                break;

            case 1:
                Adapter->PhyAddress = 0;
                break;
            
            default:
                Adapter->PhyAddress = Adapter->CurrentScanPhyIndex;
                break;
        }

        //
        // Skip OnBoard for MII only case
        //
        if ((Adapter->PhyAddress == 1)&&(Adapter->Connector == CONNECTOR_MII))
        {
            goto SCAN_PHY_NEXT;    
        }

        DBGPRINT(MP_INFO, ("   Scanning Phy address %d for link\n", Adapter->PhyAddress));

        //
        // Read the MDI control register
        //
        MdiRead(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiControlReg);

        //
        // Read the status register
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
        // Sticky Bits
    }
    else
    {   
        //
        // Not looking for link
        //
        if (Adapter->FoundPhyAt < 32)
        {
            Adapter->PhyAddress = Adapter->FoundPhyAt;
        }
        else if (Adapter->Connector == CONNECTOR_MII) 
	{
            //
            // No valid PHYs were found last time so just default
            //
            Adapter->PhyAddress = 0;  // Default for MII
        }
        else 
        { 
            //
            // assume a 503 interface
            //
            Adapter->PhyAddress = 32;

            //
            // Record the current speed and duplex.  We will be in half duplex
            // mode unless the user used the force full duplex over-ride.
            //
            Adapter->usLinkSpeed = 10;
            Adapter->usDuplexMode = (USHORT) Adapter->AiForceDpx;
            if (!Adapter->usDuplexMode)
            {
                Adapter->usDuplexMode = 1;
            }

            return(NDIS_STATUS_SUCCESS);
        }

        DBGPRINT(MP_INFO, ("   No Links Found!!\n"));
    }

    //
    // check if we found a valid phy or on !LookForLink pass
    //
    if (!( (MdiControlReg == 0xffff) || ((MdiStatusReg == 0) && (MdiControlReg == 0))) 
        || (!Adapter->bLookForLink))
    {   
        
        //
        // Valid phy or Not looking for Link
        //

#if DBG
        if (!( (MdiControlReg == 0xffff) || ((MdiStatusReg == 0) && (MdiControlReg == 0))))
        {
            DBGPRINT(MP_INFO, ("   Found a Phy at address %d\n", Adapter->PhyAddress));
        }
#endif
        //
        // Store highest priority phy found for NO link case
        //
        if (Adapter->CurrentScanPhyIndex < Adapter->FoundPhyAt && Adapter->FoundPhyAt != 1)
        {
            // this phy is higher priority
            Adapter->FoundPhyAt = (UCHAR) Adapter->PhyAddress;
        }

        //
        // Select Phy before checking link status
        // NOTE: may take up to 3.5 Sec if LookForLink == TRUE
        //SelectPhy(Adapter, Adapter->PhyAddress, (BOOLEAN)LookForLink);
        //
        SelectPhy(Adapter, Adapter->PhyAddress, FALSE);
        
        NEGOTIATION_WAIT:
        
        //
        // wait for auto-negotiation to complete (up to 3.5 seconds)
        //
        if (Adapter->LinkDetectionWaitCount++ < RENEGOTIATE_TIME)
        {
            // Read the status register twice because of sticky bits
            MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
            MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

            if (!(MdiStatusReg & MDI_SR_AUTO_NEG_COMPLETE))
            {
                return NDIS_STATUS_PENDING;
            }
        }
        else
        {
            Adapter->LinkDetectionWaitCount = 0;
        }

        //
        // Read the MDI control register
        //
        MdiRead(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiControlReg);

        //
        // Read the status register
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

        //
        // If there is a valid link or we alreadry tried once then use this Phy.
        //
        if ((MdiStatusReg & MDI_SR_LINK_STATUS) || (!Adapter->bLookForLink))
        {
#if DBG
            if (MdiStatusReg & MDI_SR_LINK_STATUS)
            {
                DBGPRINT(MP_INFO, ("   Using Phy at address %d with link\n", Adapter->PhyAddress));
            }
            else
            {
                DBGPRINT(MP_INFO, ("   Using Phy at address %d WITHOUT link!!!\n", Adapter->PhyAddress));
            }
#endif

            return(SetupPhy(Adapter));      // Exit with Link Path
        }
    } // End if valid PHY
    
    SCAN_PHY_NEXT:
                                   
    Adapter->CurrentScanPhyIndex++;
    if (Adapter->CurrentScanPhyIndex >= 32)
    {
        Adapter->bLookForLink = FALSE;
    }

    goto SCAN_PHY_START;
}


//***************************************************************************
//
// Name:            SelectPhy
//
// Description:     This routine will Isolate all Phy addresses on the MII
//                  Bus except for the one address to be 'selected'.  This
//                  Phy address will be un-isolated and auto-negotiation will
//                  be enabled, started, and completed.  The Phy will NOT be
//                  reset and the speed will NOT be set to any value (that is
//                  done in SetupPhy).
//
// Arguments:       SelectPhyAddress - PhyAddress to select
//                  WaitAutoNeg      - Flag TRUE = Wait for Auto Negociation to complete.
//                                          FALSE = don't wait. Good for 'No Link' case.
//
// Returns:         Nothing
//
// Modification log:
// Date      Who  Description
// --------  ---  --------------------------------------------------------
//***************************************************************************
VOID SelectPhy(
    IN PMP_ADAPTER  Adapter,
    IN UINT         SelectPhyAddress,
    IN BOOLEAN      WaitAutoNeg
    )
{
    UCHAR   i;
    USHORT  MdiControlReg; 
    USHORT  MdiStatusReg;
    
    //
    // Isolate all other phys and unisolate the one to query
    //
    for (i = 0; i < 32; i++)
    {
        if (i != SelectPhyAddress)
        {
            // isolate this phy
            MdiWrite(Adapter, MDI_CONTROL_REG, i, MDI_CR_ISOLATE);
            // wait 100 microseconds for the phy to isolate.
            NdisStallExecution(100);
        }
    }

    // unisolate the phy to query

    //
    // Read the MDI control register
    //
    MdiRead(Adapter, MDI_CONTROL_REG, SelectPhyAddress, FALSE, &MdiControlReg);

    //
    // Set/Clear bit unisolate this phy
    //
    MdiControlReg &= ~MDI_CR_ISOLATE;                // Clear the Isolate Bit

    //
    // issue the command to unisolate this Phy
    //
    MdiWrite(Adapter, MDI_CONTROL_REG, SelectPhyAddress, MdiControlReg);

    //
    // sticky bits on link
    //
    MdiRead(Adapter, MDI_STATUS_REG, SelectPhyAddress, FALSE, &MdiStatusReg);
    MdiRead(Adapter, MDI_STATUS_REG, SelectPhyAddress, FALSE, &MdiStatusReg);

    //
    // if we have link, don't mess with the phy
    //
    if (MdiStatusReg & MDI_SR_LINK_STATUS)
        return;

    //
    // Read the MDI control register
    //
    MdiRead(Adapter, MDI_CONTROL_REG, SelectPhyAddress, FALSE, &MdiControlReg);

    //
    // set Restart auto-negotiation
    //
    MdiControlReg |= MDI_CR_AUTO_SELECT;             // Set Auto Neg Enable
    MdiControlReg |= MDI_CR_RESTART_AUTO_NEG;        // Restart Auto Neg

    //
    // restart the auto-negotion process
    //
    MdiWrite(Adapter, MDI_CONTROL_REG, SelectPhyAddress, MdiControlReg);

    //
    // wait 200 microseconds for the phy to unisolate.
    //
    NdisStallExecution(200);

    if (WaitAutoNeg)
    {
        //
        // wait for auto-negotiation to complete (up to 3.5 seconds)
        //
        for (i = RENEGOTIATE_TIME; i != 0; i--)
        {
            // Read the status register twice because of sticky bits
            MdiRead(Adapter, MDI_STATUS_REG, SelectPhyAddress, FALSE, &MdiStatusReg);
            MdiRead(Adapter, MDI_STATUS_REG, SelectPhyAddress, FALSE, &MdiStatusReg);

            if (MdiStatusReg & MDI_SR_AUTO_NEG_COMPLETE)
                break;

            MP_STALL_EXECUTION(100);
        }
    }
}

//-----------------------------------------------------------------------------
// Procedure:   SetupPhy
//
// Description: This routine will setup phy 1 or phy 0 so that it is configured
//              to match a speed and duplex over-ride option.  If speed or
//              duplex mode is not explicitly specified in the registry, the
//              driver will skip the speed and duplex over-ride code, and
//              assume the adapter is automatically setting the line speed, and
//              the duplex mode.  At the end of this routine, any truly Phy
//              specific code will be executed (each Phy has its own quirks,
//              and some require that certain special bits are set).
//
//   NOTE:  The driver assumes that SPEED and FORCEFDX are specified at the
//          same time. If FORCEDPX is set without speed being set, the driver
//          will encouter a fatal error and log a message into the event viewer.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Result:
// Returns:
//  NDIS_STATUS_SUCCESS
//  NDIS_STATUS_FAILURE
//-----------------------------------------------------------------------------

NDIS_STATUS SetupPhy(
    IN PMP_ADAPTER Adapter)
{
    USHORT   MdiControlReg = 0;
    USHORT   MdiStatusReg = 0; 
    USHORT   MdiIdLowReg = 0; 
    USHORT   MdiIdHighReg = 0;
    USHORT   MdiMiscReg = 0;
    USHORT   LastMdiMiscReg;
    UINT     PhyId;
    BOOLEAN  ForcePhySetting = FALSE;
    UINT     i;

    //
    // If we are NOT forcing a setting for line speed or full duplex, then
    // we won't force a link setting, and we'll jump down to the phy
    // specific code.
    //
    if (((Adapter->AiTempSpeed) || (Adapter->AiForceDpx)))
    {
        
        //
        // Find out what kind of technology this Phy is capable of.
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

        //
        // Read the MDI control register at our phy
        //
        MdiRead(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiControlReg);

        //
        // Now check the validity of our forced option.  If the force option is
        // valid, then force the setting.  If the force option is not valid,
        // we'll set a flag indicating that we should error out.
        //

        //
        // If speed is forced to 10mb
        //
        if (Adapter->AiTempSpeed == 10)
        {
            // If half duplex is forced
            if (Adapter->AiForceDpx == 1)
            {
                if (MdiStatusReg & MDI_SR_10T_HALF_DPX)
                {
                    DBGPRINT(MP_INFO, ("   Forcing 10mb 1/2 duplex\n"));
                    MdiControlReg &= ~(MDI_CR_10_100 | MDI_CR_AUTO_SELECT | MDI_CR_FULL_HALF);
                    ForcePhySetting = TRUE;
                }
            }

            // If full duplex is forced
            else if (Adapter->AiForceDpx == 2)
            {
                if (MdiStatusReg & MDI_SR_10T_FULL_DPX)
                {
                    DBGPRINT(MP_INFO, ("   Forcing 10mb full duplex\n"));
                    MdiControlReg &= ~(MDI_CR_10_100 | MDI_CR_AUTO_SELECT);
                    MdiControlReg |= MDI_CR_FULL_HALF;
                    ForcePhySetting = TRUE;
                }
            }

            // If auto duplex (we actually set phy to 1/2)
            else
            {
                if (MdiStatusReg & (MDI_SR_10T_FULL_DPX | MDI_SR_10T_HALF_DPX))
                {
                    DBGPRINT(MP_INFO, ("   Forcing 10mb auto duplex\n"));
                    MdiControlReg &= ~(MDI_CR_10_100 | MDI_CR_AUTO_SELECT | MDI_CR_FULL_HALF);
                    ForcePhySetting = TRUE;
                    Adapter->AiForceDpx = 1;
                }
            }
        }

        //
        // If speed is forced to 100mb
        //
        else if (Adapter->AiTempSpeed == 100)
        {
            // If half duplex is forced
            if (Adapter->AiForceDpx == 1)
            {
                if (MdiStatusReg & (MDI_SR_TX_HALF_DPX | MDI_SR_T4_CAPABLE))
                {
                    DBGPRINT(MP_INFO, ("   Forcing 100mb half duplex\n"));
                    MdiControlReg &= ~(MDI_CR_AUTO_SELECT | MDI_CR_FULL_HALF);
                    MdiControlReg |= MDI_CR_10_100;
                    ForcePhySetting = TRUE;
                }
            }

            // If full duplex is forced
            else if (Adapter->AiForceDpx == 2)
            {
                if (MdiStatusReg & MDI_SR_TX_FULL_DPX)
                {
                    DBGPRINT(MP_INFO, ("   Forcing 100mb full duplex\n"));
                    MdiControlReg &= ~MDI_CR_AUTO_SELECT;
                    MdiControlReg |= (MDI_CR_10_100 | MDI_CR_FULL_HALF);
                    ForcePhySetting = TRUE;
                }
            }

            // If auto duplex (we set phy to 1/2)
            else
            {
                if (MdiStatusReg & (MDI_SR_TX_HALF_DPX | MDI_SR_T4_CAPABLE))
                {
                    DBGPRINT(MP_INFO, ("   Forcing 100mb auto duplex\n"));
                    MdiControlReg &= ~(MDI_CR_AUTO_SELECT | MDI_CR_FULL_HALF);
                    MdiControlReg |= MDI_CR_10_100;
                    ForcePhySetting = TRUE;
                    Adapter->AiForceDpx = 1;
                }
            }
        }

        if (ForcePhySetting == FALSE)
        {
            DBGPRINT(MP_INFO, ("   Can't force speed=%d, duplex=%d\n",Adapter->AiTempSpeed, Adapter->AiForceDpx));

            return(NDIS_STATUS_FAILURE);
        }

        //
        // Write the MDI control register with our new Phy configuration
        //
        MdiWrite(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, MdiControlReg);

        //
        // wait 100 milliseconds for auto-negotiation to complete
        //
        MP_STALL_EXECUTION(100);

    }

    //
    // Find out specifically what Phy this is.  We do this because for certain
    // phys there are specific bits that must be set so that the phy and the
    // 82557 work together properly.
    //
    MdiRead(Adapter, PHY_ID_REG_1, Adapter->PhyAddress, FALSE, &MdiIdLowReg);
    MdiRead(Adapter, PHY_ID_REG_2, Adapter->PhyAddress, FALSE, &MdiIdHighReg);

    PhyId =  ((UINT) MdiIdLowReg | ((UINT) MdiIdHighReg << 16));

    DBGPRINT(MP_INFO, ("   Phy ID is %x\n", PhyId));

    //
    // And out the revsion field of the Phy ID so that we'll be able to detect
    // future revs of the same Phy.
    //
    PhyId &= PHY_MODEL_REV_ID_MASK;

    //
    // Handle the National TX
    //
    if (PhyId == PHY_NSC_TX)
    {
        DBGPRINT(MP_INFO, ("   Found a NSC TX Phy\n"));

        MdiRead(Adapter, NSC_CONG_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiMiscReg);

        MdiMiscReg |= (NSC_TX_CONG_TXREADY | NSC_TX_CONG_F_CONNECT);

        //
        // If we are configured to do congestion control, then enable the
        // congestion control bit in the National Phy
        //
        if (Adapter->Congest)
            MdiMiscReg |= NSC_TX_CONG_ENABLE;
        else
            MdiMiscReg &= ~NSC_TX_CONG_ENABLE;

        MdiWrite(Adapter, NSC_CONG_CONTROL_REG, Adapter->PhyAddress, MdiMiscReg);
    }

    FindPhySpeedAndDpx(Adapter, PhyId);

    DBGPRINT(MP_WARN, ("   Current Speed=%d, Current Duplex=%d\n",Adapter->usLinkSpeed, Adapter->usDuplexMode));

    return(NDIS_STATUS_SUCCESS);
}


//-----------------------------------------------------------------------------
// Procedure:   FindPhySpeedAndDpx
//
// Description: This routine will figure out what line speed and duplex mode
//              the PHY is currently using.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      PhyId - The ID of the PHY in question.
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------

VOID FindPhySpeedAndDpx(
    IN PMP_ADAPTER  Adapter,
    IN UINT         PhyId
    )
{
    USHORT  MdiStatusReg = 0;
    USHORT  MdiMiscReg = 0;
    USHORT  MdiOwnAdReg = 0;
    USHORT  MdiLinkPartnerAdReg = 0;
    
    //
    // If there was a speed and/or duplex override, then set our current
    // value accordingly
    //
    Adapter->usLinkSpeed = Adapter->AiTempSpeed;
    Adapter->usDuplexMode = (USHORT) Adapter->AiForceDpx;

    //
    // If speed and duplex were forced, then we know our current settings, so
    // we'll just return.  Otherwise, we'll need to figure out what NWAY set
    // us to.
    //
    if (Adapter->usLinkSpeed && Adapter->usDuplexMode)
    {
        return;
    }

    //
    // If we didn't have a valid link, then we'll assume that our current
    // speed is 10mb half-duplex.
    //

    //
    // Read the status register twice because of sticky bits
    //
    MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
    MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

    //
    // If there wasn't a valid link then use default speed & duplex
    //
    if (!(MdiStatusReg & MDI_SR_LINK_STATUS))
    {
        DBGPRINT(MP_INFO, ("   Link Not found for speed detection!!!  Using defaults.\n"));

        Adapter->usLinkSpeed = 10;
        Adapter->usDuplexMode = 1;

        return;
    }

    //
    // If this is an Intel PHY (a T4 PHY_100 or a TX PHY_TX), then read bits
    // 1 and 0 of extended register 0, to get the current speed and duplex
    // settings.
    //
    if ((PhyId == PHY_100_A) || (PhyId == PHY_100_C) || (PhyId == PHY_TX_ID))
    {
        DBGPRINT(MP_INFO, ("   Detecting Speed/Dpx for an Intel PHY\n"));

        //
        // Read extended register 0
        //
        MdiRead(Adapter, EXTENDED_REG_0, Adapter->PhyAddress, FALSE, &MdiMiscReg);

        //
        // Get current speed setting
        //
        if (MdiMiscReg & PHY_100_ER0_SPEED_INDIC)
        {
            Adapter->usLinkSpeed = 100;
        }
        else 
        {
            Adapter->usLinkSpeed    = 10;
        }

        //
        //
        // Get current duplex setting -- if bit is set then FDX is enabled
        //
        if (MdiMiscReg & PHY_100_ER0_FDX_INDIC)
        {
            Adapter->usDuplexMode = 2;
        }
        else
        {
            Adapter->usDuplexMode   = 1;
        }

        return;
    }

    //
    // Read our link partner's advertisement register
    //
    MdiRead(Adapter, 
            AUTO_NEG_LINK_PARTNER_REG, 
            Adapter->PhyAddress, 
            FALSE,
            &MdiLinkPartnerAdReg);
    //
    // See if Auto-Negotiation was complete (bit 5, reg 1)
    //
    MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

    //
    // If a True NWAY connection was made, then we can detect speed/duplex by
    // ANDing our adapter's advertised abilities with our link partner's
    // advertised ablilities, and then assuming that the highest common
    // denominator was chosed by NWAY.
    //
    if ((MdiLinkPartnerAdReg & NWAY_LP_ABILITY) &&
        (MdiStatusReg & MDI_SR_AUTO_NEG_COMPLETE))
    {
        DBGPRINT(MP_INFO, ("   Detecting Speed/Dpx from NWAY connection\n"));

        //
        // Read our advertisement register
        //
        MdiRead(Adapter, AUTO_NEG_ADVERTISE_REG, Adapter->PhyAddress, FALSE, &MdiOwnAdReg);

        //
        // AND the two advertisement registers together, and get rid of any
        // extraneous bits.
        //
        MdiOwnAdReg &= (MdiLinkPartnerAdReg & NWAY_LP_ABILITY);

        //
        // Get speed setting
        //
        if (MdiOwnAdReg & (NWAY_AD_TX_HALF_DPX | NWAY_AD_TX_FULL_DPX | NWAY_AD_T4_CAPABLE))
        {
            Adapter->usLinkSpeed = 100;
        }
        else
        {
            Adapter->usLinkSpeed    = 10;
        }

        //
        // Get duplex setting -- use priority resolution algorithm
        //
        if (MdiOwnAdReg & (NWAY_AD_T4_CAPABLE))
        {
            Adapter->usDuplexMode = 1;
            return;
        }
        else if (MdiOwnAdReg & (NWAY_AD_TX_FULL_DPX))
        {
            Adapter->usDuplexMode = 2;
            return;
        }
        else if (MdiOwnAdReg & (NWAY_AD_TX_HALF_DPX))
        {
            Adapter->usDuplexMode = 1;
            return;
        }
        else if (MdiOwnAdReg & (NWAY_AD_10T_FULL_DPX))
        {
            Adapter->usDuplexMode = 2;
            return;
        }
        else
        {
            Adapter->usDuplexMode = 1;
            return;
        }
    }

    //
    // If we are connected to a non-NWAY repeater or hub, and the line
    // speed was determined automatically by parallel detection, then we have
    // no way of knowing exactly what speed the PHY is set to unless that PHY
    // has a propietary register which indicates speed in this situation.  The
    // NSC TX PHY does have such a register.  Also, since NWAY didn't establish
    // the connection, the duplex setting should HALF duplex.
    //
    Adapter->usDuplexMode = 1;

    if (PhyId == PHY_NSC_TX)
    {
        DBGPRINT(MP_INFO, ("   Detecting Speed/Dpx from non-NWAY NSC connection\n"));

        //
        // Read register 25 to get the SPEED_10 bit
        //
        MdiRead(Adapter, NSC_SPEED_IND_REG, Adapter->PhyAddress, FALSE, &MdiMiscReg);

        //
        // If bit 6 was set then we're at 10mb
        //
        if (MdiMiscReg & NSC_TX_SPD_INDC_SPEED)
        {
            Adapter->usLinkSpeed = 10;
        }
        else 
	{
            Adapter->usLinkSpeed    = 100;
        }
    }
    //
    // If we don't know what line speed we are set at, then we'll default to
    // 10mbs
    //
    else 
    {
        Adapter->usLinkSpeed  = 10;
    }
}


//-----------------------------------------------------------------------------
// Procedure:   ResetPhy
//
// Description: This routine will reset the PHY that the adapter is currently
//              configured to use.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------

VOID ResetPhy(
    IN PMP_ADAPTER Adapter
    )
{
    USHORT  MdiControlReg;

    //
    // Reset the Phy, enable auto-negotiation, and restart auto-negotiation.
    //
    MdiControlReg = (MDI_CR_AUTO_SELECT | MDI_CR_RESTART_AUTO_NEG | MDI_CR_RESET);

    //
    // Write the MDI control register with our new Phy configuration
    //
    MdiWrite(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, MdiControlReg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\precomp.h ===
#include <ndis.h>

#include "e100_equ.h"
#include "e100_557.h"
#include "e100_def.h"

#include "mp_dbg.h"
#include "mp_cmn.h"
#include "mp_def.h"
#include "mp.h"
#include "mp_nic.h"

#include "e100_sup.h"
  
#if OFFLOAD
#include "offload.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\50\makefile.inc ===
$(O)\e100.mof: ..\e100.mof

$(O)\e100_wmi.h: $(O)\e100.bmf
    wmimofck -h$(O)\e100_wmi.h $(O)\e100.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\51\makefile.inc ===
$(O)\e100.mof: ..\e100.mof

$(O)\e100_wmi.h: $(O)\e100.bmf 
    wmimofck -h$(O)\e100_wmi.h $(O)\e100.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\offload.h ===
/*++
 
Copyright (c) 2001  Microsoft Corporation

Module Name:
    offload.h

Abstract:
    Task offloading header file

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
                            created

Notes:

--*/

#if OFFLOAD
//
//  Define the maximum size of large TCP packets the driver can offload.
//  This sample driver uses shared memory to map the large packets, 
//  LARGE_SEND_OFFLOAD_SIZE is useless in this case, so we just define 
//  it as NIC_MAX_PACKET_SIZE. But shipping drivers should define
//  LARGE_SEND_OFFLOAD_SIZE if they support LSO, and use it as 
//  MaximumPhysicalMapping  when they call NdisMInitializeScatterGatherDma 
//  if they use ScatterGather method. If the drivers don't support
//  LSO, then MaximumPhysicalMapping is NIC_MAX_PACKET_SIZE.
//
#define LARGE_SEND_OFFLOAD_SIZE     NIC_MAX_PACKET_SIZE
//
// Definitions for header flags.
//
#define TCP_FLAG_FIN    0x00000100
#define TCP_FLAG_SYN    0x00000200
#define TCP_FLAG_RST    0x00000400
#define TCP_FLAG_PUSH   0x00000800
#define TCP_FLAG_ACK    0x00001000
#define TCP_FLAG_URG    0x00002000

//
// These are the maximum size of TCP and IP options
// 
#define TCP_MAX_OPTION_SIZE     40
#define IP_MAX_OPTION_SIZE      40

//
// Structure of a TCP packet header.
//
struct TCPHeader {
    USHORT    tcp_src;                // Source port.
    USHORT    tcp_dest;               // Destination port.
    int       tcp_seq;                // Sequence number.
    int       tcp_ack;                // Ack number.
    USHORT    tcp_flags;              // Flags and data offset.
    USHORT    tcp_window;             // Window offered.
    USHORT    tcp_xsum;               // Checksum.
    USHORT    tcp_urgent;             // Urgent pointer.
};

typedef struct TCPHeader TCPHeader;


//
// IP Header format.
//
typedef struct IPHeader {
    UCHAR     iph_verlen;             // Version and length.
    UCHAR     iph_tos;                // Type of service.
    USHORT    iph_length;             // Total length of datagram.
    USHORT    iph_id;                 // Identification.
    USHORT    iph_offset;             // Flags and fragment offset.
    UCHAR     iph_ttl;                // Time to live.
    UCHAR     iph_protocol;           // Protocol.
    USHORT    iph_xsum;               // Header checksum.
    UINT      iph_src;                // Source address.
    UINT      iph_dest;               // Destination address.
} IPHeader;

#define TCP_IP_MAX_HEADER_SIZE  TCP_MAX_OPTION_SIZE+IP_MAX_OPTION_SIZE \
                                +sizeof(TCPHeader)+sizeof(IPHeader)


#define LARGE_SEND_MEM_SIZE_OPTION       3
//
// Try different size of shared memory to use
// 
extern ULONG LargeSendSharedMemArray[];

//
// Compute the checksum
// 
#define XSUM(_TmpXsum, _StartVa, _PacketLength, _Offset)                             \
{                                                                                    \
    PUSHORT  WordPtr = (PUSHORT)((PUCHAR)_StartVa + _Offset);                        \
    ULONG    WordCount = (_PacketLength) >> 1;                                       \
    BOOLEAN  fOddLen = (BOOLEAN)((_PacketLength) & 1);                               \
    while (WordCount--)                                                              \
    {                                                                                \
        _TmpXsum += *WordPtr;                                                        \
        WordPtr++;                                                                   \
    }                                                                                \
    if (fOddLen)                                                                     \
    {                                                                                \
        _TmpXsum += (USHORT)*((PUCHAR)WordPtr);                                      \
    }                                                                                \
    _TmpXsum = (((_TmpXsum >> 16) | (_TmpXsum << 16)) + _TmpXsum) >> 16;             \
}                                                                                        
        

//
// Function prototypes
// 
VOID
e100DumpPkt(
    PNDIS_PACKET Packet
    );

VOID
CalculateChecksum(
    PVOID        StartVa,
    ULONG        PacketLength,
    PNDIS_PACKET pPacket,
    ULONG        IpHdrOffset
    );

VOID
CalculateTcpChecksum(
    PVOID   StartVa,
    ULONG   PacketLength,
    ULONG  IpHdrOffset
    );

VOID
CalculateIpChecksum(
    PUCHAR StartVa,
    ULONG  IpHdrOffset
    );

VOID 
CalculateUdpChecksum(
    PNDIS_PACKET Packet,
    ULONG  IpHdrOffset
    );


VOID
MPOffloadSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    );

NDIS_STATUS 
MpOffloadSendPacket(
    IN  PMP_ADAPTER     Adapter,
    IN  PNDIS_PACKET    Packet,
    IN  BOOLEAN         bFromQueue
    );


VOID 
MP_OFFLOAD_FREE_SEND_PACKET(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_TCB         pMpTcb
    );

VOID 
DisableOffload(
    IN  PMP_ADAPTER Adapter
    );

#endif // OFFLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\kd\e100kd.h ===
//
// Copy some definitions in mp_dbg.h here
//
#define MP_LOUD       4
#define MP_INFO       3
#define MP_TRACE      2
#define MP_WARN       1
#define MP_ERROR      0


#define SIGN_EXTEND(_v) \
   if (GetTypeSize("PVOID") != sizeof(ULONG64)) \
      (_v) = (ULONG64) (LONG64) (LONG) (_v)

#define DBG_TEST_FLAG(_V, _F)                 (((_V) & (_F)) != 0)

void PrintMpTcbDetails(ULONG64 pMpTcb, int Verbosity);
void PrintHwTcbDetails(ULONG64 pHwTcb);
void PrintMpRfdDetails(ULONG64 pMpRfd, int Verbosity);
void PrintHwRfdDetails(ULONG64 pHwRfd);

BOOL GetData( IN LPVOID ptr, IN ULONG64 AddressPtr, IN ULONG size, IN PCSTR type );


ULONG GetFieldOffsetAndSize(
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize);

ULONG GetUlongFromAddress(
   ULONG64 Location);

ULONG64 GetPointerFromAddress(
   ULONG64 Location);

ULONG GetUlongValue(
   PCHAR String);

ULONG64 GetPointerValue(
   PCHAR String);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\routines.c ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    routines.c

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop
#pragma warning (disable: 4514 4706)

//-----------------------------------------------------------------------------
// Procedure:   MdiWrite
//
// Description: This routine will write a value to the specified MII register
//              of an external MDI compliant device (e.g. PHY 100).  The
//              command will execute in polled mode.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      RegAddress - The MII register that we are writing to
//      PhyAddress - The MDI address of the Phy component.
//      DataValue - The value that we are writing to the MII register.
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------
VOID MdiWrite(
    IN PMP_ADAPTER Adapter,
    IN ULONG RegAddress,
    IN ULONG PhyAddress,
    IN USHORT DataValue)
{
    BOOLEAN bResult;

    // Issue the write command to the MDI control register.
    Adapter->CSRAddress->MDIControl = (((ULONG) DataValue) |
                                          (RegAddress << 16) |
                                          (PhyAddress << 21) |
                                          (MDI_WRITE << 26));

    // wait 20usec before checking status
    NdisStallExecution(20);

    // wait 2 seconds for the mdi write to complete
    MP_STALL_AND_WAIT(Adapter->CSRAddress->MDIControl & MDI_PHY_READY, 2000, bResult);
    
    if (!bResult)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
    }
}


//-----------------------------------------------------------------------------
// Procedure:   MdiRead
//
// Description: This routine will read a value from the specified MII register
//              of an external MDI compliant device (e.g. PHY 100), and return
//              it to the calling routine.  The command will execute in polled
//              mode.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      RegAddress - The MII register that we are reading from
//      PhyAddress - The MDI address of the Phy component.
//      Recoverable - Whether the hardware error(if any)if recoverable or not
//
// Results:
//      DataValue - The value that we read from the MII register.
//
// Returns:
//     None
//-----------------------------------------------------------------------------
BOOLEAN MdiRead(
    IN PMP_ADAPTER Adapter,
    IN ULONG RegAddress,
    IN ULONG PhyAddress,
    IN BOOLEAN  Recoverable,
    IN OUT PUSHORT DataValue)
{
    BOOLEAN bResult;
               
    // Issue the read command to the MDI control register.
    Adapter->CSRAddress->MDIControl = ((RegAddress << 16) |
                                          (PhyAddress << 21) |
                                          (MDI_READ << 26));

    // wait 20usec before checking status
    NdisStallExecution(20);

    // Wait up to 2 seconds for the mdi read to complete
    MP_STALL_AND_WAIT(Adapter->CSRAddress->MDIControl & MDI_PHY_READY, 2000, bResult);
    if (!bResult)
    {
        if (!Recoverable)
        {
            MP_SET_NON_RECOVER_ERROR(Adapter);
        }
        MP_SET_HARDWARE_ERROR(Adapter);
        return bResult;
    }

    *DataValue = (USHORT) Adapter->CSRAddress->MDIControl;
    return bResult;

}


//-----------------------------------------------------------------------------
// Procedure:   DumpStatsCounters
//
// Description: This routine will dump and reset the 82557's internal
//              Statistics counters.  The current stats dump values will be
//              added to the "Adapter's" overall statistics.
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------
VOID DumpStatsCounters(
    IN PMP_ADAPTER Adapter)
{
    BOOLEAN bResult;

    // The query is for a driver statistic, so we need to first
    // update our statistics in software.

    // clear the dump counters complete DWORD
    Adapter->StatsCounters->CommandComplete = 0;

    NdisAcquireSpinLock(&Adapter->Lock);
    
    // Dump and reset the hardware's statistic counters
    D100IssueScbCommand(Adapter, SCB_CUC_DUMP_RST_STAT, TRUE);

    // Restore the resume transmit software flag.  After the dump counters
    // command is issued, we should do a WaitSCB before issuing the next send.
    Adapter->ResumeWait = TRUE;
    
    NdisReleaseSpinLock(&Adapter->Lock);

    // wait up to 2 seconds for the dump/reset to complete
    MP_STALL_AND_WAIT(Adapter->StatsCounters->CommandComplete == 0xA007, 2000, bResult);
    if (!bResult)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
        return;
    }

    // Output the debug counters to the debug terminal.
    DBGPRINT(MP_INFO, ("Good Transmits %d\n", Adapter->StatsCounters->XmtGoodFrames));
    DBGPRINT(MP_INFO, ("Good Receives %d\n", Adapter->StatsCounters->RcvGoodFrames));
    DBGPRINT(MP_INFO, ("Max Collisions %d\n", Adapter->StatsCounters->XmtMaxCollisions));
    DBGPRINT(MP_INFO, ("Late Collisions %d\n", Adapter->StatsCounters->XmtLateCollisions));
    DBGPRINT(MP_INFO, ("Transmit Underruns %d\n", Adapter->StatsCounters->XmtUnderruns));
    DBGPRINT(MP_INFO, ("Transmit Lost CRS %d\n", Adapter->StatsCounters->XmtLostCRS));
    DBGPRINT(MP_INFO, ("Transmits Deferred %d\n", Adapter->StatsCounters->XmtDeferred));
    DBGPRINT(MP_INFO, ("One Collision xmits %d\n", Adapter->StatsCounters->XmtSingleCollision));
    DBGPRINT(MP_INFO, ("Mult Collision xmits %d\n", Adapter->StatsCounters->XmtMultCollisions));
    DBGPRINT(MP_INFO, ("Total Collisions %d\n", Adapter->StatsCounters->XmtTotalCollisions));

    DBGPRINT(MP_INFO, ("Receive CRC errors %d\n", Adapter->StatsCounters->RcvCrcErrors));
    DBGPRINT(MP_INFO, ("Receive Alignment errors %d\n", Adapter->StatsCounters->RcvAlignmentErrors));
    DBGPRINT(MP_INFO, ("Receive no resources %d\n", Adapter->StatsCounters->RcvResourceErrors));
    DBGPRINT(MP_INFO, ("Receive overrun errors %d\n", Adapter->StatsCounters->RcvOverrunErrors));
    DBGPRINT(MP_INFO, ("Receive CDT errors %d\n", Adapter->StatsCounters->RcvCdtErrors));
    DBGPRINT(MP_INFO, ("Receive short frames %d\n", Adapter->StatsCounters->RcvShortFrames));

    // update packet counts
    Adapter->GoodTransmits += Adapter->StatsCounters->XmtGoodFrames;
    Adapter->GoodReceives += Adapter->StatsCounters->RcvGoodFrames;

    // update transmit error counts
    Adapter->TxAbortExcessCollisions += Adapter->StatsCounters->XmtMaxCollisions;
    Adapter->TxLateCollisions += Adapter->StatsCounters->XmtLateCollisions;
    Adapter->TxDmaUnderrun += Adapter->StatsCounters->XmtUnderruns;
    Adapter->TxLostCRS += Adapter->StatsCounters->XmtLostCRS;
    Adapter->TxOKButDeferred += Adapter->StatsCounters->XmtDeferred;
    Adapter->OneRetry += Adapter->StatsCounters->XmtSingleCollision;
    Adapter->MoreThanOneRetry += Adapter->StatsCounters->XmtMultCollisions;
    Adapter->TotalRetries += Adapter->StatsCounters->XmtTotalCollisions;

    // update receive error counts
    Adapter->RcvCrcErrors += Adapter->StatsCounters->RcvCrcErrors;
    Adapter->RcvAlignmentErrors += Adapter->StatsCounters->RcvAlignmentErrors;
    Adapter->RcvResourceErrors += Adapter->StatsCounters->RcvResourceErrors;
    Adapter->RcvDmaOverrunErrors += Adapter->StatsCounters->RcvOverrunErrors;
    Adapter->RcvCdtFrames += Adapter->StatsCounters->RcvCdtErrors;
    Adapter->RcvRuntErrors += Adapter->StatsCounters->RcvShortFrames;
}


//-----------------------------------------------------------------------------
// Procedure:   NICIssueSelectiveReset
//
// Description: This routine will issue a selective reset, forcing the adapter
//              the CU and RU back into their idle states.  The receive unit
//              will then be re-enabled if it was previously enabled, because
//              an RNR interrupt will be generated when we abort the RU.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------

VOID NICIssueSelectiveReset(
    PMP_ADAPTER Adapter)
{
    NDIS_STATUS     Status;
    BOOLEAN         bResult;
    
    // Wait for the SCB to clear before we check the CU status.
    if (!MP_TEST_FLAG(Adapter, fMP_ADAPTER_HARDWARE_ERROR))
    {
        WaitScb(Adapter);
    }

    // If we have issued any transmits, then the CU will either be active, or
    // in the suspended state.  If the CU is active, then we wait for it to be
    // suspended.  If the the CU is suspended, then we need to put the CU back
    // into the idle state by issuing a selective reset.
    if (Adapter->TransmitIdle == FALSE)
    {
        // Wait up to 2 seconds for suspended state
        MP_STALL_AND_WAIT((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) != SCB_CUS_ACTIVE, 2000, bResult) 
        if (!bResult)
        {
            MP_SET_HARDWARE_ERROR(Adapter);
        }

        // Check the current status of the receive unit
        if ((Adapter->CSRAddress->ScbStatus & SCB_RUS_MASK) != SCB_RUS_IDLE)
        {
            // Issue an RU abort.  Since an interrupt will be issued, the
            // RU will be started by the DPC.
            Status = D100IssueScbCommand(Adapter, SCB_RUC_ABORT, TRUE);
        }

        // Issue a selective reset.
        DBGPRINT(MP_INFO, ("CU suspended. ScbStatus=%04x Issue selective reset\n", Adapter->CSRAddress->ScbStatus));
        Adapter->CSRAddress->Port = PORT_SELECTIVE_RESET;

        // Wait after a port sel-reset command
        NdisStallExecution(NIC_DELAY_POST_RESET);

        // wait up to 2 ms for port command to complete                                                           
        MP_STALL_AND_WAIT(Adapter->CSRAddress->Port == 0, 2, bResult) 
        if (!bResult)
        {
            MP_SET_HARDWARE_ERROR(Adapter);
        }

        // disable interrupts after issuing reset, because the int
        // line gets raised when reset completes.
        NICDisableInterrupt(Adapter);

        // Restore the transmit software flags.
        Adapter->TransmitIdle = TRUE;
        Adapter->ResumeWait = TRUE;
    }
}

VOID NICIssueFullReset(
    PMP_ADAPTER Adapter)
{
    BOOLEAN     bResult;

    NICIssueSelectiveReset(Adapter);

    Adapter->CSRAddress->Port = PORT_SOFTWARE_RESET;

    // wait up to 2 ms for port command to complete                                                           
    MP_STALL_AND_WAIT(Adapter->CSRAddress->Port == 0, 2, bResult);
    if (!bResult)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
        return;
    }

    NICDisableInterrupt(Adapter);
}


//-----------------------------------------------------------------------------
// Procedure:   D100SubmitCommandBlockAndWait
//
// Description: This routine will submit a command block to be executed, and
//              then it will wait for that command block to be executed.  Since
//              board ints will be disabled, we will ack the interrupt in
//              this routine.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//  NDIS_STATUS_SUCCESS
//  NDIS_STATUS_HARD_ERRORS
//-----------------------------------------------------------------------------

NDIS_STATUS D100SubmitCommandBlockAndWait(
    IN PMP_ADAPTER Adapter)
{
    NDIS_STATUS     Status;
    BOOLEAN         bResult;

    // Points to the Non Tx Command Block.
    volatile PNON_TRANSMIT_CB CommandBlock = Adapter->NonTxCmdBlock;

    // Set the Command Block to be the last command block
    CommandBlock->NonTxCb.Config.ConfigCBHeader.CbCommand |= CB_EL_BIT;

    // Clear the status of the command block
    CommandBlock->NonTxCb.Config.ConfigCBHeader.CbStatus = 0;

#if DBG
    // Don't try to start the CU if the command unit is active.
    if ((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) == SCB_CUS_ACTIVE)
    {
        DBGPRINT(MP_ERROR, ("Scb "PTR_FORMAT" ScbStatus %04x\n", Adapter->CSRAddress, Adapter->CSRAddress->ScbStatus));
        ASSERT(FALSE);
        MP_SET_HARDWARE_ERROR(Adapter);
        return(NDIS_STATUS_HARD_ERRORS);
    }
#endif

    // Start the command unit.
    D100IssueScbCommand(Adapter, SCB_CUC_START, FALSE);

    // Wait for the SCB to clear, indicating the completion of the command.
    if (!WaitScb(Adapter))
    {
        return(NDIS_STATUS_HARD_ERRORS);
    }

    // Wait for some status, timeout value 3 secs
    MP_STALL_AND_WAIT(CommandBlock->NonTxCb.Config.ConfigCBHeader.CbStatus & CB_STATUS_COMPLETE, 3000, bResult);
    if (!bResult)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
        return(NDIS_STATUS_HARD_ERRORS);
    }

    // Ack any interrupts
    if (Adapter->CSRAddress->ScbStatus & SCB_ACK_MASK)
    {
        // Ack all pending interrupts now
        Adapter->CSRAddress->ScbStatus &= SCB_ACK_MASK;
    }

    // Check the status of the command, and if the command failed return FALSE,
    // otherwise return TRUE.
    if (!(CommandBlock->NonTxCb.Config.ConfigCBHeader.CbStatus & CB_STATUS_OK))
    {
        DBGPRINT(MP_ERROR, ("Command failed\n"));
        MP_SET_HARDWARE_ERROR(Adapter);
        Status = NDIS_STATUS_HARD_ERRORS;
    }
    else
        Status = NDIS_STATUS_SUCCESS;

    return(Status);
}

//-----------------------------------------------------------------------------
// Procedure: GetConnectionStatus
//
// Description: This function returns the connection status that is
//              a required indication for PC 97 specification from MS
//              the value we are looking for is if there is link to the
//              wire or not.
//
// Arguments: IN Adapter structure pointer
//
// Returns:   NdisMediaStateConnected
//            NdisMediaStateDisconnected
//-----------------------------------------------------------------------------
NDIS_MEDIA_STATE NICGetMediaState(IN PMP_ADAPTER Adapter)
{
    USHORT  MdiStatusReg = 0;
    BOOLEAN bResult1;
    BOOLEAN bResult2;
     
    
    // Read the status register at phy 1
    bResult1 = MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, TRUE, &MdiStatusReg);
    bResult2 = MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, TRUE, &MdiStatusReg);
    
    // if there is hardware failure, or let the state remains the same
    if (!bResult1 || !bResult2)
    {
        return Adapter->MediaState;
    }
    if (MdiStatusReg & MDI_SR_LINK_STATUS)
        return(NdisMediaStateConnected);
    else
        return(NdisMediaStateDisconnected);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\kd\e100kd.c ===
// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "e100_equ.h"
#include "e100_557.h"

#include "mp_cmn.h"

#include "e100kd.h"

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER64, 0};


USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;                 // is debuggee a CHK build?

typedef struct
{
    char           Name[16];
    unsigned int   Val;
} DBG_LEVEL;

DBG_LEVEL DbgLevel[] = {
    {"ERROR", MP_ERROR},
    {"WARN",  MP_WARN},
    {"TRACE", MP_TRACE},
    {"INFO",  MP_INFO},
    {"LOUD",  MP_LOUD}
};

typedef struct
{
    char  Name[32];
    unsigned int   Val;

} DBG_ADAPTER_FLAGS, DBG_FILTER;

DBG_ADAPTER_FLAGS DbgAdapterFlags[] = {
    {"SCATTER_GATHER",      fMP_ADAPTER_SCATTER_GATHER},       
    {"MAP_REGISTER",        fMP_ADAPTER_MAP_REGISTER},     
    {"RECV_LOOKASIDE",      fMP_ADAPTER_RECV_LOOKASIDE},   
    {"INTERRUPT_IN_USE",    fMP_ADAPTER_INTERRUPT_IN_USE}, 
    {"RESET_IN_PROGRESS",   fMP_ADAPTER_RESET_IN_PROGRESS},                                 
    {"NO_CABLE",            fMP_ADAPTER_NO_CABLE},         
    {"HARDWARE_ERROR",      fMP_ADAPTER_HARDWARE_ERROR}   
};

//
// Ndis Packet Filter Bits (OID_GEN_CURRENT_PACKET_FILTER).
//
#define NDIS_PACKET_TYPE_DIRECTED               0x00000001
#define NDIS_PACKET_TYPE_MULTICAST              0x00000002
#define NDIS_PACKET_TYPE_ALL_MULTICAST          0x00000004
#define NDIS_PACKET_TYPE_BROADCAST              0x00000008
#define NDIS_PACKET_TYPE_SOURCE_ROUTING    0x00000010
#define NDIS_PACKET_TYPE_PROMISCUOUS            0x00000020
#define NDIS_PACKET_TYPE_SMT                       0x00000040
#define NDIS_PACKET_TYPE_ALL_LOCAL              0x00000080
#define NDIS_PACKET_TYPE_GROUP                  0x00001000
#define NDIS_PACKET_TYPE_ALL_FUNCTIONAL    0x00002000
#define NDIS_PACKET_TYPE_FUNCTIONAL             0x00004000
#define NDIS_PACKET_TYPE_MAC_FRAME              0x00008000


DBG_FILTER DbgFilterTable[] = {
    {"DIRECTED",            NDIS_PACKET_TYPE_DIRECTED},       
    {"MULTICAST",           NDIS_PACKET_TYPE_MULTICAST},      
    {"ALL_MULTICAST",       NDIS_PACKET_TYPE_ALL_MULTICAST},  
    {"BROADCAST",           NDIS_PACKET_TYPE_BROADCAST},      
    {"SOURCE_ROUTING",      NDIS_PACKET_TYPE_SOURCE_ROUTING}, 
    {"PROMISCUOUS",         NDIS_PACKET_TYPE_PROMISCUOUS},    
    {"SMT",                 NDIS_PACKET_TYPE_SMT},            
    {"ALL_LOCAL",           NDIS_PACKET_TYPE_ALL_LOCAL},      
    {"GROUP",               NDIS_PACKET_TYPE_GROUP},          
    {"ALL_FUNCTIONAL",      NDIS_PACKET_TYPE_ALL_FUNCTIONAL}, 
    {"FUNCTIONAL",          NDIS_PACKET_TYPE_FUNCTIONAL},     
    {"MAC_FRAME",           NDIS_PACKET_TYPE_MAC_FRAME}      
};

typedef struct
{
    char  Name[32];
    USHORT Val;
} DBG_RFD_STATUS, DBG_RFD_COMMAND, DBG_USHORT_BITS, DBG_USHORT_VALUE;

typedef struct
{
    char  Name[32];
    UCHAR Val;
} DBG_UCHAR_BITS, DBG_UCHAR_VALUE;


DBG_RFD_STATUS DbgRfdStatus[] = {
    {"COMPLETE",            RFD_STATUS_COMPLETE},  
    {"OK",                  RFD_STATUS_OK},        
    {"CRC_ERROR",           RFD_CRC_ERROR},        
    {"ALIGNMENT_ERROR",     RFD_ALIGNMENT_ERROR},  
    {"NO_RESOURCES",        RFD_NO_RESOURCES},     
    {"DMA_OVERRUN",         RFD_DMA_OVERRUN},      
    {"FRAME_TOO_SHORT",     RFD_FRAME_TOO_SHORT},  
    {"RX_ERR",              RFD_RX_ERR},           
    {"IA_MATCH",            RFD_IA_MATCH},
    {"RECEIVE_COLLISION",   RFD_RECEIVE_COLLISION},
};

DBG_RFD_COMMAND DbgRfdCommand[] = {
    {"EL",  RFD_EL_BIT},   
    {"S",   RFD_S_BIT},  
    {"H",   RFD_H_BIT},  
    {"SF",  RFD_SF_BIT} 
};

DBG_USHORT_BITS DbgCbCommandBits[] = {
    {"EL",      CB_EL_BIT},    
    {"S",       CB_S_BIT},     
    {"I",       CB_I_BIT},     
    {"TX_SF",   CB_TX_SF_BIT} 
};

DBG_USHORT_VALUE DbgCbCommands[] = { 
    {"CB_NOP",                 CB_NOP},           
    {"CB_IA_ADDRESS",          CB_IA_ADDRESS},    
    {"CB_CONFIGURE",           CB_CONFIGURE},     
    {"CB_MULTICAST",           CB_MULTICAST},     
    {"CB_TRANSMIT",            CB_TRANSMIT},      
    {"CB_LOAD_MICROCODE",      CB_LOAD_MICROCODE},
    {"CB_DUMP",                CB_DUMP},          
    {"CB_DIAGNOSE",            CB_DIAGNOSE}      
};

DBG_USHORT_VALUE DbgScbStatusRus[] = {
    {"IDLE",           SCB_RUS_IDLE},
    {"SUSPEND",        SCB_RUS_SUSPEND},
    {"NO_RESOURCES",   SCB_RUS_NO_RESOURCES},
    {"READY",          SCB_RUS_READY},
    {"SUSP_NO_RBDS",   SCB_RUS_SUSP_NO_RBDS},
    {"NO_RBDS",        SCB_RUS_NO_RBDS},
    {"READY_NO_RBDS",  SCB_RUS_READY_NO_RBDS},
};

DBG_USHORT_BITS DbgScbStatusBits[] = {
    {"CX",      SCB_STATUS_CX}, 
    {"FR",      SCB_STATUS_FR}, 
    {"CNA",     SCB_STATUS_CNA},
    {"RNR",     SCB_STATUS_RNR},
    {"MDI",     SCB_STATUS_MDI},
    {"SWI",     SCB_STATUS_SWI}
};

DBG_UCHAR_VALUE DbgScbCommandCuc[] = {
    {"START",         SCB_CUC_START},
    {"RESUME",        SCB_CUC_RESUME},       
    {"DUMP_ADDR",     SCB_CUC_DUMP_ADDR},    
    {"DUMP_STAT",     SCB_CUC_DUMP_STAT},    
    {"LOAD_BASE",     SCB_CUC_LOAD_BASE},    
    {"DUMP_RST_STAT", SCB_CUC_DUMP_RST_STAT},
    {"STATIC_RESUME", SCB_CUC_STATIC_RESUME}
};


DBG_UCHAR_VALUE DbgScbCommandRuc[] = {
    {"START",         SCB_RUC_START},
    {"RESUME",        SCB_RUC_RESUME},    
    {"ABORT",         SCB_RUC_ABORT},
    {"LOAD_HDS",      SCB_RUC_LOAD_HDS},  
    {"LOAD_BASE",     SCB_RUC_LOAD_BASE}, 
    {"RBD_RESUME",    SCB_RUC_RBD_RESUME}
};

VOID WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

LPEXT_API_VERSION ExtensionApiVersion(VOID)
{
    return &ApiVersion;
}

VOID CheckVersion(VOID)
{

    //
    // for now don't bother to version check
    //
    return;
}

DECLARE_API( help )
{
    int i;

    dprintf("E100 extensions:\n");

    dprintf("   dbglevel                                  dump debug level\n");
    dprintf("   mpadapter <MP_ADAPTER> <verbosity>>       dump MP_ADAPTER block\n");
    dprintf("   csr <CSRAddress>                          dump CSR block\n");
    dprintf("   sendlist <CurrSendHead> <verbosity>       dump send list\n");
    dprintf("   mptcb <MP_TCB>                            dump MP_TCB block\n");   
    dprintf("   hwtcb <HW_TCB>                            dump HW_TCB block\n");   
    dprintf("   sendqueue <SendWaitQueue>                 dump queued send packets\n");
    dprintf("   recvlist <RecvList> <verbosity>           dump receive list\n");
    dprintf("   mprfd <MP_RFD>                            dump MP_RFD block\n");   
    dprintf("   hwrfd <HW_RFD>                            dump HW_RFD block\n");   
    dprintf("   recvpendlist <RecvPendList>               dump pending indicated rx packets\n");
}


DECLARE_API(dbglevel)    
{
    ULONG64  debugLevelPtr;
    ULONG    debugLevel, NewLevel;
    ULONG64  Val;

    int      i;
    ULONG    Bytes;

    debugLevelPtr = GetExpression("e100bnt5!MPDebugLevel");

    if(debugLevelPtr == 0)
    {
        dprintf("Error retrieving address of MPDebugLevel\n");
        dprintf("Target is %s\n", ChkTarget ? "Checked" : "Free");
    }

    dprintf("MPDebugLevel @ %p\n", debugLevelPtr);                    

    debugLevel = GetUlongFromAddress(debugLevelPtr);

    dprintf("Current MPDebugLevel = %d", debugLevel);

    for(i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
    {
        if(debugLevel == DbgLevel[i].Val)
        {
            dprintf(" - %s", DbgLevel[i].Name);
            break;
        }
    }

    dprintf("\n");

    dprintf("Available settings: ");
    for(i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
    {
        if(debugLevel != DbgLevel[i].Val)
        {
            dprintf("%d-%s ", DbgLevel[i].Val, DbgLevel[i].Name);
        }
    }

    dprintf("\n");

    if(!*args)
    {
        return;
    }

    i = sscanf(args, "%lx", &NewLevel);

    if(i == 1)
    {
        for(i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if(NewLevel == DbgLevel[i].Val)
            {
                if(NewLevel != debugLevel)
                {
                    dprintf("New MPDebugLevel = %d\n", NewLevel);
                    WriteMemory(debugLevelPtr, &NewLevel, sizeof(ULONG), &Bytes);
                }

                break;
            }
        }
    }
}

DECLARE_API(version)    
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf("%s E100 Extension dll on a %s system\n", 
        kind,  ChkTarget? "Checked" : "Free");

}

#define MAX_FLAGS_PER_LINE  4
#define MAC_ADDRESS_LENGTH 6

DECLARE_API(mpadapter)    
{
    ULONG64  pAdapter;

    int      ArgCount = 0;

    ULONG    i, j;
    ULONG    Flags;
    ULONG    PacketFilter;
    ULONG    Off;

    UCHAR    MacAddress[MAC_ADDRESS_LENGTH];
    UINT     MCAddressCount;
    PUCHAR   pBuffer;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx",&pAdapter);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: mpadapter <pointer to MP_ADAPTER>\n");
        return ;
    }

    dprintf(" pAdapter %p : \n", pAdapter);

    InitTypeRead(pAdapter, MP_ADAPTER);

    dprintf("   AdapterHandle  : %p\n", ReadField(AdapterHandle));

    Flags = (ULONG) ReadField(Flags);
    dprintf("   Flags          : 0x%08x\n", Flags);

    j = 0;
    for(i = 0; i < sizeof(DbgAdapterFlags)/sizeof(DBG_ADAPTER_FLAGS); i++)
    {
        if(Flags & DbgAdapterFlags[i].Val)
        {
            if(j == 0)
            {
                dprintf("                     ");
            }

            dprintf("%s", DbgAdapterFlags[i].Name);

            j++;

            if(j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if(j != 0)
    {
        dprintf("\n");
    }

    if(!GetFieldOffset("MP_ADAPTER", "PermanentAddress", &Off))
    {
        if(GetData(MacAddress, pAdapter+Off, MAC_ADDRESS_LENGTH, "PermanentAddress[]"))
        {
            dprintf("   Permanent address : %02x-%02x-%02x-%02x-%02x-%02x\n", 
                MacAddress[0], MacAddress[1],
                MacAddress[2], MacAddress[3],
                MacAddress[4], MacAddress[5]);
        }
    }

    if((BOOLEAN) ReadField(OverrideAddress))
    {
        if(!GetFieldOffset("MP_ADAPTER", "CurrentAddress", &Off))
        {
            if(GetData(MacAddress, pAdapter+Off, MAC_ADDRESS_LENGTH, "CurrentAddress[]"))
            {
                dprintf("   Current address : %02x-%02x-%02x-%02x-%02x-%02x\n", 
                    MacAddress[0], MacAddress[1],
                    MacAddress[2], MacAddress[3],
                    MacAddress[4], MacAddress[5]);
            }
        }
    }
    else
    {
        dprintf("   Current address : same as above\n"); 
    }

    dprintf("\n"); 

    dprintf("   --- SEND ---\n");
    dprintf("   CurrSendHead = %p , CurrSendTail = %p , nBusySend = %d\n", 
        ReadField(CurrSendHead), ReadField(CurrSendTail), (LONG)ReadField(nBusySend)); 

    dprintf("   SendWaitQueue Head = %p, Tail = %p\n",
        ReadField(SendWaitQueue.Head), ReadField(SendWaitQueue.Tail)); 
    dprintf("   NumTcb = %d, RegNumTcb = %d, NumBuffers = %d\n", 
        (LONG)ReadField(NumTcb), (LONG)ReadField(RegNumTcb), (LONG)ReadField(NumBuffers));
    dprintf("   MpTcbMem = %p\n", ReadField(MpTcbMem)); 

    if(DBG_TEST_FLAG(Flags, fMP_ADAPTER_MAP_REGISTER))
    {
        dprintf("   CurrMapRegHead = %d, CurrMapRegTail = %d\n",
            (UINT)ReadField(CurrMapRegHead), (UINT)ReadField(CurrMapRegTail));       
    }

    dprintf("   TransmitIdle = %s, ResumeWait = %s\n", 
        (BOOLEAN)ReadField(TransmitIdle) ? "TRUE" : "FALSE", 
        (BOOLEAN)ReadField(ResumeWait) ? "TRUE" : "FALSE");

    dprintf("   SendBufferPool = %p\n", ReadField(SendBufferPool));

    dprintf("\n"); 

    dprintf("   --- RECV ---\n");

    if(!GetFieldOffset("MP_ADAPTER", "RecvList", &Off))
    {
        dprintf("   RecvList @ %p , nReadyRecv = %d\n",
            pAdapter+Off, (LONG)ReadField(nReadyRecv));
    }

    if(!GetFieldOffset("MP_ADAPTER", "RecvPendList", &Off))
    {
        dprintf("   RecvPendList @ %p , RefCount = %d\n",
            pAdapter+Off, (LONG)ReadField(RefCount));
    }

    dprintf("   NumRfd = %d, CurrNumRfd = %d , HwRfdSize = %d\n", 
        (LONG)ReadField(NumRfd), (LONG)ReadField(CurrNumRfd), (LONG)ReadField(HwRfdSize));

    dprintf("   bAllocNewRfd = %s, RfdShrinkCount = %d\n", 
        (BOOLEAN)ReadField(bAllocNewRfd) ? "TRUE" : "FALSE",
        (LONG)ReadField(RfdShrinkCount));       

    dprintf("   RecvPacketPool = %p , RecvBufferPool = %p\n", 
        ReadField(RecvPacketPool), ReadField(RecvBufferPool));  

    dprintf("\n"); 

    PacketFilter = (ULONG)ReadField(PacketFilter);
    dprintf("   PacketFilter   : 0x%08x\n", PacketFilter);

    j = 0;
    for(i = 0; i < sizeof(DbgFilterTable)/sizeof(DBG_FILTER); i++)
    {
        if(PacketFilter & DbgFilterTable[i].Val)
        {
            if(j == 0)
            {
                dprintf("                     ");
            }

            dprintf("%s", DbgFilterTable[i].Name);

            j++;

            if(j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if(j != 0)
    {
        dprintf("\n");
    }

    dprintf("   ulLookAhead=%d, usLinkSpeed=%d, usDuplexMode=%d\n",
        (ULONG)ReadField(ulLookAhead), (USHORT)ReadField(usLinkSpeed), 
        (USHORT)ReadField(usDuplexMode));

    dprintf("\n");

    MCAddressCount = (UINT)ReadField(MCAddressCount);
    dprintf("   MCAddressCount = %d\n", MCAddressCount);

    pBuffer = malloc(MCAddressCount * MAC_ADDRESS_LENGTH);
    if(pBuffer)
    {
        if(!GetFieldOffset("MP_ADAPTER", "MCList", &Off))
        {
            if(GetData(pBuffer, pAdapter+Off, MCAddressCount * MAC_ADDRESS_LENGTH, "MCList[]"))
            {
                for(i=0; i<MCAddressCount; i++)
                {
                    j = i * MAC_ADDRESS_LENGTH;
                    dprintf("   (%d) = %02x-%02x-%02x-%02x-%02x-%02x\n",
                        i, pBuffer[j], pBuffer[j+1], pBuffer[j+2], 
                        pBuffer[j+3], pBuffer[j+4], pBuffer[j+5]);
                }
            }
        }

        free(pBuffer);
    }
    else
    {

    }


    dprintf("\n");


    dprintf("   IoBaseAddress = 0x%x, IoRange = 0x%x, InterrupLevel = 0x%x, MemPhysAddress = 0x%x\n",   
        (ULONG)ReadField(IoBaseAddress), (ULONG)ReadField(IoRange), 
        (ULONG)ReadField(InterruptLevel), (ULONG)ReadField(MemPhysAddress.LowPart)); 
    dprintf("   PortOffset = %p , CSRAddress = %p\n", 
        ReadField(PortOffset), ReadField(CSRAddress));

    dprintf("   RevsionID = %d, SubVendorID = 0x%02x, SubSystemID = 0x%02x\n",
        (UCHAR)ReadField(RevsionID), (USHORT)ReadField(SubVendorID), 
        (USHORT)ReadField(SubSystemID));

}

DECLARE_API(csr)    
{
    ULONG64  pHwCsr;
    int      ArgCount = 0;

    UCHAR    ucVal;
    USHORT   usVal;

    ULONG    i;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pHwCsr);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: csr <CSRAddress>\n");
        return ;
    }

    dprintf(" pHwCsr %x : \n", pHwCsr);

    InitTypeRead(pHwCsr, HW_CSR);

    // ScbStatus 
    usVal = (USHORT)ReadField(ScbStatus);
    dprintf("   ScbStatus - 0x%04x ", usVal);

    dprintf("CUS-");              
    switch(usVal & SCB_CUS_MASK)
    {
        case SCB_CUS_IDLE:
            dprintf("IDLE "); 
            break;

        case SCB_CUS_SUSPEND:
            dprintf("SUSPEND "); 
            break;

        case SCB_CUS_ACTIVE:
            dprintf("ACTIVE "); 
            break;

        default:
            dprintf("Reserved "); 
    }

    for(i = 0; i < sizeof(DbgScbStatusRus)/sizeof(DBG_USHORT_VALUE); i++)
    {
        if((usVal & SCB_RUS_MASK) == DbgScbStatusRus[i].Val)
        {
            dprintf("RUS-%s ", DbgScbStatusRus[i].Name);
            break;
        }
    }

    dprintf("STAT-");

    for(i = 0; i < sizeof(DbgScbStatusBits)/sizeof(DBG_USHORT_BITS); i++)
    {
        if(usVal & DbgScbStatusBits[i].Val)
        {
            dprintf("%s ", DbgScbStatusBits[i].Name);
        }
    }

    dprintf("\n");

    //ScbCommandLow
    ucVal = (UCHAR)ReadField(ScbCommandLow);
    dprintf("   ScbCommandLow - 0x%02x ", ucVal);

    for(i = 0; i < sizeof(DbgScbCommandCuc)/sizeof(DBG_UCHAR_VALUE); i++)
    {
        if((ucVal & SCB_CUC_MASK) == DbgScbCommandCuc[i].Val)
        {
            dprintf("CUC-%s ", DbgScbCommandCuc[i].Name);
            break;
        }
    }

    for(i = 0; i < sizeof(DbgScbCommandRuc)/sizeof(DBG_UCHAR_VALUE); i++)
    {
        if((ucVal & SCB_RUC_MASK) == DbgScbCommandRuc[i].Val)
        {
            dprintf("RUC-%s ", DbgScbCommandRuc[i].Name);
            break;
        }
    }

    //ScbCommandHigh
    ucVal = (UCHAR)ReadField(ScbCommandHigh);
    dprintf(" ScbCommandHigh - 0x%02x ", ucVal);              
    if(ucVal & SCB_INT_MASK)
    {
        dprintf("INT_MASK ");
    }
    if(ucVal & SCB_SOFT_INT)
    {
        dprintf("SOFT_INT ");
    }

    dprintf("\n");
}

DECLARE_API(sendlist)    
{
    ULONG64  pMpTcb;
    ULONG64  pFirstMpTcb;

    int      ArgCount = 0;
    int      Verbosity = 0;
    int      index = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx %lx", &pMpTcb, &Verbosity);
    }

    //check for arguments
    if(ArgCount < 1 || Verbosity > 1)
    {
        dprintf("Usage: sendlist <CurrSendHead> <verbosity>\n");
        dprintf("1-Show HW_TCB info\n");
        return ;
    }

    SIGN_EXTEND(pMpTcb);                      

    pFirstMpTcb = pMpTcb;

    do                                                
    {
        dprintf(" (%d) pMpTcb %p : \n", index, pMpTcb);

        PrintMpTcbDetails(pMpTcb, Verbosity);

        if(GetFieldValue(pMpTcb, "MP_TCB", "Next", pMpTcb))
        {
            break;
        }

        index++;

        if(CheckControlC())
        {
            dprintf("***Control-C***\n");
            break;
        }

    } while(pMpTcb != pFirstMpTcb);

}


DECLARE_API(mptcb)    
{
    ULONG64  pMpTcb;

    int      ArgCount = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pMpTcb);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: mptcb <MP_TCB>\n");
        return ;
    }

    dprintf(" pMpTcb %p : \n", pMpTcb);

    PrintMpTcbDetails(pMpTcb, 1);

}

DECLARE_API(hwtcb)    
{
    ULONG64  pHwTcb;

    int      ArgCount = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pHwTcb);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: hwtcb <HW_TCB>\n");
        return ;
    }

    dprintf(" pHwTcb %p : \n", pHwTcb);

    PrintHwTcbDetails(pHwTcb);
}

void PrintMpTcbDetails(ULONG64 pMpTcb, int Verbosity)
{
    ULONG    Flags;
    ULONG64  pMpTxBuf;
    ULONG64  pHwTcb;

    ULONG64  pVal;                 
    ULONG    ulVal;
    USHORT   usVal;

    InitTypeRead(pMpTcb, MP_TCB);

    dprintf("   Next %p", ReadField(Next));

    Flags = (ULONG) ReadField(Flags);
    dprintf(" , Flags - 0x%x", Flags);
    if(Flags & fMP_TCB_IN_USE)
    {
        dprintf(" IN_USE");
    }
    if(Flags & fMP_TCB_USE_LOCAL_BUF)
    {
        dprintf(" USE_LOCAL_BUF");
    }
    if(Flags & fMP_TCB_MULTICAST)
    {
        dprintf(" MULTICAST");
    }

    dprintf("\n");

    if(Flags & fMP_TCB_USE_LOCAL_BUF)
    {

        pMpTxBuf = ReadField(MpTxBuf);
        dprintf("   MpTxBuf = %p", pMpTxBuf);

        GetFieldValue(pMpTxBuf, "MP_TXBUF", "NdisBuffer", pVal);
        dprintf(" - NdisBuffer = %p", pVal);

        GetFieldValue(pMpTxBuf, "MP_TXBUF", "AllocSize", ulVal);
        dprintf(" , AllocSize = %d", ulVal);

        GetFieldValue(pMpTxBuf, "MP_TXBUF", "AllocVa", pVal);
        dprintf(" , AllocVa = %p", pVal);

        GetFieldValue(pMpTxBuf, "MP_TXBUF", "pBuffer", pVal);
        dprintf(" , pBuffer = %p\n", pVal);

        dprintf("\n");
    }

    if(Flags & fMP_TCB_IN_USE)
    {
        dprintf("   Packet = %p\n", ReadField(Packet));

        pHwTcb = ReadField(HwTcb);
        dprintf("   HwTcb = %p , HwTcbPhys = 0x%lx , PrevHwTcb = 0x%x\n", 
            pHwTcb, (ULONG)ReadField(HwTcbPhys), ReadField(PrevHwTcb));

        dprintf("   HwTbd (First) = %p , HwTbdPhys = 0x%x\n", 
            ReadField(HwTbd), (ULONG)ReadField(HwTbdPhys));

        dprintf("   PhysBufCount = %d, BufferCount = %d, FirstBuffer = %p , PacketLength = %d\n", 
            (ULONG)ReadField(PhysBufCount), (ULONG)ReadField(BufferCount), 
            ReadField(FirstBuffer), (ULONG)ReadField(PacketLength));
    }

    dprintf("\n");

    if((Flags & fMP_TCB_IN_USE) && Verbosity == 1)
    {
        PrintHwTcbDetails(pHwTcb);
    }
}

void PrintHwTcbDetails(ULONG64 pHwTcb)
{
    USHORT   HwCbStatus;
    USHORT   HwCbCommand; 

    ULONG    i;

    InitTypeRead(pHwTcb, HW_TCB);

    HwCbStatus = (USHORT) ReadField(TxCbHeader.CbStatus);
    HwCbCommand = (USHORT) ReadField(TxCbHeader.CbCommand);

    dprintf("      TxCbHeader.CbStatus = 0x%04x ,", HwCbStatus);
    if(HwCbStatus & CB_STATUS_COMPLETE)
    {
        dprintf(" COMPLETE");
    }
    if(HwCbStatus & CB_STATUS_OK)
    {
        dprintf(" OK");
    }
    if(HwCbStatus & CB_STATUS_UNDERRUN)
    {
        dprintf(" UNDERRUN");
    }

    dprintf("\n");

    dprintf("      TxCbHeader.CbCommand = 0x%04x ", HwCbCommand);
    for(i = 0; i < sizeof(DbgCbCommandBits)/sizeof(DBG_USHORT_BITS); i++)
    {
        if(HwCbCommand & DbgCbCommandBits[i].Val)
        {
            dprintf(", %s", DbgCbCommandBits[i].Name);
        }
    }

    for(i = 0; i < sizeof(DbgCbCommands)/sizeof(DBG_USHORT_VALUE); i++)
    {
        if((HwCbCommand & CB_CMD_MASK) == DbgCbCommands[i].Val)
        {
            dprintf(", %s", DbgCbCommands[i].Name);
            break;
        }
    }

    if(i == sizeof(DbgCbCommands)/sizeof(DBG_USHORT_VALUE))
    {
        dprintf(", UNKNOWN COMMAND");
    }

    dprintf("\n");

    dprintf("      TxCbHeader.CbLinkPointer = 0x%x\n", (ULONG)ReadField(TxCbHeader.CbLinkPointer));

    if((HwCbCommand & CB_CMD_MASK) == CB_TRANSMIT)
    {
        dprintf("      TxCbTbdPointer = 0x%08x\n", (ULONG)ReadField(TxCbTbdPointer));
        dprintf("      TxCbCount = %d, ", (USHORT)ReadField(TxCbCount));
        dprintf("TxCbThreshold = %d, ", (UCHAR)ReadField(TxCbThreshold));
        dprintf("TxCbTbdNumber = %d\n", (UCHAR)ReadField(TxCbTbdNumber));
    }
}

DECLARE_API(sendqueue)    
{
    ULONG64  pEntry; 
    ULONG64  pPacket;

    ULONG    ulSize;

    int      ArgCount = 0;
    int      index = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pEntry);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: sendqueue <SendWaitQueue address>\n");
        return ;
    }

    SIGN_EXTEND(pEntry);

    if(!(ulSize = GetTypeSize("NDIS_PACKET_PRIVATE")))
    {
        dprintf("Failed to get the type size of NDIS_PACKET_PRIVATE\n");
        return;
    }

    dprintf("NDIS_PACKET_PRIVATE size is 0x%x\n", ulSize);

    while(pEntry)
    {
        pPacket = pEntry - ulSize;
        if(pPacket > pEntry)
        {
            dprintf("Invalid pEntry %p\n", pEntry);
            break;
        }

        dprintf("   (%d) pEntry = %p, Pkt = %p\n", index, pEntry, pPacket);

        if(ReadPtr(pEntry, &pEntry))
        {
            break;
        }

        index++;

        if(CheckControlC())
        {
            dprintf("***Control-C***\n");
            break;
        }
    }
}

DECLARE_API(recvlist)    
{
    ULONG64  pListHead;
    ULONG64  pMpRfd;
    ULONG64  pHwRfd;

    int      ArgCount = 0;
    int      Verbosity = 0;
    int      index = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx %lx", &pListHead, &Verbosity);
    }

    //check for arguments
    if(ArgCount < 1 || Verbosity > 1)
    {
        dprintf("Usage: recvlist <RecvList address> <verbosity>\n");
        dprintf("1-Show HW_RFD info\n");
        return ;
    }

    SIGN_EXTEND(pListHead);

    if(GetFieldValue(pListHead, "LIST_ENTRY", "Flink", pMpRfd))
    {
        dprintf("Failed to get LIST_ENTRY Flink at %p\n", pListHead);
        return;      
    }

    while((pMpRfd != pListHead))
    {
        dprintf("   (%d) pMpRfd %p :\n", index, pMpRfd);

        PrintMpRfdDetails(pMpRfd, Verbosity);

        if(GetFieldValue(pMpRfd, "LIST_ENTRY", "Flink", pMpRfd))
        {
            dprintf("Failed to get LIST_ENTRY Flink at %p\n", pMpRfd);
            break;
        }

        index++;

        if(CheckControlC())
        {
            dprintf("***Control-C***\n");
            break;
        }
    }

    dprintf("RecvList has %d RFDs\n", index);

}

DECLARE_API(mprfd)    
{
    ULONG64  pMpRfd;

    int      ArgCount = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pMpRfd);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: mprfd <MP_RFD>\n");
        return ;
    }

    dprintf(" pMpRfd %p : \n", pMpRfd);

    PrintMpRfdDetails(pMpRfd, 1);
}

DECLARE_API(hwrfd)    
{
    ULONG64  pHwRfd;

    int      ArgCount = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pHwRfd);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: hwrfd <HW_RFD>\n");
        return ;
    }

    dprintf(" pHwRfd = %p : \n", pHwRfd); 

    PrintHwRfdDetails(pHwRfd);
}

void PrintMpRfdDetails(ULONG64 pMpRfd, int Verbosity)
{
    ULONG64  pHwRfd;

    ULONG    Flags;

    InitTypeRead(pMpRfd, MP_RFD);

    dprintf("   Flink %p", ReadField(List.Flink));
    dprintf(" , Blink %p\n", ReadField(List.Blink));

    pHwRfd = ReadField(HwRfd);                           
    dprintf("   NdisPacket = %p , NdisBuffer = %p , HwRfd = %p\n", 
        ReadField(NdisPacket), ReadField(NdisBuffer), pHwRfd);

    dprintf("   PacketSize = %d, ", (ULONG) ReadField(PacketSize));

    Flags = (ULONG) ReadField(Flags);                                   
    dprintf("Flags 0x%x", Flags);
    if(Flags & fMP_RFD_RECV_PEND)
    {
        dprintf(" RECV_PEND ");
    }
    if(Flags & fMP_RFD_ALLOC_PEND)
    {
        dprintf(" ALLOC_PEND ");
    }
    if(Flags & fMP_RFD_RECV_READY)
    {
        dprintf(" RECV_READY ");
    }
    if(Flags & fMP_RFD_RESOURCES)
    {
        dprintf(" RESOURCES ");
    }
    

    dprintf("\n");

    if(Verbosity == 1)
    {
        PrintHwRfdDetails(pHwRfd);
    }
}

void PrintHwRfdDetails(ULONG64 pHwRfd)
{
    USHORT   RfdStatus;
    USHORT   RfdCommand; 

    ULONG    i;

    InitTypeRead(pHwRfd, HW_RFD);

    RfdStatus = (USHORT) ReadField(RfdCbHeader.CbStatus);
    RfdCommand = (USHORT) ReadField(RfdCbHeader.CbCommand);

    dprintf("      RfdCbHeader.CbStatus = 0x%04x", RfdStatus);

    for(i = 0; i < sizeof(DbgRfdStatus)/sizeof(DBG_RFD_STATUS); i++)
    {
        if(RfdStatus & DbgRfdStatus[i].Val)
        {
            dprintf(", %s", DbgRfdStatus[i].Name);
        }
    }

    dprintf("\n");

    dprintf("      RfdCbHeader.CbCommand = %04x", RfdCommand);
    for(i = 0; i < sizeof(DbgRfdCommand)/sizeof(DBG_RFD_COMMAND); i++)
    {
        if(RfdCommand & DbgRfdCommand[i].Val)
        {
            dprintf(", %s", DbgRfdCommand[i].Name);
        }
    }

    dprintf("\n");

    dprintf("      RfdCbHeader.CbLinkPointer = 0x%x\n", (ULONG)ReadField(RfdCbHeader.CbLinkPointer));
    //dprintf("      RfdRbdPointer = 0x%x\n", (ULONG)ReadField(RfdRbdPointer));
    dprintf("      RfdActualCount = %x , %d", (USHORT)ReadField(RfdActualCount), (USHORT)ReadField(RfdActualCount) & 0x3fff);
    dprintf(", RfdSize = %d\n", (USHORT)ReadField(RfdSize));
}

DECLARE_API(recvpendlist)    
{
    ULONG64  pListHead;
    ULONG64  pMpRfd;
    ULONG64  pPacket;

    int      ArgCount = 0;
    int      index = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pListHead);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: recvpendlist <RecvPendList address>\n");
        return ;
    }

    SIGN_EXTEND(pListHead);

    if(GetFieldValue(pListHead, "LIST_ENTRY", "Flink", pMpRfd))
    {
        dprintf("Failed to get LIST_ENTRY Flink at %p\n", pListHead);
        return;      
    }

    while(pMpRfd != pListHead)
    {
        dprintf("   (%d) pMpRfd %x :\n", index, pMpRfd);

        PrintMpRfdDetails(pMpRfd, 0);

        if(GetFieldValue(pMpRfd, "LIST_ENTRY", "Flink", pMpRfd))
        {
            dprintf("Failed to get LIST_ENTRY Flink at %p\n", pMpRfd);
            break;
        }

        index++;

        if(CheckControlC())
        {
            dprintf("***Control-C***\n");
            break;
        }
    }

    dprintf("RecvPendList has %d RFDs\n", index);

}


/**
   Get 'size' bytes from the debuggee program at 'dwAddress' and place it
   in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 **/
BOOL GetData( IN LPVOID ptr, IN ULONG64 AddressPtr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while(size > 0)
    {

        if(count >= 3000)
            count = 3000;

        b = ReadMemory(AddressPtr, ptr, count, &BytesRead );

        if(!b || BytesRead != count)
        {
            dprintf( "Unable to read %u bytes at %X, for %s\n", size, AddressPtr, type );
            return FALSE;
        }

        AddressPtr += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

/**
   
   Routine to get offset and size of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.
   
 **/
ULONG GetFieldOffsetAndSize(
    IN LPSTR     Type, 
    IN LPSTR     Field, 
    OUT PULONG   pOffset,
    OUT PULONG   pSize) 
{
    FIELD_INFO flds = {
        Field, "", 0, 
        DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_SIZE_IN_BITS, 
        0, NULL};
    SYM_DUMP_PARAM Sym = {
        sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &flds
    };
    ULONG Err, i=0;
    LPSTR dot, last=Field;

    Sym.nFields = 1;
    Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
    *pOffset = (ULONG) (flds.address - Sym.addr);
    *pSize   = flds.size;
    return Err;
}

ULONG GetUlongFromAddress (
    ULONG64 Location)
{
    ULONG Value;
    ULONG result;

    if((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG)))
    {
        dprintf("unable to read from %08x\n",Location);
        return 0;
    }

    return Value;
}

ULONG64 GetPointerFromAddress(
    ULONG64 Location)
{
    ULONG64 Value;
    ULONG result;

    if(ReadPtr(Location,&Value))
    {
        dprintf("unable to read from %p\n",Location);
        return 0;
    }

    return Value;
}

ULONG GetUlongValue (
    PCHAR String)
{
    ULONG64 Location;
    ULONG Value;
    ULONG result;

    Location = GetExpression(String);
    if(!Location)
    {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return GetUlongFromAddress(Location);
}

ULONG64 GetPointerValue (
    PCHAR String)
{
    ULONG64 Location, Val=0;

    Location = GetExpression(String);
    if(!Location)
    {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    ReadPtr(Location, &Val);

    return Val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\testwmi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testwmi.rc
//
#define IDD_MAIN                        101
#define IDD_SCALAR_PROPERTY             102
#define IDD_ARRAY_PROPERTY              103
#define IDS_PROPERTIES                  1003
#define IDG_INSTANCES                   1010
#define IDL_CLASSES                     1014
#define IDS_CLASSES                     1015
#define IDT_PROPERTIES                  1016
#define IDT_INSTANCES                   1017
#define IDT_PROPERTY_VALUE              1019
#define IDS_PROPERTY_TYPE               1025
#define IDE_PROPERTY_VALUE              1026
#define IDB_MODIFY                      1027
#define IDS_PROPERTY_TYPE_ARRAY         1028
#define IDS_TYPE                        1029
#define IDB_CANCEL                      1040
#define IDS_INTANCES                    -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\private\mp_pm.c ===
#include <ndis.h> 
#include <e100_equ.h>
#include <e100_557.h>
#include <e100_def.h>
#include <mp_def.h>
#include <mp_cmn.h>
#include <mp.h>
#include <mp_nic.h>
#include <mp_dbg.h>
#include <e100_sup.h>
// Things to note:
// PME_ena bit should be active before the 82558 is set into low power mode
// Default for WOL should generate wake up event after a HW Reset

// Fixed Packet Filtering
// Need to verify that the micro code is loaded and Micro Machine is active
// Clock signal is active on PCI clock


// Address Matching
// Need to enable IAMatch_Wake_En bit and the MCMatch_Wake_En bit is set

// ARP Wakeup 
// Need to set BRCST DISABL bet to 0 (broadcast enable)
// To handle VLAN set the VLAN_ARP bit
// IP address needs to be configured with 16 least significant bits
// Set the IP Address in the IP_Address configuration word.

// Fixed WakeUp Filters:
// There are 3ight different fixed WakeUp Filters 
// ( Unicast, Multicast, Arp. etc). 


// Link Status Event
// Set Link_Status_Wakeup Enable bit.

// Flexible filtering:
// Supports: ARP packets, Directed, Magic Packet and Link Event

// Flexible Filtering Overview:
// driver should program micro-code before setting card into low power
// Incoming packets are compared against the loadable microcode. If PME is 
// is enabled then, the system is woken up.


// Segments are defined in book - but not implemented here.

// WakeUp Packet -that causes the machine to wake up will be stored
// in the Micro Machine temporary storage area so that the driver can read it.


// Software Work:
// Power Down:
// OS requests the driver to go to a low power state
// Software Pends request
// SW sets CU and RU to idle by issuing a Selective Reset to the device
//      3rd portion .- Wake Up Segments defintion
// The above three segments are loaded as on chain. The last CB must have
// its EL bit set.
// Device can now be powered down. 
// Software driver completes OS request
// OS then physically switches the Device to low power state 
// 

// Power Up:
// OS powers up the Device
// OS tells the SW that it is now in D0
// driver should NOT initialize the Device. It should NOT issue a Self Test
// Driver Initiates a PORT DUMP command
// Device dumps its internal registers including the wakeup frame storage area
// SW reads the PME register
// SW reads the WakeUp Frame Data, analyzes it and acts accordingly
// SW restores its cvonfiguration and and resumes normal operation.
//

//
// Power Management definitions from the Intel Handbook
//

//
// Definitions from Table 4.2, Pg 4.9 
// of the 10/100 Mbit Ethernet Family Software Technical 
// Reference Manual
//

#define PMC_Offset  0xDE
#define E100_PMC_WAKE_FROM_D0       0x1
#define E100_PMC_WAKE_FROM_D1       0x2
#define E100_PMC_WAKE_FROM_D2       0x4
#define E100_PMC_WAKE_FROM_D3HOT    0x8
#define E100_PMC_WAKE_FROM_D3_AUX   0x10

//
// Load Programmable filter definintions.
// Taken from C-19 from the Software Reference Manual.
// It has examples too. The opcode used for load is 0x80000
//

#define BIT_15_13                   0xA000

#define CB_LOAD_PROG_FILTER         BIT_3
#define CU_LOAD_PROG_FILTER_EL      BIT_7
#define CU_SUCCEED_LOAD_PROG_FILTER BIT_15_13
#define CB_FILTER_EL                BIT_7
#define CB_FILTER_PREDEFINED_FIX    BIT_6
#define CB_FILTER_ARP_WAKEUP        BIT_3
#define CB_FILTER_IA_WAKEUP         BIT_1

#define CU_SCB_NULL                 ((UINT)-1)


#pragma pack( push, enter_include1, 1 )

//
// Define the PM Capabilities register in the device
// portion of the PCI config space
// 
typedef struct _MP_PM_CAP_REG {

    USHORT UnInteresting:11;
    USHORT PME_Support:5;
   

} MP_PM_CAP_REG;


//
// Define the PM Control/Status Register
//
typedef struct  _MP_PMCSR {

        USHORT PowerState:2;    // Power State;
        USHORT Res:2;           // reserved
        USHORT DynData:1;       // Ignored
        USHORT Res1:3;            // Reserved 
        USHORT PME_En:1;        // Enable device to set the PME Event;
        USHORT DataSel:4;       // Unused
        USHORT DataScale:2;     // Data Scale - Unused
        USHORT PME_Status:1;    // PME Status - Sticky bit;


} MP_PMCSR ;

typedef struct _MP_PM_PCI_SPACE {

    UCHAR Stuff[PMC_Offset];

    // PM capabilites 
    
    MP_PM_CAP_REG   PMCaps;

    // PM Control Status Register
    
    MP_PMCSR        PMCSR;
    

} MP_PM_PCI_SPACE , *PMP_PM_PCI_SPACE ;


//
// This is the Programmable Filter Command Structure
//
typedef struct _MP_PROG_FILTER_COMM_STRUCT
{
    // CB Status Word
    USHORT CBStatus;

    // CB Command Word
    USHORT CBCommand;

    //Next CB PTR == ffff ffff
    ULONG NextCBPTR;

    //Programmable Filters
    ULONG FilterData[16];


} MP_PROG_FILTER_COMM_STRUCT,*PMP_PROG_FILTER_COMM_STRUCT;

typedef struct _MP_PMDR
{
    // Status of the PME bit
    UCHAR PMEStatus:1;

    // Is the TCO busy
    UCHAR TCORequest:1;

    // Force TCO indication
    UCHAR TCOForce:1;

    // Is the TCO Ready
    UCHAR TCOReady:1;

    // Reserved
    UCHAR Reserved:1;

    // Has an InterestingPacket been received
    UCHAR InterestingPacket:1;

    // Has a Magic Packet been received
    UCHAR MagicPacket:1;

    // Has the Link Status been changed
    UCHAR LinkStatus:1;
    
} MP_PMDR , *PMP_PMDR;

//-------------------------------------------------------------------------
// Structure used to set up a programmable filter.
// This is overlayed over the Control/Status Register (CSR)
//-------------------------------------------------------------------------
typedef struct _CSR_FILTER_STRUC {

    // Status- used to  verify if the load prog filter command 
    // has been accepted .set to 0xa000 
    USHORT      ScbStatus;              // SCB Status register

    // Set to an opcode of  0x8  
    //
    UCHAR       ScbCommandLow;          // SCB Command register (low byte)

    // 80. Low + High gives the required opcode 0x80080000
    UCHAR       ScbCommandHigh;         // SCB Command register (high byte)

    // Set to NULL ff ff ff ff 
    ULONG       NextPointer;      // SCB General pointer

    // Set to a hardcoded filter, Arp + IA Match, + IP address

    union
    {
        ULONG u32;

        struct {
            UCHAR   IPAddress[2];
            UCHAR   Reserved;
            UCHAR   Set;
        
        }PreDefined;
        
    }Programmable;     // Wake UP Filter    union
    
} CSR_FILTER_STRUC, *PCSR_FILTER_STRUC;

#pragma pack( pop, enter_include1 )

#define MP_CLEAR_PMDR(pPMDR)  (*pPMDR) = ((*pPMDR) | 0xe0);  // clear the 3 uppermost bits in the PMDR


//-------------------------------------------------------------------------
// L O C A L    P R O T O T Y P E S 
//-------------------------------------------------------------------------

__inline 
NDIS_STATUS 
MPIssueScbPoMgmtCommand(
    IN PMP_ADAPTER Adapter,
    IN PCSR_FILTER_STRUC pFilter,
    IN BOOLEAN WaitForScb
    );


VOID
MPCreateProgrammableFilter (
    IN PMP_WAKE_PATTERN     pMpWakePattern , 
    IN PUCHAR pFilter, 
    IN OUT PULONG pNext
    );


//
// Macros used to walk a doubly linked list. Only macros that are not defined in ndis.h
// The List Next macro will work on Single and Doubly linked list as Flink is a common
// field name in both
//

/*
PLIST_ENTRY
ListNext (
    IN PLIST_ENTRY
    );

PSINGLE_LIST_ENTRY
ListNext (
    IN PSINGLE_LIST_ENTRY
    );
*/
#define ListNext(_pL)                       (_pL)->Flink

/*
PLIST_ENTRY
ListPrev (
    IN LIST_ENTRY *
    );
*/
#define ListPrev(_pL)                       (_pL)->Blink

//-------------------------------------------------------------------------
// P O W E R    M G M T    F U N C T I O N S  
//-------------------------------------------------------------------------

PUCHAR 
HwReadPowerPMDR(
    IN  PMP_ADAPTER     Adapter
    )
/*++
Routine Description:

    This routine will Hardware's PM registers
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/    
{
    UCHAR PMDR =0;
    PUCHAR pPMDR = NULL;

#define CSR_SIZE sizeof (*Adapter->CSRAddress)



    ASSERT (CSR_SIZE == 0x18);

    pPMDR =  0x18 + (PUCHAR)Adapter->CSRAddress ;

    PMDR = *pPMDR;

    return pPMDR;

}



NDIS_STATUS
MPWritePciSlotInfo(
    PMP_ADAPTER pAdapter,
    ULONG Offset,
    PVOID pValue,
    ULONG SizeofValue
    )
{
    ULONG ulResult; 
    NDIS_STATUS Status;
    
    ulResult = NdisWritePciSlotInformation(
               pAdapter->AdapterHandle,
               0,
               Offset,
               pValue,
               SizeofValue);

    ASSERT (ulResult == SizeofValue);

    // What do we do in case of failure;
    //
    if (ulResult == SizeofValue)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
    }


    return Status;

}


NDIS_STATUS
MPReadPciSlotInfo(
    PMP_ADAPTER pAdapter,
    ULONG Offset,
    PVOID pValue,
    ULONG SizeofValue
    )
{
    ULONG ulResult; 
    NDIS_STATUS Status;
    
    ulResult = NdisReadPciSlotInformation(
               pAdapter->AdapterHandle,
               0,
               Offset,
               pValue,
               SizeofValue);

    ASSERT (ulResult == SizeofValue);

    // What do we do in case of failure;
    //
    if (ulResult == SizeofValue)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
    }


    return Status;

}


NDIS_STATUS
MpClearPME_En (
    IN PMP_ADAPTER pAdapter,
    IN MP_PMCSR PMCSR
    )
{
    NDIS_STATUS Status;
    UINT ulResult;
    
    PMCSR.PME_En = 0;
    
    Status = MPWritePciSlotInfo( pAdapter,
                                    FIELD_OFFSET(MP_PM_PCI_SPACE, PMCSR),
                                    (PVOID)&PMCSR,
                                    sizeof(PMCSR));

    return Status;
}



VOID MpExtractPMInfoFromPciSpace(
    PMP_ADAPTER pAdapter,
    PUCHAR pPciConfig
    )
/*++
Routine Description:

    Looks at the PM information in the 
    device specific section of the PCI Config space.
    
    Interprets the register values and stores it 
    in the adapter structure
  
    Definitions from Table 4.2 & 4.3, Pg 4-9 & 4-10 
    of the 10/100 Mbit Ethernet Family Software Technical 
    Reference Manual
  

Arguments:

    Adapter     Pointer to our adapter
    pPciConfig  Pointer to Common Pci Space

Return Value:

--*/    
{
    PMP_PM_PCI_SPACE    pPmPciConfig = (PMP_PM_PCI_SPACE )pPciConfig;
    PMP_POWER_MGMT      pPoMgmt = &pAdapter->PoMgmt;
    MP_PMCSR PMCSR;

    //
    // First interpret the PM Capabities register
    //
    {
        MP_PM_CAP_REG   PmCaps;

        PmCaps = pPmPciConfig->PMCaps;

        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D0)
        {
            pAdapter->PoMgmt.bWakeFromD0 = TRUE;       
        }
    
        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D1)
        {
            pAdapter->PoMgmt.bWakeFromD1 = TRUE;       
        }

        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D2)
        {
            pAdapter->PoMgmt.bWakeFromD2 = TRUE;       
        }

        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D3HOT)
        {
            pAdapter->PoMgmt.bWakeFromD3Hot = TRUE;       
        }

        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D3_AUX)
        {
            pAdapter->PoMgmt.bWakeFromD3Aux = TRUE;       
        }

    }

    //
    // Interpret the PM Control/Status Register
    //
    {
        PMCSR = pPmPciConfig->PMCSR;

        if (PMCSR.PME_En == 1)
        {
            //
            // PME is enabled. Clear the PME_En bit.
            // So that it is not asserted
            //
            MpClearPME_En (pAdapter,PMCSR);

        }

        
        //pPoMgmt->PowerState = PMCSR.PowerState;
    }        

}


VOID
MPSetPowerLowPrivate(
    PMP_ADAPTER pAdapter 
    )
/*++
Routine Description:

    The section follows the steps mentioned in 
    Section C.2.6.2 of the Reference Manual.
  

Arguments:

    Adapter     Pointer to our adapter

Return Value:

--*/    
{
    CSR_FILTER_STRUC    Filter;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    USHORT              IntStatus;

    NdisZeroMemory (&Filter, sizeof (Filter));

    do
    {

        //
        // Before issue the command to low power state, we should disable the 
        // interrup and ack all the pending interrupts, then set the adapter's power to
        // low state.
        // 
        NICDisableInterrupt(pAdapter);
        NIC_ACK_INTERRUPT(pAdapter, IntStatus);    
        pAdapter->CurrentPowerState = pAdapter->NextPowerState;
        //
        // Send the WakeUp Patter to the nic                        
        MPIssueScbPoMgmtCommand(pAdapter, &Filter, TRUE);

        //
        // Section C.2.6.2 - The driver needs to wait for the CU to idle
        // The above function already waits for the CU to idle
        //
        ASSERT ((pAdapter->CSRAddress->ScbStatus & SCB_CUS_MASK) == SCB_CUS_IDLE);

        
    } while (FALSE);        

    
}
    
NDIS_STATUS
MPSetPowerD0Private (
    IN MP_ADAPTER* pAdapter
    )       
{
    PUCHAR pPMDR; 
    NDIS_STATUS Status; 
            
    do
    {
        // Dump the packet if necessary
        //Cause of Wake Up 

        pPMDR = HwReadPowerPMDR(pAdapter);
        

        NICInitializeAdapter(pAdapter);

        
        // Clear the PMDR 
        MP_CLEAR_PMDR(pPMDR);

        NICIssueSelectiveReset(pAdapter);

    } while (FALSE);

    return NDIS_STATUS_SUCCESS;
}
 


VOID
MPSetPowerWorkItem(
    IN PNDIS_WORK_ITEM pWorkItem,
    IN PVOID pContext
    )
{

    //
    // Call the appropriate function
    //




    //
    // Complete the original request
    //




}



VOID
HwSetWakeUpConfigure(
    IN PMP_ADAPTER pAdapter, 
    PUCHAR pPoMgmtConfigType, 
    UINT WakeUpParameter
    )
{

  
    if (MPIsPoMgmtSupported( pAdapter) == TRUE)   
    {   
        (*pPoMgmtConfigType)=  ((*pPoMgmtConfigType)| CB_WAKE_ON_LINK_BYTE9 |CB_WAKE_ON_ARP_PKT_BYTE9  );
        
    }
}



NDIS_STATUS
MPSetUpFilterCB(
    IN PMP_ADAPTER pAdapter
    )
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    PCB_HEADER_STRUC    NonTxCmdBlockHdr = (PCB_HEADER_STRUC)pAdapter->NonTxCmdBlock;
    PFILTER_CB_STRUC    pFilterCb = (PFILTER_CB_STRUC)NonTxCmdBlockHdr;
    BOOLEAN             bUsePredinfined = FALSE;

    DBGPRINT(MP_TRACE, ("--> HwSetupIAAddress\n"));

    NdisZeroMemory (pFilterCb, sizeof(*pFilterCb));

    // Individual Address Setup
    NonTxCmdBlockHdr->CbStatus = 0;
    NonTxCmdBlockHdr->CbCommand = CB_EL_BIT | CB_LOAD_PROG_FILTER;
    NonTxCmdBlockHdr->CbLinkPointer = DRIVER_NULL;



    if (bUsePredinfined)
        {
            // Simple method
            
            // Set up the first pattern . This is a pre-defined pattern
            pFilterCb->Pattern[3] = \
                    (CB_FILTER_EL |CB_FILTER_PREDEFINED_FIX | CB_FILTER_ARP_WAKEUP | CB_FILTER_IA_WAKEUP );

            pFilterCb->Pattern[0] = pAdapter->PoMgmt.IPAddress.u8[0]; 
            pFilterCb->Pattern[1] = pAdapter->PoMgmt.IPAddress.u8[1]; 
        }
    else
        {
            // correct method

            // go through each filter in the list. 
            ULONG                       Curr = 0;
            ULONG                       Next = 0;
            PLIST_ENTRY                 pPatternEntry = ListNext(&pAdapter->PoMgmt.PatternList) ;
    
            while (pPatternEntry != (&pAdapter->PoMgmt.PatternList))
            {
                PMP_WAKE_PATTERN            pWakeUpPattern = NULL;
                PNDIS_PM_PACKET_PATTERN     pCurrPattern = NULL;;

                // initialize local variables
                pWakeUpPattern = CONTAINING_RECORD(pPatternEntry, MP_WAKE_PATTERN, linkListEntry);

                // increment the iterator
                pPatternEntry = ListNext (pPatternEntry);
                
                // Update the Curr Array Pointer
                Curr = Next;
                
                // Create the Programmable filter for this device.
                MPCreateProgrammableFilter (pWakeUpPattern , (PUCHAR)&pFilterCb->Pattern[Curr], &Next);

                if (Next >=16)
                {
                    break;
                }
            
            } 

            {
                // Set the EL bit on the last pattern
                PUCHAR pLastPattern = (PUCHAR) &pFilterCb->Pattern[Curr]; 

                // Get to bit 31
                pLastPattern[3] |= CB_FILTER_EL ; 


            }

    }   
    ASSERT(pAdapter->CSRAddress->ScbCommandLow == 0)

    //  Wait for the CU to Idle before giving it this command        
    if(!WaitScb(pAdapter))
    {
        Status = NDIS_STATUS_HARD_ERRORS;
    }


    return Status;


}

NDIS_STATUS 
MPIssueScbPoMgmtCommand(
    IN PMP_ADAPTER pAdapter,
    IN PCSR_FILTER_STRUC pNewFilter,
    IN BOOLEAN WaitForScb
    )
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    do
    {
        // Set up SCB to issue this command

        Status = MPSetUpFilterCB(pAdapter);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Submit the configure command to the chip, and wait for it to complete.

        pAdapter->CSRAddress->ScbGeneralPointer = pAdapter->NonTxCmdBlockPhys;

        Status = D100SubmitCommandBlockAndWait(pAdapter);

        if(Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

    } while (FALSE);
        
    return Status;
}



NDIS_STATUS
MPCalculateE100PatternForFilter (
    IN PUCHAR pFrame,
    IN ULONG FrameLength,
    IN PUCHAR pMask,
    IN ULONG MaskLength,
    OUT PULONG pSignature
    )
/*++
Routine Description:

    This function outputs the E100 specific Pattern Signature
    used to wake up the machine.

    Section C.2.4 - CRC word calculation of a Flexible Filer
  

Arguments:

    pFrame                  - Pattern Set by the protocols
    FrameLength             - Length of the Pattern
    pMask                   - Mask set by the Protocols
    MaskLength              - Length of the Mask
    pSignature              - caller allocated return structure
    
Return Value:
    Returns Success 
    Failure - if the Pattern is greater than 129 bytes

--*/    
{
    
    const ULONG Coefficients  = 0x04c11db7;
    ULONG Signature = 0;
    ULONG n = 0;
    ULONG i= 0;
    PUCHAR pCurrentMaskByte = pMask - 1; // init to -1
    ULONG MaskOffset = 0;
    ULONG BitOffsetInMask = 0;
    ULONG MaskBit = 0;
    BOOLEAN fIgnoreCurrentByte = FALSE;
    ULONG ShiftBy = 0;
    UCHAR FrameByte = 0;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    *pSignature = 0;

    do 
    {
        if (FrameLength > 128)
        {   
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        // The E100 driver can only accept 3 DWORDS of Mask in a single pattern 
        if (MaskLength > (3*sizeof(ULONG)))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        for (n=i=0;(n<128) && (n < FrameLength); ++n)
        {
        
            // The first half deals with the question - 
            // Is the nth Frame byte to be included in the Filter
            //
            
            BitOffsetInMask =  (n % 8); 

            if (BitOffsetInMask == 0)
            {
                //
                // We need to move to a new byte. 
                // [0] for 0th byte, [1] for 8th byte, [2] for 16th byte, etc.
                // 
                MaskOffset = n/8; // This is the new byte we need to go 

                //
                //
                if (MaskOffset == MaskLength)
                {
                    break;
                }
                
                pCurrentMaskByte ++;
                ASSERT (*pCurrentMaskByte == pMask[n/8]);    
            }

            
            // Now look at the actual bit in the mask
            MaskBit = 1 << BitOffsetInMask ;
            
            // If the current Mask Bit is set in the Mask then 
            // we need to use it in the CRC calculation, otherwise we ignore it
            fIgnoreCurrentByte = ! (MaskBit & pCurrentMaskByte[0]);

            if (fIgnoreCurrentByte)
            {
                continue;
            }

            // We are suppossed to take in the current byte as part of the CRC calculation
            // Initialize the variables
            FrameByte = pFrame[n];
            ShiftBy = (i % 3 )  * 8;
            
            ASSERT (ShiftBy!= 24); // Bit 24 is never used

            if (Signature & 0x80000000)
            {
                Signature = ((Signature << 1) ^ ( FrameByte << ShiftBy) ^ Coefficients);
            }
            else
            {
                Signature = ((Signature << 1 ) ^ (FrameByte << ShiftBy));
            }
            ++i;

        }

        // Clear bits 22-31
        Signature &= 0x00ffffff; 
        
        // Update the result
        *pSignature = Signature;

        // We have succeeded
        Status = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);

    return Status;
}


VOID
MPCreateProgrammableFilter (
    IN PMP_WAKE_PATTERN     pMpWakePattern , 
    IN PUCHAR pFilter, 
    IN OUT PULONG pNext
    )
/*++
Routine Description:

    This function outputs the E100 specific Pattern Signature
    used to wake up the machine.

    Section C.2.4 - Load Programmable Filter page C.20
  

Arguments:

    pMpWakePattern    - Filter will be created for this pattern, 
    pFilter         - Filter will be stored here, 
    pNext           - Used for validation . This Ulong will also be incremented by the size
                        of the filter (in ulongs)
    
Return Value:

--*/    
{
    PUCHAR pCurrentByte = pFilter;
    ULONG NumBytesWritten = 0;
    PULONG pCurrentUlong = (PULONG)pFilter;
    PNDIS_PM_PACKET_PATTERN pNdisPattern = (PNDIS_PM_PACKET_PATTERN)(&pMpWakePattern->Pattern[0]);
    ULONG LengthOfFilter = 0;

    // Is there enough room for this pattern
    //
    {
        // Length in DWORDS
        LengthOfFilter = pNdisPattern->MaskSize /4;

        if (pNdisPattern->MaskSize % 4 != 0) 
        {       
            LengthOfFilter++;
        }

        // Increment LengthOfFilter to account for the 1st DWORD
        LengthOfFilter++;

        // We are only allowed 16 DWORDS in a filter
        if (*pNext + LengthOfFilter >= 16)
        {
            // Failure - early exit
            return;                    
        }
            
    }
    // Clear the Predefined bit; already cleared in the previous function.    
    // first , initialize    - 
    *pCurrentUlong = 0;

    // Mask Length goes into Bits 27-29 of the 1st DWORD. MaskSize is measured in DWORDs
    {
        ULONG dwMaskSize = pNdisPattern->MaskSize /4;
        ULONG dwMLen = 0;


        // If there is a remainder a remainder then increment
        if (pNdisPattern->MaskSize % 4 != 0)
        {
            dwMaskSize++;
        }


        //            
        // If we fail this assertion, it means our 
        // MaskSize is greater than 16 bytes.
        // This filter should have been failed upfront at the time of the request
        //
        
        ASSERT (0 < dwMaskSize <5);
        //
        // In the Spec, 0 - Single DWORD maske, 001 -  2 DWORD mask, 
        // 011 - 3 DWORD  mask, 111 - 4 Dword Mask. 
        // 
        
        if (dwMaskSize == 1) dwMLen = 0;
        if (dwMaskSize == 2) dwMLen = 1;
        if (dwMaskSize == 3) dwMLen = 3;
        if (dwMaskSize == 4) dwMLen = 7;

        // Adjust the Mlen, so it is in the correct position

        dwMLen = (dwMLen << 3);



        if (dwMLen != 0)
        {
            ASSERT (dwMLen <= 0x38 && dwMLen >= 0x08);
        }                
        
        // These go into bits 27,28,29 (bits 3,4 and 5 of the 4th byte) 
        pCurrentByte[3] |=  dwMLen ;

                
    }

    // Add  the signature to bits 0-23 of the 1st DWORD
    {
        PUCHAR pSignature = (PUCHAR)&pMpWakePattern->Signature;


        // Bits 0-23 are also the 1st three bytes of the DWORD            
        pCurrentByte[0] = pSignature[0];
        pCurrentByte[1] = pSignature[1];
        pCurrentByte[2] = pSignature[2]; 

    }

    
    // Lets move to the next DWORD. Init variables
    pCurrentByte += 4 ;
    NumBytesWritten = 4;
    pCurrentUlong = (PULONG)pCurrentByte;
    
    // We Copy in the Mask over here
    {
        // The Mask is at the end of the pattern
        PNDIS_PM_PACKET_PATTERN pNdisPattern = (PNDIS_PM_PACKET_PATTERN)&pMpWakePattern->Pattern[0];
        PUCHAR pMask = (PUCHAR)pNdisPattern + sizeof(*pNdisPattern);

        Dump (pMask,pNdisPattern->MaskSize, 0,1);

        NdisMoveMemory (pCurrentByte, pMask, pNdisPattern->MaskSize);

        NumBytesWritten += pNdisPattern->MaskSize;
            
    }


    // Update the output value        
    {
        ULONG NumUlongs = (NumBytesWritten /4);

        if ((NumBytesWritten %4) != 0)
        {
            NumUlongs ++;
        }

        ASSERT (NumUlongs == LengthOfFilter);

        *pNext = *pNext + NumUlongs;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\ne2000\card.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    card.c

Abstract:

    Card-specific functions for the NDIS 3.0 Novell 2000 driver.

Author:

    Sean Selitrennikoff

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include "precomp.h"

BOOLEAN
CardSlotTest(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardRamTest(
    IN PNE2000_ADAPTER Adapter
    );


#pragma NDIS_PAGEABLE_FUNCTION(CardCheckParameters)

BOOLEAN CardCheckParameters(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Checks that the I/O base address is correct.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE, if IoBaseAddress appears correct.

--*/

{
    UCHAR Tmp;

    //
    // If adapter responds to a stop command correctly -- assume it is there.
    //

    //
    // Turn off interrupts first.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_MASK, 0);

    //
    // Stop the card.
    //
    SyncCardStop(Adapter);

    //
    // Pause
    //
    NdisStallExecution(2000);

    //
    // Read response
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_COMMAND, &Tmp);

    if ((Tmp == (CR_NO_DMA | CR_STOP)) ||
        (Tmp == (CR_NO_DMA | CR_STOP | CR_START))
    )
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}
#ifdef NE2000

#pragma NDIS_PAGEABLE_FUNCTION(CardSlotTest)


BOOLEAN CardSlotTest(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Checks if the card is in an 8 or 16 bit slot and sets a flag in the
    adapter structure.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE, if all goes well, else FALSE.

--*/

{
    UCHAR Tmp;
    UCHAR RomCopy[32];
    UCHAR i;
	BOOLEAN found;

    //
    // Reset the chip
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_RESET, &Tmp);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RESET, 0xFF);

    //
    // Go to page 0 and stop
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_STOP | CR_NO_DMA);

    //
    // Pause
    //
    NdisStallExecution(2000);

    //
    // Check that it is stopped
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_COMMAND, &Tmp);
    if (Tmp != (CR_NO_DMA | CR_STOP))
    {
        IF_LOUD(DbgPrint("Could not stop the card\n");)

        return(FALSE);
    }

    //
    // Setup to read from ROM
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_DATA_CONFIG,
        DCR_BYTE_WIDE | DCR_FIFO_8_BYTE | DCR_NORMAL
    );

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_MASK, 0x0);

    //
    // Ack any interrupts that may be hanging around
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, 0xFF);

    //
    // Setup to read in the ROM, the address and byte count.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_LSB, 0x0);

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB, 0x0);

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 32);

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0);

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_DMA_READ | CR_START
    );

    //
    // Read first 32 bytes in 16 bit mode
    //
	for (i = 0; i < 32; i++)
	{
		NdisRawReadPortUchar(Adapter->IoPAddr + NIC_RACK_NIC, RomCopy + i);
	}

    IF_VERY_LOUD( DbgPrint("Resetting the chip\n"); )

    //
    // Reset the chip
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_RESET, &Tmp);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RESET, 0xFF);

    //
    // Check ROM for 'B' (byte) or 'W' (word)
    // NOTE: If the buffer has bot BB and WW then use WW instead of BB
    IF_VERY_LOUD( DbgPrint("Checking slot type\n"); )

	found = FALSE;
	for (i = 16; i < 31; i++)
	{
		if (((RomCopy[i] == 'B') && (RomCopy[i+1] == 'B')) ||
			((RomCopy[i] == 'W') && (RomCopy[i+1] == 'W'))
		)
		{
			if (RomCopy[i] == 'B')
			{
				Adapter->EightBitSlot = TRUE;
				found = TRUE;
			}
			else
			{
				Adapter->EightBitSlot = FALSE;
				found = TRUE;
				break;		// Go no farther
			}
		}
	}

	if (found)
	{
		IF_VERY_LOUD( (Adapter->EightBitSlot?DbgPrint("8 bit slot\n"):
							  DbgPrint("16 bit slot\n")); )
	}
	else
	{
		//
		// If neither found -- then not an NE2000
		//
		IF_VERY_LOUD( DbgPrint("Failed slot type\n"); )
	}

    return(found);
}

#endif // NE2000




#pragma NDIS_PAGEABLE_FUNCTION(CardRamTest)

BOOLEAN
CardRamTest(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Finds out how much RAM the adapter has.  It starts at 1K and checks thru
    60K.  It will set Adapter->RamSize to the appropriate value iff this
    function returns TRUE.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE, if all goes well, else FALSE.

--*/

{
    PUCHAR RamBase, RamPointer;
    PUCHAR RamEnd;

	UCHAR TestPattern[]={ 0xAA, 0x55, 0xFF, 0x00 };
	PULONG pTestPattern = (PULONG)TestPattern;
	UCHAR ReadPattern[4];
	PULONG pReadPattern = (PULONG)ReadPattern;

    for (RamBase = (PUCHAR)0x400; RamBase < (PUCHAR)0x10000; RamBase += 0x400) {

        //
        // Write Test pattern
        //

        if (!CardCopyDown(Adapter, RamBase, TestPattern, 4)) {

            continue;

        }

        //
        // Read pattern
        //

        if (!CardCopyUp(Adapter, ReadPattern, RamBase, 4)) {

            continue;

        }

        IF_VERY_LOUD( DbgPrint("Addr 0x%x: 0x%x, 0x%x, 0x%x, 0x%x\n",
                               RamBase,
                               ReadPattern[0],
                               ReadPattern[1],
                               ReadPattern[2],
                               ReadPattern[3]
                              );
                    )


        //
        // If they are the same, find the end
        //

        if (*pReadPattern == *pTestPattern) {

            for (RamEnd = RamBase; !(PtrToUlong(RamEnd) & 0xFFFF0000); RamEnd += 0x400) {

                //
                // Write test pattern
                //

                if (!CardCopyDown(Adapter, RamEnd, TestPattern, 4)) {

                    break;

                }

                //
                // Read pattern
                //

                if (!CardCopyUp(Adapter, ReadPattern, RamEnd, 4)) {

                    break;

                }

                if (*pReadPattern != *pTestPattern) {

                    break;

                }

            }

            break;

        }

    }

    IF_LOUD( DbgPrint("RamBase 0x%x, RamEnd 0x%x\n", RamBase, RamEnd); )

    //
    // If not found, error out
    //

    if ((RamBase >= (PUCHAR)0x10000) || (RamBase == RamEnd)) {

        return(FALSE);

    }

    //
    // Watch for boundary case when RamEnd is maximum value
    //

    if ((ULONG_PTR)RamEnd & 0xFFFF0000) {

        RamEnd -= 0x100;

    }

    //
    // Check all of ram
    //

    for (RamPointer = RamBase; RamPointer < RamEnd; RamPointer += 4) {

        //
        // Write test pattern
        //

        if (!CardCopyDown(Adapter, RamPointer, TestPattern, 4)) {

            return(FALSE);

        }

        //
        // Read pattern
        //

        if (!CardCopyUp(Adapter, ReadPattern, RamBase, 4)) {

            return(FALSE);

        }

        if (*pReadPattern != *pTestPattern) {

            return(FALSE);

        }

    }

    //
    // Store Results
    //

    Adapter->RamBase = RamBase;
    Adapter->RamSize = (ULONG)(RamEnd - RamBase);

    return(TRUE);

}

#pragma NDIS_PAGEABLE_FUNCTION(CardInitialize)

BOOLEAN
CardInitialize(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Initializes the card into a running state.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE, if all goes well, else FALSE.

--*/

{
    UCHAR Tmp;
    USHORT i;

    //
    // Stop the card.
    //
    SyncCardStop(Adapter);

    //
    // Initialize the Data Configuration register.
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_DATA_CONFIG,
        DCR_AUTO_INIT | DCR_FIFO_8_BYTE
    );

    //
    // Set Xmit start location
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_START, 0xA0);

    //
    // Set Xmit configuration
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_CONFIG, 0x0);

    //
    // Set Receive configuration
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RCV_CONFIG, RCR_MONITOR);

    //
    // Set Receive start
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_PAGE_START, 0x4);

    //
    // Set Receive end
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_PAGE_STOP, 0xFF);

    //
    // Set Receive boundary
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_BOUNDARY, 0x4);

    //
    // Set Xmit bytes
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_COUNT_LSB, 0x3C);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_COUNT_MSB, 0x0);

    //
    // Pause
    //
    NdisStallExecution(2000);

    //
    // Ack all interrupts that we might have produced
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, 0xFF);

    //
    // Change to page 1
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE1 | CR_STOP);

    //
    // Set current
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_CURRENT, 0x4);

    //
    // Back to page 0
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0 | CR_STOP);

    //
    // Pause
    //
    NdisStallExecution(2000);

    //
    // Check that Command register reflects this last command
    //
    NdisRawReadPortUchar(Adapter->IoPAddr + NIC_COMMAND, &Tmp);
    if (!(Tmp & CR_STOP))
    {
        IF_LOUD(DbgPrint("Invalid command register\n");)

        return(FALSE);
    }

    //
    // Do initialization errata
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 55);

    //
    // Setup for a read
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_DMA_READ | CR_START
    );

#ifdef NE2000

    //
    // Check if the slot is 8 or 16 bit (affects data transfer rate).
    //

    if ((Adapter->BusType == NdisInterfaceMca) ||
		(NE2000_PCMCIA == Adapter->CardType))
    {
        Adapter->EightBitSlot = FALSE;
    }
    else
    {
        IF_VERY_LOUD(DbgPrint("CardSlotTest\n");)

        if (CardSlotTest(Adapter) == FALSE)
        {
            //
            // Stop chip
            //
            SyncCardStop(Adapter);

            IF_LOUD(DbgPrint("  -- Failed\n");)
            return(FALSE);
        }

    }

#else // NE2000

    Adapter->EightBitSlot = TRUE;

#endif // NE2000

    //
    // Mask Interrupts
    //

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_MASK, 0x0);

    //
    // Setup the Adapter for reading ram
    //

// NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0);   // robin

    if (Adapter->EightBitSlot)
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_DATA_CONFIG,
            DCR_FIFO_8_BYTE | DCR_NORMAL | DCR_BYTE_WIDE
        );
    }
    else
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_DATA_CONFIG,
            DCR_FIFO_8_BYTE | DCR_NORMAL | DCR_WORD_WIDE
        );
    }

    //
    // Clear transmit configuration.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_CONFIG, 0);

    //
    // Clear receive configuration.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RCV_CONFIG, 0);

    //
    // Clear any interrupts
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, 0xFF);

    //
    // Stop the chip
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_NO_DMA | CR_STOP);

    //
    // Clear any DMA values
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0);

    //
    // Clear any DMA values
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0);

    //
    // Wait for the reset to complete.
    //
    i = 0x3FFF;

    while (--i)
    {
        NdisRawReadPortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, &Tmp);

        if (Tmp & ISR_RESET)
            break;

        NdisStallExecution(4);
    }

    //
    // Put card in loopback mode
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_CONFIG, TCR_LOOPBACK);

    //
    // Start the chip.
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_NO_DMA | CR_START
    );

    //
    // Test for the amount of RAM
    //
    if (NE2000_ISA == Adapter->CardType)
    {
        if (CardRamTest(Adapter) == FALSE)
        {
            //
            // Stop the chip
            //
            SyncCardStop(Adapter);

            return(FALSE);
        }
    }
    else
    {
        //
        //  We know what it is for the pcmcia adapters,
        //  so don't waste time on detecting it.
        //
        Adapter->RamBase = (PUCHAR)0x4000;
        Adapter->RamSize = 0x4000;
    }

    //
    // Stop the chip
    //
    SyncCardStop(Adapter);

    return(TRUE);
}


#pragma NDIS_PAGEABLE_FUNCTION(CardReadEthernetAddress)

BOOLEAN CardReadEthernetAddress(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Reads in the Ethernet address from the Novell 2000.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    The address is stored in Adapter->PermanentAddress, and StationAddress if it
    is currently zero.

--*/

{
    UINT    c;

    //
    //  Things are done a little differently for PCMCIA adapters.
    //
    if (NE2000_PCMCIA == Adapter->CardType)
    {
#if 0
    
        NDIS_STATUS             Status;
        PUCHAR                  pAttributeWindow;
        NDIS_PHYSICAL_ADDRESS   AttributePhysicalAddress;
        //
        //  Setup the physical address for the attribute window.
        //
        NdisSetPhysicalAddressHigh(AttributePhysicalAddress, 0);
        NdisSetPhysicalAddressLow(
            AttributePhysicalAddress,
            Adapter->AttributeMemoryAddress
        );

        //
        //  We need to get the pcmcia information from the tuple.
        //
        Status = NdisMMapIoSpace(
                     (PVOID *)&pAttributeWindow,
                     Adapter->MiniportAdapterHandle,
                     AttributePhysicalAddress,
                     Adapter->AttributeMemorySize
                 );
        if (NDIS_STATUS_SUCCESS != Status)
        {
            //
            //  Failed to setup the attribute window.
            //
            return(FALSE);
        }

        //
        //  Read the ethernet address from the card.
        //
        for (c = 0; c < ETH_LENGTH_OF_ADDRESS; c++)
        {
			NdisReadRegisterUchar(
				(PUCHAR)(pAttributeWindow + CIS_NET_ADDR_OFFSET + c * 2),
				&Adapter->PermanentAddress[c]);
        }
#endif
		if (ETH_LENGTH_OF_ADDRESS != NdisReadPcmciaAttributeMemory(
													Adapter->MiniportAdapterHandle,
													CIS_NET_ADDR_OFFSET/2,
													Adapter->PermanentAddress,
													ETH_LENGTH_OF_ADDRESS
													))
		{
			return(FALSE);
		}

    }
    else
    {
        //
        // Setup to read the ethernet address
        //
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 12);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_LSB, 0);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB, 0);
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_COMMAND,
            CR_START | CR_DMA_READ
        );

        //
        // Read in the station address. (We have to read words -- 2 * 6 -- bytes)
        //
        for (c = 0; c < NE2000_LENGTH_OF_ADDRESS; c++)
        {
            NdisRawReadPortUchar(
                Adapter->IoPAddr + NIC_RACK_NIC,
                &Adapter->PermanentAddress[c]
            );
        }
    }

    IF_LOUD(
        DbgPrint(
            "Ne2000: PermanentAddress [ %02x-%02x-%02x-%02x-%02x-%02x ]\n",
            Adapter->PermanentAddress[0],
            Adapter->PermanentAddress[1],
            Adapter->PermanentAddress[2],
            Adapter->PermanentAddress[3],
            Adapter->PermanentAddress[4],
            Adapter->PermanentAddress[5]
        );
    )

    //
    // Use the burned in address as the station address, unless the
    // registry specified an override value.
    //
    if ((Adapter->StationAddress[0] == 0x00) &&
        (Adapter->StationAddress[1] == 0x00) &&
        (Adapter->StationAddress[2] == 0x00) &&
        (Adapter->StationAddress[3] == 0x00) &&
        (Adapter->StationAddress[4] == 0x00) &&
        (Adapter->StationAddress[5] == 0x00)
    )
    {
        Adapter->StationAddress[0] = Adapter->PermanentAddress[0];
        Adapter->StationAddress[1] = Adapter->PermanentAddress[1];
        Adapter->StationAddress[2] = Adapter->PermanentAddress[2];
        Adapter->StationAddress[3] = Adapter->PermanentAddress[3];
        Adapter->StationAddress[4] = Adapter->PermanentAddress[4];
        Adapter->StationAddress[5] = Adapter->PermanentAddress[5];
    }

    return(TRUE);
}


BOOLEAN
CardSetup(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets up the card.

Arguments:

    Adapter - pointer to the adapter block, which must be initialized.

Return Value:

    TRUE if successful.

--*/

{
    UINT i;
    UINT Filter;
    UCHAR Tmp;


    //
    // Write to and read from CR to make sure it is there.
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_STOP | CR_NO_DMA | CR_PAGE0
    );

    NdisRawReadPortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        &Tmp
    );
    if ((Tmp & (CR_STOP | CR_NO_DMA | CR_PAGE0)) !=
        (CR_STOP | CR_NO_DMA | CR_PAGE0)
    )
    {
        return(FALSE);
    }

    //
    // Set up the registers in the correct sequence, as defined by
    // the 8390 specification.
    //
    if (Adapter->EightBitSlot)
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_DATA_CONFIG,
            DCR_BYTE_WIDE | DCR_NORMAL | DCR_FIFO_8_BYTE
        );
    }
    else
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_DATA_CONFIG,
            DCR_WORD_WIDE | DCR_NORMAL | DCR_FIFO_8_BYTE
        );
    }


    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0);

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0);

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_RCV_CONFIG,
        Adapter->NicReceiveConfig
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_XMIT_CONFIG,
        TCR_LOOPBACK
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_BOUNDARY,
        Adapter->NicPageStart
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_PAGE_START,
        Adapter->NicPageStart
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_PAGE_STOP,
        Adapter->NicPageStop
    );

    Adapter->Current = Adapter->NicPageStart + (UCHAR)1;
    Adapter->NicNextPacket = Adapter->NicPageStart + (UCHAR)1;
    Adapter->BufferOverflow = FALSE;

    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_INTR_STATUS, 0xff);

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_INTR_MASK,
        Adapter->NicInterruptMask
    );


    //
    // Move to page 1 to write the station address
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_STOP | CR_NO_DMA | CR_PAGE1
    );

    for (i = 0; i < NE2000_LENGTH_OF_ADDRESS; i++)
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + (NIC_PHYS_ADDR + i),
            Adapter->StationAddress[i]
        );
    }

    Filter = Adapter->PacketFilter;

    //
    // Write out the multicast addresses
    //
    for (i = 0; i < 8; i++)
    {
        NdisRawWritePortUchar(
            Adapter->IoPAddr + (NIC_MC_ADDR + i),
            (UCHAR)((Filter & NDIS_PACKET_TYPE_ALL_MULTICAST) ?
                    0xff : Adapter->NicMulticastRegs[i])
        );
    }

    //
    // Write out the current receive buffer to receive into
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_CURRENT,
        Adapter->Current
    );


    //
    // move back to page 0 and start the card...
    //
    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_STOP | CR_NO_DMA | CR_PAGE0
    );

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_START | CR_NO_DMA | CR_PAGE0
    );

    //
    // ... but it is still in loopback mode.
    //
    return(TRUE);
}

VOID CardStop(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Stops the card.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    None.

--*/

{
    UINT i;
    UCHAR Tmp;

    //
    // Turn on the STOP bit in the Command register.
    //
    SyncCardStop(Adapter);

    //
    // Clear the Remote Byte Count register so that ISR_RESET
    // will come on.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0);


    //
    // Wait for ISR_RESET, but only for 1.6 milliseconds (as
    // described in the March 1991 8390 addendum), since that
    // is the maximum time for a software reset to occur.
    //
    //
    for (i = 0; i < 4; i++)
    {
        NdisRawReadPortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, &Tmp);
        if (Tmp & ISR_RESET)
            break;

        NdisStallExecution(500);
    }

    if (i == 4)
    {
        IF_LOUD( DbgPrint("RESET\n");)
        IF_LOG( Ne2000Log('R');)
    }

    //
    // Put the card in loopback mode, then start it.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_XMIT_CONFIG, TCR_LOOPBACK);
    NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_START | CR_NO_DMA);

    //
    // At this point the card is still in loopback mode.
    //
}

BOOLEAN CardReset(
    IN PNE2000_ADAPTER Adapter
)

/*++

Routine Description:

    Resets the card.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    TRUE if everything is OK.

--*/

{
    //
    // Stop the chip
    //
    CardStop(Adapter);

    //
    // Wait for the card to finish any receives or transmits
    //
    NdisStallExecution(2000);

    //
    // CardSetup() does a software reset.
    //
    if (!CardSetup(Adapter))
    {
        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_HARDWARE_FAILURE,
            2,
            cardReset,
            NE2000_ERRMSG_CARD_SETUP
        );

        return(FALSE);
    }

    //
    // Restart the chip
    //
    CardStart(Adapter);

    return TRUE;
}



BOOLEAN CardCopyDownPacket(
    IN PNE2000_ADAPTER  Adapter,
    IN PNDIS_PACKET     Packet,
    OUT PUINT           Length
)

/*++

Routine Description:

    Copies the packet Packet down starting at the beginning of
    transmit buffer XmitBufferNum, fills in Length to be the
    length of the packet.

Arguments:

    Adapter - pointer to the adapter block
    Packet - the packet to copy down

Return Value:

    Length - the length of the data in the packet in bytes.
    TRUE if the transfer completed with no problems.

--*/

{
    //
    // Addresses of the Buffers to copy from and to.
    //
    PUCHAR CurBufAddress;
    PUCHAR OddBufAddress;
    PUCHAR XmitBufAddress;

    //
    // Length of each of the above buffers
    //
    UINT CurBufLen;
    UINT PacketLength;

    //
    // Was the last transfer of an odd length?
    //
    BOOLEAN OddBufLen = FALSE;

    //
    // Current NDIS_BUFFER that is being copied from
    //
    PNDIS_BUFFER CurBuffer;

    //
    // Programmed I/O, have to transfer the data.
    //
    NdisQueryPacket(Packet, NULL, NULL, &CurBuffer, &PacketLength);

    //
    // Skip 0 length copies
    //
    if (PacketLength == 0) {
        return(TRUE);
    }

    //
    // Get the starting buffer address
    //
    XmitBufAddress = (PUCHAR)Adapter->XmitStart +
                    Adapter->NextBufToFill*TX_BUF_SIZE;

    //
    // Get address and length of the first buffer in the packet
    //
    NdisQueryBuffer(CurBuffer, (PVOID *)&CurBufAddress, &CurBufLen);

    while (CurBuffer && (CurBufLen == 0)) {

        NdisGetNextBuffer(CurBuffer, &CurBuffer);

        NdisQueryBuffer(CurBuffer, (PVOID *)&CurBufAddress, &CurBufLen);

    }

    //
    // set up the card
    //
    {

        //
        // Temporary places for holding values for transferring to
        // an odd aligned address on 16-bit slots.
        //
        UCHAR Tmp;
        UCHAR Tmp1;
        USHORT TmpShort;

        //
        // Values for waiting for noticing when a DMA completes.
        //
        USHORT OldAddr, NewAddr;

        //
        // Count of transfers to do
        //
        USHORT Count;

        //
        // Buffer to read from for odd aligned transfers
        //
        PUCHAR ReadBuffer;

        if (!Adapter->EightBitSlot && ((ULONG_PTR)XmitBufAddress & 0x1)) {

            //
            // Avoid transfers to odd addresses in word mode.
            //
            // For odd addresses we need to read first to get the previous
            // byte and then merge it with our first byte.
            //

            //
            // Set Count and Source address
            //

//          NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0);  // robin

            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                LSB(PtrToUlong(XmitBufAddress - 1))
            );

            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                                  MSB((PtrToUlong(XmitBufAddress) - 1))
                                 );

// NE2000 PCMCIA CHANGE START

            //
            //  NE2000 PCMCIA CHANGE!!!
            //
            //NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x1 );
            //NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0 );

            //
            // Set direction (Read)
            //

            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_COMMAND,
                           CR_START | CR_PAGE0 | CR_DMA_READ );

            //
            //  NE2000 PCMCIA CHANGE!!!
            //
            //NdisRawReadPortUchar( Adapter->IoPAddr + NIC_RACK_NIC, &Tmp1 );
            NdisRawReadPortUshort( Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort );
            Tmp1 = LSB(TmpShort);

// NE2000 PCMCIA CHANGE END

            //
            // Do Write errata as described on pages 1-143 and
            // 1-144 of the 1992 LAN databook
            //

            //
            // Set Count and destination address
            //
            ReadBuffer = XmitBufAddress + ((ULONG_PTR)XmitBufAddress & 1);

            OldAddr = NewAddr = (USHORT)(ReadBuffer);

//          NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND,   // robin
//                                CR_PAGE0                          // robin
//                                );                                // robin
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                                  LSB(PtrToUlong(ReadBuffer))
                                 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                                  MSB(PtrToUlong(ReadBuffer))
                                 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2 );
            NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0 );

            //
            // Set direction (Read)
            //
            NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_COMMAND,
                           CR_START | CR_PAGE0 | CR_DMA_READ
                           );

            //
            // Read from port
            //
            NdisRawReadPortUshort( Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort );

            //
            // Wait for addr to change
            //
            TmpShort = 0xFFFF;

            while (TmpShort != 0) {

                NdisRawReadPortUchar( Adapter->IoPAddr + NIC_CRDA_LSB, &Tmp );
                NewAddr = Tmp;
                NdisRawReadPortUchar( Adapter->IoPAddr + NIC_CRDA_MSB, &Tmp );
                NewAddr |= (Tmp << 8);

                if (NewAddr != OldAddr) {

                    break;

                }

                NdisStallExecution(1);

                TmpShort--;
            }

            if (NewAddr == OldAddr) {

                NdisWriteErrorLogEntry(
                    Adapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_HARDWARE_FAILURE,
                    2,
                    cardCopyDownPacket,
                    (ULONG_PTR)XmitBufAddress
                    );

                return(FALSE);

            }

            //
            // Set Count and destination address
            //
            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                               LSB(PtrToUlong(XmitBufAddress - 1)) );

            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                               MSB(PtrToUlong(XmitBufAddress - 1)) );

            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2 );

            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0 );

            //
            // Set direction (Write)
            //
            NdisRawWritePortUchar( Adapter->IoPAddr + NIC_COMMAND,
                           CR_START | CR_PAGE0 | CR_DMA_WRITE );

            //
            // It seems that the card stores words in LOW:HIGH order
            //
            NdisRawWritePortUshort( Adapter->IoPAddr + NIC_RACK_NIC,
                           (USHORT)(Tmp1 | ((*CurBufAddress) << 8)) );

            //
            // Wait for DMA to complete
            //
            Count = 0xFFFF;

            while (Count) {

                NdisRawReadPortUchar( Adapter->IoPAddr + NIC_INTR_STATUS, &Tmp1 );

                if (Tmp1 & ISR_DMA_DONE) {

                    break;

                } else {

                    Count--;
                    NdisStallExecution(4);

                }

            }

            CurBufAddress++;
            XmitBufAddress++;
            PacketLength--;
            CurBufLen--;

        }

        //
        // Do Write errata as described on pages 1-143 and 1-144 of
        // the 1992 LAN databook
        //

        //
        // Set Count and destination address
        //
        ReadBuffer = XmitBufAddress + ((ULONG_PTR)XmitBufAddress & 1);

        OldAddr = NewAddr = (USHORT)(ReadBuffer);

//      NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND,   // robin
//                            CR_PAGE0                          // robin
//                           );                                 // robin
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                              LSB(PtrToUlong(ReadBuffer))
                             );

        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                              MSB(PtrToUlong(ReadBuffer))
                             );
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                              0x2
                             );
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                              0x0
                             );

        //
        // Set direction (Read)
        //
        NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_COMMAND,
                       CR_START | CR_PAGE0 | CR_DMA_READ
                       );

        if (Adapter->EightBitSlot) {

            //
            // Read from port
            //
            NdisRawReadPortUchar( Adapter->IoPAddr + NIC_RACK_NIC, &Tmp );
            NdisRawReadPortUchar( Adapter->IoPAddr + NIC_RACK_NIC, &Tmp );

        } else {

            //
            // Read from port
            //
            NdisRawReadPortUshort( Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort );

        }

        //
        // Wait for addr to change
        //
        TmpShort = 0xFFFF;

        while (TmpShort != 0) {

            NdisRawReadPortUchar( Adapter->IoPAddr + NIC_CRDA_LSB, &Tmp );
            NewAddr = Tmp;
            NdisRawReadPortUchar( Adapter->IoPAddr + NIC_CRDA_MSB, &Tmp );
            NewAddr |= (Tmp << 8);

            if (NewAddr != OldAddr) {

                break;

            }

            NdisStallExecution(1);

            TmpShort--;
        }

        if (NewAddr == OldAddr) {

            NdisWriteErrorLogEntry(
                Adapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_HARDWARE_FAILURE,
                2,
                cardCopyDownPacket,
                (ULONG_PTR)XmitBufAddress
                );

            return(FALSE);

        }

        //
        // Set Count and destination address
        //

//      NdisRawWritePortUchar( Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0 ); // robin

        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                           LSB(PtrToUlong(XmitBufAddress)) );

        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                           MSB(PtrToUlong(XmitBufAddress)) );

        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                           LSB(PacketLength) );

        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                           MSB(PacketLength) );
        //
        // Set direction (Write)
        //
        NdisRawWritePortUchar( Adapter->IoPAddr + NIC_COMMAND,
                       CR_START | CR_PAGE0 | CR_DMA_WRITE );

    } // setup

    //
    // Copy the data now
    //

    do {

        UINT Count;
        UCHAR Tmp;

        //
        // Write the previous byte with this one
        //
        if (OddBufLen) {

            //
            // It seems that the card stores words in LOW:HIGH order
            //
            NdisRawWritePortUshort( Adapter->IoPAddr + NIC_RACK_NIC,
                       (USHORT)(*OddBufAddress | ((*CurBufAddress) << 8)) );

            OddBufLen = FALSE;
            CurBufAddress++;
            CurBufLen--;

        }

        if (Adapter->EightBitSlot) { // byte mode

            NdisRawWritePortBufferUchar(
                Adapter->IoPAddr + NIC_RACK_NIC,
                CurBufAddress,
                CurBufLen
                );

        } else { // word mode

            NdisRawWritePortBufferUshort(
                Adapter->IoPAddr + NIC_RACK_NIC,
                (PUSHORT)CurBufAddress,
                (CurBufLen >> 1));

            //
            // Save trailing byte (if an odd lengthed transfer)
            //
            if (CurBufLen & 0x1) {
                OddBufAddress = CurBufAddress + (CurBufLen - 1);
                OddBufLen = TRUE;
            }

        }

        //
        // Wait for DMA to complete
        //
        Count = 0xFFFF;
        while (Count) {

            NdisRawReadPortUchar(
                Adapter->IoPAddr + NIC_INTR_STATUS,
                &Tmp );

            if (Tmp & ISR_DMA_DONE) {

                break;

            } else {

                Count--;
                NdisStallExecution(4);

            }

        }

        //
        // Move to the next buffer
        //
        NdisGetNextBuffer(CurBuffer, &CurBuffer);

        if (CurBuffer){
            NdisQueryBuffer(CurBuffer, (PVOID *)&CurBufAddress, &CurBufLen);
        }

        //
        // Get address and length of the next buffer
        //
        while (CurBuffer && (CurBufLen == 0)) {

            NdisGetNextBuffer(CurBuffer, &CurBuffer);

            if (CurBuffer){
                NdisQueryBuffer(CurBuffer, (PVOID *)&CurBufAddress, &CurBufLen);
            }

        }

    } while (CurBuffer);

    //
    // Write trailing byte (if necessary)
    //
    if (OddBufLen)
    {
      UINT    Count;
      UCHAR   Tmp;
      USHORT  TmpShort;

      if (NE2000_PCMCIA == Adapter->CardType) {
//  NE2000 PCMCIA CHANGE!!! start
          TmpShort = (USHORT)*OddBufAddress;
          NdisRawWritePortUshort(Adapter->IoPAddr + NIC_RACK_NIC, TmpShort);
//  NE2000 PCMCIA CHANGE!!! end
      }
      else {
          NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RACK_NIC, *OddBufAddress);
      }

      //
      // Wait for DMA to complete                      robin-2
      //
      Count = 0xFFFF;
      while (Count) {

          NdisRawReadPortUchar(
              Adapter->IoPAddr + NIC_INTR_STATUS,
              &Tmp );

          if (Tmp & ISR_DMA_DONE) {
              break;
          } else {
              Count--;
              NdisStallExecution(4);
          }
      }
    }

    //
    // Return length written
    //
    *Length = PacketLength;

    return TRUE;
}

BOOLEAN
CardCopyDown(
    IN PNE2000_ADAPTER Adapter,
    IN PUCHAR TargetBuffer,
    IN PUCHAR SourceBuffer,
    IN UINT Length
    )

/*++

Routine Description:

    Copies Length bytes from the SourceBuffer to the card buffer space
    at card address TargetBuffer.

Arguments:

    Adapter - pointer to the adapter block

    SourceBuffer - Buffer in virtual address space

    TargetBuffer - Buffer in card address space

    Length - number of bytes to transfer to card

Return Value:

    TRUE if the transfer completed with no problems.

--*/

{
    //
    // Temporary place holders for odd alignment transfers
    //
    UCHAR Tmp, TmpSave;
    USHORT TmpShort;

    //
    // Values for waiting for noticing when a DMA completes.
    //
    USHORT OldAddr, NewAddr;

    //
    // Count of transfers to do
    //
    USHORT Count;

    //
    // Address the copy if coming from
    //
    PUCHAR ReadBuffer;


    //
    // Skip 0 length copies
    //

    if (Length == 0) {

        return(TRUE);

    }


    if (!Adapter->EightBitSlot && ((ULONG_PTR)TargetBuffer & 0x1)) {

        //
        // For odd addresses we need to read first to get the previous
        // byte and then merge it with our first byte.
        //

        //
        // Set Count and Source address
        //
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
            LSB(PtrToUlong(TargetBuffer - 1))
        );

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
            MSB(PtrToUlong(TargetBuffer - 1))
        );

// NE2000 PCMCIA CHANGE!!!  start
        //NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x1);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0);
// NE2000 PCMCIA CHANGE!!!  end

        //
        // Set direction (Read)
        //

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_COMMAND,
            CR_START | CR_PAGE0 | CR_DMA_READ
        );

// NE2000 PCMCIA CHANGE!!!  start
        //NdisRawReadPortUchar(Adapter->IoPAddr + NIC_RACK_NIC, &TmpSave);
        NdisRawReadPortUshort(Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort);
        TmpSave = LSB(TmpShort);
// NE2000 PCMCIA CHANGE!!!  end

        //
        // Do Write errata as described on pages 1-143 and 1-144 of the 1992
        // LAN databook
        //

        //
        // Set Count and destination address
        //

        ReadBuffer = TargetBuffer + ((ULONG_PTR)TargetBuffer & 1);

        OldAddr = NewAddr = (USHORT)(ReadBuffer);

//      NdisRawWritePortUchar(Adapter->IoPAddr + NIC_COMMAND, CR_PAGE0); // robin

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
            LSB(PtrToUlong(ReadBuffer))
        );

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
            MSB(PtrToUlong(ReadBuffer))
        );

        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0);

        //
        // Set direction (Read)
        //

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_COMMAND,
            CR_START | CR_PAGE0 | CR_DMA_READ
        );

        //
        // Read from port
        //

        NdisRawReadPortUshort(Adapter->IoPAddr + NIC_RACK_NIC, &TmpShort);

        //
        // Wait for addr to change
        //

        TmpShort = 0xFFFF;

        while (TmpShort != 0) {

            NdisRawReadPortUchar(
                          Adapter->IoPAddr + NIC_CRDA_LSB,
                          &Tmp
                         );

            NewAddr = Tmp;

            NdisRawReadPortUchar(
                          Adapter->IoPAddr + NIC_CRDA_MSB,
                          &Tmp
                         );

            NewAddr |= (Tmp << 8);

            if (NewAddr != OldAddr) {

                break;
            }

            NdisStallExecution(1);

            TmpShort--;

        }

        if (NewAddr == OldAddr) {

            return(FALSE);

        }

        //
        // Set Count and destination address
        //
        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
            LSB(PtrToUlong(TargetBuffer - 1))
        );

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
            MSB(PtrToUlong(TargetBuffer - 1))
        );

        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_LSB, 0x2);
        NdisRawWritePortUchar(Adapter->IoPAddr + NIC_RMT_COUNT_MSB, 0x0);

        //
        // Set direction (Write)
        //

        NdisRawWritePortUchar(
            Adapter->IoPAddr + NIC_COMMAND,
            CR_START | CR_PAGE0 | CR_DMA_WRITE
        );

        //
        // It seems that the card stores words in LOW:HIGH order
        //

        NdisRawWritePortUshort(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       (USHORT)(TmpSave | ((*SourceBuffer) << 8))
                       );

        //
        // Wait for DMA to complete
        //

        Count = 0xFFFF;

        while (Count) {

            NdisRawReadPortUchar(
                          Adapter->IoPAddr + NIC_INTR_STATUS,
                          &Tmp
                         );

            if (Tmp & ISR_DMA_DONE) {

                break;

            } else {

                Count--;

                NdisStallExecution(4);

            }

        }

        SourceBuffer++;
        TargetBuffer++;
        Length--;

    }

    //
    // Do Write errata as described on pages 1-143 and 1-144 of the 1992
    // LAN databook
    //

    //
    // Set Count and destination address
    //

    ReadBuffer = TargetBuffer + ((ULONG_PTR)TargetBuffer & 1);

    OldAddr = NewAddr = (USHORT)(ReadBuffer);

//  NdisRawWritePortUchar(                              // robin
//                     Adapter->IoPAddr + NIC_COMMAND,  // robin
//                     CR_PAGE0                         // robin
//                    );                                // robin

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                       LSB(PtrToUlong(ReadBuffer))
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                       MSB(PtrToUlong(ReadBuffer))
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                       0x2
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                       0x0
                      );

    //
    // Set direction (Read)
    //

    NdisRawWritePortUchar(
                   Adapter->IoPAddr + NIC_COMMAND,
                   CR_START | CR_PAGE0 | CR_DMA_READ
                  );

    if (Adapter->EightBitSlot) {

        //
        // Read from port
        //

        NdisRawReadPortUchar(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       &Tmp
                      );


        NdisRawReadPortUchar(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       &Tmp
                      );

    } else {

        //
        // Read from port
        //

        NdisRawReadPortUshort(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       &TmpShort
                      );

    }

    //
    // Wait for addr to change
    //

    TmpShort = 0xFFFF;

    while (TmpShort != 0) {

        NdisRawReadPortUchar(
                      Adapter->IoPAddr + NIC_CRDA_LSB,
                      &Tmp
                     );

        NewAddr = Tmp;

        NdisRawReadPortUchar(
                      Adapter->IoPAddr + NIC_CRDA_MSB,
                      &Tmp
                     );

        NewAddr |= (Tmp << 8);

        if (NewAddr != OldAddr) {

            break;
        }

        NdisStallExecution(1);

        TmpShort--;

    }

    if (NewAddr == OldAddr) {

        return(FALSE);

    }

    //
    // Set Count and destination address
    //

//  NdisRawWritePortUchar(                              // robin
//                     Adapter->IoPAddr + NIC_COMMAND,  // robin
//                     CR_PAGE0                         // robin
//                    );                                // robin

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                       LSB(PtrToUlong(TargetBuffer))
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                       MSB(PtrToUlong(TargetBuffer))
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                       LSB(Length)
                      );

    NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                       MSB(Length)
                      );

    //
    // Set direction (Write)
    //

    NdisRawWritePortUchar(
                   Adapter->IoPAddr + NIC_COMMAND,
                   CR_START | CR_PAGE0 | CR_DMA_WRITE
                  );

    if (Adapter->EightBitSlot) {

        //
        // Repeatedly write to out port
        //

        NdisRawWritePortBufferUchar(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       SourceBuffer,
                       Length);

    } else {

        //
        // Write words to out ports
        //

        NdisRawWritePortBufferUshort(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       (PUSHORT)SourceBuffer,
                       (Length >> 1));

        //
        // Write trailing byte (if necessary)
        //
        if (Length & 0x1)
        {
            SourceBuffer += (Length - 1);

// NE2000 PCMCIA CHANGE!!!  start

            //NdisRawWritePortUchar(
            //    Adapter->IoPAddr + NIC_RACK_NIC,
            //    *SourceBuffer
            //);

            TmpShort = (USHORT)(*SourceBuffer);
            NdisRawWritePortUshort(
                Adapter->IoPAddr + NIC_RACK_NIC,
                TmpShort
            );
// NE2000 PCMCIA CHANGE!!!  end


        }

    }

    //
    // Wait for DMA to complete
    //

    Count = 0xFFFF;

    while (Count) {

        NdisRawReadPortUchar(
                      Adapter->IoPAddr + NIC_INTR_STATUS,
                      &Tmp
                     );

        if (Tmp & ISR_DMA_DONE) {

            break;

        } else {

            Count--;

            NdisStallExecution(4);

        }

#if DBG
        if (!(Tmp & ISR_DMA_DONE)) {

            DbgPrint("CopyDownDMA didn't finish!");

        }
#endif // DBG

    }

    IF_LOG(Ne2000Log('>');)

    return TRUE;
}


BOOLEAN
CardCopyUp(
    IN PNE2000_ADAPTER Adapter,
    IN PUCHAR TargetBuffer,
    IN PUCHAR SourceBuffer,
    IN UINT BufferLength
    )

/*++

Routine Description:

    Copies data from the card to memory.

Arguments:

    Adapter - pointer to the adapter block

    Target - the target address

    Source - the source address (on the card)

    BufferLength - the number of bytes to copy

Return Value:

    TRUE if the transfer completed with no problems.

--*/

{

    //
    // Used to check when the dma is done
    //
    UCHAR IsrValue;

    //
    // Count of the number of transfers to do
    //
    USHORT Count;

    //
    // Place holder for port values
    //
    UCHAR Temp;

    if (BufferLength == 0) {

        return TRUE;

    }

    //
    // Read the Command Register, to make sure it is ready for a write
    //
    NdisRawReadPortUchar(Adapter->IoPAddr+NIC_COMMAND, &Temp);

    if (Adapter->EightBitSlot) {

        //
        // If byte mode
        //

        //
        // Set Count and destination address
        //

//      NdisRawWritePortUchar(                               // robin
//                         Adapter->IoPAddr + NIC_COMMAND,   // robin
//                         CR_PAGE0                          // robin
//                        );                                 // robin

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                           LSB(PtrToUlong(SourceBuffer))
                          );

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                           MSB(PtrToUlong(SourceBuffer))
                          );

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                           LSB(BufferLength)
                          );

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                           MSB(BufferLength)
                          );

        //
        // Set direction (Read)
        //

        NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_COMMAND,
                       CR_START | CR_PAGE0 | CR_DMA_READ
                      );
        //
        // Repeatedly read from port
        //

        NdisRawReadPortBufferUchar(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       TargetBuffer,
                       BufferLength
                      );

    } else {

        //
        // Else word mode
        //

        USHORT Tmp;

//      NdisRawWritePortUchar(                                   // robin
//                             Adapter->IoPAddr + NIC_COMMAND,   // robin
//                             CR_PAGE0                          // robin
//                            );                                 // robin

        //
        // Avoid transfers to odd addresses
        //

        if ((ULONG_PTR)SourceBuffer & 0x1) {

            //
            // For odd addresses we need to read previous word and store the
            // second byte
            //

            //
            // Set Count and Source address
            //

            NdisRawWritePortUchar(
                               Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                               LSB(PtrToUlong(SourceBuffer - 1))
                              );

            NdisRawWritePortUchar(
                               Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                               MSB(PtrToUlong(SourceBuffer - 1))
                              );

            NdisRawWritePortUchar(
                               Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                               0x2
                              );

            NdisRawWritePortUchar(
                               Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                               0x0
                              );

            //
            // Set direction (Read)
            //

            NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_COMMAND,
                           CR_START | CR_PAGE0 | CR_DMA_READ
                          );

            NdisRawReadPortUshort(
                           Adapter->IoPAddr + NIC_RACK_NIC,
                           &Tmp
                           );

            *TargetBuffer = MSB(Tmp);

            //
            // Wait for DMA to complete
            //

            Count = 0xFFFF;

            while (Count) {

                NdisRawReadPortUchar(
                              Adapter->IoPAddr + NIC_INTR_STATUS,
                              &IsrValue
                             );

                if (IsrValue & ISR_DMA_DONE) {

                    break;

                } else {

                    Count--;

                    NdisStallExecution(4);

                }

#if DBG
                if (!(IsrValue & ISR_DMA_DONE)) {

                    DbgPrint("CopyUpDMA didn't finish!");

                }
#endif // DBG

            }

            SourceBuffer++;
            TargetBuffer++;
            BufferLength--;
        }

        //
        // Set Count and destination address
        //

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_ADDR_LSB,
                           LSB(PtrToUlong(SourceBuffer))
                          );

        NdisRawWritePortUchar(
                           Adapter->IoPAddr + NIC_RMT_ADDR_MSB,
                           MSB(PtrToUlong(SourceBuffer))
                          );

// NE2000 PCMCIA CHANGE!!!  start

//        NdisRawWritePortUchar(
//            Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
//            LSB(BufferLength)
//        );
//
//        NdisRawWritePortUchar(
//            Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
//            MSB(BufferLength)
//        );

        if (BufferLength & 1)
        {
            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                LSB(BufferLength + 1)
            );

            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                MSB(BufferLength + 1)
            );
        }
        else
        {
            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_COUNT_LSB,
                LSB(BufferLength)
            );

            NdisRawWritePortUchar(
                Adapter->IoPAddr + NIC_RMT_COUNT_MSB,
                MSB(BufferLength)
            );
        }

// NE2000 PCMCIA CHANGE!!!  end


        //
        // Set direction (Read)
        //

        NdisRawWritePortUchar(
                       Adapter->IoPAddr + NIC_COMMAND,
                       CR_START | CR_PAGE0 | CR_DMA_READ
                      );

        //
        // Read words from port
        //

        NdisRawReadPortBufferUshort(
                       Adapter->IoPAddr + NIC_RACK_NIC,
                       (PUSHORT)TargetBuffer,
                       (BufferLength >> 1));

        //
        // Read trailing byte (if necessary)
        //

        if (BufferLength & 1) {

            TargetBuffer += (BufferLength - 1);

// NE2000 PCMCIA CHANGE!!!  start

            //NdisRawReadPortUchar(
            //    Adapter->IoPAddr + NIC_RACK_NIC,
            //    TargetBuffer
            //);

            NdisRawReadPortUshort(
                Adapter->IoPAddr + NIC_RACK_NIC,
                &Tmp
            );

            *TargetBuffer = LSB(Tmp);

// NE2000 PCMCIA CHANGE!!!  end
        }

    }

    //
    // Wait for DMA to complete
    //

    Count = 0xFFFF;

    while (Count) {

        NdisRawReadPortUchar(
                      Adapter->IoPAddr + NIC_INTR_STATUS,
                      &IsrValue
                     );

        if (IsrValue & ISR_DMA_DONE) {

            break;

        } else {

            Count--;

            NdisStallExecution(4);

        }

    }

#if DBG
    if (!(IsrValue & ISR_DMA_DONE)) {

        DbgPrint("CopyUpDMA didn't finish!\n");

    }

    IF_LOG(Ne2000Log('<');)

#endif // DBG

    return TRUE;

}

ULONG
CardComputeCrc(
    IN PUCHAR Buffer,
    IN UINT Length
    )

/*++

Routine Description:

    Runs the AUTODIN II CRC algorithm on buffer Buffer of
    length Length.

Arguments:

    Buffer - the input buffer

    Length - the length of Buffer

Return Value:

    The 32-bit CRC value.

Note:

    This is adapted from the comments in the assembly language
    version in _GENREQ.ASM of the DWB NE1000/2000 driver.

--*/

{
    ULONG Crc, Carry;
    UINT i, j;
    UCHAR CurByte;

    Crc = 0xffffffff;

    for (i = 0; i < Length; i++) {

        CurByte = Buffer[i];

        for (j = 0; j < 8; j++) {

            Carry = ((Crc & 0x80000000) ? 1 : 0) ^ (CurByte & 0x01);

            Crc <<= 1;

            CurByte >>= 1;

            if (Carry) {

                Crc = (Crc ^ 0x04c11db6) | Carry;

            }

        }

    }

    return Crc;

}


VOID
CardGetMulticastBit(
    IN UCHAR Address[NE2000_LENGTH_OF_ADDRESS],
    OUT UCHAR * Byte,
    OUT UCHAR * Value
    )

/*++

Routine Description:

    For a given multicast address, returns the byte and bit in
    the card multicast registers that it hashes to. Calls
    CardComputeCrc() to determine the CRC value.

Arguments:

    Address - the address

    Byte - the byte that it hashes to

    Value - will have a 1 in the relevant bit

Return Value:

    None.

--*/

{
    ULONG Crc;
    UINT BitNumber;

    //
    // First compute the CRC.
    //

    Crc = CardComputeCrc(Address, NE2000_LENGTH_OF_ADDRESS);


    //
    // The bit number is now in the 6 most significant bits of CRC.
    //

    BitNumber = (UINT)((Crc >> 26) & 0x3f);

    *Byte = (UCHAR)(BitNumber / 8);
    *Value = (UCHAR)((UCHAR)1 << (BitNumber % 8));
}

VOID
CardFillMulticastRegs(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Erases and refills the card multicast registers. Used when
    an address has been deleted and all bits must be recomputed.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    None.

--*/

{
    UINT i;
    UCHAR Byte, Bit;

    //
    // First turn all bits off.
    //

    for (i=0; i<8; i++) {

        Adapter->NicMulticastRegs[i] = 0;

    }

    //
    // Now turn on the bit for each address in the multicast list.
    //

    for ( ; i > 0; ) {

        i--;

        CardGetMulticastBit(Adapter->Addresses[i], &Byte, &Bit);

        Adapter->NicMulticastRegs[Byte] |= Bit;

    }

}








BOOLEAN SyncCardStop(
    IN PVOID SynchronizeContext
)

/*++

Routine Description:

    Sets the NIC_COMMAND register to stop the card.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    TRUE if the power has failed.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);

    NdisRawWritePortUchar(
        Adapter->IoPAddr + NIC_COMMAND,
        CR_STOP | CR_NO_DMA
    );

    return(FALSE);
}

VOID
CardStartXmit(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets the NIC_COMMAND register to start a transmission.
    The transmit buffer number is taken from Adapter->CurBufXmitting
    and the length from Adapter->PacketLens[Adapter->CurBufXmitting].

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    TRUE if the power has failed.

--*/

{
    UINT Length = Adapter->PacketLens[Adapter->CurBufXmitting];
    UCHAR Tmp;

    //
    // Prepare the NIC registers for transmission.
    //

    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_XMIT_START,
        (UCHAR)(Adapter->NicXmitStart + (UCHAR)(Adapter->CurBufXmitting*BUFS_PER_TX)));

    //
    // Pad the length to 60 (plus CRC will be 64) if needed.
    //

    if (Length < 60) {

        Length = 60;

    }

    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_XMIT_COUNT_MSB, MSB(Length));
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_XMIT_COUNT_LSB, LSB(Length));

    //
    // Start transmission, check for power failure first.
    //

    NdisRawReadPortUchar(Adapter->IoPAddr+NIC_COMMAND, &Tmp);
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND,
            CR_START | CR_XMIT | CR_NO_DMA);

    IF_LOG( Ne2000Log('x');)

}

BOOLEAN
SyncCardGetCurrent(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Gets the value of the CURRENT NIC register and stores it in Adapter->Current

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);

    //
    // Have to go to page 1 to read this register
    //

    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND,
                       CR_START | CR_NO_DMA | CR_PAGE1);

    NdisRawReadPortUchar(Adapter->IoPAddr+NIC_CURRENT,
                       &Adapter->Current);

    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND,
                       CR_START | CR_NO_DMA | CR_PAGE0);

    return FALSE;

}

BOOLEAN
SyncCardGetXmitStatus(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Gets the value of the "transmit status" NIC register and stores
    it in Adapter->XmitStatus.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);

    NdisRawReadPortUchar( Adapter->IoPAddr+NIC_XMIT_STATUS, &Adapter->XmitStatus);

    return FALSE;

}

VOID
CardSetBoundary(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets the value of the "boundary" NIC register to one behind
    Adapter->NicNextPacket, to prevent packets from being received
    on top of un-indicated ones.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    None.

--*/

{
    //
    // Have to be careful with "one behind NicNextPacket" when
    // NicNextPacket is the first buffer in receive area.
    //

    if (Adapter->NicNextPacket == Adapter->NicPageStart) {

        NdisRawWritePortUchar( Adapter->IoPAddr+NIC_BOUNDARY,
                    (UCHAR)(Adapter->NicPageStop-(UCHAR)1));

    } else {

        NdisRawWritePortUchar( Adapter->IoPAddr+NIC_BOUNDARY,
                    (UCHAR)(Adapter->NicNextPacket-(UCHAR)1));

    }

}

BOOLEAN
SyncCardSetReceiveConfig(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Sets the value of the "receive configuration" NIC register to
    the value of Adapter->NicReceiveConfig.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_RCV_CONFIG, Adapter->NicReceiveConfig);

    return FALSE;

}

BOOLEAN
SyncCardSetAllMulticast(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Turns on all the bits in the multicast register. Used when
    the card must receive all multicast packets.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UINT i;

    //
    // Have to move to page 1 to set these registers.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND,
                    CR_START | CR_NO_DMA | CR_PAGE1);

    for (i=0; i<8; i++) {

        NdisRawWritePortUchar( Adapter->IoPAddr+(NIC_MC_ADDR+i), 0xff);

    }

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND,
                    CR_START | CR_NO_DMA | CR_PAGE0);

    return FALSE;

}

BOOLEAN
SyncCardCopyMulticastRegs(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Sets the eight bytes in the card multicast registers.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UINT i;

    //
    // Have to move to page 1 to set these registers.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND,
                    CR_START | CR_NO_DMA | CR_PAGE1);

    for (i=0; i<8; i++) {

        NdisRawWritePortUchar( Adapter->IoPAddr+(NIC_MC_ADDR+i),
                        Adapter->NicMulticastRegs[i]);

    }

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND,
                    CR_START | CR_NO_DMA | CR_PAGE0);

    return FALSE;

}

BOOLEAN
SyncCardAcknowledgeOverflow(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Sets the "buffer overflow" bit in the NIC interrupt status register,
    which re-enables interrupts of that type.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UCHAR AcknowledgeMask = 0;

    if (Adapter->InterruptStatus & ISR_RCV_ERR) {

        SyncCardUpdateCounters(Adapter);

    }

    return FALSE;

}

BOOLEAN
SyncCardUpdateCounters(
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

    Updates the values of the three counters (frame alignment errors,
    CRC errors, and missed packets).

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UCHAR Tmp;

    NdisRawReadPortUchar( Adapter->IoPAddr+NIC_FAE_ERR_CNTR, &Tmp);
    Adapter->FrameAlignmentErrors += Tmp;

    NdisRawReadPortUchar( Adapter->IoPAddr+NIC_CRC_ERR_CNTR, &Tmp);
    Adapter->CrcErrors += Tmp;

    NdisRawReadPortUchar( Adapter->IoPAddr+NIC_MISSED_CNTR, &Tmp);
    Adapter->MissedPackets += Tmp;

    return FALSE;

}

BOOLEAN
SyncCardHandleOverflow(
    IN PVOID SynchronizeContext
    )

/*++<

Routine Description:

    Sets all the flags for dealing with a receive overflow, stops the card
    and acknowledges all outstanding interrupts.

Arguments:

    SynchronizeContext - pointer to the adapter block

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)SynchronizeContext);
    UCHAR Status;

    IF_LOG( Ne2000Log('F');)

    //
    // Turn on the STOP bit in the Command register.
    //

    SyncCardStop(Adapter);

    //
    // Wait for ISR_RESET, but only for 1.6 milliseconds (as
    // described in the March 1991 8390 addendum), since that
    // is the maximum time for a software reset to occur.
    //
    //

    NdisStallExecution(2000);

    //
    // Save whether we were transmitting to avoid a timing problem
    // where an indication resulted in a send.
    //

    if (!(Adapter->InterruptStatus & (ISR_XMIT | ISR_XMIT_ERR))) {

        CardGetInterruptStatus(Adapter,&Status);
        if (!(Status & (ISR_XMIT | ISR_XMIT_ERR))) {

            Adapter->OverflowRestartXmitDpc = Adapter->TransmitInterruptPending;

            IF_LOUD( DbgPrint("ORXD=%x\n",Adapter->OverflowRestartXmitDpc); )
        }

    }

    Adapter->TransmitInterruptPending = FALSE;

    //
    // Clear the Remote Byte Count register so that ISR_RESET
    // will come on.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_RMT_COUNT_MSB, 0);
    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_RMT_COUNT_LSB, 0);

    //
    // According to National Semiconductor, the next check is necessary
    // See Step 5. of the overflow process
    //
    // NOTE: The setting of variables to check if the transmit has completed
    // cannot be done here because anything in the ISR has already been ack'ed
    // inside the main DPC.  Thus, the setting of the variables, described in
    // the Handbook was moved to the main DPC.
    //
    // Continued: If you did the check here, you will doubly transmit most
    // packets that happened to be on the card when the overflow occurred.
    //

    //
    // Put the card in loopback mode, then start it.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_XMIT_CONFIG, TCR_LOOPBACK);

    //
    // Start the card.  This does not Undo the loopback mode.
    //

    NdisRawWritePortUchar( Adapter->IoPAddr+NIC_COMMAND, CR_START | CR_NO_DMA);

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\testwmi\testwmi.h ===
#ifndef _TESTWMI_H_INCLUDED

#define _TESTWMI_H_INCLUDED

#define _WIN32_DCOM

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <commctrl.h>        // For common controls, e.g. Tree
#include <objidl.h>
#include <objbase.h>
#include <ole2.h>
#include <wbemcli.h>

//
// Resource editor generated header file.
//

#include "resource.h"

//
// Default namespace.
//

#define DEFAULT_NAMESPACE      L"root\\wmi"

#define ROOT_CLASS             NULL


typedef struct _PROPERTY_INFO {
   IWbemServices    *pIWbemServices;
   IWbemClassObject *pInstance;
   LPTSTR           lpszProperty;
   LPTSTR           lpszType;
   LPVARIANT        pvaValue;
}  PROPERTY_INFO, *LPPROPERTY_INFO;
  
//
// Function defined in testwmi.cpp
//

int APIENTRY WinMain (HINSTANCE hInst,
                      HINSTANCE hPrevInstance, 
                      LPSTR lpCmdLine,         
                      int nCmdShow);

INT_PTR CALLBACK MainDlgProc (HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

INT_PTR CALLBACK DlgProcScalar (HWND hwndDlg,
                                UINT uMsg,
                                WPARAM wParam,
                                LPARAM lParam);

VOID ListDefaults (HWND hwndDlg);

VOID ShowProperties (HWND hwndDlg,
                     HWND hwndInstTree);

VOID EditProperty (HWND hwndDlg,
                   HWND hwndPropTree);

BOOL ModifyProperty (HWND hwndDlg);

BOOL DisplayArrayProperty (LPTSTR lpszProperty,
                           VARIANT *pvaValue,
                           HWND hwndDlg);

HRESULT AddToList (HWND hwndDlg,
                  VARIANT *pvaValue);

VOID ModifyArrayProperty(HWND hwndDlg,
                         LPPROPERTY_INFO pPropInfo);

VOID RefreshOnClassSelection (HWND hwndDlg);

LPTSTR GetSelectedClass (HWND hwndClassList);

LPTSTR GetSelectedItem (HWND hwndTree);

VOID InsertItem (HWND hwndTree,
                 LPTSTR lpszItem);

VOID PrintError (HRESULT hr,
                 UINT    uiLine,
                 LPTSTR  lpszFile,
                 LPCTSTR  lpFmt,
                 ...);

//
// Functions defined in wmicode.c
//

IWbemServices *ConnectToNamespace (VOID);

VOID EnumInstances (IWbemServices *pIWbemServices,
                    LPTSTR        lpszClass,
                    HWND          hwndInstTree);

VOID EnumProperties (IWbemServices *pIWbemServices,
                     LPTSTR        lpszClass,
                     LPTSTR        lpszInstance,
                     HWND          hwndPropTree);

IWbemClassObject *GetInstanceReference (IWbemServices *pIWbemServices,
                                        LPTSTR        lpszClass,
                                        LPTSTR        lpszInstance);

BOOL IsInstance (IWbemClassObject *pInst,
                 LPTSTR lpszInstance);

BOOL GetPropertyValue (IWbemClassObject *pRef,
                       LPTSTR lpszProperty, 
                       VARIANT *pvaPropertyValue,
                       LPTSTR *lppszPropertyType);

HRESULT UpdatePropertyValue (IWbemServices *pIWbemServices,
                             IWbemClassObject *pInstance,
                             LPTSTR lpszProperty,
                             LPVARIANT pvaNewValue);

BSTR StringToBstr (LPTSTR lpSrc,
                  int nLenSrc);

LPTSTR BstrToString (BSTR lpSrc,
                    int nLenSrc);


#endif // _TESTWMI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\testwmi\testwmi.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright 2000 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM: testwmi.cpp
//
// AUTHOR:  Alok Sinha August 15, 2000
//
// PURPOSE: To test getting/setting custom classs of E100BEX driver.
//
// ENVIRONMENT: Windows 2000 user mode application.
//

#include "testwmi.h"

//
// List of custom classes as defined in E100BEX sample.
//
// If you want to use this application to excersize querying/setting guids
// exported by your driver then, simply add the class name of the guid
// to the following array and recompile the program.
//

LPTSTR lpszClasses[] = {
                         TEXT("E100BExampleSetUINT_OID"),
                         TEXT("E100BExampleQueryUINT_OID"),
                         TEXT("E100BExampleQueryArrayOID"),
                         TEXT("E100BExampleQueryStringOID")
                       };
                         
//
// Handle to this instance of the application.
//

HINSTANCE     hInstance;

//
// Program entry point.
//

int APIENTRY WinMain (HINSTANCE hInst,
                      HINSTANCE hPrevInstance, 
                      LPSTR lpCmdLine,         
                      int nCmdShow)
{
  HRESULT   hr;

  hInstance = hInst;

  //
  // Make sure common control DLL is loaded.
  //

  InitCommonControls();

  //
  // Initialize COM library. Must be done before invoking any
  // other COM function.
  //

  hr = CoInitializeEx( NULL,
                       COINIT_MULTITHREADED );

  if ( hr != S_OK ) {
     PrintError( hr,
               __LINE__,
               TEXT(__FILE__),
               TEXT("Failed to initialize COM library, program exiting...") );
  }
  else {

	    hr =  CoInitializeSecurity( NULL,
                                 -1,
                                 NULL,
                                 NULL,
								                         RPC_C_AUTHN_LEVEL_CONNECT, 
								                         RPC_C_IMP_LEVEL_IDENTIFY, 
								                         NULL,
                                 EOAC_NONE,
                                 0 );
	    if ( hr == S_OK ) {
      
         if ( DialogBox(hInstance,
                        MAKEINTRESOURCE(IDD_MAIN), 
                        NULL,
                        MainDlgProc) == -1 ) {
            PrintError( HRESULT_FROM_WIN32(GetLastError()),
                      __LINE__,
                      TEXT(__FILE__),
                      TEXT("Failed to create the dialog box, ")
                      TEXT("program exiting...") );
        }
     }
     else {
        PrintError( hr,
                  __LINE__,
                  TEXT(__FILE__),
                  TEXT("CoInitializeSecurity failed, program exiting...") );
     }

     CoUninitialize();
  }

  return 0;
}

//
// Windows procedure for the main dialog box.
//

INT_PTR CALLBACK MainDlgProc (HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam)
{
  IWbemServices *pIWbemServices;
  LPNMTREEVIEW  lpnmTreeView;


  switch (uMsg) {

     case WM_INITDIALOG:


             //
             // Connect to the default namespace.
             //

             pIWbemServices = ConnectToNamespace();

             if ( !pIWbemServices ) {

                EndDialog( hwndDlg, 0 );
             }

             //
             // At DWLP_USER offset, we store pIWbemServices so we can
             // get to it later.
             //

             SetWindowLongPtr(
                      hwndDlg,
                      DWLP_USER,
                      (LONG_PTR)pIWbemServices );
             //
             // Enumerate default classes and its instances. Also,
             // show properties of the first instance.
             //

             ListDefaults( hwndDlg );

             return TRUE; // Tell Windows to continue creating the dialog box.

     case WM_COMMAND:

          switch( LOWORD(wParam) ) {

             case IDL_CLASSES:
                  if ( HIWORD(wParam) == LBN_SELCHANGE ) {

                     //
                     // User selected a class. Show its instances and
                     // the properties of the first instance.
                     //

                     RefreshOnClassSelection( hwndDlg );
                  }
                  
                  break;
          }

          break;

     case WM_NOTIFY:

          switch( wParam ) {

             case IDT_INSTANCES:

                lpnmTreeView = (LPNMTREEVIEW)lParam;

                if ( (lpnmTreeView->hdr.code == TVN_SELCHANGED) &&
                     (lpnmTreeView->action != TVC_UNKNOWN) ) {

                   //
                   // User has clicked on an instance, list its properties.
                   //     

                   ShowProperties( hwndDlg,
                                   lpnmTreeView->hdr.hwndFrom );

                }
                break;

             case IDT_PROPERTIES:

                lpnmTreeView = (LPNMTREEVIEW)lParam;

                if ( lpnmTreeView->hdr.code == NM_DBLCLK ) {

                   //
                   // User has double-clicked on a property.
                   //     

                   EditProperty( hwndDlg,
                                 lpnmTreeView->hdr.hwndFrom );
                }

                break;
             }

             break;

     case WM_SYSCOMMAND:

             //
             // Before exiting...
             //    .Make sure to disconnect from the namespace.
             //

             if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                 pIWbemServices = (IWbemServices *)GetWindowLongPtr(
                                                          hwndDlg,
                                                          DWLP_USER );
                pIWbemServices->Release();

                EndDialog( hwndDlg, 0 );
             }
  }

  return FALSE;
}

//
// Windows procedure to view/modify scalar properties.
//

INT_PTR CALLBACK DlgProcScalar (HWND hwndDlg,
                                UINT uMsg,
                                WPARAM wParam,
                                LPARAM lParam)
{
  LPPROPERTY_INFO  pPropInfo;
  VARIANT          vaTemp;
  LPTSTR           lpszValue;
  HRESULT          hr;

  switch (uMsg) {

     case WM_INITDIALOG:

          //
          // lParam points to PROPERTY_INFO structure which contains information
          // the property whose valuse is to be viewed/modified. We store this
          // pointer at DWLP_USER offset, so we get to it later.
          //

          SetWindowLongPtr( hwndDlg,
                            DWLP_USER,
                            (LONG_PTR)lParam );

          pPropInfo = (LPPROPERTY_INFO)lParam;

          //
          // Property name is the title of the dialog box.
          //

          SetWindowText( hwndDlg,
                         pPropInfo->lpszProperty );

          //
          // Show the property type.
          //

          if ( pPropInfo->lpszType ) {
             SetWindowText( GetDlgItem(hwndDlg,
                                       IDS_PROPERTY_TYPE),
                            pPropInfo->lpszType );
          }

          //
          // Change the property value to a string so it can be displayed
          // if the property has a value.
          //

          if ( (V_VT(pPropInfo->pvaValue) != VT_NULL) &&
               (V_VT(pPropInfo->pvaValue) != VT_EMPTY) ) {

             VariantInit( &vaTemp );

             hr = VariantChangeType( &vaTemp,
                                     pPropInfo->pvaValue,
                                     VARIANT_LOCALBOOL,
                                     VT_BSTR );

             if ( hr != S_OK ) {

                PrintError( hr,
                            __LINE__,
                            TEXT(__FILE__),
                            TEXT("Couldn't format the value of %s into ")
                            TEXT("displayable text. The value cannot be ")
                            TEXT(" viewed/modified."),
                            pPropInfo->lpszProperty );

                EndDialog( hwndDlg, 0 );
             }

             lpszValue = BstrToString( V_BSTR(&vaTemp),
                                       -1 );

             if ( lpszValue ) {
                SetWindowText( GetDlgItem(hwndDlg,
                                          IDE_PROPERTY_VALUE),
                               lpszValue );

                SysFreeString( (BSTR)lpszValue );
             }
             else {
                PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                            __LINE__,
                            TEXT(__FILE__),
                            TEXT("Cannot show the value of %s."),
                            pPropInfo->lpszProperty );

                EndDialog( hwndDlg, 0 );
             }
             
             VariantClear( &vaTemp );
          }

          return TRUE; // Tell Windows to continue creating the dialog box.

     case WM_COMMAND:

          switch( LOWORD(wParam) ) {

             case IDB_MODIFY:
                  
                  if ( HIWORD(wParam) == BN_CLICKED ) {

                     //
                     // User wants to update the instance after modifying the
                     // property value.
                     //

                     if ( ModifyProperty(hwndDlg) ) {

                        EndDialog( hwndDlg, 0 );
                     }
                  }

                  break;

             case IDB_CANCEL:
                  
                  if ( HIWORD(wParam) == BN_CLICKED ) {

                     EndDialog( hwndDlg, 0 );
                  }

                  break;
          }

          break;

     case WM_SYSCOMMAND:

             if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                EndDialog( hwndDlg, 0 );
             }
  }

  return FALSE;
}

//
// Windows procedure to view/modify array properties.
//

INT_PTR CALLBACK DlgProcArray (HWND hwndDlg,
                               UINT uMsg,
                               WPARAM wParam,
                               LPARAM lParam)
{
  LPPROPERTY_INFO  pPropInfo;

  switch (uMsg) {

     case WM_INITDIALOG:

          //
          // lParam points to PROPERTY_INFO structure which contains information
          // the property whose valuse is to be viewed/modified. We store this
          // pointer at DWLP_USER offset, so we get to it later.
          //

          SetWindowLongPtr( hwndDlg,
                            DWLP_USER,
                            (LONG_PTR)lParam );

          pPropInfo = (LPPROPERTY_INFO)lParam;

          //
          // Property name is the title of the dialog box.
          //

          SetWindowText( hwndDlg,
                         pPropInfo->lpszProperty );

          //
          // Show the property type.
          //

          SetWindowText( GetDlgItem(hwndDlg,
                                    IDS_PROPERTY_TYPE),
                         pPropInfo->lpszType );

          if ( DisplayArrayProperty(pPropInfo->lpszProperty,
                                    pPropInfo->pvaValue,
                                    hwndDlg) ) {
             return TRUE;
          }

          EndDialog( hwndDlg, 0 );


     case WM_COMMAND:

          switch( LOWORD(wParam) ) {

             case IDB_MODIFY:
                  
                  if ( HIWORD(wParam) == BN_CLICKED ) {

                     //
                     // User wants to update the instance after modifying the
                     // property value.
                     //

                     pPropInfo = (LPPROPERTY_INFO)GetWindowLongPtr( hwndDlg,
                                                                    DWLP_USER );
                     ModifyArrayProperty( hwndDlg,
                                          pPropInfo );

                     EndDialog( hwndDlg, 0 );
                  }

                  break;

             case IDB_CANCEL:
                  
                  if ( HIWORD(wParam) == BN_CLICKED ) {

                     EndDialog( hwndDlg, 0 );
                  }

                  break;
          }

          break;

     case WM_SYSCOMMAND:

             if ( (0xFFF0 & wParam) == SC_CLOSE ) {

                EndDialog( hwndDlg, 0 );
             }
  }

  return FALSE;
}

//
// The function populates the combo box of the main window with the classes
// defined in the lpszClasses array, selects the first class of the combo box,
// shows its instances, and properties of the first instance.
//

VOID ListDefaults (HWND hwndDlg)
{
  HWND  hwndClassList;
  UINT  i;

  hwndClassList = GetDlgItem( hwndDlg,
                              IDL_CLASSES );
  //
  // Add the default classes to the combo box.
  //

  for (i=0; i < sizeof(lpszClasses)/sizeof(LPTSTR); ++i) {

     SendMessage( hwndClassList,
                  CB_ADDSTRING,
                  0,
                  (LPARAM)lpszClasses[i] );
  }

  //
  // By default, select the first one in the list which maybe different from
  // the first element in the lpszClasses array since the list is sorted.
  //

  SendMessage( hwndClassList,
               CB_SETCURSEL,
               0,
               0 );

  //
  // Show the instances and properties of the first instance.
  //

  RefreshOnClassSelection( hwndDlg );

  return;
}

//
// The function lists all the properties of the class instance selected by the
// user.
//

VOID ShowProperties (HWND hwndDlg,
                     HWND hwndInstTree)
{
  IWbemServices *pIWbemServices;
  LPTSTR        lpszInstance;
  LPTSTR        lpszClass;


  lpszClass = GetSelectedClass( GetDlgItem(hwndDlg,
                                           IDL_CLASSES) );

  lpszInstance = GetSelectedItem( hwndInstTree );

  if ( lpszInstance && lpszClass ) {

     pIWbemServices = (IWbemServices *)GetWindowLongPtr(
                                              hwndDlg,
                                              DWLP_USER );
     //
     // Show properties of the selected instance.
     //

     TreeView_DeleteAllItems( GetDlgItem(hwndDlg,
                                         IDT_PROPERTIES) );
     EnumProperties( pIWbemServices,
                     lpszClass,
                     lpszInstance,
                     GetDlgItem(hwndDlg,
                                IDT_PROPERTIES) );

  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Properties of the selected ")
                 TEXT("instance will not be listed.") );
  }

  if ( lpszClass ) {
     SysFreeString( (BSTR)lpszClass );
  }

  if ( lpszInstance ) {
     SysFreeString( (BSTR)lpszInstance );
  }

  return;
}

//
// The function shows a dialog box displaying the value of the selected property
// and allows the user to modify it.
//

VOID EditProperty (HWND hwndDlg,
                   HWND hwndPropTree)
{
  PROPERTY_INFO    propertyInfo;
  LPTSTR           lpszInstance;
  LPTSTR           lpszClass;
  VARIANT          vaValue;

  //
  // Get the selected class name.
  //

  lpszClass = GetSelectedClass( GetDlgItem(hwndDlg,
                                           IDL_CLASSES) );

  //
  // Get the selected instance name which is __RELPATH value.
  //

  lpszInstance = GetSelectedItem( GetDlgItem(hwndDlg,
                                             IDT_INSTANCES) );

  //
  // Get the selected property name.
  //

  propertyInfo.lpszProperty = GetSelectedItem( hwndPropTree );

  if ( lpszInstance && lpszClass && propertyInfo.lpszProperty ) {

     propertyInfo.pIWbemServices = (IWbemServices *)GetWindowLongPtr(
                                                             hwndDlg,
                                                             DWLP_USER );

     propertyInfo.pInstance = GetInstanceReference( propertyInfo.pIWbemServices,
                                                    lpszClass,
                                                    lpszInstance );

     if ( propertyInfo.pInstance ) {

        if ( GetPropertyValue( propertyInfo.pInstance,
                               propertyInfo.lpszProperty,
                               &vaValue,
                               &propertyInfo.lpszType) ) {

           propertyInfo.pvaValue = &vaValue;

           if ( V_ISARRAY(&vaValue) ) {

              DialogBoxParam( hInstance,
                              MAKEINTRESOURCE(IDD_ARRAY_PROPERTY),
                              hwndDlg,
                              DlgProcArray,
                              (LPARAM)&propertyInfo );
           }
           else {

              DialogBoxParam( hInstance,
                              MAKEINTRESOURCE(IDD_SCALAR_PROPERTY),
                              hwndDlg,
                              DlgProcScalar,
                              (LPARAM)&propertyInfo );
           }

           VariantClear( &vaValue );
           SysFreeString( (BSTR)propertyInfo.lpszType );
        }
        else {
           PrintError( HRESULT_FROM_WIN32(ERROR_WMI_TRY_AGAIN),
                       __LINE__,
                       TEXT(__FILE__),
                       TEXT("Couldn't read %s."),
                       propertyInfo.lpszProperty );
        }

        propertyInfo.pInstance->Release();
     }
     else {
        PrintError( HRESULT_FROM_WIN32(ERROR_WMI_INSTANCE_NOT_FOUND),
                    __LINE__,
                    TEXT(__FILE__),
                    TEXT("Couldn't get a pointer to %s."),
                    lpszInstance );
     }

  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Properties of the selected ")
                 TEXT("instance will not be listed.") );
  }

  if ( lpszClass ) {
     SysFreeString( (BSTR)lpszClass );
  }

  if ( lpszInstance ) {
     SysFreeString( (BSTR)lpszInstance );
  }

  if ( propertyInfo.lpszProperty ) {
     SysFreeString( (BSTR)propertyInfo.lpszProperty );
  }

  return;
}

//
// The function updates the property that is modified a the user.
//

BOOL ModifyProperty (HWND hwndDlg)
{
  LPPROPERTY_INFO pPropInfo;
  HWND            hwndValue;
  VARIANT         vaTemp;
  VARIANT         vaNewValue;
  LPTSTR          lpszValue;
  ULONG           ulLen;
  HRESULT         hr;


  hr = S_FALSE;

  pPropInfo = (LPPROPERTY_INFO)GetWindowLongPtr( hwndDlg,
                                                 DWLP_USER );

  //
  // Allocate memory and get new value of the property.
  //

  hwndValue = GetDlgItem( hwndDlg,
                          IDE_PROPERTY_VALUE );

  ulLen = (ULONG)SendMessage( hwndValue,
                              WM_GETTEXTLENGTH,
                              0,
                              0 );
  if ( ulLen > 0 ) {

     lpszValue = (LPTSTR)SysAllocStringLen( NULL,
                                    ulLen+1 );

     if ( lpszValue ) {

        SendMessage( hwndValue,
                     WM_GETTEXT,
                     ulLen+1,
                     (LPARAM)lpszValue );


        VariantInit( &vaTemp );

        //
        // Change the new value from string to its original type.
        //

        V_VT(&vaTemp) = VT_BSTR;
        V_BSTR(&vaTemp) = StringToBstr( lpszValue,
                                          -1 );
        if ( V_BSTR(&vaTemp) == NULL ) {
           PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                       __LINE__,
                       TEXT(__FILE__),
                       TEXT("Couldn't modify the value of %s."),
                       pPropInfo->lpszProperty );
        }
        else {
           VariantInit( &vaNewValue );

           hr = VariantChangeType( &vaNewValue,
                                   &vaTemp,
                                   VARIANT_LOCALBOOL,
                                   V_VT(pPropInfo->pvaValue) );

           if ( hr == S_OK ) {

              //
              // Update the property and its instance.
              //

              hr = UpdatePropertyValue( pPropInfo->pIWbemServices,
                                        pPropInfo->pInstance,
                                        pPropInfo->lpszProperty,
                                        &vaNewValue );

              if ( hr == WBEM_S_NO_ERROR ) {

                 PrintError(  0,
                              __LINE__,
                              TEXT(__FILE__),
                              TEXT("%s is successfully updated with value %s."),
                              pPropInfo->lpszProperty,
                              lpszValue );
              }

              VariantClear( &vaNewValue );
           }
           else {
              PrintError( hr,
                          __LINE__,
                          TEXT(__FILE__),
                          TEXT("Couldn't convert the specified value '%s' of ")
                          TEXT("property %s into %s type."),
                          lpszValue,
                          pPropInfo->lpszProperty,
                          pPropInfo->lpszType );
           }

           SysFreeString( V_BSTR(&vaTemp) );
        }

        SysFreeString( (BSTR)lpszValue );
     }
     else {
        PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                    __LINE__,
                    TEXT(__FILE__),
                    TEXT("Couldn't modify the value of %s."),
                    pPropInfo->lpszProperty );
     }
  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_WMI_TRY_AGAIN),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("You must specify a value to modify %s."),
                 pPropInfo->lpszProperty );
  }
  
  return hr == WBEM_S_NO_ERROR;
}

//
// The function populates a tree list with the values of a property of array
// type. The property could be an array of string or integer.
//

BOOL DisplayArrayProperty (LPTSTR lpszProperty,
                           VARIANT *pvaValue,
                           HWND hwndDlg)
{
  SAFEARRAY   *psaValue;
  VARIANT     vaTemp;
  VARIANT     vaElement;
  VARTYPE     vt;
  long        lLBound;
  long        lUBound;
  long        i;
  UINT        uiSize;
  BSTR        lpsz;
  LPVOID      pv;
  HRESULT     hr;

  //
  // Make a copy of the property value.
  //

  psaValue = NULL;
  hr = SafeArrayCopy( V_ARRAY(pvaValue),
                      &psaValue );

  if ( hr == S_OK ) {
     hr = SafeArrayGetVartype( psaValue,
                               &vt );
  }

  if ( hr == S_OK ) {
     hr = SafeArrayGetLBound( psaValue,
                              1,
                              &lLBound );
  }
  
  if ( hr == S_OK ) {
     hr = SafeArrayGetUBound( psaValue,
                              1,
                              &lUBound );
  }

  if ( hr == S_OK ) {
     uiSize = SafeArrayGetElemsize( psaValue );
  }

  if ( hr == S_OK ) {
     hr = SafeArrayAccessData( psaValue,
                               &pv );
  }

  if ( hr == S_OK ) {

     lpsz = (BSTR)pv;

     //
     // Change each element into string.
     //

     for (i=0; (hr == S_OK) && (i < (lUBound-lLBound+1)); ++i) {

        VariantInit( &vaElement );
        V_VT(&vaElement) = VT_BYREF | vt;
        V_BYREF(&vaElement) = (LPVOID)lpsz;

        VariantInit( &vaTemp );

        hr = VariantChangeType( &vaTemp,
                                &vaElement,
                                VARIANT_LOCALBOOL,
                                VT_BSTR );

        if ( hr == S_OK ) {

           hr = AddToList( hwndDlg,
                           &vaTemp );

           VariantClear( &vaTemp );
        }
        else {
           PrintError( hr,
                       __LINE__,
                       TEXT(__FILE__),
                       TEXT("Couldn't format the value of %s into ")
                       TEXT("displayable text. The value cannot be ")
                       TEXT(" viewed/modified."),
                       lpszProperty );
        }

        lpsz = (BSTR)((LONG_PTR)lpsz + uiSize);
     }

     SafeArrayUnaccessData( psaValue );
  }
  else {
     PrintError( hr,
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Couldn't read the values of %s."),
                 lpszProperty );
  }

  if ( psaValue ) {
     SafeArrayDestroy( psaValue );
  }

  return hr == S_OK;
}

//
// The function add a property value to the tree list.
//

HRESULT AddToList (HWND hwndDlg,
                  VARIANT *pvaValue)
{
  TV_INSERTSTRUCT tvInsertStruc;
  
  ZeroMemory(
        &tvInsertStruc,
        sizeof(TV_INSERTSTRUCT) );

  tvInsertStruc.hParent = TVI_ROOT;

  tvInsertStruc.hInsertAfter = TVI_LAST;

  tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM;

  tvInsertStruc.item.pszText = BstrToString( V_BSTR(pvaValue),
                                             -1 );

  if ( tvInsertStruc.item.pszText ) {
     tvInsertStruc.item.cchTextMax = _tcslen( tvInsertStruc.item.pszText ) +
                                     sizeof(TCHAR);

     tvInsertStruc.item.lParam = (LPARAM)tvInsertStruc.item.cchTextMax;

     TreeView_InsertItem( GetDlgItem(hwndDlg,
                                     IDT_PROPERTY_VALUE),
                          &tvInsertStruc );

     SysFreeString( (BSTR)tvInsertStruc.item.pszText );
  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Cannot show the values of the property.") );

     return S_FALSE;
  }

  return S_OK;
}


VOID ModifyArrayProperty(HWND hwndDlg,
                         LPPROPERTY_INFO pPropInfo)
{
  MessageBox( hwndDlg,
              TEXT("This feature is currently not implemented."),
              TEXT("Modify Array"),
              MB_ICONINFORMATION | MB_OK );

  return;
}



//
// The function lists the instances of the selected class and properties of
// the first instance.
//

VOID RefreshOnClassSelection (HWND hwndDlg)
{
  IWbemServices *pIWbemServices;
  HWND           hwndClassList;
  HWND           hwndInstTree;
  HWND           hwndPropTree;
  LPTSTR         lpszClass;
  LPTSTR         lpszInstance;
  HTREEITEM      hItem;

  pIWbemServices = (IWbemServices *)GetWindowLongPtr( hwndDlg,
                                                      DWLP_USER );
  //
  // Find the selected class.
  //
  //

  hwndClassList = GetDlgItem( hwndDlg,
                              IDL_CLASSES );

  hwndInstTree = GetDlgItem( hwndDlg,
                             IDT_INSTANCES );

  hwndPropTree = GetDlgItem( hwndDlg,
                             IDT_PROPERTIES );

  TreeView_DeleteAllItems( hwndInstTree );
  TreeView_DeleteAllItems( hwndPropTree );

  lpszClass = GetSelectedClass( hwndClassList );

  if ( lpszClass ) {

     //
     // List all the instances of the selected class.
     //

     EnumInstances( pIWbemServices,
                    lpszClass,
                    hwndInstTree );    // Tree to populate.

     //
     // By default, first instance is selected and its properties
     // are shown.
     //

     hItem = TreeView_GetChild( hwndInstTree,
                                TVI_ROOT );

     //
     // hItem == NULL ==> No instances found.
     //

     if ( hItem ) {

        //
        // Select the first instance.
        //

        TreeView_SelectItem( hwndInstTree,
                             hItem );

        //
        // Find the selected instance.
        //

        lpszInstance = GetSelectedItem( hwndInstTree );

        if ( lpszInstance ) {

           //
           // Show properties of the selected instance.
           //

           EnumProperties( pIWbemServices,
                           lpszClass,
                           lpszInstance,
                           hwndPropTree );  // Tree to populate.

           SysFreeString( (BSTR)lpszInstance );
        }
        else {
           PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                       __LINE__,
                       TEXT(__FILE__),
                       TEXT("Properties of the selected ")
                       TEXT("instance will not be listed.") );
        }
     }

     SysFreeString( (BSTR)lpszClass );
  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Instances of the selected ")
                 TEXT("class will not be listed.") );
  }

  return;
}

//
// Given a handle to a combo box, the function returns the name of the
// selected item i.e. class.
//

LPTSTR GetSelectedClass (HWND hwndClassList)
{
  LPTSTR    lpszClass;
  ULONG     ulIndex;
  ULONG     ulLen;

  lpszClass = NULL;

  //
  // Find the selected class.
  //

  ulIndex = (ULONG)SendMessage( hwndClassList,
                                CB_GETCURSEL,
                                0,
                                0 );

  //
  // Find the length of the selected class name.
  //

  ulLen = (ULONG)SendMessage( hwndClassList,
                              CB_GETLBTEXTLEN,
                              (WPARAM)ulIndex,
                              0 );

  lpszClass = (LPTSTR)SysAllocStringLen( NULL,
                                 ulLen + 1 );

  if ( lpszClass ) {
     SendMessage( hwndClassList,
                  CB_GETLBTEXT,
                  (WPARAM)ulIndex,
                  (LPARAM)lpszClass );
  }

  return lpszClass;
}

//
// Given a handle to the tree list, the function returns the name of the
// selected item.
//

LPTSTR GetSelectedItem (HWND hwndTree)
{
  LPTSTR    lpszItem;
  HTREEITEM hItem;
  TVITEM    tvItem;

  lpszItem = NULL;

  //
  // Find the selected item.
  //

  hItem = TreeView_GetSelection( hwndTree );

  if ( hItem ) {

     //
     // Find out the length of the selected item and allocate memory.
     //

     ZeroMemory( &tvItem,
                 sizeof(TVITEM) );

     tvItem.hItem = hItem;
     tvItem.mask = TVIF_PARAM;

     TreeView_GetItem( hwndTree,
                       &tvItem );

     
     lpszItem = (LPTSTR)SysAllocStringLen( NULL,
                                           (UINT)tvItem.lParam );

     if ( lpszItem ) {

         tvItem.hItem = hItem;
        tvItem.mask = TVIF_TEXT;
        tvItem.pszText = lpszItem;
        tvItem.cchTextMax = (INT)tvItem.lParam;

        TreeView_GetItem( hwndTree,
                          &tvItem );
     }
  }

  return lpszItem;
}

//
// The function inserts an item into a tree list.
//

VOID InsertItem (HWND hwndTree,
                 LPTSTR lpszItem)
{
  TVINSERTSTRUCT  tvInsertStruc;

  ZeroMemory(
        &tvInsertStruc,
        sizeof(TVINSERTSTRUCT) );

  tvInsertStruc.hParent = TVI_ROOT;

  tvInsertStruc.hInsertAfter = TVI_LAST;

  tvInsertStruc.item.mask = TVIF_TEXT | TVIF_PARAM;

  tvInsertStruc.item.pszText = lpszItem;

  tvInsertStruc.item.cchTextMax = _tcslen(lpszItem) + 1;

  tvInsertStruc.item.lParam = tvInsertStruc.item.cchTextMax;

  TreeView_InsertItem( hwndTree,
                       &tvInsertStruc );

  return;
}

VOID PrintError (HRESULT hr,
                 UINT    uiLine,
                 LPTSTR  lpszFile,
                 LPCTSTR  lpFmt,
                 ...)
{

  LPTSTR   lpSysMsg;
  TCHAR    buf[400];
  ULONG    offset;
  va_list  vArgList; 


  if ( hr != 0 ) {
     _stprintf( buf,
               TEXT("Error %#lx (%s, %d): "),
               hr,
               lpszFile,
               uiLine );
  }
  else {
     _stprintf( buf,
               TEXT("(%s, %d): "),
               lpszFile,
               uiLine );
  }

  offset = _tcslen( buf );
  
  va_start( vArgList,
            lpFmt );
  _vstprintf( buf+offset,
              lpFmt,
              vArgList );

  va_end( vArgList );

  if ( hr != 0 ) {
     FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR)&lpSysMsg,
                    0,
                    NULL );
     if ( lpSysMsg ) {

        offset = _tcslen( buf );

        _stprintf( buf+offset,
                   TEXT("\n\nPossible cause:\n\n") );

        offset = _tcslen( buf );

        _tcscat( buf+offset,
                 lpSysMsg );

        LocalFree( (HLOCAL)lpSysMsg );
     }

     MessageBox( NULL,
                 buf,
                 TEXT("TestWMI"),
                 MB_ICONERROR | MB_OK );
  }
  else {
     MessageBox( NULL,
                 buf,
                 TEXT("TestWMI"),
                 MB_ICONINFORMATION | MB_OK );
  }

  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\e100bex\testwmi\wmicode.cpp ===
#include "testwmi.h"

//
// The function connects to the namespace.
//

IWbemServices *ConnectToNamespace (VOID)
{
  IWbemServices *pIWbemServices = NULL;
  IWbemLocator *pIWbemLocator = NULL;
  HRESULT      hr;


  //
  // Create an instance of WbemLocator interface.
  //

  hr = CoCreateInstance( CLSID_WbemLocator,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_IWbemLocator,
                         (LPVOID *)&pIWbemLocator );
  if ( hr == S_OK ) {

     //
     // Using the locator, connect to COM in the given namespace.
     //

     hr = pIWbemLocator->ConnectServer( DEFAULT_NAMESPACE,
                                        NULL,   // current account.
                                        NULL,   // current password.
                                        0L,     // locale
                                        0L,     // securityFlags
                                        NULL,   // domain for NTLM
                                        NULL,   // context
                                        &pIWbemServices );

     if ( hr == WBEM_S_NO_ERROR) {
         
        //
        // Switch the security level to IMPERSONATE so that provider(s)
        // will grant access to system-level objects, and so that
        // CALL authorization will be used.
        //

        hr = CoSetProxyBlanket( (IUnknown *)pIWbemServices, // proxy
                                RPC_C_AUTHN_WINNT,  // authentication service
                                RPC_C_AUTHZ_NONE,   // authorization service
                                NULL,               // server principle name
                                RPC_C_AUTHN_LEVEL_CALL, // authentication level
                                RPC_C_IMP_LEVEL_IMPERSONATE, // impersonation
                                NULL,            // identity of the client
                                EOAC_NONE );  // capability flags

        if ( hr != S_OK ) {

           pIWbemServices->Release();
           pIWbemServices  = NULL;

           PrintError( hr,
                     __LINE__,
                     TEXT(__FILE__),
                     TEXT("Couldn't impersonate, program exiting...") );
        }
     }
     else {
        PrintError( hr,
                  __LINE__,
                  TEXT(__FILE__),
                  TEXT("Couldn't connect to root\\wmi, program exiting...") );
     }

     //
     // Done with IWbemLocator.
     //

     pIWbemLocator->Release();
  }
  else {
     PrintError( hr,
               __LINE__,
               TEXT(__FILE__),
               TEXT("Couldn't create an instance of ")
               TEXT("IWbemLocator interface, programm exiting...") );
  }

  return pIWbemServices;
}

//
// Given a class name, the function populates the combo box with all
// the instances of the class.
//

VOID EnumInstances (IWbemServices *pIWbemServices,
                    LPTSTR        lpszClass,
                    HWND          hwndInstTree)
{
  IEnumWbemClassObject *pEnumInst;
  IWbemClassObject     *pInst;
  VARIANT              varInstanceName;
  BSTR                 bstrClass;
  LPTSTR               lpszInstance;
  ULONG                ulFound;
  HRESULT              hr;


  bstrClass = StringToBstr( lpszClass,
                            -1 );
  if ( !bstrClass ) {

     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
               __LINE__,
               TEXT(__FILE__),
               TEXT("Not enough memory to enumerate instances of %s"),
                    lpszClass );

     return;
  }

  hr = pIWbemServices->CreateInstanceEnum(
                  bstrClass,              // Name of the root class.
                  WBEM_FLAG_SHALLOW |     // Enumerate at current root only.
                  WBEM_FLAG_FORWARD_ONLY, // Forward-only enumeration.
                  NULL,                   // Context.
                  &pEnumInst );          // pointer to class enumerator

  if ( hr == WBEM_S_NO_ERROR ) {

     //
     // Begin enumerating instances.
     //

     ulFound = 0;

     hr = pEnumInst->Next( 2000,      // two seconds timeout
                           1,         // return just one instance.
                           &pInst,    // pointer to instance.
                           &ulFound); // Number of instances returned.
     
     while ( (hr == WBEM_S_NO_ERROR) && (ulFound == 1) ) {

        VariantInit( &varInstanceName );

        //
        // Get the instance name stored in __RELPATH property.
        //

        hr = pInst->Get( L"__RELPATH", // property name 
                         0L,                // Reserved, must be zero.
                         &varInstanceName,  // property value returned.
                         NULL,              // CIM type not needed.
                         NULL );            // Flavor not needed.

        if ( hr == WBEM_S_NO_ERROR ) {

           lpszInstance = BstrToString( V_BSTR(&varInstanceName),
                                        -1 );
           if ( lpszInstance ) {

              InsertItem( hwndInstTree,
                          lpszInstance );

               SysFreeString( (BSTR)lpszInstance );
           }
           else {
              hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

              PrintError( hr,
                          __LINE__,
                          TEXT(__FILE__),
                          TEXT("Out of memory while enumerating instaces of")
                          TEXT(" %s, no more instances will")
                          TEXT(" be listed."),
                          lpszClass );
           }

           VariantClear( &varInstanceName );
        }
        else {
           PrintError( hr,
                     __LINE__,
                     TEXT(__FILE__),
                     TEXT("Couldn't retrieve __RELPATH of an instance")
                     TEXT(" of %s, no more instances will be listed."),
                     lpszClass );
        }

        //
        // Done with this instance.
        //

        pInst->Release();

        if ( hr == WBEM_S_NO_ERROR ) {

           hr = pEnumInst->Next( 2000,       // two seconds timeout.
                                 1,          // return just one class.
                                 &pInst,     // pointer to returned class.
                                 &ulFound);  // Number of classes returned.
        }
     }
 
     pEnumInst->Release();

  }
  else {
     PrintError( hr,
               __LINE__,
               TEXT(__FILE__),
               TEXT("Couldn't create an instance of ")
               TEXT("IEnumWbemClassObject interface, instances of %s ")
               TEXT("will not be listed."),
               lpszClass );
  }

  SysFreeString( bstrClass );

  return;
}

//
// Given a class name and __RELPATH of an instance, the function lists all the
// local non-system properties in a tree list.
//

VOID EnumProperties (IWbemServices *pIWbemServices,
                     LPTSTR        lpszClass,
                     LPTSTR        lpszInstance,
                     HWND          hwndPropTree)
{
  IWbemClassObject  *pInst;
  SAFEARRAY         *psaPropNames;
  BSTR              bstrProperty;
  long              lLower;
  long              lUpper;
  long              i;
  HRESULT           hr;
  LPTSTR            lpszProperty;

  //
  // Get a pointer to the instance.
  //

  pInst = GetInstanceReference( pIWbemServices,
                                lpszClass,
                                lpszInstance );

  if ( pInst ) {

     //
     // psaPropNames must be null prior to making the call.
     //

     psaPropNames = NULL;

     //
     // Get all the properties.
     //

     hr = pInst->GetNames( NULL,              // No qualifier names.
                           WBEM_FLAG_ALWAYS | // All non-system properties
                           WBEM_FLAG_LOCAL_ONLY, 
                           NULL,             // No qualifier values.
                           &psaPropNames);   // Returned property names

     if ( hr == WBEM_S_NO_ERROR ) {

        //
        // Get the number of properties returned.
        //

        SafeArrayGetLBound( psaPropNames, 1, &lLower );
        SafeArrayGetUBound( psaPropNames, 1, &lUpper );

        //
        // List all properties or stop when encountered an error.
        //

        for (i=lLower; (hr == WBEM_S_NO_ERROR) && (i <= lUpper); i++) {

           //
           // Add the property name into the list box.
           //

           bstrProperty = NULL;

           hr = SafeArrayGetElement( psaPropNames,
                                     &i,
                                     &bstrProperty);

           if ( SUCCEEDED(hr) ) {

               lpszProperty = BstrToString( bstrProperty,
                                          -1 );

               if ( lpszProperty ) {

                  InsertItem( hwndPropTree,
                              lpszProperty );

                  SysFreeString( (BSTR)lpszProperty );
               }
               else {
                  PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                            __LINE__,
                            TEXT(__FILE__),
                            TEXT("Out of memory while enumerating")
                            TEXT(" properties of %s, no more properties")
                            TEXT(" will be listed"),
                            lpszInstance );
               }

              //
              // Done with the property name.
              //

              SysFreeString( bstrProperty );
           }
           else {
              PrintError( hr,
                          __LINE__,
                          TEXT(__FILE__),
                          TEXT("Couldn't get the name of a property(%d). ")
                          TEXT("No more properties will be listed."),
                          i );
           }
        }

        //
        // Done with the array of properties.
        //

        SafeArrayDestroy( psaPropNames );
     }
     else {
        PrintError( hr,
                    __LINE__,
                    TEXT(__FILE__),
                    TEXT("Couldn't retrieve the properties of %s, ")
                    TEXT("an instance of class %s. Properties will not be ")
                    TEXT("listed."),
                    lpszInstance, lpszClass );
     }

  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_WMI_INSTANCE_NOT_FOUND),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Couldn't retrieve a pointer to instance %s of class %s.")
                 TEXT("Its properties will not be listed."),
                 lpszInstance, lpszClass );
  }

  return;
}

//
// Given a class name and __RELPATH of an instance, the function returns a
// pointer to the instance.
//

IWbemClassObject *GetInstanceReference (IWbemServices *pIWbemServices,
                                        LPTSTR        lpszClass,
                                        LPTSTR        lpszInstance)
{
  IWbemClassObject     *pInst;
  IEnumWbemClassObject *pEnumInst;
  ULONG                ulCount;
  BSTR                 bstrClass;
  BOOL                 bFound;
  HRESULT              hr;
  

  hr = 0;

  bstrClass = StringToBstr( lpszClass,
                            -1 );
  if ( !bstrClass ) {

     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
               __LINE__,
               TEXT(__FILE__),
               TEXT("Not enough memory to get a pointer to %s."),
               lpszInstance );

     return NULL;
  }

  //
  // pInst pointer must be NULL initially,
  //

  pInst = NULL;

  // 
  // Get Instance Enumerator Interface.
  //

  pEnumInst = NULL;

  hr = pIWbemServices->CreateInstanceEnum(bstrClass,
                                          WBEM_FLAG_SHALLOW | 
                                          WBEM_FLAG_FORWARD_ONLY,
                                          NULL,         
                                          &pEnumInst );

  if ( hr == WBEM_S_NO_ERROR ) {

     //
     // Get a pointer to the instance.
     //
     // We enumerate all the instances and compare their __RELPATH with
     // the specified __RELPATH. If we find a match then, that is the one
     // we are looking for.
     //
     // The other more efficient way is to create a WQL query and execute
     // it.
     //

     hr = WBEM_S_NO_ERROR;
     bFound = FALSE;

     while ( (hr == WBEM_S_NO_ERROR) && (bFound == FALSE) ) {

        hr = pEnumInst->Next( 2000,      // two seconds timeout
                              1,         // return just one instance.
                              &pInst,    // pointer to instance.
                              &ulCount); // Number of instances returned.

        if ( ulCount > 0 ) {

           bFound = IsInstance( pInst,
                                lpszInstance );

           if ( bFound == FALSE ) {
              pInst->Release();
           }
        }
     }

     if ( bFound == FALSE )
        pInst = NULL;

     //
     // Done with the instance enumerator.
     //

     pEnumInst->Release();
  }

  SysFreeString( bstrClass );
  return pInst;
}

//
// Given a pointer, the function returns TRUE if the pointer points to
// the instance specified by lpszInstance.
//

BOOL IsInstance (IWbemClassObject *pInst,
                 LPTSTR           lpszInstance)
{
  VARIANT              varPropVal;
  LPTSTR               lpInstance;
  BOOL                 bRet;

  bRet = GetPropertyValue( pInst,
                           TEXT("__RELPATH"),
                           &varPropVal,
                           NULL );

  if ( bRet == TRUE ) {

     lpInstance = BstrToString( V_BSTR(&varPropVal),
                                       -1 );
     if ( !lpInstance ) {

        PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                  __LINE__,
                  TEXT(__FILE__),
                  TEXT("Not enough memory to search for an instance.") );

        bRet = FALSE;
     }
     else {
        bRet = _tcsicmp( lpszInstance, lpInstance ) == 0;

        SysFreeString( (BSTR)lpInstance );
     }

     VariantClear( &varPropVal );
  }

  return bRet;
}


//
// The function returns property value and its type of a given class/instance.
//

BOOL GetPropertyValue (IWbemClassObject *pRef,
                       LPTSTR           lpszProperty, 
                       VARIANT          *pvaPropertyValue,
                       LPTSTR           *lppszPropertyType)
{
  IWbemQualifierSet *pQual;
  VARIANT           vaQual;
  BSTR              bstrProperty;
  HRESULT           hr;
  BOOL              bRet;


  //
  // Get the property value.
  //

  bstrProperty = StringToBstr( lpszProperty,
                               -1 );

  if ( !bstrProperty ) {

     return FALSE;

  }

  bRet = FALSE;

  if ( lppszPropertyType ) {

     //
     // Get the textual name of the property type.
     //

     hr = pRef->GetPropertyQualifierSet( bstrProperty,
                                         &pQual );

     if ( hr == WBEM_S_NO_ERROR ) {

        //
        // Get the textual name of the property type.
        //

        hr = pQual->Get( L"CIMTYPE",
                         0,
                         &vaQual,
                         NULL );

        if ( hr == WBEM_S_NO_ERROR ) {
           *lppszPropertyType = BstrToString( V_BSTR(&vaQual),
                                              -1 );

           VariantClear( &vaQual );
        }

        pQual->Release();
     }
  }

  VariantInit( pvaPropertyValue );

  hr = pRef->Get( bstrProperty,
                  0,
                  pvaPropertyValue,
                  NULL,
                  NULL );

  if ( hr == WBEM_S_NO_ERROR ) {
     bRet = TRUE;
  }
  else {
     if ( lppszPropertyType && *lppszPropertyType ) {
        SysFreeString( (BSTR)*lppszPropertyType );
     }
  }

  SysFreeString( bstrProperty );
  return bRet;
}

//
// Given a pointer to an instance, its property and and variant specifying
// the value for the property, the function updates the property and the
// instance.
//

HRESULT UpdatePropertyValue (IWbemServices *pIWbemServices,
                             IWbemClassObject *pInstance,
                             LPTSTR lpszProperty,
                             LPVARIANT pvaNewValue)
{
  BSTR           bstrProperty;
  HRESULT hr;


  bstrProperty = StringToBstr( lpszProperty,
                               -1 );

  if ( !bstrProperty ) {

     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Not enough memory to update %s."),
                 lpszProperty );

     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
  }
  
  hr = pInstance->Put( bstrProperty,
                       0,
                       pvaNewValue,
                       0 );

  if ( hr == WBEM_S_NO_ERROR ) {
     hr = pIWbemServices->PutInstance( pInstance,
                                       WBEM_FLAG_UPDATE_ONLY,
                                       NULL,
                                       NULL );

     if ( hr != WBEM_S_NO_ERROR ) {
        PrintError(  hr,
                     __LINE__,
                     TEXT(__FILE__),
                     TEXT("Failed to save the instance,")
                     TEXT(" %s will not be updated."),
                     lpszProperty );
     }
  }
  else {
     PrintError(  hr,
                  __LINE__,
                  TEXT(__FILE__),
                  TEXT("Couldn't update %s."),
                  lpszProperty );
  }

  SysFreeString( bstrProperty );

  return hr;
}

BSTR StringToBstr (LPTSTR lpSrc,
                  int nLenSrc)
{
  BSTR lpDest;

  //
  // In case of ANSI version, we need to change the ANSI string to UNICODE since
  // BSTRs are essentially UNICODE strings.
  //

  #if !defined(UNICODE) || !defined(_UNICODE)

     int  nLenDest;

     nLenDest = MultiByteToWideChar( CP_ACP, 0, lpSrc, nLenSrc, NULL, 0);

     lpDest = SysAllocStringLen( NULL, nLenDest );

     if ( lpDest ) {
        MultiByteToWideChar( CP_ACP, 0, lpSrc, nLenSrc, lpDest, nLenDest );
     }

  //
  // In case of UNICODE version, we simply allocate memory and copy the string.
  //

  #else
     if ( lpSrc == NULL ) {
        nLenSrc = 0;
     }
     else {
        if ( nLenSrc == -1 ) {
           nLenSrc = _tcslen( lpSrc ) + sizeof(TCHAR);
        }
     }

     lpDest = SysAllocStringLen( lpSrc, nLenSrc );
  #endif

  return lpDest;
}

//
// The function converts a BSTR string into ANSI and returns it in an allocated
// memory. The memory must be freed by the caller using SysFreeString()
// function. If nLenSrc is -1, the string is null terminated.
//

LPTSTR BstrToString (BSTR lpSrc,
                    int nLenSrc)
{
  LPTSTR lpDest;

  //
  // In case of ANSI version, we need to change BSTRs which are UNICODE strings
  // into ANSI version.
  //

  #if !defined(UNICODE) || !defined(_UNICODE)

     int   nLenDest;

     nLenDest = WideCharToMultiByte( CP_ACP, 0, lpSrc, nLenSrc, NULL,
                                     0, NULL, NULL );
     lpDest = (LPTSTR)SysAllocStringLen( NULL, (size_t)nLenDest );

     if ( lpDest ) {
        WideCharToMultiByte( CP_ACP, 0, lpSrc, nLenSrc, lpDest,
                             nLenDest, NULL, NULL );
     }
  //
  // In case of UNICODE version, we simply allocate memory and copy the BSTR
  // into allocate memory and return its address.
  //

  #else
     if ( lpSrc ) {
        if ( nLenSrc == -1 ) {
           nLenSrc = _tcslen( lpSrc ) + sizeof(TCHAR);
        }
     }
     else {
        nLenSrc = 0;
     }

     lpDest = (LPTSTR)SysAllocStringLen( lpSrc, nLenSrc );
  #endif

  return lpDest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\ne2000\keywords.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    keywords.h

Abstract:

    Contains all Ndis2 and Ndis3 mac-specific keywords.

Author:

    Bob Noradki

Environment:

    This driver is expected to work in DOS, OS2 and NT at the equivalent
    of kernal mode.

    Architecturally, there is an assumption in this driver that we are
    on a little endian machine.

Notes:

    optional-notes

Revision History:



--*/

#define IOADDRESS  NDIS_STRING_CONST("IoBaseAddress")
#define INTERRUPT  NDIS_STRING_CONST("InterruptNumber")
#define MAX_MULTICAST_LIST  NDIS_STRING_CONST("MaximumMulticastList")
#define NETWORK_ADDRESS  NDIS_STRING_CONST("NetworkAddress")
#define BUS_TYPE  NDIS_STRING_CONST("BusType")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\ne2000\ne2000.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    ne2000.c

Abstract:

    This is the main file for the Novel 2000 Ethernet controller.
    This driver conforms to the NDIS 3.0 miniport interface.

Author:

    Sean Selitrennikoff (Dec 1993)

Environment:

Revision History:

--*/

#include "precomp.h"


//
// On debug builds tell the compiler to keep the symbols for
// internal functions, otw throw them out.
//
#if DBG
#define STATIC
#else
#define STATIC static
#endif

//
// Debugging definitions
//
#if DBG

//
// Default debug mode
//
ULONG Ne2000DebugFlag = NE2000_DEBUG_LOG;

//
// Debug tracing defintions
//
#define NE2000_LOG_SIZE 256
UCHAR Ne2000LogBuffer[NE2000_LOG_SIZE]={0};
UINT Ne2000LogLoc = 0;

extern
VOID
Ne2000Log(UCHAR c) {

    Ne2000LogBuffer[Ne2000LogLoc++] = c;

    Ne2000LogBuffer[(Ne2000LogLoc + 4) % NE2000_LOG_SIZE] = '\0';

    if (Ne2000LogLoc >= NE2000_LOG_SIZE)
        Ne2000LogLoc = 0;
}

#endif



//
// The global Miniport driver block.
//

DRIVER_BLOCK Ne2000MiniportBlock={0};

//
// List of supported OID for this driver.
//
STATIC UINT Ne2000SupportedOids[] = {
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_ID,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS
    };

//
// Determines whether failing the initial card test will prevent
// the adapter from being registered.
//
#ifdef CARD_TEST

BOOLEAN InitialCardTest = TRUE;

#else  // CARD_TEST

BOOLEAN InitialCardTest = FALSE;

#endif // CARD_TEST

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#pragma NDIS_INIT_FUNCTION(DriverEntry)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the primary initialization routine for the NE2000 driver.
    It is simply responsible for the intializing the wrapper and registering
    the Miniport driver.  It then calls a system and architecture specific
    routine that will initialize and register each adapter.

Arguments:

    DriverObject - Pointer to driver object created by the system.

    RegistryPath - Path to the parameters for this driver in the registry.

Return Value:

    The status of the operation.

--*/

{


    //
    // Receives the status of the NdisMRegisterMiniport operation.
    //
    NDIS_STATUS Status;

    //
    // Characteristics table for this driver.
    //
    NDIS_MINIPORT_CHARACTERISTICS NE2000Char;

    //
    // Pointer to the global information for this driver
    //
    PDRIVER_BLOCK NewDriver = &Ne2000MiniportBlock;

    //
    // Handle for referring to the wrapper about this driver.
    //
    NDIS_HANDLE NdisWrapperHandle;

    //
    // Initialize the wrapper.
    //
    NdisMInitializeWrapper(
                &NdisWrapperHandle,
                DriverObject,
                RegistryPath,
                NULL
                );

    //
    // Save the global information about this driver.
    //
    NewDriver->NdisWrapperHandle = NdisWrapperHandle;
    NewDriver->AdapterQueue = (PNE2000_ADAPTER)NULL;

    //
    // Initialize the Miniport characteristics for the call to
    // NdisMRegisterMiniport.
    //
    NE2000Char.MajorNdisVersion = NE2000_NDIS_MAJOR_VERSION;
    NE2000Char.MinorNdisVersion = NE2000_NDIS_MINOR_VERSION;
    NE2000Char.CheckForHangHandler = NULL;
    NE2000Char.DisableInterruptHandler = Ne2000DisableInterrupt;
    NE2000Char.EnableInterruptHandler = Ne2000EnableInterrupt;
    NE2000Char.HaltHandler = Ne2000Halt;
    NE2000Char.HandleInterruptHandler = Ne2000HandleInterrupt;
    NE2000Char.InitializeHandler = Ne2000Initialize;
    NE2000Char.ISRHandler = Ne2000Isr;
    NE2000Char.QueryInformationHandler = Ne2000QueryInformation;
    NE2000Char.ReconfigureHandler = NULL;
    NE2000Char.ResetHandler = Ne2000Reset;
    NE2000Char.SendHandler = Ne2000Send;
    NE2000Char.SetInformationHandler = Ne2000SetInformation;
    NE2000Char.TransferDataHandler = Ne2000TransferData;

    Status = NdisMRegisterMiniport(
                 NdisWrapperHandle,
                 &NE2000Char,
                 sizeof(NE2000Char)
                 );

    if (Status == NDIS_STATUS_SUCCESS) {

        return STATUS_SUCCESS;

    }

    return STATUS_UNSUCCESSFUL;

}


#pragma NDIS_PAGEABLE_FUNCTION(Ne2000Initialize)
extern
NDIS_STATUS
Ne2000Initialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE ConfigurationHandle
    )

/*++

Routine Description:

    Ne2000Initialize starts an adapter and registers resources with the
    wrapper.

Arguments:

    OpenErrorStatus - Extra status bytes for opening token ring adapters.

    SelectedMediumIndex - Index of the media type chosen by the driver.

    MediumArray - Array of media types for the driver to chose from.

    MediumArraySize - Number of entries in the array.

    MiniportAdapterHandle - Handle for passing to the wrapper when
       referring to this adapter.

    ConfigurationHandle - A handle to pass to NdisOpenConfiguration.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING

--*/

{
    //
    // Pointer to our newly allocated adapter.
    //
    PNE2000_ADAPTER Adapter;

    //
    // The handle for reading from the registry.
    //
    NDIS_HANDLE ConfigHandle;

    //
    // The value read from the registry.
    //
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;

    //
    // String names of all the parameters that will be read.
    //
    NDIS_STRING IOAddressStr = NDIS_STRING_CONST("IoBaseAddress");
    NDIS_STRING InterruptStr = NDIS_STRING_CONST("InterruptNumber");
    NDIS_STRING MaxMulticastListStr = NDIS_STRING_CONST("MaximumMulticastList");
    NDIS_STRING NetworkAddressStr = NDIS_STRING_CONST("NetworkAddress");
    NDIS_STRING BusTypeStr = NDIS_STRING_CONST("BusType");
    NDIS_STRING CardTypeStr = NDIS_STRING_CONST("CardType");

    //
    // TRUE if there is a configuration error.
    //
    BOOLEAN ConfigError = FALSE;

    //
    // A special value to log concerning the error.
    //
    ULONG ConfigErrorValue = 0;

    //
    // The slot number the adapter is located in, used for
    // Microchannel adapters.
    //
    UINT SlotNumber = 0;

    //
    // TRUE if it is unnecessary to read the Io Base Address
    // and Interrupt from the registry.  Used for Microchannel
    // adapters, which get this information from the slot
    // information.
    //
    BOOLEAN SkipIobaseAndInterrupt = FALSE;

    //
    // The network address the adapter should use instead of the
    // the default burned in address.
    //
    PVOID NetAddress;

    //
    // The number of bytes in the address.  It should be
    // NE2000_LENGTH_OF_ADDRESS
    //
    ULONG Length;

    //
    // These are used when calling Ne2000RegisterAdapter.
    //

    //
    // The physical address of the base I/O port.
    //
    PVOID IoBaseAddr;

    //
    // The interrupt number to use.
    //
    CCHAR InterruptNumber;

    //
    // The number of multicast address to be supported.
    //
    UINT MaxMulticastList;

    //
    // Temporary looping variable.
    //
    ULONG i;

    //
    // Status of Ndis calls.
    //
    NDIS_STATUS Status;

    NDIS_MCA_POS_DATA McaData;

    //
    // Search for the medium type (802.3) in the given array.
    //
    for (i = 0; i < MediumArraySize; i++){

        if (MediumArray[i] == NdisMedium802_3){

            break;

        }

    }

    if (i == MediumArraySize){

        return( NDIS_STATUS_UNSUPPORTED_MEDIA );

    }

    *SelectedMediumIndex = i;


    //
    // Set default values.
    //
    IoBaseAddr = DEFAULT_IOBASEADDR;
    InterruptNumber = DEFAULT_INTERRUPTNUMBER;
    MaxMulticastList = DEFAULT_MULTICASTLISTMAX;

    //
    // Allocate memory for the adapter block now.
    //
    Status = NdisAllocateMemoryWithTag( (PVOID *)&Adapter,
                   sizeof(NE2000_ADAPTER),
                   'k2EN'
                   );

    if (Status != NDIS_STATUS_SUCCESS) {

        return Status;

    }

    //
    // Clear out the adapter block, which sets all default values to FALSE,
    // or NULL.
    //
    NdisZeroMemory (Adapter, sizeof(NE2000_ADAPTER));

    //
    // Open the configuration space.
    //
    NdisOpenConfiguration(
            &Status,
            &ConfigHandle,
            ConfigurationHandle
            );

    if (Status != NDIS_STATUS_SUCCESS) {

        NdisFreeMemory(Adapter, sizeof(NE2000_ADAPTER), 0);

        return Status;

    }

    //
    //  Read in the card type.
    //
    Adapter->CardType = NE2000_ISA;

    NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigHandle,
            &CardTypeStr,
            NdisParameterHexInteger
            );
    if (Status == NDIS_STATUS_SUCCESS)
        Adapter->CardType = (UINT)ReturnedValue->ParameterData.IntegerData;

    //
    // Read net address
    //
    NdisReadNetworkAddress(
                    &Status,
                    &NetAddress,
                    &Length,
                    ConfigHandle
                    );

    if ((Length == NE2000_LENGTH_OF_ADDRESS) && (Status == NDIS_STATUS_SUCCESS)) {

        //
        // Save the address that should be used.
        //
        NdisMoveMemory(
                Adapter->StationAddress,
                NetAddress,
                NE2000_LENGTH_OF_ADDRESS
                );

    }

    //
    // Disallow multiple adapters in the same MP machine because of hardware
    // problems this results in random packet corruption.
    //
    if ((NdisSystemProcessorCount() > 1) && (Ne2000MiniportBlock.AdapterQueue != NULL)) {

        ConfigError = TRUE;
        ConfigErrorValue = (ULONG)NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION;
        goto RegisterAdapter;

        return NDIS_STATUS_FAILURE;

    }


    //
    // Read Bus Type (for NE2/AE2 support)
    //
    Adapter->BusType = NdisInterfaceIsa;

    NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigHandle,
            &BusTypeStr,
            NdisParameterHexInteger
            );

    if (Status == NDIS_STATUS_SUCCESS) {

        Adapter->BusType = (UCHAR)ReturnedValue->ParameterData.IntegerData;

    }

    if (!SkipIobaseAndInterrupt) {
        //
        // Read I/O Address
        //
        NdisReadConfiguration(
                &Status,
                &ReturnedValue,
                ConfigHandle,
                &IOAddressStr,
                NdisParameterHexInteger
                );

        if (Status == NDIS_STATUS_SUCCESS) {

            IoBaseAddr = UlongToPtr(ReturnedValue->ParameterData.IntegerData);

        }

        if (Adapter->BusType != NdisInterfacePcMcia)
        {
            //
            // Check that the value is valid.
            //
            if ((IoBaseAddr < (PVOID)MIN_IOBASEADDR) ||
                (IoBaseAddr > (PVOID)MAX_IOBASEADDR)) {

                ConfigError = TRUE;
                ConfigErrorValue = PtrToUlong(IoBaseAddr);
                goto RegisterAdapter;

            }
        }

        //
        // Read interrupt number
        //
        NdisReadConfiguration(
                &Status,
                &ReturnedValue,
                ConfigHandle,
                &InterruptStr,
                NdisParameterHexInteger
                );


        if (Status == NDIS_STATUS_SUCCESS) {

            InterruptNumber = (CCHAR)(ReturnedValue->ParameterData.IntegerData);

        }

        //
        // Verify that the value is valid.
        //
        if ((InterruptNumber < MIN_IRQ) ||
            (InterruptNumber > MAX_IRQ)) {

            ConfigError = TRUE;
            ConfigErrorValue = (ULONG)InterruptNumber;
            goto RegisterAdapter;

        }

        //
        //  If the adapter is a pcmcia card then get the memory window
        //  address for later use.
        //
        if (NE2000_PCMCIA == Adapter->CardType)
        {
#if 0
            NDIS_STRING AttributeMemoryAddrStr =
                            NDIS_STRING_CONST("MemoryMappedBaseAddress");
            NDIS_STRING AttributeMemorySizeStr =
                            NDIS_STRING_CONST("PCCARDAttributeMemorySize");

            //
            //  Read the attribute memory address.
            //
            Adapter->AttributeMemoryAddress = 0xd4000;

            NdisReadConfiguration(
                &Status,
                &ReturnedValue,
                ConfigHandle,
                &AttributeMemoryAddrStr,
                NdisParameterHexInteger
            );
            if (NDIS_STATUS_SUCCESS == Status)
            {
                Adapter->AttributeMemoryAddress =
                            (ULONG)ReturnedValue->ParameterData.IntegerData;
            }

            //
            //  Read the size of the attribute memory range.
            //
            Adapter->AttributeMemorySize = 0x1000;

            NdisReadConfiguration(
                &Status,
                &ReturnedValue,
                ConfigHandle,
                &AttributeMemorySizeStr,
                NdisParameterHexInteger
            );
            if (NDIS_STATUS_SUCCESS == Status)
            {
                Adapter->AttributeMemorySize =
                            (ULONG)ReturnedValue->ParameterData.IntegerData;
            }
#endif

        }
    }

    //
    // Read MaxMulticastList
    //
    NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigHandle,
            &MaxMulticastListStr,
            NdisParameterInteger
            );

    if (Status == NDIS_STATUS_SUCCESS) {

        MaxMulticastList = ReturnedValue->ParameterData.IntegerData;
        if (ReturnedValue->ParameterData.IntegerData <= DEFAULT_MULTICASTLISTMAX)
            MaxMulticastList = ReturnedValue->ParameterData.IntegerData;
    }


RegisterAdapter:

    //
    // Now to use this information and register with the wrapper
    // and initialize the adapter.
    //

    //
    // First close the configuration space.
    //
    NdisCloseConfiguration(ConfigHandle);

    IF_LOUD( DbgPrint(
        "Registering adapter # buffers %ld\n"
        "Card type: 0x%x\n"
        "I/O base addr 0x%lx\n"
        "interrupt number %ld\n"
        "max multicast %ld\nattribute memory address 0x%X\n"
        "attribute memory size 0x%X\n"
        "CardType: %d\n",
        DEFAULT_NUMBUFFERS,
        Adapter->CardType,
        IoBaseAddr,
        InterruptNumber,
        DEFAULT_MULTICASTLISTMAX,
        Adapter->AttributeMemoryAddress,
        Adapter->AttributeMemorySize,
        Adapter->CardType );)



    //
    // Set up the parameters.
    //
    Adapter->NumBuffers = DEFAULT_NUMBUFFERS;
    Adapter->IoBaseAddr = IoBaseAddr;

    Adapter->InterruptNumber = InterruptNumber;

    Adapter->MulticastListMax = MaxMulticastList;
    Adapter->MiniportAdapterHandle = MiniportAdapterHandle;

    Adapter->MaxLookAhead = NE2000_MAX_LOOKAHEAD;

    //
    // Now do the work.
    //
    if (Ne2000RegisterAdapter(Adapter,
          ConfigurationHandle,
          ConfigError,
          ConfigErrorValue
          ) != NDIS_STATUS_SUCCESS) {

        //
        // Ne2000RegisterAdapter failed.
        //
        NdisFreeMemory(Adapter, sizeof(NE2000_ADAPTER), 0);

        return NDIS_STATUS_FAILURE;

    }


    IF_LOUD( DbgPrint( "Ne2000RegisterAdapter succeeded\n" );)

    return NDIS_STATUS_SUCCESS;
}


#pragma NDIS_PAGEABLE_FUNCTION(Ne2000RegisterAdapter)
NDIS_STATUS
Ne2000RegisterAdapter(
    IN PNE2000_ADAPTER Adapter,
    IN NDIS_HANDLE ConfigurationHandle,
    IN BOOLEAN ConfigError,
    IN ULONG ConfigErrorValue
    )

/*++

Routine Description:

    Called when a new adapter should be registered. It allocates space for
    the adapter, initializes the adapter's block, registers resources
    with the wrapper and initializes the physical adapter.

Arguments:

    Adapter - The adapter structure.

    ConfigurationHandle - Handle passed to Ne2000Initialize.

    ConfigError - Was there an error during configuration reading.

    ConfigErrorValue - Value to log if there is an error.

Return Value:

    Indicates the success or failure of the registration.

--*/

{

    //
    // Temporary looping variable.
    //
    UINT i;

    //
    // General purpose return from NDIS calls
    //
    NDIS_STATUS status;

    //
    // check that NumBuffers <= MAX_XMIT_BUFS
    //

    if (Adapter->NumBuffers > MAX_XMIT_BUFS)
        return(NDIS_STATUS_RESOURCES);

    //
    // Check for a configuration error
    //
    if (ConfigError)
    {
        //
        // Log Error and exit.
        //
        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
            1,
            ConfigErrorValue
            );

        return(NDIS_STATUS_FAILURE);
    }

    //
    // Inform the wrapper of the physical attributes of this adapter.
    //
    NdisMSetAttributes(
        Adapter->MiniportAdapterHandle,
        (NDIS_HANDLE)Adapter,
        FALSE,
        Adapter->BusType
    );

    //
    // Register the port addresses.
    //
    status = NdisMRegisterIoPortRange(
                 (PVOID *)(&(Adapter->IoPAddr)),
                 Adapter->MiniportAdapterHandle,
                 PtrToUint(Adapter->IoBaseAddr),
                 0x20
             );

    if (status != NDIS_STATUS_SUCCESS)
        return(status);

    if (NE2000_ISA == Adapter->CardType)
    {
        //
        // Check that the IoBaseAddress seems to be correct.
        //
        IF_VERY_LOUD( DbgPrint("Checking Parameters\n"); )

        if (!CardCheckParameters(Adapter))
        {
            //
            // The card does not seem to be there, fail silently.
            //
            IF_VERY_LOUD( DbgPrint("  -- Failed\n"); )

            NdisWriteErrorLogEntry(
                Adapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
                0
            );

            status = NDIS_STATUS_ADAPTER_NOT_FOUND;

            goto fail2;
        }

        IF_VERY_LOUD( DbgPrint("  -- Success\n"); )
    }

    //
    // Initialize the card.
    //
    IF_VERY_LOUD( DbgPrint("CardInitialize\n"); )

    if (!CardInitialize(Adapter))
    {
        //
        // Card seems to have failed.
        //

        IF_VERY_LOUD( DbgPrint("  -- Failed\n"); )

        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
            0
        );

        status = NDIS_STATUS_ADAPTER_NOT_FOUND;

        goto fail2;
    }

    IF_VERY_LOUD( DbgPrint("  -- Success\n"); )

    //
    //
    // For programmed I/O, we will refer to transmit/receive memory in
    // terms of offsets in the card's 64K address space.
    //
    Adapter->XmitStart = Adapter->RamBase;

    //
    // For the NicXXX fields, always use the addressing system
    // containing the MSB only).
    //
    Adapter->NicXmitStart = (UCHAR)((PtrToUlong(Adapter->XmitStart)) >> 8);

    //
    // The start of the receive space.
    //
    Adapter->PageStart = Adapter->XmitStart +
            (Adapter->NumBuffers * TX_BUF_SIZE);

    Adapter->NicPageStart = Adapter->NicXmitStart +
            (UCHAR)(Adapter->NumBuffers * BUFS_PER_TX);

    ASSERT(Adapter->PageStart < (Adapter->RamBase + Adapter->RamSize));

    //
    // The end of the receive space.
    //
    Adapter->PageStop = Adapter->XmitStart + Adapter->RamSize;
    Adapter->NicPageStop = Adapter->NicXmitStart + (UCHAR)(Adapter->RamSize >> 8);

    ASSERT(Adapter->PageStop <= (Adapter->RamBase + Adapter->RamSize));

    IF_LOUD( DbgPrint("Xmit Start (0x%x, 0x%x) : Rcv Start (0x%x, 0x%x) : Rcv End (0x%x, 0x%x)\n",
              Adapter->XmitStart,
              Adapter->NicXmitStart,
              Adapter->PageStart,
              Adapter->NicPageStart,
              (ULONG_PTR)Adapter->PageStop,
              Adapter->NicPageStop
             );
       )


    //
    // Initialize the receive variables.
    //
    Adapter->NicReceiveConfig = RCR_REJECT_ERR;

    //
    // Initialize the transmit buffer control.
    //
    Adapter->CurBufXmitting = (XMIT_BUF)-1;

    //
    // Initialize the transmit buffer states.
    //
    for (i = 0; i < Adapter->NumBuffers; i++)
        Adapter->BufferStatus[i] = EMPTY;

    //
    // Read the Ethernet address off of the PROM.
    //
    if (!CardReadEthernetAddress(Adapter))
    {
        IF_LOUD(DbgPrint("Could not read the ethernet address\n");)

        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
            0
            );

        status = NDIS_STATUS_ADAPTER_NOT_FOUND;

        goto fail2;
    }

    //
    // Now initialize the NIC and Gate Array registers.
    //
    Adapter->NicInterruptMask = IMR_RCV | IMR_XMIT | IMR_XMIT_ERR | IMR_OVERFLOW;

    //
    // Link us on to the chain of adapters for this driver.
    //
    Adapter->NextAdapter = Ne2000MiniportBlock.AdapterQueue;
    Ne2000MiniportBlock.AdapterQueue = Adapter;


    //
    // Setup the card based on the initialization information
    //

    IF_VERY_LOUD( DbgPrint("Setup\n"); )

    if (!CardSetup(Adapter))
    {
        //
        // The NIC could not be written to.
        //

        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
            0
        );

        IF_VERY_LOUD( DbgPrint("  -- Failed\n"); )

        status = NDIS_STATUS_ADAPTER_NOT_FOUND;

        goto fail3;
    }

    IF_VERY_LOUD( DbgPrint("  -- Success\n"); )

    //
    // Initialize the interrupt.
    //
    
    Adapter->InterruptMode = NdisInterruptLatched;
    
    status = NdisMRegisterInterrupt(
                 &Adapter->Interrupt,
                 Adapter->MiniportAdapterHandle,
                 Adapter->InterruptNumber,
                 Adapter->InterruptNumber,
                 FALSE,
                 FALSE,
                 Adapter->InterruptMode
             );

    if (status != NDIS_STATUS_SUCCESS)
    {
        //
        // Maybe it is a level interrupt
        //
        
        Adapter->InterruptMode = NdisInterruptLevelSensitive;
        Adapter->InterruptsEnabled = TRUE;
        
        status = NdisMRegisterInterrupt(
                     &Adapter->Interrupt,
                     Adapter->MiniportAdapterHandle,
                     Adapter->InterruptNumber,
                     Adapter->InterruptNumber,
                     TRUE,
                     TRUE,
                     Adapter->InterruptMode
                     );
       
        if (status != NDIS_STATUS_SUCCESS)
        {
    
            NdisWriteErrorLogEntry(
                Adapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_INTERRUPT_CONNECT,
                0
            );
           
            goto fail3;
        }            
    }

    IF_LOUD( DbgPrint("Interrupt Connected\n");)

    //
    // Start up the adapter.
    //
    CardStart(Adapter);

    //
    // Initialization completed successfully. Register a shutdown handler.
    //

    NdisMRegisterAdapterShutdownHandler(
        Adapter->MiniportAdapterHandle,
        (PVOID)Adapter,
        Ne2000Shutdown
        );

    IF_LOUD( DbgPrint(" [ Ne2000 ] : OK\n");)

    return(NDIS_STATUS_SUCCESS);

    //
    // Code to unwind what has already been set up when a part of
    // initialization fails, which is jumped into at various
    // points based on where the failure occured. Jumping to
    // a higher-numbered failure point will execute the code
    // for that block and all lower-numbered ones.
    //

fail3:

    //
    // Take us out of the AdapterQueue.
    //

    if (Ne2000MiniportBlock.AdapterQueue == Adapter)
    {
        Ne2000MiniportBlock.AdapterQueue = Adapter->NextAdapter;
    }
    else
    {
        PNE2000_ADAPTER TmpAdapter = Ne2000MiniportBlock.AdapterQueue;

        while (TmpAdapter->NextAdapter != Adapter)
        {
            TmpAdapter = TmpAdapter->NextAdapter;
        }

        TmpAdapter->NextAdapter = TmpAdapter->NextAdapter->NextAdapter;
    }

    //
    // We already enabled the interrupt on the card, so
    // turn it off.
    //
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND, CR_STOP);

fail2:

    NdisMDeregisterIoPortRange(
        Adapter->MiniportAdapterHandle,
        PtrToUint(Adapter->IoBaseAddr),
        0x20,
        (PVOID)Adapter->IoPAddr
    );

    return(status);
}


extern
VOID
Ne2000Halt(
    IN NDIS_HANDLE MiniportAdapterContext
    )

/*++

Routine Description:

    NE2000Halt removes an adapter that was previously initialized.

Arguments:

    MiniportAdapterContext - The context value that the Miniport returned
        from Ne2000Initialize; actually as pointer to an NE2000_ADAPTER.

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter;

    Adapter = PNE2000_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    //
    // Shut down the chip.
    //
    CardStop(Adapter);

    //
    // Deregister the adapter shutdown handler.
    //
    NdisMDeregisterAdapterShutdownHandler(Adapter->MiniportAdapterHandle);

    //
    // Disconnect the interrupt line.
    //
    NdisMDeregisterInterrupt(&Adapter->Interrupt);

    //
    // Pause, waiting for any DPC stuff to clear.
    //
    NdisStallExecution(250000);

    NdisMDeregisterIoPortRange(Adapter->MiniportAdapterHandle,
                               PtrToUint(Adapter->IoBaseAddr),
                               0x20,
                               (PVOID)Adapter->IoPAddr
                               );

    //
    // Remove the adapter from the global queue of adapters.
    //
    if (Ne2000MiniportBlock.AdapterQueue == Adapter) {

        Ne2000MiniportBlock.AdapterQueue = Adapter->NextAdapter;

    } else {

        PNE2000_ADAPTER TmpAdapter = Ne2000MiniportBlock.AdapterQueue;

        while (TmpAdapter->NextAdapter != Adapter) {

            TmpAdapter = TmpAdapter->NextAdapter;

        }

        TmpAdapter->NextAdapter = TmpAdapter->NextAdapter->NextAdapter;
    }

    //
    // Free up the memory
    //
    NdisFreeMemory(Adapter, sizeof(NE2000_ADAPTER), 0);

    return;

}


VOID
Ne2000Shutdown(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:

    This is called by NDIS when the system is shutting down or restarting
    on an unrecoverable error. Do the minimum set of operations to make the
    card silent.

Arguments:

    MiniportAdapterContext - pointer to our adapter structure

Return Value:

    None.

--*/
{
    //
    // Pointer to the adapter structure.
    //
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)MiniportAdapterContext;

    (VOID)SyncCardStop(Adapter);
}


NDIS_STATUS
Ne2000Reset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:

    The NE2000Reset request instructs the Miniport to issue a hardware reset
    to the network adapter.  The driver also resets its software state.  See
    the description of NdisMReset for a detailed description of this request.

Arguments:

    AddressingReset - Does the adapter need the addressing information reloaded.

    MiniportAdapterContext - Pointer to the adapter structure.

Return Value:

    The function value is the status of the operation.

--*/

{

    //
    // Pointer to the adapter structure.
    //
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)MiniportAdapterContext;

    //
    // Temporary looping variable
    //
    UINT i;

    //
    // Clear the values for transmits, they will be reset these for after
    // the reset is completed.
    //
    Adapter->NextBufToFill = 0;
    Adapter->NextBufToXmit = 0;
    Adapter->CurBufXmitting = (XMIT_BUF)-1;

    Adapter->FirstPacket = NULL;
    Adapter->LastPacket = NULL;

    for (i=0; i<Adapter->NumBuffers; i++) {
            Adapter->BufferStatus[i] = EMPTY;
    }

    //
    // Physically reset the card.
    //
    Adapter->NicInterruptMask = IMR_RCV | IMR_XMIT | IMR_XMIT_ERR | IMR_OVERFLOW;

    return (CardReset(Adapter) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
}


NDIS_STATUS
Ne2000QueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
)

/*++

Routine Description:

    The NE2000QueryInformation process a Query request for
    NDIS_OIDs that are specific about the Driver.

Arguments:

    MiniportAdapterContext - a pointer to the adapter.

    Oid - the NDIS_OID to process.

    InformationBuffer -  a pointer into the
    NdisRequest->InformationBuffer into which store the result of the query.

    InformationBufferLength - a pointer to the number of bytes left in the
    InformationBuffer.

    BytesWritten - a pointer to the number of bytes written into the
    InformationBuffer.

    BytesNeeded - If there is not enough room in the information buffer
    then this will contain the number of bytes needed to complete the
    request.

Return Value:

    The function value is the status of the operation.

--*/
{

    //
    // Pointer to the adapter structure.
    //
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)MiniportAdapterContext;

    //
    //   General Algorithm:
    //
    //      Switch(Request)
    //         Get requested information
    //         Store results in a common variable.
    //      default:
    //         Try protocol query information
    //         If that fails, fail query.
    //
    //      Copy result in common variable to result buffer.
    //   Finish processing

    UINT BytesLeft = InformationBufferLength;
    PUCHAR InfoBuffer = (PUCHAR)(InformationBuffer);
    NDIS_STATUS StatusToReturn = NDIS_STATUS_SUCCESS;
    NDIS_HARDWARE_STATUS HardwareStatus = NdisHardwareStatusReady;
    NDIS_MEDIUM Medium = NdisMedium802_3;

    //
    // This variable holds result of query
    //
    ULONG GenericULong;
    USHORT GenericUShort;
    UCHAR GenericArray[6];
    UINT MoveBytes = sizeof(ULONG);
    PVOID MoveSource = (PVOID)(&GenericULong);

    //
    // Make sure that int is 4 bytes.  Else GenericULong must change
    // to something of size 4.
    //
    ASSERT(sizeof(ULONG) == 4);

    //
    // Switch on request type
    //

    switch (Oid) {

    case OID_GEN_MAC_OPTIONS:

        GenericULong = (ULONG)(NDIS_MAC_OPTION_TRANSFERS_NOT_PEND  |
                               NDIS_MAC_OPTION_RECEIVE_SERIALIZED  |
                               NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA |
                               NDIS_MAC_OPTION_NO_LOOPBACK
                               );

        break;

    case OID_GEN_SUPPORTED_LIST:

        MoveSource = (PVOID)(Ne2000SupportedOids);
        MoveBytes = sizeof(Ne2000SupportedOids);
        break;

    case OID_GEN_HARDWARE_STATUS:

        HardwareStatus = NdisHardwareStatusReady;
        MoveSource = (PVOID)(&HardwareStatus);
        MoveBytes = sizeof(NDIS_HARDWARE_STATUS);

        break;

    case OID_GEN_MEDIA_SUPPORTED:
    case OID_GEN_MEDIA_IN_USE:

        MoveSource = (PVOID) (&Medium);
        MoveBytes = sizeof(NDIS_MEDIUM);
        break;

    case OID_GEN_MAXIMUM_LOOKAHEAD:

        GenericULong = NE2000_MAX_LOOKAHEAD;

        break;


    case OID_GEN_MAXIMUM_FRAME_SIZE:

        GenericULong = (ULONG)(1514 - NE2000_HEADER_SIZE);

        break;


    case OID_GEN_MAXIMUM_TOTAL_SIZE:

        GenericULong = (ULONG)(1514);

        break;


    case OID_GEN_LINK_SPEED:

        GenericULong = (ULONG)(100000);

        break;


    case OID_GEN_TRANSMIT_BUFFER_SPACE:

        GenericULong = (ULONG)(Adapter->NumBuffers * TX_BUF_SIZE);

        break;

    case OID_GEN_RECEIVE_BUFFER_SPACE:

        GenericULong = (ULONG)(0x2000 - (Adapter->NumBuffers * TX_BUF_SIZE));

        break;

    case OID_GEN_TRANSMIT_BLOCK_SIZE:

        GenericULong = (ULONG)(TX_BUF_SIZE);

        break;

    case OID_GEN_RECEIVE_BLOCK_SIZE:

        GenericULong = (ULONG)(256);

        break;

#ifdef NE2000

    case OID_GEN_VENDOR_ID:

        NdisMoveMemory(
            (PVOID)&GenericULong,
            Adapter->PermanentAddress,
            3
            );
        GenericULong &= 0xFFFFFF00;
        MoveSource = (PVOID)(&GenericULong);
        MoveBytes = sizeof(GenericULong);
        break;

    case OID_GEN_VENDOR_DESCRIPTION:

        MoveSource = (PVOID)"Novell 2000 Adapter.";
        MoveBytes = 21;

        break;

#else

    case OID_GEN_VENDOR_ID:

        NdisMoveMemory(
            (PVOID)&GenericULong,
            Adapter->PermanentAddress,
            3
            );
        GenericULong &= 0xFFFFFF00;
        GenericULong |= 0x01;
        MoveSource = (PVOID)(&GenericULong);
        MoveBytes = sizeof(GenericULong);
        break;

    case OID_GEN_VENDOR_DESCRIPTION:

        MoveSource = (PVOID)"Novell 1000 Adapter.";
        MoveBytes = 21;

        break;

#endif

    case OID_GEN_DRIVER_VERSION:

        GenericUShort = ((USHORT)NE2000_NDIS_MAJOR_VERSION << 8) |
                NE2000_NDIS_MINOR_VERSION;

        MoveSource = (PVOID)(&GenericUShort);
        MoveBytes = sizeof(GenericUShort);
        break;

    case OID_GEN_CURRENT_LOOKAHEAD:

        GenericULong = (ULONG)(Adapter->MaxLookAhead);
        break;

    case OID_802_3_PERMANENT_ADDRESS:

        NE2000_MOVE_MEM((PCHAR)GenericArray,
                    Adapter->PermanentAddress,
                    NE2000_LENGTH_OF_ADDRESS);

        MoveSource = (PVOID)(GenericArray);
        MoveBytes = sizeof(Adapter->PermanentAddress);

        break;

    case OID_802_3_CURRENT_ADDRESS:

        NE2000_MOVE_MEM((PCHAR)GenericArray,
                    Adapter->StationAddress,
                    NE2000_LENGTH_OF_ADDRESS);

        MoveSource = (PVOID)(GenericArray);
        MoveBytes = sizeof(Adapter->StationAddress);

        break;

    case OID_802_3_MAXIMUM_LIST_SIZE:

        GenericULong = (ULONG) (Adapter->MulticastListMax);
        break;

    case OID_GEN_XMIT_OK:

        GenericULong = (UINT)(Adapter->FramesXmitGood);
        break;

    case OID_GEN_RCV_OK:

        GenericULong = (UINT)(Adapter->FramesRcvGood);
        break;

    case OID_GEN_XMIT_ERROR:

        GenericULong = (UINT)(Adapter->FramesXmitBad);
        break;

    case OID_GEN_RCV_ERROR:

        GenericULong = (UINT)(Adapter->CrcErrors);
        break;

    case OID_GEN_RCV_NO_BUFFER:

        GenericULong = (UINT)(Adapter->MissedPackets);
        break;

    case OID_802_3_RCV_ERROR_ALIGNMENT:

        GenericULong = (UINT)(Adapter->FrameAlignmentErrors);
        break;

    case OID_802_3_XMIT_ONE_COLLISION:

        GenericULong = (UINT)(Adapter->FramesXmitOneCollision);
        break;

    case OID_802_3_XMIT_MORE_COLLISIONS:

        GenericULong = (UINT)(Adapter->FramesXmitManyCollisions);
        break;

    default:

        StatusToReturn = NDIS_STATUS_INVALID_OID;
        break;

    }


    if (StatusToReturn == NDIS_STATUS_SUCCESS) {

        if (MoveBytes > BytesLeft) {

            //
            // Not enough room in InformationBuffer. Punt
            //

            *BytesNeeded = MoveBytes;

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;

        } else {

            //
            // Store result.
            //

            NE2000_MOVE_MEM(InfoBuffer, MoveSource, MoveBytes);

            (*BytesWritten) = MoveBytes;

        }
    }

    return StatusToReturn;
}


extern
NDIS_STATUS
Ne2000SetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    )

/*++

Routine Description:

    NE2000SetInformation handles a set operation for a
    single OID.

Arguments:

    MiniportAdapterContext - Context registered with the wrapper, really
        a pointer to the adapter.

    Oid - The OID of the set.

    InformationBuffer - Holds the data to be set.

    InformationBufferLength - The length of InformationBuffer.

    BytesRead - If the call is successful, returns the number
        of bytes read from InformationBuffer.

    BytesNeeded - If there is not enough data in InformationBuffer
        to satisfy the OID, returns the amount of storage needed.

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_INVALID_LENGTH
    NDIS_STATUS_INVALID_OID

--*/
{
    //
    // Pointer to the adapter structure.
    //
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)MiniportAdapterContext;

    //
    // General Algorithm:
    //
    //     Verify length
    //     Switch(Request)
    //        Process Request
    //

    UINT BytesLeft = InformationBufferLength;
    PUCHAR InfoBuffer = (PUCHAR)(InformationBuffer);

    //
    // Variables for a particular request
    //
    UINT OidLength;

    //
    // Variables for holding the new values to be used.
    //
    ULONG LookAhead;
    ULONG Filter;

    //
    // Status of the operation.
    //
    NDIS_STATUS StatusToReturn = NDIS_STATUS_SUCCESS;


    IF_LOUD( DbgPrint("In SetInfo\n");)

    //
    // Get Oid and Length of request
    //
    OidLength = BytesLeft;

    switch (Oid) {

    case OID_802_3_MULTICAST_LIST:

        //
        // Verify length
        //
        if ((OidLength % NE2000_LENGTH_OF_ADDRESS) != 0){

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;

            *BytesRead = 0;
            *BytesNeeded = 0;

            break;

        }

        //
        // Set the new list on the adapter.
        //
        NdisMoveMemory(Adapter->Addresses, InfoBuffer, OidLength);

        //
        //  If we are currently receiving all multicast or
        //  we are promsicuous then we DO NOT call this, or
        //  it will reset thoes settings.
        //
        if
        (
            !(Adapter->PacketFilter & (NDIS_PACKET_TYPE_ALL_MULTICAST |
                                       NDIS_PACKET_TYPE_PROMISCUOUS))
        )
        {
            StatusToReturn = DispatchSetMulticastAddressList(Adapter);
        }
        else
        {
            //
            //  Our list of multicast addresses is kept by the
            //  wrapper.
            //
            StatusToReturn = NDIS_STATUS_SUCCESS;
        }

        break;

    case OID_GEN_CURRENT_PACKET_FILTER:

        //
        // Verify length
        //

        if (OidLength != 4 ) {

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;

            *BytesRead = 0;
            *BytesNeeded = 0;

            break;

        }

        NE2000_MOVE_MEM(&Filter, InfoBuffer, 4);

        //
        // Verify bits
        //
        if (!(Filter & (NDIS_PACKET_TYPE_ALL_MULTICAST |
                            NDIS_PACKET_TYPE_PROMISCUOUS |
                            NDIS_PACKET_TYPE_MULTICAST |
                            NDIS_PACKET_TYPE_BROADCAST |
                            NDIS_PACKET_TYPE_DIRECTED)) &&
            (Filter != 0))
        {
            StatusToReturn = NDIS_STATUS_NOT_SUPPORTED;

            *BytesRead = 4;
            *BytesNeeded = 0;

            break;

        }

        //
        // Set the new value on the adapter.
        //
        Adapter->PacketFilter = Filter;
        StatusToReturn = DispatchSetPacketFilter(Adapter);
        break;

    case OID_GEN_CURRENT_LOOKAHEAD:

        //
        // Verify length
        //

        if (OidLength != 4) {

            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;

            *BytesRead = 0;
            *BytesNeeded = 4;

            break;

        }

        //
        // Store the new value.
        //

        NE2000_MOVE_MEM(&LookAhead, InfoBuffer, 4);

        if (LookAhead <= NE2000_MAX_LOOKAHEAD) {
            Adapter->MaxLookAhead = LookAhead;
        } else {
            StatusToReturn = NDIS_STATUS_INVALID_LENGTH;
        }

        break;

    default:

        StatusToReturn = NDIS_STATUS_INVALID_OID;

        *BytesRead = 0;
        *BytesNeeded = 0;

        break;

    }


    if (StatusToReturn == NDIS_STATUS_SUCCESS) {

        *BytesRead = BytesLeft;
        *BytesNeeded = 0;

    }

    return(StatusToReturn);
}


NDIS_STATUS
DispatchSetPacketFilter(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets the appropriate bits in the adapter filters
    and modifies the card Receive Configuration Register if needed.

Arguments:

    Adapter - Pointer to the adapter block

Return Value:

    The final status (always NDIS_STATUS_SUCCESS).

Notes:

  - Note that to receive all multicast packets the multicast
    registers on the card must be filled with 1's. To be
    promiscuous that must be done as well as setting the
    promiscuous physical flag in the RCR. This must be done
    as long as ANY protocol bound to this adapter has their
    filter set accordingly.

--*/


{
    //
    // See what has to be put on the card.
    //

    if
    (
        Adapter->PacketFilter & (NDIS_PACKET_TYPE_ALL_MULTICAST |
                                 NDIS_PACKET_TYPE_PROMISCUOUS)
    )
    {
        //
        // need "all multicast" now.
        //
        CardSetAllMulticast(Adapter);    // fills it with 1's
    }
    else
    {
        //
        // No longer need "all multicast".
        //
        DispatchSetMulticastAddressList(Adapter);
    }

    //
    // The multicast bit in the RCR should be on if ANY protocol wants
    // multicast/all multicast packets (or is promiscuous).
    //
    if
    (
        Adapter->PacketFilter & (NDIS_PACKET_TYPE_ALL_MULTICAST |
                                 NDIS_PACKET_TYPE_MULTICAST |
                                 NDIS_PACKET_TYPE_PROMISCUOUS)
    )
    {
        Adapter->NicReceiveConfig |= RCR_MULTICAST;
    }
    else
    {
        Adapter->NicReceiveConfig &= ~RCR_MULTICAST;
    }

    //
    // The promiscuous physical bit in the RCR should be on if ANY
    // protocol wants to be promiscuous.
    //
    if (Adapter->PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS)
    {
        Adapter->NicReceiveConfig |= RCR_ALL_PHYS;
    }
    else
    {
        Adapter->NicReceiveConfig &= ~RCR_ALL_PHYS;
    }

    //
    // The broadcast bit in the RCR should be on if ANY protocol wants
    // broadcast packets (or is promiscuous).
    //
    if
    (
        Adapter->PacketFilter & (NDIS_PACKET_TYPE_BROADCAST |
                                 NDIS_PACKET_TYPE_PROMISCUOUS)
    )
    {
        Adapter->NicReceiveConfig |= RCR_BROADCAST;
    }
    else
    {
        Adapter->NicReceiveConfig &= ~RCR_BROADCAST;
    }

    CardSetReceiveConfig(Adapter);

    return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
DispatchSetMulticastAddressList(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Sets the multicast list for this open

Arguments:

    Adapter - Pointer to the adapter block

Return Value:

    NDIS_STATUS_SUCESS

Implementation Note:

    When invoked, we are to make it so that the multicast list in the filter
    package becomes the multicast list for the adapter. To do this, we
    determine the required contents of the NIC multicast registers and
    update them.


--*/
{
    //
    // Update the local copy of the NIC multicast regs and copy them to the NIC
    //
    CardFillMulticastRegs(Adapter);
    CardCopyMulticastRegs(Adapter);

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\ne2000\interrup.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    interrup.c

Abstract:

    This is a part of the driver for the National Semiconductor Novell 2000
    Ethernet controller.  It contains the interrupt-handling routines.
    This driver conforms to the NDIS 3.0 interface.

    The overall structure and much of the code is taken from
    the Lance NDIS driver by Tony Ercolano.

Author:

    Sean Selitrennikoff (seanse) Dec-1991

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Bob Noradki - Apr 93 - added piggyback interrupt code.
    Jameel Hyder- Dec 94 - Fixed initialization - part of the fixes from JimMcn

--*/

#include "precomp.h"

//
// On debug builds tell the compiler to keep the symbols for
// internal functions, otw throw them out.
//
#if DBG
#define STATIC
#else
#define STATIC static
#endif



INDICATE_STATUS
Ne2000IndicatePacket(
    IN PNE2000_ADAPTER Adapter
    );

VOID
Ne2000DoNextSend(
    PNE2000_ADAPTER Adapter
    );



//
// This is used to pad short packets.
//
static UCHAR BlankBuffer[60] = "                                                            ";



VOID
Ne2000EnableInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    )

/*++

Routine Description:

    This routine is used to turn on the interrupt mask.

Arguments:

    Context - The adapter for the NE2000 to start.

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)(MiniportAdapterContext);

    IF_LOG( Ne2000Log('P'); )

    CardUnblockInterrupts(Adapter);

    Adapter->InterruptsEnabled = TRUE;
}

VOID
Ne2000DisableInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    )

/*++

Routine Description:

    This routine is used to turn off the interrupt mask.

Arguments:

    Context - The adapter for the NE2000 to start.

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)(MiniportAdapterContext);

    IF_LOG( Ne2000Log('p'); )

    CardBlockInterrupts(Adapter);

    Adapter->InterruptsEnabled = FALSE;
}

VOID
Ne2000Isr(
    OUT PBOOLEAN InterruptRecognized,
    OUT PBOOLEAN QueueDpc,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt handler which is registered with the operating
    system. If several are pending (i.e. transmit complete and receive),
    handle them all.  Block new interrupts until all pending interrupts
    are handled.

Arguments:

    InterruptRecognized - Boolean value which returns TRUE if the
        ISR recognizes the interrupt as coming from this adapter.

    QueueDpc - TRUE if a DPC should be queued.

    Context - pointer to the adapter object

Return Value:

    None.
--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)Context);
    UCHAR InterruptStatus;
    UCHAR InterruptMask;

    IF_LOUD( DbgPrint("In Ne2000ISR\n");)

    IF_LOG( Ne2000Log('i'); )

    IF_VERY_LOUD( DbgPrint( "Ne2000InterruptHandler entered\n" );)

    if (!Adapter->InterruptsEnabled) {
        *InterruptRecognized     = FALSE;
        *QueueDpc                = FALSE;
        return;
    }        

    //
    // Look to see if an interrupt has been asserted
    //
    CardGetInterruptStatus(Adapter, &InterruptStatus);
    
    if (InterruptStatus == 0) {
        *InterruptRecognized     = FALSE;
        *QueueDpc                = FALSE;
        return;
    }        

    //
    // It appears to be our interrupt.
    // Force the INT signal from the chip low. When all
    // interrupts are acknowledged interrupts will be unblocked,
    //
    CardBlockInterrupts(Adapter);

    *InterruptRecognized     = TRUE;
    *QueueDpc                = TRUE;


    IF_LOG( Ne2000Log('I'); )

    return;
}


VOID
Ne2000HandleInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:

    This is the defered processing routine for interrupts.  It
    reads from the Interrupt Status Register any outstanding
    interrupts and handles them.

Arguments:

    MiniportAdapterContext - a handle to the adapter block.

Return Value:

    NONE.

--*/
{
    //
    // The adapter to process
    //
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)MiniportAdapterContext);

    //
    // The most recent port value read.
    //
    UCHAR InterruptStatus;

    //
    // The interrupt type currently being processed.
    //
    INTERRUPT_TYPE InterruptType;
    
    ULONG CardTestCount = 0;

    IF_LOUD( DbgPrint("==>IntDpc\n");)
    IF_LOG( Ne2000Log('d'); )

    //
    // Get the interrupt bits and save them.
    //
    CardGetInterruptStatus(Adapter, &InterruptStatus);
    Adapter->InterruptStatus |= InterruptStatus;

    if (InterruptStatus != ISR_EMPTY) {

        //
        // Acknowledge the interrupts
        //
        NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS,
                              InterruptStatus
                             );

    }

    //
    // Return the type of the most important interrupt waiting on the card.
    // Order of importance is COUNTER, OVERFLOW, TRANSMIT,and RECEIVE.
    //
    InterruptType = CARD_GET_INTERRUPT_TYPE(Adapter, Adapter->InterruptStatus);

    //
    // InterruptType is used to dispatch to correct DPC and are then cleared
    //
    while (InterruptType != UNKNOWN) {

        //
        // Handle the interrupts
        //

        switch (InterruptType) {

        case COUNTER:

            //
            // One of the counters' MSB has been set, read in all
            // the values just to be sure (and then exit below).
            //

            IF_LOUD( DbgPrint("DPC got COUNTER\n");)

            SyncCardUpdateCounters((PVOID)Adapter);

            //
            // Clear the COUNTER interrupt bit
            //
            Adapter->InterruptStatus &= ~ISR_COUNTER;

            break;

        case OVERFLOW:

            //
            // Overflow interrupts are handled as part of a receive interrupt,
            // so set a flag and then pretend to be a receive, in case there
            // is no receive already being handled.
            //
            Adapter->BufferOverflow = TRUE;

            IF_LOUD( DbgPrint("Overflow Int\n"); )
            IF_VERY_LOUD( DbgPrint(" overflow interrupt\n"); )

            //
            // Clear the OVERFLOW interrupt bit
            //
            Adapter->InterruptStatus &= ~ISR_OVERFLOW;

        case RECEIVE:

            IF_LOG( Ne2000Log('R'); )
            IF_LOUD( DbgPrint("DPC got RCV\n"); )

            //
            // For receives, call this to handle the receive
            //
            if (Ne2000RcvDpc(Adapter)) {

                //
                // Clear the RECEIVE interrupt bits
                //
                Adapter->InterruptStatus &= ~(ISR_RCV | ISR_RCV_ERR);

            }

            IF_LOG( Ne2000Log('r'); )

            if (!(Adapter->InterruptStatus & (ISR_XMIT | ISR_XMIT_ERR)))
                break;

        case TRANSMIT:

            IF_LOG( Ne2000Log('X'); )

            ASSERT(!Adapter->OverflowRestartXmitDpc);

            //
            // Get the status of the transmit
            //
            SyncCardGetXmitStatus((PVOID)Adapter);

            //
            // We are no longer expecting an interrupts, as
            // we just got it.
            //
            Adapter->TransmitInterruptPending = FALSE;

            IF_LOUD( DbgPrint( "DPC got XMIT\n"); )

            //
            // Handle transmit errors
            //
            if (Adapter->InterruptStatus & ISR_XMIT_ERR) {

                OctogmetusceratorRevisited(Adapter);

            }

            //
            // Handle the transmit
            //
            if (Adapter->InterruptStatus & ISR_XMIT) {

                Ne2000XmitDpc(Adapter);

            }

            //
            // Clear the TRANSMIT interrupt bits
            //
            Adapter->InterruptStatus &= ~(ISR_XMIT | ISR_XMIT_ERR);

            break;

        default:

            IF_LOUD( DbgPrint("unhandled interrupt type: %x\n", InterruptType); )

            break;

        }

        //
        // Get any new interrupts
        //
        CardGetInterruptStatus(Adapter, &InterruptStatus);
        
        if ((InterruptStatus == 0xff) && (++CardTestCount > 10)) {
            //
            // this card appears dead
            //
            break;
        }

        if (InterruptStatus != ISR_EMPTY) {

            //
            // Acknowledge the interrupt
            //
            NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS,
                                  InterruptStatus
                                 );
        }

        //
        // Save the interrupt reasons
        //
        Adapter->InterruptStatus |= InterruptStatus;

        //
        // Get next interrupt to process
        //
        InterruptType = CARD_GET_INTERRUPT_TYPE(Adapter, Adapter->InterruptStatus);

    }

    if (Adapter->InterruptMode == NdisInterruptLevelSensitive) {
        //
        // Re-enable the interrupt (disabled in Isr)
        //
        NdisMSynchronizeWithInterrupt(&Adapter->Interrupt,
                                      Ne2000EnableInterrupt,
                                      Adapter);
    }                                      

    IF_LOG( Ne2000Log('D'); )

    IF_LOUD( DbgPrint("<==IntDpc\n"); )

}


BOOLEAN
Ne2000RcvDpc(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    This is the real interrupt handler for receive/overflow interrupt.

    Called when a receive interrupt is received. It first indicates
    all packets on the card and finally indicates ReceiveComplete().

Arguments:

    Adapter - Pointer to the adapter block.

Return Value:

    TRUE if done with all receives, else FALSE.

--*/

{
    //
    // Use to restart a transmit if a buffer overflow occured
    // during a transmission
    //
    BOOLEAN TransmitInterruptWasPending = FALSE;

    //
    // Status of a received packet.
    //
    INDICATE_STATUS IndicateStatus = INDICATE_OK;

    //
    // Flag to tell when the receive process is complete
    //
    BOOLEAN Done = TRUE;

    IF_LOUD( DbgPrint( "Ne2000RcvDpc entered\n" );)

    //
    // Default to not indicating NdisMEthIndicateReceiveComplete
    //
    Adapter->IndicateReceiveDone = FALSE;

    //
    // At this point, receive interrupts are disabled.
    //
    SyncCardGetCurrent((PVOID)Adapter);

    //
    // Handle a buffer overflow
    //
    if (Adapter->BufferOverflow) {

        SyncCardHandleOverflow(Adapter);

#if DBG
        if (Adapter->OverflowRestartXmitDpc) {

            IF_LOG( Ne2000Log('O');)
            IF_LOUD( DbgPrint ("Adapter->OverflowRestartXmitDpc set:RcvDpc\n"); )

        }
#endif // DBG

    }

    //
    // Loop
    //
    while (TRUE)
    {
        if ((Adapter->InterruptStatus & ISR_RCV_ERR) &&
            !Adapter->BufferOverflow
        )
        {
            IF_LOUD( DbgPrint ("RCV_ERR, IR=%x\n",Adapter->InterruptStatus); )

            //
            // Skip this packet
            //

            SyncCardGetCurrent((PVOID)Adapter);

            Adapter->NicNextPacket = Adapter->Current;

            CardSetBoundary(Adapter);

            break;

        }

        if (Adapter->Current == Adapter->NicNextPacket) {

            //
            // Acknowledge previous packet before the check for new ones,
            // then read in the Current register.
            // The card register Current used to point to
            // the end of the packet just received; read
            // the new value off the card and see if it
            // still does.
            //
            // This will store the value in Adapter->Current and acknowledge
            // the receive interrupt.
            //
            //

            SyncCardGetCurrent((PVOID)Adapter);

            if (Adapter->Current == Adapter->NicNextPacket) {

                //
                // End of Loop -- no more packets
                //

                break;
            }

        }

        //
        // A packet was found on the card, indicate it.
        //

        Adapter->ReceivePacketCount++;

        //
        // Verify packet is not corrupt
        //
        if (Ne2000PacketOK(Adapter)) {

            ULONG PacketLen;

            PacketLen = (Adapter->PacketHeader[2]) + ((Adapter->PacketHeader[3])*256) - 4;

            PacketLen = (PacketLen < Adapter->MaxLookAhead)?
                         PacketLen :
                         Adapter->MaxLookAhead;

            //
            // Copy up the lookahead data
            //
            if (!CardCopyUp(Adapter,
                            Adapter->Lookahead,
                            Adapter->PacketHeaderLoc,
                            PacketLen + NE2000_HEADER_SIZE
                            )) {

                //
                // Failed! Skip this packet
                //
                IndicateStatus = SKIPPED;

            } else {

                //
                // Indicate the packet to the wrapper
                //
                IndicateStatus = Ne2000IndicatePacket(Adapter);

                if (IndicateStatus != CARD_BAD) {

                    Adapter->FramesRcvGood++;

                }

            }

        } else {

            //
            // Packet is corrupt, skip it.
            //
            IF_LOUD( DbgPrint("Packet did not pass OK check\n"); )

            IndicateStatus = SKIPPED;

        }

        //
        // Handle when the card is unable to indicate good packets
        //
        if (IndicateStatus == CARD_BAD) {

#if DBG

            IF_NE2000DEBUG( NE2000_DEBUG_CARD_BAD ) {

                DbgPrint("R: <%x %x %x %x> C %x N %x\n",
                    Adapter->PacketHeader[0],
                    Adapter->PacketHeader[1],
                    Adapter->PacketHeader[2],
                    Adapter->PacketHeader[3],
                    Adapter->Current,
                    Adapter->NicNextPacket);

            }
#endif

            IF_LOG( Ne2000Log('W');)

            //
            // Start off with receive interrupts disabled.
            //

            Adapter->NicInterruptMask = IMR_XMIT | IMR_XMIT_ERR | IMR_OVERFLOW;

            //
            // Reset the adapter
            //
            CardReset(Adapter);

            //
            // Since the adapter was just reset, stop indicating packets.
            //

            break;

        }

        //
        // (IndicateStatus == SKIPPED) is OK, just move to next packet.
        //
        if (IndicateStatus == SKIPPED) {

            SyncCardGetCurrent((PVOID)Adapter);

            Adapter->NicNextPacket = Adapter->Current;

        } else {

            //
            // Free the space used by packet on card.
            //

            Adapter->NicNextPacket = Adapter->PacketHeader[1];

        }

        //
        // This will set BOUNDARY to one behind NicNextPacket.
        //
        CardSetBoundary(Adapter);

        if (Adapter->ReceivePacketCount > 10) {

            //
            // Give transmit interrupts a chance
            //
            Done = FALSE;
            Adapter->ReceivePacketCount = 0;
            break;

        }

    }

    //
    // See if a buffer overflow occured previously.
    //
    if (Adapter->BufferOverflow) {

        //
        // ... and set a flag to restart the card after receiving
        // a packet.
        //
        Adapter->BufferOverflow = FALSE;

        SyncCardAcknowledgeOverflow(Adapter);

        //
        // Undo loopback mode
        //
        CardStart(Adapter);

        IF_LOG( Ne2000Log('f'); )

        //
        // Check if transmission needs to be queued or not
        //
        if (Adapter->OverflowRestartXmitDpc && Adapter->CurBufXmitting != -1) {

            IF_LOUD( DbgPrint("queueing xmit in RcvDpc\n"); )

            Adapter->OverflowRestartXmitDpc = FALSE;

            Adapter->TransmitInterruptPending = TRUE;

            IF_LOG( Ne2000Log('5'); )

            CardStartXmit(Adapter);

        }
    }

    //
    // Finally, indicate ReceiveComplete to all protocols which received packets
    //
    if (Adapter->IndicateReceiveDone) {

        NdisMEthIndicateReceiveComplete(Adapter->MiniportAdapterHandle);

        Adapter->IndicateReceiveDone = FALSE;

    }

    IF_LOUD( DbgPrint( "Ne2000RcvDpc exiting\n" );)

    return (Done);

}


VOID
Ne2000XmitDpc(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    This is the real interrupt handler for a transmit complete interrupt.
    Ne2000Dpc queues a call to it.

    Called after a transmit complete interrupt. It checks the
    status of the transmission, completes the send if needed,
    and sees if any more packets are ready to be sent.

Arguments:

    Adapter  - Pointer to the adapter block.

Return Value:

    None.

--*/

{
    //
    // Packet that was transmitted
    //
    PNDIS_PACKET Packet;

    //
    // Status of the send
    //
    NDIS_STATUS Status;

    //
    // Length of the packet sent
    //
    ULONG Len;

    //
    // Temporary loopnig variable
    //
    UINT i;

    IF_VERY_LOUD( DbgPrint( "Ne2000XmitDpc entered\n" );)

    //
    // Verify that we are transmitting a packet
    //
    if ( Adapter->CurBufXmitting == -1 ) {

#if DBG
        DbgPrint( "Ne2000HandleXmitComplete called with nothing transmitting!\n" );
#endif

        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_DRIVER_FAILURE,
            1,
            NE2000_ERRMSG_HANDLE_XMIT_COMPLETE
            );

        return;
    }

    IF_LOG( Ne2000Log('C');)

    //
    // Get the status of the transmit
    //
    SyncCardGetXmitStatus((PVOID)Adapter);

    //
    // Statistics
    //
    if (Adapter->XmitStatus & TSR_XMIT_OK) {

        Adapter->FramesXmitGood++;
        Status = NDIS_STATUS_SUCCESS;

    } else {

        Adapter->FramesXmitBad++;
        Status = NDIS_STATUS_FAILURE;

    }

    //
    // Mark the current transmit as done.
    //
    Len = (Adapter->PacketLens[Adapter->CurBufXmitting] + 255) >> 8;

    ASSERT (Len != 0);

    //
    // Free the transmit buffers
    //
    for (i = Adapter->CurBufXmitting; i < Adapter->CurBufXmitting + Len; i++) {

        Adapter->BufferStatus[i] = EMPTY;

    }

    //
    // Set the next buffer to start transmitting.
    //
    Adapter->NextBufToXmit += Len;

    if (Adapter->NextBufToXmit == MAX_XMIT_BUFS) {

        Adapter->NextBufToXmit = 0;

    }

    if (Adapter->BufferStatus[Adapter->NextBufToXmit] == EMPTY &&
        Adapter->NextBufToFill != Adapter->NextBufToXmit) {

        Adapter->NextBufToXmit = 0;

    }

    //
    // Remove the packet from the outstanding packet list.
    //
    Packet = Adapter->Packets[Adapter->CurBufXmitting];
    Adapter->Packets[Adapter->CurBufXmitting] = (PNDIS_PACKET)NULL;

    //
    // See what to do next.
    //

    switch (Adapter->BufferStatus[Adapter->NextBufToXmit]) {


    case FULL:

        //
        // The next packet is ready to go -- only happens with
        // more than one transmit buffer.
        //

        IF_LOUD( DbgPrint( " next packet ready to go\n" );)

        //
        // Start the transmission and check for more.
        //

        Adapter->CurBufXmitting = Adapter->NextBufToXmit;

        IF_LOG( Ne2000Log('2');)

        //
        // This is used to check if stopping the chip prevented
        // a transmit complete interrupt from coming through (it
        // is cleared in the ISR if a transmit DPC is queued).
        //

        Adapter->TransmitInterruptPending = TRUE;

        IF_LOG( Ne2000Log('6'); )
        CardStartXmit(Adapter);

        break;

    case EMPTY:

        //
        // No packet is ready to transmit.
        //

        IF_LOUD( DbgPrint( " next packet empty\n" );)

        Adapter->CurBufXmitting = (XMIT_BUF)-1;

        break;

    }

    //
    // Start next send
    //

    Ne2000DoNextSend(Adapter);

    IF_VERY_LOUD( DbgPrint( "Ne2000XmitDpc exiting\n" );)

}


BOOLEAN
Ne2000PacketOK(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Reads a packet off the card -- checking if the CRC is good.  This is
    a workaround for a bug where bytes in the data portion of the packet
    are shifted either left or right by two in some weird 8390 cases.

    This routine is a combination of Ne2000TransferData (to copy up data
    from the card), CardCalculateCrc and CardCalculatePacketCrc.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE if the packet seems ok, else false.

--*/

{

    //
    // Length of the packet
    //
    UINT PacketLen;

    //
    // Guess at where the packet is located
    //
    PUCHAR PacketLoc;

    //
    // Header Validation Variables
    //
    BOOLEAN FrameAlign;
    PUCHAR PacketRcvStatus;
    PUCHAR NextPacket;
    PUCHAR PacketLenLo;
    PUCHAR PacketLenHi;
    PUCHAR ReceiveDestAddrLo;
    UINT FrameAlignCount;
    UCHAR OldPacketLenHi;
    UCHAR TempPacketHeader[6];
    PUCHAR BeginPacketHeader;

    //
    // First copy up the four-byte header the card attaches
    // plus first two bytes of the data packet (which contain
    // the destination address of the packet).  We use the extra
    // two bytes in case the packet was shifted right 1 or 2 bytes
    //
    PacketLoc = Adapter->PageStart +
        256*(Adapter->NicNextPacket-Adapter->NicPageStart);

    if (!CardCopyUp(Adapter, TempPacketHeader, PacketLoc, 6)) {

        return FALSE;

    }
    PacketLoc += 4;

    //
    // Validate the header
    //
    FrameAlignCount = 0;
    BeginPacketHeader = TempPacketHeader;

    //
    // Sometimes the Ne2000 will misplace a packet and shift the
    // entire packet and header by a byte, either up by 1 or 2 bytes.
    // This loop will look for the packet in the expected place,
    // and then shift up in an effort to find the packet.
    //
    do {

        //
        // Set where we think the packet is
        //
        PacketRcvStatus = BeginPacketHeader;
        NextPacket = BeginPacketHeader + 1;
        PacketLenLo = BeginPacketHeader + 2;
        PacketLenHi = BeginPacketHeader + 3;
        OldPacketLenHi = *PacketLenHi;
        ReceiveDestAddrLo = BeginPacketHeader + 4;
        FrameAlign = FALSE;

        //
        // Check if the status makes sense as is.
        //
        if (*PacketRcvStatus & 0x05E){

            FrameAlign = TRUE;

        } else if ((*PacketRcvStatus & RSR_MULTICAST)   // If a multicast packet
                     && (!FrameAlignCount)              // and hasn't been aligned
                     && !(*ReceiveDestAddrLo & 1)       // and lsb is set on dest addr
                  ){

            FrameAlign = TRUE;

        } else {

            //
            // Compare high and low address bytes.  If the same, the low
            // byte may have been copied into the high byte.
            //

            if (*PacketLenLo == *PacketLenHi){

                //
                // Save the old packetlenhi
                //
                OldPacketLenHi = *PacketLenHi;

                //
                // Compute new packet length
                //
                *PacketLenHi = *NextPacket - Adapter->NicNextPacket - 1;

                if (*PacketLenHi < 0) {

                    *PacketLenHi = (Adapter->NicPageStop - Adapter->NicNextPacket) +
                        (*NextPacket - Adapter->NicPageStart) - 1;

                }

                if (*PacketLenLo > 0xFC) {

                    *PacketLenHi++;
                }

            }

            PacketLen = (*PacketLenLo) + ((*PacketLenHi)*256) - 4;

            //
            // Does it make sense?
            //
            if ((PacketLen > 1514) || (PacketLen < 60)){

                //
                // Bad length.  Restore the old packetlenhi
                //
                *PacketLenHi = OldPacketLenHi;

                FrameAlign = TRUE;

            }

            //
            // Did we recover the frame?
            //
            if (!FrameAlign && ((*NextPacket < Adapter->NicPageStart) ||
                (*NextPacket > Adapter->NicPageStop))) {

                IF_LOUD( DbgPrint ("Packet address invalid in HeaderValidation\n"); )

                FrameAlign = TRUE;

            }

        }

        //
        // FrameAlignment - if first time through, shift packetheader right 1 or 2 bytes.
        // If second time through, shift it back to where it was and let it through.
        // This compensates for a known bug in the 8390D chip.
        //
        if (FrameAlign){

            switch (FrameAlignCount){

            case 0:

                BeginPacketHeader++;
                PacketLoc++;
                if (!Adapter->EightBitSlot){

                    BeginPacketHeader++;
                    PacketLoc++;

                }
                break;

            case 1:

                BeginPacketHeader--;
                PacketLoc--;
                if (!Adapter->EightBitSlot){
                    BeginPacketHeader--;
                    PacketLoc--;
                }
                break;

            }

            FrameAlignCount++;

        }

    } while ( (FrameAlignCount < 2) && FrameAlign );

    //
    // Now grab the packet header information
    //
    Adapter->PacketHeader[0] = *BeginPacketHeader;
    BeginPacketHeader++;
    Adapter->PacketHeader[1] = *BeginPacketHeader;
    BeginPacketHeader++;
    Adapter->PacketHeader[2] = *BeginPacketHeader;
    BeginPacketHeader++;
    Adapter->PacketHeader[3] = *BeginPacketHeader;

    //
    // Packet length is in bytes 3 and 4 of the header.
    //
    Adapter->PacketHeaderLoc = PacketLoc;
    PacketLen = (Adapter->PacketHeader[2]) + ((Adapter->PacketHeader[3])*256) - 4;

    //
    // Sanity check the packet
    //
    if ((PacketLen > 1514) || (PacketLen < 60)){

        if ((Adapter->PacketHeader[1] < Adapter->NicPageStart) ||
            (Adapter->PacketHeader[1] > Adapter->NicPageStop)) {

            //
            // Return TRUE here since IndicatePacket will notice the error
            // and handle it correctly.
            //
            return(TRUE);

        }

        return(FALSE);

    }

    return(TRUE);
}


INDICATE_STATUS
Ne2000IndicatePacket(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Indicates the first packet on the card to the protocols.

    NOTE: For MP, non-x86 architectures, this assumes that the packet has been
    read from the card and into Adapter->PacketHeader and Adapter->Lookahead.

    NOTE: For UP x86 systems this assumes that the packet header has been
    read into Adapter->PacketHeader and the minimal lookahead stored in
    Adapter->Lookahead

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    CARD_BAD if the card should be reset;
    INDICATE_OK otherwise.

--*/

{
    //
    // Length of the packet
    //
    UINT PacketLen;

    //
    // Length of the lookahead buffer
    //
    UINT IndicateLen;

    //
    // Variables for checking if the packet header looks valid
    //
    UCHAR PossibleNextPacket1, PossibleNextPacket2;

    //
    // Check if the next packet byte agress with the length, as
    // described on p. A-3 of the Etherlink II Technical Reference.
    // The start of the packet plus the MSB of the length must
    // be equal to the start of the next packet minus one or two.
    // Otherwise the header is considered corrupted, and the
    // card must be reset.
    //

    PossibleNextPacket1 =
                Adapter->NicNextPacket + Adapter->PacketHeader[3] + (UCHAR)1;

    if (PossibleNextPacket1 >= Adapter->NicPageStop) {

        PossibleNextPacket1 -= (Adapter->NicPageStop - Adapter->NicPageStart);

    }

    if (PossibleNextPacket1 != Adapter->PacketHeader[1]) {

        PossibleNextPacket2 = PossibleNextPacket1+(UCHAR)1;

        if (PossibleNextPacket2 == Adapter->NicPageStop) {

            PossibleNextPacket2 = Adapter->NicPageStart;

        }

        if (PossibleNextPacket2 != Adapter->PacketHeader[1]) {

            IF_LOUD( DbgPrint("First CARD_BAD check failed\n"); )
            return SKIPPED;
        }

    }

    //
    // Check that the Next is valid
    //
    if ((Adapter->PacketHeader[1] < Adapter->NicPageStart) ||
        (Adapter->PacketHeader[1] > Adapter->NicPageStop)) {

        IF_LOUD( DbgPrint("Second CARD_BAD check failed\n"); )
        return(SKIPPED);

    }

    //
    // Sanity check the length
    //
    PacketLen = Adapter->PacketHeader[2] + Adapter->PacketHeader[3]*256 - 4;

    if (PacketLen > 1514) {
        IF_LOUD( DbgPrint("Third CARD_BAD check failed\n"); )
        return(SKIPPED);

    }

#if DBG

    IF_NE2000DEBUG( NE2000_DEBUG_WORKAROUND1 ) {
        //
        // Now check for the high order 2 bits being set, as described
        // on page A-2 of the Etherlink II Technical Reference. If either
        // of the two high order bits is set in the receive status byte
        // in the packet header, the packet should be skipped (but
        // the adapter does not need to be reset).
        //

        if (Adapter->PacketHeader[0] & (RSR_DISABLED|RSR_DEFERRING)) {

            IF_LOUD (DbgPrint("H");)

            return SKIPPED;

        }

    }

#endif

    //
    // Lookahead amount to indicate
    //
    IndicateLen = (PacketLen > (Adapter->MaxLookAhead + NE2000_HEADER_SIZE)) ?
                           (Adapter->MaxLookAhead + NE2000_HEADER_SIZE) :
                           PacketLen;

    //
    // Indicate packet
    //

    Adapter->PacketLen = PacketLen;

    if (IndicateLen < NE2000_HEADER_SIZE) {

        //
        // Runt Packet
        //

        NdisMEthIndicateReceive(
                Adapter->MiniportAdapterHandle,
                (NDIS_HANDLE)Adapter,
                (PCHAR)(Adapter->Lookahead),
                IndicateLen,
                NULL,
                0,
                0
                );

    } else {

        NdisMEthIndicateReceive(
                Adapter->MiniportAdapterHandle,
                (NDIS_HANDLE)Adapter,
                (PCHAR)(Adapter->Lookahead),
                NE2000_HEADER_SIZE,
                (PCHAR)(Adapter->Lookahead) + NE2000_HEADER_SIZE,
                IndicateLen - NE2000_HEADER_SIZE,
                PacketLen - NE2000_HEADER_SIZE
                );

    }

    Adapter->IndicateReceiveDone = TRUE;

    return INDICATE_OK;
}


NDIS_STATUS
Ne2000TransferData(
    OUT PNDIS_PACKET Packet,
    OUT PUINT BytesTransferred,
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportReceiveContext,
    IN UINT ByteOffset,
    IN UINT BytesToTransfer
    )

/*++

Routine Description:

    A protocol calls the Ne2000TransferData request (indirectly via
    NdisTransferData) from within its Receive event handler
    to instruct the driver to copy the contents of the received packet
    a specified packet buffer.

Arguments:

    MiniportAdapterContext - Context registered with the wrapper, really
        a pointer to the adapter.

    MiniportReceiveContext - The context value passed by the driver on its call
    to NdisMEthIndicateReceive.  The driver can use this value to determine
    which packet, on which adapter, is being received.

    ByteOffset - An unsigned integer specifying the offset within the
    received packet at which the copy is to begin.  If the entire packet
    is to be copied, ByteOffset must be zero.

    BytesToTransfer - An unsigned integer specifying the number of bytes
    to copy.  It is legal to transfer zero bytes; this has no effect.  If
    the sum of ByteOffset and BytesToTransfer is greater than the size
    of the received packet, then the remainder of the packet (starting from
    ByteOffset) is transferred, and the trailing portion of the receive
    buffer is not modified.

    Packet - A pointer to a descriptor for the packet storage into which
    the MAC is to copy the received packet.

    BytesTransfered - A pointer to an unsigned integer.  The MAC writes
    the actual number of bytes transferred into this location.  This value
    is not valid if the return status is STATUS_PENDING.

Notes:

  - The MacReceiveContext will be a pointer to the open block for
    the packet.

--*/

{
    //
    // Variables for the number of bytes to copy, how much can be
    // copied at this moment, and the total number of bytes to copy.
    //
    UINT BytesLeft, BytesNow, BytesWanted;

    //
    // Current NDIS_BUFFER to copy into
    //
    PNDIS_BUFFER CurBuffer;

    //
    // Virtual address of the buffer.
    //
    XMIT_BUF NextBufToXmit;
    PUCHAR BufStart;

    //
    // Length and offset into the buffer.
    //
    UINT BufLen, BufOff;

    //
    // The adapter to transfer from.
    //
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)MiniportReceiveContext);

    IF_LOG( Ne2000Log('t');)

    //
    // Add the packet header onto the offset.
    //
    ByteOffset += NE2000_HEADER_SIZE;

    //
    // See how much data there is to transfer.
    //
    if (ByteOffset+BytesToTransfer > Adapter->PacketLen) {

        if (Adapter->PacketLen < ByteOffset) {

            *BytesTransferred = 0;
            IF_LOG( Ne2000Log('T');)
            return(NDIS_STATUS_FAILURE);
        }

        BytesWanted = Adapter->PacketLen - ByteOffset;

    } else {

        BytesWanted = BytesToTransfer;

    }

    //
    // Set the number of bytes left to transfer
    //
    BytesLeft = BytesWanted;

    {

        //
        // Address on the adapter to copy from
        //
        PUCHAR CurCardLoc;

        //
        // Copy data from the card -- it is not completely stored in the
        // adapter structure.
        //
        // Determine where the copying should start.
        //
        CurCardLoc = Adapter->PacketHeaderLoc + ByteOffset;

        if (CurCardLoc > Adapter->PageStop) {

            CurCardLoc = CurCardLoc - (Adapter->PageStop - Adapter->PageStart);

        }

        //
        // Get location to copy into
        //
        NdisQueryPacket(Packet, NULL, NULL, &CurBuffer, NULL);

        NdisQueryBuffer(CurBuffer, (PVOID *)&BufStart, &BufLen);

        BufOff = 0;

        //
        // Loop, filling each buffer in the packet until there
        // are no more buffers or the data has all been copied.
        //
        while (BytesLeft > 0) {

            //
            // See how much data to read into this buffer.
            //

            if ((BufLen-BufOff) > BytesLeft) {

                BytesNow = BytesLeft;

            } else {

                BytesNow = (BufLen - BufOff);

            }

            //
            // See if the data for this buffer wraps around the end
            // of the receive buffers (if so filling this buffer
            // will use two iterations of the loop).
            //

            if (CurCardLoc + BytesNow > Adapter->PageStop) {

                BytesNow = (UINT)(Adapter->PageStop - CurCardLoc);

            }

            //
            // Copy up the data.
            //

            if (!CardCopyUp(Adapter, BufStart+BufOff, CurCardLoc, BytesNow)) {

                *BytesTransferred = BytesWanted - BytesLeft;

                NdisWriteErrorLogEntry(
                    Adapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_HARDWARE_FAILURE,
                    1,
                    0x2
                    );

                return(NDIS_STATUS_FAILURE);

            }

            //
            // Update offsets and counts
            //
            CurCardLoc += BytesNow;
            BytesLeft -= BytesNow;

            //
            // Is the transfer done now?
            //
            if (BytesLeft == 0) {

                break;

            }

            //
            // Wrap around the end of the receive buffers?
            //
            if (CurCardLoc == Adapter->PageStop) {

                CurCardLoc = Adapter->PageStart;

            }

            //
            // Was the end of this packet buffer reached?
            //
            BufOff += BytesNow;

            if (BufOff == BufLen) {

                NdisGetNextBuffer(CurBuffer, &CurBuffer);

                if (CurBuffer == (PNDIS_BUFFER)NULL) {

                    break;

                }

                NdisQueryBuffer(CurBuffer, (PVOID *)&BufStart, &BufLen);

                BufOff = 0;

            }

        }

        *BytesTransferred = BytesWanted - BytesLeft;

        //
        // Did a transmit complete while we were doing what we were doing?
        //
        if (!Adapter->BufferOverflow && Adapter->CurBufXmitting != -1) {

            ULONG Len;
            UINT i;
            UCHAR Status;
            PNDIS_PACKET Packet;
            NDIS_STATUS NdisStatus;

            //
            // Check if it completed
            //
            CardGetInterruptStatus(Adapter, &Status);

            if (Status & ISR_XMIT_ERR) {
                OctogmetusceratorRevisited(Adapter);
                Adapter->InterruptStatus &= ~ISR_XMIT_ERR;
                NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, (ISR_XMIT_ERR));
                Status &= ~ISR_XMIT_ERR;

            }

            if (Status & (ISR_XMIT)) {


                IF_LOG( Ne2000Log('*'); )


                //
                // Update NextBufToXmit
                //
                Len = (Adapter->PacketLens[Adapter->CurBufXmitting] + 255) >> 8;
                NextBufToXmit = Adapter->NextBufToXmit + Len;

//                Adapter->NextBufToXmit += Len;

                if (NextBufToXmit == MAX_XMIT_BUFS) {
                    NextBufToXmit = 0;
                }

                if (Adapter->BufferStatus[NextBufToXmit] == EMPTY &&
                    Adapter->NextBufToFill != NextBufToXmit) {
                    NextBufToXmit = 0;
                }


                //
                // If the next packet is ready to go, start it.
                //
                if (Adapter->BufferStatus[NextBufToXmit] == FULL) {

                    //
                    // Ack the transmit
                    //

                    //
                    // Remove the packet from the packet list.
                    //
                    Adapter->NextBufToXmit = NextBufToXmit;
                    Packet = Adapter->Packets[Adapter->CurBufXmitting];
                    Adapter->Packets[Adapter->CurBufXmitting] = (PNDIS_PACKET)NULL;
                    SyncCardGetXmitStatus((PVOID)Adapter);


                    //
                    // Statistics
                    //
                    if (Adapter->XmitStatus & TSR_XMIT_OK) {

                        Adapter->FramesXmitGood++;
                        NdisStatus = NDIS_STATUS_SUCCESS;

                    } else {

                        Adapter->FramesXmitBad++;
                        NdisStatus = NDIS_STATUS_FAILURE;

                    }

                    for (i = Adapter->CurBufXmitting; i < Adapter->CurBufXmitting + Len; i++) {
                        Adapter->BufferStatus[i] = EMPTY;
                    }
                    Adapter->TransmitInterruptPending = FALSE;
                    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, (ISR_XMIT));
                    Adapter->CurBufXmitting = Adapter->NextBufToXmit;
                    Adapter->TransmitInterruptPending = TRUE;

                    IF_LOG( Ne2000Log('8'); )
                    Adapter->InterruptStatus &= ~(ISR_XMIT);
                    CardStartXmit(Adapter);

                } else {
                    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, (ISR_XMIT));
                    Adapter->InterruptStatus |= (Status);

                }

            }

        }

        return(NDIS_STATUS_SUCCESS);

    }

}


NDIS_STATUS
Ne2000Send(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet,
    IN UINT Flags
    )

/*++

Routine Description:


    The Ne2000Send request instructs a driver to transmit a packet through
    the adapter onto the medium.

Arguments:

    MiniportAdapterContext - Context registered with the wrapper, really
        a pointer to the adapter.

    Packet - A pointer to a descriptor for the packet that is to be
    transmitted.

    SendFlags - Optional send flags

Notes:

    This miniport driver will always accept a send.  This is because
    the Ne2000 has limited send resources and the driver needs packets
    to copy to the adapter immediately after a transmit completes in
    order to keep the adapter as busy as possible.

    This is not required for other adapters, as they have enough
    resources to keep the transmitter busy until the wrapper submits
    the next packet.

--*/

{
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)(MiniportAdapterContext);

    //
    // Put the packet on the send queue.
    //
    if (Adapter->FirstPacket == NULL) {
        Adapter->FirstPacket = Packet;
    } else {
        RESERVED(Adapter->LastPacket)->Next = Packet;
    }

    RESERVED(Packet)->Next = NULL;

    Adapter->LastPacket = Packet;

    //
    // Process the next send
    //
    Ne2000DoNextSend(Adapter);
    return(NDIS_STATUS_PENDING);

}

VOID
Ne2000DoNextSend(
    PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    This routine examines if the packet at the head of the packet
    list can be copied to the adapter, and does so.

Arguments:

    Adapter - Pointer to the adapter block.

Return Value:

    None

--*/

{
    //
    // The packet to process.
    //
    PNDIS_PACKET Packet;

    //
    // The current destination transmit buffer.
    //
    XMIT_BUF TmpBuf1;

    //
    // Length of the packet
    //
    ULONG Len;

    //
    // Temporary looping variable
    //
    ULONG i;

    IF_LOG( Ne2000Log('s'); )

    //
    // Check if we have enough resources and a packet to process
    //
    while((Adapter->FirstPacket != NULL) &&
          (Adapter->BufferStatus[Adapter->NextBufToFill] == EMPTY)) {

        //
        // Get the length of the packet.
        //
        NdisQueryPacket(
            Adapter->FirstPacket,
            NULL,
            NULL,
            NULL,
            &Len
            );

        //
        // Convert length to the number of transmit buffers needed.
        //
        Len = (Len + 255) >> 8;

        //
        // If not transmitting
        //
        if (Adapter->CurBufXmitting == -1) {

            //
            // Then check from the next free buffer if the packet will
            // fit.
            //
            if (Adapter->BufferStatus[Adapter->NextBufToXmit] == EMPTY) {

                //
                // It won't fit at the end, so put it at the first buffer
                //
                if (Adapter->NextBufToFill + Len > MAX_XMIT_BUFS) {

                    Adapter->NextBufToFill = 0;

                }

            } else {

                //
                // Check if this packet will fit before the packet on the
                // adapter.
                //
                if (Adapter->NextBufToXmit > Adapter->NextBufToFill) {

                    if (Adapter->NextBufToFill + Len > Adapter->NextBufToXmit) {

                        IF_LOG( Ne2000Log('^'); )
                        IF_LOG( Ne2000Log('S'); )

                        break;

                    }

                } else {

                    //
                    // Check if it will fit after the packet already on the
                    // adapter.
                    //
                    if (Adapter->NextBufToFill + Len > MAX_XMIT_BUFS) {

                        Adapter->NextBufToFill = 0;

                        if (Adapter->NextBufToFill + Len > Adapter->NextBufToXmit){

                            IF_LOG( Ne2000Log('%'); )
                            IF_LOG( Ne2000Log('S'); )

                            break;

                        }

                    }

                }

            }

        } else {

            //
            // Check if the packet will fit before the packet currently
            // transmitting
            //

            if (Adapter->CurBufXmitting > Adapter->NextBufToFill) {

                if (Adapter->NextBufToFill + Len > Adapter->CurBufXmitting) {

                    IF_LOG( Ne2000Log('$'); )
                    IF_LOG( Ne2000Log('S'); )

                    break;
                }

            } else {

                //
                // Check if it will fit after the packet currently transmitting
                //
                if (Adapter->NextBufToFill + Len > MAX_XMIT_BUFS) {

                    Adapter->NextBufToFill = 0;

                    if (Adapter->NextBufToFill + Len > Adapter->CurBufXmitting){

                        IF_LOG( Ne2000Log('!'); )
                        IF_LOG( Ne2000Log('S'); )
                        break;

                    }

                }

            }

        }

        //
        // Set starting location
        //
        TmpBuf1 = Adapter->NextBufToFill;

        //
        // Remove the packet from the queue.
        //
        Packet = Adapter->FirstPacket;
        Adapter->FirstPacket = RESERVED(Packet)->Next;

        if (Packet == Adapter->LastPacket) {
            Adapter->LastPacket = NULL;
        }

        //
        // Store the packet in the list
        //
        Adapter->Packets[TmpBuf1] = Packet;

        //
        // Copy down the packet.
        //
        if (CardCopyDownPacket(Adapter, Packet,
                        &Adapter->PacketLens[TmpBuf1]) == FALSE) {

            for (i = TmpBuf1; i < TmpBuf1 + Len; i++) {
                Adapter->BufferStatus[i] = EMPTY;
            }
            Adapter->Packets[TmpBuf1] = NULL;
            IF_LOG( Ne2000Log('F'); )
            IF_LOG( Ne2000Log('S'); )

            NdisMSendComplete(
                Adapter->MiniportAdapterHandle,
                Packet,
                NDIS_STATUS_FAILURE
                );

            continue;

        }

        //
        // Pad short packets with blanks.
        //
        if (Adapter->PacketLens[TmpBuf1] < 60) {

            (VOID)CardCopyDown(
                    Adapter,
                    ((PUCHAR)Adapter->XmitStart +
                    TmpBuf1*TX_BUF_SIZE +
                    Adapter->PacketLens[TmpBuf1]),
                    BlankBuffer,
                    60-Adapter->PacketLens[TmpBuf1]
                    );

        }

        //
        // Set the buffer status
        //
        for (i = TmpBuf1; i < (TmpBuf1 + Len); i++) {
                Adapter->BufferStatus[i] = FULL;
        }

        //
        // Update next free buffer
        //
        Adapter->NextBufToFill += Len;

        if (Adapter->NextBufToFill == MAX_XMIT_BUFS) {
            Adapter->NextBufToFill = 0;
        }

        //
        // See whether to start the transmission.
        //
        if (Adapter->CurBufXmitting == -1) {

            //
            // OK to start transmission.
            //
            if (Adapter->BufferStatus[Adapter->NextBufToXmit] == EMPTY &&
                Adapter->NextBufToFill != Adapter->NextBufToXmit) {

                Adapter->NextBufToXmit = 0;

            }

            Adapter->CurBufXmitting = Adapter->NextBufToXmit;


            IF_LOG( Ne2000Log('4');)

            //
            // If we are currently handling an overflow, then we need to let
            // the overflow handler send this packet...
            //

            if (Adapter->BufferOverflow) {

                Adapter->OverflowRestartXmitDpc = TRUE;

                IF_LOG( Ne2000Log('O');)
                IF_LOUD( DbgPrint ("Adapter->OverflowRestartXmitDpc set:copy and send");)

            } else {

                //
                // This is used to check if stopping the chip prevented
                // a transmit complete interrupt from coming through (it
                // is cleared in the ISR if a transmit DPC is queued).
                //

                Adapter->TransmitInterruptPending = TRUE;

                IF_LOG( Ne2000Log('9'); )
                CardStartXmit(Adapter);

            }

        }

        //
        // Ack the send immediately.  If for some reason it
        // should fail, the protocol should be able to handle
        // the retransmit.
        //

        IF_LOG( Ne2000Log('S'); )

        NdisMSendComplete(
                Adapter->MiniportAdapterHandle,
                Packet,
                NDIS_STATUS_SUCCESS
                );
    }

}

VOID
OctogmetusceratorRevisited(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Recovers the card from a transmit error.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    None.

--*/

{

    IF_LOUD( DbgPrint("Octogmetuscerator called!"); )

    IF_LOG( Ne2000Log('y'); )

    //
    // Ack the interrupt, if needed
    //
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, ISR_XMIT_ERR);

    //
    // Stop the card
    //
    SyncCardStop(Adapter);

    //
    // Wait up to 1.6 milliseconds for any receives to finish
    //
    NdisStallExecution(2000);

    //
    // Place the card in Loopback
    //
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_XMIT_CONFIG, TCR_LOOPBACK);

    //
    // Start the card in Loopback
    //
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND, CR_START | CR_NO_DMA);

    //
    // Get out of loopback and start the card
    //
    CardStart(Adapter);

    //
    // If there was a packet waiting to get sent, send it.
    //
    if (Adapter->CurBufXmitting != -1) {

        Adapter->TransmitInterruptPending = TRUE;
        CardStartXmit(Adapter);

    }
    IF_LOG( Ne2000Log('Y'); )
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\ne2000\ne2000sw.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    ne2000sw.h

Abstract:

    The main header for an Novell 2000 Miniport driver.

Author:

    Sean Selitrennikoff

Environment:

    Architecturally, there is an assumption in this driver that we are
    on a little endian machine.

Notes:

    optional-notes

Revision History:

--*/

#ifndef _NE2000SFT_
#define _NE2000SFT_

#define NE2000_NDIS_MAJOR_VERSION 3
#define NE2000_NDIS_MINOR_VERSION 0

//
// This macro is used along with the flags to selectively
// turn on debugging.
//

#if DBG

#define IF_NE2000DEBUG(f) if (Ne2000DebugFlag & (f))
extern ULONG Ne2000DebugFlag;

#define NE2000_DEBUG_LOUD               0x00000001  // debugging info
#define NE2000_DEBUG_VERY_LOUD          0x00000002  // excessive debugging info
#define NE2000_DEBUG_LOG                0x00000004  // enable Ne2000Log
#define NE2000_DEBUG_CHECK_DUP_SENDS    0x00000008  // check for duplicate sends
#define NE2000_DEBUG_TRACK_PACKET_LENS  0x00000010  // track directed packet lens
#define NE2000_DEBUG_WORKAROUND1        0x00000020  // drop DFR/DIS packets
#define NE2000_DEBUG_CARD_BAD           0x00000040  // dump data if CARD_BAD
#define NE2000_DEBUG_CARD_TESTS         0x00000080  // print reason for failing

//
// Macro for deciding whether to print a lot of debugging information.
//

#define IF_LOUD(A) IF_NE2000DEBUG( NE2000_DEBUG_LOUD ) { A }
#define IF_VERY_LOUD(A) IF_NE2000DEBUG( NE2000_DEBUG_VERY_LOUD ) { A }

//
// Whether to use the Ne2000Log buffer to record a trace of the driver.
//
#define IF_LOG(A) IF_NE2000DEBUG( NE2000_DEBUG_LOG ) { A }
extern VOID Ne2000Log(UCHAR);

//
// Whether to do loud init failure
//
#define IF_INIT(A) A

//
// Whether to do loud card test failures
//
#define IF_TEST(A) IF_NE2000DEBUG( NE2000_DEBUG_CARD_TESTS ) { A }

#else

//
// This is not a debug build, so make everything quiet.
//
#define IF_LOUD(A)
#define IF_VERY_LOUD(A)
#define IF_LOG(A)
#define IF_INIT(A)
#define IF_TEST(A)

#endif




//
// Adapter->NumBuffers
//
// controls the number of transmit buffers on the packet.
// Choices are 1 through 12.
//

#define DEFAULT_NUMBUFFERS 12


//
// Create a macro for moving memory from place to place.  Makes
// the code more readable and portable in case we ever support
// a shared memory Ne2000 adapter.
//
#define NE2000_MOVE_MEM(dest,src,size) NdisMoveMemory(dest,src,size)

//
// The status of transmit buffers.
//

typedef enum {
    EMPTY = 0x00,
    FULL = 0x02
} BUFFER_STATUS;

//
// Type of an interrupt.
//

typedef enum {
    RECEIVE    = 0x01,
    TRANSMIT   = 0x02,
    OVERFLOW   = 0x04,
    COUNTER    = 0x08,
    UNKNOWN    = 0x10
} INTERRUPT_TYPE;

//
// Result of Ne2000IndicatePacket().
//
typedef enum {
    INDICATE_OK,
    SKIPPED,
    ABORT,
    CARD_BAD
} INDICATE_STATUS;



//
// Size of the ethernet header
//
#define NE2000_HEADER_SIZE 14

//
// Size of the ethernet address
//
#define NE2000_LENGTH_OF_ADDRESS 6

//
// Number of bytes allowed in a lookahead (max)
//
#define NE2000_MAX_LOOKAHEAD (252 - NE2000_HEADER_SIZE)

//
// Maximum number of transmit buffers on the card.
//
#define MAX_XMIT_BUFS   12

//
// Definition of a transmit buffer.
//
typedef UINT XMIT_BUF;

//
// Number of 256-byte buffers in a transmit buffer.
//
#define BUFS_PER_TX 1

//
// Size of a single transmit buffer.
//
#define TX_BUF_SIZE (BUFS_PER_TX*256)




//
// This structure contains information about the driver
// itself.  There is only have one of these structures.
//
typedef struct _DRIVER_BLOCK {

    //
    // NDIS wrapper information.
    //
    NDIS_HANDLE NdisMacHandle;          // returned from NdisRegisterMac
    NDIS_HANDLE NdisWrapperHandle;      // returned from NdisInitializeWrapper

    //
    // Adapters registered for this Miniport driver.
    //
    struct _NE2000_ADAPTER * AdapterQueue;

} DRIVER_BLOCK, * PDRIVER_BLOCK;



//
// This structure contains all the information about a single
// adapter that this driver is controlling.
//
typedef struct _NE2000_ADAPTER {

    //
    // This is the handle given by the wrapper for calling ndis
    // functions.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    //
    // Interrupt object.
    //
    NDIS_MINIPORT_INTERRUPT Interrupt;

    //
    // used by DriverBlock->AdapterQueue
    //
    struct _NE2000_ADAPTER * NextAdapter;

    //
    // This is a count of the number of receives that have been
    // indicated in a row.  This is used to limit the number
    // of sequential receives so that one can periodically check
    // for transmit complete interrupts.
    //
    ULONG ReceivePacketCount;

    //
    // Configuration information
    //

    //
    // Number of buffer in this adapter.
    //
    UINT NumBuffers;

    //
    // Physical address of the IoBaseAddress
    //
    PVOID IoBaseAddr;

    //
    // Interrupt number this adapter is using.
    //
    CHAR InterruptNumber;

    //
    // Number of multicast addresses that this adapter is to support.
    //
    UINT MulticastListMax;

    //
    // The type of bus that this adapter is running on.  Either ISA or
    // MCA.
    //
    UCHAR BusType;

    //
    // InterruptMode is whether the interrupt is latched or level sensitive
    //
    NDIS_INTERRUPT_MODE InterruptMode;
    
    //
    // Current status of the interrupt mask
    //
    BOOLEAN InterruptsEnabled;


    //
    //  Type of ne2000 card.
    //
    UINT    CardType;

    //
    //  Address of the memory window.
    //
    ULONG   AttributeMemoryAddress;
    ULONG   AttributeMemorySize;

    //
    // Transmit information.
    //

    //
    // The next available empty transmit buffer.
    //
    XMIT_BUF NextBufToFill;

    //
    // The next full transmit buffer waiting to transmitted.  This
    // is valid only if CurBufXmitting is -1
    //
    XMIT_BUF NextBufToXmit;

    //
    // This transmit buffer that is currently transmitting.  If none,
    // then the value is -1.
    //
    XMIT_BUF CurBufXmitting;

    //
    // TRUE if a transmit has been started, and have not received the
    // corresponding transmit complete interrupt.
    //
    BOOLEAN TransmitInterruptPending;

    //
    // TRUE if a receive buffer overflow occurs while a
    // transmit complete interrupt was pending.
    //
    BOOLEAN OverflowRestartXmitDpc;

    //
    // The current status of each transmit buffer.
    //
    BUFFER_STATUS BufferStatus[MAX_XMIT_BUFS];

    //
    // Used to map packets to transmit buffers and visa-versa.
    //
    PNDIS_PACKET Packets[MAX_XMIT_BUFS];

    //
    // The length of each packet in the Packets list.
    //
    UINT PacketLens[MAX_XMIT_BUFS];

    //
    // The first packet we have pending.
    //
    PNDIS_PACKET FirstPacket;

    //
    // The tail of the pending queue.
    //
    PNDIS_PACKET LastPacket;

    //
    // The address of the start of the transmit buffer space.
    //
    PUCHAR XmitStart;

    //
    // The address of the start of the receive buffer space.
    PUCHAR PageStart;

    //
    // The address of the end of the receive buffer space.
    //
    PUCHAR PageStop;

    //
    // Status of the last transmit.
    //
    UCHAR XmitStatus;

    //
    // The value to write to the adapter for the start of
    // the transmit buffer space.
    //
    UCHAR NicXmitStart;

    //
    // The value to write to the adapter for the start of
    // the receive buffer space.
    //
    UCHAR NicPageStart;

    //
    // The value to write to the adapter for the end of
    // the receive buffer space.
    //
    UCHAR NicPageStop;




    //
    // Receive information
    //

    //
    // The value to write to the adapter for the next receive
    // buffer that is free.
    //
    UCHAR NicNextPacket;

    //
    // The next receive buffer that will be filled.
    //
    UCHAR Current;

    //
    // Total length of a received packet.
    //
    UINT PacketLen;




    //
    // Operational information.
    //

    //
    // Mapped address of the base io port.
    //
    ULONG_PTR IoPAddr;

    //
    // InterruptStatus tracks interrupt sources that still need to be serviced,
    // it is the logical OR of all card interrupts that have been received and not
    // processed and cleared. (see also INTERRUPT_TYPE definition in ne2000.h)
    //
    UCHAR InterruptStatus;

    //
    // The ethernet address currently in use.
    //
    UCHAR StationAddress[NE2000_LENGTH_OF_ADDRESS];

    //
    // The ethernet address that is burned into the adapter.
    //
    UCHAR PermanentAddress[NE2000_LENGTH_OF_ADDRESS];

    //
    // The adapter space address of the start of on board memory.
    //
    PUCHAR RamBase;

    //
    // The number of K on the adapter.
    //
    ULONG RamSize;

    //
    // The current packet filter in use.
    //
    ULONG PacketFilter;

    //
    // TRUE if a receive buffer overflow occured.
    //
    BOOLEAN BufferOverflow;

    //
    // TRUE if the driver needs to call NdisMEthIndicateReceiveComplete
    //
    BOOLEAN IndicateReceiveDone;

    //
    // TRUE if this is an NE2000 in an eight bit slot.
    //
    BOOLEAN EightBitSlot;


    //
    // Statistics used by Set/QueryInformation.
    //

    ULONG FramesXmitGood;               // Good Frames Transmitted
    ULONG FramesRcvGood;                // Good Frames Received
    ULONG FramesXmitBad;                // Bad Frames Transmitted
    ULONG FramesXmitOneCollision;       // Frames Transmitted with one collision
    ULONG FramesXmitManyCollisions;     // Frames Transmitted with > 1 collision
    ULONG FrameAlignmentErrors;         // FAE errors counted
    ULONG CrcErrors;                    // CRC errors counted
    ULONG MissedPackets;                // missed packet counted

    //
    // Reset information.
    //

    UCHAR NicMulticastRegs[8];          // contents of card multicast registers
    UCHAR NicReceiveConfig;             // contents of NIC RCR
    UCHAR NicInterruptMask;             // contents of NIC IMR

    //
    // The lookahead buffer size in use.
    //
    ULONG MaxLookAhead;

    //
    // These are for the current packet being indicated.
    //

    //
    // The NIC appended header.  Used to find corrupted receive packets.
    //
    UCHAR PacketHeader[4];

    //
    // Ne2000 address of the beginning of the packet.
    //
    PUCHAR PacketHeaderLoc;

    //
    // Lookahead buffer
    //
    UCHAR Lookahead[NE2000_MAX_LOOKAHEAD + NE2000_HEADER_SIZE];

    //
    // List of multicast addresses in use.
    //
    CHAR Addresses[DEFAULT_MULTICASTLISTMAX][NE2000_LENGTH_OF_ADDRESS];

} NE2000_ADAPTER, * PNE2000_ADAPTER;



//
// Given a MiniportContextHandle return the PNE2000_ADAPTER
// it represents.
//
#define PNE2000_ADAPTER_FROM_CONTEXT_HANDLE(Handle) \
    ((PNE2000_ADAPTER)(Handle))

//
// Given a pointer to a NE2000_ADAPTER return the
// proper MiniportContextHandle.
//
#define CONTEXT_HANDLE_FROM_PNE2000_ADAPTER(Ptr) \
    ((NDIS_HANDLE)(Ptr))

//
// Macros to extract high and low bytes of a word.
//
#define MSB(Value) ((UCHAR)((((ULONG)Value) >> 8) & 0xff))
#define LSB(Value) ((UCHAR)(((ULONG)Value) & 0xff))

//
// What we map into the reserved section of a packet.
// Cannot be more than 8 bytes (see ASSERT in ne2000.c).
//
typedef struct _MINIPORT_RESERVED {
    PNDIS_PACKET Next;    // used to link in the queues (4 bytes)
} MINIPORT_RESERVED, * PMINIPORT_RESERVED;


//
// Retrieve the MINIPORT_RESERVED structure from a packet.
//
#define RESERVED(Packet) ((PMINIPORT_RESERVED)((Packet)->MiniportReserved))

//
// Procedures which log errors.
//

typedef enum _NE2000_PROC_ID {
    cardReset,
    cardCopyDownPacket,
    cardCopyDownBuffer,
    cardCopyUp
} NE2000_PROC_ID;


//
// Special error log codes.
//
#define NE2000_ERRMSG_CARD_SETUP          (ULONG)0x01
#define NE2000_ERRMSG_DATA_PORT_READY     (ULONG)0x02
#define NE2000_ERRMSG_HANDLE_XMIT_COMPLETE (ULONG)0x04

//
// Declarations for functions in ne2000.c.
//
NDIS_STATUS
Ne2000SetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    );

VOID
Ne2000Halt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
Ne2000Shutdown(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
Ne2000RegisterAdapter(
    IN PNE2000_ADAPTER Adapter,
    IN NDIS_HANDLE ConfigurationHandle,
    IN BOOLEAN ConfigError,
    IN ULONG ConfigErrorValue
    );

NDIS_STATUS
Ne2000Initialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE ConfigurationHandle
    );

NDIS_STATUS
Ne2000TransferData(
    OUT PNDIS_PACKET Packet,
    OUT PUINT BytesTransferred,
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportReceiveContext,
    IN UINT ByteOffset,
    IN UINT BytesToTransfer
    );

NDIS_STATUS
Ne2000Send(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet,
    IN UINT Flags
    );

NDIS_STATUS
Ne2000Reset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
Ne2000QueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );

VOID
Ne2000Halt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
OctogmetusceratorRevisited(
    IN PNE2000_ADAPTER Adapter
    );

NDIS_STATUS
DispatchSetPacketFilter(
    IN PNE2000_ADAPTER Adapter
    );

NDIS_STATUS
DispatchSetMulticastAddressList(
    IN PNE2000_ADAPTER Adapter
    );


//
// Interrup.c
//

VOID
Ne2000EnableInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
Ne2000DisableInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

VOID
Ne2000Isr(
    OUT PBOOLEAN InterruptRecognized,
    OUT PBOOLEAN QueueDpc,
    IN PVOID Context
    );

VOID
Ne2000HandleInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

BOOLEAN
Ne2000PacketOK(
    IN PNE2000_ADAPTER Adapter
    );

VOID
Ne2000XmitDpc(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
Ne2000RcvDpc(
    IN PNE2000_ADAPTER Adapter
    );


//
// Declarations of functions in card.c.
//

BOOLEAN
CardCheckParameters(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardInitialize(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardReadEthernetAddress(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardSetup(
    IN PNE2000_ADAPTER Adapter
    );

VOID
CardStop(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardTest(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardReset(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
CardCopyDownPacket(
    IN PNE2000_ADAPTER Adapter,
    IN PNDIS_PACKET Packet,
    OUT UINT * Length
    );

BOOLEAN
CardCopyDown(
    IN PNE2000_ADAPTER Adapter,
    IN PUCHAR TargetBuffer,
    IN PUCHAR SourceBuffer,
    IN UINT Length
    );

BOOLEAN
CardCopyUp(
    IN PNE2000_ADAPTER Adapter,
    IN PUCHAR Target,
    IN PUCHAR Source,
    IN UINT Length
    );

ULONG
CardComputeCrc(
    IN PUCHAR Buffer,
    IN UINT Length
    );

VOID
CardGetPacketCrc(
    IN PUCHAR Buffer,
    IN UINT Length,
    OUT UCHAR Crc[4]
    );

VOID
CardGetMulticastBit(
    IN UCHAR Address[NE2000_LENGTH_OF_ADDRESS],
    OUT UCHAR * Byte,
    OUT UCHAR * Value
    );

VOID
CardFillMulticastRegs(
    IN PNE2000_ADAPTER Adapter
    );

VOID
CardSetBoundary(
    IN PNE2000_ADAPTER Adapter
    );

VOID
CardStartXmit(
    IN PNE2000_ADAPTER Adapter
    );

BOOLEAN
SyncCardStop(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardGetXmitStatus(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardGetCurrent(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardSetReceiveConfig(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardSetAllMulticast(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardCopyMulticastRegs(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardSetInterruptMask(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardAcknowledgeOverflow(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardUpdateCounters(
    IN PVOID SynchronizeContext
    );

BOOLEAN
SyncCardHandleOverflow(
    IN PVOID SynchronizeContext
    );

/*++

Routine Description:

    Determines the type of the interrupt on the card. The order of
    importance is overflow, then transmit complete, then receive.
    Counter MSB is handled first since it is simple.

Arguments:

    Adapter - pointer to the adapter block

    InterruptStatus - Current Interrupt Status.

Return Value:

    The type of the interrupt

--*/
#define CARD_GET_INTERRUPT_TYPE(_A, _I)                 \
  (_I & ISR_COUNTER) ?                               \
      COUNTER :                                      \
      (_I & ISR_OVERFLOW ) ?                         \
      SyncCardUpdateCounters(_A), OVERFLOW :                 \
        (_I & (ISR_XMIT|ISR_XMIT_ERR)) ?           \
          TRANSMIT :                                     \
        (_I & ISR_RCV) ?                               \
          RECEIVE :                                  \
        (_I & ISR_RCV_ERR) ?                           \
              SyncCardUpdateCounters(_A), RECEIVE :  \
              UNKNOWN

#endif // NE2000SFT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\ne2000\precomp.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    precomp.h

Abstract:

    Precompile header file.

Author:

    Sean Selitrennikoff

Environment:

Notes:

    optional-notes

Revision History:

--*/

#include <ndis.h>
#include "ne2000hw.h"
#include "ne2000sw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\ms\ne2000\ne2000hw.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved

Module Name:

    ne2000hw.h

Abstract:

    Hardware definitions.

Author:

    Sean Selitrennikoff

Environment:

Notes:

    optional-notes

Revision History:

--*/

#ifndef _NE2000HARDWARE_
#define _NE2000HARDWARE_


//
// Definitions for supporting clone adapters.
//

//
// Valid value ranges for the IoBaseAddress.
//
#ifdef NE1000
#define MIN_IOBASEADDR 0x0200
#else
#define MIN_IOBASEADDR 0x0120
#endif

#define MAX_IOBASEADDR 0xc3d0



//
// Valid value ranges for the InterruptNumber.
//
#define MIN_IRQ 2

#ifdef NE1000
#define MAX_IRQ 9
#else
#define MAX_IRQ 15
#endif


//
//  Types of Ne2000 cards.
//
#define NE2000_ISA                  0
#define NE2000_PCMCIA               1

//
// ID for MCA Ne2000 clone cards
//
#define AE2_ADAPTER_ID               0x67b0
#define UB_ADAPTER_ID                0x611f
#define NE2_ADAPTER_ID               0x7154

//
// Microchannel IRQ POS register mask and shift count
//
#define MC_IRQ_MASK     0x60
#define MC_IRQ_MASK_UB  0x0E


//
// Microchannel I/O base address mask and shift count
//
#define MC_IO_BASE_MASK      0x0E
#define MC_IO_BASE_MASK_UB   0xE0

//
// Default value for Adapter->IoBaseAddr
//
#define DEFAULT_IOBASEADDR (PVOID)0x300

#define CIS_NET_ADDR_OFFSET 0xff0

//
// Default value for Adapter->InterruptNumber
//
#define DEFAULT_INTERRUPTNUMBER 3


//
// Default value for Adapter->MulticastListMax
//
#define DEFAULT_MULTICASTLISTMAX 8


//
// Offsets from Adapter->IoPAddr of the ports used to access
// the 8390 NIC registers.
//
// The names in parenthesis are the abbreviations by which
// the registers are referred to in the 8390 data sheet.
//
// Some of the offsets appear more than once
// because they have have relevant page 0 and page 1 values,
// or they are different registers when read than they are
// when written. The notation MSB indicates that only the
// MSB can be set for this register, the LSB is assumed 0.
//

#define NIC_COMMAND         0x0     // (CR)
#define NIC_PAGE_START      0x1     // (PSTART)   MSB, write-only
#define NIC_PHYS_ADDR       0x1     // (PAR0)     page 1
#define NIC_PAGE_STOP       0x2     // (PSTOP)    MSB, write-only
#define NIC_BOUNDARY        0x3     // (BNRY)     MSB
#define NIC_XMIT_START      0x4     // (TPSR)     MSB, write-only
#define NIC_XMIT_STATUS     0x4     // (TSR)      read-only
#define NIC_XMIT_COUNT_LSB  0x5     // (TBCR0)    write-only
#define NIC_XMIT_COUNT_MSB  0x6     // (TBCR1)    write-only
#define NIC_FIFO            0x6     // (FIFO)     read-only
#define NIC_INTR_STATUS     0x7     // (ISR)
#define NIC_CURRENT         0x7     // (CURR)     page 1
#define NIC_MC_ADDR         0x8     // (MAR0)     page 1
#define NIC_CRDA_LSB        0x8     // (CRDA0)
#define NIC_RMT_ADDR_LSB    0x8     // (RSAR0)
#define NIC_CRDA_MSB        0x9     // (CRDA1)
#define NIC_RMT_ADDR_MSB    0x9     // (RSAR1)
#define NIC_RMT_COUNT_LSB   0xa     // (RBCR0)    write-only
#define NIC_RMT_COUNT_MSB   0xb     // (RBCR1)    write-only
#define NIC_RCV_CONFIG      0xc     // (RCR)      write-only
#define NIC_RCV_STATUS      0xc     // (RSR)      read-only
#define NIC_XMIT_CONFIG     0xd     // (TCR)      write-only
#define NIC_FAE_ERR_CNTR    0xd     // (CNTR0)    read-only
#define NIC_DATA_CONFIG     0xe     // (DCR)      write-only
#define NIC_CRC_ERR_CNTR    0xe     // (CNTR1)    read-only
#define NIC_INTR_MASK       0xf     // (IMR)      write-only
#define NIC_MISSED_CNTR     0xf     // (CNTR2)    read-only
#define NIC_RACK_NIC        0x10    // Byte to read or write
#define NIC_RESET           0x1f    // (RESET)


//
// Constants for the NIC_COMMAND register.
//
// Start/stop the card, start transmissions, and select
// which page of registers was seen through the ports.
//

#define CR_STOP         (UCHAR)0x01        // reset the card
#define CR_START        (UCHAR)0x02        // start the card
#define CR_XMIT         (UCHAR)0x04        // begin transmission
#define CR_NO_DMA       (UCHAR)0x20        // stop remote DMA

#define CR_PS0          (UCHAR)0x40        // low bit of page number
#define CR_PS1          (UCHAR)0x80        // high bit of page number
#define CR_PAGE0        (UCHAR)0x00        // select page 0
#define CR_PAGE1        CR_PS0             // select page 1
#define CR_PAGE2        CR_PS1             // select page 2

#define CR_DMA_WRITE    (UCHAR)0x10        // Write
#define CR_DMA_READ     (UCHAR)0x08        // Read
#define CR_SEND         (UCHAR)0x18        // send


//
// Constants for the NIC_XMIT_STATUS register.
//
// Indicate the result of a packet transmission.
//

#define TSR_XMIT_OK     (UCHAR)0x01        // transmit with no errors
#define TSR_COLLISION   (UCHAR)0x04        // collided at least once
#define TSR_ABORTED     (UCHAR)0x08        // too many collisions
#define TSR_NO_CARRIER  (UCHAR)0x10        // carrier lost
#define TSR_NO_CDH      (UCHAR)0x40        // no collision detect heartbeat


//
// Constants for the NIC_INTR_STATUS register.
//
// Indicate the cause of an interrupt.
//

#define ISR_EMPTY       (UCHAR)0x00        // no bits set in ISR
#define ISR_RCV         (UCHAR)0x01        // packet received with no errors
#define ISR_XMIT        (UCHAR)0x02        // packet transmitted with no errors
#define ISR_RCV_ERR     (UCHAR)0x04        // error on packet reception
#define ISR_XMIT_ERR    (UCHAR)0x08        // error on packet transmission
#define ISR_OVERFLOW    (UCHAR)0x10        // receive buffer overflow
#define ISR_COUNTER     (UCHAR)0x20        // MSB set on tally counter
#define ISR_DMA_DONE    (UCHAR)0x40        // RDC
#define ISR_RESET       (UCHAR)0x80        // (not an interrupt) card is reset


//
// Constants for the NIC_RCV_CONFIG register.
//
// Configure what type of packets are received.
//

#define RCR_REJECT_ERR  (UCHAR)0x00        // reject error packets
#define RCR_BROADCAST   (UCHAR)0x04        // receive broadcast packets
#define RCR_MULTICAST   (UCHAR)0x08        // receive multicast packets
#define RCR_ALL_PHYS    (UCHAR)0x10        // receive ALL directed packets
#define RCR_MONITOR     (UCHAR)0x20        // don't collect packets


//
// Constants for the NIC_RCV_STATUS register.
//
// Indicate the status of a received packet.
//
// These are also used to interpret the status byte in the
// packet header of a received packet.
//

#define RSR_PACKET_OK   (UCHAR)0x01        // packet received with no errors
#define RSR_CRC_ERROR   (UCHAR)0x02        // packet received with CRC error
#define RSR_MULTICAST   (UCHAR)0x20        // packet received was multicast
#define RSR_DISABLED    (UCHAR)0x40        // received is disabled
#define RSR_DEFERRING   (UCHAR)0x80        // receiver is deferring


//
// Constants for the NIC_XMIT_CONFIG register.
//
// Configures how packets are transmitted.
//

#define TCR_NO_LOOPBACK (UCHAR)0x00        // normal operation
#define TCR_LOOPBACK    (UCHAR)0x02        // loopback (set when NIC is stopped)

#define TCR_INHIBIT_CRC (UCHAR)0x01        // inhibit appending of CRC

#define TCR_NIC_LBK     (UCHAR)0x02        // loopback through the NIC
#define TCR_SNI_LBK     (UCHAR)0x04        // loopback through the SNI
#define TCR_COAX_LBK    (UCHAR)0x06        // loopback to the coax


//
// Constants for the NIC_DATA_CONFIG register.
//
// Set data transfer sizes.
//

#define DCR_BYTE_WIDE   (UCHAR)0x00        // byte-wide DMA transfers
#define DCR_WORD_WIDE   (UCHAR)0x01        // word-wide DMA transfers

#define DCR_LOOPBACK    (UCHAR)0x00        // loopback mode (TCR must be set)
#define DCR_NORMAL      (UCHAR)0x08        // normal operation

#define DCR_FIFO_2_BYTE (UCHAR)0x00        // 2-byte FIFO threshhold
#define DCR_FIFO_4_BYTE (UCHAR)0x20        // 4-byte FIFO threshhold
#define DCR_FIFO_8_BYTE (UCHAR)0x40        // 8-byte FIFO threshhold
#define DCR_FIFO_12_BYTE (UCHAR)0x60       // 12-byte FIFO threshhold
#define DCR_AUTO_INIT   (UCHAR)0x10        // Auto-init to remove packets from ring


//
// Constants for the NIC_INTR_MASK register.
//
// Configure which ISR settings actually cause interrupts.
//

#define IMR_RCV         (UCHAR)0x01        // packet received with no errors
#define IMR_XMIT        (UCHAR)0x02        // packet transmitted with no errors
#define IMR_RCV_ERR     (UCHAR)0x04        // error on packet reception
#define IMR_XMIT_ERR    (UCHAR)0x08        // error on packet transmission
#define IMR_OVERFLOW    (UCHAR)0x10        // receive buffer overflow
#define IMR_COUNTER     (UCHAR)0x20        // MSB set on tally counter


//++
//
// VOID
// CardStart(
//    IN PNE2000_ADAPTER Adapter
//    )
//
//
// Routine Description:
//
//    Starts the card.
//
// Arguments:
//
//    Adapter - pointer to the adapter block
//
// Return Value:
//
//    None.
//
//--
    //
    // Assume that the card has been stopped as in CardStop.
    //

#define CardStart(Adapter) \
    NdisRawWritePortUchar(((Adapter->IoPAddr)+NIC_XMIT_CONFIG), TCR_NO_LOOPBACK)



//++
//
// VOID
// CardSetAllMulticast(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Enables every bit in the card multicast bit mask.
//  Calls SyncCardSetAllMulticast.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardSetAllMulticast(Adapter) \
    NdisMSynchronizeWithInterrupt(&(Adapter)->Interrupt, \
                SyncCardSetAllMulticast, (PVOID)(Adapter))


//++
//
// VOID
// CardCopyMulticastRegs(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Writes out the entire multicast bit mask to the card from
//  Adapter->NicMulticastRegs.  Calls SyncCardCopyMulticastRegs.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardCopyMulticastRegs(Adapter) \
    NdisMSynchronizeWithInterrupt(&(Adapter)->Interrupt, \
                SyncCardCopyMulticastRegs, (PVOID)(Adapter))



//++
//
// VOID
// CardGetInterruptStatus(
//     IN PNE2000_ADAPTER Adapter,
//     OUT PUCHAR InterrupStatus
//     )
//
// Routine Description:
//
//  Reads the interrupt status (ISR) register from the card. Only
//  called at IRQL INTERRUPT_LEVEL.
//
// Arguments:
//
//  Adapter - The adapter block.
//
//  InterruptStatus - Returns the value of ISR.
//
// Return Value:
//
//--

#define CardGetInterruptStatus(_Adapter,_InterruptStatus) \
    NdisRawReadPortUchar(((_Adapter)->IoPAddr+NIC_INTR_STATUS), (_InterruptStatus))


//++
//
// VOID
// CardSetReceiveConfig(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Sets the receive configuration (RCR) register on the card.
//  The value used is Adapter->NicReceiveConfig. Calls
//  SyncCardSetReceiveConfig.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardSetReceiveConfig(Adapter) \
    NdisMSynchronizeWithInterrupt(&(Adapter)->Interrupt, \
                SyncCardSetReceiveConfig, (PVOID)(Adapter))


//++
//
// VOID
// CardBlockInterrupts(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Blocks all interrupts from the card by clearing the
//  interrupt mask (IMR) register. Only called from
//  IRQL INTERRUPT_LEVEL.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardBlockInterrupts(Adapter) \
    NdisRawWritePortUchar(((Adapter)->IoPAddr+NIC_INTR_MASK), 0)


//++
//
// VOID
// CardUnblockInterrupts(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Unblocks all interrupts from the card by setting the
//  interrupt mask (IMR) register. Only called from IRQL
//  INTERRUPT_LEVEL.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardUnblockInterrupts(Adapter) \
    NdisRawWritePortUchar(\
            ((Adapter)->IoPAddr+NIC_INTR_MASK), \
            (Adapter)->NicInterruptMask)

//++
//
// VOID
// CardAcknowledgeOverflowInterrupt(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Acknowledges an overflow interrupt by setting the bit in
//  the interrupt status (ISR) register. Calls
//  SyncCardAcknowledgeOverflow.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardAcknowledgeOverflowInterrupt(Adapter) \
     SyncCardAcknowledgeOverflow(Adapter)


//++
//
// VOID
// CardAcknowledgeCounterInterrupt(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Acknowledges a counter interrupt by setting the bit in
//  the interrupt status (ISR) register.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardAcknowledgeCounterInterrupt(Adapter) \
    NdisRawWritePortUchar(((Adapter)->IoPAddr+NIC_INTR_STATUS), ISR_COUNTER)

//++
//
// VOID
// CardUpdateCounters(
//     IN PNE2000_ADAPTER Adapter
//     )
//
// Routine Description:
//
//  Updates the values of the three counters (frame alignment
//  errors, CRC errors, and missed packets) by reading in their
//  current values from the card and adding them to the ones
//  stored in the Adapter structure. Calls SyncCardUpdateCounters.
//
// Arguments:
//
//  Adapter - The adapter block.
//
// Return Value:
//
//  None.
//
//--

#define CardUpdateCounters(Adapter) \
    NdisMSynchronizeWithInterrupt(&(Adapter)->Interrupt, \
                SyncCardUpdateCounters, (PVOID)(Adapter))


#endif // _NE2000HARDWARE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\detect\nia35det\nia35det.c ===
#if 1 // The following includes are used when building with the microsoft internal build tree.
  #include <nt.h>
  #include <ntrtl.h>
  #include <nturtl.h>
  #include <windows.h>
#else // These headers are used when building with the microsoft DDK.
  #include <ntddk.h>
  #include <windef.h>
  #include <winerror.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ntddnetd.h>
#include <ncnet.h>
#include <netdet.h>

BOOLEAN
Nia35DetInit(
  IN  HANDLE  hModule,
  IN  DWORD   dwReason,
  IN  DWORD   dwReserved
  )
/*++

Routine Description:
  This routine is the entry point into the detection dll.
  This routine only return "TRUE".

++*/
{
  return (TRUE);
}



ULONG
Nia35NextIoAddress(
  IN  ULONG  IoBaseAddress
  )
/*++

Routine Description:
  This routine provide next I/O address for detect PC-9801-107/108.

++*/
{
  switch(IoBaseAddress){
    case 0x0770:
      return (0x2770);
    case 0x2770:
      return (0x4770);
    case 0x4770:
      return (0x6770);
    default:
      return (0xffff);
  }
}


VOID
Nia35CardSetup(
    IN   INTERFACE_TYPE  InterfaceType,
    IN   ULONG           BusNumber,
    IN   ULONG           IoBaseAddress,
    OUT  PULONG          MemoryBaseAddress,
    IN   BOOLEAN         EightBitSlot
    )
/*++

Routine Description:

    Sets up the card, using the sequence given in the Etherlink II
    technical reference.

Arguments:

    InterfaceType               -       The type of bus, ISA or EISA.
    BusNumber                   -       The bus number in the system.
    IoBaseAddress               -       The IO port address of the card.
    MemoryBaseAddress           -       Pointer to store the base address of card memory.
    EightBitSlot                -       TRUE if the adapter is in an 8-bit slot.

Return Value:

    None.

--*/
{
  UINT           i;
  UCHAR          Tmp;
  NTSTATUS       NtStatus;
  LARGE_INTEGER  Delay;

  *MemoryBaseAddress = 0;

  // Stop the card.
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x21); // STOP | ABORT_DMA
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

    // Initialize the Data Configuration register.
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100c, // NIC_DATA_CONFIG
                                0x50); // DCR_AUTO_INIT | DCR_FIFO_8_BYTE
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Xmit start location
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x0008, // NIC_XMIT_START
                                0xA0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Xmit configuration
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100a, // NIC_XMIT_CONFIG
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Receive configuration
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1008, // NIC_RCV_CONFIG
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Receive start
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x0002, // NIC_PAGE_START
                                0x4);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Receive end
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x0004, // NIC_PAGE_STOP
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Receive boundary
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x0006, // NIC_BOUNDARY
                                0x4);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set Xmit bytes
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000a, // NIC_XMIT_COUNT_LSB
                                0x3C);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000c, //  NIC_XMIT_COUNT_MSB
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Pause

  // Wait for reset to complete. (100 ms)
  Delay.LowPart = 100000;
  Delay.HighPart = 0;

  NtDelayExecution(FALSE, &Delay);

  // Ack all interrupts that we might have produced
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000e, // NIC_INTR_STATUS
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Change to page 1
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x61); // CR_PAGE1 | CR_STOP

  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Set current
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000e, // NIC_CURRENT
                                0x4);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Back to page 0
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x21); // CR_PAGE0 | CR_STOP
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Pause
  Delay.LowPart = 2000;
  Delay.HighPart = 0;

  NtDelayExecution(FALSE, &Delay);

  // Do initialization errata
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1004, // NIC_RMT_COUNT_LSB
                                55);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Reset the chip
  NtStatus = NDetReadPortUchar(InterfaceType,
                               BusNumber,
                               ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                               &Tmp);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Start the chip
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x22);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Mask Interrupts
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100e, // NIC_INTR_MASK
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  if(EightBitSlot){
    NtStatus = NDetWritePortUchar(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress + 0x100c, // NIC_DATA_CONFIG
                                  0x48); // DCR_FIFO_8_BYTE | DCR_NORMAL | DCR_BYTE_WIDE
  }else{
    NtStatus = NDetWritePortUchar(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress + 0x100c, // NIC_DATA_CONFIG
                                  0x49); // DCR_FIFO_8_BYTE | DCR_NORMAL | DCR_WORD_WIDE
  }

  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100a, // NIC_XMIT_CONFIG
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1008, // NIC_RCV_CONFIG
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000e, // NIC_INTR_STATUS
                                0xFF);
 if(!NT_SUCCESS(NtStatus)){
   return;
 }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x21); // CR_NO_DMA | CR_STOP

  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1004, // NIC_RMT_COUNT_LSB
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1006, // NIC_RMT_COUNT_MSB
                                0);
  if(!NT_SUCCESS(NtStatus)){
    return;
  }

  // Wait for STOP to complete
  i = 0xFF;
  while (--i){
    NtStatus = NDetReadPortUchar(InterfaceType,
                                 BusNumber,
                                 IoBaseAddress + 0x000e, // NIC_INTR_STATUS
                                 &Tmp);
    if(!NT_SUCCESS(NtStatus)){
      return;
    }

    // ISR_RESET
    if(Tmp & 0x80){
      break;
    }
  }

  // Put card in loopback mode
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100a, // NIC_XMIT_CONFIG
                                0x2); // TCR_LOOPBACK

  if(NtStatus != STATUS_SUCCESS){
    return;
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x22); // CR_NO_DMA | CR_START

  if(NtStatus != STATUS_SUCCESS){
    return;
  }

  // ... but it is still in loopback mode.
  return;
}


NTSTATUS
Nia35CardSlotTest(
    IN   INTERFACE_TYPE  InterfaceType,
    IN   ULONG           BusNumber,
    IN   ULONG           IoBaseAddress,
    OUT  PBOOLEAN        EightBitSlot
    )
/*++

Routine Description:

    Checks if the card is in an 8 or 16 bit slot and sets a flag in the
    adapter structure.

Arguments:


    InterfaceType       -       The type of bus, ISA or EISA.
    BusNumber           -       The bus number in the system.
    IoBaseAddress       -       The IO port address of the card.
    EightBitSlot        -       Result of test.

Return Value:

    TRUE, if all goes well, else FALSE.

--*/

{
  UCHAR          Tmp;
  UCHAR          RomCopy[32];
  UCHAR          i;
  NTSTATUS       NtStatus;
  LARGE_INTEGER  Delay;

  // Reset the chip
  NtStatus = NDetReadPortUchar(InterfaceType,
                               BusNumber,
                               ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                               &Tmp);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                                0xFF);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  // Go to page 0 and stop
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0x21); // CR_STOP | CR_NO_DMA

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  // Pause
  Delay.LowPart = 2000;
  Delay.HighPart = 0;

  NtDelayExecution(FALSE, &Delay);

  // Setup to read from ROM
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100c, // NIC_DATA_CONFIG
                                0x48); // DCR_BYTE_WIDE | DCR_FIFO_8_BYTE | DCR_NORMAL

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x100e, // NIC_INTR_MASK
                                0x0);

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  // Ack any interrupts that may be hanging around
  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x000e, // NIC_INTR_STATUS
                                0xFF);

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1000, // NIC_RMT_ADDR_LSB
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1002, // NIC_RMT_ADDR_MSB,
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1004, // NIC_RMT_COUNT_LSB
                                32);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress + 0x1006, // NIC_RMT_COUNT_MSB
                                0x0);
  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                IoBaseAddress,
                                0xA); // CR_DMA_READ | CR_START

  if(!NT_SUCCESS(NtStatus)){
    return(NtStatus);
  }

  // Read first 32 bytes in 16 bit mode
  for (i = 0; i < 32; i++){
    NtStatus = NDetReadPortUchar(InterfaceType,
                                 BusNumber,
                                 ((IoBaseAddress >> 1) & 0xf000) + 0x0888, //NIC_RACK_NIC
                                 RomCopy + i);

    if(NtStatus != STATUS_SUCCESS){
      return(NtStatus);
    }
  }

  // Reset the chip
  NtStatus = NDetReadPortUchar(InterfaceType,
                               BusNumber,
                               ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                               &Tmp);

  if(NtStatus != STATUS_SUCCESS){
    return(NtStatus);
  }

  NtStatus = NDetWritePortUchar(InterfaceType,
                                BusNumber,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                                0xFF);
  if(NtStatus != STATUS_SUCCESS){
    return(NtStatus);
  }

  // Check ROM for 'B' (byte) or 'W' (word)
  for (i = 16; i < 31; i++){
    if (((RomCopy[i] == 'B') && (RomCopy[i+1] == 'B')) ||
       ((RomCopy[i] == 'W') && (RomCopy[i+1] == 'W'))){
         if(RomCopy[i] == 'B'){
           *EightBitSlot = TRUE;
         }else{
           *EightBitSlot = FALSE;
         }

         // Now check that the address is singular.  On an Ne1000 the
         // ethernet address is store in offsets 0 thru 5.  On the Ne2000 and Nia35
         // the address is stored in offsets 0 thru 11, where each byte
         // is duplicated.
         //
         if ((RomCopy[0] == RomCopy[1]) &&
             (RomCopy[2] == RomCopy[3]) &&
             (RomCopy[4] == RomCopy[5]) &&
             (RomCopy[6] == RomCopy[7]) &&
             (RomCopy[8] == RomCopy[9]) &&
             (RomCopy[10] == RomCopy[11])){
               return(STATUS_SUCCESS);
         }

         return(STATUS_UNSUCCESSFUL);
    }
  }

  // If neither found -- then not an NIA35
  return(STATUS_UNSUCCESSFUL);
}



NTSTATUS
FindNia35Adapter(
  OUT  PMND_ADAPTER_INFO        *pDetectedAdapter,
  IN   INTERFACE_TYPE           InterfaceType,
  IN   ULONG                            BusNumber,
  IN   ULONG                            IoBaseAddress,
  IN   PWSTR                            pPnpId
  )
{
  NTSTATUS  NtStatus;
  UCHAR     Data;
  USHORT    CheckSum = 0;
  USHORT    StoredCheckSum;
  UINT      Place;
  UCHAR     Interrupt = 0;
  HANDLE    TrapHandle;
  UCHAR     InterruptList[4];
  UCHAR     ResultList[4] = {0};
  UINT      cResources;
  UINT      c;
  UCHAR     Value;
  ULONG     RamAddr = 0;

  do{

    // check I/O port range.
    NtStatus = NDetCheckPortUsage(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress,
                                  0x10);
    NtStatus |= NDetCheckPortUsage(InterfaceType,
                                   BusNumber,
                                   IoBaseAddress + 0x1000,  // upper range
                                   0x10);
    NtStatus |= NDetCheckPortUsage(InterfaceType,
                                   BusNumber,
                                   ((IoBaseAddress >> 1) & 0xf000) + 0x0888, // NIC_RACK_NIC
                                   0x2);
    NtStatus |= NDetCheckPortUsage(InterfaceType,
                                   BusNumber,
                                   ((IoBaseAddress >> 1) & 0xf000) + 0x088a, // NIC_RESET
                                   0x2);

    if(!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindNia35Adapter : Port range in use. IoBaseAddress = %x\n", IoBaseAddress);
      #endif
      break;
    }

    NDetReadPortUchar(InterfaceType,
                      BusNumber,
                      ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                      &Value);
    NDetWritePortUchar(InterfaceType,
                       BusNumber,
                       ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                       0xFF);
    NDetWritePortUchar(InterfaceType,
                       BusNumber,
                       IoBaseAddress, // COMMAND
                       0x21);

    // check interrupt.
    InterruptList[0] = 3;
    InterruptList[1] = 5;
    InterruptList[2] = 6;
    InterruptList[3] = 12;

    NtStatus = NDetSetInterruptTrap(InterfaceType,
                                    BusNumber,
                                    &TrapHandle,
                                    InterruptList,
                                    4);
    if(NT_SUCCESS(NtStatus)){

      NtStatus = Nia35CardSlotTest(InterfaceType,
                                   BusNumber,
                                   IoBaseAddress,
                                   &Value);
      if(!NT_SUCCESS(NtStatus)){
        NDetRemoveInterruptTrap(TrapHandle);
        break;
      }

      // CardSetup
      Nia35CardSetup(InterfaceType,
                    BusNumber,
                    IoBaseAddress,
                    &RamAddr,
                    Value);

      // Check for interrupt.
      NtStatus = NDetQueryInterruptTrap(TrapHandle, ResultList, 4);

      // Stop the chip.
      NDetReadPortUchar(InterfaceType,
                        BusNumber,
                        ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                        &Value);

      NDetWritePortUchar(InterfaceType,
                         BusNumber,
                         ((IoBaseAddress >> 1) & 0xf000) + 0x088a, //NIC_RESET
                         0xFF);

      NDetWritePortUchar(InterfaceType,
                         BusNumber,
                         IoBaseAddress, // COMMAND
                         0x21);

      NtStatus = NDetRemoveInterruptTrap(TrapHandle);
      if(!NT_SUCCESS(NtStatus)){
        break;
      }
  
      for(c=0 ; c<4 ; c++){
        if((ResultList[c] == 1) || (ResultList[c] == 2)){
          Interrupt = InterruptList[c];
          break;
        }
      }
    }

    // Allocate the adapter information.
    NtStatus = NetDetectAllocAdapterInfo(pDetectedAdapter,
                                         InterfaceType,
                                         BusNumber,
                                         pPnpId,
                                         0,
                                         0,
                                         0,
                                         2);
    if (!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindNia35Adapter: Unable to allocate adapter info\n");
      #endif
      break;
    }

    //  Initialize the resources.
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                IoBaseAddress,
                                0x10);
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                IoBaseAddress + 0x1000,
                                0x10);
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x0888, // NIC_RACK_NIC
                                0x2);
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                ((IoBaseAddress >> 1) & 0xf000) + 0x088a, // NIC_RESET
                                0x2);


    if(Interrupt != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceInterrupt,
                                  Interrupt,
                                  MND_RESOURCE_INTERRUPT_LATCHED);
    }

    NtStatus = STATUS_SUCCESS;

  }while(FALSE);

  return (NtStatus);

}

NTSTATUS
WINAPI
FindAdapterHandler(
  IN  OUT  PMND_ADAPTER_INFO  *pDetectedAdapter,
  IN  INTERFACE_TYPE          InterfaceType,
  IN  ULONG                   BusNumber,
  IN  PDET_ADAPTER_INFO       pAdapterInfo,
  IN  PDET_CONTEXT            pDetContext
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  NTSTATUS  NtStatus;
  ULONG     IoBaseAddress;

  if(InterfaceType != Isa){
    return(STATUS_INVALID_PARAMETER);
  }

  // Are we looking for the first adapter?
  if (fDET_CONTEXT_FIND_FIRST == (pDetContext->Flags & fDET_CONTEXT_FIND_FIRST)){
    // Initialize the context information so that we start detecting
    // at the initialize port range.
    pDetContext->ISA.IoBaseAddress = 0x0770;
  }

  for (IoBaseAddress = pDetContext->ISA.IoBaseAddress;
       IoBaseAddress <= 0x6770;
       IoBaseAddress = Nia35NextIoAddress(IoBaseAddress)){

    //  Look for the ee16 adapter at the current port.
    NtStatus = FindNia35Adapter(pDetectedAdapter,
                           InterfaceType,
                           BusNumber,
                           IoBaseAddress,
                           pAdapterInfo->PnPId);

    if (NT_SUCCESS(NtStatus)){
      // We found an adapter. Save the next IO address to check.
      pDetContext->ISA.IoBaseAddress = Nia35NextIoAddress(IoBaseAddress);
      break;
    }
  }

  if (0xffff == IoBaseAddress){
    NtStatus = STATUS_NO_MORE_ENTRIES;
  }

  return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\detect\nibcdet\sources.inc ===
MAJORCOMP = net
MINORCOMP = nibcdet

TARGETNAME=nibcdet
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=\
    $(SDK_LIB_PATH)\netdtect.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\netdet.lib

DLLENTRY=NibcDetInit

INCLUDES=..; \
         $(BASEDIR)\private\ntos\inc; \
         $(BASEDIR)\private\inc\net

C_DEFINES=$(C_DEFINES) -D_PNP_POWER=1

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\nibcdet.c  \
        ..\nibcdet.rc

DLLDEF=..\nibcdet.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\detect\nia35det\sources.inc ===
TARGETNAME=nia35det
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\netdtect.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib \
    $(SDK_LIB_PATH)\netdet.lib

DLLENTRY=Nia35DetInit

INCLUDES=..; \
         $(BASEDIR)\private\ntos\inc; \
         $(BASEDIR)\private\inc\net

C_DEFINES=$(C_DEFINES) -D_PNP_POWER=1

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\nia35det.c  \
        ..\nia35det.rc

DLLDEF=..\nia35det.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\detect\r81wdet\sources.inc ===
MAJORCOMP = net
MINORCOMP = r81wdet

TARGETNAME=r81wdet
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\netdtect.lib $(SDK_LIB_PATH)\kernel32.lib $(SDK_LIB_PATH)\user32.lib $(SDK_LIB_PATH)\netdet.lib

DLLENTRY=R81wDetInit

INCLUDES=..; \
         $(BASEDIR)\private\ntos\inc; \
         $(BASEDIR)\private\inc\net

C_DEFINES=$(C_DEFINES) -D_PNP_POWER=1

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\r81wdet.c  \
        ..\r81wdet.rc

DLLDEF=..\r81wdet.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\detect\nibcdet\nibcdet.c ===
#if 1 // The following includes are used when building with the microsoft internal build tree.
  #include <nt.h>
  #include <ntrtl.h>
  #include <nturtl.h>
  #include <windows.h>
#else // These headers are used when building with the microsoft DDK.
  #include <ntddk.h>
  #include <windef.h>
  #include <winerror.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ntddnetd.h>
#include <ncnet.h>
#include <netdet.h>

BOOLEAN
NibcDetInit(
  IN  HANDLE  hModule,
  IN  DWORD   dwReason,
  IN  DWORD   dwReserved
  )
/*++

Routine Description:
  This routine is the entry point into the detection dll.
  This routine only return "TRUE".

++*/
{
  return (TRUE);
}



ULONG
NibcNextIoAddress(
  IN  ULONG  IoBaseAddress
  )
/*++

Routine Description:
  This routine provide next I/O address for detect PC-9801-83/84/103/104.

++*/
{
  switch(IoBaseAddress){
    case 0x0888:
      return (0x1888);
    case 0x1888:
      return (0x2888);
    case 0x2888:
      return (0x3888);
    default:
      return (0xffff);
  }
}



NTSTATUS
FindNibcAdapter(
  OUT  PMND_ADAPTER_INFO	*pDetectedAdapter,
  IN   INTERFACE_TYPE		InterfaceType,
  IN   ULONG				BusNumber,
  IN   ULONG				IoBaseAddress,
  IN   PWSTR				pPnpId
  )
{
  NTSTATUS  NtStatus;
  UCHAR     Data;
  USHORT    CheckSum = 0;
  USHORT    StoredCheckSum;
  UINT      Place;
  UCHAR     Interrupt = 0;
  HANDLE    TrapHandle;
  UCHAR     InterruptList[8];
  UCHAR     ResultList[8] = {0};
  UINT      cResources;
  UINT      c;
  UCHAR     Value;
  ULONG     MemoryBaseAddress = 0;

  do{

    // check I/O port range.
    NtStatus = NDetCheckPortUsage(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress,
                                  0x4);

    if(!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindNibcAdapter : Port range in use. IoBaseAddress = %x\n", IoBaseAddress);
      #endif
      break;
    }

    // check board ID.
    // 83/84's ID is 0x05.
    NDetWritePortUchar(InterfaceType,
                       BusNumber,
                       IoBaseAddress + 0x003,
                       0x88);
    NDetReadPortUchar(InterfaceType,
                      BusNumber,
                      IoBaseAddress + 0x001,
                      &Value);
    if(Value != 0x05){
      NtStatus = STATUS_NOT_FOUND;
      #if DBG
        DbgPrint("ID is invalid. ID = %x\n",Value);
      #endif
      break;
    }

    // check interrupt.
    InterruptList[0] = 3;
    InterruptList[1] = 5;
    InterruptList[2] = 6;
    InterruptList[3] = 9;
    InterruptList[4] = 10;
    InterruptList[5] = 12;
    InterruptList[6] = 13;

    NtStatus = NDetSetInterruptTrap(InterfaceType,
                                    BusNumber,
                                    &TrapHandle,
                                    InterruptList,
                                    7);
    if(NT_SUCCESS(NtStatus)){
      NtStatus = NDetQueryInterruptTrap(TrapHandle, ResultList, 7);
      NtStatus = NDetRemoveInterruptTrap(TrapHandle);
  
      if(!NT_SUCCESS(NtStatus)){
        #if DBG
          DbgPrint("NDetRemoveInterruptTrap failed. Status = %x\n",NtStatus);
        #endif
        break;
      }
  
      for(c=0 ; c<7 ; c++){
        if((ResultList[c] == 1) || (ResultList[c] == 2)){
          Interrupt = InterruptList[c];
          break;
        }
      }
    }else{
      #if DBG
        DbgPrint("NDetSetInterruptTrap failed. Status = %x\n",NtStatus);
      #endif
    }

    for(c=0 ; c<16 ; c++){
      MemoryBaseAddress = 0xc0000 + (0x2000 * c);
      if(MemoryBaseAddress == 0xd0000){
        continue;
      }
      NtStatus = NDetCheckMemoryUsage(
                   InterfaceType,
                   BusNumber,
                   MemoryBaseAddress,
                   0x2000);
      if (NT_SUCCESS(NtStatus))
      {
        #if DBG
          DbgPrint("NDetCheckMemoryUsage success. Address = %x\n",MemoryBaseAddress);
        #endif
        break;
      }
    }

    // Allocate the adapter information.
    NtStatus = NetDetectAllocAdapterInfo(pDetectedAdapter,
                                         InterfaceType,
                                         BusNumber,
                                         pPnpId,
                                         0,
                                         0,
                                         0,
                                         2);
    if (!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("NetDetectAllocAdapterInfo failed. Status = %x\n",NtStatus);
      #endif
      break;
    }

    #if DBG
      DbgPrint("IoBaseAddress = %x\n",IoBaseAddress);
      DbgPrint("Interrupt = %x\n",Interrupt);
      DbgPrint("MemoryAddress = %x\n",MemoryBaseAddress);
    #endif

    //	Initialize the resources.
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                IoBaseAddress,
                                0x4);
    if(Interrupt != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceInterrupt,
                                  Interrupt,
                                  MND_RESOURCE_INTERRUPT_LATCHED);
    }
    if(MemoryBaseAddress != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceMemory,
                                  MemoryBaseAddress,
                                  0x2000);
    }

    NtStatus = STATUS_SUCCESS;

  }while(FALSE);

  return (NtStatus);

}

NTSTATUS
WINAPI
FindAdapterHandler(
  IN  OUT  PMND_ADAPTER_INFO  *pDetectedAdapter,
  IN  INTERFACE_TYPE          InterfaceType,
  IN  ULONG                   BusNumber,
  IN  PDET_ADAPTER_INFO       pAdapterInfo,
  IN  PDET_CONTEXT            pDetContext
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  NTSTATUS  NtStatus;
  ULONG     IoBaseAddress;

  if(InterfaceType != Isa){
    return(STATUS_INVALID_PARAMETER);
  }

  // Are we looking for the first adapter?
  if (fDET_CONTEXT_FIND_FIRST == (pDetContext->Flags & fDET_CONTEXT_FIND_FIRST)){
    // Initialize the context information so that we start detecting
    // at the initialize port range.
    pDetContext->ISA.IoBaseAddress = 0x0888;
  }

  for (IoBaseAddress = pDetContext->ISA.IoBaseAddress;
       IoBaseAddress <= 0x3888;
       IoBaseAddress = NibcNextIoAddress(IoBaseAddress)){

    //  Look for the PC-9801-83/84/103/104 adapter at the current port.
    NtStatus = FindNibcAdapter(pDetectedAdapter,
                               InterfaceType,
                               BusNumber,
                               IoBaseAddress,
                               pAdapterInfo->PnPId);

    if (NT_SUCCESS(NtStatus)){
      // We found an adapter. Save the next IO address to check.
      #if DBG
        DbgPrint("Found an adapter. I/O port is %x\n",IoBaseAddress);
      #endif
      pDetContext->ISA.IoBaseAddress = NibcNextIoAddress(IoBaseAddress);
      break;
    }
  }

  if (0xffff == IoBaseAddress){
    NtStatus = STATUS_NO_MORE_ENTRIES;
  }

  return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\drivers\sources.inc ===
TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget

SOURCES=

NTTARGETFILE0=\
    $(O)\netnec98.inf

!if $(FREEBUILD)
BDIR = ..\retail
!else
BDIR = ..\debug
!endif

!if "$(ALT_PROJECT)"!=""
!if "$(ALT_PROJECT)"=="NEC_98"
MISCFILES = \
    $(BDIR)\b80crdr.sys     \
    $(BDIR)\b80nibc.sys     \
    $(BDIR)\b80r81j.sys     \
    $(BDIR)\b80r81w.sys     \
    $(BDIR)\nia35.sys       \
    $(BDIR)\r8100cfg.cpl    \
    $(BDIR)\r8100cfg.chm    \
    $(O)\netnec98.inf
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\drivers\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

STAMP=stampinf -f $@ -d date -v
            
_LNG=..\$(LANGUAGE)
_INX=..

!IFDEF SERVERINF
!IFDEF BINPLACE_CMD
BINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
!ENDIF
!ENDIF

$(O)\netnec98.inf: $(_INX)\netnec98.inx $(_LNG)\netnec98.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\detect\r81wdet\r81wdet.c ===
#if 1 // The following includes are used when building with the microsoft internal build tree.
  #include <nt.h>
  #include <ntrtl.h>
  #include <nturtl.h>
  #include <windows.h>
#else // These headers are used when building with the microsoft DDK.
  #include <ntddk.h>
  #include <windef.h>
  #include <winerror.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ntddnetd.h>
#include <ncnet.h>
#include <netdet.h>

BOOLEAN
R81wDetInit(
  IN  HANDLE  hModule,
  IN  DWORD   dwReason,
  IN  DWORD   dwReserved
  )
/*++

Routine Description:
  This routine is the entry point into the detection dll.
  This routine only return "TRUE".

++*/
{
  return (TRUE);
}



ULONG
R81wNextIoAddress(
  IN  ULONG  IoBaseAddress
  )
/*++

Routine Description:
  This routine provide next I/O address for detect PC-9801-111.

++*/
{
  switch(IoBaseAddress){
    case 0x0888:
      return (0x1888);
    case 0x1888:
      return (0x2888);
    case 0x2888:
      return (0x3888);
    default:
      return (0xffff);
  }
}



NTSTATUS
FindR81wAdapter(
  OUT  PMND_ADAPTER_INFO	*pDetectedAdapter,
  IN   INTERFACE_TYPE		InterfaceType,
  IN   ULONG				BusNumber,
  IN   ULONG				IoBaseAddress,
  IN   PWSTR				pPnpId
  )
{
  NTSTATUS  NtStatus;
  UCHAR     Data;
  USHORT    CheckSum = 0;
  USHORT    StoredCheckSum;
  UINT      Place;
  UCHAR     Interrupt = 0;
  HANDLE    TrapHandle;
  UCHAR     InterruptList[8];
  UCHAR     ResultList[8] = {0};
  UINT      cResources;
  UINT      c;
  UCHAR     Value;
  ULONG     MemoryBaseAddress = 0;

  do{

    // check I/O port range.
    NtStatus = NDetCheckPortUsage(InterfaceType,
                                  BusNumber,
                                  IoBaseAddress,
                                  0x4);

    if(!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindR81wAdapter : Port range in use. IoBaseAddress = %x\n", IoBaseAddress);
      #endif

      break;
    }

    // check board ID.
    // 111's ID is 0x67.
    NDetWritePortUchar(InterfaceType,
                       BusNumber,
                       IoBaseAddress + 0x003,
                       0x88);
    NDetReadPortUchar(InterfaceType,
                      BusNumber,
                      IoBaseAddress + 0x001,
                      &Value);
    if(Value != 0x67){
      NtStatus = STATUS_NOT_FOUND;
      #if DBG
        DbgPrint("R81WDET : Board ID is invalid.\n");
        DbgPrint("R81WDET : I/O port is %x.\n",IoBaseAddress);
      #endif
      break;
    }

    // check interrupt.
    InterruptList[0] = 3;
    InterruptList[1] = 5;
    InterruptList[2] = 6;
    InterruptList[3] = 9;
    InterruptList[4] = 10;
    InterruptList[5] = 12;
    InterruptList[6] = 13;

    NtStatus = NDetSetInterruptTrap(InterfaceType,
                                    BusNumber,
                                    &TrapHandle,
                                    InterruptList,
                                    7);
    if(NT_SUCCESS(NtStatus)){
      NtStatus = NDetQueryInterruptTrap(TrapHandle, ResultList, 7);
      NtStatus = NDetRemoveInterruptTrap(TrapHandle);
  
      if(!NT_SUCCESS(NtStatus)){
        #if DBG
          DbgPrint("R81WDET : RemoveInterrupt failed.");
        #endif
        break;
      }
  
      for(c=0 ; c<7 ; c++){
        if((ResultList[c] == 1) || (ResultList[c] == 2)){
          Interrupt = InterruptList[c];
          break;
        }
      }
    }else{
      #if DBG
        DbgPrint("R81WDET : SetInterrupt failed\n");
      #endif
    }

    for(c=0 ; c<16 ; c++){
      MemoryBaseAddress = 0xc0000 + (0x2000 * c);
      if(MemoryBaseAddress == 0xd0000){
        continue;
      }
      NtStatus = NDetCheckMemoryUsage(
                   InterfaceType,
                   BusNumber,
                   MemoryBaseAddress,
                   0x2000);
      if (NT_SUCCESS(NtStatus))
      {
        break;
      }
    }

    // Allocate the adapter information.
    NtStatus = NetDetectAllocAdapterInfo(pDetectedAdapter,
                                         InterfaceType,
                                         BusNumber,
                                         pPnpId,
                                         0,
                                         0,
                                         0,
                                         2);
    if (!NT_SUCCESS(NtStatus)){
      #if DBG
        DbgPrint("FindR81wAdapter: Unable to allocate adapter info\n");
      #endif
      break;
    }

    #if DBG
      DbgPrint("I/O port is %x\n",IoBaseAddress);
      DbgPrint("IRQ is %x\n",Interrupt);
      DbgPrint("Memory address is %x\n",MemoryBaseAddress);
    #endif

    //	Initialize the resources.
    NetDetectInitializeResource(*pDetectedAdapter,
                                0,
                                MndResourcePort,
                                IoBaseAddress,
                                0x4);
    if(Interrupt != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceInterrupt,
                                  Interrupt,
                                  MND_RESOURCE_INTERRUPT_LATCHED);
    }
    if(MemoryBaseAddress != 0){
      NetDetectInitializeResource(*pDetectedAdapter,
                                  1,
                                  MndResourceMemory,
                                  MemoryBaseAddress,
                                  0x2000);
    }

    NtStatus = STATUS_SUCCESS;

  }while(FALSE);

  return (NtStatus);

}

NTSTATUS
WINAPI
FindAdapterHandler(
  IN  OUT  PMND_ADAPTER_INFO  *pDetectedAdapter,
  IN  INTERFACE_TYPE          InterfaceType,
  IN  ULONG                   BusNumber,
  IN  PDET_ADAPTER_INFO       pAdapterInfo,
  IN  PDET_CONTEXT            pDetContext
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
  NTSTATUS  NtStatus;
  ULONG     IoBaseAddress;

  if(InterfaceType != Isa){
    return(STATUS_INVALID_PARAMETER);
  }

  // Are we looking for the first adapter?
  if (fDET_CONTEXT_FIND_FIRST == (pDetContext->Flags & fDET_CONTEXT_FIND_FIRST)){
    // Initialize the context information so that we start detecting
    // at the initialize port range.
    pDetContext->ISA.IoBaseAddress = 0x0888;
  }

  for (IoBaseAddress = pDetContext->ISA.IoBaseAddress;
       IoBaseAddress <= 0x3888;
       IoBaseAddress = R81wNextIoAddress(IoBaseAddress)){

    //  Look for the PC-9801-111 adapter at the current port.
    NtStatus = FindR81wAdapter(pDetectedAdapter,
                           InterfaceType,
                           BusNumber,
                           IoBaseAddress,
                           pAdapterInfo->PnPId);

    if (NT_SUCCESS(NtStatus)){
      // We found an adapter. Save the next IO address to check.
      #if DBG
        DbgPrint("R81WDET : We found an PC-9801-111\n");
      #endif
      pDetContext->ISA.IoBaseAddress = R81wNextIoAddress(IoBaseAddress);
      break;
    }
  }

  if (0xffff == IoBaseAddress){
    NtStatus = STATUS_NO_MORE_ENTRIES;
  }

  return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\nec\drivers\nec_98\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\sna\ibmmg\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\ibmsync.inf: $(_INX)\ibmsync.inx $(_LNG)\ibmsync.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\net\sna\mgate\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\mgsync.inf: $(_INX)\mgsync.inx $(_LNG)\mgsync.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\nlsmsg\ioerror.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TEST.C

Abstract:

    Test program for the eventlog service. This program calls the Elf
    APIs to test out the operation of the service.

Author:

    Rajen Shah  (rajens) 05-Aug-1991

Revision History:


--*/
/*----------------------*/
/* INCLUDES             */
/*----------------------*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>      // printf
#include <string.h>     // stricmp
#include <stdlib.h>
#include <process.h>    // exit
#include <elfcommn.h>
#include <windows.h>
#include <ntiolog.h>
#include <malloc.h>
#include <time.h>

#define     READ_BUFFER_SIZE        1024*2      // Use 2K buffer

#define     SIZE_DATA_ARRAY         65

//
// Global buffer used to emulate "binary data" when writing an event
// record.
//
ULONG    Data[SIZE_DATA_ARRAY];
enum _OPERATION_TYPE {
   Invalid,
   Clear,
   Read,
   Write,
   LPC
} Operation = Invalid;
ULONG ReadFlags;
ULONG NumberofRecords = 1;
ULONG DelayInMilliseconds = 0;
CHAR DefaultModuleName[] = "System";
PCHAR pModuleName = DefaultModuleName;

// Function prototypes

VOID ParseParms(ULONG argc, PCHAR *argv);

VOID
Initialize (
    VOID
    )
{
    ULONG   i;

    // Initialize the values in the data buffer.
    //
    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] = i;

}

VOID
Usage (
    VOID
    )
{
    printf( "usage: \n" );
    printf( "-c              Clears the specified log\n");
    printf( "-rsb            Reads nn event log records sequentially backwards\n");
    printf( "-rsf nn         Reads nn event log records sequentially forwards\n");
    printf( "-rrb <record>   Reads event log from <record> backwards\n");
    printf( "-rrf <record>   Reads event log from <record> forwards\n");
    printf( "-m <modulename> Module name to use for read/clear\n");
    exit(0);

} // Usage

VOID
DisplayEventRecords( PVOID Buffer,
                     ULONG  BufSize,
                     PULONG NumRecords)

{
    PEVENTLOGRECORD pLogRecord;
    IO_ERROR_LOG_PACKET UNALIGNED  *errorPacket;
    NTSTATUS Status;
    ANSI_STRING         StringA;
    UNICODE_STRING      StringU;
    PWSTR               pwString;
    PCHAR               paString;
    ULONG               Count = 0;
    ULONG               Offset = 0;
    ULONG               i;
    UCHAR MessageBuffer[265];
    BOOLEAN             ioRecord;

    pLogRecord = (PEVENTLOGRECORD) Buffer;

    if (getenv("TZ") == NULL) {
        _putenv("TZ=PDT");
    }

    while (Offset < BufSize && Count < *NumRecords) {

        printf("\nRecord # %lu\n", pLogRecord->RecordNumber);

        if (/* pLogRecord->EventType != IO_TYPE_ERROR_MESSAGE || */
            pLogRecord->DataLength < sizeof(IO_ERROR_LOG_PACKET)) {

            ioRecord = FALSE;

            printf("Length: 0x%lx TimeGenerated: 0x%lx  EventID: 0x%lx EventType: 0x%x\n",
                    pLogRecord->Length, pLogRecord->TimeGenerated, pLogRecord->EventID,
                    pLogRecord->EventType);

            printf("NumStrings: 0x%x StringOffset: 0x%lx UserSidLength: 0x%lx TimeWritten: 0x%lx\n",
                    pLogRecord->NumStrings, pLogRecord->StringOffset,
                    pLogRecord->UserSidLength, pLogRecord->TimeWritten);

            printf("UserSidOffset: 0x%lx    DataLength: 0x%lx    DataOffset:  0x%lx \n",
                    pLogRecord->UserSidOffset, pLogRecord->DataLength,
                    pLogRecord->DataOffset);
        } else {

            ioRecord = TRUE;
            errorPacket = (PIO_ERROR_LOG_PACKET)
                ((PCHAR) pLogRecord + pLogRecord->DataOffset);
        }

        //
        // Print out module name
        //

        pwString = (PWSTR)((LPBYTE) pLogRecord + sizeof(EVENTLOGRECORD));
        RtlInitUnicodeString (&StringU, pwString);
        RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

        printf("ModuleName:  %s \t", StringA.Buffer);
        RtlFreeAnsiString (&StringA);

        //
        // Display ComputerName
        //
        pwString += wcslen(pwString) + 1;

        RtlInitUnicodeString (&StringU, pwString);
        RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

        printf("ComputerName: %s\n",StringA.Buffer);
        RtlFreeAnsiString (&StringA);

        //
        // Display strings
        //

        pwString = (PWSTR)((LPBYTE)pLogRecord + pLogRecord->StringOffset);

        printf("Strings: ");
        for (i=0; i<pLogRecord->NumStrings; i++) {

            RtlInitUnicodeString (&StringU, pwString);
            RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

            printf("  %s  ",StringA.Buffer);

            RtlFreeAnsiString (&StringA);

            pwString = (PWSTR)((LPBYTE)pwString + StringU.MaximumLength);
        }

        printf("\n");

        if (ioRecord) {

            MessageBuffer[0] = '\0';
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                errorPacket->ErrorCode,
                0,
                MessageBuffer,
                256,
                NULL
                );

#if 0
            printf("Event id: %8lx, => %s",
                errorPacket->ErrorCode, MessageBuffer);
#endif
            printf(MessageBuffer, errorPacket->DumpData[0], errorPacket->DumpData[1], errorPacket->DumpData[2]);
            printf("Major Function code: %2x, IoControlCode: %8x\n",
                errorPacket->MajorFunctionCode, errorPacket->IoControlCode);
            paString = ctime((time_t *) &pLogRecord->TimeGenerated);

            if (pwString != NULL) {
                printf("Sequence number: %ld, Time of error: %s",
                    errorPacket->SequenceNumber, paString);
            }

            printf("Unique Error Value: %ld, Final Status: %8lx\n",
                errorPacket->UniqueErrorValue, errorPacket->FinalStatus);

            printf("Device Offset: %08lx%08lx\n",
                errorPacket->DeviceOffset.HighPart, errorPacket->DeviceOffset.LowPart);

            printf("Dump Data:");

            for (i = 0; i < 1 + (errorPacket->DumpDataSize +3)/ 4; i++) {

                if (!(i % 4)) {
                    printf("\n");
                }

                printf("%08lx ", errorPacket->DumpData[i]);
            }

            printf("\n");

        }

        // Get next record
        //
        Offset += pLogRecord->Length;

        pLogRecord = (PEVENTLOGRECORD)((ULONG)Buffer + Offset);

        Count++;

    }

    *NumRecords = Count;

}


NTSTATUS
ReadFromLog ( HANDLE LogHandle,
             PVOID  Buffer,
             PULONG pBytesRead,
             ULONG  ReadFlag,
             ULONG  Record
             )
{
    NTSTATUS    Status;
    ULONG       MinBytesNeeded;

    Status = ElfReadEventLogW (
                        LogHandle,
                        ReadFlag,
                        Record,
                        Buffer,
                        READ_BUFFER_SIZE,
                        pBytesRead,
                        &MinBytesNeeded
                        );


    if (Status == STATUS_NO_MORE_FILES)
        printf("Buffer too small. Need %lu bytes min\n", MinBytesNeeded);

    return (Status);
}




NTSTATUS
TestReadEventLog (
    ULONG Count,
    ULONG ReadFlag,
    ULONG Record
    )

{
    NTSTATUS    Status, IStatus;

    HANDLE      LogHandle;
    UNICODE_STRING  ModuleNameU;
    ANSI_STRING ModuleNameA;
    ULONG   NumRecords, BytesReturned;
    PVOID   Buffer;
    ULONG   RecordOffset;
    ULONG   NumberOfRecords;
    ULONG   OldestRecord;

    printf("Testing ElfReadEventLog API to read %lu entries\n",Count);

    Buffer = malloc (READ_BUFFER_SIZE);

    //
    // Initialize the strings
    //
    NumRecords = Count;
    RtlInitAnsiString(&ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);

    //
    // Open the log handle
    //
    printf("ElfOpenEventLog - ");
    Status = ElfOpenEventLogW (
                    NULL,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Get and print record information
        //

        Status = ElfNumberOfRecords(LogHandle, & NumberOfRecords);
        if (NT_SUCCESS(Status)) {
           Status = ElfOldestRecord(LogHandle, & OldestRecord);
        }

        if (!NT_SUCCESS(Status)) {
           printf("Query of record information failed with %X", Status);
           return(Status);
        }

        printf("\nThere are %d records in the file, %d is the oldest"
         " record number\n", NumberOfRecords, OldestRecord);

        RecordOffset = Record;

        while (Count && NT_SUCCESS(Status)) {

            printf("Read %u records\n", NumRecords);
            //
            // Read from the log
            //
            Status = ReadFromLog ( LogHandle,
                                   Buffer,
                                   &BytesReturned,
                                   ReadFlag,
                                   RecordOffset
                                 );
            if (NT_SUCCESS(Status)) {

                printf("Bytes read = 0x%lx\n", BytesReturned);
                NumRecords = Count;
                DisplayEventRecords(Buffer, BytesReturned, &NumRecords);
                Count -= NumRecords;
            }

        }
        printf("\n");

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_END_OF_FILE) {
               printf("Tried to read more records than in log file\n");
            }
            else {
                printf ("Error - 0x%lx. Remaining count %lu\n", Status, Count);
            }
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfCloseEventLog\n");
        IStatus = ElfCloseEventLog (LogHandle);
    }

    return (Status);
}

NTSTATUS
TestElfClearLogFile(
    VOID
    )

{
    NTSTATUS    Status, IStatus;
    HANDLE      LogHandle;
    UNICODE_STRING  BackupU, ModuleNameU;
    ANSI_STRING ModuleNameA;

    printf("Testing ElfClearLogFile API\n");
    //
    // Initialize the strings
    //
    RtlInitAnsiString( &ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);

    //
    // Open the log handle
    //
    printf("Calling ElfOpenEventLog for CLEAR - ");
    Status = ElfOpenEventLogW (
                    NULL,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Clear the log file and back it up to "view.log"
        //

        printf("Calling ElfClearEventLogFile backing up to view.log  ");
        RtlInitUnicodeString( &BackupU, L"view.log" );

        Status = ElfClearEventLogFileW (
                        LogHandle,
                        &BackupU
                        );

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }

        //
        // Now just clear the file without backing it up
        //
        printf("Calling ElfClearEventLogFile with no backup  ");
        Status = ElfClearEventLogFileW (
                        LogHandle,
                        NULL
                        );

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfCloseEventLog\n");
        IStatus = ElfCloseEventLog (LogHandle);
    }

    return(Status);
}


VOID
main (
    IN SHORT argc,
    IN PSZ argv[]
    )
{

    Initialize();           // Init any data

    //
    // Parse the command line
    //

    ParseParms(argc, argv);

    if ( Operation == Invalid) {
        printf( "Must specify an operation\n");
        Usage( );
    }

    switch (Operation) {
       case Clear:

          TestElfClearLogFile();

       case Read:

          if (ReadFlags & EVENTLOG_SEEK_READ) {
              TestReadEventLog(1, ReadFlags, NumberofRecords) ;
          }
          else {
              TestReadEventLog(NumberofRecords, ReadFlags, 0) ;
          }
          break;

    }
}

VOID
ParseParms(
    ULONG argc,
    PCHAR *argv
    )
{

   ULONG i;
   PCHAR pch;

   for (i = 1; i < argc; i++) {    /* for each argument */
       if (*(pch = argv[i]) == '-') {
           while (*++pch) {
               switch (*pch) {
                  case 'r':
                     //
                     // Different Read options
                     //

                     if (Operation != Invalid) {
                        printf("Only one operation at a time\n");
                        Usage();
                     }

                     Operation = Read;
                     if (*++pch == 's') {
                        ReadFlags |= EVENTLOG_SEQUENTIAL_READ;
                     }
                     else if (*pch == 'r') {
                        ReadFlags |= EVENTLOG_SEEK_READ;
                     }
                     else {
                        Usage();
                     }

                     if (*++pch == 'f') {
                        ReadFlags |= EVENTLOG_FORWARDS_READ;
                     }
                     else if (*pch == 'b') {
                        ReadFlags |= EVENTLOG_BACKWARDS_READ;
                     }
                     else {
                        Usage();
                     }

                     //
                     // See if they specified a number of records
                     //

                     if (i + 1 < argc && argv[i+1][0] != '-') {
                        NumberofRecords = atoi(argv[++i]);
                        if (NumberofRecords == 0) {
                           Usage();
                        }
                     }

                     break;

                  case 'c':

                     if (Operation != Invalid) {
                        printf("Only one operation at a time\n");
                        Usage();
                     }

                     Operation = Clear;
                     break;

                  case 'm':
                     if (i+1 < argc) {
                        pModuleName = argv[++i];
                     }
                     else {
                        Usage();
                     }
                     break;

                  case '?':
                  case 'h':
                  case 'H':
                     Usage();
                     break;

                  default:        /* Invalid options */
                     printf("Invalid option %c\n\n", *pch);
                     Usage();
                     break;
               }
           }
       }
       //
       // There aren't any non switch parms
       else {
          Usage();
       }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\byte.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    Byte.c

Abstract:

    This module contains the code to do byte mode reads.

Author:

    Don Redford 30-Aug-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

BOOLEAN
ParIsByteSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterByteMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateByteMode(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParByteModeRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    

BOOLEAN
ParIsByteSupported(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine determines whether or not byte mode is suported
    by trying to negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    ParDump2(PARINFO, ("ParIsByteSupported: Start\n"));

    if (Extension->BadProtocolModes & BYTE_BIDIR) {
        ParDump2(PARINFO, ("ParIsByteSupported: BAD PROTOCOL Leaving\n"));
        return FALSE;
    }

    if (!(Extension->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        ParDump2(PARINFO, ("ParIsByteSupported: NO Leaving\n"));
        return FALSE;
    }

    if (Extension->ProtocolModesSupported & BYTE_BIDIR) {
        ParDump2(PARINFO, ("ParIsByteSupported: Already Checked YES Leaving\n"));
        return TRUE;
    }

    // Must use Byte Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterByteMode (Extension, FALSE);
    ParTerminateByteMode (Extension);
    
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParIsByteSupported: SUCCESS Leaving\n"));
        Extension->ProtocolModesSupported |= BYTE_BIDIR;
        return TRUE;
    }
   
    ParDump2(PARINFO, ("ParIsByteSupported: UNSUCCESSFUL Leaving\n"));
    return FALSE;    
}

NTSTATUS
ParEnterByteMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    byte mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    ParDump2(PARINFO, ("ParEnterByteMode: Start\n"));
    // Make sure Byte mode Harware is still there
    Status = Extension->TrySetChipMode( Extension->PortContext, ECR_BYTE_PIO_MODE );
    
    
    if ( NT_SUCCESS(Status) ) {
        if ( Extension->ModeSafety == SAFE_MODE ) {
            ParDump2(PARINFO, ("ParEnterByteMode: In SAFE_MODE doing IEEE Negotiation\n"));
            if ( DeviceIdRequest ) {
                Status = IeeeEnter1284Mode (Extension, BYTE_EXTENSIBILITY | DEVICE_ID_REQ);
            } else {
                Status = IeeeEnter1284Mode (Extension, BYTE_EXTENSIBILITY);
            }
        } else {
            ParDump2(PARINFO, ("ParEnterByteMode: In UNSAFE_MODE.\n"));
            Extension->Connected = TRUE;
        }
    }
    
    // dvdr
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParEnterByteMode: IeeeEnter1284Mode returned success\n"));
        Extension->CurrentPhase = PHASE_REVERSE_IDLE;
        Extension->IsIeeeTerminateOk = TRUE;
    } else {
        ParDump2(PARINFO, ("ParEnterByteMode: IeeeEnter1284Mode returned unsuccessful\n"));
        ParTerminateByteMode ( Extension );
        Extension->CurrentPhase = PHASE_UNKNOWN;
        Extension->IsIeeeTerminateOk = FALSE;
    }

    ParDump2(PARINFO, ("ParEnterByteMode: Leaving with Status : %x \n", Status));
    
    return Status; 
}    

VOID
ParTerminateByteMode(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    ParDump2(PARINFO, ("ParTerminateByteMode: Enter.\n"));
    if ( Extension->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Extension);
    } else {
        ParDump2(PARINFO, ("ParTerminateByteMode: In UNSAFE_MODE.\n"));
        Extension->Connected = FALSE;
    }
    Extension->ClearChipMode( Extension->PortContext, ECR_BYTE_PIO_MODE );
    ParDump2(PARINFO, ("ParTerminateByteMode: Exit.\n"));
}

NTSTATUS
ParByteModeRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 byte mode read into the given
    buffer for no more than 'BufferSize' bytes.

Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;    
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          lpsBufPtr = (PUCHAR)Buffer;
    ULONG           i;
    UCHAR           dsr, dcr;
    UCHAR           HDReady, HDAck, HDFinished;

    Controller = Extension->Controller;

    // Read Byte according to 1284 spec.
    ParDump2(PARENTRY,("ParByteModeRead: Start\n"));

    dcr = GetControl (Controller);

    // Set Direction to be in reverse
    dcr |= DCR_DIRECTION;
    StoreControl (Controller, dcr);    

    HDReady = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, INACTIVE, ACTIVE );
    HDAck = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, ACTIVE, INACTIVE );
    HDFinished = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, ACTIVE, ACTIVE );

    switch (Extension->CurrentPhase) {
    
        case PHASE_REVERSE_IDLE:

            ParDump2(PARINFO,("ParByteModeRead: PHASE_REVERSE_IDLE\n"));
            // Check to see if the peripheral has indicated Interrupt Phase and if so, 
            // get us ready to reverse transfer.

            for (;;) {

                // See if data is available (looking for state 7)
                dsr = GetStatus(Controller);

                if (dsr & DSR_NOT_DATA_AVAIL) {

                    // Data is NOT available - do nothing
                    // The device doesn't report any data, it still looks like it is
                    // in ReverseIdle.  Just to make sure it hasn't powered off or somehow
                    // jumped out of Byte mode, test also for AckDataReq high and XFlag low
                    // and nDataAvaul high.
                    if( (dsr & DSR_BYTE_VALIDATION) != DSR_BYTE_TEST_RESULT ) {

                        Status = STATUS_IO_DEVICE_ERROR;
                        Extension->CurrentPhase = PHASE_UNKNOWN;

                        ParDump2(PARERRORS, ("ParByteModeRead:Failed State 7: Controller %x dcr %x\n",
                                            Controller, dcr));
                    }
                    goto ByteReadExit;

                } else {

                    // Data is available, go to Reverse Transfer Phase
                    Extension->CurrentPhase =  PHASE_REVERSE_XFER ;
                    // Go to Reverse XFER phase
                    goto PhaseReverseXfer;
                }

            }
        
PhaseReverseXfer:

        case PHASE_REVERSE_XFER: 
        
            ParDump2(PARINFO,("ParByteModeRead:PHASE_REVERSE_XFER\n"));
            
            for (i = 0; i < BufferSize; i++) {
            
                // Host enters state 7
                StoreControl (Controller, HDReady);

                // =============== Periph State 9     ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = low (signals state 9)
                // nAckReverse/AckDataReq   = Don't Care
                // XFlag                    = Don't Care
                // nPeriphReq/nDataAvail    = Don't Care
                if (!CHECK_DSR(Controller,
                               DONT_CARE, INACTIVE, DONT_CARE,
                               DONT_CARE, DONT_CARE,
                               IEEE_MAXTIME_TL)) {
                    // Time out.
                    // Bad things happened - timed out on this state,
                    // Mark Status as bad and let our mgr kill current mode.
                    Status = STATUS_IO_DEVICE_ERROR;

                    ParDump2(PARERRORS, ("ParByteModeRead:Failed State 9: Controller %x dcr %x\n",
                                          Controller, dcr));
                    Extension->CurrentPhase = PHASE_UNKNOWN;
                    goto ByteReadExit;
                }

                // Read the Byte                
                READ_PORT_BUFFER_UCHAR( Controller, lpsBufPtr++, (ULONG)0x01 );

                // Set host lines to indicate state 10.
                StoreControl (Controller, HDAck);

                // =============== Periph State 11     ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = High (signals state 11)
                // nAckReverse/AckDataReq   = Don't Care
                // XFlag                    = Don't Care
                // nPeriphReq/nDataAvail    = Don't Care
                if (!CHECK_DSR(Controller,
                               DONT_CARE, ACTIVE, DONT_CARE,
                               DONT_CARE, DONT_CARE,
                               IEEE_MAXTIME_TL)) {
                    // Time out.
                    // Bad things happened - timed out on this state,
                    // Mark Status as bad and let our mgr kill current mode.
                    Status = STATUS_IO_DEVICE_ERROR;

//                    Extension->IeeeTerminateIsOk = TRUE;
                    ParDump2(PARERRORS, ("ParByteModeRead:Failed State 11: Controller %x dcr %x\n",
                                          Controller, dcr));
                    Extension->CurrentPhase = PHASE_UNKNOWN;
                    goto ByteReadExit;
                }


                // Set host lines to indicate state 16.
                StoreControl (Controller, HDFinished);

                // At this point, we've either received the number of bytes we
                // were looking for, or the peripheral has no more data to
                // send, or there was an error of some sort (of course, in the
                // error case we shouldn't get to this comment).  Set the
                // phase to indicate reverse idle if no data available or
                // reverse data transfer if there's some waiting for us
                // to get next time.

                dsr = GetStatus(Controller);
                
                if (dsr & DSR_NOT_DATA_AVAIL) {
                
                    // Data is NOT available - go to Reverse Idle
                    // Really we are going to HBDNA, but if we set
                    // current phase to reverse idle, the next time
                    // we get into this function all we have to do
                    // is set hostbusy low to indicate idle and
                    // we have infinite time to do that.
                    // Break out of the loop so we don't try to read
                    // data that isn't there.
                    // NOTE - this is a successful case even if we
                    // didn't read all that the caller requested
                    Extension->CurrentPhase = PHASE_REVERSE_IDLE ;
                    i++; // account for this last byte transferred
                    break;

                } else {
                    // Data is available, go to (remain in ) Reverse Transfer Phase
                    Extension->CurrentPhase = PHASE_REVERSE_XFER ;
                }

            } // end for i loop

            *BytesTransferred = i;

            dsr = GetStatus(Controller);

            // DON'T FALL THRU THIS ONE
            break;

        default:
        
            Status = STATUS_IO_DEVICE_ERROR;
            Extension->CurrentPhase = PHASE_UNKNOWN ;

            ParDump2(PARERRORS, ("ParByteModeRead:Failed State 9: Unknown Phase. Controller %x dcr %x\n",
                                Controller, dcr));
            ParDump2(PARERRORS, ( "ParByteModeRead: You're hosed man.\n" ));
            ParDump2(PARERRORS, ( "ParByteModeRead: If you are here, you've got a bug somewhere else.\n" ));
            ParDump2(PARERRORS, ( "ParByteModeRead: Go fix it!\n" ));
            goto ByteReadExit;
            break;
    } // end switch

ByteReadExit:

    ParDump2(PARINFO,("ParByteModeRead:PHASE_REVERSE_IDLE\n"));
    
    if( Extension->CurrentPhase == PHASE_REVERSE_IDLE ) {
        // Host enters state 7  - officially in Reverse Idle now
        dcr |= DCR_NOT_HOST_BUSY;

        StoreControl (Controller, dcr);
    }

    // Set Direction to be in forward
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);    

    ParDump2(PAREXIT,("ParByteModeRead:End [%d] bytes read = %d\n",
                    NT_SUCCESS(Status), *BytesTransferred));
    Extension->log.ByteReadCount += *BytesTransferred;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

//
// This file contains functions that are only used for debugging the ParClass driver.
//

#include "pch.h"
#if (1 == DVRH_PAR_LOGFILE)
    #include "stdarg.h"
    #include "stdio.h"
#endif

static STRUCTUREOFFSETSTABLE gsotDEVICE_EXTENSION [] = {
    {"ExtensionSignature", FIELD_OFFSET(DEVICE_EXTENSION, ExtensionSignature)},
    {"DeviceType", FIELD_OFFSET(DEVICE_EXTENSION, DeviceType)},
    {"DeviceStateFlags", FIELD_OFFSET(DEVICE_EXTENSION, DeviceStateFlags)},
    {"Ieee1284_3DeviceId", FIELD_OFFSET(DEVICE_EXTENSION, Ieee1284_3DeviceId)},
    {"IsPdo", FIELD_OFFSET(DEVICE_EXTENSION, IsPdo)},
    {"EndOfChain", FIELD_OFFSET(DEVICE_EXTENSION, EndOfChain)},
    {"PodoRegForWMI", FIELD_OFFSET(DEVICE_EXTENSION, PodoRegForWMI)},
    {"ParClassFdo", FIELD_OFFSET(DEVICE_EXTENSION, ParClassFdo)},
    {"ParClassPdo", FIELD_OFFSET(DEVICE_EXTENSION, ParClassPdo)},
    {"Next", FIELD_OFFSET(DEVICE_EXTENSION, Next)},
    {"DeviceObject", FIELD_OFFSET(DEVICE_EXTENSION, DeviceObject)},
    {"PortDeviceObject", FIELD_OFFSET(DEVICE_EXTENSION, PortDeviceObject)},
    {"PortDeviceFileObject", FIELD_OFFSET(DEVICE_EXTENSION, PortDeviceFileObject)},
    {"PortSymbolicLinkName", FIELD_OFFSET(DEVICE_EXTENSION, PortSymbolicLinkName)},
    {"PhysicalDeviceObject", FIELD_OFFSET(DEVICE_EXTENSION, PhysicalDeviceObject)},
    {"ParentDeviceObject", FIELD_OFFSET(DEVICE_EXTENSION, ParentDeviceObject)},
    {"CurrentOpIrp", FIELD_OFFSET(DEVICE_EXTENSION, CurrentOpIrp)},
    {"NotificationHandle", FIELD_OFFSET(DEVICE_EXTENSION, NotificationHandle)},
    {"ClassName", FIELD_OFFSET(DEVICE_EXTENSION, ClassName)},
    {"SymbolicLinkName", FIELD_OFFSET(DEVICE_EXTENSION, SymbolicLinkName)},
    {"TimerStart", FIELD_OFFSET(DEVICE_EXTENSION, TimerStart)},
    {"CreatedSymbolicLink", FIELD_OFFSET(DEVICE_EXTENSION, CreatedSymbolicLink)},
    {"UsePIWriteLoop", FIELD_OFFSET(DEVICE_EXTENSION, UsePIWriteLoop)},
    {"Initialized", FIELD_OFFSET(DEVICE_EXTENSION, Initialized)},
    {"Initializing", FIELD_OFFSET(DEVICE_EXTENSION, Initializing)},
    {"OpenCloseRefCount", FIELD_OFFSET(DEVICE_EXTENSION, OpenCloseRefCount)},
    {"ParPortDeviceGone", FIELD_OFFSET(DEVICE_EXTENSION, ParPortDeviceGone)},
    {"RegForPptRemovalRelations", FIELD_OFFSET(DEVICE_EXTENSION, RegForPptRemovalRelations)},
    {"spare1", FIELD_OFFSET(DEVICE_EXTENSION, spare1)},
    {"IdxForwardProtocol", FIELD_OFFSET(DEVICE_EXTENSION, IdxForwardProtocol)},
    {"IdxReverseProtocol", FIELD_OFFSET(DEVICE_EXTENSION, IdxReverseProtocol)},
    {"CurrentEvent", FIELD_OFFSET(DEVICE_EXTENSION, CurrentEvent)},
    {"CurrentPhase", FIELD_OFFSET(DEVICE_EXTENSION, CurrentPhase)},
    {"PortHWMode", FIELD_OFFSET(DEVICE_EXTENSION, PortHWMode)},
    {"OpenCloseMutex", FIELD_OFFSET(DEVICE_EXTENSION, OpenCloseMutex)},
    {"DevObjListMutex", FIELD_OFFSET(DEVICE_EXTENSION, DevObjListMutex)},
    {"WorkQueue", FIELD_OFFSET(DEVICE_EXTENSION, WorkQueue)},
    {"ThreadObjectPointer", FIELD_OFFSET(DEVICE_EXTENSION, ThreadObjectPointer)},
    {"RequestSemaphore", FIELD_OFFSET(DEVICE_EXTENSION, RequestSemaphore)},
    {"OriginalController", FIELD_OFFSET(DEVICE_EXTENSION, OriginalController)},
    {"Controller", FIELD_OFFSET(DEVICE_EXTENSION, Controller)},
    {"EcrController", FIELD_OFFSET(DEVICE_EXTENSION, EcrController)},
    {"SpanOfController", FIELD_OFFSET(DEVICE_EXTENSION, SpanOfController)},
    {"TryAllocatePort", FIELD_OFFSET(DEVICE_EXTENSION, TryAllocatePort)},
    {"FreePort", FIELD_OFFSET(DEVICE_EXTENSION, FreePort)},
    {"QueryNumWaiters", FIELD_OFFSET(DEVICE_EXTENSION, QueryNumWaiters)},
    {"PortContext", FIELD_OFFSET(DEVICE_EXTENSION, PortContext)},
    {"HardwareCapabilities", FIELD_OFFSET(DEVICE_EXTENSION, HardwareCapabilities)},
    {"TrySetChipMode", FIELD_OFFSET(DEVICE_EXTENSION, TrySetChipMode)},
    {"ClearChipMode", FIELD_OFFSET(DEVICE_EXTENSION, ClearChipMode)},
    {"TrySelectDevice", FIELD_OFFSET(DEVICE_EXTENSION, TrySelectDevice)},
    {"DeselectDevice", FIELD_OFFSET(DEVICE_EXTENSION, DeselectDevice)},
    {"FifoDepth", FIELD_OFFSET(DEVICE_EXTENSION, FifoDepth)},
    {"FifoWidth", FIELD_OFFSET(DEVICE_EXTENSION, FifoWidth)},
    {"bAllocated", FIELD_OFFSET(DEVICE_EXTENSION, bAllocated)},
    {"BusyDelay", FIELD_OFFSET(DEVICE_EXTENSION, BusyDelay)},
    {"BusyDelayDetermined", FIELD_OFFSET(DEVICE_EXTENSION, BusyDelayDetermined)},
    {"DeferredWorkItem", FIELD_OFFSET(DEVICE_EXTENSION, DeferredWorkItem)},
    {"TimeToTerminateThread", FIELD_OFFSET(DEVICE_EXTENSION, TimeToTerminateThread)},
    {"UseNT35Priority", FIELD_OFFSET(DEVICE_EXTENSION, UseNT35Priority)},
    {"InitializationTimeout", FIELD_OFFSET(DEVICE_EXTENSION, InitializationTimeout)},
    {"AbsoluteOneSecond", FIELD_OFFSET(DEVICE_EXTENSION, AbsoluteOneSecond)},
    {"OneSecond", FIELD_OFFSET(DEVICE_EXTENSION, OneSecond)},
    {"Connected", FIELD_OFFSET(DEVICE_EXTENSION, Connected)},
    {"AllocatedByLockPort", FIELD_OFFSET(DEVICE_EXTENSION, AllocatedByLockPort)},
    {"spare4", FIELD_OFFSET(DEVICE_EXTENSION, spare4)},
    {"fnRead", FIELD_OFFSET(DEVICE_EXTENSION, fnRead)},
    {"fnWrite", FIELD_OFFSET(DEVICE_EXTENSION, fnWrite)},
    {"IdleTimeout", FIELD_OFFSET(DEVICE_EXTENSION, IdleTimeout)},
    {"ProtocolData", FIELD_OFFSET(DEVICE_EXTENSION, ProtocolData)},
    {"ForwardInterfaceAddress", FIELD_OFFSET(DEVICE_EXTENSION, ForwardInterfaceAddress)},
    {"ReverseInterfaceAddress", FIELD_OFFSET(DEVICE_EXTENSION, ReverseInterfaceAddress)},
    {"SetForwardAddress", FIELD_OFFSET(DEVICE_EXTENSION, SetForwardAddress)},
    {"SetReverseAddress", FIELD_OFFSET(DEVICE_EXTENSION, SetReverseAddress)},
    {"LockPortMutex", FIELD_OFFSET(DEVICE_EXTENSION, LockPortMutex)},
    {"DeviceState", FIELD_OFFSET(DEVICE_EXTENSION, DeviceState)},
    {"SystemState", FIELD_OFFSET(DEVICE_EXTENSION, SystemState)},
    {"spare2", FIELD_OFFSET(DEVICE_EXTENSION, spare2)},
    {"bShadowBuffer", FIELD_OFFSET(DEVICE_EXTENSION, bShadowBuffer)},
    {"ShadowBuffer", FIELD_OFFSET(DEVICE_EXTENSION, ShadowBuffer)},
    {"spare3", FIELD_OFFSET(DEVICE_EXTENSION, spare3)},
    {"bSynchWrites", FIELD_OFFSET(DEVICE_EXTENSION, bSynchWrites)},
    {"bFirstByteTimeout", FIELD_OFFSET(DEVICE_EXTENSION, bFirstByteTimeout)},
    {"bIsHostRecoverSupported", FIELD_OFFSET(DEVICE_EXTENSION, bIsHostRecoverSupported)},
    {"PauseEvent", FIELD_OFFSET(DEVICE_EXTENSION, PauseEvent)},
    {"ProtocolModesSupported", FIELD_OFFSET(DEVICE_EXTENSION, ProtocolModesSupported)},
    {"BadProtocolModes", FIELD_OFFSET(DEVICE_EXTENSION, BadProtocolModes)},
    {"ModeSafety", FIELD_OFFSET(DEVICE_EXTENSION, ModeSafety)},
    {"IsIeeeTerminateOk", FIELD_OFFSET(DEVICE_EXTENSION, IsIeeeTerminateOk)},
    {"IsCritical", FIELD_OFFSET(DEVICE_EXTENSION, IsCritical)},
    {"P12843DL", FIELD_OFFSET(DEVICE_EXTENSION, P12843DL)},
    {"log", FIELD_OFFSET(DEVICE_EXTENSION, log)},
    {"WmiLibContext", FIELD_OFFSET(DEVICE_EXTENSION, WmiLibContext)},
    {"WmiRegistrationCount", FIELD_OFFSET(DEVICE_EXTENSION, WmiRegistrationCount)},
    {"DeviceIdString", FIELD_OFFSET(DEVICE_EXTENSION, DeviceIdString)},
    {"DeviceDescription", FIELD_OFFSET(DEVICE_EXTENSION, DeviceDescription)},
    {"dummy", FIELD_OFFSET(DEVICE_EXTENSION, dummy)},
    {"RemoveLock", FIELD_OFFSET(DEVICE_EXTENSION, RemoveLock)},
    {"HwProfileChangeNotificationHandle", FIELD_OFFSET(DEVICE_EXTENSION, HwProfileChangeNotificationHandle)},
    {"ExtensionSignatureEnd", FIELD_OFFSET(DEVICE_EXTENSION, ExtensionSignatureEnd)},
    {NULL, sizeof(DEVICE_EXTENSION)}
};

#if DBG
#if (1 == DVRH_PAR_LOGFILE)
/**************************************************************************
Function:	DVRH_LogMessage()
Description:Logs message to configured output
Inputs:		Parameter indicated message log level and 
			Format string and parameters
Outputs:	Boolean value indicating success or failure
***************************************************************************/
BOOLEAN DVRH_LogMessage(PCHAR szFormat, ...)
{
	ULONG Length;
	char messagebuf[256];
	va_list va;
    IO_STATUS_BLOCK  IoStatus;
	OBJECT_ATTRIBUTES objectAttributes;
	NTSTATUS status;
	HANDLE FileHandle;
    UNICODE_STRING fileName;

	//format the string
    va_start(va,szFormat);
	vsprintf(messagebuf,szFormat,va);
	va_end(va);

	//get a handle to the log file object
    fileName.Buffer = NULL;
    fileName.Length = 0;
    fileName.MaximumLength = sizeof(DEFAULT_LOG_FILE_NAME) + sizeof(UNICODE_NULL);
    fileName.Buffer = ExAllocatePool(PagedPool,
                                        fileName.MaximumLength);
    if (!fileName.Buffer)
    {
        ParDump2(PARERRORS, ("LogMessage: FAIL. ExAllocatePool Failed.\n") );
        return FALSE;
    }
    RtlZeroMemory(fileName.Buffer, fileName.MaximumLength);
    status = RtlAppendUnicodeToString(&fileName, (PWSTR)DEFAULT_LOG_FILE_NAME);
	
	InitializeObjectAttributes (&objectAttributes,
								(PUNICODE_STRING)&fileName,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL );

	status = ZwCreateFile(&FileHandle,
					  FILE_APPEND_DATA,
					  &objectAttributes,
					  &IoStatus,
					  0, 
					  FILE_ATTRIBUTE_NORMAL,
					  FILE_SHARE_WRITE,
					  FILE_OPEN_IF,
					  FILE_SYNCHRONOUS_IO_NONALERT,
					  NULL,     
					  0 );

	if(NT_SUCCESS(status))
	{
		CHAR buf[300];
		LARGE_INTEGER time;
		KeQuerySystemTime(&time);

		//put a time stamp on the output message
		sprintf(buf,"%10u-%10u  %s",time.HighPart,time.LowPart,messagebuf);

		//format the string to make sure it appends a newline carrage-return to the 
		//end of the string.
		Length=strlen(buf);
		if(buf[Length-1]=='\n')
		{
			buf[Length-1]='\r';
			strcat(buf,"\n");
			Length++;
		}
		else
		{
			strcat(buf,"\r\n");
			Length+=2;
		}

		ZwWriteFile(FileHandle,
				  NULL,
				  NULL,
				  NULL,
				  &IoStatus,
				  buf,
				  Length,
				  NULL,
				  NULL );

		ZwClose(FileHandle);
	}
    if (fileName.Buffer)
        ExFreePool (fileName.Buffer);

	return STATUS_SUCCESS;
}


/**************************************************************************
Function:	DVRH_LogByteData()
Description:Formats byte data to be displayed in the configured output
Inputs:		Log level, Whether this is input or output data, a pointer to
			the byte data buffer and the size of the buffer
Outputs:	Boolean indicated success or failure
***************************************************************************/
#if 0
BOOLEAN DVRH_LogByteData(BOOLEAN READ,PCHAR szBuff,ULONG dwTransferred)
{
	CString	cStr;
	ULONG MAX_SIZE=80;
	UNICODE_STRING UniStr;
	ANSI_STRING AnsiStr;
	WCHAR wStr[8];
	PCHAR   szTemp=szBuff;
	UCHAR   bTemp;  
	ULONG	dwDisplaySize;

	UniStr.Length=0;
	UniStr.MaximumLength=8;
	UniStr.Buffer=wStr;
	AnsiStr.Length=0;
	AnsiStr.MaximumLength=0;
	AnsiStr.Buffer=NULL;

	if(READ)
		cStr=L"<RCV";
	else            
		cStr=L"SND>";

	//make sure the size of the requested string is within the set range
	dwDisplaySize=(((dwTransferred*3)+10) > MAX_SIZE)?((MAX_SIZE-10)/3):dwTransferred;

	//format byte data
	while(dwDisplaySize)
	{   
		bTemp=szTemp[0];
		if(bTemp > 0xF)
			cStr+=L" ";
		else
			cStr+=L" 0";

		RtlIntegerToUnicodeString(bTemp,16,&UniStr);
        		
		cStr+=UniStr.Buffer;

		szTemp++;
		dwDisplaySize--;
	}

	cStr.StringToAnsiString(&AnsiStr);
	LogMessage("%5u %s",dwTransferred,AnsiStr.Buffer);
	RtlFreeAnsiString(&AnsiStr);

	return (TRUE);
}
#endif
#endif // (1 == DVRH_PAR_LOGFILE)

VOID
ParInitDebugLevel (
    IN PUNICODE_STRING RegistryPath
   )
/*++

Routine Description:

    Checked Build Only!

    Initialize debugging variables from registry; set to default values
      if anything fails.

Arguments:

    RegistryPath            - Root path in registry where we should look

Return Value:

    None        

--*/

{
    NTSTATUS                 Status;
    RTL_QUERY_REGISTRY_TABLE paramTable[4];
    PWSTR                    path;
    ULONG                    defaultDebugLevel = PARDUMP_SILENT;
    ULONG                    defaultBreakOn    = PAR_BREAK_ON_NOTHING;
    ULONG                    defaultUseAsserts = 0; // don't use asserts


    //
    // We were given a counted string, but we need a null terminated string
    //
    path = ExAllocatePool(PagedPool, RegistryPath->Length+sizeof(WCHAR));

    if (!path) {
        // can't get a buffer, use defaults and return
        ParDebugLevel = defaultDebugLevel;
        ParBreakOn    = defaultBreakOn;
        ParUseAsserts = defaultUseAsserts;
        return;
    }

    RtlMoveMemory(path, RegistryPath->Buffer, RegistryPath->Length);
    path[ (RegistryPath->Length) / 2 ] = UNICODE_NULL;


    //
    // set up table entries for call to RtlQueryRegistryValues
    //
    RtlZeroMemory(&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = (PWSTR)L"ParDebugLevel";
    paramTable[0].EntryContext  = &ParDebugLevel;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &defaultDebugLevel;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = (PWSTR)L"ParBreakOn";
    paramTable[1].EntryContext  = &ParBreakOn;
    paramTable[1].DefaultType   = REG_DWORD;
    paramTable[1].DefaultData   = &defaultBreakOn;
    paramTable[1].DefaultLength = sizeof(ULONG);

    paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name          = (PWSTR)L"ParUseAsserts";
    paramTable[2].EntryContext  = &defaultUseAsserts;
    paramTable[2].DefaultType   = REG_DWORD;
    paramTable[2].DefaultData   = &defaultBreakOn;
    paramTable[2].DefaultLength = sizeof(ULONG);

    //
    // leave paramTable[3] as all zeros - this terminates the table
    //

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     path,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    if (!NT_SUCCESS(Status)) {
        // registry read failed, use defaults
        ParDebugLevel = defaultDebugLevel;
        ParBreakOn    = defaultBreakOn;
        ParUseAsserts = defaultUseAsserts;
    }

    ExFreePool( path );

    ParDumpV( ("ParDebugLevel = %08x , ParBreakOn = %08x\n", ParDebugLevel, ParBreakOn) );

}
#endif // DBG

#if DBG
VOID
ParDumpDeviceObjectList(
    PDEVICE_OBJECT ParClassFdo
    )

/*++

Routine Description:

    This function is a diagnostic routine that is only 
      available in Checked builds

    Dump the list of ParClass ejected Device Objects

Arguments:

    FdoDeviceObject - The ParClass Function Device Object

Return Value:

    NONE

--*/

{
    PDEVICE_EXTENSION FdoExtension = ParClassFdo ->DeviceExtension;
    PDEVICE_OBJECT    currentDO    = FdoExtension->ParClassPdo;

    ParDump(PARDUMP_VERBOSE_MAX,
            ("PARALLEL: ParDumpDeviceObjectList(...):\n") );

    while( currentDO ) {
        PDEVICE_EXTENSION currentExt = currentDO->DeviceExtension;
        ParDump(PARDUMP_VERBOSE_MAX,
                ("PARALLEL:  - %x %wZ %wZ\n",
                 currentDO, &currentExt->ClassName, &currentExt->SymbolicLinkName) );
        currentDO = ( (PDEVICE_EXTENSION)(currentDO->DeviceExtension) )->Next;
    }
}
#endif

NTSTATUS
ParAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    )
{
    NTSTATUS status;
    ParDump2(PARREMLOCK, ("debug::ParAcquireRemoveLock: RemoveLock= %x , Tag= %x\n", RemoveLock, Tag) );
    ParDump2(PARREMLOCK, ("debug::ParAcquireRemoveLock: Count [%x] Removed[%x] - calling IoAcquireRemoveLock\n",
                          RemoveLock->Common.IoCount, RemoveLock->Common.Removed));
    status = IoAcquireRemoveLock(RemoveLock, Tag);
    return status;
}

VOID
ParReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    )
{
    ParDump2(PARREMLOCK, ("debug::ParReleaseRemoveLock: RemoveLock= %x , Tag= %x\n", RemoveLock, Tag) );
    ParDump2(PARREMLOCK, ("debug::ParReleaseRemoveLock: Count [%x] Removed[%x] - calling IoReleaseRemoveLock\n", 
                          RemoveLock->Common.IoCount, RemoveLock->Common.Removed));
    IoReleaseRemoveLock(RemoveLock, Tag);
}

VOID
ParReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    )
{
    ParDump2(PARREMLOCK, ("debug::ParReleaseRemoveLockAndWait: RemoveLock= %x , Tag= %x\n", RemoveLock, Tag) );
    ParDump2(PARREMLOCK, ("debug::ParReleaseRemoveLock: Count [%x] Removed[%x] - calling IoReleaseRemoveLockAndWait\n", 
                          RemoveLock->Common.IoCount, RemoveLock->Common.Removed));
    IoReleaseRemoveLockAndWait(RemoveLock, Tag);
    ParDump2(PARREMLOCK, ("debug::ParReleaseRemoveLock: Count [%x] Removed[%x] - post IoReleaseRemoveLockAndWait\n", 
                          RemoveLock->Common.IoCount, RemoveLock->Common.Removed));
}

VOID ParDumpDevObjStructList(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead
    ) 
{
    PPAR_DEVOBJ_STRUCT current = DevObjStructHead;

    if( DevObjStructHead ) {
        ParDump2(PARPNP1, ("debug::ParDumpDevObjStructList - Enter\n") );
    } else {
        ParDump2(PARPNP1, ("debug::ParDumpDevObjStructList - Enter - Empty list - returning\n") );
        return;
    }

    while( current ) {
        ParDump2(PARPNP1, ("  Controller    = %x\n", current->Controller) );
        ParDump2(PARPNP1, ("  LegacyPodo    = %x\n", current->LegacyPodo) );
        ParDump2(PARPNP1, ("  EndOfChainPdo = %x\n", current->EndOfChainPdo) );
        ParDump2(PARPNP1, ("  Dot3Id0Pdo    = %x\n", current->Dot3Id0Pdo) );
        ParDump2(PARPNP1, ("  Dot3Id1Pdo    = %x\n", current->Dot3Id1Pdo) );
        ParDump2(PARPNP1, ("  Dot3Id2Pdo    = %x\n", current->Dot3Id2Pdo) );
        ParDump2(PARPNP1, ("  Dot3Id3Pdo    = %x\n", current->Dot3Id3Pdo) );
        ParDump2(PARPNP1, ("  LegacyZipPdo  = %x\n", current->LegacyZipPdo) );
        current = current->Next;
    }
    return;
}

VOID
ParDumpDevExtTable()
{
    ULONG i = 0;

    while( gsotDEVICE_EXTENSION[i].pszField ) {
        DbgPrint("%3x - %s\n", gsotDEVICE_EXTENSION[i].dwOffset, gsotDEVICE_EXTENSION[i].pszField);
        ++i;
    }

    DbgPrint("sizeof(DEVICE_EXTENSION) = %08x\n", gsotDEVICE_EXTENSION[i].dwOffset);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\becp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    becp.c

Abstract:

    This module contains code for the host to utilize BoundedECP if it has been
    detected and successfully enabled.

Author:

    Robbie Harris (Hewlett-Packard) 27-May-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
#include "readwrit.h"
#include "hwecp.h"

// The following error codes were added to reflect errors that are unique to 
// Bounded ECP
#define VE_FRAME_NO_DATA            -74      // attempt to enter FrameRev w/o nPerReq
#define VE_FRAME_CANT_EXIT_REVERSE  -75      // attempt to exit FrameRev w/ nPerReq

//=========================================================
// BECP::ExitReversePhase
//
// Description : Get out of BECP Reverse Phase to the common state
//
// Input Parameters : Controller, pPortInfoStruct
//
// Modifies :
//
// Pre-conditions :
//
// Post-conditions :
//
// Returns :
//
//=========================================================
NTSTATUS ParBecpExitReversePhase( IN  PDEVICE_EXTENSION   Extension )
{
    // When using BECP, test nPeriphRequest prior to negotiation 
    // from reverse phase to forward phase.  Do not negotiate unless the 
    // peripheral indicates it is finished sending.  If using any other
    // mode, negotiate immediately.
    if ( Extension->ModeSafety == SAFE_MODE ) {
        if (Extension->CurrentPhase == PHASE_REVERSE_IDLE)
        {
            if (!CHECK_DSR( Extension->Controller,
                            DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE,
		    		        IEEE_MAXTIME_TL) )
    	    {
                ParDump2(PARERRORS, ("ParBecpExitReversePhase: Periph Stuck. Can't Flip Bus\n"));
                return STATUS_IO_TIMEOUT;
            }
        }
    }
    return ParEcpHwExitReversePhase(Extension);
}

//============================================================================
// NAME:    ECPFrame::Read()
//
//
// LAC FRAME  12Dec97
//      This function is used for two different kinds of reads:
//        1) continuing read - where we don't expect to exit reverse mode afterwards
//        2) non-continuing read - where we expect to exit reverse mode afterwards
//      The problem is that we have no way of knowing which is which.  I can
//      either wait after each read for nPeriphRequest to drop, or I can
//      check to see if it has dropped when I enter and handle it then.  
//
//      The other problem is that we have no way of communicating the fact that 
//      we have done this to the PortTuple.  It uses the last_direction member
//      to decide whether it should even look at entering or exiting some phase.
//
//      Lets face it, we are on our own with this.  It is safer to leave it 
//      connected and then try to straighten things out when we come back.  I
//      know that this wastes some time, but so does waiting at the end of 
//      every read when only half of them are going to drop the nPeriphRequest.
//
//      This routine performs a 1284 ECP mode read into the given
//      buffer for no more than 'BufferSize' bytes.
//
//      This routine runs at DISPATCH_LEVEL.
//
// PARAMETERS:
//      Controller      - Supplies the base address of the parallel port.
//      pPortInfoStruct - Supplies port information as defined in p1284.h
//      Buffer          - Supplies the buffer to read into.
//      BufferSize      - Supplies the number of bytes in the buffer.
//      BytesTransferred - Returns the number of bytes transferred.
//
// RETURNS:
//      NTSTATUS STATUS_SUCCESS or...
//      The number of bytes successfully read from the port is
//      returned via one of the arguments passed into this method.
//
// NOTES:
//      - Called ECP_PatchReverseTransfer in the original 16 bit code.
//
//============================================================================
NTSTATUS
ParBecpRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    ParDump2(PARENTRY,("ParBecpRead: Enter BufferSize[%d]\n", BufferSize));
    status = ParEcpHwRead( Extension, Buffer, BufferSize, BytesTransferred );

    if (NT_SUCCESS(status)) {

        PUCHAR Controller;

        Controller = Extension->Controller;
        if ( CHECK_DSR_WITH_FIFO( Controller, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE,
                                  ECR_FIFO_EMPTY, ECR_FIFO_SOME_DATA,
                                  DEFAULT_RECEIVE_TIMEOUT) ) {    
            ParDump2(PARINFO,("ParBecpRead: No more data. Flipping to Fwd.\n"));
            //
            // Bounded ECP rule - no more data from periph - flip bus to forward
            //
            status = ParReverseToForward( Extension );
            ParDump2(PARINFO,("ParBecpRead: We have flipped to Fwd.\n"));

        } else {
            UCHAR bDSR = READ_PORT_UCHAR( Controller + OFFSET_DSR );
            
            //
            // Periph still has data, check for valid state
            //

            ParDump2(PARINFO,("ParBecpRead: Periph says there is more data.  Checking for stall.\n"));
            // It's OK for the device to continue asserting nPeriphReq,
            // it may have more data to send.  However, nAckReverse and
            // XFlag should be in a known state, so double check them.
            if ( ! TEST_DSR( bDSR, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, DONT_CARE ) ) {
                #if DVRH_BUS_RESET_ON_ERROR
                    BusReset(Controller + OFFSET_DCR);  // Pass in the dcr address
                #endif
                status = STATUS_LINK_FAILED;
            	ParDump2(PARERRORS,("ParBecpRead: nAckReverse and XFlag are bad.\n"));
            } else {
                //
                // Periph has correctly acknowledged that it has data (state valid)
                //
                if ( (TRUE == Extension->P12843DL.bEventActive) ) {
                    //
                    // Signal transport (e.g., dot4) that data is avail
                    //
                    KeSetEvent(Extension->P12843DL.Event, 0, FALSE);
                }
            }

        }
    }
    
    ParDump2(PAREXIT, ("ParBecpRead: Exit[%d] BytesTransferred[%d]\r\n", NT_SUCCESS(status), *BytesTransferred));
    return status;
}

NTSTATUS
ParEnterBecpMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    BECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if ( Extension->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Extension, BECP_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Extension, BECP_EXTENSIBILITY);
        }
    } else {
        Extension->Connected = TRUE;
    }
    
    if (NT_SUCCESS(Status)) {
        Status = ParEcpHwSetupPhase(Extension);
        Extension->bSynchWrites = TRUE;     // NOTE this is a temp hack!!!  dvrh
        if (!Extension->bShadowBuffer)
        {
            Queue_Create(&(Extension->ShadowBuffer), Extension->FifoDepth * 2);	
            Extension->bShadowBuffer = TRUE;
        }
        Extension->IsIeeeTerminateOk = TRUE;
    }

    ParDump2(PARENTRY,("ParEnterBecpMode: End [%d]\n", NT_SUCCESS(Status)));
    return Status;
}

BOOLEAN
ParIsBecpSupported(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    NTSTATUS Status;

    if (Extension->BadProtocolModes & BOUNDED_ECP)
    {
        ParDump2(PARINFO, ("ParIsBecpSupported: FAILED: BOUNDED_ECP has been marked as BadProtocolModes\n"));
        return FALSE;
    }

    if (Extension->ProtocolModesSupported & BOUNDED_ECP)
    {
        ParDump2(PARINFO, ("ParIsBecpSupported: PASSED: BOUNDED_ECP has already been cheacked\n"));
        return TRUE;
    }

    if (!(Extension->HardwareCapabilities & PPT_ECP_PRESENT))
    {
        ParDump2(PARINFO, ("ParIsBecpSupported: FAILED: No HWECP\n"));
        return FALSE;
    }

    if (0 == Extension->FifoWidth)
    {
        ParDump2(PARINFO, ("ParIsBecpSupported: FAILED: No FifoWidth\n"));
        return FALSE;
    }
        
    // Must use BECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterBecpMode (Extension, FALSE);
    ParTerminateBecpMode (Extension);

    if (NT_SUCCESS(Status)) {
    
        Extension->ProtocolModesSupported |= BOUNDED_ECP;
        ParDump2(PARINFO, ("ParIsBecpSupported: PASSED:\n"));
        return TRUE;
    }
    ParDump2(PARINFO, ("ParIsBecpSupported: FAILED: BOUNDED_ECP didn't negotiate\n"));
    return FALSE;
}

VOID
ParTerminateBecpMode(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    ParDump2( PARENTRY, ("ParTerminateBecpMode: Entry CurrentPhase %d\r\n", Extension->CurrentPhase));

	// Need to check current phase -- if its reverse, need to flip bus
	// If its not forward -- its an incorrect phase and termination will fail.
    switch (Extension->CurrentPhase)
	{
		case  PHASE_FORWARD_IDLE:	// Legal state to terminate
		{
			break;
		}
        case PHASE_REVERSE_IDLE:	// Flip the bus so we can terminate
        {
            NTSTATUS status = ParEcpHwExitReversePhase( Extension );

        	if ( STATUS_SUCCESS == status )
        	{
        		status = ParEcpEnterForwardPhase(Extension );
        	}
            else
            {
                ParDump2( PARERRORS, ("ParTerminateBecpMode: Couldn't flip the bus\n"));
            }
            break;
        }
		case  PHASE_FORWARD_XFER:
        case  PHASE_REVERSE_XFER:
		{
            ParDump2( PARERRORS, ("ParTerminateBecpMode: invalid wCurrentPhase (XFer in progress) \r\n"));
			//status = VE_BUSY;
            // Dunno what to do here.  We probably will confuse the peripheral.
			break;
		}
		// LAC TERMINATED  13Jan98
		// Included PHASE_TERMINATE in the switch so we won't return an
		// error if we are already terminated.
		case PHASE_TERMINATE:
		{
			// We are already terminated, nothing to do
			break;
		}	
        default:
        {
            ParDump2( PARERRORS, ("ParTerminateBecpMode: VE_CORRUPT: invalid CurrentPhase %d\r\n", Extension->CurrentPhase));
            //status = VE_CORRUPT;
            // Dunno what to do here.  We're lost and don't have a map to figure
            // out where we are!
            break;
        }
	}

    ParEcpHwWaitForEmptyFIFO(Extension);
    ParCleanupHwEcpPort(Extension);
    if ( Extension->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Extension);
    } else {
        ParDump2(PARINFO, ("ParTerminateBecpMode: In UNSAFE_MODE.\n"));
        Extension->Connected = FALSE;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\devobj.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       devobj.c
//
//--------------------------------------------------------------------------

// this file contains functions to create, initialize, manage, and destroy ParClass device objects

#include "pch.h"

extern WCHAR   ParInt2Wchar[];

VOID
ParMakeClassNameFromPortLptName(
    IN  PUNICODE_STRING PortSymbolicLinkName, 
    OUT PUNICODE_STRING ClassName
    )
/*

  Get LPTx name from ParPort device and use this name to construct the \Device\Parallely name.

  y = x-1  (i.e., LPT3 => \Device\Parallel2)

*/
{
    NTSTATUS       status;
    PDEVICE_OBJECT portDeviceObject;
    PFILE_OBJECT   portDeviceFileObject;
    PWSTR          portName;
    ULONG          portNumber;
    LONG           count;
    UNICODE_STRING str;

    // Get a pointer to the ParPort device
    status = IoGetDeviceObjectPointer(PortSymbolicLinkName, STANDARD_RIGHTS_ALL,
                                      &portDeviceFileObject, &portDeviceObject);
    if( !NT_SUCCESS(status) ) {
        ParDump2(PARPNP1, ("devobj::ParMakeClassNameFromPortLptName - unable to get handle to parport device\n"));
        return;
    }

    // Get LPTx portName from ParPort device
    portName = ParGetPortLptName( portDeviceObject );

    // Done with handle 
    ObDereferenceObject( portDeviceFileObject );

    // Did we get a portName?
    if( 0 == portName ) {
        ParDump2(PARPNP1, ("devobj::ParMakeClassNameFromPortLptName - unable to get portName from parport device\n"));
        return;
    }

    // Verify that the portname looks like LPTx where x is a number
    ParDump2(PARPNP1, ("devobj::ParMakeClassNameFromPortLptName - portName = <%S>\n", portName));

    if( portName[0] != L'L' || portName[1] != L'P' || portName[2] != L'T' ) {
        ParDump2(PARPNP1, ("devobj::ParMakeClassNameFromPortLptName - name prefix doesn't look like LPT\n"));
        return;
    }

    // prefix is LPT, check for integer suffix with value > 0
    RtlInitUnicodeString( &str, (PWSTR)&portName[3] );

    status = RtlUnicodeStringToInteger( &str, 10, &portNumber );
    if( !NT_SUCCESS( status ) ) {
        ParDump2(PARPNP1, ("devobj::ParMakeClassNameFromPortLptName - name suffix doesn't look like an integer\n"));
        return;
    }

    if( portNumber == 0 ) {
        ParDump2(PARPNP1, ("devobj::ParMakeClassNameFromPortLptName - name suffix == 0 - FAIL - Invalid value\n"));
        return;
    }

    ParDump2(PARPNP1, ("devobj::ParMakeClassNameFromPortLptName - LPT name suffix= %d\n", portNumber));

    // Build \Device\Parallely name from LPTx name
    ParMakeClassNameFromNumber( portNumber-1, ClassName );

    ParDump2(PARPNP1, ("devobj::ParMakeClassNameFromPortLptName - portName=<%S>  className=<%wZ>\n", 
                       portName, ClassName));

}

// return TRUE if given a pointer to a ParClass PODO, FALSE otherwise
BOOLEAN
ParIsPodo(PDEVICE_OBJECT DevObj) {
    PDEVICE_EXTENSION devExt = DevObj->DeviceExtension;

    if( !devExt->IsPdo ) {
        // this is an FDO
        return FALSE;
    }

    // still here? - this is either a PODO or a PDO

    if( devExt->DeviceIdString[0] != 0 ) {
        // this device object has a device ID string - It's a PDO
        return FALSE;
    }

    // still here? - this is either a PODO, or a PDO marked "hardware gone" that
    //  is simply waiting for PnP to send it a REMOVE.

    if( devExt->DeviceStateFlags & PAR_DEVICE_HARDWARE_GONE) {
        // this is a PDO marked "hardware gone"
        return FALSE;
    }

    // still here? - this is a PODO
    return TRUE;
}

#if USE_TEMP_FIX_FOR_MULTIPLE_INTERFACE_ARRIVAL
//
// Temp fix for PnP calling us multiple times for the same interface arrival
// 
// 
// Return Value: Did we already process an interface arrival for this interface?
//
BOOLEAN
ParIsDuplicateInterfaceArrival(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION NotificationStruct,
    IN  PDEVICE_OBJECT                        Fdo
    )
{
    PUNICODE_STRING   portSymbolicLinkName = NotificationStruct->SymbolicLinkName;
    PDEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PDEVICE_OBJECT    curDevObj;
    PDEVICE_EXTENSION curDevExt;

    PAGED_CODE();

    ParDump2(PARPNP1, ("Enter ParIsDuplicateInterfaceArrival()\n"));

    //
    // Find the ParClass PODOs and compare the PortSymbolicLinkName in the 
    //   device extension with the one in the interface arrival notification.
    //
    curDevObj = fdoExt->ParClassPdo;
    while( curDevObj ) {
        curDevExt = curDevObj->DeviceExtension;
        if( ParIsPodo(curDevObj) ) {
            ParDump2(PARPNP1, ("DevObj= %x IS PODO\n",curDevObj) );
            ParDump2(PARPNP1, ("Comparing port symbolic link names\n"));
            if( RtlEqualUnicodeString(portSymbolicLinkName,&curDevExt->PortSymbolicLinkName, FALSE) ) {
                ParDump2(PARPNP1, ("MATCH! - Second Arrival of this Interface\n"));
                return TRUE;
            } else {
                ParDump2(PARPNP1, ("NO match on port symbolic link name for interface arrival - keep searching\n"));
            }
        } else {
            ParDump2(PARPNP1, ("DevObj= %x NOT a PODO\n",curDevObj) );
        }
        curDevObj = curDevExt->Next;
    }

    return FALSE;
}
#endif

NTSTATUS
ParPnpNotifyInterfaceChange(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION NotificationStruct,
    IN  PDEVICE_OBJECT                        Fdo
    )
/*++dvdf

Routine Description:

    This routine is the PnP "interface change notification" callback routine.

    This gets called on a ParPort triggered device interface arrival or removal.
      - Interface arrival corresponds to a ParPort device being STARTed
      - Interface removal corresponds to a ParPort device being REMOVEd

    On arrival:
      - Create the LPTx PODO (PlainOldDeviceObject) for legacy/raw port access.
      - Query for an EOC (End-Of-Chain) PnP Device, create PDO if device found.
      - Enumerate all 1284.3 DC (Daisy Chain) devices attached to the port.

    This callback is a NO-OP for interface removal because all ParClass created
      P[O]DOs register for PnP EventCategoryTargetDeviceChange callbacks and
      use that callback to clean up when their associated ParPort device goes
      away.

Arguments:

    NotificationStruct  - Structure defining the change.

    Fdo                                - pointer to ParClass FDO 
                                         (supplied as the "context" when we 
                                          registered for this callback)
Return Value:

    STATUS_SUCCESS - always, even if something goes wrong

--*/
{
    PUNICODE_STRING   portSymbolicLinkName = NotificationStruct->SymbolicLinkName;
    PDEVICE_OBJECT    legacyPodo;
    PDEVICE_EXTENSION legacyExt;
    //    PDEVICE_OBJECT    endOfChainPdo;
    PDEVICE_OBJECT    portDeviceObject;
    PFILE_OBJECT      portDeviceFileObject;
    NTSTATUS          status;
    BOOLEAN           foundNewDevice = FALSE;
    // UCHAR             dot3DeviceCount;

    PAGED_CODE();

    //
    // Verify that interface class is a ParPort device interface.
    //
    // Any other InterfaceClassGuid is an error, but let it go since
    //   it is not fatal to the machine.
    //
    if( !IsEqualGUID( (LPGUID)&(NotificationStruct->InterfaceClassGuid),
                      (LPGUID)&GUID_PARALLEL_DEVICE) ) {
        ParDump2(PARERRORS, ("ParPnpNotifyInterfaceChange() - ERROR - Bad InterfaceClassGuid\n") );
        return STATUS_SUCCESS;
    }


    //
    // This callback is a NO-OP for interface removal.
    //
    // All ParClass DO's that depend on this interface register for target
    //   device change PnP notification on the ParPort device associated
    //   with this interface. 
    //
    // Thus, all such ParClass DO's that depend on this interface will
    //   have already received target device change notification callbacks
    //   that the ParPort device associated with this interface is being
    //   removed prior to the arrival of this interface removal
    //   notification callback.
    //
    if(!IsEqualGUID( (LPGUID)&(NotificationStruct->Event), 
                     (LPGUID)&GUID_DEVICE_INTERFACE_ARRIVAL )) {
        ParDump2(PARPNP1, ("Interface Removal Notification\n") );
        return STATUS_SUCCESS;
    }


    //
    // A ParPort device has STARTed and we are the bus driver for the port. 
    //   Continue...
    //

#if USE_TEMP_FIX_FOR_MULTIPLE_INTERFACE_ARRIVAL
    //
    // Temp fix for PnP calling us multiple times for the same interface arrival
    // 
    if( ParIsDuplicateInterfaceArrival(NotificationStruct, Fdo) ) {
        ParDump2(PARERRORS, ("Duplicate Interface Arrival Notification - Returning/Ignoring\n") );
        return STATUS_SUCCESS;
    }
#endif

    //
    // Get a pointer to and create a FILE against the ParPort device
    //
    status = IoGetDeviceObjectPointer(portSymbolicLinkName, STANDARD_RIGHTS_ALL,
                                      &portDeviceFileObject, &portDeviceObject);
    if( !NT_SUCCESS(status) ) {
        ParDump2(PARERRORS, ("ParPnpNotifyInterfaceChange() - ERROR - unable to get device object port to ParPort device\n") );
        return STATUS_SUCCESS;
    }


    //
    // Acquire the ParPort device
    //
    status = ParAcquirePort(portDeviceObject, NULL);
    if( !NT_SUCCESS(status) ) {
        ParDump2(PARERRORS, ("ParPnpNotifyInterfaceChange() - ERROR - unable to acquire port\n") );
        ObDereferenceObject(portDeviceFileObject);
        return STATUS_SUCCESS;
    }


    // 
    // Create the Legacy LPTx PODO (PlainOldDeviceObject) for raw port access.
    //
    legacyPodo = ParCreateLegacyPodo(Fdo, portSymbolicLinkName);
    if( !legacyPodo ) {
        // If we can't create the legacyPodo, then nothing following will 
        //   succeed, so bail out.
        ParDump2(PARERRORS, ("ParPnpNotifyInterfaceChange() - ERROR - unable to create legacyPodo\n") );
        ParReleasePort(portDeviceObject);
        ObDereferenceObject(portDeviceFileObject);
        return STATUS_SUCCESS;
    }
        

    // 
    // SUCCESS - Legacy PODO created
    //
    legacyExt = legacyPodo->DeviceExtension;
    ParDump2(PARPNP1, ("devobj::ParPnpNotifyInterfaceChange - CREATED legacyPODO - <%wZ> <%wZ>\n",
                       &legacyExt->ClassName, &legacyExt->SymbolicLinkName) );


    //
    // Legacy PODO - add to list of ParClass created device objects
    //
    ParAddDevObjToFdoList(legacyPodo);


    //
    // release port and close our FILE to Parport device (our PODO and PDOs 
    //   have their own FILEs open against parport)
    //
    ParReleasePort(portDeviceObject);
    ObDereferenceObject(portDeviceFileObject);


    //
    // Tell PnP that we might have some new children
    //
    {
        PDEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
        ParDump2(PARPNP1, ("devobj::ParPnpNotifyInterfaceChange - calling IoInvalidateDeviceRelations(,BusRelations)\n") );
        IoInvalidateDeviceRelations(fdoExt->PhysicalDeviceObject, BusRelations);
    }

    return STATUS_SUCCESS;
}

PDEVICE_OBJECT
ParCreateLegacyPodo(
    IN PDEVICE_OBJECT  Fdo, 
    IN PUNICODE_STRING PortSymbolicLinkName
    )
/*++dvdf

Routine Description:

    This routine creates the LPTx PODO (PlainOldDeviceObject) that is
      used for legacy/raw port access.

    - create a classname of the form "\Device\ParallelN"
    - create device object
    - initialize device object and extension
    - create symbolic link
    - register for PnP TargetDeviceChange notification
    
Arguments:

    Fdo                  - pointer to ParClass FDO

    PortSymbolicLinkName - symbolic link name of the ParPort device

Return Value:

    PDEVICE_OBJECT - on success
    NULL           - otherwise

--*/

{
    NTSTATUS            status;
    UNICODE_STRING      className = {0,0,0};
    PDEVICE_OBJECT      legacyPodo;
    PDEVICE_EXTENSION   legacyExt;
    PDRIVER_OBJECT      driverObject = Fdo->DriverObject;

#define PAR_CLASSNAME_OFFSET 8

    PAGED_CODE();


    //
    // Legacy PODO - try to build a \Device\Parallely classname based on the LPTx name 
    //   retrieved from the ParPort device
    //
    ParMakeClassNameFromPortLptName(PortSymbolicLinkName, &className);

    if( !className.Buffer ) {
        //
        // We failed to construct a ClassName from the Port's 
        //   LPTx name - just make up a name 
        //
        // Use an offset so that the name we make up doesn't collide 
        //   with other ports
        //
        ParMakeClassNameFromNumber( PAR_CLASSNAME_OFFSET + g_NumPorts++, &className );
        if( !className.Buffer ) {
            // unable to create class name, bail out
            return NULL;
        }
    }


    //
    // Legacy PODO - create device object
    //
    status = ParCreateDevice(driverObject, sizeof(DEVICE_EXTENSION), &className,
                            FILE_DEVICE_PARALLEL_PORT, 0, TRUE, &legacyPodo);

    if( !NT_SUCCESS( status ) ) {
        //
        // We failed to create a device, if failure was due to a name collision, then
        //   make up a new classname and try again
        //
        if( status == STATUS_OBJECT_NAME_COLLISION || status == STATUS_OBJECT_NAME_EXISTS ) {
            // name collision - make up a new classname and try again
            RtlFreeUnicodeString( &className );
            ParMakeClassNameFromNumber( PAR_CLASSNAME_OFFSET + g_NumPorts++, &className );
            if( !className.Buffer ) {
                // unable to create class name, bail out
                return NULL;
            }
            status = ParCreateDevice(driverObject, sizeof(DEVICE_EXTENSION), &className,
                                    FILE_DEVICE_PARALLEL_PORT, 0, TRUE, &legacyPodo);
        }
    }


    if( !NT_SUCCESS( status ) ) {
        // unable to create device object, bail out
        RtlFreeUnicodeString(&className);
        ParLogError(driverObject, NULL, PhysicalZero, PhysicalZero, 
                    0, 0, 0, 9, STATUS_SUCCESS, PAR_INSUFFICIENT_RESOURCES);
        return NULL;
    }

    legacyExt = legacyPodo->DeviceExtension;

    //
    // Legacy PODO - initialize device object and extension
    //
    ParInitCommonDOPre(legacyPodo, Fdo, &className);
    status = ParInitLegacyPodo(legacyPodo, PortSymbolicLinkName);
    if( !NT_SUCCESS( status ) ) {
        // initialization failed, clean up and bail out
        ParAcquireListMutexAndKillDeviceObject(Fdo, legacyPodo);
        return NULL;
    }

    //
    // Note that we are a PODO in our extension
    //
    legacyExt->DeviceType = PAR_DEVTYPE_PODO;


    ParInitCommonDOPost(legacyPodo);

    //
    // Legacy PODO - create symbolic link
    //
    if( legacyExt->SymbolicLinkName.Buffer ) {

        status = IoCreateUnprotectedSymbolicLink(&legacyExt->SymbolicLinkName, 
                                                 &legacyExt->ClassName);

        if ( NT_SUCCESS(status) ) {
            // note this in our extension for later cleanup
            legacyExt->CreatedSymbolicLink = TRUE;
            
            // Write symbolic link map info to the registry.
            status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                           (PWSTR)L"PARALLEL PORTS",
                                           legacyExt->ClassName.Buffer,
                                           REG_SZ,
                                           legacyExt->SymbolicLinkName.Buffer,
                                           legacyExt->SymbolicLinkName.Length +
                                               sizeof(WCHAR));
            
            if (!NT_SUCCESS(status)) {
                // unable to write map info to registry - continue anyway
                ParLogError(legacyPodo->DriverObject, legacyPodo, 
                            legacyExt->OriginalController, PhysicalZero, 
                            0, 0, 0, 6, status, PAR_NO_DEVICE_MAP_CREATED);
            }
            
        } else {
            
            // unable to create the symbolic link.
            legacyExt->CreatedSymbolicLink = FALSE;
            RtlFreeUnicodeString(&legacyExt->SymbolicLinkName);
            ParLogError(legacyPodo->DriverObject, legacyPodo, 
                        legacyExt->OriginalController, PhysicalZero, 
                        0, 0, 0, 5, status, PAR_NO_SYMLINK_CREATED);
        }
        
    } else {
        // extension does not contain a symbolic link name for us to use
        legacyExt->CreatedSymbolicLink = FALSE;
    }

    if( FALSE == legacyExt->CreatedSymbolicLink ) {
        // Couldn't create a symbolic Link
        //   clean up and bail out
        ParAcquireListMutexAndKillDeviceObject(Fdo, legacyPodo);
        return NULL;
    }

    //
    // Legacy PODO - register for PnP TargetDeviceChange notification
    //
    status = IoRegisterPlugPlayNotification(EventCategoryTargetDeviceChange,
                                            0,
                                            (PVOID)legacyExt->PortDeviceFileObject,
                                            driverObject,
                                            (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) ParPnpNotifyTargetDeviceChange,
                                            (PVOID)legacyPodo,
                                            &legacyExt->NotificationHandle);

    if( !NT_SUCCESS(status) ) {
        // PnP registration for TargetDeviceChange notification failed,
        //   clean up and bail out
        ParAcquireListMutexAndKillDeviceObject(Fdo, legacyPodo);
        return NULL;
    }

    //
    // Register for WMI
    //
    status = ParWmiPdoInitWmi( legacyPodo );
    if( !NT_SUCCESS( status ) ) {
        // WMI registration failed, clean up and bail out
        ParAcquireListMutexAndKillDeviceObject(Fdo, legacyPodo);
        return NULL;
    } else {
        //
        // Note in our extension that we have registered for WMI
        //   so we can clean up later
        //
        legacyExt->PodoRegForWMI = TRUE;
    }

    return legacyPodo;
}

VOID
ParInitCommonDOPre(
    IN PDEVICE_OBJECT  DevObj, 
    IN PDEVICE_OBJECT  Fdo, 
    IN PUNICODE_STRING ClassName
    )
/*++dvdf - code complete - compiles clean - not tested

Routine Description:

    This routine contains common initialization code for ParClass
      created PDOs and PODOs that should be called before (Pre) the
      device object type specific (PDO/PODO) intialization function 
      is called.

Arguments:

    DevObj    - points to the DeviceObject to be initialized

    Fdo       - points to the ParClass FDO

    ClassName - points to the ClassName for the PDO/PODO

Return Value:

    None - This function can not fail.

--*/
{
    PDEVICE_EXTENSION   extension;

    PAGED_CODE();

    // - we use buffered IO
    // - force power dispatch at PASSIVE_LEVEL IRQL so we can page driver
    // DevObj->Flags |= (DO_BUFFERED_IO | DO_POWER_PAGABLE);
    DevObj->Flags |= DO_BUFFERED_IO; // RMT - should also set POWER_PAGABLE

    // initialize extension to all zeros
    extension = DevObj->DeviceExtension;
    RtlZeroMemory(extension, sizeof(DEVICE_EXTENSION));

    // used by debugger extension
    extension->ExtensionSignature    = PARCLASS_EXTENSION_SIGNATURE;
    extension->ExtensionSignatureEnd = PARCLASS_EXTENSION_SIGNATURE;

    // initialize synchronization and list mechanisms
    ExInitializeFastMutex(&extension->OpenCloseMutex);
    InitializeListHead(&extension->WorkQueue);
    KeInitializeSemaphore(&extension->RequestSemaphore, 0, MAXLONG);
    KeInitializeEvent(&extension->PauseEvent, NotificationEvent, TRUE);


    // general info
    extension->ClassName            = *ClassName; // copy the struct
    extension->DeviceObject         = DevObj;

    extension->EndOfChain           = TRUE;                 // override later if this is a
    extension->Ieee1284_3DeviceId   = DOT3_END_OF_CHAIN_ID; //   1284.3 Daisy Chain device

    extension->IsPdo                = TRUE;       // really means !FDO
    extension->ParClassFdo          = Fdo;
    extension->BusyDelay            = 0;
    extension->BusyDelayDetermined  = FALSE;
    
    // timing constants
    extension->TimerStart           = PAR_WRITE_TIMEOUT_VALUE;
    extension->IdleTimeout.QuadPart -= 250*10*1000;       // 250 ms
    extension->AbsoluteOneSecond.QuadPart = 10*1000*1000;
    extension->OneSecond.QuadPart   = -(extension->AbsoluteOneSecond.QuadPart);

    // init IEEE 1284 protocol settings
    ParInitializeExtension1284Info( extension );
}

NTSTATUS
ParInitLegacyPodo(
    IN PDEVICE_OBJECT  LegacyPodo,
    IN PUNICODE_STRING PortSymbolicLinkName
    )
/*++

Routine Description:

    This function performs ParClass DeviceObject and DeviceExtension
    initialization specific to ParClass Legacy PODOs (Plain Old Device
    Objects). A Legacy PODO represents the "raw" parallel port and is 
    used by legacy drivers to communicate with parallel port connected 
    devices.

    Precondition:
      - ParInitCommonPre(...)  must be called with this DeviceObject before
                                this function is called.

    Postcondition:
      - ParInitCommonPost(...) must be called with this DeviceObject after
                                this function is called.

    On error, this routine defers cleaning up the LegacyPodo DeviceObject
      and any pool allocations to the caller.

Arguments:

    LegacyPodo           - pointer to the legacy device object to initialize

    PortSymbolicLinkName - symbolic link name of ParPort device

Return Value:

    STATUS_SUCCESS      - on success
    STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS            status               = STATUS_SUCCESS;
    PDEVICE_EXTENSION   legacyExt            = LegacyPodo->DeviceExtension;
    PWSTR               buffer               = NULL;
    PFILE_OBJECT        portDeviceFileObject = NULL;
    PDEVICE_OBJECT      portDeviceObject     = NULL;

    PAGED_CODE();

    //
    // Get a pointer to and create a FILE against the ParPort device
    //
    //  - We need a pointer to the ParPort DeviceObject so that we can send 
    //      it IRPs.
    //
    //  - We need a FILE against the DeviceObject to keep the ParPort 
    //      DeviceObject from "going away" while we are using it. 
    //
    //  - Having an open FILE against the ParPort DeviceObject will also prevent
    //      PnP from doing a resource rebalance on the ParPort DeviceObject and 
    //      changing its resources while we are holding pointers to the ParPort 
    //      device's registers. This works because a ParPort DeviceObject fails 
    //      PnP QUERY_STOP IRPs if anyone has an open FILE against it.
    //
    status = IoGetDeviceObjectPointer(PortSymbolicLinkName,
                                      STANDARD_RIGHTS_ALL,
                                      &portDeviceFileObject,
                                      &portDeviceObject);
    if( !NT_SUCCESS(status) ) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // success - save pointer to ParPort DeviceObject and a copy of the 
    //             REFERENCED pointer to the FILE created against the ParPort
    //             DeviceObject in our extension
    //
    legacyExt->PortDeviceObject        = portDeviceObject;
    legacyExt->PortDeviceFileObject    = portDeviceFileObject;

    //
    // Save a copy of the ParPort SymbolicLinkName in our device extension.
    //
    buffer = ParCreateWideStringFromUnicodeString(PortSymbolicLinkName);
    if( !buffer ) {
        // unable to copy PortSymbolicLinkName, bail out
        return STATUS_UNSUCCESSFUL;
    }
    // copy ParPort SymbolicLinkName to our device extension
    RtlInitUnicodeString(&legacyExt->PortSymbolicLinkName, buffer);
    
    //
    // make sure that IRPs sent to us have enough stack locations so that we 
    //   can forward them to ParPort if needed
    //
    legacyExt->DeviceObject->StackSize = (CHAR)( legacyExt->PortDeviceObject->StackSize + 1 );

    //
    // Obtain PARALLEL_PORT_INFORMATION and PARALLEL_PNP_INFORMATION from 
    //   the ParPort device and save it in our device extension 
    //  
    status = ParGetPortInfoFromPortDevice(legacyExt);
    if (!NT_SUCCESS(status)) {
        ParLogError(LegacyPodo->DriverObject, LegacyPodo, PhysicalZero, PhysicalZero,
                    0, 0, 0, 4, status, PAR_CANT_FIND_PORT_DRIVER);
        return STATUS_UNSUCCESSFUL;
    }
        
    if (legacyExt->OriginalController.HighPart == 0 &&
        legacyExt->OriginalController.LowPart  == (ULONG_PTR) legacyExt->Controller) {
        
        legacyExt->UsePIWriteLoop = FALSE;
    } else {
        legacyExt->UsePIWriteLoop = TRUE;
    }
        
    return STATUS_SUCCESS;
}

VOID
ParInitCommonDOPost(
    IN PDEVICE_OBJECT DevObj
    )
/*++dvdf - code complete - compiles clean - not tested

Routine Description:

    This routine contains common initialization code for ParClass
      created PDOs and PODOs that should be called after (Post) the
      device object type specific (PDO/PODO) intialization function 
      is called.

Arguments:

    DevObj    - points to the DeviceObject to be initialized

Return Value:

    None - This function can not fail.

--*/
{
    PAGED_CODE();

    // Check the registry for parameter overrides
    ParCheckParameters(DevObj->DeviceExtension);

    // Tell the IO system that we are ready to receive IRPs
    DevObj->Flags &= ~DO_DEVICE_INITIALIZING;
}

PDEVICE_OBJECT
ParDetectCreateEndOfChainPdo(
    IN PDEVICE_OBJECT LegacyPodo
    )
/*++

Routine Description:

    Detect if an EndOfChain device is connected. If so, create a PDO for the
      device and add the PDO to the list of ParClass children.
    
Arguments:

    LegacyPodo - pointer to the legacy PODO for the port.

Return Value:

    Pointer to the new PDO if device found

    NULL otherwise

--*/
{
    PDEVICE_OBJECT newPdo = ParDetectCreatePdo( LegacyPodo, DOT3_END_OF_CHAIN_ID, FALSE );

    if( newPdo ) {
        ParAddDevObjToFdoList( newPdo );
    }

    return newPdo;    
}

PDEVICE_OBJECT
ParDetectCreatePdo(
    IN PDEVICE_OBJECT LegacyPodo, 
    IN UCHAR          Dot3Id,
    IN BOOLEAN        bStlDot3Id
    )
/*++

Routine Description:

    Detect if there is a 1284 device attached.
    If a device is detected then create a PDO to represent the device.

Preconditions:
    Caller has acquired the ParPort device
    Caller has SELECTed the device
    
Postconditions:
    ParPort device is still acquired
    Device is still SELECTed
    
Arguments:

    LegacyPodo - points to the Legacy PODO for the port

    Dot3Id     - 1284.3 daisy chain id
                   0..3 is daisy chain device
                      4 is end of chain device 

Return Value:

    PDEVICE_OBJECT - on success, points to the PDO we create
    NULL           - otherwise 

--*/
{
    PDEVICE_EXTENSION  legacyExt            = LegacyPodo->DeviceExtension;
    PDRIVER_OBJECT     driverObject         = LegacyPodo->DriverObject;
    PDEVICE_OBJECT     fdo                  = legacyExt->ParClassFdo;
    UNICODE_STRING     className            = {0,0,NULL};
    NTSTATUS           status;
    PCHAR              deviceIdString       = NULL;
    ULONG              deviceIdLength;
    PDEVICE_OBJECT     newDevObj            = NULL;
    PDEVICE_EXTENSION  newDevExt;
    ULONG              idTry                = 1;
    ULONG              maxIdTries           = 3;

    BOOLEAN            useModifiedClassName = FALSE;
    UNICODE_STRING     modifiedClassName;
    UNICODE_STRING     suffix;
    UNICODE_STRING     dash;
    WCHAR              suffixBuffer[10];
    ULONG              number               = 0;
    ULONG              maxNumber            = 256;
    ULONG              newLength;


    PAGED_CODE();

    //
    // Query for PnP device
    //
    while( (NULL == deviceIdString) && (idTry <= maxIdTries) ) {
        deviceIdString = Par3QueryDeviceId(legacyExt, NULL, 0, &deviceIdLength, FALSE, bStlDot3Id);
        if( NULL == deviceIdString ) {
            ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - no 1284 ID on try %d\n", idTry) );
            KeStallExecutionProcessor(1);
            ++idTry;
        } else {
             ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - devIdString=<%s> on try %d\n", deviceIdString, idTry) );
        }
    }

    if( !deviceIdString ) {
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - no 1284 ID, bail out\n") );
        return NULL;
    }


    //
    // Found PnP Device, create a PDO to represent the device
    //  - create classname
    //  - create device object
    //  - initialize device object and extension
    //  - create symbolic link
    //  - register for PnP TargetDeviceChange notification
    //
    

    //
    // Create a class name of the form \Device\ParallelN,
    //
    ParMakeDotClassNameFromBaseClassName(&legacyExt->ClassName, Dot3Id, &className);
    if( !className.Buffer ) {
        // unable to construct ClassName
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - unable to construct ClassName for device\n") );
        ExFreePool(deviceIdString);
        return NULL;
    }
    

    //
    // create device object
    //
    status = ParCreateDevice(driverObject, sizeof(DEVICE_EXTENSION), &className,
                            FILE_DEVICE_PARALLEL_PORT, 0, TRUE, &newDevObj);

    ///
    if( status == STATUS_OBJECT_NAME_COLLISION ) {
        //
        // old name is still in use, appending a suffix and try again
        //
        
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - ParCreateDevice FAILED due to name Collision on <%wZ> - retry\n", &className));
        
        useModifiedClassName = TRUE;

        suffix.Length            = 0;
        suffix.MaximumLength     = sizeof(suffixBuffer);
        suffix.Buffer            = suffixBuffer;
        
        RtlInitUnicodeString( &dash, (PWSTR)L"-" );
        
        newLength = className.MaximumLength + 5*sizeof(WCHAR); // L"-XXX" suffix
        modifiedClassName.Length        = 0;
        modifiedClassName.MaximumLength = (USHORT)newLength;
        modifiedClassName.Buffer        = ExAllocatePool(PagedPool, newLength);
        if( NULL == modifiedClassName.Buffer ) {
            ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - ParCreateDevice FAILED - no PagedPool avail\n"));
            ExFreePool(deviceIdString);
            RtlFreeUnicodeString( &className );
            return NULL;
        }
        
        while( ( status == STATUS_OBJECT_NAME_COLLISION ) && ( number <= maxNumber ) ) {
            
            status = RtlIntegerToUnicodeString(number, 10, &suffix);
            if ( !NT_SUCCESS(status) ) {
                ExFreePool(deviceIdString);
                RtlFreeUnicodeString( &className );
                RtlFreeUnicodeString( &modifiedClassName );
                return NULL;
            }
            
            RtlCopyUnicodeString( &modifiedClassName, &className );
            RtlAppendUnicodeStringToString( &modifiedClassName, &dash );
            RtlAppendUnicodeStringToString( &modifiedClassName, &suffix );
            
            ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - trying ParCreateDevice with className <%wZ>\n", &modifiedClassName));
            status = ParCreateDevice(driverObject, sizeof(DEVICE_EXTENSION), &modifiedClassName,
                                    FILE_DEVICE_PARALLEL_PORT, 0, TRUE, &newDevObj);
            if( NT_SUCCESS( status ) ) {
                ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - ParCreateDevice returned SUCCESS with className <%wZ>\n", &modifiedClassName));
            } else {
                ++number;
            }
        }
    }
    ///
        
    if( useModifiedClassName ) {
        // copy modifiedClassName to className
        RtlFreeUnicodeString( &className );
        className = modifiedClassName;
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - copy useModifiedClassName to className - className=<%wZ>\n", &className));        
    }


    if( !NT_SUCCESS(status) ) {
        // unable to create device object, bail out
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - unable to create device object "
                           "className=<%wZ>, bail out - status=%x\n", &className, status) );
        ExFreePool(deviceIdString);
        RtlFreeUnicodeString(&className);
        ParLogError(fdo->DriverObject, NULL, PhysicalZero, PhysicalZero,
                    0, 0, 0, 9, STATUS_SUCCESS, PAR_INSUFFICIENT_RESOURCES);
        return NULL;
    } else {
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - device created <%wZ>\n", &className));        
    }
    //
    // device object created
    //
    newDevExt = newDevObj->DeviceExtension;

    //
    // initialize device object and extension
    //
    ParInitCommonDOPre(newDevObj, fdo, &className);
    status = ParInitPdo(newDevObj, (PUCHAR)deviceIdString, deviceIdLength, LegacyPodo, Dot3Id);
    if( !NT_SUCCESS( status ) ) {
        // initialization failed, clean up and bail out
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - call to ParInitPdo failed, bail out\n") );
        ParAcquireListMutexAndKillDeviceObject(fdo, newDevObj);
        return NULL;
    }
    ParInitCommonDOPost(newDevObj);
    
    //
    // create symbolic link
    //
    if( newDevExt->SymbolicLinkName.Buffer ) {

        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - ready to create symlink - SymbolicLinkName <%wZ>, ClassName <%wZ>\n",
                           &newDevExt->SymbolicLinkName, &newDevExt->ClassName) );
        ParDump2(PARPNP1, (" - Length=%hd, MaximumLength=%hd\n", newDevExt->ClassName.Length, newDevExt->ClassName.MaximumLength) );

        // doug
        ASSERT(newDevExt->ClassName.Length < 100);

        PAGED_CODE();
        status = IoCreateUnprotectedSymbolicLink(&newDevExt->SymbolicLinkName, &newDevExt->ClassName);

        if ( NT_SUCCESS(status) ) {
            // note this in our extension for later cleanup
            ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - SymbolicLinkName -> ClassName = <%wZ> -> <%wZ>\n",
                               &newDevExt->SymbolicLinkName, &newDevExt->ClassName) );
            newDevExt->CreatedSymbolicLink = TRUE;
            
            // Write symbolic link map info to the registry.
            status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                           (PWSTR)L"PARALLEL PORTS",
                                           newDevExt->ClassName.Buffer,
                                           REG_SZ,
                                           newDevExt->SymbolicLinkName.Buffer,
                                           newDevExt->SymbolicLinkName.Length +
                                               sizeof(WCHAR));
            
            if (!NT_SUCCESS(status)) {
                // unable to write map info to registry - continue anyway
                ParLogError(newDevObj->DriverObject, newDevObj, 
                            newDevExt->OriginalController, PhysicalZero, 
                            0, 0, 0, 6, status, PAR_NO_DEVICE_MAP_CREATED);
            }
            
        } else {
            
            // unable to create the symbolic link.
            ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - unable to create SymbolicLink - status = %x\n",status));
            newDevExt->CreatedSymbolicLink = FALSE;
            RtlFreeUnicodeString(&newDevExt->SymbolicLinkName);
            ParLogError(newDevObj->DriverObject, newDevObj, 
                        newDevExt->OriginalController, PhysicalZero, 
                        0, 0, 0, 5, status, PAR_NO_SYMLINK_CREATED);
        }
        
    } else {
        // extension does not contain a symbolic link name for us to use
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - extension does not contain a symbolic link for us to use\n"));
        newDevExt->CreatedSymbolicLink = FALSE;
    }
    
    // End-Of-Chain PDO - register for PnP TargetDeviceChange notification
    status = IoRegisterPlugPlayNotification(EventCategoryTargetDeviceChange,
                                            0,
                                            (PVOID)newDevExt->PortDeviceFileObject,
                                            driverObject,
                                            (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) ParPnpNotifyTargetDeviceChange,
                                            (PVOID)newDevObj,
                                            &newDevExt->NotificationHandle);

    if( !NT_SUCCESS(status) ) {
        // PnP registration for TargetDeviceChange notification failed,
        //   clean up and bail out
        ParDump2(PARPNP1, ("devobj::ParDetectCreatePdo - PnP registration failed, killing PDO\n") );
        ParAcquireListMutexAndKillDeviceObject(fdo, newDevObj);
        return NULL;
    }

    return newDevObj;
}

NTSTATUS
ParInitPdo(
    IN PDEVICE_OBJECT NewPdo, 
    IN PUCHAR         DeviceIdString,
    IN ULONG          DeviceIdLength,
    IN PDEVICE_OBJECT LegacyPodo,
    IN UCHAR          Dot3Id
    )
{
    static WCHAR ParInt2Wchar[] = { L'0', L'1', L'2', L'3', L'4', L'5' };
    NTSTATUS status;
    PDEVICE_EXTENSION  legacyExt     = LegacyPodo->DeviceExtension;
    PDEVICE_EXTENSION  newExt = NewPdo->DeviceExtension;

    //
    // start with identical initialization as done for Legacy PODO
    //
    status = ParInitLegacyPodo(NewPdo, &legacyExt->PortSymbolicLinkName);
    if( !NT_SUCCESS(status) ) {
        return status;
    }
    
    //
    // Fixup extension if we are a daisy chain device or legacy Zip
    //
    newExt->Ieee1284Flags = legacyExt->Ieee1284Flags;
    if( Dot3Id != DOT3_END_OF_CHAIN_ID ) {
        newExt->EndOfChain = FALSE;
        newExt->Ieee1284_3DeviceId = Dot3Id;
        // NewPdo->Flags &= ~DO_POWER_PAGABLE; // RMT - temp clear bit until ppa, disk, partmgr set it
    }

    //
    // Note that we are a PDO in our extension
    //
    newExt->DeviceType = PAR_DEVTYPE_PDO;


    //
    // use PODO's SymbolicLinkName + a ".N" suffix as the PDO's SymbolicLinkName
    //
    {
        UNICODE_STRING newSymLinkName;
        USHORT index;
        USHORT length = (USHORT)( newExt->SymbolicLinkName.Length + ( 3 * sizeof(WCHAR) ) );
        ParDump2(PARPNP1, ("devobj::ParInitPdo - old SymLinkName=%wZ\n", &newExt->SymbolicLinkName) );
        RtlInitUnicodeString(&newSymLinkName, NULL);
        newSymLinkName.Buffer = ExAllocatePool(PagedPool, length);
        if( !newSymLinkName.Buffer ) {
            return STATUS_UNSUCCESSFUL;
        }
        newSymLinkName.Length=0;
        newSymLinkName.MaximumLength=length;
        RtlCopyUnicodeString(&newSymLinkName, &newExt->SymbolicLinkName);
        index = (USHORT) ( (newExt->SymbolicLinkName.Length)/sizeof(WCHAR) );
        newSymLinkName.Buffer[index+0] = L'.';
        newSymLinkName.Buffer[index+1] = ParInt2Wchar[Dot3Id];
        newSymLinkName.Buffer[index+2] = L'\0';
        newSymLinkName.Length += (2 * sizeof(WCHAR));
        RtlFreeUnicodeString(&newExt->SymbolicLinkName);
        newExt->SymbolicLinkName = newSymLinkName;
        ParDump2(PARPNP1, ("devobj::ParInitPdo - new SymLinkName=%wZ\n", &newExt->SymbolicLinkName) );
        ParDump2(PARPNP1, (" - Length=%hd, MaximumLength=%hd\n", newExt->SymbolicLinkName.Length, newExt->SymbolicLinkName.MaximumLength) );
    }

    // initialize PnP fields of device extension
    {
        UCHAR RawString[128];
        UCHAR DescriptionString[128];
        PUCHAR deviceIdString;

        deviceIdString = ExAllocatePool(PagedPool, DeviceIdLength + sizeof(UCHAR) );
        if( deviceIdString ) {
            RtlCopyMemory(deviceIdString, DeviceIdString, DeviceIdLength);
            *(deviceIdString+DeviceIdLength) = 0; // NULL terminate
        }

        RtlZeroMemory( RawString, sizeof(RawString) );
        RtlZeroMemory( DescriptionString, sizeof(DescriptionString) );
        status = ParPnpGetId(DeviceIdString, BusQueryDeviceID, RawString, DescriptionString);
        
        if (NT_SUCCESS(status)) {
            RtlCopyMemory(newExt->DeviceIdString,    RawString,         strlen((const PCHAR)RawString));
            RtlCopyMemory(newExt->DeviceDescription, DescriptionString, strlen((const PCHAR)DescriptionString));
            if( deviceIdString ) {
                ParDetectDot3DataLink(newExt, deviceIdString);
            }
        }

        if( deviceIdString ) {
            ExFreePool(deviceIdString);
        }

    }
    return status;
}

PWSTR
ParGetPortLptName(
    IN PDEVICE_OBJECT PortDeviceObject
    )
// return 0 on any error
{
    NTSTATUS                    status;
    PARALLEL_PNP_INFORMATION    pnpInfo;

    // Get Parallel Pnp Info from ParPort device, return PortName

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO,
                                       PortDeviceObject, NULL, 0, 
                                       &pnpInfo, sizeof(PARALLEL_PNP_INFORMATION), NULL);
    if( NT_SUCCESS(status) ) {
        return (PWSTR)(pnpInfo.PortName);
    } else {
        ParDump2(PARERRORS, ("devobj::ParGetPortLptName - FAILED - returning 0\n"));
        return 0;
    }
}

UCHAR
ParGet1284_3DeviceCount(
    IN PDEVICE_OBJECT PortDeviceObject
    )
// return 0 on any error

{
    NTSTATUS                    status;
    PARALLEL_PNP_INFORMATION    pnpInfo;

    // Get Parallel Pnp Info from ParPort device, return Dot3 device Id count returned

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO,
                                       PortDeviceObject, NULL, 0, 
                                       &pnpInfo, sizeof(PARALLEL_PNP_INFORMATION), NULL);
    if( NT_SUCCESS(status) ) {
        return (UCHAR)(pnpInfo.Ieee1284_3DeviceCount);
    } else {
        ParDump2(PARERRORS, ("devobj::ParGet1284_3DeviceCount - FAILED - returning 0\n"));
        return 0;
    }
}

NTSTATUS
ParBuildSendInternalIoctl(
    IN  ULONG           IoControlCode,
    IN  PDEVICE_OBJECT  TargetDeviceObject,
    IN  PVOID           InputBuffer         OPTIONAL,
    IN  ULONG           InputBufferLength,
    OUT PVOID           OutputBuffer        OPTIONAL,
    IN  ULONG           OutputBufferLength,
    IN  PLARGE_INTEGER  RequestedTimeout    OPTIONAL
    )
/*++dvdf

Routine Description:

    This routine builds and sends an Internal IOCTL to the TargetDeviceObject, waits
    for the IOCTL to complete, and returns status to the caller.

    *** WORKWORK - dvdf 12Dec98: This function does not support Input and Output in the same IOCTL

Arguments:

    IoControlCode       - the IOCTL to send
    TargetDeviceObject  - who to send the IOCTL to
    InputBuffer         - pointer to input buffer, if any
    InputBufferLength,  - length of input buffer
    OutputBuffer        - pointer to output buffer, if any
    OutputBufferLength, - length of output buffer
    Timeout             - how long to wait for request to complete, NULL==use driver global AcquirePortTimeout

Return Value:

    Status

--*/
{
    NTSTATUS           status;
    PIRP               irp;
    LARGE_INTEGER      timeout;
    KEVENT             event;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN            needToCopyOutputBuffer = FALSE;

    PAGED_CODE();

    ParDump2(PARIOCTL1,("devobj::ParBuildSendInternalIoctl: Enter\n"));

    //
    // Current limitation is that this function does not handle a request with
    //   both InputBufferLength and OutputBufferLength > 0
    //
    if( InputBufferLength != 0 && OutputBufferLength != 0 ) {
        // ASSERTMSG("ParBuildSendInternalIoctl does not support input and output in the same IOCTL \n", FALSE);
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Allocate and initialize IRP
    //
    irp = IoAllocateIrp( (CCHAR)(TargetDeviceObject->StackSize + 1), FALSE );
    if( !irp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength  = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode      = IoControlCode;


    if( InputBufferLength != 0 ) {
        irp->AssociatedIrp.SystemBuffer = InputBuffer;
    } else if( OutputBufferLength != 0 ) {
        irp->AssociatedIrp.SystemBuffer = OutputBuffer;
    }


    //
    // Set completion routine and send IRP
    //
    KeInitializeEvent( &event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( irp, ParSynchCompletionRoutine, &event, TRUE, TRUE, TRUE );

    status = ParCallDriver(TargetDeviceObject, irp);

    if( !NT_SUCCESS(status) ) {
        ParDump2(PARIOCTL1,("devobj::ParBuildSendInternalIoctl: ParCallDriver FAILED - status=%x\n",status));
        IoFreeIrp( irp );
        return status;
    }

    //
    // Set timeout and wait
    //
    //                                      user specified   : default
    timeout = (NULL != RequestedTimeout) ? *RequestedTimeout : AcquirePortTimeout;
    status = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &timeout);

    //
    // Did we timeout or did the IRP complete?
    //
    if( status == STATUS_TIMEOUT ) {
        // we timed out - cancel the IRP
        IoCancelIrp( irp );
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    //
    // Irp is complete, grab the status and free the irp
    //
    status = irp->IoStatus.Status;
    IoFreeIrp( irp );

    return status;
}

NTSTATUS
ParSelect1284_3Device(
    IN  PDEVICE_OBJECT PortDeviceObject,
    IN  UCHAR          Dot3DeviceId
    )
/*++dvdf

Routine Description:

    This routine selects a 1284.3 daisy chain device via an 
      IOCTL_INTERNAL_SELECT_DEVICE sent to the ParPort to which
      our device is connected.

    Note: Caller must have already Acquired the Port prior to calling this function.

Arguments:

    PortDeviceObject - points to the ParPort that the device is connected to.

    Dot3DeviceId     - IEEE 1284.3 daisy chain id (in the range [0..3]) to be selected.

Return Value:

    STATUS_SUCCESS   - if the device was selected
    !STATUS_SUCCESS  - otherwise

--*/
{
    PARALLEL_1284_COMMAND  par1284Command;

    par1284Command.ID           = Dot3DeviceId;
    par1284Command.Port         = 0;
    par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT; // we have already Acquired the port

    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_SELECT_DEVICE, 
                                     PortDeviceObject, 
                                     &par1284Command, sizeof(PARALLEL_1284_COMMAND),
                                     NULL, 0, NULL);
}

NTSTATUS
ParDeselect1284_3Device(
    IN  PDEVICE_OBJECT PortDeviceObject,
    IN  UCHAR          Dot3DeviceId
    )
/*++dvdf

Routine Description:

    This routine selects a 1284.3 daisy chain device via an 
      IOCTL_INTERNAL_SELECT_DEVICE sent to the ParPort to which
      our device is connected.

    Note: This function does not Release the port so the Caller still has 
            the port after this function returns.

Arguments:

    PortDeviceObject - points to the ParPort that the device is connected to.

    Dot3DeviceId     - IEEE 1284.3 daisy chain id (in the range [0..3]) to be selected.

Return Value:

    STATUS_SUCCESS   - if the device was selected
    !STATUS_SUCCESS  - otherwise

--*/
{
    PARALLEL_1284_COMMAND  par1284Command;

    par1284Command.ID           = Dot3DeviceId;
    par1284Command.Port         = 0;
    par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT; // just Deselect device, don't Release port

    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_DESELECT_DEVICE, 
                                     PortDeviceObject, 
                                     &par1284Command, sizeof(PARALLEL_1284_COMMAND), 
                                     NULL, 0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\debug.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    debug.h

Abstract:

    This module contains debug macros and goodies.

Author:

    Robbie Harris (Hewlett-Packard) 1-July-1998

Environment:

    Kernel mode

Revision History :

--*/
#define DDPnP1(_x_)
#define DD(_x_)
// #define DDPnP1(_x_) DbgPrint _x_

#ifndef _DEBUG_
#define _DEBUG_

#if (1 == DVRH_DELAY_THEORY)
    extern int DVRH_wt;
    extern int DVRH_wb;
    extern int DVRH_rt;
    extern int DVRH_rb;
#endif

typedef struct tagSTRUCTUREOFFSETSTABLE {
	char * pszField;
	unsigned long dwOffset;
} STRUCTUREOFFSETSTABLE, *PSTRUCTUREOFFSETSTABLE;

#if DBG
    // PAR_TEST_HARNESS is used to enable a special mode to bucket
    // writes and siphon reads to a test harness.  This functionality
    // is for debugging purposes only.
    //          0 - off
    //          1 - on
    #define PAR_TEST_HARNESS    0

    // use with ParDebugLevel and ParDump(...)
    #define PARALWAYS             ((ULONG)0xffffffff)   // Set all the bits. So this will always show

    #define PARERRORS             ((ULONG)0x00000001)
    #define PARUNLOAD             ((ULONG)0x00000002)
    #define PARINITDEV            ((ULONG)0x00000004)
    #define PARIRPPATH            ((ULONG)0x00000008)

    #define PARSTARTER            ((ULONG)0x00000010)
    #define PAROPENCLOSE          ((ULONG)0x00000020)
    #define PARREMLOCK            ((ULONG)0x00000040)
    #define PARTHREAD             ((ULONG)0x00000080)

    #define PARIEEE               ((ULONG)0x00000100)
    #define PAREXIT               ((ULONG)0x00000200)
    #define PARENTRY              ((ULONG)0x00000400)
    #define PARENTRY_EXIT         (PARENTRY | PAREXIT)
    #define PARINFO               ((ULONG)0x00000800)

    #define PARECPTRACE           ((ULONG)0x00001000)
    #define PARALLOCFREEPORT      ((ULONG)0x00002000)
    #define PARSELECTDESELECT     ((ULONG)0x00004000) 
    #define PARDOT3DL             ((ULONG)0x00008000)

    #define PARPNP1               ((ULONG)0x00010000) // device object create/kill - major events
    #define PARPNP2               ((ULONG)0x00020000) // device object create/kill - verbose
    #define PARPNP4               ((ULONG)0x00040000)
    #define PARPNP8               ((ULONG)0x00080000)

    #define PARLGZIP              ((ULONG)0x00100000) // Legacy Zip drive
    #define PARRESCAN             ((ULONG)0x00200000) // bus rescan - QUERY_DEVICE_RELATIONS/BusRelations
    #define PARIOCTL1             ((ULONG)0x00400000) // IOCTL related info
    #define PARIOCTL2             ((ULONG)0x00800000) // IOCTL related info

    #define PARDUMP_PNP_PARPORT   ((ULONG)0x01000000) // ParPort PnP interface and device notification callback activity

    #define PARDUMP_PNP_DL        ((ULONG)0x02000000) // 1284.3 DL PnP
    #define PARREG                ((ULONG)0x04000000) // registry operations
    #define PARPOWER              ((ULONG)0x08000000)

    #define PARDUMP_SILENT        ((ULONG)0x00000000)


    #define PARDUMP_VERBOSE       ((ULONG)0x20000000)
    #define PARDUMP_VERBOSE_VERY  ((ULONG)0x40000000)
    #define PARDUMP_VERBOSE_MAX   ((ULONG)0xFFFFFFFF)

    // use with ParBreakOn
    #define PAR_BREAK_ON_NOTHING                   ((ULONG)0x00000000)
    #define PAR_BREAK_ON_DRIVER_ENTRY              ((ULONG)0x00000001)
    #define PAR_BREAK_ON_UNLOAD                    ((ULONG)0x00000002)
    #define PAR_BREAK_ON_ADD_DEVICE                ((ULONG)0x00000004)
    #define PAR_BREAK_ON_DEV_1                     ((ULONG)0x00000100)


    extern ULONG ParDebugLevel;     // How verbose do we want parallel.sys to be with DbgPrint messages?
    extern ULONG ParBreakOn;        // What conditions do we want to break on?
    extern ULONG ParUseAsserts;     // 0 == disable ASSERTs
#endif // DBG

#if DBG
    // DVRH_SHOW_DEBUG_SPEW 0 - Debug Spew is off
    //                      1 - Debug Spew is on
    //  - Note:  The timer spew is not controlled by this
    //           Look at DVRH_SHOW_SHALLOW_TIMER and
    //           DVRH_SHOW_DEEP_TIMER.                
    #define DVRH_SHOW_DEBUG_SPEW   1

    // DVRH_SHOW_SHALLOW_TIMER  0 - Entry Timers off
    //                          1 - Entry Timers on
    #define DVRH_SHOW_SHALLOW_TIMER 0

    // DVRH_SHOW_DEEP_TIMER 0 - Full Timer off
    //                      1 - Full Timer on
    #define DVRH_SHOW_DEEP_TIMER 0

    // DVRH_SHOW_BYTE_LOG   0 - Byte Log off
    //                      1 - Byte Log on
    #define DVRH_SHOW_BYTE_LOG  0

    // DVRH_PAR_LOGFILE is used to allow for debug logging to a file
    //  This functionality is for debugging purposes only.
    //          0 - off
    //          1 - on
    #define DVRH_PAR_LOGFILE    0

    // DVRH_BUS_RESET_ON_ERROR
    //  This functionality is for debugging purposes only.
    // Holds a bus reset for 100us when a handshaking error
    // is discovered.
    //          0 - off
    //          1 - on
    #define DVRH_BUS_RESET_ON_ERROR    0

#else
    #define DVRH_SHOW_DEBUG_SPEW    0
    #define DVRH_SHOW_SHALLOW_TIMER 0
    #define DVRH_SHOW_DEEP_TIMER    0
    #define DVRH_SHOW_BYTE_LOG  0
    #define DVRH_PAR_LOGFILE    0
    #define DVRH_BUS_RESET_ON_ERROR    0
#endif

#if (1 == DVRH_PAR_LOGFILE)
    #define DEFAULT_LOG_FILE_NAME	L"\\??\\C:\\tmp\\parallel.log"

    BOOLEAN DVRH_LogMessage(PCHAR szFormat, ...);
//    BOOLEAN DVRH_LogByteData(BOOLEAN READ,PCHAR szBuff,ULONG dwTransferred);
    #if 1
        #define DVRH_DbgPrint   DVRH_LogMessage
        #define DDF             DVRH_LogMessage
    #else
        // This is put in so I can pinpoint a single debug message
        #define DVRH_DbgPrint
        // #define DVRH_ShallowDbgMsg     DVRH_LogMessage
        #define DVRH_ShallowDbgMsg
    #endif
#else
    #define DVRH_DbgPrint   DbgPrint
    #define DVRH_ShallowDbgMsg
    #define DDF DbgPrint
#endif

#if (DBG && 1 == DVRH_SHOW_DEBUG_SPEW)
    #define ParAssert( ASSERTION )  if(ParUseAsserts) ASSERT( ASSERTION )

    #define ParDump(LEVEL,STRING) \
            if (ParDebugLevel & (LEVEL))  DVRH_DbgPrint STRING

    #define ParDump2(LEVEL,STRING) \
                if (ParDebugLevel & (LEVEL)) { \
                    DVRH_DbgPrint("PARALLEL: "); \
                    DVRH_DbgPrint STRING; \
                } 

        // display if we want PnP info
    #define ParDumpP(STRING) \
                if (ParDebugLevel & PARPNP1) { \
                    DVRH_DbgPrint("PARALLEL: "); \
                    DVRH_DbgPrint STRING; \
                } 

        // display if we want Register info
    #define ParDumpReg(LEVEL,STRING,ECRADDR,DCRADDR,DSRADDR) \
                if (ParDebugLevel & (LEVEL) ) { \
                    DVRH_DbgPrint("PARALLEL: "); \
                    DVRH_DbgPrint STRING; \
            	    DVRH_DbgPrint(" dsr[%02x] dcr[%02x] ecr[%02x]\r\n", \
            	                (int)READ_PORT_UCHAR(DSRADDR),   \
            	                (int)READ_PORT_UCHAR(DCRADDR),   \
            	                (int)READ_PORT_UCHAR(ECRADDR));   \
                } 

        // verbose - display if ANY debug flag is set
    #define ParDumpV(STRING) \
                if (ParDebugLevel & PARDUMP_VERBOSE_MAX) { \
                    DVRH_DbgPrint("PARALLEL: "); \
                    DVRH_DbgPrint STRING; \
                }

    #define ParBreak(BREAK_CONDITION,STRING) \
        if (ParBreakOn & (BREAK_CONDITION)) { \
            DVRH_DbgPrint("PARALLEL: Break: "); \
            DVRH_DbgPrint STRING; \
            DbgBreakPoint(); \
        }
#endif  // (DBG && 1 == DVRH_SHOW_DEBUG_SPEW)

#if (DBG && 1 == DVRH_SHOW_SHALLOW_TIMER)
    #define ParTimerMainCheck(x)    {                                       \
                                        LARGE_INTEGER myTickCount;           \
                                        KeQueryTickCount(&myTickCount);     \
                                        DVRH_DbgPrint("Parallel:Timer: %d,%d,%I64d, ", \
                                                        PsGetCurrentProcessId(),    \
                                                        PsGetCurrentThreadId(),     \
                                                        myTickCount);               \
                                        DVRH_DbgPrint x; \
                                    }
#endif

#if (DBG && 1 == DVRH_SHOW_DEEP_TIMER)
    #define ParTimerCheck(x)    {                                       \
                                    LARGE_INTEGER myTickCount;           \
                                    KeQueryTickCount(&myTickCount);     \
                                    DVRH_DbgPrint("Parallel:Timer: %d,%d,%I64d, ", \
                                                    PsGetCurrentProcessId(),    \
                                                    PsGetCurrentThreadId(),     \
                                                    myTickCount);               \
                                    DVRH_DbgPrint x; \
                                }
#endif


#if (0 == DVRH_SHOW_DEBUG_SPEW)
    #define ParAssert( X )              //lint !e760
    #define ParDump(LEVEL,STRING)       //lint !e760
    #define ParDump2(LEVEL,STRING)      //lint !e760
    #define ParDumpP(STRING)            //lint !e760
    #define ParDumpReg(LEVEL,STRING,ECRADDR,DCRADDR,DSRADDR)    //lint !e760
    #define ParDumpV(STRING)            //lint !e760
    #define ParBreak(LEVEL,STRING)      //lint !e760
#endif // DBG

#if (0 == DVRH_SHOW_SHALLOW_TIMER)
    #define ParTimerMainCheck(x)        //lint !e760
#endif // DBG
#if (0 == DVRH_SHOW_DEEP_TIMER)
    #define ParTimerCheck(x)            //lint !e760
#endif // DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\ecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    ecp.c

Abstract:

    Enhanced Capabilities Port (ECP)
    
    This module contains the common routines that aue used/ reused
    by swecp and hwecp.

Author:

    Robbie Harris (Hewlett-Packard) - May 27, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
#include "ecp.h"

//=========================================================
// ECP::EnterForwardPhase
//
// Description : Do what is necessary to enter forward phase for 
//               ECP
//
// Input Parameters : Controller,  pPortInfoStruct
//
// Modifies : ECR, DCR
//
// Pre-conditions :
//
// Post-conditions :
//
// Returns :
//
//=========================================================
NTSTATUS ParEcpEnterForwardPhase(IN  PDEVICE_EXTENSION   Extension)
{
	Extension->CurrentPhase = PHASE_FORWARD_IDLE;
	return STATUS_SUCCESS;
}

// =========================================================
// ECP::EnterReversePhase
//
// Description : Move from the common phase (FwdIdle, wPortHWMode=PS2)
//               to ReversePhase.  
//
// Input Parameters : Controller, pPortInfoStruct
//
// Modifies : pPortInfoStruct->CurrentPhase, DCR
//
// Pre-conditions : CurrentPhase == PHASE_FORWARD_IDLE
//                  wPortHWMode == HW_MODE_PS2
//
// Post-conditions : Bus is in ECP State 40
//                   CurrentPhase = PHASE_REVERSE_IDLE
//
// Returns : status of operation
//
//=========================================================
NTSTATUS ParEcpEnterReversePhase(IN  PDEVICE_EXTENSION   Extension)
{
	// Assume that we are in the common entry phase (FWDIDLE, and ECR mode=PS/2)
	// EnterReversePhase assumes that we are in PHASE_FORWARD_IDLE,
	// and that the ECPMode is set to PS/2 mode at entry.
	// Don't use this assert.  If you are not in ECP mode in your BIOS
	// setup it will fail 100% of the time since the ECR is not present.
	//volatile UCHAR ecr = READ_PORT_UCHAR( Controller + ECR_OFFSET ) & 0xe0;
	//HPKAssert( ((PHASE_FORWARD_IDLE == pPortInfoStruct->CurrentPhase) && (0x20 == ecr)), 
	//          ("SoftwareECP::EnterReversePhase: Bad initial state (%d/%x)\n",(int)pPortInfoStruct->CurrentPhase,(int)ecr) );
	
	// Setup the status to indicate successful
	NTSTATUS status = STATUS_SUCCESS;
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    PUCHAR wPortECR;       // I/O address of ECR
	UCHAR dcr;

	ParDump2(PARENTRY,("ParEcpEnterReversePhase:  Start\n"));
    // Calculate I/O port addresses for common registers
    wPortDCR = Extension->Controller + OFFSET_DCR;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        wPortECR = Extension->Controller + ECR_OFFSET;
    #else
        wPortECR = Extension->EcrController + ECR_OFFSET;
    #endif
	// Now, Check the current state to make sure that we are ready for
	// a change to reverse phase.
	if ( PHASE_FORWARD_IDLE == Extension->CurrentPhase )
	{
		// Okay, we are ready to proceed.  Set the CurrentPhase and go on to 
		// state 47
        //----------------------------------------------------------------------
        // Set CurrentPhase to indicate Forward To Reverse Mode.
        //----------------------------------------------------------------------
		ParDump2(PARECPTRACE,("ParEcpEnterReversePhase: PHASE_FwdToRev\n"));
        Extension->CurrentPhase = PHASE_FWD_TO_REV;

        //----------------------------------------------------------------------
        // Set Dir=1 in DCR for reading.
        //----------------------------------------------------------------------
        dcr = READ_PORT_UCHAR(wPortDCR);     // Get content of DCR.
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
        WRITE_PORT_UCHAR(wPortDCR, dcr);
		ParDump2(PARECPTRACE,("ParEcpEnterReversePhase: After DCR update DCR - %x.\n", READ_PORT_UCHAR(wPortDCR) ));

		// Set the data port bits to 1 so that other circuits can control them
        //WRITE_PORT_UCHAR(Controller + OFFSET_DATA, 0xFF);

        //----------------------------------------------------------------------
        // Assert HostAck low.  (ECP State 38)
        //----------------------------------------------------------------------
        Extension->CurrentEvent = 38;
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
        WRITE_PORT_UCHAR(wPortDCR, dcr);
		ParDump2(PARECPTRACE,("ParEcpEnterReversePhase: HostAck Low DCR - %x.\n", READ_PORT_UCHAR(wPortDCR) ));

        // REVISIT: Should use TICKCount to get a finer granularity.
        // According to the spec we need to delay at least .5 us
        KeStallExecutionProcessor((ULONG) 1);       // Stall for 1 us

        //----------------------------------------------------------------------
        // Assert nReverseRequest low.  (ECP State 39)
        //----------------------------------------------------------------------
        Extension->CurrentEvent = 39;
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE );
        WRITE_PORT_UCHAR(wPortDCR, dcr);
		ParDump2(PARECPTRACE,("ParEcpEnterReversePhase: nReverseRequest Low DCR - %x.\n", READ_PORT_UCHAR(wPortDCR) ));

        // NOTE: Let the caller check for State 40, since the error handling for
        // State 40 is different between hwecp and swecp.
	}
	else
	{
		//HPKAssert(0, ("ECP::EnterReversePhase: - Wrong phase on enter\n"));
		//status =  ??
		ParDump2(PARERRORS,("ParEcpEnterReversePhase: Wrong Phase\n"));
        status = STATUS_LINK_FAILED;
	}
	
    ParDumpReg(PAREXIT, ("ParEcpEnterReversePhase: Exit[%d]", NT_SUCCESS(status)),
                wPortECR,
                wPortDCR,
                Extension->Controller + OFFSET_DSR);
	return( status );
}	

//=========================================================
// ECP::ExitReversePhase
//
// Description : Transition from the ECP reverse Phase to the 
//               common phase for all entry functions
//
// Input Parameters : Controller - offset to the I/O ports
//			pPortInfoStruct - pointer to port information
//
// Modifies : CurrentPhase, DCR
//
// Pre-conditions :
//
// Post-conditions : NOTE: This function does not completely move to 
//                   the common phase for entry functions.  Both the
//                   HW and SW ECP classes must do extra work
//
// Returns : Status of the operation
//
//=========================================================
NTSTATUS ParEcpExitReversePhase(IN  PDEVICE_EXTENSION   Extension)
{
    NTSTATUS       status = STATUS_SUCCESS;
    PUCHAR         Controller = Extension->Controller;
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    PUCHAR wPortECR;       // I/O address of ECR
    UCHAR          dcr;

	ParDump2( PARENTRY, ("ParEcpExitReversePhase: Entry \n"));

    wPortDCR = Controller + OFFSET_DCR;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        wPortECR = Controller + ECR_OFFSET;
    #else
        wPortECR = Extension->EcrController + ECR_OFFSET;
    #endif

    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse To Forward Mode.
    //----------------------------------------------------------------------
	ParDump2(PARECPTRACE,("ParEcpExitReversePhase: Phase_RevToFwd\n"));
    Extension->CurrentPhase = PHASE_REV_TO_FWD;


    //----------------------------------------------------------------------
    // Set HostAck high
    //----------------------------------------------------------------------
    dcr = READ_PORT_UCHAR(wPortDCR);
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE );
    WRITE_PORT_UCHAR(wPortDCR, dcr);


    //----------------------------------------------------------------------
    // Set nReverseRequest high.  (State 47)
    //----------------------------------------------------------------------
    Extension->CurrentEvent = 47;
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE );
    WRITE_PORT_UCHAR(wPortDCR, dcr);

    //----------------------------------------------------------------------
    // Check first for PeriphAck low and PeriphClk high. (State 48)
    //----------------------------------------------------------------------
    Extension->CurrentEvent = 48;
    if ( ! CHECK_DSR(Controller, INACTIVE, ACTIVE, DONT_CARE, ACTIVE, DONT_CARE,
                      IEEE_MAXTIME_TL) )
    {
   		// Bad things happened - timed out on this state,
        // Mark Status as bad and let our mgr kill ECP mode.
        // status = SLP_RecoverPort( pSDCB, RECOVER_18 );   // Reset port.
        status = STATUS_LINK_FAILED;
    	ParDump2(PARERRORS,("ParEcpExitReversePhase: state 48 Timeout\n"));
        goto ParEcpExitReversePhase;
    }
    
    //----------------------------------------------------------------------
    // Check next for nAckReverse high.  (State 49) 
    //----------------------------------------------------------------------
	Extension->CurrentEvent = 49;
	if ( ! CHECK_DSR(Controller ,INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
                      IEEE_MAXTIME_TL ) )
    
    {
   		// Bad things happened - timed out on this state,
        // Mark Status as bad and let our mgr kill ECP mode.
        //nError = RecoverPort( pSDCB, RECOVER_19 );   // Reset port.
        status = STATUS_LINK_FAILED;
    	ParDump2(PARERRORS,("ParEcpExitReversePhase:state 49 Timeout\n"));
        goto ParEcpExitReversePhase;
    }

	// Warning: Don't assume that the ECR is in PS/2 mode here.
	// You cannot change the direction in this routine.  It must be
	// done elsewhere (SWECP or HWECP).

ParEcpExitReversePhase:
    ParDumpReg(PAREXIT,
                ("ParEcpExitReversePhase:  Exit [%d]\n", NT_SUCCESS(status)),
                wPortECR,
                wPortDCR,
                Extension->Controller + OFFSET_DSR);
	ParDump2(PAREXIT,("ParEcpExitReversePhase:  Exit [%d]\n", NT_SUCCESS(status)));
    return status;
}	


BOOLEAN
ParEcpHaveReadData (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    return (BOOLEAN)( (UCHAR)0 == (READ_PORT_UCHAR(Extension->Controller + OFFSET_DSR) & DSR_NOT_PERIPH_REQUEST));
}


NTSTATUS
ParEcpSetupPhase(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine performs 1284 Setup Phase.

Arguments:

    Controller      - Supplies the port address.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    PUCHAR         Controller;
    UCHAR          dcr;

    ParDump2(PARENTRY,("ParEcpSetupPhase: Start\n"));

    // The negotiation succeeded.  Current mode and phase.
    //
    Extension->CurrentPhase = PHASE_SETUP;
    Controller = Extension->Controller;
    // Negoiate leaves us in state 6, we need to be in state 30 to
    // begin transfer. Note that I am assuming that the controller
    // is already set as it should be for state 6.
    //
	ParDump2(PARECPTRACE,("ParEcpSetupPhase: Phase_Setup\n"));

    // *************** State 30 Setup Phase ***************8
    //  DIR                     = Don't Care
    //  IRQEN                   = Don't Care
    //  1284/SelectIn           = High
    //  nReverseReq/**(ECP only)= High
    //  HostAck/HostBusy        = Low  (Signals state 30)
    //  HostClk/nStrobe         = High
    //
    Extension->CurrentEvent = 30;
    dcr = READ_PORT_UCHAR(Controller + OFFSET_DCR);
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, INACTIVE, ACTIVE);
    WRITE_PORT_UCHAR(Controller + OFFSET_DCR, dcr);

    // *************** State 31 Setup Phase ***************8
    // PeriphAck/PtrBusy        = low
    // PeriphClk/PtrClk         = high
    // nAckReverse/AckDataReq   = high  (Signals state 31)
    // XFlag                    = high
    // nPeriphReq/nDataAvail    = Don't Care
    Extension->CurrentEvent = 31;
    if (!CHECK_DSR(Controller,
                  INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
                  IEEE_MAXTIME_TL))
    {
		// Bad things happened - timed out on this state.
        // Set status to an error and let PortTuple kill ECP mode (Terminate).
	    ParDump2(PARERRORS, ("ParEcpSetupPhase:State 31 Failed: Controller %x dcr %x\n",
                            Controller, dcr));
        Extension->CurrentPhase = PHASE_UNKNOWN;                        
        return STATUS_IO_DEVICE_ERROR;
    }

	ParDump2(PARECPTRACE,("ParEcpSetupPhase: Phase_FwdIdle\n"));
    Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    ParDump2(PAREXIT,("ParEcpSetupPhase: Exit status = STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\ecp.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    ecp.h

Abstract:

    This module contains utility code used by other 1284
    ecp modules (currently swecp, hwecp, and becp).

Author:

    Robbie Harris (Hewlett-Packard) 28-May-1998

Environment:

    Kernel mode

Revision History :

--*/

#ifndef _ECP_
#define _ECP_

#define DEFAULT_ECP_CHANNEL 0

NTSTATUS
ParEcpEnterReversePhase(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpExitReversePhase(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpSetupPhase(
    IN  PDEVICE_EXTENSION   Extension
    );

#define ParTestEcpWrite(X)                                               \
                (X->CurrentPhase != PHASE_FORWARD_IDLE && X->CurrentPhase != PHASE_FORWARD_XFER)  \
                 ? STATUS_IO_DEVICE_ERROR : STATUS_SUCCESS


// ==================================================================
// The following RECOVER codes are used for Hewlett-Packard devices.
// Do not remove any of the error codes.  These recover codes are
// used to quickly get the host and periph back to a known state.
// When using a recover code, add a comment where it is used at...
#define RECOVER_0           0       // Reserved - not used anywhere
#define RECOVER_1           1       // ECP_Terminate
#define RECOVER_2           2       // SLP_SetupPhase init
#define RECOVER_3           3       // SLP_FTP init DCR
#define RECOVER_4           4       // SLP_FTP init DSR
#define RECOVER_5           5       // SLP_FTP data xfer DCR
#define RECOVER_6           6       // SLP_FRP init DCR
#define RECOVER_7           7       // SLP_FRP init DSR
#define RECOVER_8           8       // SLP_FRP state 38 DCR
#define RECOVER_9           9       // SLP_FRP state 39 DCR
#define RECOVER_10          10      // SLP_FRP state 40 DSR
#define RECOVER_11          11      // SLP_RTP init DCR
#define RECOVER_12          12      // SLP_RTP init DSR
#define RECOVER_13          13      // SLP_RTP state 43 DCR
#define RECOVER_14          14      // SLP_RFP init DCR
#define RECOVER_15          15      // SLP_RFP init DSR
#define RECOVER_16          16      // SLP_RFP state 47- DCR
#define RECOVER_17          17      // SLP_RFP state 47 DCR
#define RECOVER_18          18      // SLP_RFP state 48 DSR
#define RECOVER_19          19      // SLP_RFP state 49 DSR
#define RECOVER_20          20      // ZIP_EmptyFifo DCR
#define RECOVER_21          21      // ZIP_FTP init DCR
#define RECOVER_22          22      // ZIP_FTP init DSR
#define RECOVER_23          23      // ZIP_FTP data xfer DCR
#define RECOVER_24      24      // ZIP_FRP init DSR
#define RECOVER_25      25      // ZIP_FRP init DCR
#define RECOVER_26      26      // ZIP_FRP state 38 DCR
#define RECOVER_27      27      // ZIP_FRP state 39 DCR
#define RECOVER_28      28      // ZIP_FRP state 40 DSR
#define RECOVER_29      29      // ZIP_FRP state 41 DCR
#define RECOVER_30      30      // ZIP_RTP init DSR
#define RECOVER_31      31      // ZIP_RTP init DCR
#define RECOVER_32      32      // ZIP_RFP init DSR
#define RECOVER_33      33      // ZIP_RFP init DCR
#define RECOVER_34      34      // ZIP_RFP state 47- DCR
#define RECOVER_35      35      // ZIP_RFP state 47 DCR
#define RECOVER_36      36      // ZIP_RFP state 48 DSR
#define RECOVER_37      37      // ZIP_RFP state 49 DSR
#define RECOVER_38      38      // ZIP_RFP state 49+ DCR
#define RECOVER_39      39      // Slippy_Terminate 
#define RECOVER_40      40      // ZIP_SCA init DCR
#define RECOVER_41      41      // ZIP_SCA init DSR
#define RECOVER_42      42      // SLP_SCA init DCR
#define RECOVER_43      43      // SLP_SCA init DSR
#define RECOVER_44      44      // ZIP_SP init DCR
#define RECOVER_45      45      // SIP_FRP init DSR
#define RECOVER_46      46      // SIP_FRP init DCR
#define RECOVER_47      47      // SIP_FRP state 38 DCR
#define RECOVER_48      48      // SIP_FRP state 39 DCR
#define RECOVER_49      49      // SIP_FRP state 40 DSR
#define RECOVER_50      50      // SIP_RTP init DCR
#define RECOVER_51      51      // SIP_RFP init DSR
#define RECOVER_52      52      // SIP_RFP state 43 DCR

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\epp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    epp.c

Abstract:

    This module contains the common code to perform all EPP related tasks 
    for EPP Software and EPP Hardware modes.

Author:

    Don Redford - July 29, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


NTSTATUS
ParEppSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    );
    

NTSTATUS
ParEppSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets an EPP Address.
    
Arguments:

    Extension           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    // LARGE_INTEGER   Start;
    // LARGE_INTEGER   End;
    // UCHAR           dsr;
    UCHAR           dcr;
    
    // dvdr
    ParDump2(PARINFO, ("ParEppSetAddress: Entering\n"));

    Controller = Extension->Controller;

    Extension->CurrentPhase = PHASE_FORWARD_XFER;
    
    dcr = GetControl (Controller);
    
    
    WRITE_PORT_UCHAR(Controller + DATA_OFFSET, Address);
//    KeStallExecutionProcessor(1);
    
    //
    // Event 56
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE,
                      INACTIVE, DONT_CARE, INACTIVE );
    StoreControl (Controller, dcr);
            
    //
    // Event 58
    //
    if (!CHECK_DSR(Controller,
                   ACTIVE, DONT_CARE, DONT_CARE,
                   DONT_CARE, DONT_CARE,
                   DEFAULT_RECEIVE_TIMEOUT)) {
        //
        // Return the device to Idle.
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE,
                          ACTIVE, DONT_CARE, INACTIVE );
        StoreControl (Controller, dcr);
//        KeStallExecutionProcessor(1);
            
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE,
                          ACTIVE, DONT_CARE, ACTIVE );
        StoreControl (Controller, dcr);
            
        Extension->CurrentPhase = PHASE_FORWARD_IDLE;

        // dvdr
        ParDump2(PARINFO, ("ParEppSetAddress: Leaving with IO Device Error Event 58\n"));

        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 59
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE,
                      ACTIVE, DONT_CARE, INACTIVE );
    StoreControl (Controller, dcr);
            
    //
    // Event 60
    //
    if (!CHECK_DSR(Controller,
                   INACTIVE, DONT_CARE, DONT_CARE,
                   DONT_CARE, DONT_CARE,
                   DEFAULT_RECEIVE_TIMEOUT)) {

        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE,
                          ACTIVE, DONT_CARE, ACTIVE );
        StoreControl (Controller, dcr);

        Extension->CurrentPhase = PHASE_FORWARD_IDLE;

        // dvdr
        ParDump2(PARINFO, ("ParEppSetAddress: Leaving with IO Device Error Event 60\n"));
        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 61
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE,
                      ACTIVE, DONT_CARE, ACTIVE );
    StoreControl (Controller, dcr);

    Extension->CurrentPhase = PHASE_FORWARD_IDLE;

    // dvdr
    ParDump2(PARINFO, ("ParEppSetAddress: Leaving with STATUS_SUCCESS\n"));

    return STATUS_SUCCESS;
            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\exports.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       exports.c
//
//--------------------------------------------------------------------------

//
// This file contains the functions exported in response to IOCTL_INTERNAL_PARCLASS_CONNECT
//
    
#include "pch.h"
#include "readwrit.h"
    
USHORT
ParExportedDetermineIeeeModes(
    IN PDEVICE_EXTENSION    Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to find out what Ieee Modes there Device Supports.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    Extension->BadProtocolModes = 0;
    IeeeDetermineSupportedProtocols(Extension);
    return Extension->ProtocolModesSupported;
}

NTSTATUS
ParExportedIeeeFwdToRevMode(
    IN PDEVICE_EXTENSION  Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to put there device into reverse Ieee Mode.
    The Mode is determined by what was passed into the function  
    ParExportedNegotiateIeeeMode() as the Reverse Protocol with the
    ModeMaskRev.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    return ( ParForwardToReverse( Extension ) );
}

NTSTATUS
ParExportedIeeeRevToFwdMode(
    IN PDEVICE_EXTENSION  Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to put there device into forward Ieee Mode.
    The Mode is determined by what was passed into the function  
    ParExportedNegotiateIeeeMode() as the Forward Protocol with the
    ModeMaskFwd.
    
Arguments:
    
    Extension       - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
{
    return ( ParReverseToForward( Extension ) );
}

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PDEVICE_EXTENSION  Extension,
    IN USHORT             ModeMaskFwd,
    IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
    IN BOOLEAN            IsForward
    )
    
/*++
    
Routine Description:
    
    Called by filter drivers to negotiate an IEEE mode.
    
Arguments:
    
    Extension       - Device Extension
    
    Extensibility   - IEEE 1284 Extensibility
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/
    
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    if (Extension->Connected)
    {
        ParDump2( PARERRORS, ("ParExportedNegotiateIeeeMode: Already Connected.\n"));
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    
    if (ModeSafety == UNSAFE_MODE)
    {    
        ParDump2( PARINFO, ("ParExportedNegotiateIeeeMode: UNSAFE_MODE.\n"));
        // Checking to see if we are doing forward compatability
        //  and reverse Nibble or Byte
        if ( (ModeMaskFwd & CENTRONICS) || (ModeMaskFwd & IEEE_COMPATIBILITY) ) {
            if ( !((ModeMaskRev & NIBBLE) || (ModeMaskRev & CHANNEL_NIBBLE) || (ModeMaskRev & BYTE_BIDIR)) ) {
                ParDump2( PARERRORS, ("ParExportedNegotiateIeeeMode: UNSAFE_MODE Not correct modes.\n"));
                return STATUS_UNSUCCESSFUL;
            }
        } else {
            // Unsafe mode is only possible if the Fwd and Rev PCTLs
            // the same if Other than above.
            if (ModeMaskFwd != ModeMaskRev) {
                ParDump2( PARERRORS, ("ParExportedNegotiateIeeeMode: UNSAFE_MODE Forward and Reverse Modes do not match.\n"));
                return STATUS_UNSUCCESSFUL;
            }

        }
        // Need to fill in....
        // Todo....
        // Mark in the extension
        ParDump2( PARINFO, ("ParExportedNegotiateIeeeMode: UNSAFE_MODE Forward and Reverse Modes OK.\n"));
        Extension->ModeSafety = ModeSafety;
        ParDump2( PARINFO, ("ParExportedNegotiateIeeeMode: ModeSafety is %x.\n", Extension->ModeSafety));
        Status = IeeeNegotiateMode(Extension, ModeMaskRev, ModeMaskFwd);
    }
    else 
    {
        ParDump2( PARINFO, ("ParExportedNegotiateIeeeMode: Negotiating Modes.\n"));
        Extension->ModeSafety = ModeSafety;
        Status = IeeeNegotiateMode(Extension, ModeMaskRev, ModeMaskFwd);
    }
   
    if (IsForward)
    {
        if (afpForward[Extension->IdxForwardProtocol].fnConnect)
            Status = afpForward[Extension->IdxForwardProtocol].fnConnect(Extension, FALSE);
    }
    else
    {
        if (arpReverse[Extension->IdxReverseProtocol].fnConnect)
            Status = arpReverse[Extension->IdxReverseProtocol].fnConnect(Extension, FALSE);
   
    }
  
    return Status;
}

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PDEVICE_EXTENSION   Extension
    )
/*++
    
Routine Description:
    
    Called by filter drivers to terminate from an IEEE mode.
    
Arguments:
    
    Extension   - Device Extension
    
Return Value:
  
    STATUS_SUCCESS if successful.
 
--*/
{
    // Check the extension for UNSAFE_MODE
    // and do the right thing
    if ( Extension->ModeSafety == UNSAFE_MODE ) {    
 
        // Need to fill in....
        // Todo....
        // Mark in the extension
    }
    
    // dvdr
    ParDump2(PARENTRY, ("ParExportedTerminateIeeeMode: Entering\n"));

    if (Extension->CurrentPhase == PHASE_REVERSE_IDLE ||
        Extension->CurrentPhase == PHASE_REVERSE_XFER)
    {
        ParDump2(PARINFO, ("ParExportedTerminateIeeeMode: Calling Terminate Reverse Function\n"));
        if (arpReverse[Extension->IdxReverseProtocol].fnDisconnect)
        {
            ParDump2(PARINFO, ("ParExportedTerminateIeeeMode: Calling arpReverse.fnDisconnect\n"));
            arpReverse[Extension->IdxReverseProtocol].fnDisconnect (Extension);
        }
    }
    else
    {
        ParDump2(PARINFO, ("ParExportedTerminateIeeeMode: Calling Terminate Forward Function\n"));
        if (afpForward[Extension->IdxForwardProtocol].fnDisconnect)
        {
            ParDump2(PARINFO, ("ParExportedTerminateIeeeMode: Calling afpForward.fnDisconnect\n"));
            afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
        }
    }
    // dvdr
    ParDump2(PAREXIT, ("ParExportedTerminateIeeeMode: Leaving\n"));

    Extension->ModeSafety = SAFE_MODE;
    return STATUS_SUCCESS;
}

NTSTATUS
ParExportedParallelRead(
    IN PDEVICE_EXTENSION    Extension,
    IN  PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead,
    IN  UCHAR               Channel
    )
    
/*++
    
Routine Description:
    
    Called by filter drivers to terminate from a currently connected mode.
    
Arguments:
    
    Extension   - Device Extension
    
Return Value:
   
    STATUS_SUCCESS if successful.
    
--*/
    
{
    UNREFERENCED_PARAMETER( Channel );

    return ParRead( Extension, Buffer, NumBytesToRead, NumBytesRead);
}

NTSTATUS
ParExportedParallelWrite(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten,
    IN  UCHAR               Channel
    )
    
/*++
    
Routine Description:
   
    Called by filter drivers to terminate from a currently connected mode.
    
Arguments:
    
    Extension   - Device Extension
    
Return Value:
    
    STATUS_SUCCESS if successful.
    
--*/

{
    UNREFERENCED_PARAMETER( Channel );

    ParDump2(PARINFO, ("ParExportedParallelWrite: Entering\n"));
    ParDump2(PARINFO, ("ParExportedParallelWrite: Calling ParWrite\n"));
    
    return ParWrite( Extension, Buffer, NumBytesToWrite, NumBytesWritten);
}

NTSTATUS
ParExportedTrySelect(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PARALLEL_1284_COMMAND   Command
    )
{
    return( STATUS_UNSUCCESSFUL );
}   

NTSTATUS
ParExportedDeSelect(
    IN  PDEVICE_EXTENSION       Extension,
    IN  PARALLEL_1284_COMMAND   Command
    )
{
    return( STATUS_UNSUCCESSFUL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\hwecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    hwecp.c

Abstract:

    This module contains code for the host to utilize HardwareECP if it has been
    detected and successfully enabled.

Author:

    Robbie Harris (Hewlett-Packard) 21-May-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
#include "hwecp.h"

VOID ParCleanupHwEcpPort(IN  PDEVICE_EXTENSION   Extension)
/*++

Routine Description:

   Cleans up prior to a normal termination from ECP mode.  Puts the
   port HW back into Compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    PUCHAR      Controller;
    NTSTATUS    nError = STATUS_SUCCESS;
    // UCHAR       bDCR;           // Contents of DCR

    Controller = Extension->Controller;

    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        Extension->ClearChipMode( Extension->PortContext, ECR_ECP_PIO_MODE );
    #else
        #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
            WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_PS2);
        #else
            WRITE_PORT_UCHAR(Extension->EcrController + ECR_OFFSET, DEFAULT_ECR_PS2);
        #endif
    #endif
    Extension->PortHWMode = HW_MODE_PS2;

    ParCleanupSwEcpPort(Extension);

    //----------------------------------------------------------------------
    // Set the ECR to mode 000 (Compatibility Mode).
    //----------------------------------------------------------------------
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        // Nothing to do!
    #else
        #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
            WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
        #else
            WRITE_PORT_UCHAR(Extension->EcrController + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
        #endif
    #endif
    Extension->PortHWMode = HW_MODE_COMPATIBILITY;
}

VOID ParEcpHwDrainShadowBuffer(
    IN  Queue  *pShadowBuffer,
    IN  PUCHAR  lpsBufPtr,
    IN  ULONG   dCount,
    OUT ULONG  *fifoCount)
{
    *fifoCount = 0;
    
    if (Queue_IsEmpty(pShadowBuffer)) {
        ParDump2(PARINFO,("ParEcpHwDrainShadowBuffer: No data in Shadow\r\n"));
        return;
    }

    while ( dCount > 0 ) {
        // LAC FRAME  13Jan98
        // Break out the Queue_Dequeue from the pointer increment so we can
        // observe the data if needed.
        if (FALSE == Queue_Dequeue(pShadowBuffer, lpsBufPtr)) {  // Get byte from queue.
            ParDump2(PARERRORS,("ParEcpHwDrainShadowBuffer: ShadowBuffer Bad\r\n"));
            return;
        }
        ParDump2(PARINFO,("ParEcpHwDrainShadowBuffer: read data byte %02x\r\n",(int)*lpsBufPtr));
        lpsBufPtr++;
        dCount--;                       // Decrement count.
        (*fifoCount)++;
    }

#if DBG
    if (*fifoCount) {
        ParTimerCheck(("ParEcpHwDrainShadowBuffer:  read %d bytes from shadow\r\n", *fifoCount ));
    }
#endif
    ParDump2( PARINFO, ("ParEcpHwDrainShadowBuffer:  read %d bytes from shadow\r\n", *fifoCount ));
}

//============================================================================
// NAME:    HardwareECP::EmptyFIFO()
//  
//      Empties HW FIFO into a shadow buffer.  This must be done before
//      turning the direction from reverse to forward, if the printer has
//      stuffed data in that no one has read yet.
//
// PARAMETERS: 
//      Controller      - Supplies the base address of the parallel port.
//
// RETURNS: STATUS_SUCCESS or ....
//
// NOTES:
//      Called ZIP_EmptyFIFO in the original 16 bit code.
//
//============================================================================
NTSTATUS ParEcpHwEmptyFIFO(IN  PDEVICE_EXTENSION   Extension)
{
    NTSTATUS   nError = STATUS_SUCCESS;
    Queue      *pShadowBuffer;
	UCHAR      bData;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        PUCHAR     wPortDFIFO = Extension->Controller + ECP_DFIFO_OFFSET;  // IO address of ECP Data FIFO
        PUCHAR     wPortECR = Extension->Controller + ECR_OFFSET;    // IO address of Extended Control Register (ECR)
    #else
        PUCHAR     wPortDFIFO = Extension->EcrController;  // IO address of ECP Data FIFO
        PUCHAR     wPortECR = Extension->EcrController + ECR_OFFSET;    // IO address of Extended Control Register (ECR)
    #endif
    
    // While data exists in the FIFO, read it and put it into shadow buffer.
    // If the shadow buffer fills up before the FIFO is exhausted, an
    // error condition exists.

    pShadowBuffer = &(Extension->ShadowBuffer);
    while ((READ_PORT_UCHAR(wPortECR) & ECR_FIFO_EMPTY) == 0 )
    {
		// LAC FRAME  13Jan98
		// Break out the Port Read so we can observe the data if needed
		bData = READ_PORT_UCHAR(wPortDFIFO);
        if (FALSE == Queue_Enqueue(pShadowBuffer, bData))    // Put byte in queue.
        {
            ParDump2(PARERRORS, ( "ParEcpHwEmptyFIFO:  Shadow buffer full, FIFO not empty\r\n" ));
            nError = STATUS_BUFFER_OVERFLOW;
            goto ParEcpHwEmptyFIFO_ExitLabel;
        }
        ParDump2(PARINFO,("ParEcpHwEmptyFIFO: Enqueue data %02x\r\n",(int)bData));
    }

    if( ( !Queue_IsEmpty(pShadowBuffer) && (Extension->P12843DL.bEventActive) )) {
        KeSetEvent(Extension->P12843DL.Event, 0, FALSE);
    }

ParEcpHwEmptyFIFO_ExitLabel:
    return nError;
}   // ParEcpHwEmptyFIFO

// LAC ENTEREXIT  5Dec97
//=========================================================
// HardwareECP::ExitForwardPhase
//
// Description : Exit from HWECP Forward Phase to the common phase
//               (FWD IDLE, PS/2)
//
// Input Parameters : Controller, pPortInfoStruct
//
// Modifies :
//
// Pre-conditions :
//
// Post-conditions :
//
// Returns :
//
//=========================================================
NTSTATUS ParEcpHwExitForwardPhase( IN  PDEVICE_EXTENSION   Extension )
{
    NTSTATUS status;
    PUCHAR wPortECR;       // I/O address of ECR

	ParDump2( PARENTRY, ("ParEcpHwExitForwardPhase: Entry\r\n") );
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        wPortECR = Extension->Controller + ECR_OFFSET;
    #else
        wPortECR = Extension->EcrController + ECR_OFFSET;
    #endif

	// First, there could be data in the FIFO.  Wait for it to empty
	// and then put the bus in the common state (PHASE_FORWARD_IDLE with
	// ECRMode set to PS/2
	status = ParEcpHwWaitForEmptyFIFO( Extension );

    Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    ParDumpReg(PAREXIT, ("ParEcpHwExitForwardPhase: Exit[%d]", NT_SUCCESS(status)),
                wPortECR,
                Extension->Controller + OFFSET_DCR,
                Extension->Controller + OFFSET_DSR);
	
	return( status );
}	

// LAC ENTEREXIT  5Dec97
//=========================================================
// HardwareECP::EnterReversePhase
//
// Description : Go from the common phase to HWECP Reverse Phase
//
// Input Parameters : Controller, pPortInfoStruct
//
// Modifies :
//
// Pre-conditions :
//
// Post-conditions :
//
// Returns :
//
//=========================================================
NTSTATUS ParEcpHwEnterReversePhase( IN  PDEVICE_EXTENSION   Extension )
{
    NTSTATUS status;
    PUCHAR Controller;
    PUCHAR wPortECR;       // I/O address of Extended Control Register
    PUCHAR wPortDCR;       // I/O address of Device Control Register
    UCHAR  dcr;
    
//    ParTimerCheck(("ParEcpHwEnterReversePhase: Start\r\n"));
    Controller = Extension->Controller;
#if (0 == PARCHIP_ECR_ARBITRATOR)
    wPortECR = Controller + ECR_OFFSET;
#else
    wPortECR = Extension->EcrController + ECR_OFFSET;
#endif
    wPortDCR = Controller + OFFSET_DCR;


    ParDumpReg(PARENTRY, ("ParEcpHwEnterReversePhase: Enter"),
                wPortECR,
                wPortDCR,
                Controller + OFFSET_DSR);
	
	// EnterReversePhase assumes that we are in PHASE_FORWARD_IDLE,
	// and that the ECPMode is set to PS/2 mode at entry.
	//volatile UCHAR ecr = READ_PORT_UCHAR( Controller + ECR_OFFSET ) & 0xe0;
	//HPKAssert( ((PHASE_FORWARD_IDLE == pPortInfoStruct->CurrentPhase) && (0x20 == ecr)), 
	//          ("HardwareECP::EnterReversePhase: Bad initial state (%d/%x)\r\n",(int)pPortInfoStruct->CurrentPhase,(int)ecr) );

    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        Extension->ClearChipMode( Extension->PortContext, ECR_ECP_PIO_MODE );
    #else
        WRITE_PORT_UCHAR(wPortECR, DEFAULT_ECR_PS2);
    #endif
    Extension->PortHWMode = HW_MODE_PS2;

    if ( Extension->ModeSafety == SAFE_MODE ) {

    	// Reverse the bus first (using ECP::EnterReversePhase)
	    status = ParEcpEnterReversePhase(Extension);
    	if ( NT_SUCCESS(status) )
	    {
    		//----------------------------------------------------------------------
	    	// Wait for nAckReverse low (ECP State 40)
		    //----------------------------------------------------------------------
    		if ( !CHECK_DSR(Controller, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, DONT_CARE,
	    	                IEEE_MAXTIME_TL) )
		    {
    		    ParDump2(PARERRORS,("ParEcpHwEnterReversePhase: State 40 failed\r\n"));
                status = ParEcpHwRecoverPort( Extension, RECOVER_28 );
                if ( NT_SUCCESS(status))
    	    		status = STATUS_LINK_FAILED;
                goto ParEcpHwEnterReversePhase_ExitLabel;
    		}
    		else
	    	{
		    	ParDump2(PARECPTRACE, ("ParEcpHwEnterReversePhase: Phase_RevIdle. Setup HW ECR\r\n"));
			    Extension->CurrentPhase = PHASE_REVERSE_IDLE;
    		}
        }
	} else {
        //----------------------------------------------------------------------
        // Set Dir=1 in DCR for reading.
        //----------------------------------------------------------------------
        dcr = READ_PORT_UCHAR( wPortDCR );     // Get content of DCR.
        dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
        WRITE_PORT_UCHAR(wPortDCR, dcr);
	}

    //----------------------------------------------------------------------
    // Set the ECR to mode 011 (ECP Mode).  DmaEnable=0.
    //----------------------------------------------------------------------
    ParDump2(PARECPTRACE,("ParEcpHwEnterReversePhase: Before Setting Harware DCR - %x.\n", READ_PORT_UCHAR(wPortDCR) ));
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        status = Extension->TrySetChipMode ( Extension->PortContext, ECR_ECP_PIO_MODE );
        if ( !NT_SUCCESS(status) )
        {
            ParDump2(PARERRORS,("ParEcpHwEnterReversePhase: TrySetChipMode failed\r\n"));
        }
    #else
        WRITE_PORT_UCHAR( wPortECR, DEFAULT_ECR_ECP );
    #endif
    Extension->PortHWMode = HW_MODE_ECP;

    ParDump2(PARECPTRACE,("ParEcpHwEnterReversePhase: After Setting Harware Before nStrobe and nAutoFd DCR - %x.\n", READ_PORT_UCHAR(wPortDCR) ));

    //----------------------------------------------------------------------
    // Set nStrobe=0 and nAutoFd=0 in DCR, so that ECP HW can control.
    //----------------------------------------------------------------------
    dcr = READ_PORT_UCHAR( wPortDCR );               // Get content of DCR.
    dcr = UPDATE_DCR( dcr, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE);
    WRITE_PORT_UCHAR( wPortDCR, dcr );

    ParDump2(PARECPTRACE,("ParEcpHwEnterReversePhase: After nStrobe and nAutoFd DCR - %x.\n", READ_PORT_UCHAR(wPortDCR) ));

    // Set the phase variable to ReverseIdle
    Extension->CurrentPhase = PHASE_REVERSE_IDLE;

ParEcpHwEnterReversePhase_ExitLabel:
//    ParTimerCheck(("ParEcpHwEnterReversePhase: End\r\n"));
    ParDumpReg(PAREXIT, ("ParEcpHwEnterReversePhase: Exit[%d]", NT_SUCCESS(status)),
                wPortECR,
                wPortDCR,
                Controller + OFFSET_DSR);

	return( status );
}

//=========================================================
// HardwareECP::ExitReversePhase
//
// Description : Get out of HWECP Reverse Phase to the common state
//
// Input Parameters : Controller, pPortInfoStruct
//
// Modifies :
//
// Pre-conditions :
//
// Post-conditions :
//
// Returns :
//
//=========================================================
NTSTATUS ParEcpHwExitReversePhase( IN  PDEVICE_EXTENSION   Extension )
{
    NTSTATUS nError = STATUS_SUCCESS;
    UCHAR   bDCR;
    UCHAR   bECR;
    PUCHAR wPortECR;
    PUCHAR wPortDCR;
    PUCHAR Controller;

	ParDump2( PARENTRY, ("ParEcpHwExitReversePhase: Entry\r\n") );
//    ParTimerCheck(("ParEcpHwExitReversePhase: Start\r\n"));
    Controller = Extension->Controller;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        wPortECR = Controller + ECR_OFFSET;
    #else
        wPortECR = Extension->EcrController + ECR_OFFSET;
    #endif
    wPortDCR = Controller + OFFSET_DCR;

    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse To Forward Mode.
    //----------------------------------------------------------------------
    Extension->CurrentPhase = PHASE_REV_TO_FWD;
	
    if ( Extension->ModeSafety == SAFE_MODE ) {

        //----------------------------------------------------------------------
        // Assert nReverseRequest high.  This should stop further data transfer
        // into the FIFO.  [[REVISIT:  does the chip handle this correctly
        // if it occurs in the middle of a byte transfer (states 43-46)??
        // Answer (10/9/95) no, it doesn't!!]]
        //----------------------------------------------------------------------
        bDCR = READ_PORT_UCHAR(wPortDCR);               // Get content of DCR.
        bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE );
        WRITE_PORT_UCHAR(wPortDCR, bDCR );

        //----------------------------------------------------------------------
        // Wait for PeriphAck low and PeriphClk high (ECP state 48) together
        // with nAckReverse high (ECP state 49).
        //----------------------------------------------------------------------
        if ( ! CHECK_DSR(Controller,
                        INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
                        DEFAULT_RECEIVE_TIMEOUT ) )
        {
            ParDump2( PARERRORS, ("ParEcpHwExitReversePhase: Periph failed state 48/49.\r\n"));
            nError = ParEcpHwRecoverPort( Extension, RECOVER_37 );   // Reset port.
            if (NT_SUCCESS(nError))
            {
                ParDump2( PARERRORS, ("ParEcpHwExitReversePhase: State 48/49 Failure. RecoverPort Invoked.\r\n"));
                return STATUS_LINK_FAILED;
            }
            return nError;
        }

        //-----------------------------------------------------------------------
        // Empty the HW FIFO of any bytes that may have already come in.
        // This must be done before changing ECR modes because the FIFO is reset
        // when that occurs.
        //-----------------------------------------------------------------------
        bECR = READ_PORT_UCHAR(wPortECR);               // Get content of ECR.
        if ((bECR & ECR_FIFO_EMPTY) == 0)       // Check if FIFO is not empty.
        {
            if ((nError = ParEcpHwEmptyFIFO(Extension)) != STATUS_SUCCESS)
            {
                ParDump2( PARERRORS, ("ParEcpHwExitReversePhase: Attempt to empty ECP chip failed.\r\n"));
                return nError;
            }
        }

        //----------------------------------------------------------------------
        // Assert HostAck and HostClk high.  [[REVISIT:  is this necessary? 
        //    should already be high...]]
        //----------------------------------------------------------------------
        bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        WRITE_PORT_UCHAR(wPortDCR, bDCR );

    } // SAFE_MODE

    //----------------------------------------------------------------------
    // Set the ECR to PS2 Mode so we can change bus direction.
    //----------------------------------------------------------------------
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        Extension->ClearChipMode( Extension->PortContext, ECR_ECP_PIO_MODE );
    #else
        WRITE_PORT_UCHAR(wPortECR, DEFAULT_ECR_PS2);
    #endif
    Extension->PortHWMode = HW_MODE_PS2;


    //----------------------------------------------------------------------
    // Set Dir=0 (Write) in DCR.
    //----------------------------------------------------------------------
    bDCR = READ_PORT_UCHAR(wPortDCR);
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    WRITE_PORT_UCHAR(wPortDCR, bDCR );


    //----------------------------------------------------------------------
    // Set the ECR back to ECP Mode.  DmaEnable=0.
    //----------------------------------------------------------------------
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        nError = Extension->TrySetChipMode ( Extension->PortContext, ECR_ECP_PIO_MODE );
    #else
        WRITE_PORT_UCHAR(wPortECR, DEFAULT_ECR_ECP);
    #endif
    Extension->PortHWMode = HW_MODE_ECP;


    Extension->CurrentPhase = PHASE_FORWARD_IDLE;

//    ParTimerCheck(("ParEcpHwExitReversePhase: End\r\n"));
    ParDumpReg(PAREXIT, ("ParEcpHwExitReversePhase: Exit[%d]", NT_SUCCESS(nError)),
                wPortECR,
                wPortDCR,
                Extension->Controller + OFFSET_DSR);

    return(nError);
}

BOOLEAN
ParEcpHwHaveReadData (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    Queue     *pQueue;

    // check shadow buffer
    pQueue = &(Extension->ShadowBuffer);
    if (!Queue_IsEmpty(pQueue)) {
        return TRUE;
    }

    // check periph
    if (ParEcpHaveReadData(Extension))
        return TRUE;

    // Check if FIFO is not empty.
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        return (BOOLEAN)( (UCHAR)0 == (READ_PORT_UCHAR(Extension->Controller + ECR_OFFSET) & ECR_FIFO_EMPTY) );
    #else
        return (BOOLEAN)( (UCHAR)0 == (READ_PORT_UCHAR(Extension->EcrController + ECR_OFFSET) & ECR_FIFO_EMPTY) );
    #endif
}

NTSTATUS
ParEcpHwHostRecoveryPhase(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    NTSTATUS   nError = STATUS_SUCCESS;
    PUCHAR    pPortDCR;       // I/O address of Device Control Register
    PUCHAR    pPortDSR;       // I/O address of Device Status Register
    PUCHAR    pPortECR;       // I/O address of Extended Control Register
    UCHAR    bDCR;           // Contents of DCR
    UCHAR    bDSR;           // Contents of DSR

    if (!Extension->bIsHostRecoverSupported)
    {
        ParDump2( PARENTRY, ( "ParEcpHwHostRecoveryPhase: Host Recovery not supported\r\n"));
        return STATUS_SUCCESS;
    }

    ParDump2( PARENTRY, ( "ParEcpHwHostRecoveryPhase: Host Recovery Start\r\n"));

	// Calculate I/O port addresses for common registers
    pPortDCR = Extension->Controller + OFFSET_DCR;
    pPortDSR = Extension->Controller + OFFSET_DSR;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        pPortECR = Controller + OFFSET_ECR;
    #else
        pPortECR = Extension->EcrController + ECR_OFFSET;
    #endif

    // Set the ECR to mode 001 (PS2 Mode)
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        // Don't need to flip to Byte mode.  The ECR arbitrator will handle this.
    #else
        WRITE_PORT_UCHAR(pPortECR, DEFAULT_ECR_PS2);
    #endif
    Extension->PortHWMode = HW_MODE_PS2;

    // Set Dir=1 in DCR to disable host bus drive, because the peripheral may 
    // try to drive the bus during host recovery phase.  We are not really going
    // to let any data handshake across, because we don't set HostAck low, and
    // we don't enable the ECP chip during this phase.
    bDCR = READ_PORT_UCHAR(pPortDCR);               // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DIR_READ, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    WRITE_PORT_UCHAR(pPortDCR, bDCR );

    // Check the DCR to see if it has been stomped on
    bDCR = READ_PORT_UCHAR( pPortDCR );
    if ( TEST_DCR( bDCR, DIR_WRITE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE ) )
    {
        // DCR ok, now test DSR for valid state, ignoring PeriphAck since it could change
        bDSR = READ_PORT_UCHAR( pPortDSR );
        // 11/21/95 LLL, CGM: change test to look for XFlag high
        if ( TEST_DSR( bDSR, DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )
        {
            // Drop ReverseRequest to initiate host recovery
            bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE );
            WRITE_PORT_UCHAR( pPortDCR, bDCR );

            // Wait for nAckReverse response
            // 11/21/95 LLL, CGM: tightened test to include PeriphClk and XFlag.
            //                "ZIP_HRP: state 73, DSR" 
            if ( CHECK_DSR( Extension->Controller,
                            DONT_CARE, ACTIVE, INACTIVE, ACTIVE, DONT_CARE, 
                            IEEE_MAXTIME_TL))
            {
                // Yes, raise nReverseRequest, HostClk and HostAck (HostAck high so HW can drive)
                bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, ACTIVE );
                WRITE_PORT_UCHAR( pPortDCR, bDCR );

                // Wait for nAckReverse response
                // 11/21/95 LLL, CGM: tightened test to include XFlag and PeriphClk.
                //         "ZIP_HRP: state 75, DSR"
                if ( CHECK_DSR( Extension->Controller,
                                DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE, 
                                IEEE_MAXTIME_TL))
                {
                    // Let the host drive the bus again.
                    bDCR = READ_PORT_UCHAR(pPortDCR);               // Get content of DCR.
                    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
                    WRITE_PORT_UCHAR(pPortDCR, bDCR );

                    // Recovery is complete, let the caller decide what to do now
                    nError = STATUS_SUCCESS;
                    Extension->CurrentPhase = PHASE_FORWARD_IDLE;
                }
                else
                {
                    nError = STATUS_IO_TIMEOUT;
                    ParDump2( PARERRORS, ( "ParEcpHwHostRecoveryPhase: Error prior to state 75 \r\n"));
                }
            }
            else
            {
                nError = STATUS_IO_TIMEOUT;
                ParDump2( PARERRORS, ( "ParEcpHwHostRecoveryPhase: Error prior to state 73 \r\n"));
			}
        }
        else
        {
            #if DVRH_BUS_RESET_ON_ERROR
                BusReset(pPortDCR);  // Pass in the dcr address
            #endif
            ParDump2( PARERRORS, ( "ParEcpHwHostRecoveryPhase: VE_LINK_FAILURE \r\n"));
            nError = STATUS_LINK_FAILED;
		}
    }
    else
    {
        ParDump2( PARERRORS, ( "ParEcpHwHostRecoveryPhase: VE_PORT_STOMPED \r\n"));
        nError = STATUS_DEVICE_PROTOCOL_ERROR;
   }

    if (!NT_SUCCESS(nError))
    {
        // Make sure both HostAck and HostClk are high before leaving
        // Also let the host drive the bus again.
        bDCR = READ_PORT_UCHAR( pPortDCR );
        bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        WRITE_PORT_UCHAR( pPortDCR, bDCR );

        // [[REVISIT]] pSDCB->wCurrentPhase = PHASE_UNKNOWN;
    }

    // Set the ECR to ECP mode, disable DMA
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        nError = Extension->TrySetChipMode ( Extension->PortContext, ECR_ECP_PIO_MODE );
    #else
        WRITE_PORT_UCHAR(pPortECR, DEFAULT_ECR_ECP);
    #endif
    Extension->PortHWMode = HW_MODE_ECP;

    ParDump2( PAREXIT, ( "ParEcpHwHostRecoveryPhase:: Exit %d\r\n", NT_SUCCESS(nError)));
    return(nError);
}

NTSTATUS
ParEcpHwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 ECP mode read under Hardware control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    NTSTATUS  nError = STATUS_SUCCESS;
    PUCHAR    lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type
    ULONG     dCount = BufferSize;             // Working copy of caller's original request count
    UCHAR     bDSR;               // Contents of DSR
    UCHAR     bPeriphRequest;     // Calculated state of nPeriphReq signal, used in loop
    ULONG     dFifoCount = 0;         // Amount of data pulled from FIFO shadow at start of read
    PUCHAR    wPortDSR = Extension->Controller + DSR_OFFSET;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        PUCHAR    wPortECR = Extension->Controller + ECR_OFFSET;
        PUCHAR    wPortDFIFO = Extension->Controller + ECP_DFIFO_OFFSET;
    #else
        PUCHAR    wPortECR = Extension->EcrController + ECR_OFFSET;
        PUCHAR    wPortDFIFO = Extension->EcrController;
    #endif
    #if (1 == DVRH_USE_HW_MAXTIME)
        LARGE_INTEGER   WaitOverallTimer;
        LARGE_INTEGER   StartOverallTimer;
        LARGE_INTEGER   EndOverallTimer;
    #else
        LARGE_INTEGER   WaitPerByteTimer;
        LARGE_INTEGER   StartPerByteTimer;
        LARGE_INTEGER   EndPerByteTimer;
        BOOLEAN         bResetTimer = TRUE;
    #endif
    ULONG           wBurstCount;        // Calculated amount of data in FIFO
    UCHAR       ecrFIFO;

    ParTimerCheck(("ParEcpHwRead: Start BufferSize[%d]\r\n", BufferSize));

    #if (1 == DVRH_USE_HW_MAXTIME)
        // Look for limit to overall time spent in this routine.  If bytes are just barely
        // trickling in, we don't want to stay here forever.
        WaitOverallTimer.QuadPart = (990 * 10 * 1000) + KeQueryTimeIncrement();
        //        WaitOverallTimer.QuadPart = (DEFAULT_RECEIVE_TIMEOUT * 10 * 1000) + KeQueryTimeIncrement();
    #else
        WaitPerByteTimer.QuadPart = (35 * 10 * 1000) + KeQueryTimeIncrement();
    #endif

    //----------------------------------------------------------------------
    // Set status byte to indicate Reverse Transfer Phase.
    //----------------------------------------------------------------------
    Extension->CurrentPhase = PHASE_REVERSE_XFER;

    //----------------------------------------------------------------------
    // We've already checked the shadow in ParRead. So go right to the
    // Hardware FIFO and pull more data across.
    //----------------------------------------------------------------------
    #if (1 == DVRH_USE_HW_MAXTIME)
        KeQueryTickCount(&StartOverallTimer);   // Start the timer
    #else
        KeQueryTickCount(&StartPerByteTimer);   // Start the timer
    #endif

ParEcpHwRead_ReadLoopStart:
    //------------------------------------------------------------------
    // Determine whether the FIFO has any data and respond accordingly
    //------------------------------------------------------------------
    ecrFIFO = (UCHAR)(READ_PORT_UCHAR(wPortECR) & (UCHAR)ECR_FIFO_MASK);

    if (ECR_FIFO_FULL == ecrFIFO)
    {
        ParDump2(PARINFO, ("ParEcpHwRead: ECR_FIFO_FULL\r\n"));
        wBurstCount = ( dCount > Extension->FifoDepth ? Extension->FifoDepth : dCount );
        dCount -= wBurstCount;

        #if (1 == PAR_USE_BUFFER_READ_WRITE)
            READ_PORT_BUFFER_UCHAR(wPortDFIFO, lpsBufPtr, wBurstCount);
            lpsBufPtr += wBurstCount;
  	        ParDump2(PARINFO,("ParEcpHwRead: Read FIFOBurst\r\n"));
        #else
            while ( wBurstCount-- )
            {
                *lpsBufPtr = READ_PORT_UCHAR(wPortDFIFO);
		        ParDump2(PARINFO,("ParEcpHwRead: Full FIFO: Read byte value %02x\r\n",(int)*lpsBufPtr));
                lpsBufPtr++;
            }
        #endif
        #if (0 == DVRH_USE_HW_MAXTIME)
            bResetTimer = TRUE;
        #endif
    }
    else if (ECR_FIFO_SOME_DATA == ecrFIFO)
    {
        // Read just one byte at a time, since we don't know exactly how much is
        // in the FIFO.
        *lpsBufPtr = READ_PORT_UCHAR(wPortDFIFO);
        lpsBufPtr++;
        dCount--;
        #if (0 == DVRH_USE_HW_MAXTIME)
            bResetTimer = TRUE;
        #endif
    }
    else    // ECR_FIFO_EMPTY
    {

        ParDump2(PARINFO, ("ParEcpHwRead: ECR_FIFO_EMPTY\r\n"));
        // Nothing to do. We either have a slow peripheral or a bad peripheral.
        // We don't have a good way to figure out if its bad.  Let's chew up our
        // time and hope for the best.
        #if (0 == DVRH_USE_HW_MAXTIME)
            bResetTimer = FALSE;
        #endif
    }   //  ECR_FIFO_EMPTY a.k.a. else clause of (ECR_FIFO_FULL == ecrFIFO)

    if (dCount == 0)
        goto ParEcpHwRead_ReadLoopEnd;
    else
    {
        #if (1 == DVRH_USE_HW_MAXTIME)
            // Limit the overall time we spend in this loop.
            KeQueryTickCount(&EndOverallTimer);
            if (((EndOverallTimer.QuadPart - StartOverallTimer.QuadPart) * KeQueryTimeIncrement()) > WaitOverallTimer.QuadPart)
                goto ParEcpHwRead_ReadLoopEnd;
        #else
            // Limit the overall time we spend in this loop.
            if (bResetTimer)
            {
                bResetTimer = FALSE;
                KeQueryTickCount(&StartPerByteTimer);   // Restart the timer
            }
            else
            {
                KeQueryTickCount(&EndPerByteTimer);
                if (((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement()) > WaitPerByteTimer.QuadPart)
                    goto ParEcpHwRead_ReadLoopEnd;
            }
        #endif
    }

    goto ParEcpHwRead_ReadLoopStart;
ParEcpHwRead_ReadLoopEnd:

	ParDump2(PARECPTRACE,("ParEcpHwRead: Phase_RevIdle\r\n"));
    Extension->CurrentPhase = PHASE_REVERSE_IDLE;

    *BytesTransferred  = BufferSize - dCount;      // Set current count.

    Extension->log.HwEcpReadCount += *BytesTransferred;

    if (0 == *BytesTransferred)
    {
        bDSR = READ_PORT_UCHAR(wPortDSR);
        bPeriphRequest = (UCHAR)TEST_DSR( bDSR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE );
        // Only flag a timeout error if the device still said it had data to send.
        if ( bPeriphRequest )
        {
            //
            // Periph still says that it has data, but we timed out trying to read the data.
            //
            ParDump2(PARERRORS, ("ParEcpHwRead: read timout with nPeriphRequest asserted and no data read\r\n"));
            nError = STATUS_IO_TIMEOUT;
            if ((TRUE == Extension->P12843DL.bEventActive) ) {
                //
                // Signal transport that it should try another read
                //
                KeSetEvent(Extension->P12843DL.Event, 0, FALSE);
            }
        }
    }
    ParTimerCheck(("ParEcpHwRead: Exit[%d] BytesTransferred[%d]\r\n", NT_SUCCESS(nError), *BytesTransferred));

    ParDumpReg(PAREXIT, ("ParEcpHwRead: Exit[%d] BytesTransferred[%d]", NT_SUCCESS(nError), *BytesTransferred),
                wPortECR,
                Extension->Controller + OFFSET_DCR,
                Extension->Controller + OFFSET_DSR);

    return nError;
}   // ParEcpHwRead

NTSTATUS
ParEcpHwRecoverPort(
    PDEVICE_EXTENSION Extension,
    UCHAR  bRecoverCode
    )
{
    NTSTATUS   nError = STATUS_SUCCESS;
    PUCHAR    wPortDCR;       // IO address of Device Control Register (DCR)
    PUCHAR    wPortDSR;       // IO address of Device Status Register (DSR)
    PUCHAR    wPortECR;       // IO address of Extended Control Register (ECR)
    PUCHAR    wPortData;      // IO address of Data Register
    UCHAR    bDCR;           // Contents of DCR
    UCHAR    bDSR;           // Contents of DSR
    UCHAR    bDSRmasked;     // DSR after masking low order bits

    ParDump2( PARENTRY, ( "ParEcpHwRecoverPort:  enter %d\r\n", bRecoverCode ));

    // Calculate I/O port addresses for common registers
    wPortDCR = Extension->Controller + OFFSET_DCR;
    wPortDSR = Extension->Controller + OFFSET_DSR;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        wPortECR = Extension->Controller + ECR_OFFSET;
    #else
        wPortECR = Extension->EcrController + ECR_OFFSET;
    #endif
    wPortData = Extension->Controller + OFFSET_DATA;


    //----------------------------------------------------------------------
    // Check if port is stomped.
    //----------------------------------------------------------------------
    bDCR = READ_PORT_UCHAR(wPortDCR);               // Get content of DCR.

    if ( ! TEST_DCR( bDCR, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE ) )
    {
        #if DVRH_BUS_RESET_ON_ERROR
            BusReset(wPortDCR);  // Pass in the dcr address
        #endif
        ParDump2( PARERRORS, ( "!ParEcpHwRecoverPort:  port stomped.\r\n"));
        nError = STATUS_DEVICE_PROTOCOL_ERROR;
    }


    //----------------------------------------------------------------------
    // Attempt a termination phase to get the peripheral recovered.
    // Ignore the error return, we've already got that figured out.
    //----------------------------------------------------------------------
    IeeeTerminate1284Mode(Extension );

    //----------------------------------------------------------------------
    // Set the ECR to PS2 Mode so we can change bus direction.
    //----------------------------------------------------------------------
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        Extension->ClearChipMode( Extension->PortContext, ECR_ECP_PIO_MODE );
    #else
        WRITE_PORT_UCHAR(wPortECR, DEFAULT_ECR_PS2);
    #endif
    Extension->PortHWMode = HW_MODE_PS2;

    //----------------------------------------------------------------------
    // Assert nSelectIn low, nInit high, nStrobe high, and nAutoFd high.
    //----------------------------------------------------------------------
    bDCR = READ_PORT_UCHAR(wPortDCR);             // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
    WRITE_PORT_UCHAR(wPortDCR, bDCR);
    WRITE_PORT_UCHAR(wPortData, bRecoverCode);      // Output the error ID
    KeStallExecutionProcessor(100);                 // Hold long enough to capture
    WRITE_PORT_UCHAR(wPortData, 0);                 // Now clear the data lines.


    //----------------------------------------------------------------------
    // Set the ECR to mode 000 (Compatibility Mode).
    //----------------------------------------------------------------------
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        // Nothing needs to be done here.
    #else
        WRITE_PORT_UCHAR(wPortECR, DEFAULT_ECR_COMPATIBILITY);
    #endif
    Extension->PortHWMode = HW_MODE_COMPATIBILITY;


    //----------------------------------------------------------------------
    // Check for any link errors if nothing bad found yet.
    //----------------------------------------------------------------------
    bDSR = READ_PORT_UCHAR(wPortDSR);               // Get content of DSR.
    bDSRmasked = (UCHAR)(bDSR | 0x07);              // Set first 3 bits (don't cares).

    if (NT_SUCCESS(nError))
    {
        if (bDSRmasked != 0xDF)
        {
            ParDump2( PARERRORS, ("!ParEcpHwRecoverPort:  DSR Exp value: 0xDF, Act value: 0x%X\r\n", bDSRmasked));

            // Get DSR again just to make sure...
            bDSR = READ_PORT_UCHAR(wPortDSR);           // Get content of DSR.
            bDSRmasked = (UCHAR)(bDSR | 0x07);          // Set first 3 bits (don't cares).

            if ( (bDSRmasked == CHKPRNOFF1) || (bDSRmasked == CHKPRNOFF2) ) // Check for printer off.
            {
                ParDump2( PARERRORS, ("!ParEcpHwRecoverPort:  DSR value: 0x%X, Printer Off.\r\n", bDSRmasked));
                nError = STATUS_DEVICE_POWERED_OFF;
            }
            else 
            {
                if (bDSRmasked == CHKNOCABLE)   // Check for cable unplugged.
                {
                    ParDump2( PARERRORS, ("!ParEcpHwRecoverPort:  DSR value: 0x%X, Cable Unplugged.\r\n", bDSRmasked));
                    nError = STATUS_DEVICE_NOT_CONNECTED;
                }
                else
                {
                    nError = STATUS_LINK_FAILED;
                }
            }
        }
    }

    //----------------------------------------------------------------------
    // Set status byte to indicate Compatibility Mode.
    //----------------------------------------------------------------------
    Extension->CurrentPhase = PHASE_FORWARD_IDLE;

    ParDump2( PAREXIT, ( "ParEcpHwRecoverPort:  exit, return = 0x%X\r\n", NT_SUCCESS(nError) ));

    return nError;

}   // ParEcpHwRecoverPort

NTSTATUS
ParEcpHwSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets the ECP Address.
    
Arguments:

    Extension           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    NTSTATUS   nError = STATUS_SUCCESS;
    PUCHAR    wPortDSR;       // IO address of Device Status Register
    PUCHAR    wPortECR;       // IO address of Extended Control Register
    PUCHAR    wPortAFIFO;     // IO address of ECP Address FIFO
    UCHAR    bDSR;           // Contents of DSR
    UCHAR    bECR;           // Contents of ECR
    BOOLEAN    bDone;

    ParDump2( PARENTRY, ("ParEcpHwSetAddress, Start\r\n"));

    // Calculate I/O port addresses for common registers
    wPortDSR = Extension->Controller + DSR_OFFSET;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        wPortECR = Extension->Controller + ECR_OFFSET;
    #else
        wPortECR = Extension->EcrController + ECR_OFFSET;
    #endif
    wPortAFIFO = Extension->Controller + AFIFO_OFFSET;

    //----------------------------------------------------------------------
    // Check for any link errors.
    //----------------------------------------------------------------------
    //ZIP_CHECK_PORT( DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
    //                "ZIP_SCA: init DCR", RECOVER_40, errorExit );

    //ZIP_CHECK_LINK( DONT_CARE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
    //                "ZIP_SCA: init DSR", RECOVER_41, errorExit );


    // Set state to indicate ECP forward transfer phase
    Extension->CurrentPhase = PHASE_FORWARD_XFER;


    //----------------------------------------------------------------------
    // Send ECP channel address to AFIFO.
    //----------------------------------------------------------------------
    if ( ! ( TEST_ECR_FIFO( READ_PORT_UCHAR( wPortECR), ECR_FIFO_EMPTY ) ? TRUE : 
             CheckPort( wPortECR, ECR_FIFO_MASK, ECR_FIFO_EMPTY, 
                        IEEE_MAXTIME_TL ) ) )
    {
        nError = ParEcpHwHostRecoveryPhase(Extension);
        ParDump2(PARERRORS, ("ParEcpHwSetAddress: FIFO full, timeout sending ECP channel address\r\n"));
        nError = STATUS_IO_DEVICE_ERROR;
    }
    else
    {

        // Send the address byte.  The most significant bit must be set to distinquish
        // it as an address (as opposed to a run-length compression count).
        WRITE_PORT_UCHAR(wPortAFIFO, (UCHAR)(Address | 0x80));


    }

    if ( NT_SUCCESS(nError) )
    {
        // If there have been no previous errors, and synchronous writes
        // have been requested, wait for the FIFO to empty and the device to
        // complete the last PeriphAck handshake before returning success.
        if ( Extension->bSynchWrites )
        {
            LARGE_INTEGER   Wait;
            LARGE_INTEGER   Start;
            LARGE_INTEGER   End;

            // we wait up to 35 milliseconds.
            Wait.QuadPart = (IEEE_MAXTIME_TL * 10 * 1000) + KeQueryTimeIncrement();  // 35ms

            KeQueryTickCount(&Start);

            bDone = FALSE;
            while ( ! bDone )
            {
                bECR = READ_PORT_UCHAR( wPortECR );
                bDSR = READ_PORT_UCHAR( wPortDSR );
                // LLL/CGM 10/9/95: Tighten up link test - PeriphClk high
                if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
                     TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )
                {
                    bDone = TRUE;
                }
                else
                {
                    KeQueryTickCount(&End);
                    if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart)
                    {
                        ParDump2( PARERRORS, ("ParEcpHwSetAddress, timeout during synch\r\n"));
                        bDone = TRUE;
                        nError = ParEcpHwHostRecoveryPhase(Extension);
                        nError = STATUS_IO_DEVICE_ERROR;
                    }
                }
            } // of while...
        } // if bSynchWrites...
    }

    if ( NT_SUCCESS(nError) )
    {
        // Update the state to reflect that we are back in an idle phase
        Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    }
    else if ( nError == STATUS_IO_DEVICE_ERROR )
    {
        // Update the state to reflect that we are back in an idle phase
        Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    }       

    ParDumpReg(PAREXIT, ("ParEcpHwSetAddress: Exit[%d]", NT_SUCCESS(nError)),
                wPortECR,
                Extension->Controller + OFFSET_DCR,
                wPortDSR);

    return nError;
}

NTSTATUS
ParEcpHwSetupPhase(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine performs 1284 Setup Phase.

Arguments:

    Controller      - Supplies the port address.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS   Status = STATUS_SUCCESS;
    PUCHAR    pPortDCR;       // IO address of Device Control Register (DCR)
    PUCHAR    pPortDSR;       // IO address of Device Status Register (DSR)
    PUCHAR    pPortECR;       // IO address of Extended Control Register (ECR)
    UCHAR    bDCR;           // Contents of DCR

    ParDump2(PARENTRY,("HardwareECP::SetupPhase: Start\r\n"));

    // Calculate I/O port addresses for common registers
    pPortDCR = Extension->Controller + OFFSET_DCR;
    pPortDSR = Extension->Controller + OFFSET_DSR;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        pPortECR = Extension->Controller + ECR_OFFSET;
    #else
        pPortECR = Extension->EcrController + ECR_OFFSET;
    #endif

    // Get the DCR and make sure port hasn't been stomped
    //ZIP_CHECK_PORT( DIR_WRITE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
    //                "ZIP_SP: init DCR", RECOVER_44, exit1 );


    // Set HostAck low
    bDCR = READ_PORT_UCHAR(pPortDCR);               // Get content of DCR.
    bDCR = UPDATE_DCR( bDCR, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
    WRITE_PORT_UCHAR( pPortDCR, bDCR );

    // for some reason dvdr doesn't want an extra check in UNSAFE_MODE
    if ( Extension->ModeSafety == SAFE_MODE ) {
        // Wait for nAckReverse to go high
        // LLL/CGM 10/9/95:  look for PeriphAck low, PeriphClk high as per 1284 spec.
        if ( !CHECK_DSR(Extension->Controller, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE,
                        IEEE_MAXTIME_TL ) )
        {
            // Any failure leaves us in an unknown state to recover from.
            Extension->CurrentPhase = PHASE_UNKNOWN;
            Status = STATUS_IO_DEVICE_ERROR;
            goto HWECP_SetupPhaseExitLabel;
        }
    }

    //----------------------------------------------------------------------
    // Set the ECR to mode 001 (PS2 Mode).
    //----------------------------------------------------------------------
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        Status = Extension->TrySetChipMode ( Extension->PortContext, ECR_ECP_PIO_MODE );            
    #else
        WRITE_PORT_UCHAR(pPortECR, DEFAULT_ECR_PS2);
    #endif
    // Set DCR:  DIR=0 for output, HostAck and HostClk high so HW can drive
    bDCR = UPDATE_DCR( bDCR, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
    WRITE_PORT_UCHAR( pPortDCR, bDCR );

    // Set the ECR to ECP mode, disable DMA
    #if (1 == PARCHIP_ECR_ARBITRATOR)
        // Nothing needs to be done here
    #else
        WRITE_PORT_UCHAR( pPortECR, DEFAULT_ECR_ECP );
    #endif
    Extension->PortHWMode = HW_MODE_ECP;

    // If setup was successful, mark the new ECP phase.
    Extension->CurrentPhase = PHASE_FORWARD_IDLE;

    Status = STATUS_SUCCESS;

HWECP_SetupPhaseExitLabel:

    ParDump2(PARENTRY,("HardwareECP::SetupPhase: End [%d]\r\n", NT_SUCCESS(Status)));
    return Status;
}

NTSTATUS ParEcpHwWaitForEmptyFIFO(IN PDEVICE_EXTENSION   Extension)
/*++

Routine Description:

    This routine will babysit the Fifo.

Arguments:

    Extension  - The device extension.

Return Value:

    NTSTATUS.

--*/
{
    UCHAR           bDSR;         // Contents of DSR
    UCHAR           bECR;         // Contents of ECR
    UCHAR           bDCR;         // Contents of ECR
    BOOLEAN         bDone = FALSE;
    PUCHAR          wPortDSR;
    PUCHAR          wPortECR;
    PUCHAR          wPortDCR;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    NTSTATUS        status = STATUS_SUCCESS;

    // Calculate I/O port addresses for common registers 
    wPortDSR = Extension->Controller + OFFSET_DSR;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        wPortECR = Extension->Controller + ECR_OFFSET;
    #else
        wPortECR = Extension->EcrController + ECR_OFFSET;
    #endif
    wPortDCR = Extension->Controller + OFFSET_DCR;

    Wait.QuadPart = (330 * 10 * 1000) + KeQueryTimeIncrement();  // 330ms
    
    KeQueryTickCount(&Start);

    //--------------------------------------------------------------------
    // wait for the FIFO to empty and the last
    // handshake of PeriphAck to complete before returning success.
    //--------------------------------------------------------------------

    while ( ! bDone )
    {
        bECR = READ_PORT_UCHAR(wPortECR);
        bDSR = READ_PORT_UCHAR(wPortDSR);
        bDCR = READ_PORT_UCHAR(wPortDCR);
        
#if 0
        if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
            TEST_DCR( bDCR, INACTIVE, INACTIVE, ACTIVE, ACTIVE, DONT_CARE, ACTIVE ) &&
            TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )  {
#else
        if ( TEST_ECR_FIFO( bECR, ECR_FIFO_EMPTY ) &&
            TEST_DCR( bDCR, INACTIVE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, ACTIVE ) &&
            TEST_DSR( bDSR, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )  {
#endif
            
            // FIFO is empty, exit without error.
            bDone = TRUE;

        } else {
        
            KeQueryTickCount(&End);
            
            if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart) {
                
                // FIFO not empty, timeout occurred, exit with error.
                // NOTE: There is not a good way to determine how many bytes
                // are stuck in the fifo
                ParDump2( PARERRORS, ("ParEcpHwWaitForEmptyFIFO: timeout during synch\r\n"));
                status = STATUS_IO_TIMEOUT;
                bDone = TRUE;
            }
        }
     } // of while...
     
     return status;
}

NTSTATUS
ParEcpHwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
/*++

Routine Description:

    Writes data to the peripheral using the ECP protocol under hardware
    control.
    
Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          wPortDSR;
    PUCHAR          wPortECR;
    PUCHAR          wPortDFIFO;
    ULONG           bytesToWrite = BufferSize;
    // ULONG           i;
    // UCHAR           dcr;
    UCHAR           dsr, ecr;
    UCHAR           ecrFIFO;
    LARGE_INTEGER   WaitPerByteTimer;
    LARGE_INTEGER   StartPerByteTimer;
    LARGE_INTEGER   EndPerByteTimer;
    #if (1 == DVRH_USE_HW_MAXTIME)
        LARGE_INTEGER   WaitOverallTimer;
        LARGE_INTEGER   StartOverallTimer;
        LARGE_INTEGER   EndOverallTimer;
    #endif
    BOOLEAN         bResetTimer = TRUE;
    ULONG           wBurstCount;    // Length of burst to write when FIFO empty
    PUCHAR          pBuffer;
    NTSTATUS        Status = STATUS_SUCCESS;

    wPortDSR = Extension->Controller + DSR_OFFSET;
    #if (0 == DVRH_USE_PARPORT_ECP_ADDR)
        wPortECR = Extension->Controller+ ECR_OFFSET;
        wPortDFIFO = Extension->Controller + ECP_DFIFO_OFFSET;
    #else
        wPortECR = Extension->EcrController + ECR_OFFSET;
        wPortDFIFO = Extension->EcrController;
    #endif
    pBuffer    = Buffer;

    ParTimerCheck(("ParEcpHwWrite: Start bytesToWrite[%d]\r\n", bytesToWrite));
    
    Status = ParTestEcpWrite(Extension);
    if (!NT_SUCCESS(Status))
    {
        Extension->CurrentPhase = PHASE_UNKNOWN;                     
        Extension->Connected = FALSE;                                
        ParDump2(PARERRORS,("ParEcpHwWrite: Invalid Entry State\r\n"));
        goto ParEcpHwWrite_ExitLabel;       // Use a goto so we can see Debug info located at the end of proc!
    }

    Extension->CurrentPhase = PHASE_FORWARD_XFER;
    //----------------------------------------------------------------------
    // Setup Timer Stuff.
    //----------------------------------------------------------------------
    // we wait up to 35 milliseconds.
    WaitPerByteTimer.QuadPart = (35 * 10 * 1000) + KeQueryTimeIncrement();  // 35ms
    #if (1 == DVRH_USE_HW_MAXTIME)
        WaitOverallTimer.QuadPart = (330 * 10 * 1000) + KeQueryTimeIncrement();  // 35ms
        //WaitOverallTimer.QuadPart = (35 * 10 * 1000) + KeQueryTimeIncrement();  // 35ms
    #endif
    
    // Set up the overall timer that limits how much time is spent per call
    // to this function.
    #if (1 == DVRH_USE_HW_MAXTIME)
        KeQueryTickCount(&StartOverallTimer);
    #endif

    // Set up the timer that limits the time allowed for per-byte handshakes.
    KeQueryTickCount(&StartPerByteTimer);

    //----------------------------------------------------------------------
    // Send the data to the DFIFO.
    //----------------------------------------------------------------------

HWECP_WriteLoop_Start:

    //------------------------------------------------------------------
    // Determine whether the FIFO has space and respond accordingly.
    //------------------------------------------------------------------
    ecrFIFO = (UCHAR)(READ_PORT_UCHAR(wPortECR) & ECR_FIFO_MASK);

    if ( ECR_FIFO_EMPTY == ecrFIFO )
    {
        wBurstCount = (bytesToWrite > Extension->FifoDepth) ? Extension->FifoDepth : bytesToWrite;
        bytesToWrite -= wBurstCount;

        #if (PAR_USE_BUFFER_READ_WRITE == 1)
  			ParDump2(PARINFO,("ParEcpHwWrite: FIFOBurst\r\n"));
            WRITE_PORT_BUFFER_UCHAR(wPortDFIFO, pBuffer, wBurstCount);
            pBuffer += wBurstCount;
        #else
            while ( wBurstCount-- ) 
            {
    			ParDump2(PARINFO,("ParEcpHwWrite: FIFOBurst: %02x\r\n",(int)*pBuffer));
                WRITE_PORT_UCHAR(wPortDFIFO, *pBuffer++);
            }
        #endif

        bResetTimer = TRUE;
    }
    else if (ECR_FIFO_SOME_DATA == ecrFIFO)
    {
        // Write just one byte at a time, since we don't know exactly how much
        // room there is.
        ParDump2(PARINFO,("ParEcpHwWrite: OneByte: %02x\r\n",(int)*pBuffer));
        WRITE_PORT_UCHAR(wPortDFIFO, *pBuffer++);
        bytesToWrite--;
        bResetTimer = TRUE;
    }
    else {    //  ECR_FIFO_FULL
        ParDump2(PARINFO,("ParEcpHwWrite: ECR_FIFO_FULL ecr=%02x\r\n",(int)READ_PORT_UCHAR(wPortECR)));
        // Need to figure out whether to keep attempting to send, or to quit
        // with a timeout status.

        // Reset the per-byte timer if a byte was received since the last
        // timer check.
        if ( bResetTimer )
        {
   			ParDump2(PARINFO,("ParEcpHwWrite: ECR_FIFO_FULL Reset Timer\r\n"));
            KeQueryTickCount(&StartPerByteTimer);
            bResetTimer = FALSE;
        }

        KeQueryTickCount(&EndPerByteTimer);
        if ((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement() > WaitPerByteTimer.QuadPart)
        {
            ParDump2(PARERRORS,("ParEcpHwWrite: ECR_FIFO_FULL Timeout ecr=%02x\r\n",(int)READ_PORT_UCHAR(wPortECR)));
            Status = STATUS_TIMEOUT;
            // Peripheral is either busy or stalled.  If the peripheral
            // is busy then they should be using SWECP to allow for
            // relaxed timings.  Let's punt!
            goto HWECP_WriteLoop_End;
        }
    }

    if (bytesToWrite == 0)
    {
        goto HWECP_WriteLoop_End; // Transfer completed.
    }

    #if (1 == DVRH_USE_HW_MAXTIME)
        // Limit the overall time we spend in this loop, in case the
        // peripheral is taking data at a slow overall rate.
        KeQueryTickCount(&EndOverallTimer);
        if ((EndOverallTimer.QuadPart - StartOverallTimer.QuadPart) * KeQueryTimeIncrement() > WaitOverallTimer.QuadPart)
	    {
		    ParDump2(PARERRORS,("ParEcpHwWrite: OverAll Timer expired!\r\n"));
            Status = STATUS_TIMEOUT;
            goto HWECP_WriteLoop_End;
	    }
    #endif
    goto HWECP_WriteLoop_Start; // Start over

HWECP_WriteLoop_End:

    if ( NT_SUCCESS(Status) )
    {
        // If there have been no previous errors, and synchronous writes
        // have been requested, wait for the FIFO to empty and the last
        // handshake of PeriphAck to complete before returning success.
        if (Extension->bSynchWrites )
        {
            BOOLEAN         bDone = FALSE;

			ParDump2(PARINFO,("ParEcpHwWrite: Waiting for FIFO to empty\r\n"));
            #if (0 == DVRH_USE_HW_MAXTIME)
                KeQueryTickCount(&StartPerByteTimer);
            #endif
            while ( ! bDone )
            {
                ecr = READ_PORT_UCHAR(wPortECR);
                dsr = READ_PORT_UCHAR(wPortDSR);
                // LLL/CGM 10/9/95: tighten up DSR test - PeriphClk should be high
                if ( TEST_ECR_FIFO( ecr, ECR_FIFO_EMPTY ) &&
                     TEST_DSR( dsr, INACTIVE, ACTIVE, ACTIVE, ACTIVE, DONT_CARE ) )
                {
                    ParDump2(PARINFO,("ParEcpHwWrite: FIFO is now empty\r\n"));
                    // FIFO is empty, exit without error.
                    bDone = TRUE;
                }
                else
                {
                #if (1 == DVRH_USE_HW_MAXTIME)
                    KeQueryTickCount(&EndOverallTimer);
                    if ((EndOverallTimer.QuadPart - StartOverallTimer.QuadPart) * KeQueryTimeIncrement() > WaitOverallTimer.QuadPart)
                #else
                    KeQueryTickCount(&EndPerByteTimer);
                    if ((EndPerByteTimer.QuadPart - StartPerByteTimer.QuadPart) * KeQueryTimeIncrement() > WaitPerByteTimer.QuadPart)
                #endif
                    {
            			ParDump2(PARERRORS,("ParEcpHwWrite: FIFO didn't empty. dsr[%x] ecr[%x]\r\n", dsr, ecr));
                        // FIFO not empty, timeout occurred, exit with error.
                        Status = STATUS_TIMEOUT;
                        bDone = TRUE;
                        //HPKAssertOnError(0, ("ZIP_FTP, timeout during synch\r\n"));
                    }
                }
            } // of while...
        }
    }

    Extension->CurrentPhase = PHASE_FORWARD_IDLE;

ParEcpHwWrite_ExitLabel:

    *BytesTransferred = BufferSize - bytesToWrite;

    Extension->log.HwEcpWriteCount += *BytesTransferred;

    ParTimerCheck(("ParEcpHwWrite: Exit[%d] BytesTransferred[%d]\r\n", NT_SUCCESS(Status), (long)*BytesTransferred));
    //    ParDumpReg(PAREXIT | PARECPTRACE, ("ParEcpHwWrite: Exit[%d] BytesTransferred[%d]", NT_SUCCESS(Status), (long)*BytesTransferred),
    ParDumpReg(PAREXIT, ("ParEcpHwWrite: Exit[%d] BytesTransferred[%d]", NT_SUCCESS(Status), (long)*BytesTransferred),
                wPortECR,
                Extension->Controller + OFFSET_DCR,
                wPortDSR);

    return Status;
}

NTSTATUS
ParEnterEcpHwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    ECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Controller;

    ParDump2(PARENTRY,("ParEnterEcpHwMode: Start EcrController %x\n", Extension->EcrController));
    Controller = Extension->Controller;

    if ( Extension->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Extension, ECP_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Extension, ECP_EXTENSIBILITY);
        }
    } else {
        ParDump2(PARINFO, ("ParEnterEcpHwMode:: UNSAFE_MODE.\n"));
        Extension->Connected = TRUE;
    }
    
    // LAC ENTEREXIT  5Dec97
    // Make sure that the ECR is in PS/2 mode, and that wPortHWMode
    // has the correct value.  (This is the common entry mode);
    #if (0 == PARCHIP_ECR_ARBITRATOR)
        WRITE_PORT_UCHAR( Controller + ECR_OFFSET, DEFAULT_ECR_PS2 );
    #endif    
    Extension->PortHWMode = HW_MODE_PS2;

    if (NT_SUCCESS(Status)) {
        Status = ParEcpHwSetupPhase(Extension);
        Extension->bSynchWrites = TRUE;     // NOTE this is a temp hack!!!  dvrh
        if (!Extension->bShadowBuffer)
        {
            Queue_Create(&(Extension->ShadowBuffer), Extension->FifoDepth * 2);		
            Extension->bShadowBuffer = TRUE;
        }
        Extension->IsIeeeTerminateOk = TRUE;
    }

    return Status;
}

BOOLEAN
ParIsEcpHwSupported(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    NTSTATUS Status;

    if (Extension->BadProtocolModes & ECP_HW_NOIRQ)
        return FALSE;

    if (Extension->ProtocolModesSupported & ECP_HW_NOIRQ)
        return TRUE;

    if (!(Extension->HardwareCapabilities & PPT_ECP_PRESENT))
        return FALSE;

    if (0 == Extension->FifoWidth)
        return FALSE;
        
    if (Extension->ProtocolModesSupported & ECP_SW)
        return TRUE;

    // Must use HWECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEcpHwMode (Extension, FALSE);
    ParTerminateHwEcpMode (Extension);

    if (NT_SUCCESS(Status)) {

        Extension->ProtocolModesSupported |= ECP_HW_NOIRQ;
        return TRUE;
    }
    return FALSE;
}

VOID
ParTerminateHwEcpMode(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    ParDump2( PARENTRY, ("HWECP::Terminate Entry CurrentPhase %d\r\n", Extension->CurrentPhase));
	// Need to check current phase -- if its reverse, need to flip bus
	// If its not forward -- its an incorrect phase and termination will fail.
    if ( Extension->ModeSafety == SAFE_MODE ) {

        switch (Extension->CurrentPhase)
	    {
		    case  PHASE_FORWARD_IDLE:	// Legal state to terminate
    		{
	    		break;
		    }
            case PHASE_REVERSE_IDLE:	// Flip the bus so we can terminate
            {
                NTSTATUS status = ParEcpHwExitReversePhase( Extension );

            	if ( STATUS_SUCCESS == status )
            	{
            		status = ParEcpEnterForwardPhase(Extension );
        	    }
                else
                {
                    ParDump2( PARERRORS, ("HWECP::Terminate Couldn't flip the bus\r\n"));
                }
                break;
            }
		    case  PHASE_FORWARD_XFER:
            case  PHASE_REVERSE_XFER:
	    	{
                ParDump2( PARERRORS, ("HWECP::Terminate invalid wCurrentPhase (XFer in progress) \r\n"));
    			//status = VE_BUSY;
                // Dunno what to do here.  We probably will confuse the peripheral.
		    	break;
    		}
	    	// LAC TERMINATED  13Jan98
		    // Included PHASE_TERMINATE in the switch so we won't return an
    		// error if we are already terminated.
	    	case PHASE_TERMINATE:
		    {
    			// We are already terminated, nothing to do
	    		break;
		    }	
            default:
            {
                ParDump2( PARERRORS, ("ECP::Terminate VE_CORRUPT: invalid CurrentPhase %d\r\n", Extension->CurrentPhase));
                //status = VE_CORRUPT;
                // Dunno what to do here.  We're lost and don't have a map to figure
                // out where we are!
                break;
            }
	    }

        ParDump2(PARINFO, ("HWECP::Terminate - Test ECPChanAddr\r\n"));

        ParEcpHwWaitForEmptyFIFO(Extension);
        ParCleanupHwEcpPort(Extension);
        IeeeTerminate1284Mode (Extension);
    } else {
        ParCleanupHwEcpPort(Extension);
        ParDump2(PARINFO, ("HWECP::Terminate - UNSAFE_MODE\r\n"));
        Extension->Connected = FALSE;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\hwecp.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    hwecp.h

Abstract:

    This module contains utility code used by other 1284
    hwecp modules (currently becp and hwecp).

Author:

    Robbie Harris (Hewlett-Packard) 27-May-1998

Environment:

    Kernel mode

Revision History :

--*/
#ifndef _HWECP_
#define _HWECP_

#include "ecp.h"
#include "queue.h"

// DVRH_USE_HW_MAXTIME  0 - off
//                      1 - on
//  - Note:  The value will control if we limit the overall time
//          we can send/recieve data from the HWECP read/write methods
#define DVRH_USE_HW_MAXTIME   0

//--------------------------------------------------------------------------
// Printer status constants.   Seem to only be used by hwecp
//--------------------------------------------------------------------------
#define CHKPRNOK        0xDF        // DSR value indicating printer ok.
#define CHKPRNOFF1      0x87        // DSR value indicating printer off.
#define CHKPRNOFF2      0x4F        // DSR value indicating printer off.
#define CHKNOCABLE      0x7F        // DSR value indicating no cable.
#define CHKPRNOFLIN     0xCF        // DSR value indicating printer offline.
#define CHKNOPAPER      0xEF        // DSR value indicating out of paper.
#define CHKPAPERJAM     0xC7        // DSR value indicating paper jam.


VOID
ParCleanupHwEcpPort(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwEmptyFIFO(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwHostRecoveryPhase(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwRecoverPort(
    IN PDEVICE_EXTENSION Extension,
    UCHAR  bRecoverCode
    );

NTSTATUS
ParEcpHwWaitForEmptyFIFO(
    IN PDEVICE_EXTENSION   Extension
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\hwepp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    epp.c

Abstract:

    This module contains the code to perform all Hardware EPP related tasks.

Author:

    Don Redford - July 30, 1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


BOOLEAN
ParIsEppHwSupported(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine determines whether or not HW EPP mode is suported
    for either direction by negotiating when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    // dvdr
    ParDump2(PARINFO, ("ParIsEppHwWriteSupported: Entering\n"));

    // Check to see if the hardware is capable
    if (!(Extension->HardwareCapabilities & PPT_EPP_PRESENT)) {
        // dvdr
        ParDump2(PARINFO, ("ParIsEppHwWriteSupported: Hardware Not Supported Leaving\n"));
        return FALSE;
    }

    if (Extension->BadProtocolModes & EPP_HW) {
        // dvdr
        ParDump2(PARINFO, ("ParIsEppHwWriteSupported: Bad Protocol Not Supported Leaving\n"));
        return FALSE;
    }
        
    if (Extension->ProtocolModesSupported & EPP_HW) {
        // dvdr
        ParDump2(PARINFO, ("ParIsEppHwWriteSupported: Already Checked Supported Leaving\n"));
        return TRUE;
    }

    // Must use HWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppHwMode (Extension, FALSE);
    ParTerminateEppHwMode (Extension);
    
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParIsEppHwWriteSupported: Negotiated Supported Leaving\n"));
        Extension->ProtocolModesSupported |= EPP_HW;
        return TRUE;
    }
   
    ParDump2(PARINFO, ("ParIsEppHwWriteSupported: Not Negotiated Not Supported Leaving\n"));
    return FALSE;    
}

NTSTATUS
ParEnterEppHwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    EPP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    // dvdr
    ParDump2(PARINFO, ("ParEnterEppHwMode: Entering\n"));

    if ( Extension->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            // dvdr
            ParDump2(PARINFO, ("ParEnterEppHwMode: Calling IeeeEnter1284Mode with DEVICE_ID_REQUEST\n"));
            Status = IeeeEnter1284Mode (Extension, EPP_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            // dvdr
            ParDump2(PARINFO, ("ParEnterEppHwMode: Calling IeeeEnter1284Mode\n"));
            Status = IeeeEnter1284Mode (Extension, EPP_EXTENSIBILITY);
        }
    } else {
        ParDump2(PARINFO, ("ParEnterEppHwMode: In UNSAFE_MODE.\n"));
        Extension->Connected = TRUE;
    }
    
    if (NT_SUCCESS(Status)) {
        Status = Extension->TrySetChipMode ( Extension->PortContext, ECR_EPP_PIO_MODE );
        
        if (NT_SUCCESS(Status)) {
            // dvdr
            ParDump2(PARINFO, ("ParEnterEppHwMode: IeeeEnter1284Mode returned success\n"));
            Extension->CurrentPhase = PHASE_FORWARD_IDLE;
            Extension->IsIeeeTerminateOk = TRUE;
        } else {
            ParDump2(PARINFO, ("ParEnterEppHwMode: TrySetChipMode returned unsuccessful\n"));
            ParTerminateEppHwMode ( Extension );
            Extension->CurrentPhase = PHASE_UNKNOWN;
            Extension->IsIeeeTerminateOk = FALSE;
        }
    } else {
        // dvdr
        ParDump2(PARINFO, ("ParEnterEppHwMode: IeeeEnter1284Mode returned unsuccessful\n"));
        Extension->CurrentPhase = PHASE_UNKNOWN;
        Extension->IsIeeeTerminateOk = FALSE;
    }
    
    ParDump2(PARINFO, ("ParEnterEppHwMode: Leaving with Status : %x \n", Status));

    return Status; 
}    

VOID
ParTerminateEppHwMode(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Extension  - The Device Extension which has the parallel port's controller address.

Return Value:

    None.

--*/

{
    // dvdr
    ParDump2(PARINFO, ("ParTerminateEppMode: Entering\n"));
    Extension->ClearChipMode( Extension->PortContext, ECR_EPP_PIO_MODE );
    if ( Extension->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode ( Extension );
    } else {
        ParDump2(PARINFO, ("ParTerminateEppMode: In UNSAFE_MODE.\n"));
        Extension->Connected = FALSE;
    }
    ParDump2(PARINFO, ("ParTerminateEppMode: Leaving\n"));
    return;    
}

NTSTATUS
ParEppHwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the EPP using Hardware flow control.
    
Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          wPortEPP;
    PUCHAR          pBuffer;
    ULONG           ulongSize = 0;  // represents how many ULONG's we are transfering if enabled
    
    // dvdr
    ParDump2(PARINFO, ("ParEppHwWrite: Entering\n"));

    wPortEPP    = Extension->Controller + EPP_OFFSET;
    pBuffer     = Buffer;

    Extension->CurrentPhase = PHASE_FORWARD_XFER;
    
    // Check to see if hardware supports 32 bit reads and writes
    if ( Extension->HardwareCapabilities & PPT_EPP_32_PRESENT ) {
        if ( !(BufferSize % 4) )
            ulongSize = BufferSize >> 2;
    }

    // ulongSize != 0 so EPP 32 bit is enabled and Buffersize / 4
    if ( ulongSize ) {
        WRITE_PORT_BUFFER_ULONG( (PULONG)wPortEPP,
                                 (PULONG)pBuffer,
                                 ulongSize );
    } else {
        WRITE_PORT_BUFFER_UCHAR( wPortEPP,
                                 (PUCHAR)pBuffer,
                                 BufferSize );
    }

    Extension->CurrentPhase = PHASE_FORWARD_IDLE;

    *BytesTransferred = BufferSize;

    // dvdr
    ParDump2(PARINFO, ("ParEppHwWrite: Leaving with %i Bytes Transferred\n", BufferSize));
    
    return STATUS_SUCCESS;
}

NTSTATUS
ParEppHwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 EPP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          wPortEPP;
    PUCHAR          pBuffer;
    ULONG           ulongSize = 0;  // represents how many ULONG's we are transfering if enabled
    
    // dvdr
    ParDump2(PARINFO, ("ParEppHwRead: Entering\n"));

    wPortEPP    = Extension->Controller + EPP_OFFSET;
    pBuffer     = Buffer;
    Extension->CurrentPhase = PHASE_REVERSE_XFER;
    
    // Check to see if hardware supports 32 bit reads and writes
    if ( Extension->HardwareCapabilities & PPT_EPP_32_PRESENT ) {
        if ( !(BufferSize % 4) )
            ulongSize = BufferSize >> 2;
    }

    // ulongSize != 0 so EPP 32 bit is enabled and Buffersize / 4
    if ( ulongSize ) {
        READ_PORT_BUFFER_ULONG( (PULONG)wPortEPP,
                                (PULONG)pBuffer,
                                ulongSize );
    } else {
        READ_PORT_BUFFER_UCHAR( wPortEPP,
                                (PUCHAR)pBuffer,
                                BufferSize );
    }

    Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    *BytesTransferred = BufferSize;

    // dvdr
    ParDump2(PARINFO, ("ParEppHwRead: Leaving with %i Bytes Transferred\n", BufferSize));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\ieee1284.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    ieee1284.c

Abstract:

    This module contains the code to do ieee 1284 negotiation and termination.

Author:

    Timothy T. Wells (v-timtw)          13 Mar 97
    Robbie Harris (Hewlett-Packard)     21 May 98.  Added enough comments to the
                                                    Negotation proc to keep any developer happy.

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
#include "readwrit.h"

VOID
IeeeTerminate1284Mode(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
IeeeEnter1284Mode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Extensibility
    );

//
// Definition of the Forward and Reverse Protocol Arrays
//
extern FORWARD_PTCL    afpForward[] = {

    //
    // Bounded ECP (Hardware)
    //
    ParIsBecpSupported,
    ParEnterBecpMode,
    ParTerminateBecpMode,
    ParEcpHwSetAddress,
    ParEcpEnterForwardPhase,           // Enter Forward
    ParEcpHwExitForwardPhase,           // Exit Forward
    ParEcpHwWrite,
    BOUNDED_ECP,
    FAMILY_BECP,             

    //
    // ECP Hardware
    //
    ParIsEcpHwSupported,        // This is resued for both read/write
    ParEnterEcpHwMode,
    ParTerminateHwEcpMode,
    ParEcpHwSetAddress,           
    ParEcpEnterForwardPhase,  // Enter Forward
    ParEcpHwExitForwardPhase,   // Exit Forward
    ParEcpHwWrite,
    ECP_HW_NOIRQ,
    FAMILY_ECP,

    //
    // Epp Hardware
    //
    ParIsEppHwSupported,
    ParEnterEppHwMode,
    ParTerminateEppHwMode,
    ParEppSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEppHwWrite,
    EPP_HW,
    FAMILY_EPP,

    //
    // Epp Software
    //
    ParIsEppSwWriteSupported,
    ParEnterEppSwMode,
    ParTerminateEppSwMode,
    ParEppSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEppSwWrite,
    EPP_SW,
    FAMILY_EPP,

    //
    // Ecp Software
    //
    ParIsEcpSwWriteSupported,
    ParEnterEcpSwMode,
    ParTerminateEcpMode,
    ParEcpSetAddress,
    NULL,                               // Enter Forward
    NULL,                               // Exit Forward
    ParEcpSwWrite,
    ECP_SW,
    FAMILY_ECP,

    //
    // IEEE Centronics
    //
    NULL,
    ParEnterSppMode,
    ParTerminateSppMode,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    SppIeeeWrite,
    IEEE_COMPATIBILITY,
    FAMILY_NONE,

    //
    // Centronics
    //
    NULL,
    ParEnterSppMode,
    ParTerminateSppMode,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    SppWrite,
    CENTRONICS,
    FAMILY_NONE,

    //
    // None...
    //
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,           // Enter Forward
    NULL,           // Exit Forward
    NULL,
    NONE,
    FAMILY_NONE
};

extern REVERSE_PTCL    arpReverse[] = {

    //
    // Bounded Ecp Mode
    //
    ParIsBecpSupported,
    ParEnterBecpMode,
    ParTerminateBecpMode,
    NULL,                       // Violates IEEE 1284.3 to set Reverse address for BECP
    ParEcpHwEnterReversePhase,   // Enter Reverse
    ParBecpExitReversePhase,     // Exit Reverse
    ParEcpHwDrainShadowBuffer,  // A read from Cached data
    ParEcpHwHaveReadData,         // Quick peek to see if Periph has reverse data without flipping the bus
                                // NOTE: This is crucial since it violates the 1284.3 BECP to flip
                                // blindly into reverse if the peripheral doesn't have data.
    ParBecpRead,
    BOUNDED_ECP,
    FAMILY_BECP,             

    //
    // Hardware Ecp Mode
    //
    ParIsEcpHwSupported,        // This is resued for both read/write
    ParEnterEcpHwMode,
    ParTerminateHwEcpMode,
    ParEcpHwSetAddress,           // Reuse the one in ecp.c
    ParEcpHwEnterReversePhase,  // Enter Reverse
    ParEcpHwExitReversePhase,   // Exit Reverse
    ParEcpHwDrainShadowBuffer,  // A read from Cached data
    ParEcpHwHaveReadData,       // Quick peek to see if Periph has reverse data without flipping the bus
    ParEcpHwRead,
    ECP_HW_NOIRQ,
    FAMILY_ECP,

    //
    // Epp Hardware
    //
    ParIsEppHwSupported,            // This is resued for both read/write
    ParEnterEppHwMode,
    ParTerminateEppHwMode,
    ParEppSetAddress,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParEppHwRead,
    EPP_HW,
    FAMILY_EPP,

    //
    // Epp Software Mode
    //
    ParIsEppSwReadSupported,
    ParEnterEppSwMode,
    ParTerminateEppSwMode,
    ParEppSetAddress,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParEppSwRead,
    EPP_SW,
    FAMILY_EPP,

    //
    // Ecp Software Mode
    //
    ParIsEcpSwReadSupported,
    ParEnterEcpSwMode,
    ParTerminateEcpMode,
    ParEcpSetAddress,
    ParEcpForwardToReverse,             // Enter Reverse
    ParEcpReverseToForward,             // Exit Reverse
    NULL,                               // A read from Cached data
    ParEcpHaveReadData,                 // Quick peek to see if Periph has reverse data without flipping the bus
    ParEcpSwRead,
    ECP_SW,
    FAMILY_ECP,

    //
    // Byte Mode
    //
    ParIsByteSupported,
    ParEnterByteMode,
    ParTerminateByteMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParByteModeRead,
    BYTE_BIDIR,
    FAMILY_REVERSE_BYTE,

    //
    // Nibble Mode
    //
    ParIsNibbleSupported,
    ParEnterNibbleMode,
    ParTerminateNibbleMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParNibbleModeRead,
    NIBBLE,
    FAMILY_REVERSE_NIBBLE,

    //
    // Channelized Nibble Mode
    //
    ParIsChannelizedNibbleSupported,
    ParEnterChannelizedNibbleMode,
    ParTerminateNibbleMode,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    ParNibbleModeRead,
    CHANNEL_NIBBLE,
    FAMILY_REVERSE_NIBBLE,
    
    //
    // None...
    //
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,           // Enter Reverse
    NULL,           // Exit Reverse
    NULL,           // A read from Cached data
    NULL,           // Quick peek to see if Periph has reverse data without flipping the bus
    NULL,
    NONE,
    FAMILY_NONE
};


VOID
IeeeTerminate1284Mode(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    PUCHAR Controller;
    PUCHAR wPortDCR;
    UCHAR  dcr, dsrMask, dsrValue;
    BOOLEAN bXFlag;
    BOOLEAN bUseXFlag = FALSE;

    Controller = Extension->Controller;
    wPortDCR = Controller + OFFSET_DCR;
    dcr = READ_PORT_UCHAR(wPortDCR);

    if ( PHASE_TERMINATE == Extension->CurrentPhase )
	{
    		// We are already terminated.  This will fail if we don't
    		// just bypass this mess.
    		goto Terminate_ExitLabel;
	}

#if 0
    // Not  ready for this yet.  --dvrh
    if (!Extension->IsIeeeTerminateOk)
        goto Terminate_ExitLabel;
#endif

    // Keep Negotiated XFLAG to use for termination.
//    xFlag,  // Technically we should have
            // cached this value from state
            // 6 of nego. This peripheral's XFlag
            // at pre state 22 should be the
            // same as state 6.
    bXFlag = READ_PORT_UCHAR(Controller + OFFSET_DSR) & 0x10;

    // REVISIT: Do we need to ensure the preceeding state is a valid
    //          state to terminate from.  In other words, is there there
    //          a black bar on the 1284 line for that state?
    ParDump2(PARENTRY,("IeeeTerminate1284Mode: Start Controller %x\n", Controller));

    // =============== Host State 22 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low (Signals state 22)
    //  nReverseReq/**(ECP only)    = Don't Care (High for ECP, otherwise unused)
    //  HostAck/HostBusy/nAutoFeed  = High
    //  HostClk/nStrobe             = High
	//
    Extension->CurrentEvent = 22;
    dcr = READ_PORT_UCHAR(wPortDCR);
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    WRITE_PORT_UCHAR(wPortDCR, dcr);

    // Clear data lines so we don't have any random spew.
    WRITE_PORT_UCHAR(Controller + OFFSET_DATA, 0);

    // *************** Periph State 23/24 Termination ***************8
    // PeriphAck/PtrBusy        = High  (Signals state 23 for ECP
    //                                   otherwise already high)
    // PeriphClk/PtrClk         = Low   (Signals state 24 for ecp
    //                                   Signals state 23 for Nibble)
    // nAckRev/AckDataReq/PE    = Don't Care
    // XFlag                    = Low  (ECP and Byte)   (State 24)
    //                          = High (Nibble)         (State 24)
    //                          = Low (All DeviceID Requests including Nibble) (State 24)
    //                          = Undefined (EPP)
    // nPeriphReq/nDataAvail    = High
    //                            Don't check nPeriphReq/nDataAvail
    //                            Since it was in a "Don't Care"
    //                            state (ie. Double bar in the spec)
    //                            until state 23 for ECP mode.
    if (Extension->CurrentPhase == PHASE_REVERSE_IDLE ||
        Extension->CurrentPhase == PHASE_REVERSE_XFER)
    {
        // We must be in Nibble Reverse.  Let's double check!!!
        if (FAMILY_REVERSE_NIBBLE == arpReverse[Extension->IdxReverseProtocol].ProtocolFamily ||
            FAMILY_REVERSE_BYTE ==  arpReverse[Extension->IdxReverseProtocol].ProtocolFamily)
            bUseXFlag = TRUE;   // We're in Nibble or Byte
        else
            bUseXFlag = FALSE;   // Don't know what mode we are in?
    }
    else
    {
        if (FAMILY_BECP == afpForward[Extension->IdxForwardProtocol].ProtocolFamily ||
            FAMILY_ECP == afpForward[Extension->IdxForwardProtocol].ProtocolFamily)
            bUseXFlag = TRUE;   // We're in an ECP Flavor
        else
            bUseXFlag = FALSE;   // Don't know what mode we are in?
        
    }

    if (bUseXFlag)
    {
        dsrMask = DSR_TEST_MASK( DONT_CARE,
                                 INACTIVE,
                                 DONT_CARE,
                                 bXFlag ? INACTIVE : ACTIVE,
                                 DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE,
                                   INACTIVE,
                                   DONT_CARE,
                                   bXFlag ? INACTIVE : ACTIVE,
                                   DONT_CARE );
    }
    else
    {
        dsrMask = DSR_TEST_MASK( DONT_CARE,
                                 INACTIVE,
                                 DONT_CARE,
                                 DONT_CARE,
                                 DONT_CARE );
        dsrValue = DSR_TEST_VALUE( DONT_CARE,
                                   INACTIVE,
                                   DONT_CARE,
                                   DONT_CARE,
                                   DONT_CARE );
    }
    Extension->CurrentEvent = 23;
    if (!CheckPort(Controller + OFFSET_DSR,
                  dsrMask,
                  dsrValue,
                  IEEE_MAXTIME_TL))
    {
        // We couldn't negotiate back to compatibility mode.
        // just terminate.
        ParDump2(PARERRORS,("IeeeTerminate1284Mode:State 23/24 Failed: Controller %x dsr %x dcr %x\n",
                            Controller,
                            READ_PORT_UCHAR(Controller + OFFSET_DSR), dcr));
        goto Terminate_ExitLabel;
    }

    // =============== Host State 25 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = Low (Signals State 25)
    //  HostClk/nStrobe             = High
	//
    Extension->CurrentEvent = 25;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    WRITE_PORT_UCHAR(wPortDCR, dcr);

    // =============== State 26 Termination ===============8
    // Do nothing for state 26

    // =============== Periph State 27 Termination ===============8
    // PeriphAck/PtrBusy        = High
    // PeriphClk/PtrClk         = High   (Signals State 27)
    // nAckRev/AckDataReq/PE    = Don't Care  (Invalid from State 23)
    // XFlag                    = Don't Care (All Modes)   (Invlaid at State 27)
    // nPeriphReq/nDataAvial    = Don't Care (Invalid from State 26)
    // dvrh 6/16/97
    Extension->CurrentEvent = 27;
    if (!CHECK_DSR(Controller,
                    ACTIVE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE,
                    IEEE_MAXTIME_TL))
    {
        ParDump2(PARERRORS, ("IeeeTerminate1284Mode:State 27 Failed: Controller %x dsr %x dcr %x\n",
                            Controller,
                            READ_PORT_UCHAR(Controller + OFFSET_DSR), dcr));
    }

// I'm really big into having one exit point in a
// proc.  2/10/97 dvrh
Terminate_ExitLabel:

    // =============== Host State 28 Termination ===============8
    //  DIR                         = Don't Care (Possibly Low)
    //  IRQEN                       = Don't Care (Possibly Low)
    //  1284/SelectIn               = Low
    //  nReverseReq/**(ECP only)    = Don't Care (Possibly High)
    //  HostAck/HostBusy/nAutoFeed  = High (Signals State 28)
    //  HostClk/nStrobe             = High
	//
    Extension->CurrentEvent = 28;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    WRITE_PORT_UCHAR(wPortDCR, dcr);

	// We are now back in compatibility mode.

	ParDump2(PARECPTRACE,("IeeeTerminate1284Mode: Phase_Terminate\n"));
    Extension->CurrentPhase = PHASE_TERMINATE;
    Extension->Connected = FALSE;
    Extension->IsIeeeTerminateOk = FALSE;
    ParDump2(PAREXIT,("IeeeTerminate1284Mode: End dcr %x\n", dcr));
    return;
}

NTSTATUS
IeeeEnter1284Mode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Extensibility
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    PUCHAR          wPortDCR;
    PUCHAR          Controller;
    UCHAR           dcr;
    // BOOLEAN         xFlag;
    NTSTATUS        Status = STATUS_SUCCESS;
    const USHORT    sPeriphResponseTime = 35;

    Controller = Extension->Controller;
    wPortDCR = Controller + OFFSET_DCR;

    ParDump2(PARENTRY,("IeeeEnter1284Mode: Start Controller %x\n", Controller));
    
    /* =============== Host Prep for Pre State 0 ===============8
       Set the following just in case someone didn't
       put the port in compatibility mode before we got it.
      
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High for ECP / Don't Care for Nibble
                                    I will do ahead and set it to high
                                    since Nibble doesn't care.
        HostAck/HostBusy        = High
        HostClk/nStrobe         = Don't Care
    ============================================================ */
    dcr = READ_PORT_UCHAR(wPortDCR);               // Get content of DCR.
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, DONT_CARE);
    WRITE_PORT_UCHAR(wPortDCR, dcr);
    KeStallExecutionProcessor(2);

    /* =============== Host Pre State 0 Negotiation ===============8
        DIR                     = Low ( Don't Care by spec )
        IRQEN                   = Low ( Don't Care by spec )
        1284/SelectIn           = Low
        nReverseReq/  (ECP only)= High ( Don't Care by spec )
        HostAck/HostBusy        = High
        HostClk/nStrobe         = High
    ============================================================ */
    
    dcr = UPDATE_DCR(dcr, INACTIVE, INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE);
    WRITE_PORT_UCHAR(wPortDCR, dcr);
    KeStallExecutionProcessor(2);
    /* =============== Host State 0 Negotiation ===============8
       Place the extensibility request value on the data bus - state 0.
      
    ============================================================ */
    Extension->CurrentEvent = 0;
    WRITE_PORT_UCHAR(Controller + DATA_OFFSET, Extensibility);
    KeStallExecutionProcessor(2);

    /* =========== Host State 1 Negotiation Phase ===========8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High  (Signals State 1)
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low   (Signals state 1)
        HostClk/nStrobe         = High
      
    ============================================================ */
    Extension->CurrentEvent = 1;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
    WRITE_PORT_UCHAR(wPortDCR, dcr);

    /* =============== Periph State 2 Negotiation ===============8
       PeriphAck/PtrBusy        = Don't Care
       PeriphClk/PtrClk         = low   Signals State 2
       nAckReverse/AckDataReq   = high  Signals State 2
       XFlag                    = high  Signals State 2
                                    **Note: It is high at state 2
                                            for both ecp and nibble
       nPeriphReq/nDataAvail    = high  Signals State 2
    ============================================================ */
    Extension->CurrentEvent = 2;
    if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, ACTIVE,
                  sPeriphResponseTime)) {
        KeStallExecutionProcessor(2);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, ACTIVE, DONT_CARE);
        WRITE_PORT_UCHAR(wPortDCR, dcr);
        
        ParDump2(PARIEEE, ("IeeeEnter1284Mode: %x - Extensibility=%x, FAIL - TIMEOUT on Event 2\n",
                   Extension->Controller, Extensibility) );
        Extension->CurrentPhase = PHASE_UNKNOWN;
        Extension->Connected = FALSE;
        Extension->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    /* =============== Host State 3 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = Low
        HostClk/nStrobe         = Low (signals State 3)
      
        NOTE: Strobe the Extensibility byte
    ============================================================ */
    Extension->CurrentEvent = 3;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, INACTIVE);
    WRITE_PORT_UCHAR(wPortDCR, dcr);

    // HostClk must be help low for at least .5 microseconds.
    //
    KeStallExecutionProcessor(2);

    /* =============== Host State 4 Negotiation ===============8
        DIR                     = Don't Care
        IRQEN                   = Don't Care
        1284/SelectIn           = High
        nReverseReq/  (ECP only)= Don't Care
        HostAck/HostBusy        = High (signals State 4)
        HostClk/nStrobe         = High (signals State 4)
      
        NOTE: nReverseReq should be high in ECP, but this line is only
                valid for ECP.  Since it isn't used for signaling
                anything in negotiation, let's just ignore it for now.
    ============================================================ */
    Extension->CurrentEvent = 4;
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
    WRITE_PORT_UCHAR(wPortDCR, dcr);

    /* ============== Periph State 5/6 Negotiation ===============
       PeriphAck/PtrBusy        = Don't Care. low (ECP) / Don't Care (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       PeriphClk/PtrClk         = high (Signals State 6)
       nAckReverse/AckDataReq   = Don't Care. low (ECP) / high (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       XFlag                    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       nPeriphReq/nDataAvail    = Don't Care. high (ECP) / low (Nibble)
                                    Since this line differs based on Protocol
                                    Let's not check the line.
       ============== Periph State 5/6 Negotiation ==============8
      
        NOTES:
                - It's ok to lump states 5 and 6 together.  In state 5 Nibble,
                    the periph will set XFlag low and nPeriphReq/nDataAvail low.
                    The periph will then hold for .5ms then set PeriphClk/PtrClk
                    high.  In ECP, state 5 is nAckReverse/AckDataReq going low and
                    PeriphAck/PtrBusy going low.  Followed by a .5ms pause.
                    Followed by PeriphClk/PtrClk going high.
    ============================================================ */
    Extension->CurrentEvent = 5;
    if (!CHECK_DSR(Controller, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE,
                  sPeriphResponseTime)) {
                  
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE);
        WRITE_PORT_UCHAR(wPortDCR, dcr);

        ParDump2(PARIEEE, ("IeeeEnter1284Mode: %x - Extensibility=%x, FAIL - TIMEOUT on Events 5/6\n",
                   Extension->Controller, Extensibility) );
        Extension->CurrentPhase = PHASE_UNKNOWN;
        Extension->Connected = FALSE;
        Extension->IsIeeeTerminateOk = FALSE;
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    KeStallExecutionProcessor(2);

    ParDump2(PARENTRY,("IeeeEnter1284Mode: Phase Negotiated Controller %x\n", Controller));
    Extension->CurrentPhase = PHASE_NEGOTIATION;
    Extension->Connected = TRUE;
    return STATUS_SUCCESS;
}

VOID
IeeeDetermineSupportedProtocols(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine walks the list of all ieee1284 modes, and
    flags each of the ones the peripheral supports in
    Extension->ProtocolModesSupported. This proc is called from
    external IOCTL.

Arguments:

    Extension - The parallel device extension

Return Value:

--*/
{
    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    // Take CENTRONICS as a given since it is not a
    // mode we can neogitate to.
    //
    // n.b.
    // Let's go ahead and mark IEEE_COMPATIBILITY since we
    // cannot negotiate into it.  But if the someone sets 
    // IEEE_COMPATIBILITY and the peripheral does not support
    // IEEE 1284 compliant compatibility mode then we're gonna
    // create one very unhappy peripheral.      -- dvrh
    Extension->ProtocolModesSupported = CENTRONICS | IEEE_COMPATIBILITY;

    //
    // Unlikely that we would be connected, but...
    //

    ParTerminate(Extension);

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (afpForward[fm].fnIsModeSupported)
            afpForward[fm].fnIsModeSupported(Extension);
    }

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (arpReverse[rm].fnIsModeSupported)
            arpReverse[rm].fnIsModeSupported(Extension);
    }

    return;
}

NTSTATUS
IeeeNegotiateBestMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    )
/*++

Routine Description:

    This routine walks the list of supported modes, looking for the best
    (fastest) mode.  It will skip any mode(s) mask passed in.

Arguments:

    Extension - The parallel device extension

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    //
    // A USHORT is provided in the extension so that each of the protocols
    // can decide whether they need to negotiate each time we go through this
    // process...
    //

    //
    // Unlikely that we would be connected, but...
    //

    ParDump2(PARENTRY, ("IeeeNegotiateBestMode: Enter. Skipping Fwd [%lx] Rev [%lx]\n",
                usWriteMask, usReadMask));

    ParTerminate(Extension);

    Extension->IdxForwardProtocol = FORWARD_NONE;
    Extension->IdxReverseProtocol = REVERSE_NONE;

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (!(afpForward[fm].Protocol & usWriteMask)) {

            if (afpForward[fm].fnIsModeSupported) {

                ParDump2( PARINFO, ("IeeeNegotiateBestMode: Calling ForwardIsSupportedRoutine.\n"));

                if (afpForward[fm].fnIsModeSupported(Extension)) {
                    Extension->IdxForwardProtocol = (USHORT)fm;
                    break;
                }
            }
        }
    }

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (!(arpReverse[rm].Protocol & usReadMask)) {

            if (arpReverse[rm].fnIsModeSupported) {

                ParDump2( PARINFO, ("IeeeNegotiateBestMode: Calling ReverseIsSupportedRoutine.\n"));
                if (arpReverse[rm].fnIsModeSupported(Extension)) {

                    Extension->IdxReverseProtocol = (USHORT)rm;
                    break;
                }
            }
        }
    }

    #if (1 == DVRH_USE_CORRECT_PTRS)
        Extension->fnRead = arpReverse[Extension->IdxReverseProtocol].fnRead;
        Extension->fnWrite = afpForward[Extension->IdxForwardProtocol].fnWrite;
    #endif
    ParDump2( PAREXIT, ("IeeeNegotiateBestMode: Exit. Fwd [%x] Rev [%x]\n", fm, rm));
    return STATUS_SUCCESS;
}

NTSTATUS
IeeeNegotiateMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    )

/*++

Routine Description:

    This routine walks the list of supported modes, looking for the best
    (fastest) mode which is also in the mode mask passed in.

Arguments:

    Extension - The parallel device extension

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{

    REVERSE_MODE    rm;
    FORWARD_MODE    fm;

    //
    // A USHORT is provided in the extension so that each of the protocols
    // can decide whether they need to negotiate each time we go through this
    // process...
    //

    //
    // Unlikely that we would be connected, but...
    //

    ParDump2(PARENTRY, ("IeeeNegotiateMode: Enter\n"));

    ParTerminate(Extension);

    Extension->IdxForwardProtocol = FORWARD_NONE;
    Extension->IdxReverseProtocol = REVERSE_NONE;

    for (fm = FORWARD_FASTEST; fm < FORWARD_NONE; fm++) {

        if (afpForward[fm].Protocol & usWriteMask) {

            if (afpForward[fm].fnIsModeSupported) {

                ParDump2( PARINFO, ("IeeeNegotiateMode: Calling ForwardIsSupportedRoutine.\n"));

                if (afpForward[fm].fnIsModeSupported(Extension)) {
                    Extension->IdxForwardProtocol = (USHORT)fm;
                    break;
                }

            } else {

                ParDump2( PARINFO, ("IeeeNegotiateMode: No ForwardIsSupportedRoutine.\n"));
                Extension->IdxForwardProtocol = (USHORT)fm;
                break;
            }
        }
    }

    ParDump2( PARINFO, ("IeeeNegotiateMode: Extension->IdxForwardProtocol = %x.\n", fm));

    for (rm = REVERSE_FASTEST; rm < REVERSE_NONE; rm++) {

        if (arpReverse[rm].Protocol & usReadMask) {

            if (arpReverse[rm].fnIsModeSupported) {

                ParDump2( PARINFO, ("IeeeNegotiateMode: Calling ReverseIsSupportedRoutine.\n"));
                if (arpReverse[rm].fnIsModeSupported(Extension)) {

                    Extension->IdxReverseProtocol = (USHORT)rm;
                    break;
                }

            } else {

                ParDump2( PARINFO, ("IeeeNegotiateMode: No ReverseIsSupportedRoutine.\n"));
                Extension->IdxReverseProtocol = (USHORT)rm;
                break;
            }
        }
    }

    ParDump2( PARINFO, ("IeeeNegotiateMode: Extension->IdxReverseProtocol = %x.\n", rm));
    #if (1 == DVRH_USE_CORRECT_PTRS)
        Extension->fnRead = arpReverse[Extension->IdxReverseProtocol].fnRead;
        Extension->fnWrite = afpForward[Extension->IdxForwardProtocol].fnWrite;
    #endif
    ParDump2( PAREXIT, ("IeeeNegotiateMode: Exit\n"));

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\errlog.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       errlog.c
//
//--------------------------------------------------------------------------

#include "pch.h"

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject        - Supplies a pointer to the driver object for the
                            device.

    DeviceObject        - Supplies a pointer to the device object associated
                            with the device that had the error, early in
                            initialization, one may not yet exist.

    P1,P2               - Supplies the physical addresses for the controller
                            ports involved with the error if they are available
                            and puts them through as dump data.

    SequenceNumber      - Supplies a ulong value that is unique to an IRP over
                            the life of the irp in this driver - 0 generally
                            means an error not associated with an irp.

    MajorFunctionCode   - Supplies the major function code of the irp if there
                            is an error associated with it.

    RetryCount          - Supplies the number of times a particular operation
                            has been retried.

    UniqueErrorValue    - Supplies a unique long word that identifies the
                            particular call to this function.

    FinalStatus         - Supplies the final status given to the irp that was
                            associated with this error.  If this log entry is
                            being made during one of the retries this value
                            will be STATUS_SUCCESS.

    SpecificIOStatus    - Supplies the IO status for this particular error.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    PVOID                   ObjectToUse;
    SHORT                   DumpToAllocate;

    ParDump2(PARERRORS, ("Enter ParLogError(...)\n") );

    if (ARGUMENT_PRESENT(DeviceObject)) {

        ObjectToUse = DeviceObject;

    } else {

        ObjectToUse = DriverObject;

    }

    DumpToAllocate = 0;

    if (P1.LowPart != 0 || P1.HighPart != 0) {
        DumpToAllocate = (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    if (P2.LowPart != 0 || P2.HighPart != 0) {
        DumpToAllocate += (SHORT) sizeof(PHYSICAL_ADDRESS);
    }

    ErrorLogEntry = IoAllocateErrorLogEntry(ObjectToUse,
            (UCHAR) (sizeof(IO_ERROR_LOG_PACKET) + DumpToAllocate));

    if (!ErrorLogEntry) {
        return;
    }

    ErrorLogEntry->ErrorCode         = SpecificIOStatus;
    ErrorLogEntry->SequenceNumber    = SequenceNumber;
    ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
    ErrorLogEntry->RetryCount        = RetryCount;
    ErrorLogEntry->UniqueErrorValue  = UniqueErrorValue;
    ErrorLogEntry->FinalStatus       = FinalStatus;
    ErrorLogEntry->DumpDataSize      = DumpToAllocate;

    if (DumpToAllocate) {

        RtlCopyMemory(ErrorLogEntry->DumpData, &P1, sizeof(PHYSICAL_ADDRESS));

        if (DumpToAllocate > sizeof(PHYSICAL_ADDRESS)) {

            RtlCopyMemory(((PUCHAR) ErrorLogEntry->DumpData) +
                          sizeof(PHYSICAL_ADDRESS), &P2,
                          sizeof(PHYSICAL_ADDRESS));
        }
    }

    IoWriteErrorLogEntry(ErrorLogEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\nibble.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    nibble.c

Abstract:

    This module contains the code to do nibble mode reads.

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

BOOLEAN
ParIsNibbleSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterNibbleMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateNibbleMode(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParNibbleModeRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    

BOOLEAN
ParIsNibbleSupported(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine determines whether or not nibble mode is suported
    by trying to negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    ParDump2(PARINFO, ("ParIsNibbleSupported: Start\n"));

    if (Extension->BadProtocolModes & NIBBLE) {
        ParDump2(PARINFO, ("ParIsNibbleSupported: BAD PROTOCOL Leaving\n"));
        return FALSE;
    }

    if (Extension->ProtocolModesSupported & NIBBLE) {
        ParDump2(PARINFO, ("ParIsNibbleSupported: Already Checked YES Leaving\n"));
        return TRUE;
    }

    Status = ParEnterNibbleMode (Extension, FALSE);
    ParTerminateNibbleMode (Extension);
    
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParIsNibbleSupported: SUCCESS Leaving\n"));
        Extension->ProtocolModesSupported |= NIBBLE;
        return TRUE;
    }
    
    ParDump2(PARINFO, ("ParIsNibbleSupported: UNSUCCESSFUL Leaving\n"));
    return FALSE;    
    
}

BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine determines whether or not channelized nibble mode is suported (1284.3)
    by trying to negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    ParDump2(PARINFO, ("ParIsChannelizedNibbleSupported: Start\n"));

    if (Extension->BadProtocolModes & CHANNEL_NIBBLE) {
        ParDump2(PARINFO, ("ParIsChannelizedNibbleSupported: BAD PROTOCOL Leaving\n"));
        return FALSE;
    }

    if (Extension->ProtocolModesSupported & CHANNEL_NIBBLE) {
        ParDump2(PARINFO, ("ParIsChannelizedNibbleSupported: Already Checked YES Leaving\n"));
        return TRUE;
    }

    Status = ParEnterChannelizedNibbleMode (Extension, FALSE);
    ParTerminateNibbleMode (Extension);
    
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParIsChannelizedNibbleSupported: SUCCESS Leaving\n"));
        Extension->ProtocolModesSupported |= CHANNEL_NIBBLE;
        return TRUE;
    }
    
    ParDump2(PARINFO, ("ParIsChannelizedNibbleSupported: UNSUCCESSFUL Leaving\n"));
    return FALSE;    
    
}

NTSTATUS
ParEnterNibbleMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    ParDump2(PARINFO, ("ParEnterNibbleMode: Start\n"));

    if ( Extension->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Extension, NIBBLE_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Extension, NIBBLE_EXTENSIBILITY);
        }
    } else {
        ParDump2(PARINFO, ("ParEnterNibbleMode: In UNSAFE_MODE.\n"));
        Extension->Connected = TRUE;
    }

    // dvdr
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParEnterNibbleMode: IeeeEnter1284Mode returned success\n"));
        Extension->CurrentEvent = 6;
        Extension->CurrentPhase = PHASE_NEGOTIATION;
        Extension->IsIeeeTerminateOk = TRUE;
    } else {
        ParDump2(PARINFO, ("ParEnterNibbleMode: IeeeEnter1284Mode returned unsuccessful\n"));
        ParTerminateNibbleMode ( Extension );
        Extension->CurrentPhase = PHASE_UNKNOWN;
        Extension->IsIeeeTerminateOk = FALSE;
    }

    ParDump2(PARINFO, ("ParEnterNibbleMode: Leaving with Status : %x \n", Status));

    return Status; 
}    

NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    nibble mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    ParDump2(PARINFO, ("ParEnterChannelizedNibbleMode: Start\n"));

    if ( Extension->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Extension, CHANNELIZED_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Extension, CHANNELIZED_EXTENSIBILITY);
        }
    } else {
        ParDump2(PARINFO, ("ParEnterChannelizedNibbleMode: In UNSAFE_MODE.\n"));
        Extension->Connected = TRUE;
    }
    
    // dvdr
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParEnterChannelizedNibbleMode: IeeeEnter1284Mode returned success\n"));
        Extension->CurrentEvent = 6;
        Extension->CurrentPhase = PHASE_NEGOTIATION;
        Extension->IsIeeeTerminateOk = TRUE;
    } else {
        ParDump2(PARINFO, ("ParEnterChannelizedNibbleMode: IeeeEnter1284Mode returned unsuccessful\n"));
        ParTerminateNibbleMode ( Extension );
        Extension->CurrentPhase = PHASE_UNKNOWN;
        Extension->IsIeeeTerminateOk = FALSE;
    }

    ParDump2(PARINFO, ("ParEnterChannelizedNibbleMode: Leaving with Status : %x \n", Status));
    return Status; 
}    

VOID
ParTerminateNibbleMode(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    ParDump2(PARINFO, ("ParTerminateNibbleMode: Enter.\n"));
    if ( Extension->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Extension);
    } else {
        ParDump2(PARINFO, ("ParTerminateNibbleMode: In UNSAFE_MODE.\n"));
        Extension->Connected = FALSE;
    }
    ParDump2(PARINFO, ("ParTerminateNibbleMode: Exit.\n"));
}

NTSTATUS
ParNibbleModeRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 nibble mode read into the given
    buffer for no more than 'BufferSize' bytes.

Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          wPortDCR;
    PUCHAR          wPortDSR;
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          p = (PUCHAR)Buffer;
    UCHAR           dsr, dcr;
    UCHAR           nibble[2];
    ULONG           i, j;

    Controller = Extension->Controller;
    wPortDCR = Controller + OFFSET_DCR;
    wPortDSR = Controller + OFFSET_DSR;
    
    // Read nibbles according to 1284 spec.
    ParDump2(PARENTRY,("ParNibbleModeRead: Start\n"));

    dcr = READ_PORT_UCHAR(wPortDCR);

    switch (Extension->CurrentPhase) {
    
        case PHASE_NEGOTIATION: 
        
            ParDump2(PARINFO,("ParNibbleModeRead: PHASE_NEGOTIATION\n"));
            
            // Starting in state 6 - where do we go from here?
            // To Reverse Idle or Reverse Data Transfer Phase depending if
            // data is available.
            
            dsr = READ_PORT_UCHAR(wPortDSR);
            
            // =============== Periph State 6 ===============8
            // PeriphAck/PtrBusy        = Don't Care
            // PeriphClk/PtrClk         = Don't Care (should be high
            //                              and the nego. proc already
            //                              checked this)
            // nAckReverse/AckDataReq   = Don't Care (should be high)
            // XFlag                    = Don't Care (should be low)
            // nPeriphReq/nDataAvail    = High/Low (line status determines
            //                              which state we move to)
            Extension->CurrentEvent = 6;
        #if (0 == DVRH_USE_NIBBLE_MACROS)
            if (dsr & DSR_NOT_DATA_AVAIL)
        #else
            if (TEST_DSR(dsr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE ))
        #endif
            {
                // Data is NOT available - go to Reverse Idle
                ParDump2(PARINFO,("ParNibbleModeRead: PHASE_REVERSE_IDLE\n"));
                // Host enters state 7  - officially in Reverse Idle now
                
            	// Must stall for at least .5 microseconds before this state.
                KeStallExecutionProcessor(1);

                /* =============== Host State 7 Nibble Reverse Idle ===============8
                    DIR                     = Don't Care
                    IRQEN                   = Don't Care
                    1284/SelectIn           = High
                    nReverseReq/  (ECP only)= Don't Care
                    HostAck/HostBusy        = Low (signals State 7)
                    HostClk/nStrobe         = High
                  ============================================================ */
                Extension->CurrentEvent = 7;
            #if (0 == DVRH_USE_NIBBLE_MACROS)
                dcr |= DCR_NOT_HOST_BUSY;
            #else
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, INACTIVE, ACTIVE);
            #endif
                WRITE_PORT_UCHAR(wPortDCR, dcr);

                Extension->CurrentPhase =  PHASE_REVERSE_IDLE ;
                // FALL THRU TO reverse idle
            } else {
            
                // Data is available, go to Reverse Transfer Phase
                Extension->CurrentPhase =  PHASE_REVERSE_XFER ;
                // DO NOT fall thru
                goto PhaseReverseXfer; // please save me from my sins!
            }


        case PHASE_REVERSE_IDLE:

            // Check to see if the peripheral has indicated Interrupt Phase and if so, 
            // get us ready to reverse transfer.

            // See if data is available (looking for state 19)
            dsr = READ_PORT_UCHAR(Controller + OFFSET_DSR);
                
            if (!(dsr & DSR_NOT_DATA_AVAIL)) {
                
                dcr = READ_PORT_UCHAR(wPortDCR);
                // =========== Host State 20 Interrupt Phase ===========8
                //  DIR                     = Don't Care
                //  IRQEN                   = Don't Care
                //  1284/SelectIn           = High
                //  nReverseReq/ (ECP only) = Don't Care
                //  HostAck/HostBusy        = High (Signals state 20)
                //  HostClk/nStrobe         = High
                //
                // Data is available, get us to Reverse Transfer Phase
                Extension->CurrentEvent = 20;
                dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE, ACTIVE, ACTIVE);
                WRITE_PORT_UCHAR(wPortDCR, dcr);

                // =============== Periph State 21 HBDA ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = Don't Care (should be high)
                // nAckReverse/AckDataReq   = low (signals state 21)
                // XFlag                    = Don't Care (should be low)
                // nPeriphReq/nDataAvail    = Don't Care (should be low)
                Extension->CurrentEvent = 21;
                if (CHECK_DSR(Controller,
                                DONT_CARE, DONT_CARE, INACTIVE,
                                DONT_CARE, DONT_CARE,
                                IEEE_MAXTIME_TL)) {
                                  
                // Got state 21
                    // Let's jump to Reverse Xfer and get the data
                    Extension->CurrentPhase = PHASE_REVERSE_XFER;
                    goto PhaseReverseXfer;
                        
                } else {
                    
                    // Timeout on state 21
                    Extension->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    Extension->CurrentPhase = PHASE_UNKNOWN;
                    ParDump2(PARERRORS, ("ParNibbleModeRead:Failed State 21: Controller %x dcr %x\n",
                                        Controller, dcr));
                    // NOTE:  Don't ASSERT Here.  An Assert here can bite you if you are in
                    //        Nibble Rev and you device is off/offline.
                    // dvrh 2/25/97
                    goto NibbleReadExit;
                }

            } else {
                
                // Data is NOT available - do nothing
                // The device doesn't report any data, it still looks like it is
                // in ReverseIdle.  Just to make sure it hasn't powered off or somehow
                // jumped out of Nibble mode, test also for AckDataReq high and XFlag low
                // and nDataAvaul high.
                Extension->CurrentEvent = 18;
                dsr = READ_PORT_UCHAR(Controller + OFFSET_DSR);
                if(( dsr & DSR_NIBBLE_VALIDATION )== DSR_NIBBLE_TEST_RESULT ) {

                    Extension->CurrentPhase = PHASE_REVERSE_IDLE ;

                } else {
                    #if DVRH_BUS_RESET_ON_ERROR
                        BusReset(wPortDCR);  // Pass in the dcr address
                    #endif
                    // Appears we failed state 19.
                    Extension->IsIeeeTerminateOk = TRUE;
                    Status = STATUS_IO_DEVICE_ERROR;
                    Extension->CurrentPhase = PHASE_UNKNOWN;
                    ParDump2(PARERRORS, ("ParNibbleModeRead:Failed State 19: Controller %x dcr %x\n",
                                        Controller, dcr));
                }
                goto NibbleReadExit;

            }
        
PhaseReverseXfer:

        case PHASE_REVERSE_XFER: 
        
            ParDump2(PARINFO,("ParNibbleModeRead:PHASE_REVERSE_IDLE\n"));
            
            for (i = 0; i < BufferSize; i++) {
            
                for (j = 0; j < 2; j++) {
                
                    // Host enters state 7 or 12 depending if nibble 1 or 2
//                    StoreControl (Controller, HDReady);
                    dcr |= DCR_NOT_HOST_BUSY;
                    WRITE_PORT_UCHAR(wPortDCR, dcr);

                    // =============== Periph State 9     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = low (signals state 9)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    Extension->CurrentEvent = 9;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, INACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        
                        Extension->IsIeeeTerminateOk = FALSE;
                        Status = STATUS_IO_DEVICE_ERROR;
                        ParDump2(PARERRORS, ("ParNibbleModeRead:Failed State 9: Controller %x dcr %x\n",
                                            Controller, dcr));
                        Extension->CurrentPhase = PHASE_UNKNOWN;
                        goto NibbleReadExit;
                    }

                    // Read Nibble
                    nibble[j] = READ_PORT_UCHAR(wPortDSR);

                    /* ============== Host State 10 Nibble Read ===============8
                        DIR                     = Don't Care
                        IRQEN                   = Don't Care
                        1284/SelectIn           = High
                        HostAck/HostBusy        = High (signals State 10)
                        HostClk/nStrobe         = High
                    ============================================================ */
                    Extension->CurrentEvent = 10;
                    dcr &= ~DCR_NOT_HOST_BUSY;
                    WRITE_PORT_UCHAR(wPortDCR, dcr);

                    // =============== Periph State 11     ===============8
                    // PeriphAck/PtrBusy        = Don't Care (Bit 3 of Nibble)
                    // PeriphClk/PtrClk         = High (signals state 11)
                    // nAckReverse/AckDataReq   = Don't Care (Bit 2 of Nibble)
                    // XFlag                    = Don't Care (Bit 1 of Nibble)
                    // nPeriphReq/nDataAvail    = Don't Care (Bit 0 of Nibble)
                    Extension->CurrentEvent = 11;
                    if (!CHECK_DSR(Controller,
                                  DONT_CARE, ACTIVE, DONT_CARE,
                                  DONT_CARE, DONT_CARE,
                                  IEEE_MAXTIME_TL)) {
                        // Time out.
                        // Bad things happened - timed out on this state,
                        // Mark Status as bad and let our mgr kill current mode.
                        Status = STATUS_IO_DEVICE_ERROR;
                        Extension->IsIeeeTerminateOk = FALSE;
                        ParDump2(PARERRORS, ("ParNibbleModeRead:Failed State 11: Controller %x dcr %x\n",
                                            Controller, dcr));
                        Extension->CurrentPhase = PHASE_UNKNOWN;
                        goto NibbleReadExit;
                    }
                }

                // Read two nibbles - make them into one byte.
                
                p[i] = (((nibble[0]&0x38)>>3)&0x07) |
                       ((nibble[0]&0x80) ? 0x00 : 0x08);
                p[i] |= (((nibble[1]&0x38)<<1)&0x70) |
                        ((nibble[1]&0x80) ? 0x00 : 0x80);

                ParDump2(PARINFO,("ParNibbleModeRead:%x:%c\n", p[i], p[i]));

                // At this point, we've either received the number of bytes we
                // were looking for, or the peripheral has no more data to
                // send, or there was an error of some sort (of course, in the
                // error case we shouldn't get to this comment).  Set the
                // phase to indicate reverse idle if no data available or
                // reverse data transfer if there's some waiting for us
                // to get next time.

                dsr = READ_PORT_UCHAR(wPortDSR);
                
                if (dsr & DSR_NOT_DATA_AVAIL) {
                
                    // Data is NOT available - go to Reverse Idle
                    // Really we are going to HBDNA, but if we set
                    // current phase to reverse idle, the next time
                    // we get into this function all we have to do
                    // is set hostbusy low to indicate idle and
                    // we have infinite time to do that.
                    // Break out of the loop so we don't try to read
                    // data that isn't there.
                    // NOTE - this is a successful case even if we
                    // didn't read all that the caller requested
                    Extension->CurrentPhase = PHASE_REVERSE_IDLE ;
                    i++; // account for this last byte transferred
                    break;
                    
                } else {
                    // Data is available, go to (remain in ) Reverse Transfer Phase
                    Extension->CurrentPhase = PHASE_REVERSE_XFER ;
                }
            } // end for i loop

            *BytesTransferred = i;
            // DON'T FALL THRU THIS ONE
            break;

        default:
            // I'm gonna mark this as false. There is not a correct answer here.
            //  The peripheral and the host are out of sync.  I'm gonna reset myself
            // and the peripheral.       
            Extension->IsIeeeTerminateOk = FALSE;
            Status = STATUS_IO_DEVICE_ERROR;
            Extension->CurrentPhase = PHASE_UNKNOWN ;

            ParDump2(PARERRORS, ("ParNibbleModeRead:Failed State 9: Unknown Phase. Controller %x dcr %x\n",
                                Controller, dcr));
            ParDump2(PARERRORS, ( "ParNibbleModeRead: You're hosed man.\n" ));
            ParDump2(PARERRORS, ( "ParNibbleModeRead: If you are here, you've got a bug somewhere else.\n" ));
            ParDump2(PARERRORS, ( "ParNibbleModeRead: Go fix it!\n" ));
            goto NibbleReadExit;
            break;
    } // end switch

NibbleReadExit:

    ParDump2(PARINFO,("ParNibbleModeRead:PHASE_REVERSE_IDLE\n"));
    
    if( Extension->CurrentPhase == PHASE_REVERSE_IDLE ) {
        // Host enters state 7  - officially in Reverse Idle now
        dcr |= DCR_NOT_HOST_BUSY;

        WRITE_PORT_UCHAR (wPortDCR, dcr);
    }

    ParDump2(PAREXIT,("ParNibbleModeRead:End [%d] bytes read = %d\n",
                    NT_SUCCESS(Status), *BytesTransferred));
    Extension->log.NibbleReadCount += *BytesTransferred;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\ioctl.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

File Name:

    ioctl.c

Contained in Module:

    parallel.sys

Abstract:

    This file contains functions associated with ParClass IOCTL processing.

    - The three main entry points in this file are:

      - ParDeviceControl()          - Dispatch function for non-internal IOCTLs

      - ParInternalDeviceControl()  - Dispatch function for internal IOCTLs

      - ParDeviceIo()               - Worker thread entry point for handling all 
                                        IOCTLs not completed in a dispatch function

    - Helper/Utility function naming conventions:
 
      - ParpIoctlDispatch...()      - private helper function called by dispatch function

      - ParpIoctlThread...()        - private helper function called by worker thread

Authors:

    Anthony V. Ercolano  1-Aug-1992
    Norbert P. Kusters  22-Oct-1993
    Douglas G. Fritz    24-Jul-1998

Revision History :

--*/

#include "pch.h"
#include "readwrit.h"   // require declaration for ParReverseToForward()


VOID
ParpIoctlThreadLockPort(
    IN PDEVICE_EXTENSION Extension
    )
{
    NTSTATUS status;
    PIRP     irp = Extension->CurrentOpIrp;

    ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_LOCK_PORT - attempting to acquire LockPortMutex\n") );
    // ExAcquireFastMutex (&Extension->LockPortMutex);
    ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_LOCK_PORT - LockPortMutex acquired\n") );
    
    Extension->AllocatedByLockPort = TRUE;
    
    // - begin
    ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_LOCK_PORT - attempting to Select Device\n") );
    
// dvdr    if( ParSelectDevice(Extension,FALSE) ) {
    if( ParSelectDevice(Extension,TRUE) ) {
        ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_LOCK_PORT - Select Device - SUCCESS\n") );
        status = STATUS_SUCCESS;
    } else {
        ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_LOCK_PORT - Select Device - FAIL\n") );
        status = STATUS_UNSUCCESSFUL;
        Extension->AllocatedByLockPort = FALSE;
        ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_LOCK_PORT - Releasing LockPortMutex\n") );
        // ExReleaseFastMutex (&Extension->LockPortMutex);
        ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_LOCK_PORT - Released LockPortMutex\n") );
    }    
    // - end
    
    irp->IoStatus.Status = status;
}

VOID
ParpIoctlThreadUnlockPort(
    IN PDEVICE_EXTENSION Extension
    )
{
    PIRP     irp = Extension->CurrentOpIrp;

    ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_UNLOCK_PORT\n") );
    
    Extension->AllocatedByLockPort = FALSE;
    
    if( ParDeselectDevice(Extension, FALSE) ) {
        ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_UNLOCK_PORT - Device Deselected\n") );
    } else {
        ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_UNLOCK_PORT - Device Deselect FAILED\n") );
    }
    
    ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_UNLOCK_PORT - Releasing LockMutex\n") );
    // ExReleaseFastMutex (&Extension->LockPortMutex);
    ParDump2(PARIOCTL2, ("ParDeviceIo::IOCTL_INTERNAL_UNLOCK_PORT - Released LockMutex\n") );
    
    irp->IoStatus.Status = STATUS_SUCCESS;
}

NTSTATUS
IoctlTest(PIRP Irp, PIO_STACK_LOCATION IrpSp, PDEVICE_EXTENSION Extension) {

    // if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PAR_SET_INFORMATION)) {}
    // if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PAR_QUERY_INFORMATION)) {}
    // Status = STATUS_BUFFER_TOO_SMALL;
    
    ParDump2(PARIOCTL2, ("IoctlTest - Irp= %x , IrpSp= %x , Extension= %x\n", Irp, IrpSp, Extension) );

    ParDump2(PARIOCTL2, ("OutputBufferLength= %d, sizeof(PARALLEL_WMI_LOG_INFO)= %d\n", 
             IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
             sizeof(PARALLEL_WMI_LOG_INFO) ) );
    
    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(PPARALLEL_WMI_LOG_INFO)) {
        PPARALLEL_WMI_LOG_INFO buffer = (PPARALLEL_WMI_LOG_INFO)Irp->AssociatedIrp.SystemBuffer;
        *buffer = Extension->log;
        Irp->IoStatus.Information = sizeof(PARALLEL_WMI_LOG_INFO);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    } else {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_BUFFER_TOO_SMALL;
    }
}

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.
    STATUS_INVALID_PARAMETER    - Invalid io control request.
    STATUS_DELETE_PENDING       - This device object is being deleted

--*/

{
    PIO_STACK_LOCATION              IrpSp;
    PPAR_SET_INFORMATION            SetInfo;
    NTSTATUS                        Status;
    PSERIAL_TIMEOUTS                SerialTimeouts;
    PDEVICE_EXTENSION               Extension;
    KIRQL                           OldIrql;
    // PPARCLASS_INFORMATION           pParclassInfo;


    ParDump2(PARIOCTL2, ("Enter ParDeviceControl(...)\n") );

    Irp->IoStatus.Information = 0;

    IrpSp     = IoGetCurrentIrpStackLocation(Irp);
    Extension = DeviceObject->DeviceExtension;

    //
    // bail out if a delete is pending for this device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_DELETE_PENDING) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PAR_DEVICE_REMOVED|PAR_DEVICE_SURPRISE_REMOVAL) ) {

        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

#if 0
    case IOCTL_PAR_TEST:

        return IoctlTest(Irp, IrpSp, Extension);
#endif

    case IOCTL_PAR_SET_INFORMATION:
        
        ParDump2(PARIOCTL2, ("IOCTL_PAR_SET_INFORMATION\n") );

        SetInfo = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(PAR_SET_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else if (SetInfo->Init != PARALLEL_INIT) {
            
            Status = STATUS_INVALID_PARAMETER;
            
        } else {
            
            //
            // This is a parallel reset
            //
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_QUERY_INFORMATION :
        
        ParDump2(PARIOCTL2, ("IOCTL_PAR_QUERY_INFORMATION - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PAR_QUERY_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_SERIAL_SET_TIMEOUTS:
        
        ParDump2(PARIOCTL2, ("IOCTL_SERIAL_SET_TIMEOUTS - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        SerialTimeouts = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(SERIAL_TIMEOUTS)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else if (SerialTimeouts->WriteTotalTimeoutConstant < 2000) {
            
            Status = STATUS_INVALID_PARAMETER;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_SERIAL_GET_TIMEOUTS:
        
        ParDump2(PARIOCTL2, ("IOCTL_SERIAL_GET_TIMEOUTS - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        SerialTimeouts = Irp->AssociatedIrp.SystemBuffer;
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(SERIAL_TIMEOUTS)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            //
            // We don't need to synchronize the read.
            //
            
            RtlZeroMemory(SerialTimeouts, sizeof(SERIAL_TIMEOUTS));
            SerialTimeouts->WriteTotalTimeoutConstant =
                1000 * Extension->TimerStart;
            
            Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);
            Status = STATUS_SUCCESS;
        }
        break;
        
    case IOCTL_PAR_QUERY_DEVICE_ID:
    case IOCTL_PAR_QUERY_RAW_DEVICE_ID:
        
        ParDump2(PARIOCTL2, ("IOCTL_PAR_QUERY_DEVICE_ID - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength == 0) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_PAR_QUERY_DEVICE_ID_SIZE:
        
        ParDump2(PARIOCTL2, ("IOCTL_PAR_QUERY_DEVICE_ID_SIZE - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PAR_DEVICE_ID_SIZE_INFORMATION)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_IS_PORT_FREE:
        
        ParDump2(PARIOCTL2, ("IOCTL_PAR_IS_PORT_FREE - %wZ\n", &Extension->SymbolicLinkName));
        
        if( IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(BOOLEAN) ) {

            Status = STATUS_BUFFER_TOO_SMALL;

        } else {

            if( Extension->bAllocated ) {
                // if we have the port then it is not free
                *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = FALSE;
            } else {
                // determine if the port is free by trying to allocate and free it
                //  - our alloc/free will only succeed if no one else has the port
                BOOLEAN tryAllocSuccess = Extension->TryAllocatePort( Extension->PortContext );
                if( tryAllocSuccess ) {
                    // we were able to allocate the port, free it and report that the port is free
                    Extension->FreePort( Extension->PortContext );
                    *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = TRUE;
                } else {
                    // we were unable to allocate the port, someone else must be using the port
                    *((PBOOLEAN)Irp->AssociatedIrp.SystemBuffer) = FALSE; 
                }
            }

            Irp->IoStatus.Information = sizeof(BOOLEAN);
            Status = STATUS_SUCCESS;

        }
        break;

    case IOCTL_PAR_GET_READ_ADDRESS:
        ParDump2(PARIOCTL2, ("IOCTL_PAR_GET_READ_ADDRESS - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(Extension->ReverseInterfaceAddress))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            *((PUCHAR) Irp->AssociatedIrp.SystemBuffer) = Extension->ReverseInterfaceAddress;
            Irp->IoStatus.Information = sizeof(Extension->ReverseInterfaceAddress);
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_GET_WRITE_ADDRESS:
        ParDump2(PARIOCTL2, ("IOCTL_PAR_GET_WRITE_ADDRESS - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(Extension->ForwardInterfaceAddress))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            *((PUCHAR) Irp->AssociatedIrp.SystemBuffer) = Extension->ForwardInterfaceAddress;
            Irp->IoStatus.Information = sizeof(Extension->ForwardInterfaceAddress);
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_SET_READ_ADDRESS:
    
        ParDump2(PARIOCTL2, ("  IOCTL_PAR_SET_READ_ADDRESS - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(Extension->ReverseInterfaceAddress)) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_PAR_SET_WRITE_ADDRESS:

        ParDump2(PARIOCTL2, ("  IOCTL_PAR_SET_WRITE_ADDRESS - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(Extension->ForwardInterfaceAddress)) {

            Status = STATUS_INVALID_PARAMETER;

        } else {

            Status = STATUS_PENDING;
        }
        break;
        
    case IOCTL_IEEE1284_GET_MODE:
        
        ParDump2(PARIOCTL2, ("IOCTL_IEEE1284_GET_MODE - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PARCLASS_NEGOTIATION_MASK)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            PPARCLASS_NEGOTIATION_MASK  ppnmMask;
            
            ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            ppnmMask->usReadMask =
                arpReverse[Extension->IdxReverseProtocol].Protocol;
            
            ppnmMask->usWriteMask =
                afpForward[Extension->IdxForwardProtocol].Protocol;
            
            Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_GET_DEFAULT_MODES:
        
        ParDump2(PARIOCTL2, ("IOCTL_IEEE1284_GET_MODE - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(PARCLASS_NEGOTIATION_MASK)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            PPARCLASS_NEGOTIATION_MASK  ppnmMask;
            
            ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            ppnmMask->usReadMask = NONE;            
            ppnmMask->usWriteMask = CENTRONICS;
            
            Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            
            Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_ECP_HOST_RECOVERY:

        ParDump2(PARIOCTL2, ("IOCTL_PAR_ECP_HOST_RECOVERY - %wZ\n", &Extension->SymbolicLinkName) );
        {
            BOOLEAN *isSupported;

            if( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(BOOLEAN) ) {
                Status = STATUS_INVALID_PARAMETER;                
            } else {
                isSupported = (BOOLEAN *)Irp->AssociatedIrp.SystemBuffer;
                Extension->bIsHostRecoverSupported = *isSupported;
                Status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_PAR_PING:
        ParDump2(PARIOCTL2, ("IOCTL_PAR_PING - %wZ\n",
                   &Extension->SymbolicLinkName) );
        // No Parms to check!
        Status = STATUS_PENDING;        
        break;

    case IOCTL_PAR_GET_DEVICE_CAPS:
        ParDump2(PARIOCTL2, ("IOCTL_PAR_GET_DEVICE_CAPS - %wZ\n",
                   &Extension->SymbolicLinkName) );
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(Extension->ProtocolModesSupported)) {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            Status = STATUS_PENDING;
        }
        break;

    case IOCTL_IEEE1284_NEGOTIATE:
        
        ParDump2(PARIOCTL2, ("IOCTL_IEEE1284_NEGOTIATE - %wZ\n",
                   &Extension->SymbolicLinkName) );
        
        if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength  < sizeof(PARCLASS_NEGOTIATION_MASK) ||
             IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARCLASS_NEGOTIATION_MASK) ) {
            ParDump2(PARERRORS, ( "ParDeviceControl: IOCTL_IEEE1284_NEGOTIATE STATUS_INVALID_PARAMETER.\n" ));
            Status = STATUS_INVALID_PARAMETER;
            
        } else {

            PPARCLASS_NEGOTIATION_MASK  ppnmMask;

            ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;
            
            if ((ppnmMask->usReadMask == arpReverse[Extension->IdxReverseProtocol].Protocol) &&
                (ppnmMask->usWriteMask == afpForward[Extension->IdxForwardProtocol].Protocol))
            {
                Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
                ParDump2(PARINFO, ( "ParDeviceControl: IOCTL_IEEE1284_NEGOTIATE Passed.\n" ));
                Status = STATUS_SUCCESS;
            }
            else
                Status = STATUS_PENDING;
        }
        break;

    default :

        ParDump2(PARIOCTL2, ("IOCTL default case\n") );
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    
    if (Status == STATUS_PENDING) {
        
        IoAcquireCancelSpinLock(&OldIrql);
        
        if (Irp->Cancel) {
            
            IoReleaseCancelSpinLock(OldIrql);
            Status = STATUS_CANCELLED;
            
        } else {
            
            //
            // This IRP takes more time, so it should be queued.
            //
            BOOLEAN needToSignalSemaphore = IsListEmpty( &Extension->WorkQueue );
            IoMarkIrpPending(Irp);
            IoSetCancelRoutine(Irp, ParCancelRequest);
            InsertTailList(&Extension->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Extension->RequestSemaphore, 0, 1, FALSE);
            }
        }
    }
    
    if (Status != STATUS_PENDING) {
        
        Irp->IoStatus.Status = Status;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);

    }

    return Status;
}

NTSTATUS
ParInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for internal device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.
    STATUS_INVALID_PARAMETER    - Invalid io control request.
    STATUS_DELETE_PENDING       - This device object is being deleted

--*/

{
    PIO_STACK_LOCATION              IrpSp;
    // PPAR_SET_INFORMATION            SetInfo;
    NTSTATUS                        Status;
    // PSERIAL_TIMEOUTS                SerialTimeouts;
    PDEVICE_EXTENSION               Extension;
    KIRQL                           OldIrql;
    PPARCLASS_INFORMATION           pParclassInfo;

    ParDump2(PARIOCTL2, ("Enter ParInternalDeviceControl(...)\n") );

    Irp->IoStatus.Information = 0;

    IrpSp     = IoGetCurrentIrpStackLocation(Irp);
    Extension = DeviceObject->DeviceExtension;

    //
    // bail out if a delete is pending for this device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_DELETE_PENDING) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        ParDump2(PARIOCTL2, ("ParInternalDeviceControl(...) - returning DELETE_PENDING\n") );
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        ParDump2(PARIOCTL2, ("ParInternalDeviceControl(...) - returning DELETE_PENDING\n") );
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PAR_DEVICE_REMOVED|PAR_DEVICE_SURPRISE_REMOVAL) ) {

        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_INTERNAL_PARCLASS_CONNECT:
        
        ParDump2(PARIOCTL2, ("IOCTL_INTERNAL_PARCLASS_CONNECT - Dispatch\n") );
        ParDump2(PARIOCTL2, ("IOCTL_INTERNAL_PARCLASS_CONNECT - %wZ\n", 
                   &Extension->SymbolicLinkName) );
        
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
             sizeof(PARCLASS_INFORMATION))  {
            
            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            pParclassInfo = Irp->AssociatedIrp.SystemBuffer;
            
            pParclassInfo->Controller            = Extension->Controller;
            pParclassInfo->EcrController         = Extension->EcrController;
            pParclassInfo->SpanOfController      = Extension->SpanOfController;
            pParclassInfo->ParclassContext       = Extension;
            pParclassInfo->HardwareCapabilities  = Extension->HardwareCapabilities;
            pParclassInfo->FifoDepth             = Extension->FifoDepth;
            pParclassInfo->FifoWidth             = Extension->FifoWidth;
            pParclassInfo->DetermineIeeeModes    = ParExportedDetermineIeeeModes;
            pParclassInfo->TerminateIeeeMode     = ParExportedTerminateIeeeMode;
            pParclassInfo->NegotiateIeeeMode     = ParExportedNegotiateIeeeMode;
            pParclassInfo->IeeeFwdToRevMode      = ParExportedIeeeFwdToRevMode;
            pParclassInfo->IeeeRevToFwdMode      = ParExportedIeeeRevToFwdMode;
            pParclassInfo->ParallelRead          = ParExportedParallelRead;
            pParclassInfo->ParallelWrite         = ParExportedParallelWrite;
            
            Irp->IoStatus.Information = sizeof(PARCLASS_INFORMATION);
            
            Status = STATUS_SUCCESS;
        }
        
        break;
        
    case IOCTL_INTERNAL_PARCLASS_DISCONNECT:
        
        Status = STATUS_SUCCESS;
        break;
        
    case IOCTL_INTERNAL_DISCONNECT_IDLE:
    case IOCTL_INTERNAL_LOCK_PORT:
    case IOCTL_INTERNAL_UNLOCK_PORT:
    case IOCTL_INTERNAL_PARDOT3_CONNECT:
    case IOCTL_INTERNAL_PARDOT3_RESET:
    
        Status = STATUS_PENDING;
        break;

    case IOCTL_INTERNAL_PARDOT3_DISCONNECT:

        // immediately tell worker thread to stop signalling
        Extension->P12843DL.bEventActive = FALSE;
        Status = STATUS_PENDING;
        break;

    case IOCTL_INTERNAL_PARDOT3_SIGNAL:
    
        if( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(PKEVENT) ) {
            Status = STATUS_INVALID_PARAMETER;                
        } else {
            Status = STATUS_PENDING;
        }
        break;

    default :

        ParDump2(PARIOCTL2, ("IOCTL_INTERNAL... default case - Dispatch\n") );
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    

    if (Status == STATUS_PENDING) {
        
        //
        // This IRP takes more time, queue it for the worker thread
        //

        IoAcquireCancelSpinLock(&OldIrql);
        
        if (Irp->Cancel) {
            
            IoReleaseCancelSpinLock(OldIrql);
            Status = STATUS_CANCELLED;
            
        } else {
            
            BOOLEAN needToSignalSemaphore = IsListEmpty( &Extension->WorkQueue );
            IoMarkIrpPending(Irp);
            IoSetCancelRoutine(Irp, ParCancelRequest);
            InsertTailList(&Extension->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Extension->RequestSemaphore, 0, 1, FALSE);
            }
        }
    }
    
    if (Status != STATUS_PENDING) {

        Irp->IoStatus.Status = Status;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}

VOID
ParDeviceIo(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine implements a DEVICE_IOCTL request with the extension's current irp.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{

    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    ULONG                   IdLength;
    NTSTATUS                NtStatus;
    UCHAR                   Status;
    UCHAR                   Control;
    ULONG                   ioControlCode;

    // ParDump2(PARIOCTL2,("Enter ParDeviceIo(...)\n") );

    Irp     = Extension->CurrentOpIrp;
    IrpSp   = IoGetCurrentIrpStackLocation(Irp);

    ioControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    switch( ioControlCode ) {

    case IOCTL_PAR_SET_INFORMATION : 
        {

            PPAR_SET_INFORMATION IrpBuffer = Extension->CurrentOpIrp->AssociatedIrp.SystemBuffer;
            
            Status = ParInitializeDevice(Extension);
            
            if (!PAR_OK(Status)) {
                ParNotInitError(Extension, Status); // Set the IoStatus.Status of the CurrentOpIrp appropriately
            } else {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }
        }
        break;

    case IOCTL_PAR_QUERY_INFORMATION :
        {
            PPAR_QUERY_INFORMATION IrpBuffer = Irp->AssociatedIrp.SystemBuffer;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            Status  = GetStatus(Extension->Controller);
            Control = GetControl(Extension->Controller);

            // Interpretating Status & Control
            
            IrpBuffer->Status = 0x0;

            if (PAR_POWERED_OFF(Status) || PAR_NO_CABLE(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_POWER_OFF);
                
            } else if (PAR_PAPER_EMPTY(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_PAPER_EMPTY);
                
            } else if (PAR_OFF_LINE(Status)) {
                
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_OFF_LINE);
                
            } else if (PAR_NOT_CONNECTED(Status)) {

                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_NOT_CONNECTED);

            }
            
            if (PAR_BUSY(Status)) {
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_BUSY);
            }
            
            if (PAR_SELECTED(Status)) {
                IrpBuffer->Status = (UCHAR)(IrpBuffer->Status | PARALLEL_SELECTED);
            }
            
            Irp->IoStatus.Information = sizeof( PAR_QUERY_INFORMATION );
        }
        break;

    case IOCTL_PAR_QUERY_RAW_DEVICE_ID :

        // We always read the Device Id in Nibble Mode.
        NtStatus = SppQueryDeviceId(Extension,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                    &IdLength, TRUE);

        Irp->IoStatus.Status = NtStatus;

        if (NT_SUCCESS(NtStatus)) {
            Irp->IoStatus.Information = IdLength;
        } else {
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_QUERY_DEVICE_ID :

        // We always read the Device Id in Nibble Mode.
        NtStatus = SppQueryDeviceId(Extension,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                    &IdLength, FALSE);

        Irp->IoStatus.Status = NtStatus;

        if( NT_SUCCESS( NtStatus ) ) {
            ParDump2(PARIOCTL1, ("IOCTL_PAR_QUERY_ID - SUCCESS - size = %d\n", IdLength));
            // Include terminating NULL in the string to copy back to user buffer
            Irp->IoStatus.Information = IdLength + sizeof(CHAR);
        } else if( NtStatus == STATUS_BUFFER_TOO_SMALL) {
            ParDump2(PARIOCTL1, ("IOCTL_PAR_QUERY_ID - FAIL - BUFFER_TOO_SMALL - supplied= %d, required=%d\n",
                                 IrpSp->Parameters.DeviceIoControl.OutputBufferLength, IdLength) );
            Irp->IoStatus.Information = 0;
        } else {
            ParDump2(PARIOCTL1, ("IOCTL_PAR_QUERY_ID - FAIL - QUERY ID FAILED\n") );
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_QUERY_DEVICE_ID_SIZE :

        //
        // Read the first two bytes of the Nibble Id, add room for the terminating NULL and
        // return this to the caller.
        //
        NtStatus = SppQueryDeviceId(Extension, NULL, 0, &IdLength, FALSE);

        if (NtStatus == STATUS_BUFFER_TOO_SMALL) {

            ParDump2(PARIOCTL1, ("IOCTL_PAR_QUERY_DEVICE_ID_SIZE - size required = %d\n", IdLength));

            Irp->IoStatus.Status = STATUS_SUCCESS;

            Irp->IoStatus.Information =
                sizeof(PAR_DEVICE_ID_SIZE_INFORMATION);

            // include space for terminating NULL
            ((PPAR_DEVICE_ID_SIZE_INFORMATION)
                Irp->AssociatedIrp.SystemBuffer)->DeviceIdSize = IdLength + sizeof(CHAR);

        } else {

            Irp->IoStatus.Status      = NtStatus;
            Irp->IoStatus.Information = 0;
        }
        break;

    case IOCTL_PAR_PING :

        // We need to do a quick terminate and negotiate of the current modes
        NtStatus = ParPing(Extension);
        ParDump2(PARINFO, ("ParDeviceIo:IOCTL_PAR_PING\n"));
        Irp->IoStatus.Status      = NtStatus;
        Irp->IoStatus.Information = 0;
        break;
        
    case IOCTL_INTERNAL_DISCONNECT_IDLE :

        if ((Extension->Connected) &&
            (afpForward[Extension->IdxForwardProtocol].fnDisconnect)) {
            
            ParDump2(PARINFO, ("ParDeviceIo:IOCTL_INTERNAL_DISCONNECT_IDLE: Calling afpForward.fnDisconnect\n"));
            afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
        }
        
        Irp->IoStatus.Status      = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;

    case IOCTL_IEEE1284_NEGOTIATE:
        {
            PPARCLASS_NEGOTIATION_MASK  ppnmMask = (PPARCLASS_NEGOTIATION_MASK)Irp->AssociatedIrp.SystemBuffer;

            ParTerminate(Extension);
            Irp->IoStatus.Status = IeeeNegotiateMode(Extension, ppnmMask->usReadMask, ppnmMask->usWriteMask);

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(PARCLASS_NEGOTIATION_MASK)) {
                ParDump2(PARINFO, ( "ParDeviceIo: IOCTL_IEEE1284_NEGOTIATE Passed.\n" ));
                ppnmMask->usReadMask  = arpReverse[Extension->IdxReverseProtocol].Protocol;
                ppnmMask->usWriteMask = afpForward[Extension->IdxForwardProtocol].Protocol;
                Irp->IoStatus.Information = sizeof (PARCLASS_NEGOTIATION_MASK);
            } else {
                ParDump2(PARERRORS, ( "ParDeviceIo: IOCTL_IEEE1284_NEGOTIATE failed.\n" ));
                Irp->IoStatus.Information = 0;
            }
        }
        break;

    case IOCTL_PAR_GET_DEVICE_CAPS :

        Extension->BadProtocolModes = *((USHORT *) Irp->AssociatedIrp.SystemBuffer);            
        IeeeDetermineSupportedProtocols(Extension);
        *((USHORT *) Irp->AssociatedIrp.SystemBuffer) = Extension->ProtocolModesSupported;
        Irp->IoStatus.Information = sizeof(Extension->ProtocolModesSupported);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        break;

    case IOCTL_PAR_SET_READ_ADDRESS:
        {
            PUCHAR pAddress = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            
            if (Extension->ReverseInterfaceAddress != *pAddress) {
                
                Extension->ReverseInterfaceAddress = *pAddress;
                Extension->SetReverseAddress = TRUE;
            }
            
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_PAR_SET_WRITE_ADDRESS :
        {
            PUCHAR pAddress = (PUCHAR)Irp->AssociatedIrp.SystemBuffer;
            NtStatus = STATUS_SUCCESS;

            if (Extension->ForwardInterfaceAddress != *pAddress) {
        
                Extension->ForwardInterfaceAddress = *pAddress;
                
                if (Extension->Connected) {
                    if (afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress) {
                        
                        if (Extension->CurrentPhase != PHASE_FORWARD_IDLE &&
                            Extension->CurrentPhase != PHASE_FORWARD_XFER) {
                            NtStatus = ParReverseToForward(Extension);
                        }
                        
                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus  = afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress(
                                Extension,
                                Extension->ForwardInterfaceAddress
                                );
                        }
                        
                        if (NT_SUCCESS(NtStatus)) {
                            Extension->SetForwardAddress = FALSE;
                            Extension->SetReverseAddress = FALSE;
                            Extension->ReverseInterfaceAddress = *pAddress;
                        } else {
                            Extension->SetForwardAddress = TRUE;
                            ParDump2(PARERRORS, ( "ParDeviceIo: IOCTL_PAR_SET_WRITE_ADDRESS Failed\n" ));
                        }
                    } else {
#if DBG
                        ParDump2(PARERRORS, ( "ParDeviceIo: Someone called IOCTL_PAR_SET_WRITE_ADDRESS.\n" ));
                        ParDump2(PARERRORS, ( "ParDeviceIo: You don't have a fnSetInterfaceAddress.\n" ));
                        ParDump2(PARERRORS, ( "ParDeviceIo: Either IEEE1284.c has wrong info or your caller is in error!\n" ));
                        NtStatus = STATUS_UNSUCCESSFUL;
#endif
                    }    
                } else {
                    Extension->SetForwardAddress = TRUE;
                }
            }
            
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = NtStatus;
        }
        break;

    case IOCTL_INTERNAL_LOCK_PORT :

        ParpIoctlThreadLockPort(Extension);
        break;

    case IOCTL_INTERNAL_UNLOCK_PORT :

        ParpIoctlThreadUnlockPort(Extension);
        break;
        
    case IOCTL_SERIAL_SET_TIMEOUTS:
        {
            PSERIAL_TIMEOUTS ptoNew = Irp->AssociatedIrp.SystemBuffer;

            //
            // The only other thing let through is setting
            // the timer start.
            //
            
            Extension->TimerStart = ptoNew->WriteTotalTimeoutConstant / 1000;
            Irp->IoStatus.Status  = STATUS_SUCCESS;
        }
        break;
    
    case IOCTL_INTERNAL_PARDOT3_CONNECT:
        ParDump2(PARIOCTL2, ("IOCTL_INTERNAL_PARDOT3_CONNECT - Dispatch\n") );
        Irp->IoStatus.Status  = ParDot3Connect(Extension);
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_DISCONNECT:
        ParDump2(PARIOCTL2, ("IOCTL_INTERNAL_PARDOT3_DISCONNECT - Dispatch\n") );
        Irp->IoStatus.Status  = ParDot3Disconnect(Extension);
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_SIGNAL:
        {
            PKEVENT Event;// = (PKEVENT)Irp->AssociatedIrp.SystemBuffer;

            RtlCopyMemory(&Event, Irp->AssociatedIrp.SystemBuffer, sizeof(PKEVENT));

            ASSERT_EVENT(Event);

            ParDump2(PARIOCTL2, ("IOCTL_INTERNAL_PARDOT3_SIGNAL - Dispatch. Event [%x]\n", Event) );

            Extension->P12843DL.Event        = Event;
            Extension->P12843DL.bEventActive = TRUE;
        }
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;
    case IOCTL_INTERNAL_PARDOT3_RESET:
        ParDump2(PARIOCTL2, ("IOCTL_INTERNAL_PARDOT3_RESET - Dispatch\n") );
        if (Extension->P12843DL.fnReset)
            Irp->IoStatus.Status = ((PDOT3_RESET_ROUTINE) (Extension->P12843DL.fnReset))(Extension);
        else
            Irp->IoStatus.Status  = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        break;
    default:

        //
        // unrecognized IOCTL? - we should never get here because the 
        //   dispatch routines should have filtered this out
        //

        // probably harmless, but we want to know if this happens
        //   so we can fix the problem elsewhere
        ASSERTMSG("Unrecognized IOCTL in ParDeviceIo()\n",FALSE);

        Irp->IoStatus.Status  = STATUS_UNSUCCESSFUL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\funcdecl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       funcdecl.h
//
//--------------------------------------------------------------------------

//
// Function declarations for the ParClass (parallel.sys) driver
//

VOID
ParDumpDevExtTable();

NTSTATUS 
ParWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN ULONG          Action
    );

BOOLEAN
ParIsPodo(
    IN PDEVICE_OBJECT DevObj
    );

NTSTATUS
ParWmiPdoInitWmi(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ParWmiPdoSystemControlDispatch(
    IN  PDEVICE_OBJECT  DeviceObject, 
    IN  PIRP            Irp
    );

PCHAR
Par3QueryDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PCHAR               DeviceIdBuffer,
    IN  ULONG               BufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString, // TRUE == include the 2 size bytes in the returned string
    IN BOOLEAN              bBuildStlDeviceId
    );


PDEVICE_OBJECT
ParDetectCreatePdo(PDEVICE_OBJECT legacyPodo, UCHAR Dot3Id, BOOLEAN bStlDot3Id);

NTSTATUS
ParBuildSendInternalIoctl(
    IN  ULONG           IoControlCode,
    IN  PDEVICE_OBJECT  TargetDeviceObject,
    IN  PVOID           InputBuffer         OPTIONAL,
    IN  ULONG           InputBufferLength,
    OUT PVOID           OutputBuffer        OPTIONAL,
    IN  ULONG           OutputBufferLength,
    IN  PLARGE_INTEGER  Timeout             OPTIONAL
    );


//
// initunld.c - driver initialization and unload
//
NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );

NTSTATUS
ParPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParPdoPower(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP           pIrp
   );

NTSTATUS
ParFdoPower(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP           pIrp
   );

// parclass.c ?

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

UCHAR
ParInitializeDevice(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParNotInitError(
    IN PDEVICE_EXTENSION    Extension,
    IN UCHAR                DeviceStatus
    );

VOID
ParStartIo(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParallelThread(
    IN PVOID    Context
    );

NTSTATUS
ParCreateSystemThread(
    PDEVICE_EXTENSION   Extension
    );

VOID
ParCancelRequest(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    );

// exports.c

USHORT
ParExportedDetermineIeeeModes(
    IN PDEVICE_EXTENSION    Extension
    );

NTSTATUS
ParExportedIeeeFwdToRevMode(
    IN PDEVICE_EXTENSION  Extension
    );

NTSTATUS
ParExportedIeeeRevToFwdMode(
    IN PDEVICE_EXTENSION  Extension
    );

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PDEVICE_EXTENSION  Extension,
	IN USHORT             ModeMaskFwd,
	IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
	IN BOOLEAN            IsForward
    );

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParExportedParallelRead(
    IN PDEVICE_EXTENSION    Extension,
    IN  PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead,
    IN  UCHAR               Channel
    );

NTSTATUS
ParExportedParallelWrite(
    IN PDEVICE_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten,
    IN  UCHAR               Channel
    );
    
NTSTATUS
ParTerminateParclassMode(
    IN PDEVICE_EXTENSION   Extension
    );

VOID
ParWriteIo(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParReadIo(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParDeviceIo(
    IN  PDEVICE_EXTENSION   Extension
    );


// pnp?

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

NTSTATUS
ParPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
ParParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParPdoParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParFdoParallelPnp(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

PDEVICE_OBJECT
ParPnpCreateDevice(
    IN PDRIVER_OBJECT pDriverObject
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParCheckParameters(
    IN OUT  PDEVICE_EXTENSION   Extension
    );

VOID
ParPnpFindDeviceIdKeys(
    OUT PUCHAR   *lppMFG,
    OUT PUCHAR   *lppMDL,
    OUT PUCHAR   *lppCLS,
    OUT PUCHAR   *lppDES,
    OUT PUCHAR   *lppAID,
    OUT PUCHAR   *lppCID,
    IN  PUCHAR   lpDeviceID
    );

VOID
ParDot3ParseDevId(
    PUCHAR   *lpp_DL,
    PUCHAR   *lpp_C,
    PUCHAR   *lpp_CMD,
    PUCHAR   *lpp_4DL,
    PUCHAR   *lpp_M,
    PUCHAR   lpDeviceID
);

VOID
GetCheckSum(
    IN  PUCHAR  Block,
    IN  USHORT  Len,
    OUT PUSHORT CheckSum
    );

BOOLEAN
String2Num(
    IN OUT PUCHAR   *lpp_Str,
    IN CHAR         c,
    OUT ULONG       *num
    );

UCHAR
StringCountValues(
    IN PCHAR string, 
    IN CHAR  delimeter
    );

PUCHAR
StringChr(
    IN  PCHAR string,
    IN  CHAR c
    );

ULONG
StringLen(
    IN  PUCHAR string
    );

VOID
StringSubst(
    IN OUT  PUCHAR lpS,
    IN      UCHAR chTargetChar,
    IN      UCHAR chReplacementChar,
    IN      USHORT cbS
    );

BOOLEAN
ParSelectDevice(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             HavePort
    );

BOOLEAN
ParDeselectDevice(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             KeepPort
    );

#if DBG
VOID
ParDumpDeviceObjectList(
    PDEVICE_OBJECT ParClassFdo
    );
#endif
NTSTATUS
ParAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
ParReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    );

VOID
ParReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    );

NTSTATUS
ParPnpInterfaceChangeNotify(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION pDeviceInterfaceChangeNotification,
    IN  PVOID                                 pContext
    );

VOID
ParMakeClassNameFromNumber(
    IN  ULONG           Number,
    OUT PUNICODE_STRING ClassName
    );

VOID
ParMakeDotClassNameFromBaseClassName(
    IN  PUNICODE_STRING BaseClassName,
    IN  ULONG           Number,
    OUT PUNICODE_STRING DotClassName
    );

VOID
ParInitCommonDOPre(PDEVICE_OBJECT DevObj, PDEVICE_OBJECT Fdo, PUNICODE_STRING ClassName);

VOID
ParInitCommonDOPost(PDEVICE_OBJECT DevObj);

NTSTATUS
ParInitPdo(
    IN PDEVICE_OBJECT NewPdo, 
    IN PUCHAR         DeviceIdString,
    IN ULONG          DeviceIdLength,
    IN PDEVICE_OBJECT LegacyPodo,
    IN UCHAR          Dot3Id
    );

NTSTATUS
ParInitLegacyPodo(PDEVICE_OBJECT LegacyPodo, PUNICODE_STRING PortSymbolicLinkName);

VOID
ParAddDevObjToFdoList(PDEVICE_OBJECT DevObj);

PDEVICE_OBJECT
ParCreateLegacyPodo(PDEVICE_OBJECT Fdo, PUNICODE_STRING PortSymbolicLinkName);

VOID
ParAcquireListMutexAndKillDeviceObject(PDEVICE_OBJECT Fdo, PDEVICE_OBJECT DevObj);

VOID
ParKillDeviceObject(
    PDEVICE_OBJECT DeviceObject
    );

PWSTR
ParCreateWideStringFromUnicodeString(
    PUNICODE_STRING UnicodeString
    );

PDEVICE_OBJECT
ParDetectCreateEndOfChainPdo(PDEVICE_OBJECT LegacyPodo);

VOID
ParEnumerate1284_3Devices(
    IN  PDEVICE_OBJECT  pFdoDeviceObject,
    IN  PDEVICE_OBJECT  pPortDeviceObject,
    IN  PDEVICE_OBJECT  EndOfChainDeviceObject
    );

NTSTATUS
ParPnpNotifyTargetDeviceChange(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION pDeviceInterfaceChangeNotification,
    IN  PDEVICE_OBJECT                        pFdoDeviceObject
    );
    
NTSTATUS
ParPnpNotifyInterfaceChange(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION NotificationStruct,
    IN  PDEVICE_OBJECT                        Fdo
    );

NTSTATUS
ParPnpGetId(
    IN  PUCHAR  DeviceIdString,
    IN  ULONG   Type,
    OUT PUCHAR  resultString,
    OUT PUCHAR  descriptionString
    );

NTSTATUS
ParPnpFdoQueryDeviceRelationsBusRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    );

VOID ParAddPodoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
VOID ParAddEndOfChainPdoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
VOID ParAddDot3PdoToDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PDEVICE_OBJECT CurrentDo);
VOID ParAddLegacyZipPdoToDevObjStruct(IN PPAR_DEVOBJ_STRUCT DevObjStructHead, IN PDEVICE_OBJECT CurrentDo);
PPAR_DEVOBJ_STRUCT ParFindCreateDevObjStruct(PPAR_DEVOBJ_STRUCT DevObjStructHead, PUCHAR Controller);
VOID ParDumpDevObjStructList(PPAR_DEVOBJ_STRUCT DevObjStructHead);
PPAR_DEVOBJ_STRUCT ParBuildDevObjStructList(PDEVICE_OBJECT Fdo);
VOID ParDoParallelBusRescan(PPAR_DEVOBJ_STRUCT DevObjStructHead);

BOOLEAN
ParDeviceExists(
    PDEVICE_EXTENSION Extension,
    IN BOOLEAN        HavePortKeepPort
    );

NTSTATUS
ParAllocatePortDevice(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParAllocatePortDevice(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParAcquirePort(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSTATUS
ParReleasePort(
    IN PDEVICE_OBJECT PortDeviceObject
    );

VOID
ParDetectDot3DataLink(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR DeviceId
    );

VOID
ParMarkPdoHardwareGone(
    IN PDEVICE_EXTENSION Extension
    );

VOID
ParDestroyDevObjStructList(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead
    );

VOID
ParRescan1284_3DaisyChain(
    IN PPAR_DEVOBJ_STRUCT CurrentNode
    );

VOID
ParRescanEndOfChain(
    IN PPAR_DEVOBJ_STRUCT CurrentNode
    );

NTSTATUS
ParInit1284_3Bus(
    IN PDEVICE_OBJECT PortDeviceObject
    );

UCHAR
ParGet1284_3DeviceCount(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParSelect1284_3Device(
    IN  PDEVICE_OBJECT PortDeviceObject,
    IN  UCHAR          Dot3DeviceId
    );

NTSTATUS
ParDeselect1284_3Device(
    IN  PDEVICE_OBJECT PortDeviceObject,
    IN  UCHAR          Dot3DeviceId
    );

VOID
ParRescanLegacyZip( 
    IN PPAR_DEVOBJ_STRUCT CurrentNode 
    ); 

PCHAR
Par3QueryLegacyZipDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString // TRUE ==  include the 2 size bytes in the returned string
                                             // FALSE == discard the 2 size bytes
    );

PCHAR
ParStlQueryStlDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer,
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    ) ;

BOOLEAN
ParStlCheckIfStl(
    IN PDEVICE_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

NTSTATUS
ParRegisterForParportRemovalRelations( 
    IN PDEVICE_EXTENSION Extension 
    );

NTSTATUS
ParUnregisterForParportRemovalRelations( 
    IN PDEVICE_EXTENSION Extension 
    );

VOID
ParCheckEnableLegacyZipFlag();

PWSTR
ParGetPortLptName(
    IN PDEVICE_OBJECT PortDeviceObject
    );

NTSTATUS
ParCreateDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  ULONG           DeviceExtensionSize,
    IN  PUNICODE_STRING DeviceName OPTIONAL,
    IN  DEVICE_TYPE     DeviceType,
    IN  ULONG           DeviceCharacteristics,
    IN  BOOLEAN         Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

VOID
ParInitializeExtension1284Info(
    IN PDEVICE_EXTENSION Extension
    );

VOID
ParGetDriverParameterDword(
    IN     PUNICODE_STRING ServicePath,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    );

VOID
ParFixupDeviceId(
    IN OUT PUCHAR DeviceId
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\initunld.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       initunld.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with driver initialization and unload.
//

#include "pch.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  pRegistryPath
    )
/*++dvdf2

Routine Description:

    This routine initializes the ParClass driver. This is the first driver
      routine called after the driver is loaded.

Arguments:

    DriverObject    - points to the ParClass (parallel.sys) driver object

    pRegistryPath   - points to the registry path for this driver

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

#if DBG
    ParInitDebugLevel(pRegistryPath); // initialize driver debug settings from registry
    //ParDebugLevel = -1;
#endif

    ParBreak(PAR_BREAK_ON_DRIVER_ENTRY, ("DriverEntry(PDRIVER_OBJECT, PUNICODE_STRING)\n") );

    //
    // initialize driver globals
    //

    //
    // Default timeout when trying to acquire ParPort
    //
    AcquirePortTimeout.QuadPart = -((LONGLONG) 10*1000*500); // 500 ms (timeouts in 100ns units)

    //
    // Save Registry path that we were given for use later for WMI.
    //
    RegistryPath.Buffer = ExAllocatePool( PagedPool, pRegistryPath->MaximumLength + sizeof(UNICODE_NULL) );
    if( NULL == RegistryPath.Buffer ) {
        ParDump2(PARERRORS, ("initunld::DriverEntry - unable to alloc space to hold RegistryPath\n") );
        return STATUS_INSUFFICIENT_RESOURCES;
    } else {
        RtlZeroMemory( RegistryPath.Buffer, pRegistryPath->MaximumLength + sizeof(UNICODE_NULL) );
        RegistryPath.Length        = pRegistryPath->Length;
        RegistryPath.MaximumLength = pRegistryPath->MaximumLength;
        RtlMoveMemory( RegistryPath.Buffer, pRegistryPath->Buffer, pRegistryPath->Length );
    }

    //
    // Check for settings under HKLM\SYSTEM\CurrentControlSet\Services\Parallel\Parameters
    //
    ParGetDriverParameterDword( &RegistryPath, (PWSTR)L"SppNoRaiseIrql",  &SppNoRaiseIrql );
    ParGetDriverParameterDword( &RegistryPath, (PWSTR)L"DefaultModes",    &DefaultModes );
    ParGetDriverParameterDword( &RegistryPath, (PWSTR)L"DumpDevExtTable", &DumpDevExtTable );

    //
    // Dump DEVICE_EXTENSION offsets if requested
    //
    if( DumpDevExtTable ) {
        ParDumpDevExtTable();
    }

    //
    // initialize DriverObject pointers to our dispatch routines
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = ParCreateOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = ParClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 = ParCleanup;
    DriverObject->MajorFunction[IRP_MJ_READ]                    = ParReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]                   = ParReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = ParDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = ParInternalDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]       = ParQueryInformationFile;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]         = ParSetInformationFile;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = ParParallelPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = ParPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = ParWmiPdoSystemControlDispatch;
    DriverObject->DriverExtension->AddDevice                    = ParPnpAddDevice;
    DriverObject->DriverUnload                                  = ParUnload;

    return STATUS_SUCCESS;
}

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++dvdf2

Routine Description:

    This routine is called to allow the ParClass driver to do any required 
      cleanup prior to the driver being unloaded. This is the last driver 
      routine called before the driver is loaded.

Arguments:

    DriverObject    - points to the ParClass driver object

Notes:

    No ParClass device objects remain at the time that this routine is called.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( DriverObject );
    PAGED_CODE();

    RtlFreeUnicodeString( &RegistryPath ); // free buffer we allocated in DriverEntry

    ParDump2(PARUNLOAD, ("ParUnload() - Cleanup prior to unload of ParClass driver (parallel.sys)\n") );
    ParBreak(PAR_BREAK_ON_UNLOAD, ("ParUnload(PDRIVER_OBJECT)\n") );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\p12843dl.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    p12843dl.c

Abstract:

    This module contains utility code used by 1284.3 Data Link.

Author:

    Robbie Harris (Hewlett-Packard) 10-September-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
#include "readwrit.h"
#if PAR_TEST_HARNESS
    #include "parharns.h"
#endif

UCHAR Dot3_StartOfFrame1 = 0x55;  
UCHAR Dot3_StartOfFrame2 = 0xaa;  
UCHAR Dot3_EndOfFrame1 = 0x00; 
UCHAR Dot3_EndOfFrame2 = 0xff; 


NTSTATUS
ParDot3Connect(
    IN  PDEVICE_EXTENSION    Extension
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ParFwdSkip, ParRevSkip;
    ULONG ParResetChannel, ParResetByteCount, ParResetByte;
    ULONG ParSkipDefault = 0;
    ULONG ParResetChannelDefault = -1;

    // If an MLC device hangs we can sometimes wake it up by wacking it with 
    //   4 Zeros sent to the reset channel (typically 78 or 0x4E). Make this
    //   configurable via registry setting.
    ULONG ParResetByteCountDefault = 4; // from MLC spec
    ULONG ParResetByteDefault = 0;      // from MLC spec

    BOOLEAN bPrefs = FALSE; // used to determine if we were able
                            // to get some preferred modes to
                            // work with.
    BOOLEAN bConsiderEppDangerous = FALSE;

    if (P12843DL_OFF == Extension->P12843DL.DataLinkMode)
    {
        ParDump2(PARINFO, ("ParDot3Connect: Neither Dot3 or MLC are supported.\r\n"));
        return STATUS_UNSUCCESSFUL;
    }

    if (Extension->P12843DL.bEventActive)
    {
        ParDump2(PARINFO, ("ParDot3Connect: Already connected.\r\n"));
        return STATUS_UNSUCCESSFUL;
    }

    // Let's get a Device Id so we can pull settings
    // for this device
    ParTerminate(Extension);
    {
        PCHAR    buffer         = NULL;
        ULONG    bufferLength;
        //        ULONG    bytesRead;
        UCHAR    resultString[MAX_ID_SIZE];
        ANSI_STRING     AnsiIdString;
        UNICODE_STRING  UnicodeTemp;
        RTL_QUERY_REGISTRY_TABLE paramTable[6];
        UNICODE_STRING Dot3Key;
        USHORT Dot3NameSize;
        NTSTATUS status;
        // BOOLEAN  boolResult;

        RtlZeroMemory(resultString, MAX_ID_SIZE);
        // ask the device how large of a buffer is needed to hold it's raw device id
        if ( Extension->Ieee1284Flags & ( 1 << Extension->Ieee1284_3DeviceId ) ) {
            buffer = Par3QueryDeviceId(Extension, NULL, 0, &bufferLength, FALSE, TRUE);
        }
        else{
            buffer = Par3QueryDeviceId(Extension, NULL, 0, &bufferLength, FALSE, FALSE);
        }
        if( !buffer ) {
            ParDump2(PARERRORS, ("ParDot3Connect: FAIL. Couldn't alloc pool for DevId\n") );
            return STATUS_UNSUCCESSFUL;
        }

        ParDump2(PARDOT3DL, ("ParDot3Connect:\"RAW\" ID string = <%s>\n", buffer) );

        // extract the part of the ID that we want from the raw string 
        //   returned by the hardware
        Status = ParPnpGetId( (PUCHAR)buffer, BusQueryDeviceID, resultString, NULL );
        StringSubst ((PUCHAR) resultString, ' ', '_', (USHORT)strlen(resultString));

        ParDump2(PARDOT3DL, ("ParDot3Connect: resultString Post StringSubst = <%s>\n", resultString) );

        // were we able to extract the info that we want from the raw ID string?
        if( !NT_SUCCESS(Status) ) {
            ParDump2(PARERRORS, ("ParDot3Connect: FAIL. Call to ParPnpGetId Failed\n") );
            return STATUS_UNSUCCESSFUL;
        }

        // Does the ID that we just retrieved from the device match the one 
        //   that we previously saved in the device extension?
        if(0 != strcmp( (const PCHAR)Extension->DeviceIdString, (const PCHAR)resultString)) {
            ParDump2(PARDOT3DL, ("ParDot3Connect: strcmp shows NO MATCH\n") );
            // DVDF - we may want to trigger a reenumeration since we know that the device changed
        }

        // Ok, now we have what we need to look in the registry
        // and pull some prefs.
        RtlZeroMemory(&paramTable[0], sizeof(paramTable));
        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = (PWSTR)L"ParFwdSkip";
        paramTable[0].EntryContext  = &ParFwdSkip;
        paramTable[0].DefaultType   = REG_DWORD;
        paramTable[0].DefaultData   = &ParSkipDefault;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = (PWSTR)L"ParRevSkip";
        paramTable[1].EntryContext  = &ParRevSkip;
        paramTable[1].DefaultType   = REG_DWORD;
        paramTable[1].DefaultData   = &ParSkipDefault;
        paramTable[1].DefaultLength = sizeof(ULONG);

        paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[2].Name          = (PWSTR)L"ParRC";
        paramTable[2].EntryContext  = &ParResetChannel;
        paramTable[2].DefaultType   = REG_DWORD;
        paramTable[2].DefaultData   = &ParResetChannelDefault;
        paramTable[2].DefaultLength = sizeof(ULONG);

        paramTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[3].Name          = (PWSTR)L"ParRBC";
        paramTable[3].EntryContext  = &ParResetByteCount;
        paramTable[3].DefaultType   = REG_DWORD;
        paramTable[3].DefaultData   = &ParResetByteCountDefault;
        paramTable[3].DefaultLength = sizeof(ULONG);

        paramTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[4].Name          = (PWSTR)L"ParRBD";
        paramTable[4].EntryContext  = &ParResetByte;
        paramTable[4].DefaultType   = REG_DWORD;
        paramTable[4].DefaultData   = &ParResetByteDefault;
        paramTable[4].DefaultLength = sizeof(ULONG);

        Dot3Key.Buffer = NULL;
        Dot3Key.Length = 0;
        Dot3NameSize = sizeof(L"Dot3\\") + sizeof(UNICODE_NULL);
        Dot3Key.MaximumLength = (USHORT)( Dot3NameSize + (sizeof(resultString) * sizeof(WCHAR)) );
        Dot3Key.Buffer = ExAllocatePool(PagedPool,
                                            Dot3Key.MaximumLength);
        if (!Dot3Key.Buffer)
        {
            ParDump2(PARERRORS, ("ParDot3Connect: FAIL. ExAllocatePool for Registry Check.\n") );
            return STATUS_UNSUCCESSFUL;
        }

        ParDump2(PARDOT3DL, ("ParDot3Connect: ready to Zero buffer, &Dot3Key= %x , MaximumLength=%d\n",
                             &Dot3Key, Dot3Key.MaximumLength));
        RtlZeroMemory(Dot3Key.Buffer, Dot3Key.MaximumLength);

        status = RtlAppendUnicodeToString(&Dot3Key, (PWSTR)L"Dot3\\");
        ASSERT( NT_SUCCESS(status) );

        ParDump2(PARDOT3DL, ("ParDot3Connect:\"UNICODE\" Dot3Key S  = <%S>\n", Dot3Key.Buffer) );
        ParDump2(PARDOT3DL, ("ParDot3Connect:\"UNICODE\" Dot3Key wZ = <%wZ>\n", &Dot3Key) );
        ParDump2(PARDOT3DL, ("ParDot3Connect:\"RAW\" resultString string = <%s>\n", resultString) );

        RtlInitAnsiString(&AnsiIdString,resultString);

        status = RtlAnsiStringToUnicodeString(&UnicodeTemp,&AnsiIdString,TRUE);
        if( NT_SUCCESS( status ) ) {
            ParDump2(PARDOT3DL, ("ParDot3Connect:\"UNICODE\" UnicodeTemp = <%S>\n", UnicodeTemp.Buffer) );

            Dot3Key.Buffer[(Dot3NameSize / sizeof(WCHAR)) - 1] = UNICODE_NULL;
            ParDump2(PARDOT3DL, ("ParDot3Connect:\"UNICODE\" Dot3Key (preappend)  = <%S>\n", Dot3Key.Buffer) );

            status = RtlAppendUnicodeStringToString(&Dot3Key, &UnicodeTemp);
            if( NT_SUCCESS( status ) ) {
                ParDump2(PARDOT3DL, ("ParDot3Connect: ready to call RtlQuery...\n") );
                Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL, Dot3Key.Buffer, &paramTable[0], NULL, NULL);
                ParDump2(PARINFO, ("ParDot3Connect: RtlQueryRegistryValues Status = %x\n", Status));
            }
            
            RtlFreeUnicodeString(&UnicodeTemp);
        }

        if (Dot3Key.Buffer)
            ExFreePool (Dot3Key.Buffer);
        // no longer needed
        ExFreePool(buffer);
        if (!NT_SUCCESS(Status)) {
            // registry read failed
            ParDump2(PARINFO, ("ParDot3Connect: No Periph Defaults in Registry\n") );
            ParDump2(PARDOT3DL, ("ParDot3Connect: No Periph Defaults in Registry\n") );
            // registry read failed, use defaults and consider EPP to be dangerous
            ParRevSkip = ParFwdSkip = ParSkipDefault;
            bConsiderEppDangerous = TRUE; 
        }

        ParDump2(PARDOT3DL, ("ParDot3Connect: pre IeeeNegotiateBestMode\n") );
        // if we don't have registry overrides then use what the
        // peripheral told us otherwise stick with defaults.
        if (ParSkipDefault == ParRevSkip)
            ParRevSkip = Extension->P12843DL.RevSkipMask;
        else
            Extension->P12843DL.RevSkipMask = (USHORT) ParRevSkip;

        if (ParSkipDefault == ParFwdSkip)
            ParFwdSkip = Extension->P12843DL.FwdSkipMask;
        else
            Extension->P12843DL.FwdSkipMask = (USHORT) ParFwdSkip;

        if( bConsiderEppDangerous ) {
            ParFwdSkip |= EPP_ANY;
            ParRevSkip |= EPP_ANY;
        }

        Status = IeeeNegotiateBestMode(Extension, (USHORT)ParRevSkip, (USHORT)ParFwdSkip);
        if( !NT_SUCCESS(Status) ) {
            ParDump2(PARERRORS, ("ParDot3Connect: FAIL. Peripheral Negotiation Failed\n") );
            return Status;
        }

        Extension->ForwardInterfaceAddress = Extension->P12843DL.DataChannel;
        if (Extension->P12843DL.DataLinkMode == P12843DL_MLC_DL)
        {
            if (ParResetChannel != ParResetChannelDefault)
            {
                Extension->P12843DL.ResetByte  = (UCHAR) ParResetByte & 0xff;
                Extension->P12843DL.ResetByteCount = (UCHAR) ParResetByteCount & 0xff;
                if (ParResetChannel == PAR_COMPATIBILITY_RESET)
                    Extension->P12843DL.fnReset = ParMLCCompatReset;
                else
                {
                    // Max ECP channel is 127 so let's mask off bogus bits.
                    Extension->P12843DL.ResetChannel = (UCHAR) ParResetChannel & 0x7f;
                    Extension->P12843DL.fnReset = ParMLCECPReset;
                }
            }
        }

        if (Extension->P12843DL.fnReset)
        {
            ParDump2(PARDOT3DL, ("ParDot3Connect: MLCReset is supported on %x\n", Extension->P12843DL.ResetChannel) );
            Status = ((PDOT3_RESET_ROUTINE) (Extension->P12843DL.fnReset))(Extension);
        }
        else
        {
            ParDump2(PARDOT3DL, ("ParDot3Connect: MLCReset is not supported\n") );
            Status = ParSetFwdAddress(Extension);
        }
        if( !NT_SUCCESS(Status) ) {
            ParDump2(PARERRORS, ("ParDot3Connect: FAIL. Couldn't Set Address\n") );
            return Status;
        }

        // Check to make sure we are ECP, BECP, or EPP
        ParDump2(PARDOT3DL, ("ParDot3Connect: pre check of ECP, BECP, EPP\n") );

        if (afpForward[Extension->IdxForwardProtocol].ProtocolFamily != FAMILY_BECP &&
            afpForward[Extension->IdxForwardProtocol].ProtocolFamily != FAMILY_ECP &&
            afpForward[Extension->IdxForwardProtocol].ProtocolFamily != FAMILY_EPP)
        {
            ParDump2(PARERRORS, ("ParDot3Connect: FAIL. We did not reach ECP or EPP.\n") );
            return STATUS_UNSUCCESSFUL;
        }
    }

    #if PAR_TEST_HARNESS
        ParHarnessLoad(Extension);
    #endif
    if (Extension->P12843DL.DataLinkMode == P12843DL_DOT3_DL)
    {
        ParDump2(PARDOT3DL, ("ParDot3Connect: P12843DL_DOT3_DL\n") );
        Extension->P12843DL.fnRead  = (PVOID) arpReverse[Extension->IdxReverseProtocol].fnRead;
        Extension->P12843DL.fnWrite = (PVOID) afpForward[Extension->IdxForwardProtocol].fnWrite;
    #if (1 == DVRH_USE_CORRECT_PTRS)
        Extension->fnRead = ParDot3Read;
        Extension->fnWrite = ParDot3Write;
    #else
        arpReverse[Extension->IdxReverseProtocol].fnRead = ParDot3Read;
        afpForward[Extension->IdxForwardProtocol].fnWrite = ParDot3Write;
    #endif
    }

    // DVDF 990504 - removed: Extension->P12843DL.bEventActive = NT_SUCCESS(Status);

    ParDump2(PARDOT3DL, ("ParDot3Connect: Exit %d\n", NT_SUCCESS(Status)) );

    return Status;
}

VOID
ParDot3CreateObject(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR DOT3DL,
    IN PUCHAR DOT3C
    )
{
    Extension->P12843DL.DataLinkMode = P12843DL_OFF;
    Extension->P12843DL.fnReset = NULL;
    ParDump2(PARDUMP_PNP_DL, ("ParDot3CreateObject: DOT3DL [%s] DOT3C\n",
             DOT3DL, DOT3C) );
    if (DOT3DL)
    {
        ULONG   dataChannel;
        ULONG   pid = 0x285; // pid for dot4

        // Only use the first channel.
        if (!String2Num(&DOT3DL, ',', &dataChannel))
        {
            dataChannel = 77;
            ParDump2(PARINFO, ("ParDot3CreateObject: No DataChannel Defined.\r\n"));
        }
        if (DOT3C)
        {
            if (!String2Num(&DOT3C, ',', &pid))
            {
                pid = 0x285;
                ParDump2(PARINFO, ("ParDot3CreateObject: No CurrentPID Defined.\r\n"));
            }
            ParDump2(PARINFO, ("ParDot3CreateObject: .3 mode is ON.\r\n"));
        }
        Extension->P12843DL.DataChannel = (UCHAR)dataChannel;
        Extension->P12843DL.CurrentPID = (USHORT)pid;
        Extension->P12843DL.DataLinkMode = P12843DL_DOT3_DL;
        ParDump2(PARINFO, ("ParDot3CreateObject: Data [%x] CurrentPID [%x]\r\n",
                Extension->P12843DL.DataChannel,
                Extension->P12843DL.CurrentPID));
    }
#if DBG
    if (Extension->P12843DL.DataLinkMode == P12843DL_OFF)
    {
        ParDump2(PARINFO, ("ParDot3CreateObject: DANGER: .3 mode is OFF.\r\n"));
    }
#endif
}

VOID
ParDot4CreateObject(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR DOT4DL
    )
{
    Extension->P12843DL.DataLinkMode = P12843DL_OFF;
    Extension->P12843DL.fnReset = NULL;
    ParDump2(PARDUMP_PNP_DL, ("ParDot3CreateObject: DOT4DL [%s]\n",
             DOT4DL) );
    if (DOT4DL)
    {
        UCHAR numValues = StringCountValues(DOT4DL, ',');
        ULONG dataChannel, resetChannel, ResetByteCount;
        
        ParDump2(PARDUMP_PNP_DL, ("ParDot3CreateObject: numValues [%d]\n",
                 numValues) );
        if (!String2Num(&DOT4DL, ',', &dataChannel))
        {
            dataChannel = 77;
            ParDump2(PARINFO, ("ParDot4CreateObject: No DataChannel Defined.\r\n"));
        }
        if ((String2Num(&DOT4DL, ',', &resetChannel))
            && (numValues > 1))
        {
            if (resetChannel == -1)
            {
                Extension->P12843DL.fnReset = ParMLCCompatReset;
            }
            else
            {
                Extension->P12843DL.fnReset = ParMLCECPReset;
            }
            ParDump2(PARINFO, ("ParDot4CreateObject: ResetChannel Defined.\r\n"));
        }
        else
        {
            Extension->P12843DL.fnReset = NULL;
            ParDump2(PARINFO, ("ParDot4CreateObject: No ResetChannel Defined.\r\n"));
        }
        if ((!String2Num(&DOT4DL, 0, &ResetByteCount))
            && (numValues > 2))
        {
            ResetByteCount = 4;
            ParDump2(PARINFO, ("ParDot4CreateObject: No ResetByteCount Defined.\r\n"));
        }

        Extension->P12843DL.DataChannel = (UCHAR)dataChannel;
        Extension->P12843DL.ResetChannel = (UCHAR)resetChannel;
        Extension->P12843DL.ResetByteCount = (UCHAR)ResetByteCount;
        Extension->P12843DL.DataLinkMode = P12843DL_DOT4_DL;
        ParDump2(PARINFO, ("ParDot4CreateObject: .4DL mode is ON.\r\n"));
        ParDump2(PARINFO, ("ParDot4CreateObject: Data [%x] Reset [%x] Bytes [%x]\r\n",
                Extension->P12843DL.DataChannel,
                Extension->P12843DL.ResetChannel,
                Extension->P12843DL.ResetByteCount));
    }
#if DBG
    if (Extension->P12843DL.DataLinkMode == P12843DL_OFF)
    {
        ParDump2(PARINFO, ("ParDot4CreateObject: DANGER: .4DL mode is OFF.\r\n"));
    }
#endif
}

VOID
ParMLCCreateObject(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR CMDField
    )
{

    // UCHAR         ForwardInterfaceAddress;
    // UCHAR         ReverseInterfaceAddress;

    Extension->P12843DL.DataLinkMode = P12843DL_OFF;
    Extension->P12843DL.fnReset = NULL;
    if (CMDField)
    {
        Extension->P12843DL.DataChannel = 77;

        Extension->P12843DL.DataLinkMode = P12843DL_MLC_DL;
        ParDump2(PARINFO, ("ParMLCCreateObject: MLC mode is on.\r\n"));
    }
#if DBG
    if (Extension->P12843DL.DataLinkMode == P12843DL_OFF)
    {
        ParDump2(PARINFO, ("ParMLCCreateObject: DANGER: MLC mode is OFF.\r\n"));
    }
#endif
}

VOID
ParDot3DestroyObject(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    Extension->P12843DL.DataLinkMode = P12843DL_OFF;
}

NTSTATUS
ParDot3Disconnect(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    #if PAR_TEST_HARNESS
        ParHarnessUnload(Extension);
    #endif
    if (Extension->P12843DL.DataLinkMode == P12843DL_DOT3_DL)
    {
        #if (1 == DVRH_USE_CORRECT_PTRS)
            Extension->fnRead = arpReverse[Extension->IdxReverseProtocol].fnRead;
            Extension->fnWrite = afpForward[Extension->IdxForwardProtocol].fnWrite;
        #else
        arpReverse[Extension->IdxReverseProtocol].fnRead = (PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead;
        afpForward[Extension->IdxForwardProtocol].fnWrite = (PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite;
        #endif
    }

    Extension->P12843DL.bEventActive = FALSE;
    Extension->P12843DL.Event        = 0;

    return STATUS_SUCCESS;
}

VOID
ParDot3ParseModes(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR DOT3M
    )
{
    ULONG   fwd = 0;
    ULONG   rev = 0;
    ParDump2(PARDUMP_PNP_DL, ("ParDot3ParseModes: DOT3M [%s]\n",
             DOT3M) );
    if (DOT3M)
    {
        UCHAR numValues = StringCountValues(DOT3M, ',');

        if (numValues != 2)
        {
            // The periph gave me bad values. I'm not gonna read
            // them. I will set the defaults to the lowest
            // common denominator.
            ParDump2(PARINFO, ("ParDot3ParseModes: Malformed 1284.3M field.\r\n"));
            Extension->P12843DL.FwdSkipMask = (USHORT) PAR_FWD_MODE_SKIP_MASK;
            Extension->P12843DL.RevSkipMask = (USHORT) PAR_REV_MODE_SKIP_MASK;
            return;
        }

        // Only use the first channel.
        if (!String2Num(&DOT3M, ',', &fwd))
        {
            fwd = (USHORT) PAR_FWD_MODE_SKIP_MASK;
            ParDump2(PARINFO, ("ParDot3ParseModes: Couldn't read fwd of 1284.3M.\r\n"));
        }
        if (!String2Num(&DOT3M, ',', &rev))
        {
            rev = (USHORT) PAR_REV_MODE_SKIP_MASK;
            ParDump2(PARINFO, ("ParDot3ParseModes: Couldn't read rev of 1284.3M.\r\n"));
        }
    }
    Extension->P12843DL.FwdSkipMask = (USHORT) fwd;
    Extension->P12843DL.RevSkipMask = (USHORT) rev;
}

NTSTATUS
ParDot3Read(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS Status;
    UCHAR ucScrap1;
    UCHAR ucScrap2[2];
    USHORT usScrap1;
    ULONG bytesToRead;
    ULONG bytesTransferred;
    USHORT Dot3CheckSum;
    USHORT Dot3DataLen;

    // ================================== Read the first byte of SOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead)(Extension, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the first byte of SOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_StartOfFrame1)
    {
        ParDump2(PARERRORS, ("ParDot3Read: Header Read Failed.  We're Hosed!\n"));
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the second byte of SOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead)(Extension, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the second byte of SOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_StartOfFrame2)
    {
        ParDump2(PARERRORS, ("ParDot3Read: Header Read Failed.  We're Hosed!\n"));
        *BytesTransferred = 0;
        return(Status);
    }
    
    // ================================== Read the PID (Should be in Big Endian)
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead)(Extension, &usScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the PID
    if (!NT_SUCCESS(Status) || usScrap1 != Extension->P12843DL.CurrentPID)
    {
        ParDump2(PARERRORS, ("ParDot3Read: Header Read Failed.  We're Hosed!\n"));
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the DataLen
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead)(Extension, &ucScrap2[0], bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    Dot3DataLen = (USHORT)((USHORT)(ucScrap2[0]<<8 | ucScrap2[1]) + 1);
    // ================================== Check the DataLen
    if (!NT_SUCCESS(Status))
    {
        ParDump2(PARERRORS, ("ParDot3Read: Header Read Failed.  We're Hosed!\n"));
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the Checksum
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead)(Extension, &ucScrap2[0], bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    Dot3CheckSum = (USHORT)(ucScrap2[0]<<8 | ucScrap2[1]);
    // ================================== Check the DataLen
    if (!NT_SUCCESS(Status))
    {
        ParDump2(PARERRORS, ("ParDot3Read: Header Read Failed.  We're Hosed!\n"));
        *BytesTransferred = 0;
        return(Status);
    }

    Status = ((PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead)(Extension, Buffer, BufferSize, BytesTransferred);

    if (!NT_SUCCESS(Status))
    {
        ParDump2(PARERRORS, ("ParDot3Read: Data Read Failed.  We're Hosed!\n"));
        return(Status);
    }

    // BUG BUG....  What do I do if the buffer < data

    if ((ULONG)Dot3DataLen > BufferSize)
    {
        // buffer overflow - abort operation
        ParDump2(PARERRORS, ("ParDot3Read: Bad 1284.3DL Data Len. Buffer overflow.  We're Hosed!\n"));
        return  STATUS_BUFFER_OVERFLOW;
    }

    // Check Checksum
    if (~((~Extension->P12843DL.CurrentPID)+ (~(BufferSize - 1))) != Dot3CheckSum)
    {
        ParDump2(PARERRORS, ("ParDot3Read: Bad 1284.3DL Checksum.  We're Hosed!\n"));
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    // ================================== Read the first byte of EOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead)(Extension, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the first byte of EOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_EndOfFrame1)
    {
        ParDump2(PARERRORS, ("ParDot3Read: Header Read Failed.  We're Hosed!\n"));
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the second byte of EOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Extension->P12843DL.fnRead)(Extension, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the second byte of EOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_EndOfFrame2)
    {
        ParDump2(PARERRORS, ("ParDot3Read: Header Read Failed.  We're Hosed!\n"));
        *BytesTransferred = 0;
        return(Status);
    }
    return Status;
}

NTSTATUS
ParDot3Write(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS    Status;
    ULONG       frameBytesTransferred;
    ULONG       bytesToWrite;
    USHORT      scrap1;
    USHORT      scrap2;
    USHORT      scrapHigh;
    USHORT      scrapLow;
    PUCHAR      p;

    // =========================  Write out first Byte of SOF
    bytesToWrite = 1;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite)(Extension, &Dot3_StartOfFrame1, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check first Byte of SOF
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out second Byte of SOF
    bytesToWrite = 1;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite)(Extension, &Dot3_StartOfFrame2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check second Byte of SOF
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out PID (which should be in Big Endian already)
    bytesToWrite = 2;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite)(Extension, &Extension->P12843DL.CurrentPID, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check PID
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out Length of Data
    bytesToWrite = 2;
    frameBytesTransferred = 0;
    scrap1 = (USHORT) (BufferSize - 1);
    scrapLow = (UCHAR) (scrap1 && 0xff);
    scrapHigh = (UCHAR) (scrap1 >> 8);
    p = (PUCHAR)&scrap2;
    *p++ = (UCHAR)scrapHigh;
    *p = (UCHAR)scrapLow;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite)(Extension, &scrap2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check Length of Data
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out Checksum
    bytesToWrite = 2;
    frameBytesTransferred = 0;
    scrap1=~((USHORT)(~Extension->P12843DL.CurrentPID)+ (~((USHORT)BufferSize - 1)));
    scrapLow = (UCHAR) (scrap1 && 0xff);
    scrapHigh = (UCHAR) (scrap1 >> 8);
    p = (PUCHAR)&scrap2;
    *p++ = (UCHAR)scrapHigh;
    *p = (UCHAR)scrapLow;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite)(Extension, &scrap2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check Checksum
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    Status = ((PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite)(Extension, Buffer, BufferSize, BytesTransferred);
    if (NT_SUCCESS(Status))
    {
        // =========================  Write out first Byte of EOF
        bytesToWrite = 1;
        frameBytesTransferred = 0;
        do
        {
            Status = ((PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite)(Extension, &Dot3_EndOfFrame1, bytesToWrite, &frameBytesTransferred);
        }
        while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

        // =========================  Check first Byte of EOF
        if (!NT_SUCCESS(Status))
        {
            *BytesTransferred = 0;
            return(Status);
        }

        // =========================  Write out second Byte of EOF
        bytesToWrite = 1;
        frameBytesTransferred = 0;
        do
        {
            Status = ((PPROTOCOL_WRITE_ROUTINE) Extension->P12843DL.fnWrite)(Extension, &Dot3_EndOfFrame2, bytesToWrite, &frameBytesTransferred);
        }
        while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

        // =========================  Check second Byte of EOF
        if (!NT_SUCCESS(Status))
        {
            *BytesTransferred = 0;
            return(Status);
        }
    }
    return Status;
}

NTSTATUS
ParMLCCompatReset(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR Reset[256];       // Reset should not require more than 256 chars
    const ULONG ResetLen = Extension->P12843DL.ResetByteCount;
    ULONG BytesWritten; 

    ParDump2( PARENTRY, ("ParMLCCompatReset: Start\n"));
    if (Extension->P12843DL.DataLinkMode != P12843DL_MLC_DL &&
        Extension->P12843DL.DataLinkMode != P12843DL_DOT4_DL)
    {
        ParDump2(PARINFO, ("ParMLCCompatReset: not MLC.\n") );
        return STATUS_SUCCESS;
    }

    ParTerminate(Extension);
    // Sending  NULLs for reset
    ParDump2(PARINFO, ("ParMLCCompatReset: Zeroing Reset Bytes.\n") );
    RtlFillMemory(Reset, ResetLen, Extension->P12843DL.ResetByte);

    ParDump2(PARINFO, ("ParMLCCompatReset: Sending Reset Bytes.\n") );
    // Don't use the Dot3Write since we are in MLC Mode.
    Status = SppWrite(Extension, Reset, ResetLen, &BytesWritten);
    if (!NT_SUCCESS(Status) || BytesWritten != ResetLen)
    {
        ParDump2(PARERRORS, ("ParMLCCompatReset: FAIL. Write Failed\n") );
        return Status;
    }

    ParDump2(PARINFO, ("ParMLCCompatReset: Reset Bytes were sent.\n") );
    return Status;
}

NTSTATUS
ParMLCECPReset(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR Reset[256];       // Reset should not require more than 256 chars
    const ULONG ResetLen = Extension->P12843DL.ResetByteCount;
    ULONG BytesWritten; 

    ParDump2( PARENTRY, ("ParMLCECPReset: Start\n"));
    if (Extension->P12843DL.DataLinkMode != P12843DL_MLC_DL &&
        Extension->P12843DL.DataLinkMode != P12843DL_DOT4_DL)
    {
        ParDump2(PARINFO, ("ParMLCECPReset: not MLC.\n") );
        return STATUS_SUCCESS;
    }

    Status = ParReverseToForward(Extension);
    Extension->ForwardInterfaceAddress = Extension->P12843DL.ResetChannel;
    Status = ParSetFwdAddress(Extension);
    if (!NT_SUCCESS(Status))
    {
        ParDump2(PARERRORS, ("ParMLCECPReset: FAIL. Couldn't Set Reset Channel\n") );
        return Status;
    }

    // Sending  NULLs for reset
    ParDump2(PARINFO, ("ParMLCECPReset: Zeroing Reset Bytes.\n") );
    RtlFillMemory(Reset, ResetLen, Extension->P12843DL.ResetByte);
    ParDump2(PARINFO, ("ParMLCECPReset: Sending Reset Bytes.\n") );
    // Don't use the Dot3Write since we are in MLC Mode.
    Status = afpForward[Extension->IdxForwardProtocol].fnWrite(Extension, Reset, ResetLen, &BytesWritten);
    if (!NT_SUCCESS(Status) || BytesWritten != ResetLen)
    {
        ParDump2(PARERRORS, ("ParMLCECPReset: FAIL. Write Failed\n") );
        return Status;
    }

    ParDump2(PARINFO, ("ParMLCECPReset: Reset Bytes were sent.\n") );
    Extension->ForwardInterfaceAddress = Extension->P12843DL.DataChannel;
    Status = ParSetFwdAddress(Extension);
    if (!NT_SUCCESS(Status))
    {
        ParDump2(PARERRORS, ("ParMLCECPReset: FAIL. Couldn't Set Data Channel\n") );
        return Status;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\log.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       log.h
//
//--------------------------------------------------------------------------

#ifndef _LOG_
#define _LOG_
typedef struct _LOG_INFO {
    ULONG Flags1;
    ULONG Flags2;
    ULONG reserved[2];

    LONGLONG SppWriteCount;
    LONGLONG NibbleReadCount;

    LONGLONG BoundedEcpWriteCount;
    LONGLONG BoundedEcpReadCount;

    LONGLONG HwEcpWriteCount;
    LONGLONG HwEcpReadCount;

    LONGLONG SwEcpWriteCount;
    LONGLONG SwEcpReadCount;

    LONGLONG HwEppWriteCount;
    LONGLONG HwEppReadCount;

    LONGLONG SwEppWriteCount;
    LONGLONG SwEppReadCount;

    LONGLONG ByteReadCount;
    LONGLONG ChannelNibbleReadCount;

} LOG_INFO, *PLOG_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\openclos.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       openclos.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with Create/Open, Cleanup, and Close
//

#include "pch.h"
#include "ecp.h"

NTSTATUS
ParCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a create requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.
    !STATUS_SUCCESS - Failure.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;
    USHORT              i;

    ParDump2(PAROPENCLOSE, ("openclose::ParCreateOpen - IRP_MJ_CREATE - Enter\n") );

    Extension = DeviceObject->DeviceExtension;

    Irp->IoStatus.Information = 0;

    ExAcquireFastMutex(&Extension->OpenCloseMutex);

    //
    // bail out if a delete is pending for this device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_DELETE_PENDING) {
        ExReleaseFastMutex(&Extension->OpenCloseMutex); 
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }


    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        ExReleaseFastMutex(&Extension->OpenCloseMutex); 
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }


    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PAR_DEVICE_REMOVED|PAR_DEVICE_SURPRISE_REMOVAL) ) {
        ExReleaseFastMutex(&Extension->OpenCloseMutex); 
        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

    //
    // fail IRP if no hardware under this device
    //
 
    if (!Extension->PortDeviceObject) {
        ParDump2(PAROPENCLOSE, ("NULL PortDeviceObject pointer - FAIL IRP - This is the FDO!!!\n") );
        ExReleaseFastMutex(&Extension->OpenCloseMutex); 
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // this is an exclusive access device - fail IRP if we are already open
    if (InterlockedIncrement(&Extension->OpenCloseRefCount) != 1) {
        ParDump2(PAROPENCLOSE, ("ParCreateOpen - Device Already Open - Fail request\n") );
        ExReleaseFastMutex(&Extension->OpenCloseMutex);
        InterlockedDecrement(&Extension->OpenCloseRefCount);
        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_ACCESS_DENIED;
    }

    ExReleaseFastMutex(&Extension->OpenCloseMutex);

    //
    // Lock in code.
    //
    ParClaimDriver();

    //
    // Lock in the port driver.
    //

    // RMT - what if this fails?
    ParGetPortInfoFromPortDevice(Extension);

    //
    // Set the default ieee1284 modes
    //
    ParInitializeExtension1284Info( Extension );

    ExInitializeFastMutex (&Extension->LockPortMutex);    

    KeInitializeEvent(&Extension->PauseEvent, NotificationEvent, TRUE);

    Extension->TimeToTerminateThread = FALSE;

    // assert that we do not already have a thread
    ASSERT(!Extension->ThreadObjectPointer);
    // - replaced following by above assertion: Extension->ThreadObjectPointer = NULL;

    KeInitializeSemaphore(&Extension->RequestSemaphore, 0, MAXLONG);

    if (IoGetCurrentIrpStackLocation(Irp)->Parameters.Create.Options & FILE_DIRECTORY_FILE) {
        Status = Irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;

    } else {
        Status = Irp->IoStatus.Status = ParCreateSystemThread(Extension);
    }

    ParDump2(PAROPENCLOSE, ("About to complete IRP in create/open - Irp: %x status: %x Information: %x\n",
                            Irp, Irp->IoStatus.Status, Irp->IoStatus.Information) );

    if (!NT_SUCCESS(Status)) {
        // open failed
        ULONG openCloseCount = InterlockedDecrement(&Extension->OpenCloseRefCount);
        ASSERT(0 == openCloseCount);
    }
        
    ParCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

NTSTATUS
ParCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a cleanup requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    PDEVICE_EXTENSION   Extension;
    KIRQL               CancelIrql;
    PDRIVER_CANCEL      CancelRoutine;
    PIRP                CurrentLastIrp;

    ParDump2(PAROPENCLOSE, ("In ParCleanup\n") );

    Extension = DeviceObject->DeviceExtension;


    //
    // While the list is not empty, go through and cancel each irp.
    //

    IoAcquireCancelSpinLock(&CancelIrql);

    //
    // Clean the list from back to front.
    //

    while (!IsListEmpty(&Extension->WorkQueue)) {

        CurrentLastIrp = CONTAINING_RECORD(Extension->WorkQueue.Blink,
                                           IRP, Tail.Overlay.ListEntry);

        RemoveEntryList(Extension->WorkQueue.Blink);

        CancelRoutine = CurrentLastIrp->CancelRoutine;
        CurrentLastIrp->CancelIrql    = CancelIrql;
        CurrentLastIrp->CancelRoutine = NULL;
        CurrentLastIrp->Cancel        = TRUE;

        CancelRoutine(DeviceObject, CurrentLastIrp);

        IoAcquireCancelSpinLock(&CancelIrql);
    }

    //
    // If there is a current irp then mark it as cancelled.
    //

    if (Extension->CurrentOpIrp) {
        Extension->CurrentOpIrp->Cancel = TRUE;
    }

    IoReleaseCancelSpinLock(CancelIrql);

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

//     ParDump(PARIRPPATH | PARDUMP_VERBOSE_MAX,
//             ("PARALLEL: "
//              "About to complete IRP in cleanup - "
//              "Irp: %x status: %x Information: %x\n",
//              Irp, Irp->IoStatus.Status, Irp->IoStatus.Information) );

    ParCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
ParClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a close requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    PDEVICE_EXTENSION   Extension;
    // NTSTATUS            StatusOfWait;

    ParDump2(PAROPENCLOSE, ( "ParClose(...)\n") );

    Extension = DeviceObject->DeviceExtension;

    // immediately stop signalling event
    Extension->P12843DL.bEventActive = FALSE;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    if (Extension->bShadowBuffer)
    {
        Queue_Delete(&(Extension->ShadowBuffer));
        Extension->bShadowBuffer = FALSE;
    }

    // if we still have a worker thread, kill it
    if(Extension->ThreadObjectPointer) {

        // set the flag for the worker thread to kill itself
        Extension->TimeToTerminateThread = TRUE;
        
        // wake up the thread so it can kill itself
        KeReleaseSemaphore(&Extension->RequestSemaphore, 0, 1, FALSE);
        
        // allow thread to get past PauseEvent so it can kill self
        KeSetEvent(&Extension->PauseEvent, 0, TRUE);

        // wait for the thread to die
        KeWaitForSingleObject(Extension->ThreadObjectPointer, UserRequest, KernelMode, FALSE, NULL);
        
        // allow the system to release the thread object
        ObDereferenceObject(Extension->ThreadObjectPointer);
        
        // note that we no longer have a worker thread
        Extension->ThreadObjectPointer = NULL;
    }

    // release our hold on ParPort, possibly allowing ParPort to be paged
    ParReleasePortInfoToPortDevice(Extension);

    ParCompleteRequest(Irp, IO_NO_INCREMENT);


    // RMT - is underflow possible?
    {
        ULONG openCloseRefCount;
        ExAcquireFastMutex(&Extension->OpenCloseMutex);
        openCloseRefCount = InterlockedDecrement(&Extension->OpenCloseRefCount);
        ASSERT(0 == openCloseRefCount);
        if(openCloseRefCount != 0) {
            // if we underflowed, increment and check again
            openCloseRefCount = InterlockedIncrement(&Extension->OpenCloseRefCount);
            ASSERT(0 == openCloseRefCount);
        }
        ExReleaseFastMutex(&Extension->OpenCloseMutex);
    }

    // Unlock the code that was locked during the open.
    ParReleaseDriver();

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\par12843.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       par12843.c
//
//--------------------------------------------------------------------------

//
// This file contains functions to select and deselect 1284.3 daisy chain devices
//

#include "pch.h"

BOOLEAN
ParSelectDevice(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             HavePort
    )

/*++

Routine Description:

    This routine acquires the ParPort and selects a 1284.3 device

Arguments:

    Extension   - Supplies the device extension.

    HavePort    - TRUE  indicates that caller has already acquired port
                    so we should only do a SELECT_DEVICE
                - FALSE indicates that caller has not already acquired port
                    so we should do a combination ACQUIRE_PORT/SELECT_DEVICE

Return Value:

    TRUE    - success - the device was selected (and port acquired if needed)
    FALSE   - failure

--*/
{
    NTSTATUS                    status;
    PDEVICE_OBJECT              pPortDeviceObject;
    PARALLEL_1284_COMMAND       par1284Command;
    LARGE_INTEGER               timeOut;

    // ParDumpP( ("par12843::ParSelectDevice - Enter\n") );


    //
    // Initialize command structure and extract parameters from the DeviceExtension
    //
    par1284Command.ID           = (UCHAR)Extension->Ieee1284_3DeviceId;
    par1284Command.Port         = 0; // reserved - 0 for now

    if( HavePort ) {
        par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    } else {
        par1284Command.CommandFlags = 0;
    }

    if(Extension->EndOfChain) {
        // this is NOT a daisy chain device - flag ParPort that
        //   the ID field of the command should be ignored
        par1284Command.CommandFlags |= PAR_END_OF_CHAIN_DEVICE;
    }

    pPortDeviceObject = Extension->PortDeviceObject;


    //
    // Send the request
    //
    timeOut.QuadPart = -(10*1000*500); // 500ms ( 100ns units )

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_SELECT_DEVICE,
                                       pPortDeviceObject,
                                       &par1284Command, sizeof(PARALLEL_1284_COMMAND),
                                       NULL, 0,
                                       &timeOut);

    if( NT_SUCCESS( status ) ) {
        // SELECT succeeded
        ParDump2(PARSELECTDESELECT, ("par12843::ParSelectDevice - SUCCESS\n") );
        if( !HavePort ) {
            // note in the device extension that we have the port
            Extension->bAllocated = TRUE;
        }
        return TRUE;
    } else {
        // SELECT failed
        ParDump2(PARSELECTDESELECT, ("par12843::ParSelectDevice - FAIL\n") );
        return FALSE;
    }
}

BOOLEAN
ParDeselectDevice(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             KeepPort
    )
/*++

Routine Description:

    This routine deselects a 1284.3 device and releases the ParPort

Arguments:

    Extension   - Supplies the device extension.

    KeepPort    - TRUE  indicates that we should keep the port acquired,
                    so we should only do a DESELECT_DEVICE
                - FALSE indicates that we should not keep the port acquired,
                    so we should do a combination DESELECT_DEVICE/FREE_PORT

Return Value:

    TRUE    - The device was deselected (and the port released if requested)
    FALSE   - Failure

--*/
{
    NTSTATUS                    status;
    PDEVICE_OBJECT              pPortDeviceObject;
    PARALLEL_1284_COMMAND       par1284Command;

    // ParDumpP( ("par12843::ParDeselectDevice - Enter\n") );

    //
    // If we don't have the port, succeed and return
    //
    if( !Extension->bAllocated ) {
        ParDump2(PARSELECTDESELECT, ("par12843::ParDeselectDevice: we do not have the port, returning TRUE/SUCCESS\n") );
        return TRUE;
    }

    //
    // Initialize command structure and extract parameters from the DeviceExtension
    //
    par1284Command.ID           = (UCHAR)Extension->Ieee1284_3DeviceId;
    par1284Command.Port         = 0; // reserved - 0 for now

    if( KeepPort ) {
        par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    } else {
        par1284Command.CommandFlags = 0;
    }

    if(Extension->EndOfChain) {
        // this is NOT a daisy chain device - flag ParPort that
        //   the ID field of the command should be ignored
        par1284Command.CommandFlags |= PAR_END_OF_CHAIN_DEVICE;
    }

    pPortDeviceObject = Extension->PortDeviceObject;


    //
    // Send the request
    //
    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_DESELECT_DEVICE,
                                       pPortDeviceObject,
                                       &par1284Command, sizeof(PARALLEL_1284_COMMAND),
                                       NULL, 0,
                                       NULL);

    if( NT_SUCCESS( status ) ) {
        // DESELECT succeeded
        if( !KeepPort ) {
            // note in the device extension that we gave up the port
            ParDump2(PARSELECTDESELECT, ("par12843::ParDeselectDevice - SUCCESS - giving up Port\n") );
            Extension->bAllocated = FALSE;
        } else {
            ParDump2(PARSELECTDESELECT, ("par12843::ParDeselectDevice - SUCCESS - keeping Port\n") );
        }
        return TRUE;
    } else {
        // DESELECT failed
        ParDump2(PARSELECTDESELECT, ("par12843::ParDeselectDevice - FAILED - status=%x\n", status) );
        ASSERTMSG("DESELECT FAILED??? - this should never happen", FALSE );
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\parloop.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    parloop.c

Abstract:

    This module contains the processor independant version of the
    write loop for the parallel driver.

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

ULONG
SppWriteLoop(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite
    )

/*++

Routine Description:

    This routine outputs the given write buffer to the parallel port
    using the standard centronics protocol.

Arguments:

    Controller  - Supplies the base address of the parallel port.

    WriteBuffer - Supplies the buffer to write to the port.

    NumBytesToWrite - Supplies the number of bytes to write out to the port.

Return Value:

    The number of bytes successfully written out to the parallel port.

Notes:

    This routine runs at DISPATCH_LEVEL.

--*/

{
    return(SppWriteLoopPI(Controller, WriteBuffer, NumBytesToWrite, 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\parharns.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    parharns.h

Abstract:

    This module contains 1284.3 Test Harness goodies.

Author:

    Robbie Harris (Hewlett-Packard) 20-October-1998

Environment:

    Kernel mode

Revision History :

--*/
#ifndef _PARHARNS_
#define _PARHARNS_

    #if PAR_TEST_HARNESS

        NTSTATUS
        ParHarnessLoad(
            IN  PDEVICE_EXTENSION   Extension
            );

        NTSTATUS
        ParHarnessEnterForwardPhase(
            IN  PDEVICE_EXTENSION   Extension
            );

        NTSTATUS
        ParHarnessExitForwardPhase(
            IN  PDEVICE_EXTENSION   Extension
            );

        NTSTATUS
        ParHarnessEnterReversePhase(
            IN  PDEVICE_EXTENSION   Extension
            );

        NTSTATUS
        ParHarnessExitReversePhase(
            IN  PDEVICE_EXTENSION   Extension
            );

        BOOLEAN
        ParHarnessHaveReadData (
            IN  PDEVICE_EXTENSION   Extension
            );

        NTSTATUS
        ParHarnessRead(
            IN  PDEVICE_EXTENSION   Extension,
            IN  PVOID               Buffer,
            IN  ULONG               BufferSize,
            OUT PULONG              BytesTransferred
            );

        NTSTATUS
        ParHarnessSetAddress(
            IN  PDEVICE_EXTENSION   Extension,
            IN  UCHAR               Address
            );

        NTSTATUS
        ParHarnessWrite(
            IN  PDEVICE_EXTENSION   Extension,
            IN  PVOID               Buffer,
            IN  ULONG               BufferSize,
            OUT PULONG              BytesTransferred
            );

        NTSTATUS
        ParHarnessUnload(
            IN  PDEVICE_EXTENSION   Extension
            );

    #endif // PAR_TEST_HARNESS
#endif // _PARHARNS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\parharns.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    parharns.c

Abstract:

    This module contains code for test harness useage.

Author:

    Robbie Harris (Hewlett-Packard) 15-October-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
// NOTE: PAR_TEST_HARNESS must be below pch.h

ULONG devHarness1; // dummy - so this file is not an empty translation unit if !PAR_TEST_HARNESS

#if PAR_TEST_HARNESS
#include "parharns.h"
#include "bucket.h"

NTSTATUS
ParHarnessLoad(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    NTSTATUS status;

    RtlInitUnicodeString (&(Extension->ParTestHarness.deviceName),
                            BUCKET_DEVICE_NAME);

    status = IoGetDeviceObjectPointer (
                        &(Extension->ParTestHarness.deviceName),
                        FILE_ALL_ACCESS,
                        &(Extension->ParTestHarness.file),
                        &(Extension->ParTestHarness.device));
    if (NT_SUCCESS(status))
    {
        Extension->ParTestHarness.fnRead = (PVOID) arpReverse[Extension->IdxReverseProtocol].fnRead;
        Extension->ParTestHarness.fnRevSetInterfaceAddress = (PVOID) arpReverse[Extension->IdxReverseProtocol].fnSetInterfaceAddress;
        Extension->ParTestHarness.fnEnterReverse = (PVOID) arpReverse[Extension->IdxReverseProtocol].fnEnterReverse;
        Extension->ParTestHarness.fnExitReverse = (PVOID) arpReverse[Extension->IdxReverseProtocol].fnExitReverse;
        Extension->ParTestHarness.fnReadShadow = (PVOID) arpReverse[Extension->IdxReverseProtocol].fnReadShadow;
        Extension->ParTestHarness.fnHaveReadData = (PVOID) arpReverse[Extension->IdxReverseProtocol].fnHaveReadData;

        Extension->ParTestHarness.fnWrite = (PVOID) afpForward[Extension->IdxForwardProtocol].fnWrite;
        Extension->ParTestHarness.fnFwdSetInterfaceAddress = (PVOID) afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress;
        Extension->ParTestHarness.fnEnterForward = (PVOID) afpForward[Extension->IdxForwardProtocol].fnEnterForward;
        Extension->ParTestHarness.fnExitForward = (PVOID) afpForward[Extension->IdxForwardProtocol].fnExitForward;

        arpReverse[Extension->IdxReverseProtocol].fnRead = ParHarnessRead;
        arpReverse[Extension->IdxReverseProtocol].fnSetInterfaceAddress = ParHarnessSetAddress;
        arpReverse[Extension->IdxReverseProtocol].fnEnterReverse = ParHarnessEnterReversePhase;
        arpReverse[Extension->IdxReverseProtocol].fnExitReverse = ParHarnessExitReversePhase;
        arpReverse[Extension->IdxReverseProtocol].fnReadShadow = NULL;
        arpReverse[Extension->IdxReverseProtocol].fnHaveReadData = ParHarnessHaveReadData;

        afpForward[Extension->IdxForwardProtocol].fnWrite = ParHarnessWrite;
        afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress = ParHarnessSetAddress;
        afpForward[Extension->IdxForwardProtocol].fnEnterForward = ParHarnessEnterForwardPhase;
        afpForward[Extension->IdxForwardProtocol].fnExitForward = ParHarnessExitForwardPhase;
    }

    return status;
}

NTSTATUS
ParHarnessEnterForwardPhase(
    IN  PDEVICE_EXTENSION   Extension
    )
{
	Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    return STATUS_SUCCESS;
}

NTSTATUS
ParHarnessExitForwardPhase(
    IN  PDEVICE_EXTENSION   Extension
    )
{
	Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    return STATUS_SUCCESS;
}

NTSTATUS
ParHarnessEnterReversePhase(
    IN  PDEVICE_EXTENSION   Extension
    )
{
	Extension->CurrentPhase = PHASE_REVERSE_IDLE;
    return STATUS_SUCCESS;
}

NTSTATUS
ParHarnessExitReversePhase(
    IN  PDEVICE_EXTENSION   Extension
    )
{
	Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    return STATUS_SUCCESS;
}

BOOLEAN
ParHarnessHaveReadData (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    IO_STATUS_BLOCK iosbStatus;
    PIRP pIrp;
    KEVENT Event;
    char Buffer;
    NTSTATUS status;

    pIrp = IoBuildDeviceIoControlRequest(IOCTL_BUCKET_CLIENT_READ_PEEK,
                                            Extension->ParTestHarness.device,
                                            &Buffer,
                                            1,
                                            NULL,
                                            0,
                                            FALSE,
                                            &Event,
                                            &iosbStatus);

    status = IoCallDriver(Extension->ParTestHarness.device, pIrp);
    // Do we want to wait for the Irp to complete?
    return (BOOLEAN) (iosbStatus.Information > 0);
}

NTSTATUS
ParHarnessRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK iosbStatus;
    PIRP pIrp;
    KEVENT Event;

    *BytesTransferred = 0;
    pIrp = IoBuildDeviceIoControlRequest(IOCTL_BUCKET_CLIENT_READ,
                                            Extension->ParTestHarness.device,
                                            NULL,
                                            0,
                                            Buffer,
                                            BufferSize,
                                            FALSE,
                                            &Event,
                                            &iosbStatus);

    status = IoCallDriver(Extension->ParTestHarness.device, pIrp);
    // Do we want to wait for the Irp to complete?
    if (NT_SUCCESS(status))
    {
        *BytesTransferred = iosbStatus.Information;
        status = iosbStatus.Status; 
    }
    return status;
}

NTSTATUS
ParHarnessSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    // Dunno what to do?
    return Status;
}

NTSTATUS
ParHarnessWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK iosbStatus;
    PIRP pIrp;
    KEVENT Event;

    *BytesTransferred = 0;
    pIrp = IoBuildDeviceIoControlRequest(IOCTL_BUCKET_CLIENT_WRITE,
                                            Extension->ParTestHarness.device,
                                            Buffer,
                                            BufferSize,
                                            NULL,
                                            0,
                                            FALSE,
                                            &Event,
                                            &iosbStatus);

    status = IoCallDriver(Extension->ParTestHarness.device, pIrp);
    // Do we want to wait for the Irp to complete?
    if (NT_SUCCESS(status))
    {
        *BytesTransferred = iosbStatus.Information;
        status = iosbStatus.Status; 
    }
    return status;
}

NTSTATUS
ParHarnessUnload(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    ObDereferenceObject(Extension->ParTestHarness.file);
    if (NT_SUCCESS(status))
    {
        arpReverse[Extension->IdxReverseProtocol].fnRead = Extension->ParTestHarness.fnRead;
        arpReverse[Extension->IdxReverseProtocol].fnSetInterfaceAddress = Extension->ParTestHarness.fnRevSetInterfaceAddress;
        arpReverse[Extension->IdxReverseProtocol].fnEnterReverse = Extension->ParTestHarness.fnEnterReverse;
        arpReverse[Extension->IdxReverseProtocol].fnExitReverse = Extension->ParTestHarness.fnExitReverse;
        arpReverse[Extension->IdxReverseProtocol].fnReadShadow = Extension->ParTestHarness.fnReadShadow;
        arpReverse[Extension->IdxReverseProtocol].fnHaveReadData = Extension->ParTestHarness.fnHaveReadData;

        afpForward[Extension->IdxForwardProtocol].fnWrite = Extension->ParTestHarness.fnWrite;
        afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress = Extension->ParTestHarness.fnFwdSetInterfaceAddress;
        afpForward[Extension->IdxForwardProtocol].fnEnterForward = Extension->ParTestHarness.fnEnterForward;
        afpForward[Extension->IdxForwardProtocol].fnExitForward = Extension->ParTestHarness.fnExitForward;
    }
    return status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\parclass.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    parclass.c

Abstract:

    This module contains the code for the parallel class driver.

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

    Timothy T. Wells (v-timtw)      13-Mar-97

    Pretty serious overhaul to this and other files on this project to support additional modes
    (EPP, ECP and others), as well as some new filter driver interfaces.

--*/

#include "pch.h"

#include <initguid.h>
#include <ntddpar.h>
#include <wdmguid.h>

#if DBG

//
// Initialize both debug variables even though both will be set 
//   based on registry values in function ParInitDebugLevel(...) 
//   during DriverEntry(...)
//

// How verbose do we want parallel.sys to be with DbgPrint messages?
// ULONG ParDebugLevel  = PARDUMP_VERBOSE_MAX;
ULONG ParDebugLevel  = PARDUMP_VERBOSE_MAX;

// What conditions do we want to break on?
// ULONG ParBreakOn     = PAR_BREAK_ON_NOTHING;
ULONG ParBreakOn     = PAR_BREAK_ON_NOTHING;

ULONG ParUseAsserts  = 0;

#endif // DBG


// enable scans for Legacy Zip?
ULONG ParEnableLegacyZip   = 0;
PCHAR ParLegacyZipPseudoId = PAR_LGZIP_PSEUDO_1284_ID_STRING;

ULONG DumpDevExtTable = 0; // want to default to zero in non-debugging environment

ULONG SppNoRaiseIrql = 0;
ULONG DefaultModes   = 0;

ULONG gSppLoopDelay         = 0;
ULONG gSppLoopBytesPerDelay = 0; 

//
// Temporary Development Globals - used as switches in debug code
//
ULONG tdev1 = 1;
ULONG tdev2 = 0;

extern const PHYSICAL_ADDRESS PhysicalZero = {0};

//
// Definition of OpenCloseMutex. RMT DO WE NEED THIS ???
//
extern ULONG OpenCloseReferenceCount = 1;
extern PFAST_MUTEX OpenCloseMutex = NULL;

//
// Declarations only (Definition in Ieee1284.c)
//
extern FORWARD_PTCL    afpForward[];
extern REVERSE_PTCL    arpReverse[];


UCHAR
ParInitializeDevice(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine is invoked to initialize the parallel port drive.
    It performs the following actions:

        o   Send INIT to the driver and if the device is online.

Arguments:

    Context - Really the device extension.

Return Value:

    The last value that we got from the status register.

--*/

{

    KIRQL               OldIrql;
    UCHAR               DeviceStatus = 0;
    LARGE_INTEGER       StartOfSpin = {0,0};
    LARGE_INTEGER       NextQuery   = {0,0};
    LARGE_INTEGER       Difference  = {0,0};

    ParDump2(PARENTRY, ("Enter ParInitializeDevice(...)\n") );

    //
    // Tim Wells (WestTek, L.L.C.)
    //
    // -  Removed the deferred initialization code from DriverEntry, device creation
    // code.  This code will be better utilized in the Create/Open logic or from
    // the calling application.
    //
    // -  Changed this code to always reset when asked, and to return after a fixed
    // interval reqardless of the response.  Additional responses can be provided by
    // read and write code.
    //

    //
    // Clear the register.
    //

    if (GetControl(Extension->Controller) & PAR_CONTROL_NOT_INIT) {

        //
        // We should stall for at least 60 microseconds after the init.
        //

        KeRaiseIrql( DISPATCH_LEVEL, &OldIrql );

        StoreControl( Extension->Controller, (UCHAR)(PAR_CONTROL_WR_CONTROL | PAR_CONTROL_SLIN) );

        KeStallExecutionProcessor(60);
        KeLowerIrql(OldIrql);

    }

    StoreControl( Extension->Controller, 
                  (UCHAR)(PAR_CONTROL_WR_CONTROL | PAR_CONTROL_NOT_INIT | PAR_CONTROL_SLIN) );

    //
    // Spin waiting for the device to initialize.
    //

    KeQueryTickCount(&StartOfSpin);

    ParDumpV( ("Starting init wait loop\n") );

    do {

        KeQueryTickCount(&NextQuery);

        Difference.QuadPart = NextQuery.QuadPart - StartOfSpin.QuadPart;

        ASSERT(KeQueryTimeIncrement() <= MAXLONG);

        if (Difference.QuadPart*KeQueryTimeIncrement() >= Extension->AbsoluteOneSecond.QuadPart) {

            //
            // Give up on getting PAR_OK.
            //

            ParDump2(PARINITDEV, ("Did spin of one second - StartOfSpin: %x NextQuery: %x\n",
                                  StartOfSpin.LowPart,NextQuery.LowPart) );
            ParDump2(PARINITDEV, ("ParInitialize 1 seconds wait\n") );

            break;
        }

        DeviceStatus = GetStatus(Extension->Controller);

    } while (!PAR_OK(DeviceStatus));

    return (DeviceStatus);
}

VOID
ParNotInitError(
    IN PDEVICE_EXTENSION Extension,
    IN UCHAR             DeviceStatus
    )

/*++

Routine Description:

Arguments:

    Extension       - Supplies the device extension.

    deviceStatus    - Last read status.

Return Value:

    None.

--*/

{

    PIRP Irp = Extension->CurrentOpIrp;

    if (PAR_OFF_LINE(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        ParDump(PARSTARTER | PARDUMP_VERBOSE_MAX,
                ("PARALLEL: "
                 "Init Error - off line - "
                 "STATUS/INFORMATON: %x/%x\n",
                 Irp->IoStatus.Status, Irp->IoStatus.Information) );

    } else if (PAR_NO_CABLE(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        ParDump(PARSTARTER | PARDUMP_VERBOSE_MAX,
                ("PARALLEL: "
                 "Init Error - no cable - not connected - "
                 "STATUS/INFORMATON: %x/%x\n",
                 Irp->IoStatus.Status, Irp->IoStatus.Information) );

    } else if (PAR_PAPER_EMPTY(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_PAPER_EMPTY;
        ParDump(PARSTARTER | PARDUMP_VERBOSE_MAX,
                ("PARALLEL: "
                 "Init Error - paper empty - "
                 "STATUS/INFORMATON: %x/%x\n",
                 Irp->IoStatus.Status, Irp->IoStatus.Information) );

    } else if (PAR_POWERED_OFF(DeviceStatus)) {

        Irp->IoStatus.Status = STATUS_DEVICE_POWERED_OFF;
        ParDump(PARSTARTER | PARDUMP_VERBOSE_MAX,
                ("PARALLEL: "
                 "Init Error - power off - "
                 "STATUS/INFORMATON: %x/%x\n",
                 Irp->IoStatus.Status, Irp->IoStatus.Information) );

    } else {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
        ParDump(PARSTARTER | PARDUMP_VERBOSE_MAX,
                ("PARALLEL: "
                 "Init Error - not conn - "
                 "STATUS/INFORMATON: %x/%x\n",
                 Irp->IoStatus.Status, Irp->IoStatus.Information) );
    }

}

VOID
ParCancelRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel any request in the parallel driver.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{

    ParDumpV( ("ParCancelRequest: DO= %x , Irp= %x Cancel=%d, CancelRoutine= %x\n",
               DeviceObject, Irp, Irp->Cancel, Irp->CancelRoutine) );

    //
    // The only reason that this irp can be on the queue is
    // if it's not the current irp.  Pull it off the queue
    // and complete it as canceled.
    //

    ASSERT(!IsListEmpty(&Irp->Tail.Overlay.ListEntry));

    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    ParCompleteRequest(Irp, IO_NO_INCREMENT);

}


NTSTATUS
ParQueryInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.

--*/

{
    NTSTATUS                    Status;
    PIO_STACK_LOCATION          IrpSp;
    PFILE_STANDARD_INFORMATION  StdInfo;
    PFILE_POSITION_INFORMATION  PosInfo;
    PDEVICE_EXTENSION           Extension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    // ParDumpV( ("In query information file\n") );

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PAR_DEVICE_REMOVED|PAR_DEVICE_SURPRISE_REMOVAL) ) {

        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }

    Irp->IoStatus.Information = 0;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.QueryFile.FileInformationClass) {
        
    case FileStandardInformation:
        
        if (IrpSp->Parameters.QueryFile.Length < sizeof(FILE_STANDARD_INFORMATION)) {

            Status = STATUS_BUFFER_TOO_SMALL;
            
        } else {
            
            StdInfo = Irp->AssociatedIrp.SystemBuffer;
            StdInfo->AllocationSize.QuadPart = 0;
            StdInfo->EndOfFile               = StdInfo->AllocationSize;
            StdInfo->NumberOfLinks           = 0;
            StdInfo->DeletePending           = FALSE;
            StdInfo->Directory               = FALSE;
            
            Irp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
            Status = STATUS_SUCCESS;
            
        }
        break;
        
    case FilePositionInformation:
        
        if (IrpSp->Parameters.SetFile.Length < sizeof(FILE_POSITION_INFORMATION)) {

            Status = STATUS_BUFFER_TOO_SMALL;

        } else {
            
            PosInfo = Irp->AssociatedIrp.SystemBuffer;
            PosInfo->CurrentByteOffset.QuadPart = 0;
            
            Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
            Status = STATUS_SUCCESS;
        }
        break;
        
    default:
        Status = STATUS_INVALID_PARAMETER;
        break;
        
    }
    
    Irp->IoStatus.Status = Status;

    ParCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

NTSTATUS
ParSetInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened parallel port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.

--*/

{
    NTSTATUS               Status;
    FILE_INFORMATION_CLASS fileInfoClass;
    PDEVICE_EXTENSION      Extension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PAR_DEVICE_REMOVED|PAR_DEVICE_SURPRISE_REMOVAL) ) {

        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }


//     ParDump(PARIRPPATH | PARDUMP_VERBOSE_MAX,
//             ("PARALLEL: "
//              "In set information with IRP: %08x\n",
//              Irp) );

    Irp->IoStatus.Information = 0;

    fileInfoClass = IoGetCurrentIrpStackLocation(Irp)->Parameters.SetFile.FileInformationClass;

    if (fileInfoClass == FileEndOfFileInformation) {

        Status = STATUS_SUCCESS;

    } else {

//         ParDump(PARDUMP_VERBOSE_MAX,
//                 ("PARALLEL: "
//                  "In ParSetInformationFile(...): "
//                  "Invalid FileInformationClass: %d , only %d is valid\n"
//                  "PARALLEL: "
//                  " - Returning STATUS_INVALID_PARAMETER\n",
//                  fileInfoClass, FileEndOfFileInformation) );

        Status = STATUS_INVALID_PARAMETER;

    }

    Irp->IoStatus.Status = Status;

//     ParDump(PARDUMP_VERBOSE_MAX,
//             ("PARALLEL: "
//              "About to complete IRP in set information - "
//              "Irp: %x status: %x Information: %x\n",
//              Irp, Irp->IoStatus.Status, Irp->IoStatus.Information) );

    ParCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}


#if PAR_NO_FAST_CALLS
// temp debug functions so params show up on stack trace

VOID
ParCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{
    // KIRQL               CancelIrql;
    // IoAcquireCancelSpinLock(&CancelIrql);
    // ASSERT( !Irp->CancelRoutine );
    // IoReleaseCancelSpinLock(CancelIrql);
    if( Irp->UserEvent ) {
        ASSERT_EVENT( Irp->UserEvent );
    }
    IoCompleteRequest(Irp, PriorityBoost);
}

NTSTATUS
ParCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    return IoCallDriver(DeviceObject, Irp);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\parstl.h ===
#ifndef     _PARSTL_H_
#define     _PARSTL_H_

// Define 1284 Commands
#define CPP_QUERY_PRODID    0x10

// 1284 related SHTL prod id equates
#define SHTL_EPAT_PRODID    0xAAFF
#define SHTL_EPST_PRODID    0xA8FF

// typedefs for device type
typedef unsigned char   DEVICE_STATE ;
typedef unsigned int    STL_DEVICE_TYPE ;
typedef unsigned int    IMPACT_DEVICE_TYPE ;

// device type equates
#define DEVICE_TYPE_AUTO_DETECT     -1
#define TRUE    1
#define FALSE   0

#define DEVICE_TYPE_NONE            0x0000
#define DEVICE_TYPE_ATA             0x0001
#define DEVICE_TYPE_ATAPI           0x0002
#define DEVICE_TYPE_SCSI            0x0003
#define DEVICE_TYPE_SSFDC           0x0004
#define DEVICE_TYPE_MMC             0x0005
#define DEVICE_TYPE_FLASH           0x0006
#define DEVICE_TYPE_EPP_DEVICE      0x0007
#define DEVICE_TYPE_SOUND           0x0008
#define DEVICE_TYPE_HIFD            0x0009
#define DEVICE_TYPE_LS120           0x000A
#define DEVICE_TYPE_PCMCIA_CF       0x000B
#define DEVICE_TYPE_FLP_TAPE_DSK    0x000C
#define DEVICE_TYPE_ATA_ATAPI_8BIT  0x000D
#define DEVICE_TYPE_UMAX            0x000E
#define DEVICE_TYPE_AVISION         0x000F
#define DEVICE_TYPE_DAZZLE          0x0010
#define DEVICE_TYPE_EXT_HWDETECT    0x40000000 // to OR with expected pers.

#define DEVICE_TYPE_ATA_BIT             1 << ( DEVICE_TYPE_ATA - 1 )
#define DEVICE_TYPE_ATAPI_BIT           1 << ( DEVICE_TYPE_ATAPI - 1 )
#define DEVICE_TYPE_SCSI_BIT            1 << ( DEVICE_TYPE_SCSI - 1 )
#define DEVICE_TYPE_SSFDC_BIT           1 << ( DEVICE_TYPE_SSFDC - 1 )
#define DEVICE_TYPE_MMC_BIT             1 << ( DEVICE_TYPE_MMC - 1 )
#define DEVICE_TYPE_FLASH_BIT           1 << ( DEVICE_TYPE_FLASH - 1 )
#define DEVICE_TYPE_EPP_DEVICE_BIT      1 << ( DEVICE_TYPE_EPP_DEVICE - 1 )
#define DEVICE_TYPE_SOUND_BIT           1 << ( DEVICE_TYPE_SOUND - 1 )
#define DEVICE_TYPE_HIFD_BIT            1 << ( DEVICE_TYPE_HIFD - 1 )
#define DEVICE_TYPE_LS120_BIT           1 << ( DEVICE_TYPE_LS120 - 1 )
#define DEVICE_TYPE_PCMCIA_CF_BIT       1 << ( DEVICE_TYPE_PCMCIA_CF - 1 )
#define DEVICE_TYPE_FLP_TAPE_DSK_BIT    1 << ( DEVICE_TYPE_FLP_TAPE_DSK - 1 )
#define DEVICE_TYPE_ATA_ATAPI_8BIT_BIT  1 << ( DEVICE_TYPE_ATA_ATAPI_8BIT - 1 )
#define DEVICE_TYPE_UMAX_BIT            1 << ( DEVICE_TYPE_UMAX - 1 )
#define DEVICE_TYPE_AVISION_BIT         1 << ( DEVICE_TYPE_AVISION - 1 )
#define DEVICE_TYPE_DAZZLE_BIT          1 << ( DEVICE_TYPE_DAZZLE - 1 )

// possible Device states
#define DEVICE_STATE_INVALID    0
#define DEVICE_STATE_VALID      1
#define DEVICE_STATE_ATAPI      2

// epp dev equates
#define EPPDEV_SIGN        0x03
#define PERSONALITY_MASK    0x03

// flash related equates
#define FLASH_SIGN              0x01
#define FLASH_PERSONALITY_MASK  0x03

// dazzle related equates
#define DAZ_SELECT_BLK          0x18
#define DAZ_BLK0                0x00
#define DAZ_REG1                0x19
#define DAZ_CONFIGURED          0x5A
#define DAZ_NOT_CONFIGURED      0xBC

// umax related equates
#define    BUSY         0x20
#define    PE           0x08

#define    DATAPORT             0x18
#define    STATUSPORT           0x19
#define    CONTROLPORT          0x1A
#define    EPPADDRPORT          0x1B
#define    EPPDATA0PORT         0x1C
#define    EPPDATA1PORT         0x1D
#define    EPPDATA2PORT         0x1E
#define    EPPDATA3PORT         0x1F

// HIFD related equates
#define HIFD_CONTROLLER_READY_STATUS    0x80
#define HIFD_DIGITAL_OUTPUT_REGISTER    0x02
#define HIFD_DOR_RESET_BIT              0x04
#define HIFD_ENABLE_DMA_BIT             0x08
#define HIFD_MAIN_STATUS_REGISTER       0x04
#define HIFD_DATA_RATE_SELECT_REGISTER  0x04
#define HIFD_STATUS_REGISTER_A          0x00
#define HIFD_STATUS_REGISTER_B          0x01

#define HIFD_COMMAND_TO_CONTROLLER      0x55
#define HIFD_TERMINATE_SEQUENCE         0xAA
#define HIFD_CTL_REG_0D                 0x0D
#define HIFD_CTL_REG_03                 0x03
#define HIFD_WAIT_10_MILLISEC           10000   // 10 * 1000 
#define HIFD_WAIT_1_MILLISEC            1000   // 1 * 1000 

#define SMC_ENABLE_MODE2        0x72
#define SMC_DEVICE_ID           0x78

// LS120 related equates
#define LS120_ENGINE_VERSION            0xE2
#define LS120_ENGINE_VERSION_REGISTER   0x07

// MMC engine specific equates
#define MMC_ENGINE_INDEX    0x1E
#define MMC_ENGINE_DATA     0x1F
#define MMC_FREQ_SELECT_REG 0x00
#define MMC_BLOCK_SIZE_REG  0x06

// Though these are test patterns, they may be possible commands
// for ATA/ATAPI devices, as they are written to a possible
// ATA/ATAPI command register. These values have been fixed
// carefully, to minimize, if not eliminate, possible failure.
#define MMC_TEST_PATTERN_1  0x00    // ATA Nop commands for ATA/ATAPI type devices.
#define MMC_TEST_PATTERN_2  0xA1    // ATAPI Ident. command for ATAPI type devices.
#define MMC_TEST_PATTERN_3  0x00    // ATA Nop commands for ATA/ATAPI type devices.

// some IO register equates that are inevitable
#define CYLLOW_REG          0x0004
#define CYLHIGH_REG         0x0005

// ATAPI signature equates
#define ATAPI_SIGN_LOW      0x14
#define ATAPI_SIGN_HI       0xEB

// delay equates
#define MAX_RETRIES_FOR_5_SECS      5 * 1000    //   5 secs
#define MAX_RETRIES_FOR_10_SECS     10 * 1000   //   10 secs
#define DELAY_10MICROSECONDS        10          //  10 mu sec.
#define DELAY_1MILLISECONDS         1000        //  1 milli sec.
#define DELAY_1SECOND               1000*1000   //  1 sec.

// ATA/ATAPI command opcodes
#define ATA_NOP_COMMAND            0x00
#define ATAPI_IDENTIFY             0xA1

// ATA/ATAPI drive select values 
#define ATAPI_MASTER        0xA0
#define ATAPI_SLAVE         0xB0
#define ATAPI_MAX_DRIVES    2

//  ATA register definitions
#define ATA_DATA_REG            0x0000
#define ATA_ERROR_REG           0x0001
#define ATA_PRECOMP_REG         0x0001
#define ATA_SECCNT_REG          0x0002
#define ATA_SECNUM_REG          0x0003
#define ATA_CYLLOW_REG          0x0004
#define ATA_CYLHIGH_REG         0x0005
#define ATA_DRVHD_REG           0x0006
#define ATA_TASK_STAT_REG       0x0007
#define ATA_TASK_CMD_REG        0x0007
#define ATA_ALT_STAT_REG        0x0008

// ATA status register equates
#define ATA_ST_ERROR        0x01
#define ATA_ST_INDEX        0x02
#define ATA_ST_CORRCTD      0x04
#define ATA_ST_DRQ          0x08
#define ATA_ST_SEEK_COMPL   0x10
#define ATA_ST_WRT_FLT      0x20
#define ATA_ST_READY        0x40
#define ATA_ST_BUSY         0x80

// ATA error register equates
#define ATA_ERROR_ABORTED_COMMAND   0x04

// miscellaneous equates
#define BUS_LINES_IN_HIGH_IMPEDANCE         0xFF
#define SKIP_MEMORY_ADDRESS                 ((unsigned long)(-1L))
#define SHTL_NO_ERROR                       0x0000

#define IsShtlError(x) (x & 0x8000)
#define IsImpactPresent() ( IMPACT_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsImpactSPresent() ( IMPACTS_VERSION <= ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEp1284Present() ( EP1284_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpatPlusPresent() ( EPATP_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpezPresent() ( EPEZ_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpatPresent() ( EPAT_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define IsEpstPresent() ( EPST_VERSION == ParStlReadReg ( Extension, VERSION_REGISTER ) )
#define NeedToEnableIoPads() ( EP1284_VERSION <= ParStlReadReg ( Extension, VERSION_REGISTER ) )

// Identify command processing related defines..
#define ATAPI_IDENTIFY_LENGTH               512
#define ATAPI_NAME_LENGTH                   10
#define ATAPI_NAME_OFFSET                   84

// EP1284 related equates
#define EP1284_BLK_ADDR_REGISTER    0x0A
#define EP1284_MODE_REGISTER        0x0C
#define VERSION_REGISTER            0x0B
#define EP1284_TRANSFER_CONTROL_REG 0x12
#define EP1284_PERSONALITY_REG      0x01
#define EPAT_MODE_REGISTER          0x0C
#define SOCKET_CONTROL_REGISTER     0x0C
#define ISA_CONTROL_REGISTER        0x0D
#define CONFIG_INDEX_REGISTER       0x0E
#define CONFIG_DATA_REGISTER        0x0F
#define SHTL_CARD_INSERTED_STATUS   0x02
#define XFER_IRQ_BIT                0x20
#define EP1284_POWER_CONTROL_REG    0x0F
#define ENABLE_IOPADS               0x04

// IMPACT related equates
#define IMPACT_PERSONALITY_REG  0x01

// IMPACT-S related equates
#define IMPACTS_EXT_PERSONALITY_PRESENT 0x0A // 0xA0 >> 4
#define IMPACTS_EXT_PERSONALITY_XREG    0x29

// shuttle version number related equates
#define EPST_VERSION            0xB2
#define EPAT_VERSION            0xC3
#define EPEZ_VERSION            0xC5
#define EPATP_VERSION           0xC6
#define EP1284_VERSION          0xC7
#define IMPACT_VERSION          0xC8
#define IMPACTS_VERSION         0xC9
#define EP1284_ENABLE_16BIT     0x10
#define EPAT_RESET_POLARITY     0x20
#define ISA_IO_SWAP             0x20
#define SOCKET_0                0x00
#define SOCKET_1                0x01
#define PERIPHERAL_RESET_1      0x20
#define PERIPHERAL_RESET_0      0x10

// block xfer related op-codes
#define OP_NIBBLE_BLOCK_READ    0x07

// test pattern equates
#define TEST_PATTERN_1  0x55
#define TEST_PATTERN_2  0xAA

// Memory detection related equates
#define SELECT_DRAM 0x80
#define SELECT_SRAM 0x7F
#define RESET_PTR   0x01
#define ENABLE_MEM  0x04
#define EP1284_CONTROL_REG      0x13
#define EP1284_BUFFER_DATA_REG  0x10

// IMPACT device type defines
#define IMPACT_DEVICE_TYPE_NONE                 0
#define IMPACT_DEVICE_TYPE_ATA_ATAPI            1
#define IMPACT_DEVICE_TYPE_PCMCIA_CF            2
#define IMPACT_DEVICE_TYPE_SSFDC                3
#define IMPACT_DEVICE_TYPE_MMC                  4
#define IMPACT_DEVICE_TYPE_HIFD                 5
#define IMPACT_DEVICE_TYPE_SOUND                6
#define IMPACT_DEVICE_TYPE_FLP_TAPE_DSK         7
#define IMPACT_DEVICE_TYPE_CF                   8
#define IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT       9

// parallel port signal equates
#define SLCT_IN_DISABLE     0x04
#define SLCT_IN_ENABLE      0x0C
#define STB_INIT_LOW        0x01
#define STB_INIT_AFXT_LO    0x03
#define INIT_AFXT_HIGH      0x05
#define STB_INIT_AFXT_HI    0x04
#define STB_INIT_HIGH       0x04

#define AFXT_HI_STB_HI      0x04
#define AFXT_LO_STB_HI      0x06
#define AFXT_HI_STB_LO      0x05
#define AFXT_LO_STB_LO      0x07

// structure definitions

typedef struct  _ATAPI_PARAMS{
    DEVICE_STATE    dsDeviceState[ATAPI_MAX_DRIVES];
    char            szAtapiNameString [ ATAPI_NAME_LENGTH ] ;
} ATAPIPARAMS, *PATAPIPARAMS ;

// function prototypes 
BOOLEAN
ParStlCheckIfStl(
    IN PDEVICE_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

BOOLEAN
ParStlCheckIfNon1284_3Present(
    IN PDEVICE_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlCheckIfStl1284_3(
    IN PDEVICE_EXTENSION    Extension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    ) ;

BOOLEAN
ParStlCheckIfStlProductId(
    IN PDEVICE_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    ) ;

PCHAR
ParQueryStlDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    ) ;

PCHAR
ParBuildStlDeviceId(
    IN  PDEVICE_EXTENSION   Extension
    ) ;

STL_DEVICE_TYPE __cdecl 
ParStlGetDeviceType (
    IN PDEVICE_EXTENSION    Extension,
    IN int                  nPreferredDeviceType
    ) ;

VOID
ParStlSet16BitOperation (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckDrivePresent (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlWaitForBusyToClear (
    IN  PDEVICE_EXTENSION   Extension,
    IN  int                 nRegisterToWaitOn 
    ) ;

BOOLEAN
ParStlWaitForDrq (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlWaitForIrq (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtaAtapiDevice (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlAtapiInitialize ( 
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    );

BOOLEAN
ParStlAtaInitialize ( 
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfScsiDevice (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfSSFDC (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfMMC (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfFlash (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfDazzle (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtapiDevice (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfLS120 (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfImpactLS120 (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN 
ParStlCheckIfHiFD (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlCheckIfAtaDevice (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    ) ;

BOOLEAN
ParStlCheckCardInsertionStatus ( 
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlSelectAdapterSocket (
    IN  PDEVICE_EXTENSION   Extension,
    int     nSocketNumber
    ) ;

VOID
ParStlWaitForMicroSeconds (
    int nMicroSecondsToWait
    ) ;

STL_DEVICE_TYPE
ParStlGetImpactDeviceType (
    IN  PDEVICE_EXTENSION       Extension,
    IN  OUT  PATAPIPARAMS       atapiParams,
    IN  int                     nPreferredDeviceType
    ) ;

STL_DEVICE_TYPE
ParStlGetImpactSDeviceType (
    IN  PDEVICE_EXTENSION       Extension,
    IN  OUT  PATAPIPARAMS       atapiParams,
    IN  int                     nPreferredDeviceType
    ) ;

BOOLEAN 
ParStlCheckIfEppDevice (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckPersonalityForEppDevice (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckFlashPersonality (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlHIFDCheckIfControllerReady (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlHIFDCheckSMCController (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN 
ParStlIsMMCEnginePresent(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParStlAssertIdleState (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

BOOLEAN
ParStlCheckUMAXScannerPresence(
    IN PDEVICE_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlCheckAvisionScannerPresence(
    IN PDEVICE_EXTENSION    Extension
    ) ;

BOOLEAN
ParStlSetEPPMode(
    IN PDEVICE_EXTENSION    Extension
    ) ;

USHORT
ParStlEPPWrite(
    IN PDEVICE_EXTENSION    Extension,
    IN UCHAR value
    ) ;

USHORT
ParStlEPPRead(
    IN PDEVICE_EXTENSION
    ) ;

int __cdecl
ParStlReadReg(
    IN  PDEVICE_EXTENSION   Extension,
    IN  unsigned int    reg
    ) ;

int __cdecl
ParStlWriteReg(
    IN  PDEVICE_EXTENSION   Extension,
    IN  unsigned int        reg,
    IN  int                 databyte
    ) ;

int __cdecl
ParStlReadIoPort(
    IN  PDEVICE_EXTENSION   Extension,
    IN  unsigned int        reg
    ) ;

int __cdecl
ParStlWriteIoPort(
    IN  PDEVICE_EXTENSION   Extension,
    IN  unsigned int        reg,
    IN  int                 databyte
    ) ;

int __cdecl
ParStlReceiveData(
    IN  PDEVICE_EXTENSION   Extension,
    OUT void                *hostBufferPointer,
    IN  long                shuttleMemoryAddress,
    IN  unsigned            count
    ) ;

int  __cdecl
ParStlGetMemorySize (
    IN  PDEVICE_EXTENSION   Extension
    ) ;

#endif  // for _PARSTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\parstl.c ===
/*++

Copyright (C) SCM Micro Systems.

Module Name:

    parstl.c

Abstract:

    This is the module that generates unique device id
    for shuttle adapters, that do not have the capability
    to do so, by themselves.

Author:

    Devanathan NR   21-Jun-1999
    Sudheendran TL

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"
#include "parstl.h"

BOOLEAN
ParStlCheckIfStl(
    IN PDEVICE_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    )
/*++

Routine Description:

    This function checks whether the indicated device
    is a shuttle device or not.

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy index on which to do the check.

Return Value:

    TRUE            - Yes, it was a Shuttle device.
    FALSE           - No, not a shuttle.

--*/
{
    NTSTATUS    status ;
    BOOLEAN     bStlNon1284_3Found = FALSE ;

    Extension->Ieee1284Flags &= ( ~ ( 1 << ulDaisyIndex ) ) ;
    bStlNon1284_3Found = ParStlCheckIfNon1284_3Present( Extension ) ;

    if ( TRUE == ParStlCheckIfStl1284_3 ( Extension, ulDaisyIndex, bStlNon1284_3Found ) ) {
        // this adapter is a Shuttle 1284_3 adapter
        Extension->Ieee1284Flags |= ( 1 << ulDaisyIndex ) ;
        return TRUE ;
    }
    if ( TRUE == bStlNon1284_3Found ) {
        if ( TRUE == ParStlCheckIfStlProductId ( Extension, ulDaisyIndex ) ) {
            // this adapter is Shuttle non-1284_3 adapter
            Extension->Ieee1284Flags |= ( 1 << ulDaisyIndex ) ;
            return TRUE ;
        }
    }
    return FALSE ;
}

BOOLEAN
ParStlCheckIfNon1284_3Present(
    IN PDEVICE_EXTENSION    Extension
    )
/*++

Routine Description:

    Indicates whether one of the devices of the earlier
    specification is present in the chain.


Arguments:

    Extension   - Device Extension structure


Return Value:

    TRUE    : Atleast one of the adapters are of earlier spec.
    FALSE   : None of the adapters of the earlier spec.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;
    UCHAR   ucAckStatus ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = READ_PORT_UCHAR( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    WRITE_PORT_UCHAR( CurrentControl, newvalue );    // make sure we can write

    // bring nStrobe high
    WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = READ_PORT_UCHAR( CurrentStatus );

    if ( (status & (UCHAR)0xb8 )
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        ucAckStatus = status & 0x40 ;

        // continue with fifth byte of mode qualifier
        WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = READ_PORT_UCHAR( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            if ( ucAckStatus != ( status & 0x40 ) ) {

                // save current ack status
                ucAckStatus = status & 0x40 ;

                // continue with sixth byte
                WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[5] );
                KeStallExecutionProcessor( Delay );

                // check for correct status
                status = READ_PORT_UCHAR( CurrentStatus );

                // if status is valid there is a device out there responding
                if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {

                    bReturnValue = TRUE ;

                } // Third status

            } // ack of earlier adapters not seen

            // last byte
            WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[6] );

        } // Second status

    } // First status

    WRITE_PORT_UCHAR( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // ParStlCheckIfNon1284_3Present

BOOLEAN
ParStlCheckIfStl1284_3(
    IN PDEVICE_EXTENSION    Extension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle 1284_3 type of device.

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

    bNoStrobe       - If set, indicates that the query
                      Ep1284 command issued by this function
                      need not assert strobe to latch the
                      command.

Return Value:

    TRUE            - Yes. Device is Shuttle 1284_3 type of device.
    FALSE           - No. This may mean that this device is either
                      non-shuttle or Shuttle non-1284_3 type of
                      device.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucExpectedPattern ;
    UCHAR   ucReadValue, ucReadPattern;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = READ_PORT_UCHAR( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    WRITE_PORT_UCHAR( CurrentControl, newvalue );    // make sure we can write

    // bring nStrobe high
    WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = READ_PORT_UCHAR( CurrentStatus );

    if ( (status & (UCHAR)0xb8 )
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = READ_PORT_UCHAR( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = READ_PORT_UCHAR( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {

                // Device is out there
                KeStallExecutionProcessor( Delay );

                // issue shuttle specific CPP command
                WRITE_PORT_UCHAR( CurrentPort, (UCHAR) ( 0x88 | ulDaisyIndex ) );
                KeStallExecutionProcessor( Delay );        // wait a bit

                if ( ulDaisyIndex && ( bNoStrobe == FALSE ) ) {

                    WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    KeStallExecutionProcessor( Delay );        // wait a bit

                }

                ucExpectedPattern = 0xF0 ;
                bReturnValue = TRUE ;

                while ( ucExpectedPattern ) {

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    WRITE_PORT_UCHAR( CurrentPort, (UCHAR) (0x80 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    WRITE_PORT_UCHAR( CurrentPort, (UCHAR) (0x88 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    ucReadValue = READ_PORT_UCHAR( CurrentStatus ) ;
                    ucReadPattern = ( ucReadValue << 1 ) & 0x70 ;
                    ucReadPattern |= ( ucReadValue & 0x80 ) ;

                    if ( ucReadPattern != ucExpectedPattern ) {
                        // not Shuttle 1284_3 behaviour
                        bReturnValue = FALSE ;
                        break ;
                    }

                    ucExpectedPattern -= 0x10 ;
                }


                // last byte
                WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    WRITE_PORT_UCHAR( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // end  ParStlCheckIfStl1284_3()

BOOLEAN
ParStlCheckIfStlProductId(
    IN PDEVICE_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle non-1284_3 type of device.

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

Return Value:

    TRUE            - Yes. Device is Shuttle non-1284_3 type of device.
    FALSE           - No. This may mean that this device is
                      non-shuttle.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucProdIdHiByteHiNibble, ucProdIdHiByteLoNibble ;
    UCHAR   ucProdIdLoByteHiNibble, ucProdIdLoByteLoNibble ;
    UCHAR   ucProdIdHiByte, ucProdIdLoByte ;
    USHORT  usProdId ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = READ_PORT_UCHAR( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    WRITE_PORT_UCHAR( CurrentControl, newvalue );    // make sure we can write

    // bring nStrobe high
    WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = READ_PORT_UCHAR( CurrentStatus );

    if ( (status & (UCHAR)0xb8 )
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = READ_PORT_UCHAR( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = READ_PORT_UCHAR( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {

                WRITE_PORT_UCHAR ( CurrentPort, (UCHAR) (CPP_QUERY_PRODID | ulDaisyIndex )) ;
                KeStallExecutionProcessor( Delay );

                // Device is out there
                KeStallExecutionProcessor( Delay );
                ucProdIdLoByteHiNibble = READ_PORT_UCHAR( CurrentStatus ) ;
                ucProdIdLoByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdLoByteLoNibble = READ_PORT_UCHAR( CurrentStatus ) ;
                ucProdIdLoByteLoNibble >>= 4 ;
                ucProdIdLoByte = ucProdIdLoByteHiNibble | ucProdIdLoByteLoNibble ;

                KeStallExecutionProcessor( Delay );
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteHiNibble = READ_PORT_UCHAR( CurrentStatus ) ;
                ucProdIdHiByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteLoNibble = READ_PORT_UCHAR( CurrentStatus ) ;
                ucProdIdHiByteLoNibble >>= 4 ;
                ucProdIdHiByte = ucProdIdHiByteHiNibble | ucProdIdHiByteLoNibble ;

                // last strobe
                KeStallExecutionProcessor( Delay );
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                WRITE_PORT_UCHAR( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                usProdId = ( ucProdIdHiByte << 8 ) | ucProdIdLoByte ;

                if ( ( SHTL_EPAT_PRODID == usProdId ) ||\
                     ( SHTL_EPST_PRODID == usProdId ) ) {
                    // one of the devices that conform to the earlier
                    // draft is found
                    bReturnValue = TRUE ;
                }

                // last byte
                WRITE_PORT_UCHAR( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    WRITE_PORT_UCHAR( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // end  ParStlCheckIfStlProductId()

PCHAR
ParStlQueryStlDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer,
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    )
/*++

Routine Description:

    This routine retrieves/constructs the unique device id
    string from the selected shuttle device on the chain
    and updates the caller's buffer with the same.

Arguments:

    IN  Extension               : The device extension
    OUT CallerDeviceIdBuffer    : Caller's buffer
    IN  CallerBufferSize        : Size of caller's buffer
    OUT DeviceIdSize            : Updated device id's size
    IN  bReturnRawString        : Whether to return raw
                                  string with the first two
                                  bytes or not.

Return Value:

    Pointer to the read device ID string, if successful.

    NULL otherwise.

--*/
{
    PUCHAR              Controller = Extension->Controller;
    NTSTATUS            Status;
    UCHAR               idSizeBuffer[2];
    ULONG               bytesToRead;
    ULONG               bytesRead = 0;
    USHORT              deviceIdSize;
    USHORT              deviceIdBufferSize;
    PCHAR               deviceIdBuffer;
    PCHAR               readPtr;

    *DeviceIdSize = 0;

    // assert idle state, to recover from undefined state,
    // just in case it gets into
    ParStlAssertIdleState ( Extension ) ;

    //
    // If we are currently connected to the peripheral via any 1284 mode
    //   other than Compatibility/Spp mode (which does not require an IEEE
    //   negotiation), we must first terminate the current mode/connection.
    //
    // dvdf - RMT - what if we are connected in a reverse mode?
    //
    if( (Extension->Connected) && (afpForward[Extension->IdxForwardProtocol].fnDisconnect) ) {
        afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
    }

    do {

        //
        // Negotiate the peripheral into nibble device id mode.
        //
        Status = ParEnterNibbleMode(Extension, REQUEST_DEVICE_ID);
        if( !NT_SUCCESS(Status) ) {
            ParTerminateNibbleMode(Extension);
            break ;
        }


        //
        // Read first two bytes to get the total (including the 2 size bytes) size
        //   of the Device Id string.
        //
        bytesToRead = 2;
        Status = ParNibbleModeRead(Extension, idSizeBuffer, bytesToRead, &bytesRead);
        if( !NT_SUCCESS( Status ) || ( bytesRead != bytesToRead ) ) {
            break ;
        }


        //
        // Compute size of DeviceId string (including the 2 byte size prefix)
        //
        deviceIdSize = (USHORT)( idSizeBuffer[0]*0x100 + idSizeBuffer[1] );


        //
        // Allocate a buffer to hold the DeviceId string and read the DeviceId into it.
        //
        if( bReturnRawString ) {
            //
            // Caller wants the raw string including the 2 size bytes
            //
            *DeviceIdSize      = deviceIdSize;
            deviceIdBufferSize = (USHORT)(deviceIdSize + sizeof(CHAR));     // ID size + ID + terminating NULL
        } else {
            //
            // Caller does not want the 2 byte size prefix
            //
            *DeviceIdSize      = deviceIdSize - 2*sizeof(CHAR);
            deviceIdBufferSize = (USHORT)(deviceIdSize - 2*sizeof(CHAR) + sizeof(CHAR)); //           ID + terminating NULL
        }

        deviceIdBuffer = (PCHAR)ExAllocatePool(PagedPool, deviceIdBufferSize);
        if( !deviceIdBuffer ) {
            break;
        }


        //
        // NULL out the ID buffer to be safe
        //
        RtlZeroMemory( deviceIdBuffer, deviceIdBufferSize );


        //
        // Does the caller want the 2 byte size prefix?
        //
        if( bReturnRawString ) {
            //
            // Yes, caller wants the size prefix. Copy prefix to buffer to return.
            //
            *(deviceIdBuffer+0) = idSizeBuffer[0];
            *(deviceIdBuffer+1) = idSizeBuffer[1];
            readPtr = deviceIdBuffer + 2;
        } else {
            //
            // No, discard size prefix
            //
            readPtr = deviceIdBuffer;
        }


        //
        // Read remainder of DeviceId from device
        //
        bytesToRead = deviceIdSize -  2; // already have the 2 size bytes
        Status = ParNibbleModeRead(Extension, readPtr, bytesToRead, &bytesRead);


        ParTerminateNibbleMode( Extension );

        if( !NT_SUCCESS(Status) || (bytesRead < 1) ) {
            ExFreePool( deviceIdBuffer );
            break ;
        }

        if ( strstr ( readPtr, "MFG:" ) == 0 ) {
            ExFreePool( deviceIdBuffer ) ;
            break ;
        }

        deviceIdSize = (USHORT) strlen(deviceIdBuffer);
        *DeviceIdSize = deviceIdSize;
        if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize) ) {
            // caller supplied buffer is large enough, use it
            RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
            RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
            ExFreePool( deviceIdBuffer );
            return CallerDeviceIdBuffer;
        }
        return deviceIdBuffer;

    } while ( FALSE ) ;

// Builds later than 2080 fail to terminate in Compatibility mode.
//IEEETerminate1284Mode fails after  Event 23 (Extension->CurrentEvent equals 23)
// with earlier 1284 draft.
//So, we terminate the adapter ourselves, in some cases may be redundant.
    WRITE_PORT_UCHAR(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT);
    KeStallExecutionProcessor( 5 );
    WRITE_PORT_UCHAR(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT | DCR_AUTOFEED);
    KeStallExecutionProcessor( 5 );
    WRITE_PORT_UCHAR(Controller + DCR_OFFSET, DCR_SELECT_IN | DCR_NOT_INIT);

    ParStlAssertIdleState ( Extension ) ;

    deviceIdBuffer = ParBuildStlDeviceId(Extension);

    if( !deviceIdBuffer ) {
        return NULL;
    }

    deviceIdSize = (USHORT) strlen(deviceIdBuffer);
    *DeviceIdSize = deviceIdSize;
    if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize) ) {
        // caller supplied buffer is large enough, use it
        RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
        RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
        ExFreePool( deviceIdBuffer );
        return CallerDeviceIdBuffer;
    }
    return deviceIdBuffer;
}

PCHAR
ParBuildStlDeviceId(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This function detects the type of shuttle adapter and
    builds an appropriate device id string and returns it
    back.

    It is assumed that the device is already in the
    selected state.

Arguments:

    Nil.


Return Value:

    Pointer to the read/built device ID string, if successful.

    NULL otherwise.

--*/
{
    ULONG size = 0x80 ;
    PCHAR id ;
    STL_DEVICE_TYPE dtDeviceType ;
    CHAR szDeviceIdString[0x80] ;
    CHAR szVidPidString[] = "MFG:VID_04E6;CLS:SCSIADAPTER;MDL:PID_" ;
    CHAR szVidPidStringScan[] = "MFG:VID_04E6;CLS:IMAGE;MDL:PID_" ;

    RtlZeroMemory(szDeviceIdString, sizeof(szDeviceIdString));

    // identify the shuttle adapter type by calling
    // Devtype routines here and build an unique id
    // string here.
    dtDeviceType = ParStlGetDeviceType(Extension, DEVICE_TYPE_AUTO_DETECT);

    switch ( dtDeviceType ) {

        case DEVICE_TYPE_NONE :
            return NULL;

        case DEVICE_TYPE_EPP_DEVICE :
            dtDeviceType |= 0x80000000 ;
            sprintf(szDeviceIdString, "%s%08X;", szVidPidStringScan, dtDeviceType);
            break;

        default :
            dtDeviceType |= 0x80000000 ;
            sprintf(szDeviceIdString, "%s%08X;", szVidPidString, dtDeviceType);
            break;

    }

    id = ExAllocatePool(PagedPool, size);
    if( id ) {
        RtlZeroMemory( id, size );
        RtlCopyMemory( id, szDeviceIdString, size - sizeof(NULL) );
        return id;
    }
    return NULL;
}

STL_DEVICE_TYPE __cdecl
ParStlGetDeviceType (
    IN PDEVICE_EXTENSION    Extension,
    IN int                  nPreferredDeviceType
    )
{
    STL_DEVICE_TYPE dtDeviceType    = DEVICE_TYPE_NONE ;
    int nLocalPreferredDeviceType   = nPreferredDeviceType ;
    ATAPIPARAMS atapiParams ;
    int i;

    for ( i=0 ; i<ATAPI_MAX_DRIVES ; i++){
        atapiParams.dsDeviceState[i] = DEVICE_STATE_INVALID ;
    }

    do
    {
        if ( TRUE == ParStlCheckIfScsiDevice(Extension))
        {
// SCSI Device identified.
            dtDeviceType |= DEVICE_TYPE_SCSI_BIT ;
            break ;
        }

        if ( TRUE == NeedToEnableIoPads () )
        {
// in some adapters, the IO pads need to be enabled, before
// doing the device detection
            ParStlWriteReg( Extension, CONFIG_INDEX_REGISTER, EP1284_POWER_CONTROL_REG );
            ParStlWriteReg( Extension, CONFIG_DATA_REGISTER, ENABLE_IOPADS );
        }

        if ( TRUE == IsImpactSPresent() )
        {
// as impact-s has been identified, the device type identification
// can be done through personality configuration info
            dtDeviceType |= ParStlGetImpactSDeviceType( Extension, &atapiParams, nPreferredDeviceType );
            break;
        }

        if ( TRUE == IsImpactPresent() )
        {
// as impact has been identified, the device type identification
// can be done through personality configuration info
            dtDeviceType |= ParStlGetImpactDeviceType( Extension, &atapiParams, nPreferredDeviceType );
            break;
        }

        if (TRUE == ParStlCheckIfEppDevice(Extension))
        {
// epp device identified
            if ( TRUE == ParStlCheckUMAXScannerPresence(Extension) ) {
// umax identified
                dtDeviceType |= DEVICE_TYPE_UMAX_BIT;
                break;
            }
            if ( TRUE == ParStlCheckAvisionScannerPresence(Extension) ) {
// avision identified
                dtDeviceType |= DEVICE_TYPE_AVISION_BIT;
                break;
            }
// generice scanner peripheral detected
            dtDeviceType |= DEVICE_TYPE_EPP_DEVICE_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfSSFDC(Extension))
        {
// SSFDC identified
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfMMC(Extension,&atapiParams))
        {
// MMC device identified
            dtDeviceType |= DEVICE_TYPE_MMC_BIT;
            break;
        }

// set the 16 bit mode of the adapter
        ParStlSet16BitOperation(Extension) ;

        if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension, &atapiParams))
        {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
            if (TRUE == ParStlCheckIfAtapiDevice(Extension, &atapiParams))
            {
// sub-classify between HiFD and LS-120.
                if ( TRUE == ParStlCheckIfLS120(Extension))
                {
// LS Engine is found.
                    dtDeviceType |= DEVICE_TYPE_LS120_BIT ;
                    break ;
                }
// Check for HiFD.
                if (TRUE == ParStlCheckIfHiFD(Extension))
                {
// HiFD device identified.
                    dtDeviceType |=   DEVICE_TYPE_HIFD_BIT ;
                    break ;
                }
// OtherWise, it is a generic ATAPI device.
                dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                break ;
            }

            if (TRUE == ParStlCheckIfAtaDevice(Extension, &atapiParams))
            {
// ata identified
                dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                break;
            }
        }

        if (TRUE == ParStlCheckIfDazzle(Extension))
        {
// dazzle identified
            dtDeviceType |= DEVICE_TYPE_DAZZLE_BIT;
            break;
        }

        if (TRUE == ParStlCheckIfFlash(Extension))
        {
// flash identified
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break;
        }
    }
    while ( FALSE ) ;

    return dtDeviceType & nPreferredDeviceType ;
}

VOID
ParStlWaitForMicroSeconds (
    int nMicroSecondsToWait
    ) {
    KeStallExecutionProcessor ( nMicroSecondsToWait ) ;
}

BOOLEAN
ParStlCheckCardInsertionStatus (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byPowerRegData ;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
            break ;
        }

        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , 0x0F ) ;
        byPowerRegData  =  (UCHAR) ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;

        if ( byPowerRegData & SHTL_CARD_INSERTED_STATUS )
        {
// as the card not inserted status is reported, it is ATA / ATAPI
// possibly, not flash. hence, we break here.
            break ;
        }

        bReturnValue    =   TRUE ;
    }
    while ( FALSE ) ;

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlSelectAdapterSocket (
    IN  PDEVICE_EXTENSION   Extension,
    IN  int                 nSocketNumber
    )
{
    BOOLEAN bReturnValue    =   FALSE ;
    UCHAR   bySCRControlReg , byISAControlReg ;

    do
    {
        if ( ( nSocketNumber != SOCKET_0 ) &&
             ( nSocketNumber != SOCKET_1 ) )
        {
// as an invalid socket number is provided, we
// break here with error.
            break ;
        }

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        bySCRControlReg = (UCHAR) ParStlReadReg (Extension, CONFIG_DATA_REGISTER ) ;

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , ISA_CONTROL_REGISTER ) ;
        byISAControlReg = (UCHAR) ParStlReadReg (Extension, CONFIG_DATA_REGISTER ) ;

        if ( SOCKET_1 == nSocketNumber )
        {
            bySCRControlReg |=  (UCHAR)SOCKET_1 ;
            bySCRControlReg |=  (UCHAR)PERIPHERAL_RESET_1 ;
            byISAControlReg &=  ~(UCHAR)ISA_IO_SWAP ;
        }
        else
        {
            bySCRControlReg &=  ~(UCHAR)SOCKET_1 ;
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_0 ;
        }

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , ISA_CONTROL_REGISTER ) ;
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , byISAControlReg ) ;

        ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

        if ( SOCKET_1 == nSocketNumber )
        {
// Wait for a few milliseconds to provide an optimal puse width
// for reset.
            ParStlWaitForMicroSeconds(1000);
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_1 ;
        }
        else
        {
            bySCRControlReg &=  ~(UCHAR)PERIPHERAL_RESET_0 ;
        }
        ParStlWriteReg(Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

        bReturnValue    =   TRUE ;
    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN
ParStlCheckIfAtaAtapiDevice (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( TRUE == ParStlCheckCardInsertionStatus(Extension) )
        {
// as the card insertion status is valid, its probably
// a flash
            break ;
        }
        if ( FALSE == ParStlCheckDrivePresent(Extension, atapiParams) )
        {
// as the ATA/ATAPI controller is not present, it cant be
// an ATA/ATAPI device
            break ;
        }
        bReturnValue = TRUE;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckIfAtapiDevice (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
// return whatever ATAPI initialization module says
        bReturnValue = ParStlAtapiInitialize(Extension, atapiParams) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckIfAtaDevice (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
// return whatever ATA initialization module says
        bReturnValue = ParStlAtaInitialize(Extension, atapiParams) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckDrivePresent (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byOrgCylHigh, byOrgCylLow ;
    int     nCurrentDrive = 0 , i ;
    UCHAR   nDrvHdArray[]={ATAPI_MASTER, ATAPI_SLAVE};

    do
    {
        if ( atapiParams->dsDeviceState[nCurrentDrive] == DEVICE_STATE_VALID )
        {
// this means that the MMC module had detected the presence
// of an ATA/ATAPI device. So, we make use of that and break out
            bReturnValue = TRUE ;
            break ;
        }

        ParStlWriteIoPort(Extension, ATA_DRVHD_REG, nDrvHdArray[nCurrentDrive]);

//  The Atapi Fuji MO drive is found to de-assert BSY and still
//  does not respond to reg. r/w when configured as slave with no media.
//  However, after a delay, it works ok.
        if ( nCurrentDrive )
        {
            ParStlWaitForMicroSeconds ( DELAY_1SECOND ) ;
        }

// this dummy write of 0 is to zero out a possible
// floating bus
        for ( i = 0 ; i < 16 ; i++ )
        {
            ParStlWriteReg(Extension, CONFIG_INDEX_REGISTER, i) ;
            if ( !( ParStlReadIoPort (Extension, ATA_TASK_STAT_REG ) & ATA_ST_BUSY ) )
            {
                break ;
            }
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as the busy has been found permanently set, we check
// for the slave also
            continue;
        }

// as the drive head setup might have been performed in a busy state,
// we set it up again after busy clears.
        ParStlWriteIoPort(Extension, ATA_DRVHD_REG, nDrvHdArray[nCurrentDrive]);

        if ( ( ParStlReadIoPort(Extension, ATA_DRVHD_REG) & ATAPI_SLAVE ) != nDrvHdArray[nCurrentDrive] )
        {
            continue ;
        }

// read original contents of the cyl ATA high/low registers
        byOrgCylLow  = (UCHAR) ParStlReadIoPort(Extension, ATA_CYLLOW_REG);
        byOrgCylHigh = (UCHAR) ParStlReadIoPort(Extension, ATA_CYLHIGH_REG);

// write a test pattern in the cyl ATA high/low registers
        ParStlWriteIoPort(Extension, ATA_CYLLOW_REG, TEST_PATTERN_1);
        ParStlWriteIoPort(Extension, ATA_CYLHIGH_REG, TEST_PATTERN_2);

// read the test pattern in the cyl ATA high/low registers
        if ( ( TEST_PATTERN_1 != ParStlReadIoPort(Extension, ATA_CYLLOW_REG) ) ||\
             ( TEST_PATTERN_2 != ParStlReadIoPort(Extension, ATA_CYLHIGH_REG) ) )
        {
// as we were not able to read back the written values
// we break out here, indicating the absence of the device
            continue ;
        }

// write back original contents in the cyl ATA high/low registers
        ParStlWriteIoPort(Extension, ATA_CYLLOW_REG, byOrgCylLow);
        ParStlWriteIoPort(Extension, ATA_CYLHIGH_REG, byOrgCylHigh);
        bReturnValue = TRUE ;
        atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_VALID ;
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return bReturnValue ;
}

BOOLEAN
ParStlAtapiInitialize (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    int     nCurrentDrive   = 0, i ;
    UCHAR   byTempValue ;
    UCHAR   chAtapiIdentifyBuffer [ ATAPI_IDENTIFY_LENGTH ] ;
    do
    {
        if ( DEVICE_STATE_VALID != atapiParams->dsDeviceState[nCurrentDrive] )
        {
// the device is absent
            continue ;
        }

        if ( nCurrentDrive )
        {
// as it is the next drive, choose the slave
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_SLAVE);
        }
        else
        {
// choose the master
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set after master/slave, we fail
// the detection process
            continue ;
        }

// check if the ATAPI signature is present in the cyl hi/lo
// registers. If present, it is definitely an ATAPI device
        if ( ( ParStlReadIoPort(Extension, ATA_CYLLOW_REG) == ATAPI_SIGN_LOW ) &&\
             ( ParStlReadIoPort(Extension, ATA_CYLHIGH_REG) == ATAPI_SIGN_HI ) )
        {
// as ATAPI signature is present, it is ATAPI type
            bReturnValue = TRUE ;

// set this flag so that, ATA initialize will skip this
// target
            atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_ATAPI ;
// for Impact, since Ls120 engine is always present,
// issuing ATAPI_IDENTIFY is mandatory.
            if ( !IsImpactPresent())
            {
                continue ;
            }
        }

// issue the ata nop command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATA_NOP_COMMAND) ;

        if ( FALSE == ParStlWaitForIrq(Extension) )
        {
// ATAPI devices are expected to give interrrupt on NOP command
// mandatorily.
            continue ;
        }
        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we proceed with the next
// drive
            continue ;
        }

// issue the atapi packet command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATAPI_IDENTIFY) ;

        if ( FALSE == ParStlWaitForIrq(Extension) )
        {
// ATAPI devices are expected to give interrrupt on 0xA1 command
// mandatorily.
            continue ;
        }
        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we proceed with the next
// drive
            continue ;
        }

        byTempValue = (UCHAR) ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) ;
        if ( ! ( byTempValue & ATA_ST_ERROR ) )
        {
// as the drive has passed the packet command, this is an atapi
// drive
// Wait for DRQ to be sit, as some drives are known
// to remove busy too early and set DRQ after some time.
            if ( FALSE == ParStlWaitForDrq(Extension) )
            {
// as there was no DRQ set, we proceed with the next
// drive
                continue ;
            }
            bReturnValue = TRUE ;
// as the DRQ is still asserted, quell it, as certain ATA/ATAPI-4
// spec. dictates it so
// There is a need to check the device identifier returned in the
// ATAPI Identify cmd. to determine the presence of Ls-120.
            ParStlReceiveData ( Extension, chAtapiIdentifyBuffer , SKIP_MEMORY_ADDRESS , ATAPI_IDENTIFY_LENGTH ) ;
            for ( i = 0 ; i < ATAPI_NAME_LENGTH ; i++ )
            {
                atapiParams->szAtapiNameString[i] = chAtapiIdentifyBuffer[ ATAPI_NAME_OFFSET + i ] ;
            }

// set this flag so that, ATA initialize will skip this
// target
            atapiParams->dsDeviceState[nCurrentDrive] = DEVICE_STATE_ATAPI ;
        }
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlAtaInitialize (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue    = FALSE ;
    UCHAR   byTempValue ;
    int     nCurrentDrive   = 0 ;
    do
    {
        if ( DEVICE_STATE_VALID != atapiParams->dsDeviceState[nCurrentDrive] )
        {
// atapi module has marked its presence or the device is absent
            continue ;
        }

// select the possibly present device
        if ( nCurrentDrive )
        {
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_SLAVE ) ;
        }
        else
        {
            ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER ) ;
        }

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set after master/slave, we fail the
// detection process
            continue ;
        }

// issue the ata NOP command
        ParStlWriteIoPort(Extension, ATA_TASK_CMD_REG, ATA_NOP_COMMAND) ;

        if ( FALSE == ParStlWaitForBusyToClear(Extension, ATA_TASK_STAT_REG) )
        {
// as busy has permanently set, we fail the detection process
            continue ;
        }

        byTempValue = (UCHAR) ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) ;
        if ( ( byTempValue != BUS_LINES_IN_HIGH_IMPEDANCE ) &&\
             ( byTempValue & ATA_ST_ERROR ) )
        {
// as the bus is not reading 0xFF and the status register
// indicates an error, this is likely to be an ATA device
            if ( ATA_ERROR_ABORTED_COMMAND == ( (UCHAR) ParStlReadIoPort ( Extension, ATA_ERROR_REG ) & 0x0F ) )
            {
// as the error register, contains the ata aborted error
// in response to our ATA NOP command, we conclude that
// it is ATA! as it is already known that it is not ATAPI
                bReturnValue = TRUE ;
                break;
            }
        }
    }
    while ( ++nCurrentDrive < ATAPI_MAX_DRIVES );

// reset back to master state, as check drive present
// will be called successively
    ParStlWriteIoPort(Extension, ATA_DRVHD_REG, ATAPI_MASTER);

    return ( bReturnValue ) ;
}

BOOLEAN
ParStlWaitForBusyToClear (
    IN  PDEVICE_EXTENSION   Extension,
    IN  int                 nRegisterToWaitOn
    )
{
// The default timeout increased to 10secs as Fujitsu MO is found to set
// BUSY for >5secs for 0xA1 command.
    int nMaxRetrials  = MAX_RETRIES_FOR_10_SECS ;
    BOOLEAN    bRetVal =   FALSE ;

    while ( nMaxRetrials-- )
    {
// the following service will be implemented by the caller
// the driver can use the STLMPORT service.
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
        if ( ! ( ParStlReadIoPort ( Extension, nRegisterToWaitOn ) & ATA_ST_BUSY ) )
        {
// as busy has cleared, we return clear here
            bRetVal = TRUE ;
            break ;
        }
    }
    return  bRetVal ;
}

BOOLEAN
ParStlWaitForDrq (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    int nMaxRetrials  = MAX_RETRIES_FOR_5_SECS ;
    BOOLEAN    bRetVal =   FALSE ;
    while ( nMaxRetrials-- )
    {
        if ( ParStlReadIoPort ( Extension, ATA_TASK_STAT_REG ) & ATA_ST_DRQ )
        {
// as busy has cleared, we return clear here
            bRetVal = TRUE ;
            break ;
        }
// the following service will be implemented by the caller
// the driver can use the STLMPORT service.
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
    }
    return  bRetVal ;
}

BOOLEAN
ParStlWaitForIrq (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    int nMaxRetrials  = MAX_RETRIES_FOR_10_SECS ;
    BOOLEAN    bRetVal =   FALSE ;
    while ( nMaxRetrials-- )
    {
        if ( ParStlReadReg ( Extension, EP1284_TRANSFER_CONTROL_REG ) & XFER_IRQ_BIT )
        {
// as Irq has asserted, we return true here
            bRetVal = TRUE ;
            break ;
        }
        ParStlWaitForMicroSeconds ( DELAY_1MILLISECONDS ) ;
    }
    return  bRetVal ;
}

VOID
ParStlSet16BitOperation (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    int nModeReg ;

    nModeReg = ParStlReadReg ( Extension, EP1284_MODE_REGISTER ) ;

    if ( 0 == ( nModeReg & EP1284_ENABLE_16BIT ) )
    {
// as the bit is not already set, this needs to be set now
        ParStlWriteReg ( Extension, EP1284_MODE_REGISTER, nModeReg | EP1284_ENABLE_16BIT ) ;
    }
}

BOOLEAN
ParStlCheckIfEppDevice (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
// as EPPDEVs live only on EP1284 we break here
            break;
        }

        bReturnValue = ParStlCheckPersonalityForEppDevice(Extension) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckPersonalityForEppDevice (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, EP1284_PERSONALITY_REG ) ;
    if ( EPPDEV_SIGN == ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & PERSONALITY_MASK ) )
    {
// as the EPPDEV sign is found in the personality
// we break with success here
        bReturnValue   = TRUE ;
    }

    return bReturnValue ;
}

BOOLEAN
ParStlCheckIfFlash (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;

    do
    {
        if ( !IsEp1284Present() && !IsImpactPresent() && !IsEpatPlusPresent() )
        {
// Check the sign-on version checks for the existence of Shuttle
// adapter. If nothing is found, we break here.
            break ;
        }

// Perform a ATA-16bit check just in case, it turns out to be something else
        bReturnValue = ParStlCheckFlashPersonality(Extension) ;
    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN
ParStlCheckFlashPersonality (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE ;

    if ( IsEp1284Present() )
    {
// as the personality configuration check only works for
// Ep1284, confim its presence before the actual check.
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, EP1284_PERSONALITY_REG ) ;
        if ( FLASH_SIGN == ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & FLASH_PERSONALITY_MASK ) )
        {
// as the flash sign ATA-16bit device is found in the personality
// we break with success here
            bReturnValue   = TRUE ;
        }
    }
    else
    {
// always return true, if a shuttle adapter other than ep1284 is
// identified and assume it might be flash!
        bReturnValue    =   TRUE ;
    }

    return bReturnValue ;
}

BOOLEAN
ParStlCheckIfDazzle (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   ucSignature ;

    do
    {
        if ( !IsEp1284Present() )
        {
// Check for EP1284 presence, as Dazzle is ONLY on EP1284
// adapters. If the adapter is not EP1284, we break.
            break ;
        }

// Check whether any card insertion is detected, to eliminate
// possible flash adapters with the card in
        if ( TRUE == ParStlCheckCardInsertionStatus( Extension ) ) {
            break ;
        }

// code to read the pulled up pattern present on dazzle
// adapters.
        ParStlWriteReg( Extension, DAZ_SELECT_BLK, DAZ_BLK0 ) ;
        ucSignature = (UCHAR) ParStlReadReg( Extension, DAZ_REG1 ) ;

        if ( ( ucSignature == DAZ_CONFIGURED ) ||\
             ( ucSignature == DAZ_NOT_CONFIGURED ) ) {
            // the pulled up pattern generally found ONLY
            // on the DAZZLE adapter is found. So, we
            // conclude that it is a Dazzle adapter
                bReturnValue = TRUE ;
        }

    }
    while ( FALSE ) ;

    return  bReturnValue ;
}

BOOLEAN
ParStlCheckIfHiFD (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
        if ( FALSE == ParStlSelectAdapterSocket(Extension, SOCKET_1) )
        {
// as the socket 1 selection failed,
// we break out here.
            break ;
        }

// check for the ready status of the floppy controller,
// after clearing the reset bit of the floppy controller.

        if ( FALSE == ParStlHIFDCheckIfControllerReady(Extension) )
        {
// since the controller didnot wake up after the
// reset pin was asserted, we break here.

            break ;
        }

        if ( FALSE == ParStlHIFDCheckSMCController(Extension) )
        {
// as the SMC ID retrieval failed,
// we break out here.
            break ;
        }

        bReturnValue = TRUE ;

    }
    while ( FALSE ) ;
// Reset the socket to zero.
    ParStlSelectAdapterSocket(Extension, SOCKET_0);
    return bReturnValue ;
}

BOOLEAN
ParStlHIFDCheckIfControllerReady (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue    =   FALSE ;
    UCHAR   bySCRControlReg ;
    do
    {
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , SOCKET_CONTROL_REGISTER ) ;
        bySCRControlReg = (UCHAR) ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;
        bySCRControlReg |=  (UCHAR)PERIPHERAL_RESET_1 ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_10_MILLISEC ) ;

        ParStlWriteIoPort ( Extension, HIFD_DIGITAL_OUTPUT_REGISTER ,
                              0x00 ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_1_MILLISEC ) ;

        ParStlWriteIoPort ( Extension, HIFD_DIGITAL_OUTPUT_REGISTER ,
                              HIFD_DOR_RESET_BIT | HIFD_ENABLE_DMA_BIT ) ;
        ParStlWaitForMicroSeconds ( HIFD_WAIT_10_MILLISEC ) ;

        if ( HIFD_CONTROLLER_READY_STATUS == ParStlReadIoPort ( Extension, HIFD_MAIN_STATUS_REGISTER ) )
        {
            bReturnValue = TRUE ;
        }

        bySCRControlReg     &= ~(UCHAR)PERIPHERAL_RESET_1 ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , bySCRControlReg ) ;

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlHIFDCheckSMCController (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;
    do
    {
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_COMMAND_TO_CONTROLLER ) ;
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_COMMAND_TO_CONTROLLER ) ;
        ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_CTL_REG_0D ) ;
        if ( SMC_DEVICE_ID == ParStlReadIoPort ( Extension, HIFD_STATUS_REGISTER_B ) )
        {
            bReturnValue = TRUE ;
            ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_A , HIFD_CTL_REG_03 ) ;
            ParStlWriteIoPort ( Extension, HIFD_STATUS_REGISTER_B , SMC_ENABLE_MODE2 ) ;
        }
        ParStlWriteReg ( Extension, HIFD_STATUS_REGISTER_A , HIFD_TERMINATE_SEQUENCE ) ;

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

STL_DEVICE_TYPE
ParStlGetImpactDeviceType (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams,
    IN  int                 nPreferredDeviceType
    )
{
    IMPACT_DEVICE_TYPE      idtImpactDeviceType ;
    STL_DEVICE_TYPE         dtDeviceType = DEVICE_TYPE_NONE ;
    int                     nLocalPreferredDeviceType = nPreferredDeviceType ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACT_PERSONALITY_REG ) ;
    idtImpactDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) >> 4 ;

    switch ( idtImpactDeviceType )
    {
        case IMPACT_DEVICE_TYPE_ATA_ATAPI:

            // set the 16 bit mode of the adapter
            ParStlSet16BitOperation(Extension) ;

            if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension,atapiParams))
            {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
                if (TRUE == ParStlCheckIfAtapiDevice(Extension,atapiParams))
                {
// atapi identified
// Check for Impact LS-120 device
                    if ( TRUE == ParStlCheckIfImpactLS120(Extension, atapiParams))
                    {
                        dtDeviceType |= DEVICE_TYPE_LS120_BIT ;
                        break ;
                    }
                    dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                    break ;
                }

                if (TRUE == ParStlCheckIfAtaDevice(Extension, atapiParams))
                {
// ata identified
                    dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                    break;
                }
            }
            break ;

        case IMPACT_DEVICE_TYPE_CF:
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break ;

        case IMPACT_DEVICE_TYPE_PCMCIA_CF:
            dtDeviceType |= DEVICE_TYPE_PCMCIA_CF_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SSFDC:
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_MMC:
            dtDeviceType |= DEVICE_TYPE_MMC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_HIFD:
            dtDeviceType |= DEVICE_TYPE_HIFD_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SOUND:
            dtDeviceType |= DEVICE_TYPE_SOUND_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_FLP_TAPE_DSK:
            dtDeviceType |= DEVICE_TYPE_FLP_TAPE_DSK_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT:
            dtDeviceType |= DEVICE_TYPE_ATA_ATAPI_8BIT_BIT ;
            break;

        default:
            break;
    }

    return dtDeviceType & nPreferredDeviceType ;
}

STL_DEVICE_TYPE
ParStlGetImpactSDeviceType (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams,
    IN  int                 nPreferredDeviceType
    )
{
    IMPACT_DEVICE_TYPE      idtImpactDeviceType ;
    IMPACT_DEVICE_TYPE      idtImpactSDeviceType ;
    STL_DEVICE_TYPE         dtDeviceType = DEVICE_TYPE_NONE ;
    int                     nLocalPreferredDeviceType = nPreferredDeviceType ;

    ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACT_PERSONALITY_REG ) ;
    idtImpactDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) >> 4 ;

    switch ( idtImpactDeviceType )
    {
        case IMPACT_DEVICE_TYPE_ATA_ATAPI:

            // set the 16 bit mode of the adapter
            ParStlSet16BitOperation(Extension) ;

            if (TRUE == ParStlCheckIfAtaAtapiDevice(Extension,atapiParams))
            {
// necessary but not sufficient condition has passed
// proceed for sufficency checks
                if (TRUE == ParStlCheckIfAtapiDevice(Extension,atapiParams))
                {
// atapi identified
                    dtDeviceType |= DEVICE_TYPE_ATAPI_BIT;
                    break ;
                }

                if (TRUE == ParStlCheckIfAtaDevice(Extension,atapiParams))
                {
// ata identified
                    dtDeviceType |= DEVICE_TYPE_ATA_BIT;
                    break;
                }
            }
            break ;

        case IMPACT_DEVICE_TYPE_CF:
            dtDeviceType |= DEVICE_TYPE_FLASH_BIT;
            break ;

        case IMPACT_DEVICE_TYPE_PCMCIA_CF:
            dtDeviceType |= DEVICE_TYPE_PCMCIA_CF_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SSFDC:
            dtDeviceType |= DEVICE_TYPE_SSFDC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_MMC:
            dtDeviceType |= DEVICE_TYPE_MMC_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_HIFD:
            dtDeviceType |= DEVICE_TYPE_HIFD_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_SOUND:
            dtDeviceType |= DEVICE_TYPE_SOUND_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_FLP_TAPE_DSK:
            dtDeviceType |= DEVICE_TYPE_FLP_TAPE_DSK_BIT ;
            break;

        case IMPACT_DEVICE_TYPE_ATA_ATAPI_8BIT:
            dtDeviceType |= DEVICE_TYPE_ATA_ATAPI_8BIT_BIT ;
            break;

        case IMPACTS_EXT_PERSONALITY_PRESENT:
            ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER, IMPACTS_EXT_PERSONALITY_XREG ) ;
            idtImpactSDeviceType    = ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) ;
            dtDeviceType = DEVICE_TYPE_EXT_HWDETECT ;
            dtDeviceType |= idtImpactSDeviceType ;
            break ;

        default:
            break;
    }

    return dtDeviceType & nPreferredDeviceType ;
}

BOOLEAN
ParStlCheckIfLS120 (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == ParStlSelectAdapterSocket(Extension, SOCKET_1) )
        {
// as the socket 1 selection failed,
// we break out here.
            break ;
        }

// check for engine version.

        if ( LS120_ENGINE_VERSION == ParStlReadIoPort( Extension, LS120_ENGINE_VERSION_REGISTER ) )
        {
// if the ls120 engine version is correct, we have
// found LS120.

            bReturnValue    =   TRUE ;
        }

// Reset the socket to zero.
        ParStlSelectAdapterSocket ( Extension, SOCKET_0 ) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckIfImpactLS120 (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE ;
    BOOLEAN bLs120NameFound= TRUE ;
    char chLs120Name[] = "HU DlFpoyp";
    char *pszAtapiName = atapiParams->szAtapiNameString ;
    int  i , nMemoryOnBoard ;

    do
    {
        for ( i = 0 ;i < sizeof(chLs120Name)-1 ; i++ )
        {
            if ( pszAtapiName[i] != chLs120Name[i] )
            {
                bLs120NameFound = FALSE ;
                break ;
            }
        }
        if ( TRUE != bLs120NameFound )
        {
// as LS-120 name string is not found, we conclude that it is
// not LS-120
            break ;
        }
        nMemoryOnBoard =  ParStlGetMemorySize(Extension) ;
        if ( ( !IsShtlError ( nMemoryOnBoard ) ) && \
             ( nMemoryOnBoard ) )
        {
// there is memory on-board.
// hence, we return ls120 here
            bReturnValue = TRUE ;
            break ;
        }
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckIfMMC (
    IN  PDEVICE_EXTENSION   Extension,
    IN  OUT  PATAPIPARAMS   atapiParams
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
        if ( FALSE == IsEpatPlusPresent() )
        {
// as mmc device can exist only on EPAT Plus adapter only
// we break out of here
            break;
        }
        if ( TRUE == ParStlCheckIfAtaAtapiDevice (Extension,atapiParams) )
        {
// as an ATA/ATAPI device is probably present,
// we break out of here
            break;
        }
        bReturnValue = ParStlIsMMCEnginePresent(Extension) ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlIsMMCEnginePresent(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;

    do
    {
// check if the ATAPI signature is present in the cyl hi/lo
// registers. If present, it is definitely an ATAPI device
        if ( ( ParStlReadIoPort(Extension, CYLLOW_REG) == ATAPI_SIGN_LOW ) &&\
             ( ParStlReadIoPort(Extension, CYLHIGH_REG) == ATAPI_SIGN_HI ) )
        {
// as ATAPI signature is present, it cant be MMC
            break ;
        }

// write a zero pattern ( which will be a NOP for ATA/ATAPI devices )
// in the block size / possible ATA/ATAPI command register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_1);
        if ( MMC_TEST_PATTERN_1 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as the written value is not available, it means device present
// has responded to the written value, in a way different from
// how an MMC would have.
            break ;
        }

// write a test pattern in the freq register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_FREQ_SELECT_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_2);

// write another in the block size register
        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        ParStlWriteReg(Extension, MMC_ENGINE_DATA, MMC_TEST_PATTERN_3);

        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_FREQ_SELECT_REG);
        if ( MMC_TEST_PATTERN_2 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as we were not able to read back the written value
// we quit here
            break;
        }

        ParStlWriteReg(Extension, MMC_ENGINE_INDEX, MMC_BLOCK_SIZE_REG);
        if ( MMC_TEST_PATTERN_3 != ParStlReadReg(Extension, MMC_ENGINE_DATA) )
        {
// as we were not able to read back the written value
// we quit here
            break;
        }
// as all tests have passed, engine presence is confirmed
// here
        bReturnValue = TRUE ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckIfScsiDevice (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    do
    {
        if ( FALSE == IsEpstPresent() )
        {
// as SCSI devices live only on EPST we break here
            break;
        }

        bReturnValue = TRUE ;
    }
    while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckIfSSFDC (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN bReturnValue   = FALSE;
    UCHAR   byMakerCode = 0x00 , byDeviceCode = 0x00 ;
    do
    {
        if ( FALSE == IsEp1284Present() )
        {
// SSFDC lives on EP1284 alone, other than impact
// which is already taken care
            break;
        }

//check to see if the loop back of the EPCS and EPDO pins
//of the INDEX 00 register read the same. If so, it is
//SSFDC board characteristic
        ParStlWriteReg ( Extension, CONFIG_INDEX_REGISTER , 0x00 ) ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x10 ) ;
        ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x12 ) ;
        if ( 0x1A == ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) )
        {
            ParStlWriteReg ( Extension, CONFIG_DATA_REGISTER , 0x10 ) ;
            if ( ! ( ParStlReadReg ( Extension, CONFIG_DATA_REGISTER ) & 0x08 ) )
            {
//as they are equal, SSFDC present
                bReturnValue    =   TRUE ;
                break ;
            }
        }

    }
    while ( FALSE ) ;

    return bReturnValue ;
}

VOID
ParStlAssertIdleState (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    PUCHAR  CurrentPort, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentControl = CurrentPort + 2;

// place op-code for idle state in port base
    WRITE_PORT_UCHAR ( CurrentPort, (UCHAR) 0x00 ) ;
    KeStallExecutionProcessor( Delay );

// bring down DCR_INIT and DCR_STROBE
    WRITE_PORT_UCHAR ( CurrentControl, (UCHAR) STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );

// lift DCR_INIT and DCR_STROBE to high
    WRITE_PORT_UCHAR ( CurrentControl, (UCHAR) STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );
}

BOOLEAN
ParStlCheckAvisionScannerPresence(
        IN PDEVICE_EXTENSION Extension
    )
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   data;

    do {

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x08 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x08 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) != 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x02 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x02 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) != 0) {
            break ;
        }

        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;
        ParStlWriteReg( Extension, CONTROLPORT, 0x00 ) ;

        data = (UCHAR) ParStlReadReg( Extension, STATUSPORT);
        if((data & 0x80) == 0) {
            break ;
        }

        bReturnValue = TRUE ;

    } while ( FALSE ) ;

    return bReturnValue ;
}

BOOLEAN
ParStlCheckUMAXScannerPresence(
    IN PDEVICE_EXTENSION    Extension
    )
{
    UCHAR   commandPacket_[6] = {0x55,0xaa,0,0,0,0} ;
    PUCHAR  commandPacket ;
    USHORT  status;
    UCHAR   idx;
    PUCHAR  saveCommandPacket;
    ULONG   dataLength;

    ParStlWriteReg ( Extension, CONTROLPORT, 0 ) ;  // scannner reset
    KeStallExecutionProcessor ( 2000 ) ;            // 2 m.secs delay
    ParStlWriteReg ( Extension, CONTROLPORT, 0x0C ) ;

    commandPacket = commandPacket_ ;
    saveCommandPacket = commandPacket;

    if ( TRUE == ParStlSetEPPMode(Extension) ) {

        commandPacket+=2;
        dataLength = *(ULONG*)commandPacket;
        dataLength &= 0xffffff; //data bytes ordering (msb to lsb) will
                                // wrong .What we need here is whether the
                                // dataLength is 0 or not.

        commandPacket = saveCommandPacket;

        //Command phase

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700) != 0){
            return FALSE;      //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;     //TIMEOUT_ERROR);
        }

        for(idx=0; idx<= 6 ;idx++){

            if(status & 0x800){
                break;
            }

            status = ParStlEPPRead(Extension);
        }

        if(idx == 7){

            status = (status & 0xf800)  | 0x100;
            if ( status & 0x700 )
                return FALSE;
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;          //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *(commandPacket)++);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        status = ParStlEPPWrite(Extension, *commandPacket);
        if((status & 0x700 ) != 0){
            return FALSE;         //TIMEOUT_ERROR);
        }

        //Response phase

        status    =    ParStlEPPRead(Extension);
        commandPacket = saveCommandPacket;

        if((status & 0x700) == 0){

            if((commandPacket[5] == 0xc2)&& (dataLength == 0)){

                status = ParStlEPPRead(Extension);

                if((status & 0x0700) != 0){
                    return FALSE;  //TIMEOUT_ERROR);
                }
            }
        }

        return  TRUE;
    }
    return FALSE;
}

BOOLEAN
ParStlSetEPPMode(
    IN PDEVICE_EXTENSION    Extension
    )
{
    UCHAR   idx;
    BOOLEAN timeout = TRUE ;

    ParStlWriteReg( Extension, CONTROLPORT, 0x0C ) ;
    ParStlWriteReg( Extension, DATAPORT, 0x40 ) ;
    ParStlWriteReg( Extension, CONTROLPORT, 0x06 ) ;

    for(idx=0; idx<10; idx++){

        if((ParStlReadReg(Extension, STATUSPORT) & 0x78) == 0x38){

            timeout = FALSE;
            break;

        }

    }

    if(timeout == FALSE){

        ParStlWriteReg( Extension, CONTROLPORT,0x7 );
        timeout = TRUE;

        for(idx=0; idx<10; idx++){

            if((ParStlReadReg( Extension, STATUSPORT) & 0x78) == 0x38){
                timeout = FALSE;
                break;
            }

        }

        if(timeout == FALSE){

            ParStlWriteReg( Extension, CONTROLPORT,0x4 ) ;
            timeout = TRUE;

            for(idx=0; idx<10; idx++){

                if((ParStlReadReg( Extension, STATUSPORT) & 0xf8) == 0xf8){
                    timeout = FALSE;
                    break;
                }

            }

            if(timeout == FALSE){

                timeout = TRUE;

                ParStlWriteReg( Extension, CONTROLPORT, 0x5 );

                for(idx=0; idx<10; idx++){

                    if( ParStlReadReg( Extension, CONTROLPORT ) == 0x5){

                        timeout = FALSE;
                        break;

                    }
                }

                if(timeout == FALSE){

                    ParStlWriteReg( Extension, CONTROLPORT, 0x84) ;
                    return TRUE ;

                } // final check

            } // third check

        } // second check

    } // first check

    return(FALSE);
}

USHORT
ParStlEPPWrite(
    IN PDEVICE_EXTENSION    Extension,
    IN UCHAR                value
    )
{
    UCHAR   idx;
    USHORT  statusData;
    BOOLEAN timeout;

    timeout = TRUE;

    for(idx=0; idx<10; idx++){

        if( !( (statusData = (USHORT)ParStlReadReg( Extension, STATUSPORT)) & BUSY)){
            timeout = FALSE;
            break;
        }

    }

    if(timeout == TRUE){

        return(((statusData<<8) & 0xf800)|0x100);

    }

    ParStlWriteReg( Extension, EPPDATA0PORT,value );
    return(((statusData & 0xf8) << 8)|value);
}

USHORT
ParStlEPPRead(
    IN PDEVICE_EXTENSION Extension
    )
{
    UCHAR   idx;
    USHORT  statusData;
    USHORT  controlData;
    UCHAR   eppData;
    BOOLEAN timeout = TRUE ;

    for(idx=0; idx<10; idx++){

        if(!( (statusData = (USHORT)ParStlReadReg( Extension, STATUSPORT)) & PE)){
            timeout = FALSE;
            break;
        }

    }

    if(timeout == TRUE){

        return(((statusData<<8) & 0xf800)|0x100);

    }

    eppData = (UCHAR)ParStlReadReg( Extension, EPPDATA0PORT) ;
    return(((statusData & 0x00f8)<<8) | eppData );
}

int  __cdecl
ParStlReadReg (
    IN  PDEVICE_EXTENSION   Extension,
    IN  unsigned            reg
    )
{
    UCHAR   byReadNibble ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// select the register to read
    WRITE_PORT_UCHAR ( CurrentPort, (UCHAR)reg ) ;
    KeStallExecutionProcessor( Delay );

// issue nibble ctl signals to read
    WRITE_PORT_UCHAR ( CurrentControl, STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );
    WRITE_PORT_UCHAR ( CurrentControl, STB_INIT_AFXT_LO ) ;
    KeStallExecutionProcessor( Delay );

// read first nibble
    byReadNibble = READ_PORT_UCHAR (CurrentStatus);
    KeStallExecutionProcessor( Delay );
    byReadNibble >>= 4 ;

// issue nibble ctl signals to read
    WRITE_PORT_UCHAR ( CurrentControl, STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );

// read next nibble
    byReadNibble |= ( READ_PORT_UCHAR ( CurrentStatus ) & 0xF0 ) ;

    return (int)byReadNibble ;
}

int  __cdecl
ParStlWriteReg (
    IN  PDEVICE_EXTENSION   Extension,
    IN  unsigned            reg,
    IN  int                 databyte
    )
{
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// select the register to write
    WRITE_PORT_UCHAR ( CurrentPort, (UCHAR)( reg | 0x60 ) ) ;
    KeStallExecutionProcessor( Delay );

// write to printer ctl port
    WRITE_PORT_UCHAR ( CurrentControl, STB_INIT_LOW ) ;
    KeStallExecutionProcessor( Delay );

// write the requested data
    WRITE_PORT_UCHAR ( CurrentPort, (UCHAR)databyte ) ;
    KeStallExecutionProcessor( Delay );

// write to printer ctl port
    WRITE_PORT_UCHAR ( CurrentControl, STB_INIT_AFXT_HI ) ;
    KeStallExecutionProcessor( Delay );

    return SHTL_NO_ERROR ;
}

int __cdecl
ParStlReceiveData (
    IN  PDEVICE_EXTENSION   Extension,
    IN  VOID                *hostBufferPointer,
    IN  long                shuttleMemoryAddress,
    IN  unsigned            count
    )
{
    PCHAR   pchDataBuffer = (PCHAR) hostBufferPointer ;
    unsigned int i = 0 ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl ;
    ULONG   Delay = 5 ;

    CurrentPort = Extension->Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

// set the block address register to ATA/ATAPI data register,
// as this function is currently used ONLY for ATA/ATAPI devices
// ATA/ATAPI data register 0x1F0 corresponds to 0x18 value
    ParStlWriteReg ( Extension, EP1284_BLK_ADDR_REGISTER, 0x18 ) ;

// do the nibble block read sequence
// write the nibble block read op-code
    WRITE_PORT_UCHAR ( CurrentPort, OP_NIBBLE_BLOCK_READ ) ;
    KeStallExecutionProcessor( Delay );

// set control ports to correct signals.
    WRITE_PORT_UCHAR ( CurrentControl, STB_INIT_AFXT_LO ) ;
    KeStallExecutionProcessor( Delay );

// set data port to 0xFF
    WRITE_PORT_UCHAR ( CurrentPort, 0xFF ) ;
    KeStallExecutionProcessor( Delay );
    WRITE_PORT_UCHAR ( CurrentControl, INIT_AFXT_HIGH ) ;
    KeStallExecutionProcessor( Delay );

    do
    {
// low nibble is available in status after
// toggling sequences as in EP1284 manual
        WRITE_PORT_UCHAR ( CurrentControl, AFXT_LO_STB_HI ) ;
        KeStallExecutionProcessor( Delay );
        pchDataBuffer[i] = READ_PORT_UCHAR( CurrentStatus ) >> 4 ;
        KeStallExecutionProcessor( Delay );

// high nibble is available in status after
// toggling sequences as in EP1284 manual
        WRITE_PORT_UCHAR ( CurrentControl, AFXT_HI_STB_HI ) ;
        KeStallExecutionProcessor( Delay );

        pchDataBuffer[i++] |= ( READ_PORT_UCHAR ( CurrentStatus ) & 0xF0 ) ;
        KeStallExecutionProcessor( Delay );
        if ( count - 1 == i )
        {
// to read the last byte
            WRITE_PORT_UCHAR ( CurrentPort, 0xFD ) ;
            KeStallExecutionProcessor( Delay );
        }

        WRITE_PORT_UCHAR ( CurrentControl, AFXT_LO_STB_LO ) ;
        KeStallExecutionProcessor( Delay );

        pchDataBuffer[i] = READ_PORT_UCHAR ( CurrentStatus ) >> 4 ;
        KeStallExecutionProcessor( Delay );

        WRITE_PORT_UCHAR ( CurrentControl, AFXT_HI_STB_LO ) ;
        KeStallExecutionProcessor( Delay );
        pchDataBuffer[i++] |= ( READ_PORT_UCHAR ( CurrentStatus ) & 0xF0 ) ;
        KeStallExecutionProcessor( Delay );
    }
    while ( i <= count ) ;

// clean up
    WRITE_PORT_UCHAR ( CurrentPort, 0x00 ) ;
    KeStallExecutionProcessor( Delay );

// done
    return SHTL_NO_ERROR ;
}

int  __cdecl
ParStlReadIoPort (
    IN  PDEVICE_EXTENSION   Extension,
    IN  unsigned            reg
    )
{
    switch ( reg )
    {
    case 0x08 :
        reg = 0x16 ;
        break ;
    case 0x09 :
        reg = 0x17 ;
        break ;
    default :
        reg |= 0x18 ;
        break;
    }
    return ParStlReadReg ( Extension, reg ) ;
}

int  __cdecl
ParStlWriteIoPort (
    IN  PDEVICE_EXTENSION   Extension,
    IN  unsigned            reg,
    IN  int                 databyte
    )
{
    switch ( reg )
    {
    case 0x08 :
        reg = 0x16 ;
        break ;
    case 0x09 :
        reg = 0x17 ;
        break ;
    default :
        reg |= 0x18 ;
        break;
    }
    return ParStlWriteReg ( Extension, reg, databyte ) ;
}

int  __cdecl
ParStlGetMemorySize (
    IN  PDEVICE_EXTENSION   Extension
    )
{
    BOOLEAN    bReturnValue = FALSE ;
    UCHAR      byTempValue ;
    do
    {
// Issue reset through control register
// first try on DRAM
        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|SELECT_DRAM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// write to the first location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_1 ) ;
// write to the next location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_2 ) ;

        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|SELECT_DRAM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// read from the first and next location in the memory
        if ( ( TEST_PATTERN_1 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) &&\
             ( TEST_PATTERN_2 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) )
        {
            bReturnValue = TRUE ;
            break ;
        }

        if ( !IsImpactPresent () )
        {
// as only DRAM can be present on non-impact adapters
            break ;
        }
// Issue reset through control register
// and next try on SRAM
        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|RESET_PTR ;
        byTempValue &= SELECT_SRAM ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// write to the first location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_1 ) ;
// write to the next location in the memory
        ParStlWriteReg ( Extension, EP1284_BUFFER_DATA_REG, TEST_PATTERN_2 ) ;

        byTempValue = (UCHAR) ParStlReadReg ( Extension, EP1284_CONTROL_REG ) ;
        byTempValue |= ENABLE_MEM|RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;
        byTempValue &= ~RESET_PTR ;
        ParStlWriteReg ( Extension, EP1284_CONTROL_REG, byTempValue ) ;

// read from the first location in the memory
        if ( ( TEST_PATTERN_1 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) &&\
             ( TEST_PATTERN_2 == (UCHAR) ParStlReadReg ( Extension, EP1284_BUFFER_DATA_REG ) ) )
        {
            bReturnValue = TRUE ;
            break ;
        }
    }
    while ( FALSE ) ;
    return bReturnValue ;
}
// end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#define WANT_WDM

// 4115 - named type definition in parentheses
// 4127 - conditional expression is constant
// 4201 - nonstandard extension used : nameless struct/union
// 4214 - nonstandard extension used : bit field types other than int
// 4514 - unreferenced inline function has been removed
#pragma warning( disable : 4115 4127 4201 4214 4514 )

#include "ntddk.h"
#include "wdmguid.h"
#include "wmidata.h"

#define DVRH_USE_PARPORT_ECP_ADDR 1
#define DVRH_DELAY_THEORY 0
#include "parallel.h"

#include "debug.h"
#include "parclass.h"

// #pragma warning( push )
#pragma warning( disable : 4200 )
#include "ntddser.h"
// #pragma warning( pop )

#include "parlog.h"
#include "stdio.h"
#include "util.h"
#include "funcdecl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\parclass.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name :

    parclass.h

Abstract:

    Type definitions and data for the ParClass (parallel.sys) driver.

Author:


Revision History:

--*/


#include "ntddk.h"              // Windows NT DDK header
#include "parallel.h"           // Public (driver) interface to ParPort
#include "queue.h"              // dvrh's Queue
#include "test.h"
// #include "log.h" - structure moved to ntddpar.h
#include <wmilib.h>

#define ASSERT_EVENT(E) {                             \
    ASSERT((E)->Header.Type == NotificationEvent ||   \
           (E)->Header.Type == SynchronizationEvent); \
}

#define REQUEST_DEVICE_ID   TRUE
#define HAVE_PORT_KEEP_PORT TRUE

// enable scans for Legacy Zip?
extern ULONG ParEnableLegacyZip;

#define PAR_LGZIP_PSEUDO_1284_ID_STRING "MFG:IMG;CMD:;MDL:VP0;CLS:SCSIADAPTER;DES:IOMEGA PARALLEL PORT"
extern PCHAR ParLegacyZipPseudoId;

#define USE_PAR3QUERYDEVICEID 1

// Disable IRQL Raising in Parclass
//       0 - Run at passive
//       1 - Run everything at dispatch
// NOTE:  SPP.c will still raise IRQL to dispatch regardless of this setting.
//        This has not changed since NT 3.51.  Any takers?
#define DVRH_RAISE_IRQL 0

extern LARGE_INTEGER  AcquirePortTimeout; // timeout for IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE
extern ULONG          g_NumPorts;         // used to generate N in \Device\ParallelN ClassName
extern UNICODE_STRING RegistryPath;       // copy of the registry path passed to DriverEntry()

extern ULONG DumpDevExtTable;

// Driver Globals
extern ULONG SppNoRaiseIrql; // 0  == original raise IRQL behavior in SPP
                             // !0 == new behavior - disable raise IRQL 
                             //   and insert some KeDelayExecutionThread 
                             //   calls while waiting for peripheral response

extern ULONG DefaultModes;   // Upper USHORT is Reverse Default Mode, Lower is Forward Default Mode
                             // if == 0, or invalid, then use default of Nibble/Centronics

// used to slow down Spp writes to reduce CPU util caused by printing
extern ULONG gSppLoopDelay;         // how long to sleep each time we decide to do so (100ns units)
extern ULONG gSppLoopBytesPerDelay; // how many bytes to write between sleeps 

//
// Temporary Development Globals - used as switches in debug code
//
extern ULONG tdev1;
extern ULONG tdev2;

//
// remove this after PnP stops calling us back multiple 
//  times for the same interface arrival
//
#define USE_TEMP_FIX_FOR_MULTIPLE_INTERFACE_ARRIVAL 1

#define PAR_USE_BUFFER_READ_WRITE 1   // Used to select between WRITE_PORT_BUFFER_UCHAR/READ_PORT_BUFFER_UCHAR vs WRITE_PORT_UCHAR/READ_PORT_UCHAR in hwecp.c
#define DVRH_USE_CORRECT_PTRS   1

#define PAR_NO_FAST_CALLS 1
#if PAR_NO_FAST_CALLS
VOID
ParCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

NTSTATUS
ParCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
#else
#define ParCompleteRequest(a,b) IoCompleteRequest(a,b)
#define ParCallDriver(a,b) IoCallDriver(a,b)
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'CraP')
#endif

#define PARCLASS_POOL_TAG (ULONG) 'CraP'

// used as a check that this is a ParClass Device Extension
//  - used for debugging and by a ParClass debugger extension
//  - the value is arbitrary but must be consistent between the driver and the debugger extension
#define PARCLASS_EXTENSION_SIGNATURE 0xA55AC33C

// the following two variables are not currently used
extern ULONG OpenCloseReferenceCount;// Keep track of Creates vs Closes
extern PFAST_MUTEX OpenCloseMutex;   // protect access to OpenCloseReferenceCount
#if 0
#define ParClaimDriver()                        \
    ExAcquireFastMutex(OpenCloseMutex);         \
    if(++OpenCloseReferenceCount == 1) {        \
        MmResetDriverPaging(DriverEntry);       \
    }                                           \
    ExReleaseFastMutex(OpenCloseMutex);
#define ParReleaseDriver()                      \
    ExAcquireFastMutex(OpenCloseMutex);         \
    if(--OpenCloseReferenceCount == 0) {        \
        MmPageEntireDriver(DriverEntry);        \
    }                                           \
    ExReleaseFastMutex(OpenCloseMutex);
#else
#define ParClaimDriver()
#define ParReleaseDriver()
#endif

extern const PHYSICAL_ADDRESS PhysicalZero;

//
// For the above directory, the serial port will
// use the following name as the suffix of the serial
// ports for that directory.  It will also append
// a number onto the end of the name.  That number
// will start at 1.
//
#define DEFAULT_PARALLEL_NAME L"LPT"

//
// This is the parallel class name.
//
#define DEFAULT_NT_SUFFIX L"Parallel"


#define PARALLEL_DATA_OFFSET    0
#define PARALLEL_STATUS_OFFSET  1
#define PARALLEL_CONTROL_OFFSET 2
#define PARALLEL_REGISTER_SPAN  3

//
// Ieee 1284 constants (Protocol Families)
//
#define FAMILY_NONE             0x0
#define FAMILY_REVERSE_NIBBLE   0x1
#define FAMILY_REVERSE_BYTE     0x2
#define FAMILY_ECP              0x3
#define FAMILY_EPP              0x4
#define FAMILY_BECP             0x5
#define FAMILY_MAX              FAMILY_BECP

//
// For pnp id strings
//
#define MAX_ID_SIZE 256

// used to construct IEEE 1284.3 "Dot" name suffixes 
// table lookup for integer to WCHAR conversion
#define PAR_UNICODE_PERIOD L'.'
#define PAR_UNICODE_COLON  L':'


//
// DeviceStateFlags
//
#define PAR_DEVICE_STARTED             ((ULONG)0x00000001)
#define PAR_DEVICE_DELETED             ((ULONG)0x00000002) // IoDeleteDevice has been called
#define PAR_DEVICE_REMOVE_PENDING      ((ULONG)0x00000004) // received QUERY_REMOVE, waiting for REMOVE or CANCEL
#define PAR_DEVICE_REMOVED             ((ULONG)0x00000008) // received REMOVE
#define PAR_DEVICE_PAUSED              ((ULONG)0x00000010) // stop-pending, stopped, or remove-pending states
#define PAR_DEVICE_STOP_PENDING        ((ULONG)0x00000020) // received QUERY_STOP
#define PAR_DEVICE_DELETE_PENDING      ((ULONG)0x00000040) // we have started the process of deleting device object
#define PAR_DEVICE_HARDWARE_GONE       ((ULONG)0x00000080) // our hardware is gone
#define PAR_DEVICE_SURPRISE_REMOVAL    ((ULONG)0x00000100) // we received a SURPRISE_REMOVAL
#define PAR_DEVICE_PORT_REMOVE_PENDING ((ULONG)0x00000200) // our ParPort is in a Remove Pending State

//#define PAR_REV_MODE_SKIP_MASK    (CHANNEL_NIBBLE | BYTE_BIDIR | EPP_ANY)
#define PAR_REV_MODE_SKIP_MASK    (CHANNEL_NIBBLE | BYTE_BIDIR | EPP_ANY | ECP_ANY)
#define PAR_FWD_MODE_SKIP_MASK   (EPP_ANY | BOUNDED_ECP | ECP_HW_NOIRQ | ECP_HW_IRQ)
//#define PAR_FWD_MODE_SKIP_MASK  (EPP_ANY)
#define PAR_MAX_CHANNEL 127
#define PAR_COMPATIBILITY_RESET 300

typedef struct _DOT3DL_PCTL {
    PVOID           fnRead;
    PVOID           fnWrite;
    PVOID           fnReset;
    P12843_DL_MODES DataLinkMode;
    USHORT          CurrentPID;
    USHORT          FwdSkipMask;
    USHORT          RevSkipMask;
    UCHAR           DataChannel;
    UCHAR           ResetChannel;
    UCHAR           ResetByteCount;
    UCHAR           ResetByte;
    PKEVENT         Event;
    BOOLEAN         bEventActive;
} DOT3DL_PCTL, *PDOT3DL_PCTL;

#if PAR_TEST_HARNESS
    typedef struct _PAR_HARNS_PCTL {
        PVOID   fnRead;
        PVOID   fnRevSetInterfaceAddress;
        PVOID   fnEnterReverse;
        PVOID   fnExitReverse;
        PVOID   fnReadShadow;
        PVOID   fnHaveReadData;

        PVOID   fnWrite;
        PVOID   fnFwdSetInterfaceAddress;
        PVOID   fnEnterForward;
        PVOID   fnExitForward;

        UNICODE_STRING      deviceName;
        PDEVICE_OBJECT      device;
        PFILE_OBJECT        file;

    } PAR_HARNS_PCTL, *PPAR_HARNS_PCTL;
#endif


//
// ParClass DeviceObject structure
// 
//   - Lists the ParClass created PODO and all PDOs associated with a specific ParPort device
//
typedef struct _PAR_DEVOBJ_STRUCT {
    PUCHAR                    Controller;    // host controller address for devices in this structure
    PDEVICE_OBJECT            LegacyPodo;    // legacy or "raw" port device
    PDEVICE_OBJECT            EndOfChainPdo; // End-Of-Chain PnP device
    PDEVICE_OBJECT            Dot3Id0Pdo;    // 1284.3 daisy chain device, 1284.3 deviceID == 0
    PDEVICE_OBJECT            Dot3Id1Pdo;
    PDEVICE_OBJECT            Dot3Id2Pdo;
    PDEVICE_OBJECT            Dot3Id3Pdo;    // 1284.3 daisy chain device, 1284.3 deviceID == 3
    PDEVICE_OBJECT            LegacyZipPdo;  // Legacy Zip Drive
    PFILE_OBJECT              pFileObject;   // Need an open handle to ParPort device to prevent it
                                             //    from being removed out from under us
    struct _PAR_DEVOBJ_STRUCT *Next;
} PAR_DEVOBJ_STRUCT, *PPAR_DEVOBJ_STRUCT;

//
// Used in device extension for DeviceType field
//
#define PAR_DEVTYPE_FDO    0x00000001
#define PAR_DEVTYPE_PODO   0x00000002
#define PAR_DEVTYPE_PDO    0x00000004


//
// ParClass Device Extension:
//  - This is a common structure for ParClass (parallel.sys) FDO, PDOs, and PODOs.
//  - Fields that are not used by a particular type of device object are 0, NULL, or FALSE.
//    - FDO     == field used by Function  Device Object
//    - PDO     == field used by Physical  Device Objects
//    - PODO    == field used by Plain Old Device Objects - similar to a PDOs but no 
//                   device ID and is not reported to or known by PnP
//    - P[O]DO  == field used by PDOs and PODOs
//    - no mark == field used by all three types of ParClass device objects
// 
typedef struct _DEVICE_EXTENSION {

    ULONG   ExtensionSignature; // Used to increase our confidence that this is a ParClass extension

    ULONG   DeviceType;         // PAR_DEVTYPE_FDO=0x1, PODO=0x2, or PDO=0x4

    ULONG   DeviceStateFlags;   // Device State - See Device State Flags above

    UCHAR   Ieee1284_3DeviceId; // PDO - 0..3 is 1284.3 Daisy Chain device, 4 is End-Of-Chain Device, 5 is Legacy Zip
    BOOLEAN IsPdo;              // TRUE == this is either a PODO or a PDO - use DeviceIdString[0] to distinguish
    BOOLEAN EndOfChain;         // PODO - TRUE==NOT a 1284.3 daisy chain device - deprecated, use Ieee1284_3DeviceId==4 instead
    BOOLEAN PodoRegForWMI;      // has this PODO registered for WMI callbacks?

    // 0x10 on x86

    PDEVICE_OBJECT ParClassFdo; // P[O]DO - points to the ParClass FDO

    PDEVICE_OBJECT ParClassPdo; // FDO    - points to first P[O]DO in list of ParClass created PODOs and PDOs

    PDEVICE_OBJECT Next;        // P[O]DO - points to the next DO in the list of ParClass ejected P[O]DOs

    PDEVICE_OBJECT DeviceObject;// back pointer to our device object

    // 0x20 on x86

    PDEVICE_OBJECT PortDeviceObject;    // P[O]DO - points to the associated ParPort device object

    PFILE_OBJECT   PortDeviceFileObject;// P[O]DO - referenced pointer to a FILE created against PortDeviceObject

    UNICODE_STRING PortSymbolicLinkName;// P[O]DO - Symbolic link name of the associated ParPort device - used to open a FILE

    // 0x30 on x86

    PDEVICE_OBJECT PhysicalDeviceObject;// FDO - The PDO passed to ParPnPAddDevice

    PDEVICE_OBJECT ParentDeviceObject;  // FDO - parent DO returned by IoAttachDeviceToDeviceStack

    PIRP CurrentOpIrp;                  // IRP that our thread is currently processing

    PVOID NotificationHandle;           // PlugPlay Notification Handle

    // 0x40 on x86

    UNICODE_STRING ClassName;           // P[O]DO - ClassName passed to IoCreateDevice() as DeviceName

    UNICODE_STRING SymbolicLinkName;    // P[O]DO - SymbolicLinkName linked to ClassName using IoCreateUnprotectedSymbolicLink()

    // 0x50 on x86

    ULONG TimerStart;           // initial value used for countdown when starting an operation

    BOOLEAN CreatedSymbolicLink; // P[O]DO - did we create a Symbolic Link for this device?

    BOOLEAN UsePIWriteLoop;     // P[O]DO - do we want to use processor independant write loop?

    BOOLEAN Initialized;        // FALSE == we think that the device needs to be initialized

    //
    // Set to true before the deferred initialization routine is run
    // and false once it has completed.  Used to synchronize the deferred
    // initialization worker thread and the parallel port thread
    //
    BOOLEAN Initializing;

    LONG OpenCloseRefCount;     // count of Creates vs Closes - number of open FILEs against us,
                                //   used for QUERY_REMOVE decision: SUCCEED if count == 0, otherwise FAIL

    BOOLEAN ParPortDeviceGone;  // Is our ParPort device object gone, possibly surprise removed?

    BOOLEAN RegForPptRemovalRelations; // Are we registered for ParPort removal relations?

    UCHAR   Ieee1284Flags;   // is device Stl older 1284.3 spec device?

    UCHAR   spare1;          // return to dword alignment

    // 0x60 on x86
    USHORT        IdxForwardProtocol;  // see afpForward[] in ieee1284.c
    USHORT        IdxReverseProtocol;  // see arpReverse[] in ieee1284.c
    ULONG         CurrentEvent;        // IEEE 1284 event - see IEEE 1284-1994 spec
    P1284_PHASE   CurrentPhase;        // see parallel.h for enum def - PHASE_UNKNOWN, ..., PHASE_INTERRUPT_HOST
    P1284_HW_MODE PortHWMode;          // see parallel.h for enum def - HW_MODE_COMPATIBILITY, ..., HW_MODE_CONFIGURATION

    // 0x70 on x86
    FAST_MUTEX OpenCloseMutex;  // protect manipulation of OpenCloseRefCount

    // 0x90 on x86
    FAST_MUTEX DevObjListMutex; // protect manipulation of list of ParClass ejected DOs

    // 0xb0 on x86
    LIST_ENTRY WorkQueue;       // Queue of irps waiting to be processed.

    PVOID ThreadObjectPointer;  // pointer to a worker thread for this Device

    KSEMAPHORE RequestSemaphore;// dispatch routines use this to tell device worker thread that there is work to do

    //
    // PARALLEL_PORT_INFORMATION returned by IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO
    //
    PHYSICAL_ADDRESS                OriginalController;
    PUCHAR                          Controller;
    PUCHAR                          EcrController;
    ULONG                           SpanOfController;
    PPARALLEL_TRY_ALLOCATE_ROUTINE  TryAllocatePort; // nonblocking callback to allocate ParPort device
    PPARALLEL_FREE_ROUTINE          FreePort;        // callback to free ParPort device
    PPARALLEL_QUERY_WAITERS_ROUTINE QueryNumWaiters; // callback to query number of waiters in port allocation queue
    PVOID                           PortContext;     // context for callbacks to ParPort

    //
    // subset of PARALLEL_PNP_INFORMATION returned by IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO
    //
    ULONG                           HardwareCapabilities;
    PPARALLEL_SET_CHIP_MODE         TrySetChipMode;
    PPARALLEL_CLEAR_CHIP_MODE       ClearChipMode;
    PPARALLEL_TRY_SELECT_ROUTINE    TrySelectDevice;
    PPARALLEL_DESELECT_ROUTINE      DeselectDevice;
    ULONG                           FifoDepth;
    ULONG                           FifoWidth;

    BOOLEAN                         bAllocated; // have we allocated associated ParPort device?
                                                // Note: during some PnP processing we may have the port
                                                //   for a short duration without setting this value to TRUE

    ULONG BusyDelay;            // number of microseconds to wait after strobing a byte before checking the BUSY line.

    BOOLEAN BusyDelayDetermined;// Indicates if the BusyDelay parameter has been computed yet.

    PWORK_QUEUE_ITEM DeferredWorkItem; // Holds the work item used to defer printer initialization

    BOOLEAN TimeToTerminateThread; // TRUE == Thread should kill itself via PsTerminateSystemThread()

    // If the registry entry by the same name is set, run the parallel
    // thread at the priority we used for NT 3.5 - this solves some
    // cases where a dos app spinning for input in the foreground is
    // starving the parallel thread
    BOOLEAN UseNT35Priority;

    ULONG InitializationTimeout;// timeout in seconds to wait for device to respond to an initialization request
                                //  - default == 15 seconds
                                //  - value overridden by registry entry of same name
                                //  - we will spin for max amount if no device attached

    LARGE_INTEGER AbsoluteOneSecond;// constants that are cheaper to put here rather 
    LARGE_INTEGER OneSecond;        //   than in bss

    //
    // IEEE 1284 Mode support
    //
    BOOLEAN       Connected;           // are we currently negotiated into a 1284 mode?
    BOOLEAN       AllocatedByLockPort; // are we currently allocated via IOCTL_INTERNAL_LOCK_PORT?
    USHORT        spare4[2];
#if (1 == DVRH_USE_CORRECT_PTRS)
    PVOID         fnRead;       // Current pointer to a valid read funtion
    PVOID         fnWrite;      // Current pointer to a valid write Funtion
#endif
    LARGE_INTEGER IdleTimeout;         // how long do we hold the port on the caller's behalf following an operation?
    USHORT        ProtocolData[FAMILY_MAX];
    UCHAR         ForwardInterfaceAddress;
    UCHAR         ReverseInterfaceAddress;
    BOOLEAN       SetForwardAddress;
    BOOLEAN       SetReverseAddress;
    FAST_MUTEX    LockPortMutex;

    DEVICE_POWER_STATE DeviceState;// Current Device Power State
    SYSTEM_POWER_STATE SystemState;// Current System Power State

    ULONG         spare2;
    BOOLEAN       bShadowBuffer;
    Queue         ShadowBuffer;
    ULONG         spare3;
    BOOLEAN       bSynchWrites;      // TRUE if ECP HW writes should be synchronous
    BOOLEAN       bFirstByteTimeout; // TRUE if bus just reversed, means give the
                                     //   device some time to respond with some data
    BOOLEAN       bIsHostRecoverSupported;  // Set via IOCTL_PAR_ECP_HOST_RECOVERY.
                                            // HostRecovery will not be utilized unless this bit is set
    KEVENT        PauseEvent; // PnP dispatch routine uses this to pause worker thread during
                              //   during QUERY_STOP, STOP, and QUERY_REMOVE states

    USHORT        ProtocolModesSupported;
    USHORT        BadProtocolModes;

    PARALLEL_SAFETY       ModeSafety;
    BOOLEAN               IsIeeeTerminateOk;
    BOOLEAN               IsCritical; 
    DOT3DL_PCTL           P12843DL;

    // WMI
    PARALLEL_WMI_LOG_INFO log;
    WMILIB_CONTEXT        WmiLibContext;
    LONG                  WmiRegistrationCount;  // number of times this device has registered with WMI

    // PnP Query ID results
    UCHAR DeviceIdString[MAX_ID_SIZE];    // IEEE 1284 DeviceID string massaged/checksum'd to match INF form
    UCHAR DeviceDescription[MAX_ID_SIZE]; // "Manufacturer<SPACE>Model" from IEEE 1284 DeviceID string

#if PAR_TEST_HARNESS
    PAR_HARNS_PCTL        ParTestHarness;
#endif
    ULONG                 dummy; // dummy word to force RemoveLock to QuadWord alignment
    IO_REMOVE_LOCK RemoveLock;  // FDO - insure that other IRPs drain before FDO processes REMOVE_DEVICE
    PVOID                 HwProfileChangeNotificationHandle;
    ULONG                 ExtensionSignatureEnd; // keep this the last member in extension
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//
// Protocol structure definitions
//

typedef
BOOLEAN
(*PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_CONNECT_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

typedef
VOID
(*PPROTOCOL_DISCONNECT_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_ENTER_FORWARD_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_EXIT_FORWARD_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_ENTER_REVERSE_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_EXIT_REVERSE_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_READ_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

typedef
VOID
(*PPROTOCOL_READSHADOW_ROUTINE) (
    IN Queue *pShadowBuffer,
    IN PUCHAR  lpsBufPtr,
    IN ULONG   dCount,
    OUT ULONG *fifoCount
    );

typedef
BOOLEAN
(*PPROTOCOL_HAVEREADDATA_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension
    );

typedef
NTSTATUS
(*PPROTOCOL_WRITE_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

typedef
NTSTATUS
(*PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    );

typedef struct _FORWARD_PTCL {
    PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE     fnIsModeSupported;
    PPROTOCOL_CONNECT_ROUTINE               fnConnect;
    PPROTOCOL_DISCONNECT_ROUTINE            fnDisconnect;
    PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE fnSetInterfaceAddress;
    PPROTOCOL_ENTER_FORWARD_ROUTINE         fnEnterForward;
    PPROTOCOL_EXIT_FORWARD_ROUTINE          fnExitForward;
    PPROTOCOL_WRITE_ROUTINE                 fnWrite;
    USHORT                                  Protocol;
    USHORT                                  ProtocolFamily;
} FORWARD_PTCL, *PFORWARD_PTCL;

typedef struct _REVERSE_PTCL {
    PPROTOCOL_IS_MODE_SUPPORTED_ROUTINE     fnIsModeSupported;
    PPROTOCOL_CONNECT_ROUTINE               fnConnect;
    PPROTOCOL_DISCONNECT_ROUTINE            fnDisconnect;
    PPROTOCOL_SET_INTERFACE_ADDRESS_ROUTINE fnSetInterfaceAddress;
    PPROTOCOL_ENTER_REVERSE_ROUTINE         fnEnterReverse;
    PPROTOCOL_EXIT_REVERSE_ROUTINE          fnExitReverse;
    PPROTOCOL_READSHADOW_ROUTINE            fnReadShadow;
    PPROTOCOL_HAVEREADDATA_ROUTINE          fnHaveReadData;
    PPROTOCOL_READ_ROUTINE                  fnRead;
    USHORT                                  Protocol;
    USHORT                                  ProtocolFamily;
} REVERSE_PTCL, *PREVERSE_PTCL;

extern FORWARD_PTCL    afpForward[];
extern REVERSE_PTCL    arpReverse[];

//
// WARNING...Make sure that enumeration matches the protocol array...
//
typedef enum _FORWARD_MODE {

    FORWARD_FASTEST     = 0,
    BOUNDED_ECP_FORWARD = FORWARD_FASTEST,
    ECP_HW_FORWARD_NOIRQ,
    EPP_HW_FORWARD,
    EPP_SW_FORWARD,
    ECP_SW_FORWARD,
    IEEE_COMPAT_MODE,
    CENTRONICS_MODE,
    FORWARD_NONE

} FORWARD_MODE;

typedef enum _REVERSE_MODE {

    REVERSE_FASTEST     = 0,
    BOUNDED_ECP_REVERSE = REVERSE_FASTEST,
    ECP_HW_REVERSE_NOIRQ,
    EPP_HW_REVERSE,
    EPP_SW_REVERSE,
    ECP_SW_REVERSE,
    BYTE_MODE,
    NIBBLE_MODE,
    CHANNELIZED_NIBBLE_MODE,
    REVERSE_NONE

} REVERSE_MODE;

//
// Ieee Extensibility constants
//

#define NIBBLE_EXTENSIBILITY        0x00
#define BYTE_EXTENSIBILITY          0x01
#define CHANNELIZED_EXTENSIBILITY   0x08
#define ECP_EXTENSIBILITY           0x10
#define BECP_EXTENSIBILITY          0x18
#define EPP_EXTENSIBILITY           0x40
#define DEVICE_ID_REQ               0x04

//
// Bit Definitions in the status register.
//

#define PAR_STATUS_NOT_ERROR    0x08 //not error on device
#define PAR_STATUS_SLCT         0x10 //device is selected (on-line)
#define PAR_STATUS_PE           0x20 //paper empty
#define PAR_STATUS_NOT_ACK      0x40 //not acknowledge (data transfer was not ok)
#define PAR_STATUS_NOT_BUSY     0x80 //operation in progress

//
//  Bit Definitions in the control register.
//

#define PAR_CONTROL_STROBE      0x01 //to read or write data
#define PAR_CONTROL_AUTOFD      0x02 //to autofeed continuous form paper
#define PAR_CONTROL_NOT_INIT    0x04 //begin an initialization routine
#define PAR_CONTROL_SLIN        0x08 //to select the device
#define PAR_CONTROL_IRQ_ENB     0x10 //to enable interrupts
#define PAR_CONTROL_DIR         0x20 //direction = read
#define PAR_CONTROL_WR_CONTROL  0xc0 //the 2 highest bits of the control
                                     // register must be 1
//
// More bit definitions.
//

#define DATA_OFFSET         0
#define DSR_OFFSET          1
#define DCR_OFFSET          2

#define OFFSET_DATA     DATA_OFFSET // Put in for compatibility with legacy code
#define OFFSET_DSR      DSR_OFFSET  // Put in for compatibility with legacy code
#define OFFSET_DCR      DCR_OFFSET  // Put in for compatibility with legacy code

//
// Bit definitions for the DSR.
//

#define DSR_NOT_BUSY            0x80
#define DSR_NOT_ACK             0x40
#define DSR_PERROR              0x20
#define DSR_SELECT              0x10
#define DSR_NOT_FAULT           0x08

//
// More bit definitions for the DSR.
//

#define DSR_NOT_PTR_BUSY        0x80
#define DSR_NOT_PERIPH_ACK      0x80
#define DSR_WAIT                0x80
#define DSR_PTR_CLK             0x40
#define DSR_PERIPH_CLK          0x40
#define DSR_INTR                0x40
#define DSR_ACK_DATA_REQ        0x20
#define DSR_NOT_ACK_REVERSE     0x20
#define DSR_XFLAG               0x10
#define DSR_NOT_DATA_AVAIL      0x08
#define DSR_NOT_PERIPH_REQUEST  0x08

//
// Bit definitions for the DCR.
//

#define DCR_RESERVED            0xC0
#define DCR_DIRECTION           0x20
#define DCR_ACKINT_ENABLED      0x10
#define DCR_SELECT_IN           0x08
#define DCR_NOT_INIT            0x04
#define DCR_AUTOFEED            0x02
#define DCR_STROBE              0x01

//
// More bit definitions for the DCR.
//

#define DCR_NOT_1284_ACTIVE     0x08
#define DCR_ASTRB               0x08
#define DCR_NOT_REVERSE_REQUEST 0x04
#define DCR_NOT_HOST_BUSY       0x02
#define DCR_NOT_HOST_ACK        0x02
#define DCR_DSTRB               0x02
#define DCR_NOT_HOST_CLK        0x01
#define DCR_WRITE               0x01

#define DCR_NEUTRAL (DCR_RESERVED | DCR_SELECT_IN | DCR_NOT_INIT)

//
// Give a timeout of 300 seconds.  Some postscript printers will
// buffer up a lot of commands then proceed to render what they
// have.  The printer will then refuse to accept any characters
// until it's done with the rendering.  This render process can
// take a while.  We'll give it 300 seconds.
//
// Note that an application can change this value.
//
#define PAR_WRITE_TIMEOUT_VALUE 300


#ifdef JAPAN // IBM-J printers

//
// Support for IBM-J printers.
//
// When the printer operates in Japanese (PS55) mode, it redefines
// the meaning of parallel lines so that extended error status can
// be reported.  It is roughly compatible with PC/AT, but we have to
// take care of a few cases where the status looks like PC/AT error
// condition.
//
// Status      Busy /AutoFdXT Paper Empty Select /Fault
// ------      ---- --------- ----------- ------ ------
// Not RMR      1    1         1           1      1
// Head Alarm   1    1         1           1      0
// ASF Jam      1    1         1           0      0
// Paper Empty  1    0         1           0      0
// No Error     0    0         0           1      1
// Can Req      1    0         0           0      1
// Deselect     1    0         0           0      0
//
// The printer keeps "Not RMR" during the parallel port
// initialization, then it takes "Paper Empty", "No Error"
// or "Deselect".  Other status can be thought as an
// H/W error condition.
//
// Namely, "Not RMR" conflicts with PAR_NO_CABLE and "Deselect"
// should also be regarded as another PAR_OFF_LINE.  When the
// status is PAR_PAPER_EMPTY, the initialization is finished
// (we should not send init purlse again.)
//
// See ParInitializeDevice() for more information.
//
// [takashim]

#define PAR_OFF_LINE_COMMON( Status ) ( \
            (IsNotNEC_98) ? \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            !(Status & PAR_STATUS_SLCT) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            !(Status & PAR_STATUS_SLCT) \
             )

#define PAR_OFF_LINE_IBM55( Status ) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            ((Status & PAR_STATUS_SLCT) ^ PAR_STATUS_SLCT) && \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR))

#define PAR_PAPER_EMPTY2( Status ) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_PE) && \
            ((Status & PAR_STATUS_SLCT) ^ PAR_STATUS_SLCT) && \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR))

//
// Redefine this for Japan.
//

#define PAR_OFF_LINE( Status ) ( \
            PAR_OFF_LINE_COMMON( Status ) || \
            PAR_OFF_LINE_IBM55( Status ))

#else // JAPAN
//
// Busy, not select, not error
//
// !JAPAN

#define PAR_OFF_LINE( Status ) ( \
            (IsNotNEC_98) ? \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            !(Status & PAR_STATUS_SLCT) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            !(Status & PAR_STATUS_SLCT) \
            )

#endif // JAPAN

//
// Busy, PE
//

#define PAR_PAPER_EMPTY( Status ) ( \
            (Status & PAR_STATUS_PE) )

//
// error, ack, not busy
//

#define PAR_POWERED_OFF( Status ) ( \
            (IsNotNEC_98) ? \
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_NOT_ACK) ^ PAR_STATUS_NOT_ACK) && \
            (Status & PAR_STATUS_NOT_BUSY) : \
\
            ((Status & PAR_STATUS_NOT_ERROR) ^ PAR_STATUS_NOT_ERROR) && \
            (Status & PAR_STATUS_NOT_ACK) && \
            (Status & PAR_STATUS_NOT_BUSY) \
            )

//
// not error, not busy, not select
//

#define PAR_NOT_CONNECTED( Status ) ( \
            (Status & PAR_STATUS_NOT_ERROR) && \
            (Status & PAR_STATUS_NOT_BUSY) &&\
            !(Status & PAR_STATUS_SLCT) )

//
// not error, not busy
//

#define PAR_OK(Status) ( \
            (Status & PAR_STATUS_NOT_ERROR) && \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            (Status & PAR_STATUS_NOT_BUSY) )

//
// busy, select, not error
//

#define PAR_POWERED_ON(Status) ( \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_SLCT) && \
            (Status & PAR_STATUS_NOT_ERROR))

//
// busy, not error
//

#define PAR_BUSY(Status) (\
             (( Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
             ( Status & PAR_STATUS_NOT_ERROR ) )

//
// selected
//

#define PAR_SELECTED(Status) ( \
            ( Status & PAR_STATUS_SLCT ) )

//
// No cable attached.
//

#define PAR_NO_CABLE(Status) ( \
            (IsNotNEC_98) ?                                           \
            ((Status & PAR_STATUS_NOT_BUSY) ^ PAR_STATUS_NOT_BUSY) && \
            (Status & PAR_STATUS_NOT_ACK) &&                          \
            (Status & PAR_STATUS_PE) &&                               \
            (Status & PAR_STATUS_SLCT) &&                             \
            (Status & PAR_STATUS_NOT_ERROR) :                         \
                                                                      \
            (Status & PAR_STATUS_NOT_BUSY) &&                         \
            (Status & PAR_STATUS_NOT_ACK) &&                          \
            (Status & PAR_STATUS_PE) &&                               \
            (Status & PAR_STATUS_SLCT) &&                             \
            (Status & PAR_STATUS_NOT_ERROR)                           \
            )

//
// not error, not busy, selected.
//

#define PAR_ONLINE(Status) (                              \
            (Status & PAR_STATUS_NOT_ERROR) &&            \
            (Status & PAR_STATUS_NOT_BUSY) &&             \
            ((Status & PAR_STATUS_PE) ^ PAR_STATUS_PE) && \
            (Status & PAR_STATUS_SLCT) )


//BOOLEAN
//ParCompareGuid(
//  IN LPGUID guid1,
//  IN LPGUID guid2
//  )
//
#define ParCompareGuid(g1, g2)  (                                    \
        ( (g1) == (g2) ) ?                                           \
        TRUE :                                                       \
        RtlCompareMemory( (g1), (g2), sizeof(GUID) ) == sizeof(GUID) \
        )


//VOID StoreData(
//      IN PUCHAR RegisterBase,
//      IN UCHAR DataByte
//      )
// Data must be on line before Strobe = 1;
// Strobe = 1, DIR = 0
// Strobe = 0
//
// We change the port direction to output (and make sure stobe is low).
//
// Note that the data must be available at the port for at least
// .5 microseconds before and after you strobe, and that the strobe
// must be active for at least 500 nano seconds.  We are going
// to end up stalling for twice as much time as we need to, but, there
// isn't much we can do about that.
//
// We put the data into the port and wait for 1 micro.
// We strobe the line for at least 1 micro
// We lower the strobe and again delay for 1 micro
// We then revert to the original port direction.
//
// Thanks to Olivetti for advice.
//

#define StoreData(RegisterBase,DataByte)                            \
{                                                                   \
    PUCHAR _Address = RegisterBase;                                 \
    UCHAR _Control;                                                 \
    _Control = GetControl(_Address);                                \
    ASSERT(!(_Control & PAR_CONTROL_STROBE));                       \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(PAR_CONTROL_STROBE | PAR_CONTROL_DIR)) \
        );                                                          \
    WRITE_PORT_UCHAR(                                               \
        _Address+PARALLEL_DATA_OFFSET,                              \
        (UCHAR)DataByte                                             \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)((_Control | PAR_CONTROL_STROBE) & ~PAR_CONTROL_DIR) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)(_Control & ~(PAR_CONTROL_STROBE | PAR_CONTROL_DIR)) \
        );                                                          \
    KeStallExecutionProcessor((ULONG)1);                            \
    StoreControl(                                                   \
        _Address,                                                   \
        (UCHAR)_Control                                             \
        );                                                          \
}

//UCHAR
//GetControl(
//  IN PUCHAR RegisterBase
//  )
#define GetControl(RegisterBase) \
    (READ_PORT_UCHAR((RegisterBase)+PARALLEL_CONTROL_OFFSET))


//VOID
//StoreControl(
//  IN PUCHAR RegisterBase,
//  IN UCHAR ControlByte
//  )
#define StoreControl(RegisterBase,ControlByte)  \
{                                               \
    WRITE_PORT_UCHAR(                           \
        (RegisterBase)+PARALLEL_CONTROL_OFFSET, \
        (UCHAR)ControlByte                      \
        );                                      \
}


//UCHAR
//GetStatus(
//  IN PUCHAR RegisterBase
//  )

#define GetStatus(RegisterBase) \
    (READ_PORT_UCHAR((RegisterBase)+PARALLEL_STATUS_OFFSET))


//
// Function prototypes
//

//
// ieee1284.c
//

VOID
IeeeTerminate1284Mode(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
IeeeEnter1284Mode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Extensibility
    );

VOID
IeeeDetermineSupportedProtocols(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
IeeeNegotiateBestMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    );

NTSTATUS
IeeeNegotiateMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  USHORT              usReadMask,
    IN  USHORT              usWriteMask
    );

//
// port.c
//

NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PDEVICE_EXTENSION   Extension
    );

VOID
ParReleasePortInfoToPortDevice(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParFreePort(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

BOOLEAN
ParAllocPort(
    IN  PDEVICE_EXTENSION   Extension
    );

PDEVICE_OBJECT
ParGetPortObjectFromLinkName(
    IN  PUNICODE_STRING     SymbolicLinkName,
    IN  PDEVICE_EXTENSION   Extension
    );

//
// parpnp.c
//
#ifndef STATIC_LOAD

NTSTATUS
ParPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    );

NTSTATUS
ParParallelPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParCheckParameters(
    IN OUT  PDEVICE_EXTENSION   Extension
    );

#endif

//
// oldinit.c
//

#ifdef STATIC_LOAD

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath
    );

BOOLEAN
ParMakeNames(
    IN  ULONG           ParallelPortNumber,
    OUT PUNICODE_STRING PortName,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    );

VOID
ParInitializeClassDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath,
    IN  ULONG           ParallelPortNumber
    );

VOID
ParCheckParameters(
    IN      PUNICODE_STRING     RegistryPath,
    IN OUT  PDEVICE_EXTENSION   Extension
    );

#endif

//
// parloop.c
//

ULONG
SppWriteLoop(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite
    );

//
// parclass.c
//

VOID
ParLogError(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PDEVICE_OBJECT      DeviceObject OPTIONAL,
    IN  PHYSICAL_ADDRESS    P1,
    IN  PHYSICAL_ADDRESS    P2,
    IN  ULONG               SequenceNumber,
    IN  UCHAR               MajorFunctionCode,
    IN  UCHAR               RetryCount,
    IN  ULONG               UniqueErrorValue,
    IN  NTSTATUS            FinalStatus,
    IN  NTSTATUS            SpecificIOStatus
    );

NTSTATUS
ParCreateOpen(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParInternalDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParQueryInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParSetInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParExportedNegotiateIeeeMode(
    IN PDEVICE_EXTENSION  Extension,
	IN USHORT             ModeMaskFwd,
	IN USHORT             ModeMaskRev,
    IN PARALLEL_SAFETY    ModeSafety,
	IN BOOLEAN            IsForward
    );

NTSTATUS
ParExportedTerminateIeeeMode(
    IN PDEVICE_EXTENSION   Extension
    );

//////////////////////////////////////////////////////////////////
//  Modes of operation
//////////////////////////////////////////////////////////////////

//
// spp.c
//

NTSTATUS
ParEnterSppMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    );

ULONG
SppCheckBusyDelay(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    );

NTSTATUS
SppWrite(
    IN  PDEVICE_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    );

VOID
ParTerminateSppMode(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
SppQueryDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PUCHAR              DeviceIdBuffer,
    IN  ULONG               BufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    );

//
// sppieee.c
//
NTSTATUS
SppIeeeWrite(
    IN  PDEVICE_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    );

//
// nibble.c
//

BOOLEAN
ParIsChannelizedNibbleSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
BOOLEAN
ParIsNibbleSupported(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEnterNibbleMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

NTSTATUS
ParEnterChannelizedNibbleMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateNibbleMode(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParNibbleModeRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// Byte.c
//

BOOLEAN
ParIsByteSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterByteMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateByteMode(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParByteModeRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// epp.c
//

NTSTATUS
ParEppSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    );

//
// hwepp.c
//

BOOLEAN
ParIsEppHwSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterEppHwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

VOID
ParTerminateEppHwMode(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEppHwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppHwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// swepp.c
//

BOOLEAN
ParIsEppSwWriteSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
BOOLEAN
ParIsEppSwReadSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterEppSwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateEppSwMode(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEppSwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppSwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

//
// ecp.c and swecp.c
//

NTSTATUS
ParEcpEnterForwardPhase (
    IN  PDEVICE_EXTENSION   Extension
    );

BOOLEAN
ParEcpHaveReadData (
    IN  PDEVICE_EXTENSION   Extension
    );

BOOLEAN
ParIsEcpSwWriteSupported(
    IN  PDEVICE_EXTENSION   Extension
    );

BOOLEAN
ParIsEcpSwReadSupported(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEnterEcpSwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

VOID 
ParCleanupSwEcpPort(
    IN  PDEVICE_EXTENSION   Extension
    );
    
VOID
ParTerminateEcpMode(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    );

NTSTATUS
ParEcpSwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpSwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpForwardToReverse(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpReverseToForward(
    IN  PDEVICE_EXTENSION   Extension
    );

//
// hwecp.c
//

BOOLEAN
ParEcpHwHaveReadData (
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwExitForwardPhase (
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwEnterReversePhase (
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwExitReversePhase (
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParEcpHwDrainShadowBuffer(IN Queue *pShadowBuffer,
                            IN PUCHAR  lpsBufPtr,
                            IN ULONG   dCount,
                            OUT ULONG *fifoCount);

NTSTATUS
ParEcpHwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpHwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEcpHwSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    );

NTSTATUS
ParEnterEcpHwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

BOOLEAN
ParIsEcpHwSupported(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEcpHwSetupPhase(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParTerminateHwEcpMode(
    IN  PDEVICE_EXTENSION   Extension
    );

//
// becp.c
//

NTSTATUS
ParBecpExitReversePhase(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParBecpRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParEnterBecpMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );

BOOLEAN
ParIsBecpSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
VOID
ParTerminateBecpMode(
    IN  PDEVICE_EXTENSION   Extension
    );

//
// p12843dl.c
//
NTSTATUS
ParDot3Connect(
    IN  PDEVICE_EXTENSION    Extension
    );

VOID
ParDot3CreateObject(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR DOT3DL,
    IN PUCHAR DOT3C
    );

VOID
ParDot4CreateObject(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR DOT4DL
    );

VOID
ParDot3ParseModes(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR DOT3M
    );

VOID
ParMLCCreateObject(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR CMDField
    );

VOID
ParDot3DestroyObject(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParDot3Disconnect(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParDot3Read(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

NTSTATUS
ParDot3Write(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );

typedef
NTSTATUS
(*PDOT3_RESET_ROUTINE) (
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParMLCCompatReset(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParMLCECPReset(
    IN  PDEVICE_EXTENSION   Extension
    );

#if DBG
VOID
ParInitDebugLevel (
    IN PUNICODE_STRING RegistryPath
   );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\queue.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    queue.h

Abstract:

   Creates a simple Queue that works in Kernel Mode.

Author:

    Robbie Harris (Hewlett-Packard) 22-May-1998

Environment:

    Kernel mode

Revision History :

--*/
#ifndef _QUEUE_
#define _QUEUE_

typedef struct _Queue {
    int     head;
    int     max;
    int     tail;
    UCHAR   *theArray;
} Queue, *PQueue;

void Queue_Create(Queue *pQueue, int size);
BOOLEAN Queue_Delete(Queue *pQueue);
BOOLEAN Queue_Dequeue(Queue *pQueue, PUCHAR data);
BOOLEAN Queue_Enqueue(Queue *pQueue, UCHAR data);
BOOLEAN Queue_GarbageCollect(Queue *pQueue); 
BOOLEAN Queue_IsEmpty(Queue *pQueue);
BOOLEAN Queue_IsFull(Queue *pQueue);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\pnp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    parpnp.c

Abstract:

    This file contains the main PnP functions.

      see:
        - pnpfdo.c   for AddDevice and FDO handling of PnP IRPs
        - pnppdo.c   for PDO handling of PnP IRPs
        - pnpnotfy.c for PnP callback entry points
        - pnputil.c  for PnP utility functions

Author:

    Timothy T. Wells

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

// used to construct 1284.3 "Dot" name suffixes 
// table lookup for integer to WCHAR conversion
WCHAR   ParInt2Wchar[] = { L'0', L'1', L'2', L'3' };

//
// Keep track of the number of parallel port devices created...
//
ULONG g_NumPorts = 0;

LARGE_INTEGER AcquirePortTimeout;

UNICODE_STRING RegistryPath = {0,0,0};

NTSTATUS
ParRegisterForParportRemovalRelations( 
    IN PDEVICE_EXTENSION Extension 
    ) 
{
    NTSTATUS                  status;
    PARPORT_REMOVAL_RELATIONS pptRemovalRelations;
    PDEVICE_OBJECT            portDevObj = Extension->PortDeviceObject;

    if( Extension->RegForPptRemovalRelations ) {
        // already registered - don't do it again
        return STATUS_SUCCESS;
    }

    pptRemovalRelations.DeviceObject = Extension->DeviceObject;
    pptRemovalRelations.Flags        = 0;
    pptRemovalRelations.DeviceName   = &Extension->ClassName;

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_REGISTER_FOR_REMOVAL_RELATIONS, portDevObj,
                                       &pptRemovalRelations, sizeof(PARPORT_REMOVAL_RELATIONS),
                                       NULL, 0, NULL);
    if( NT_SUCCESS( status ) ) {
        Extension->RegForPptRemovalRelations  = TRUE;
    }

    return status;
}

NTSTATUS
ParUnregisterForParportRemovalRelations( 
    IN PDEVICE_EXTENSION Extension 
    ) 
{
    NTSTATUS                  status;
    PARPORT_REMOVAL_RELATIONS pptRemovalRelations;
    PDEVICE_OBJECT            portDevObj = Extension->PortDeviceObject;

    if( !Extension->RegForPptRemovalRelations ) {
        // we're not registered - don't try to unregister
        return STATUS_SUCCESS;
    }

    if( Extension->ParPortDeviceGone ) {
        // ParPort device is already gone - probably surprise removed
        //   - don't try to send IOCTL or we will likely bugcheck
        return STATUS_SUCCESS;
    }

    pptRemovalRelations.DeviceObject = Extension->DeviceObject;
    pptRemovalRelations.Flags        = 0;
    pptRemovalRelations.DeviceName   = &Extension->ClassName;

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_UNREGISTER_FOR_REMOVAL_RELATIONS, portDevObj,
                                       &pptRemovalRelations, sizeof(PARPORT_REMOVAL_RELATIONS),
                                       NULL, 0, NULL);
    if( NT_SUCCESS( status ) ) {
        Extension->RegForPptRemovalRelations  = FALSE;
    }

    return status;
}

PCHAR
Par3QueryDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString, // TRUE ==  include the 2 size bytes in the returned string
                                              // FALSE == discard the 2 size bytes
    IN BOOLEAN              bBuildStlDeviceId
    )
/*++

  This is the replacement function for SppQueryDeviceId.

  This function uses the caller supplied buffer if the supplied buffer
    is large enough to hold the device id. Otherwise, a buffer is
    allocated from paged pool to hold the device ID and a pointer to
    the allocated buffer is returned to the caller. The caller determines
    whether a buffer was allocated by comparing the returned PCHAR with
    the DeviceIdBuffer parameter passed to this function. A NULL return
    value indicates that an error occurred.

    *** this function assumes that the caller has already acquired
          the port (and selected the device if needed in the case
          of a 1284.3 daisy chain device).

    *** If this function returns a pointer to a paged pool allocation then
          the caller is responsible for freeing the buffer when it is no
          longer needed.

--*/
{
    PUCHAR              Controller = Extension->Controller;
    NTSTATUS            Status;
    UCHAR               idSizeBuffer[2];
    ULONG               bytesToRead;
    ULONG               bytesRead = 0;
    USHORT              deviceIdSize;
    USHORT              deviceIdBufferSize;
    PCHAR               deviceIdBuffer;
    PCHAR               readPtr;
    BOOLEAN             allocatedBuffer = FALSE;

    ParDumpV( ("Enter pnp::Par3QueryDeviceId: Controller=%x\n", Controller) );
                    
    if( TRUE == bBuildStlDeviceId ) {
        // if this is a legacy stl, forward call to special handler
        return ParStlQueryStlDeviceId(Extension, 
                                          CallerDeviceIdBuffer, CallerBufferSize,
                                          DeviceIdSize, bReturnRawString);
    }

    if( Extension->Ieee1284_3DeviceId == DOT3_LEGACY_ZIP_ID ) {
        // if this is a legacy Zip, forward call to special handler
        return Par3QueryLegacyZipDeviceId(Extension, 
                                          CallerDeviceIdBuffer, CallerBufferSize,
                                          DeviceIdSize, bReturnRawString);
    }

    //
    // Take a 40ms nap - there is at least one printer that can't handle
    //   back to back 1284 device ID queries without a minimum 20-30ms delay
    //   between the queries which breaks PnP'ing the printer
    //
    if( KeGetCurrentIrql() == PASSIVE_LEVEL ) {
        LARGE_INTEGER delay;
        delay.QuadPart = - 10 * 1000 * 40; // 40 ms
        KeDelayExecutionThread( KernelMode, FALSE, &delay );
    }

    *DeviceIdSize = 0;

    //
    // If we are currently connected to the peripheral via any 1284 mode
    //   other than Compatibility/Spp mode (which does not require an IEEE
    //   negotiation), we must first terminate the current mode/connection.
    // 
    // dvdf - RMT - what if we are connected in a reverse mode?
    //
    if( (Extension->Connected) && (afpForward[Extension->IdxForwardProtocol].fnDisconnect) ) {
        afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
    }


    //
    // Negotiate the peripheral into nibble device id mode.
    //
    Status = ParEnterNibbleMode(Extension, REQUEST_DEVICE_ID);
    if( !NT_SUCCESS(Status) ) {
        ParDumpV( ("pnp::Par3QueryDeviceId: call to ParEnterNibbleMode FAILED\n") );
        ParTerminateNibbleMode(Extension);
        return NULL;
    }


    //
    // Read first two bytes to get the total (including the 2 size bytes) size 
    //   of the Device Id string.
    //
    bytesToRead = 2;
    Status = ParNibbleModeRead(Extension, idSizeBuffer, bytesToRead, &bytesRead);
    if( !NT_SUCCESS( Status ) || ( bytesRead != bytesToRead ) ) {
        ParDumpV( ("pnp::Par3QueryDeviceId: read of DeviceID size FAILED\n") );
        return NULL;
    }


    //
    // Compute size of DeviceId string (including the 2 byte size prefix)
    //
    deviceIdSize = (USHORT)( idSizeBuffer[0]*0x100 + idSizeBuffer[1] );
    ParDumpV( ("pnp::Par3QueryDeviceId: DeviceIdSize (including 2 size bytes) reported as %d\n", deviceIdSize) );


    //
    // Allocate a buffer to hold the DeviceId string and read the DeviceId into it.
    //
    if( bReturnRawString ) {
        //
        // Caller wants the raw string including the 2 size bytes
        //
        *DeviceIdSize      = deviceIdSize;
        deviceIdBufferSize = (USHORT)(deviceIdSize + sizeof(CHAR));     // ID size + ID + terminating NULL
    } else {
        //
        // Caller does not want the 2 byte size prefix
        //
        *DeviceIdSize      = deviceIdSize - 2*sizeof(CHAR);
        deviceIdBufferSize = (USHORT)(deviceIdSize - 2*sizeof(CHAR) + sizeof(CHAR)); //           ID + terminating NULL
    }


    //
    // If caller's buffer is large enough use it, otherwise allocate a buffer
    //   to hold the device ID
    //
    if( CallerDeviceIdBuffer && (CallerBufferSize >= deviceIdBufferSize) ) {
        //
        // Use caller's buffer - *** NOTE: we are creating an alias for the caller buffer
        //
        deviceIdBuffer = CallerDeviceIdBuffer;
        ParDumpV( ("pnp::Par3QueryDeviceId: using Caller supplied buffer\n") );
    } else {
        //
        // Either caller did not supply a buffer or supplied a buffer that is not
        //   large enough to hold the device ID, so allocate a buffer.
        //
        ParDumpV( ("pnp::Par3QueryDeviceId: Caller's Buffer TOO_SMALL - CallerBufferSize= %d, deviceIdBufferSize= %d\n",
                   CallerBufferSize, deviceIdBufferSize) );
        ParDumpV( ("pnp::Par3QueryDeviceId: will allocate and return ptr to buffer\n") );
        deviceIdBuffer = (PCHAR)ExAllocatePool(PagedPool, deviceIdBufferSize);
        if( !deviceIdBuffer ) {
            ParDumpV( ("pnp::Par3QueryDeviceId: ExAllocatePool FAILED\n") );
            return NULL;
        }
        allocatedBuffer = TRUE; // note that we allocated our own buffer rather than using caller's buffer
    }


    //
    // NULL out the ID buffer to be safe
    //
    RtlZeroMemory( deviceIdBuffer, deviceIdBufferSize );


    //
    // Does the caller want the 2 byte size prefix?
    //
    if( bReturnRawString ) {
        //
        // Yes, caller wants the size prefix. Copy prefix to buffer to return.
        //
        *(deviceIdBuffer+0) = idSizeBuffer[0];
        *(deviceIdBuffer+1) = idSizeBuffer[1];
        readPtr = deviceIdBuffer + 2;
    } else {
        //
        // No, discard size prefix
        //
        readPtr = deviceIdBuffer;
    }


    //
    // Read remainder of DeviceId from device
    //
    bytesToRead = deviceIdSize -  2; // already have the 2 size bytes
    Status = ParNibbleModeRead(Extension, readPtr, bytesToRead, &bytesRead);
            

    ParTerminateNibbleMode( Extension );
    WRITE_PORT_UCHAR(Controller + DCR_OFFSET, DCR_NEUTRAL);

    if( !NT_SUCCESS(Status) || (bytesRead < 1) ) {
        if( allocatedBuffer ) {
            // we're using our own allocated buffer rather than a caller supplied buffer - free it
            ParDump2(PARERRORS, ("Par3QueryDeviceId:: read of DeviceId FAILED - discarding buffer\n") );
            ExFreePool( deviceIdBuffer );
        }
        return NULL;
    }

    if ( bytesRead < bytesToRead ) {
        //
        // Device likely reported incorrect value for IEEE 1284 Device ID length
        //
        // This spew is on by default in checked builds to try to get
        //   a feel for how many types of devices are broken in this way
        //
        DbgPrint(("pnp::Par3QueryDeviceId - ID shorter than expected\n") );
    }

    return deviceIdBuffer;
}

NTSTATUS
ParSynchCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine is for use with synchronous IRP processing.
    All it does is signal an event, so the driver knows it
    can continue.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Irp          - Irp that just completed

    Event        - Event we'll signal to say Irp is done

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
ParCheckParameters(
    IN OUT  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine reads the parameters section of the registry and modifies
    the device extension as specified by the parameters.

Arguments:

    RegistryPath    - Supplies the registry path.

    Extension       - Supplies the device extension.

Return Value:

    None.

--*/

{
    RTL_QUERY_REGISTRY_TABLE ParamTable[4];
    ULONG                    UsePIWriteLoop;
    ULONG                    UseNT35Priority;
    ULONG                    Zero = 0;
    NTSTATUS                 Status;
    HANDLE                   hRegistry;

    ParDump(PARDUMP_VERBOSE_MAX, 
            ("PARALLEL: "
             "Enter ParCheckParameters(...)\n") );

    if (Extension->PhysicalDeviceObject) {

        Status = IoOpenDeviceRegistryKey (Extension->PhysicalDeviceObject,
                                          PLUGPLAY_REGKEY_DRIVER,
                                          STANDARD_RIGHTS_ALL,
                                          &hRegistry);

        if (NT_SUCCESS(Status)) {

            RtlZeroMemory(ParamTable, sizeof(ParamTable));

            ParamTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[0].Name          = (PWSTR)L"UsePIWriteLoop";
            ParamTable[0].EntryContext  = &UsePIWriteLoop;
            ParamTable[0].DefaultType   = REG_DWORD;
            ParamTable[0].DefaultData   = &Zero;
            ParamTable[0].DefaultLength = sizeof(ULONG);

            ParamTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[1].Name          = (PWSTR)L"UseNT35Priority";
            ParamTable[1].EntryContext  = &UseNT35Priority;
            ParamTable[1].DefaultType   = REG_DWORD;
            ParamTable[1].DefaultData   = &Zero;
            ParamTable[1].DefaultLength = sizeof(ULONG);

            ParamTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
            ParamTable[2].Name          = (PWSTR)L"InitializationTimeout";
            ParamTable[2].EntryContext  = &(Extension->InitializationTimeout);
            ParamTable[2].DefaultType   = REG_DWORD;
            ParamTable[2].DefaultData   = &Zero;
            ParamTable[2].DefaultLength = sizeof(ULONG);

            Status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE | RTL_REGISTRY_OPTIONAL,
                                            hRegistry, ParamTable, NULL, NULL);

            if (NT_SUCCESS(Status)) {

                if(UsePIWriteLoop) {
                    Extension->UsePIWriteLoop = TRUE;
                }

                if(UseNT35Priority) {
                    Extension->UseNT35Priority = TRUE;
                }

                if(Extension->InitializationTimeout == 0) {
                    Extension->InitializationTimeout = 15;
                }
            }

        } else {
            Extension->InitializationTimeout = 15;
        }

        ZwClose (hRegistry);

    } else {
        Extension->InitializationTimeout = 15;
    }
}

BOOLEAN
String2Num(
    IN OUT PUCHAR   *lpp_Str,
    IN CHAR         c,
    OUT ULONG       *num
    )
{
    PUCHAR string = *lpp_Str;
    int cc;
    int cnt = 0;

    ParDump2(PARINFO, ("String2Num. string [%s]\n", string) );
    *num = 0;
    if (!*lpp_Str)
    {
        ParDump2(PARINFO, ("String2Num. Null String\n") );
        *num = 0;
        return FALSE;
    }
    // At this point, we should have a string that is a
    // positive hex value.  I will not be checking for
    // validity of the string.  If peripheral handed me a
    // bogus value then I'm gonna make their life
    // miserable.
String2Num_Start:
    cc = (int)(unsigned char)**lpp_Str;
    if (cc >= '0' && cc <= '9')
    {    
        *num = 16 * *num + (cc - '0');     /* accumulate digit */
    }
    else if (cc >= 'A' && cc <= 'F')
    {
        *num = 16 * *num + (cc - 55);     /* accumulate digit */
    }
    else if (cc >= 'a' && cc <= 'f')
    {
        *num = 16 * *num + (cc - 87);     /* accumulate digit */
    }
    else if (cc == c || cc == 0)
    {
        ParDump2(PARINFO, ("String2Num. Delimeter found num [%x]\n", *num));
        *lpp_Str = 0;
        return TRUE;
    }
    else if (cc == 'y' || cc == 'Y')
    {
        ParDump2(PARINFO, ("String2Num. Special case 'y' hit\n") );
        *lpp_Str = 0;
        *num = -1;     /* Special case */
        return FALSE;
    }
    else 
    {
        ParDump2(PARINFO, ("String2Num. Dunno\n") );
        *lpp_Str = 0;
        *num = 0;     /* It's all messed up */
        return FALSE;
    }
    ParDump2(PARINFO, ("String2Num. num [%x]\n", *num) );
    (*lpp_Str)++;
    if (cnt++ > 100)
    {
        // If our string is this large, then I'm gonna assume somethings
        // wrong
        ParDump2(PARINFO, ("String2Num. String too long\n") );
        goto String2Num_End;
    }
    goto String2Num_Start;

String2Num_End:
    ParDump2(PARINFO, ("String2Num. Somethings wrong with String\n") );
    *num = 0;
    return FALSE;
}

UCHAR
StringCountValues(
    IN PCHAR string, 
    IN CHAR  delimeter
    )
{
    PUCHAR  lpKey = (PUCHAR)string;
    UCHAR   cnt = 1;

    if(!string) {
        return 0;
    }

    while(*lpKey) {
        if( *lpKey==delimeter ) {
            ++cnt;
        }
        lpKey++;
    }

    return cnt;
}

PUCHAR
StringChr(
    IN PCHAR string, 
    IN CHAR  c
    )
{
    if(!string) {
        return(NULL);
    }

    while(*string) {
        if( *string==c ) {
            return (PUCHAR)string;
        }
        string++;
    }

    return NULL;
}

VOID
StringSubst(
    IN PUCHAR lpS,
    IN UCHAR  chTargetChar,
    IN UCHAR  chReplacementChar,
    IN USHORT cbS
    )
{
    USHORT  iCnt = 0;

    while ((lpS != '\0') && (iCnt++ < cbS))
        if (*lpS == chTargetChar)
            *lpS++ = chReplacementChar;
        else
            ++lpS;
}

VOID
ParFixupDeviceId(
    IN OUT PUCHAR DeviceId
    )
/*++

Routine Description:

    This routine parses the NULL terminated string and replaces any invalid
    characters with an underscore character.

    Invalid characters are:
        c <= 0x20 (' ')
        c >  0x7F
        c == 0x2C (',')

Arguments:

    DeviceId - specifies a device id string (or part of one), must be
               null-terminated.

Return Value:

    None.

--*/

{
    PUCHAR p;
    for( p = DeviceId; *p; ++p ) {
        if( (*p <= ' ') || (*p > (UCHAR)0x7F) || (*p == ',') ) {
            *p = '_';
        }
    }
}

VOID
ParDetectDot3DataLink(
    IN  PDEVICE_EXTENSION   Extension,
    IN PUCHAR DeviceId
    )
{
    PUCHAR          DOT3DL = NULL;       // 1284.3 Data Link Channels
    PUCHAR          DOT3C = NULL;        // 1284.3 Data Link Services
    PUCHAR          DOT4DL = NULL;       // 1284.4 Data Link for peripherals that were
                                         // implemented prior to 1284.3
    PUCHAR          CMDField = NULL;     // The command field for parsing legacy MLC
    PUCHAR          DOT3M = NULL;       // 1284 physical layer modes that will break this device

    ParDump2(PARDUMP_PNP_DL, ("ParDetectDot3DataLink: DeviceId [%s]\n", DeviceId) );
    ParDot3ParseDevId(&DOT3DL, &DOT3C, &CMDField, &DOT4DL, &DOT3M, DeviceId);
    ParDot3ParseModes(Extension,DOT3M);
    if (DOT4DL)
    {
        ParDump2(PARDUMP_PNP_DL, ("1284.4 with MLC Data Link Detected. DOT4DL [%s]\n", DOT4DL) );
        ParDot4CreateObject(Extension, DOT4DL);
    }
    else if (DOT3DL)
    {
        ParDump2(PARDUMP_PNP_DL, ("1284.3 Data Link Detected DL:[%s] C:[%s]\n", DOT3DL, DOT3C) );
        ParDot3CreateObject(Extension, DOT3DL, DOT3C);
    }
    else if (CMDField)
    {
        ParDump2(PARDUMP_PNP_DL, ("MLC Data Link Detected. MLC [%s]\n", CMDField) );
        ParMLCCreateObject(Extension, CMDField);
    }
#if DBG
    else
    {
        ParDump2(PARDUMP_PNP_DL, ("No Data Link Detected\n") );
    }
#endif
}

VOID
ParDot3ParseDevId(
    PUCHAR   *lpp_DL,
    PUCHAR   *lpp_C,
    PUCHAR   *lpp_CMD,
    PUCHAR   *lpp_4DL,
    PUCHAR   *lpp_M,
    PUCHAR   lpDeviceID
)
{
    PUCHAR   lpKey = lpDeviceID;     // Pointer to the Key to look at
    PUCHAR   lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.

    ParDump(PARDUMP_PNP_DL, 
            ("PARALLEL: "
             "Enter ParDot3ParseDevId(...)\n") );

    while (lpKey != NULL)
    {
        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?
        if (!(lpValue = StringChr((PCHAR)lpKey, ':')) ) {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        switch (*lpKey) {
        case '1':
            // Look for DOT3 Datalink
            if((RtlCompareMemory(lpKey, "1284.4DL:", wKeyLength)==9))
            {
                *lpp_4DL = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=NULL)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3DL:", wKeyLength)==9))
            {
                *lpp_DL = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=NULL)
                {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3C:", wKeyLength)==8))
            {
                *lpp_C = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((RtlCompareMemory(lpKey, "1284.3M:", wKeyLength)==8))
            {
                *lpp_M = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case '.':
            // Look for for .3 extras
            if ((RtlCompareMemory(lpKey, ".3C:", wKeyLength)==4) ) {

                *lpp_C = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if ((RtlCompareMemory(lpKey, ".3M:", wKeyLength)==4) ) {

                *lpp_M = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case 'C':
            // Look for MLC Datalink
            if ((RtlCompareMemory(lpKey, "CMD:", wKeyLength)==4) ) {

                *lpp_CMD = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }
            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }

            break;

        default:
            // The key is uninteresting.  Go to the next Key
            if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;
        }
    }
}

PUCHAR
ParQueryDeviceId(
    IN  PDEVICE_EXTENSION Extension
    )
/*++

Routine Description:

    try to read a device ID from a device

    *** this function assumes that the caller has already acquired
          the port (and selected the device if needed).

    *** on success, this function returns a pointer to allocated pool
          which the caller is responsible for freeing when it is no
          longer needed

Arguments:

    Extension - used to find the Controller

Return Value:

    PUCHAR  - points to DeviceIdString on success
    NULL    - if failure

--*/
{
    PUCHAR    Controller = Extension->Controller;
    NTSTATUS  Status;
    UCHAR     SizeBuf[2];
    ULONG     NumBytes = 0;
    USHORT    Size;
    PUCHAR    deviceId;

    if ((Extension->Connected) &&
        (afpForward[Extension->IdxForwardProtocol].fnDisconnect)) {

        afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
    }

    //
    // negotiate the peripheral into nibble mode/device id request.
    //
    Status = ParEnterNibbleMode(Extension, TRUE);
    if (!NT_SUCCESS(Status)) {
        ParDumpV( ("ParQueryDeviceId() - ParEnterNibbleMode FAILed\n") );
        return NULL;
    }

    // read the Device Id string size (encoded in first 2 bytes) 
    //  - reported size includes the 2 size bytes
    Status = ParNibbleModeRead(Extension, SizeBuf, 2, &NumBytes);
    if( !NT_SUCCESS(Status) || ( NT_SUCCESS(Status) && NumBytes != 2 ) ) {
        // read of ID string size failed
        ParDumpV( ("ParQueryDeviceId() - Read of ID string size FAILed\n") );
        ParTerminateNibbleMode(Extension);
        WRITE_PORT_UCHAR(Controller + DCR_OFFSET, DCR_NEUTRAL);
        return NULL;
    }

    // we have the deviceId size
    Size = (USHORT)( SizeBuf[0]*0x100 + SizeBuf[1] );
    // *DeviceIdSize = Size - sizeof(USHORT);
    ParDumpV( ("DeviceIdSize reported as %d, attempting to read DeviceId\n", Size - sizeof(USHORT)) );

    // allocate a buffer to hold device ID
    deviceId = ExAllocatePool(PagedPool, Size);
    if( !deviceId ) {
        ParDumpV( ("ParQueryDeviceId() - unable to allocate buffer to hold ID\n") );
        ParTerminateNibbleMode(Extension);
        WRITE_PORT_UCHAR(Controller + DCR_OFFSET, DCR_NEUTRAL);
        ExFreePool(deviceId);
        return NULL;
    }
    RtlZeroMemory(deviceId, Size);

    // read the device ID
    Status = ParNibbleModeRead(Extension, deviceId, Size - sizeof(USHORT), &NumBytes);
    if ( !NT_SUCCESS(Status) || ( NT_SUCCESS(Status) && ( NumBytes != (Size - sizeof(USHORT)) ) ) ) {
        ParDumpV( ("ParQueryDeviceId() - FAIL in read of DeviceID\n") );
        ParTerminateNibbleMode(Extension);
        WRITE_PORT_UCHAR(Controller + DCR_OFFSET, DCR_NEUTRAL);
        ExFreePool(deviceId);
        return NULL;
    }
    ParDumpV( ("ParQueryDeviceId() - ID=<%s>\n", deviceId) );
    return deviceId;
}

VOID
ParKillDeviceObject(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Kill a ParClass ejected device object:
     - set the device extension state to indicate that we are
         in the process of going away so that we can fail 
         IRPs as appropriate
     - remove symbolic link to the device object
     - close handle to ParPort FILE object
     - unregister PnP notification callbacks
     - free pool allocations
     - remove the device object from the ParClass FDO's list of 
         ParClass ejected device objects
     - delete the device object

     *** This routine assumes that the caller holds FdoExtension->DevObjListMutex

Arguments:

    DeviceObject - The device object we want to kill

Return Value:

    NONE

--*/

{
    PDEVICE_EXTENSION Extension;

    if( !DeviceObject ) {
        // insurance against receiving a NULL pointer
        ParDumpV( ("ParKillDeviceObject(...): passed a NULL pointer, returning") );
        return; 
    }

    Extension = DeviceObject->DeviceExtension;

    if( !Extension->IsPdo ) {
        // we only handle ParClass ejected device objects (PDOs and PODOs)
        ParDumpV( ("ParKillDeviceObject(...): DeviceObject passed is the FDO, bailing out") );
        return;
    }

    ParDumpV( ("ParKillDeviceObject(...): Killing Device Object: %x %wZ\n",
               DeviceObject, &Extension->SymbolicLinkName) );


    //
    // set the device extension state to indicate that death is 
    //   imminent so that we can fail IRPs as appropriate
    //
    Extension->DeviceStateFlags |= PAR_DEVICE_DELETE_PENDING;

    // Notify the data link so it can begin the cleanup process.
    ParDot3DestroyObject(Extension);

    //
    // remove symbolic link to the device object
    //
    if( Extension->CreatedSymbolicLink ) {
        NTSTATUS status;
        status = IoDeleteSymbolicLink( &Extension->SymbolicLinkName );
        if( !NT_SUCCESS(status) ) {
            ParDumpV( ("IoDeleteSymbolicLink FAILED for %wZ\n", &Extension->SymbolicLinkName) );
        }
        status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                        (PWSTR)L"PARALLEL PORTS",
                                        Extension->ClassName.Buffer);
        if( !NT_SUCCESS(status) ) {
            ParDumpV( ("RtlDeleteRegistryValue FAILED for PARALLEL PORTS%wZ->%wZ\n",
                       &Extension->ClassName, &Extension->SymbolicLinkName) );
        }
        Extension->CreatedSymbolicLink = FALSE;
    }
            

    //
    // close handle to ParPort FILE object
    //
    if( Extension->PortDeviceFileObject ) {
        ObDereferenceObject( Extension->PortDeviceFileObject );
        Extension->PortDeviceFileObject = NULL;
    }


    //
    // unregister PnP notification callbacks
    //
    if( Extension->NotificationHandle ) {
        IoUnregisterPlugPlayNotification (Extension->NotificationHandle);
        Extension->NotificationHandle = NULL;
    }

    //
    // If this is a PODO that is registered for WMI, unregister now
    //   (PDOs don't do this because they register/unregister during START/REMOVE)
    //
    if( ParIsPodo(DeviceObject) && Extension->PodoRegForWMI ) {
        ParWMIRegistrationControl( DeviceObject, WMIREG_ACTION_DEREGISTER );
        Extension->PodoRegForWMI = FALSE;
    }

    //
    // free pool allocations that hold our name strings
    //
    RtlFreeUnicodeString(&Extension->PortSymbolicLinkName);
    RtlFreeUnicodeString(&Extension->SymbolicLinkName);
    RtlFreeUnicodeString(&Extension->ClassName);


    //
    // if the device object is in the list of ParClass ejected device objects,
    //   remove it from the list
    //
    {
        //
        // The head of the list is really "ParClassPdo" in the 
        //   ParClass FDO's device extension
        //
        PDEVICE_EXTENSION FdoExtension = Extension->ParClassFdo->DeviceExtension;
        PDEVICE_OBJECT    currentDO    = FdoExtension->ParClassPdo;
        PDEVICE_EXTENSION currentExt;
        if( !currentDO ) {      // empty device object list
            goto objectNotInList;
        }
        currentExt   = currentDO->DeviceExtension;

        if( currentDO == DeviceObject ) {

            //
            // device object that we're looking for is the
            //   first in the list, so remove it
            //
            FdoExtension->ParClassPdo  = currentExt->Next;
            currentExt->Next           = NULL;

        } else {

            //
            // walk the list to find the device object that we're looking for
            //

            PDEVICE_OBJECT    nextDO   = currentExt->Next;
            PDEVICE_EXTENSION nextExt;
            if( !nextDO ) {     // object not in list
                goto objectNotInList;
            }
            nextExt  = nextDO->DeviceExtension;

            while( nextDO != DeviceObject ) {

                //
                // we haven't found the device object that we're looking for yet,
                //   so advance our pointers
                //
                currentDO  = nextDO;
                currentExt = nextExt;
                nextDO     = currentExt->Next;
                if( !nextDO ) { // object not in list
                    goto objectNotInList;
                }
                nextExt    = nextDO->DeviceExtension;

            }

            //
            // found device object - remove it from the list
            //
            currentExt->Next = nextExt->Next;
            nextExt->Next    = NULL;

        }

    }
objectNotInList: // target for device object not in list


    //
    // delete the device object
    //
    if( !(Extension->DeviceStateFlags & PAR_DEVICE_DELETED) ) {
        // mark extension so that we don't call IoDeleteDevice twice
        Extension->DeviceStateFlags |= PAR_DEVICE_DELETED;
        IoDeleteDevice(DeviceObject);
    }
}

BOOLEAN
ParDeviceExists(
    IN PDEVICE_EXTENSION Extension,
    IN BOOLEAN           HavePortKeepPort
    )

/*++

Routine Description:

    Is the hardware associated with this Device Object still there?

    Query for the device's 1284 device ID string, extract the 
    relevent information from the raw ID string, and compare
    this information with that stored in the device's extension.

    Note: This function returns FALSE on any error.

Arguments:

    Extension - The device extension of the Device Object to check

Return Value:

    TRUE  - if the device is still there
    FALSE - otherwise

--*/

{
    NTSTATUS status;
    PCHAR    buffer         = NULL;
    ULONG    bufferLength;
    UCHAR    resultString[MAX_ID_SIZE];
    BOOLEAN  boolResult;

    ParDumpV( ("Enter ParDeviceExists(...): %wZ\n", &Extension->SymbolicLinkName) );

    RtlZeroMemory(resultString, MAX_ID_SIZE);

    //
    // Select the 1284.3 daisy chain device
    //
    if( !ParSelectDevice(Extension, HavePortKeepPort) ) {
        return FALSE;
    };
    
    //
    // Query the DeviceId
    //
    if ( Extension->Ieee1284Flags & ( 1 << Extension->Ieee1284_3DeviceId ) ) {
        buffer = Par3QueryDeviceId(Extension, NULL, 0, &bufferLength, FALSE, TRUE);
    }
    else {
        buffer = Par3QueryDeviceId(Extension, NULL, 0, &bufferLength, FALSE, FALSE);
    }

    //
    // We no longer need access to the hardware, Deselect the 1284.3 daisy chain device
    //
    boolResult = ParDeselectDevice(Extension, HavePortKeepPort);
    ASSERT(TRUE == boolResult);

    // check if we got a device ID
    if( !buffer ) {
        ParDumpV( ("pnp::ParDeviceExists: Device gone (Par3QueryDeviceId returned NULL)\n") );
        return FALSE;
    }

    ParDumpP( ("pnp::ParDeviceExists: \"RAW\" ID string = <%s>\n", buffer) );

    // extract the part of the ID that we want from the raw string 
    //   returned by the hardware
    status = ParPnpGetId((PUCHAR)buffer, BusQueryDeviceID, (PUCHAR)resultString, NULL);

    // no longer needed
    ExFreePool(buffer);

    // were we able to extract the info that we want from the raw ID string?
    if( !NT_SUCCESS(status) ) {
        return FALSE;
    }

    // Does the ID that we just retrieved from the device match the one 
    //   that we previously saved in the device extension?
    if(0 != strcmp((const PCHAR)Extension->DeviceIdString, (const PCHAR)resultString)) {
        ParDumpP( ("pnp::ParDeviceExists: device <%s> on %wZ GONE - strcmp failed\n",
                   resultString, &Extension->SymbolicLinkName) );
        ParDumpP( ("pnp::ParDeviceExists: existing device was <%s>\n",
                   Extension->DeviceIdString) );
        return FALSE;
    }

    ParDumpP( ("pnp::ParDeviceExists: device <%s> on %wZ is STILL THERE\n",
               resultString, &Extension->SymbolicLinkName) );

    return TRUE;
}

NTSTATUS
ParPnpGetId(
    IN PUCHAR DeviceIdString,
    IN ULONG Type,
    OUT PUCHAR resultString,
    OUT PUCHAR descriptionString OPTIONAL
    )
/*
    Description:

        Creates Id's from the device id retrieved from the printer

    Parameters:

        DeviceId - String with raw device id
        Type - What of id we want as a result
        Id - requested id

    Return Value:
        NTSTATUS

*/
{
    NTSTATUS status;
    USHORT          checkSum=0;                     // A 16 bit check sum
    UCHAR           nodeName[16] = "LPTENUM\\";
    // The following are used to generate sub-strings from the Device ID string
    // to get the DevNode name, and to update the registry
    PUCHAR          MFG = NULL;                   // Manufacturer name
    PUCHAR          MDL = NULL;                   // Model name
    PUCHAR          CLS = NULL;                   // Class name
    PUCHAR          AID = NULL;                   // Hardare ID
    PUCHAR          CID = NULL;                   // Compatible IDs
    PUCHAR          DES = NULL;                   // Device Description

    ParDump(PARDUMP_VERBOSE_MAX, 
            ("PARALLEL: "
             "Enter ParPnpGetId(...)\n") );

    status = STATUS_SUCCESS;

    switch(Type) {

    case BusQueryDeviceID:

        // Extract the usefull fields from the DeviceID string.  We want
        // MANUFACTURE (MFG):
        // MODEL (MDL):
        // AUTOMATIC ID (AID):
        // COMPATIBLE ID (CID):
        // DESCRIPTION (DES):
        // CLASS (CLS):

        ParPnpFindDeviceIdKeys(&MFG, &MDL, &CLS, &DES, &AID, &CID, DeviceIdString);

        // Check to make sure we got MFG and MDL as absolute minimum fields.  If not
        // we cannot continue.
        if (!MFG || !MDL)
        {
            status = STATUS_NOT_FOUND;
            goto ParPnpGetId_Cleanup;
        }
        //
        // Concatenate the provided MFG and MDL P1284 fields
        // Checksum the entire MFG+MDL string
        //
        sprintf((PCHAR)resultString, "%s%s\0",MFG,MDL);
        
        if (descriptionString) {
            sprintf((PCHAR)descriptionString, "%s %s\0",MFG,MDL);
        }
            
        break;

    case BusQueryHardwareIDs:

        GetCheckSum((PUCHAR)DeviceIdString, (USHORT)strlen((const PCHAR)DeviceIdString), &checkSum);
        sprintf((PCHAR)resultString,"%s%.20s%04X",nodeName,DeviceIdString,checkSum);
        break;

    case BusQueryCompatibleIDs:

        //
        // return only 1 id
        //
        GetCheckSum(DeviceIdString, (USHORT)strlen((const PCHAR)DeviceIdString), &checkSum);
        sprintf((PCHAR)resultString,"%.20s%04X",DeviceIdString,checkSum);

        break;
    }

    if (Type!=BusQueryDeviceID) {

        //
        // Convert and spaces in the Hardware ID to underscores
        //
        StringSubst (resultString, ' ', '_', (USHORT)strlen((const PCHAR)resultString));
    }

ParPnpGetId_Cleanup:

    return(status);
}

VOID
ParPnpFindDeviceIdKeys(
    PUCHAR   *lppMFG,
    PUCHAR   *lppMDL,
    PUCHAR   *lppCLS,
    PUCHAR   *lppDES,
    PUCHAR   *lppAID,
    PUCHAR   *lppCID,
    PUCHAR   lpDeviceID
    )
/*

    Description:
        This function will parse a P1284 Device ID string looking for keys
        of interest to the LPT enumerator. Got it from win95 lptenum

    Parameters:
        lppMFG      Pointer to MFG string pointer
        lppMDL      Pointer to MDL string pointer
        lppMDL      Pointer to CLS string pointer
        lppDES      Pointer to DES string pointer
        lppCIC      Pointer to CID string pointer
        lppAID      Pointer to AID string pointer
        lpDeviceID  Pointer to the Device ID string

    Return Value:
        no return VALUE.
        If found the lpp parameters are set to the approprate portions
        of the DeviceID string, and they are NULL terminated.
        The actual DeviceID string is used, and the lpp Parameters just
        reference sections, with appropriate null thrown in.

*/
{
    PUCHAR   lpKey = lpDeviceID;     // Pointer to the Key to look at
    PUCHAR   lpValue;                // Pointer to the Key's value
    USHORT   wKeyLength;             // Length for the Key (for stringcmps)

    // While there are still keys to look at.

    ParDump(PARDUMP_VERBOSE_MAX, 
            ("PARALLEL: "
             "Enter ParPnpFindDeviceIdKeys(...)\n") );

    while (lpKey != NULL)
    {
        while (*lpKey == ' ')
            ++lpKey;

        // Is there a terminating COLON character for the current key?
        if (!(lpValue = StringChr((PCHAR)lpKey, ':')) ) {
            // N: OOPS, somthing wrong with the Device ID
            return;
        }

        // The actual start of the Key value is one past the COLON
        ++lpValue;

        //
        // Compute the Key length for Comparison, including the COLON
        // which will serve as a terminator
        //
        wKeyLength = (USHORT)(lpValue - lpKey);

        //
        // Compare the Key to the Know quantities.  To speed up the comparison
        // a Check is made on the first character first, to reduce the number
        // of strings to compare against.
        // If a match is found, the appropriate lpp parameter is set to the
        // key's value, and the terminating SEMICOLON is converted to a NULL
        // In all cases lpKey is advanced to the next key if there is one.
        //
        switch (*lpKey) {
        case 'M':
            // Look for MANUFACTURE (MFG) or MODEL (MDL)
            if((RtlCompareMemory(lpKey, "MANUFACTURER", wKeyLength)>5) ||
               (RtlCompareMemory(lpKey, "MFG", wKeyLength)==3) ) {

                *lppMFG = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=NULL) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if((RtlCompareMemory(lpKey, "MODEL", wKeyLength)==5) ||
                      (RtlCompareMemory(lpKey, "MDL", wKeyLength)==3) ) {

                *lppMDL = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;

        case 'C':
            // Look for CLASS (CLS)
            if ((RtlCompareMemory(lpKey, "CLASS", wKeyLength)==5) ||
                (RtlCompareMemory(lpKey, "CLS", wKeyLength)==3) ) {

                *lppCLS = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((RtlCompareMemory(lpKey, "COMPATIBLEID", wKeyLength)>5) ||
                       (RtlCompareMemory(lpKey, "CID", wKeyLength)==3) ) {

                *lppCID = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr((PCHAR)lpValue,';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
        
            break;

        case 'D':
            // Look for DESCRIPTION (DES)
            if(RtlCompareMemory(lpKey, "DESCRIPTION", wKeyLength) ||
                RtlCompareMemory(lpKey, "DES", wKeyLength) ) {

                *lppDES = lpValue;
                if((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            
            break;

        case 'A':
            // Look for AUTOMATIC ID (AID)
            if (RtlCompareMemory(lpKey, "AUTOMATICID", wKeyLength) ||
                RtlCompareMemory(lpKey, "AID", wKeyLength) ) {

                *lppAID = lpValue;
                if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                    *lpKey = '\0';
                    ++lpKey;
                }

            } else if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {

                *lpKey = '\0';
                ++lpKey;

            }
            break;

        default:
            // The key is uninteresting.  Go to the next Key
            if ((lpKey = StringChr((PCHAR)lpValue, ';'))!=0) {
                *lpKey = '\0';
                ++lpKey;
            }
            break;
        }
    }
}


VOID
GetCheckSum(
    PUCHAR  Block,
    USHORT  Len,
    PUSHORT CheckSum
    )
{
    USHORT i;
    //    UCHAR  lrc;
    USHORT crc = 0;

    unsigned short crc16a[] = {
        0000000,  0140301,  0140601,  0000500,
        0141401,  0001700,  0001200,  0141101,
        0143001,  0003300,  0003600,  0143501,
        0002400,  0142701,  0142201,  0002100,
    };
    unsigned short crc16b[] = {
        0000000,  0146001,  0154001,  0012000,
        0170001,  0036000,  0024000,  0162001,
        0120001,  0066000,  0074000,  0132001,
        0050000,  0116001,  0104001,  0043000,
    };

    //
    // Calculate CRC using tables.
    //

    UCHAR tmp;
    for ( i=0; i<Len;  i++) {
         tmp = (UCHAR)(Block[i] ^ (UCHAR)crc);
         crc = (USHORT)((crc >> 8) ^ crc16a[tmp & 0x0f] ^ crc16b[tmp >> 4]);
    }

    *CheckSum = crc;
}


//
// old pnpdone.c follows
// 

NTSTATUS
ParParallelPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   )
/*++dvdf

Routine Description:

    This is the dispatch routine for all PNP IRPs. It forwards the request
    to the appropriate routine based on whether the DO is a PDO or FDO.

Arguments:

    pDeviceObject           - represents a parallel device

    pIrp                    - PNP Irp

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    PDEVICE_EXTENSION extension = pDeviceObject->DeviceExtension;

    if ( ((PDEVICE_EXTENSION)(pDeviceObject->DeviceExtension))->IsPdo ) {
        ASSERT( extension->DeviceType && (PAR_DEVTYPE_PODO | PAR_DEVTYPE_PDO) );
        return ParPdoParallelPnp (pDeviceObject, pIrp);
    } else {
        ASSERT( extension->DeviceType && PAR_DEVTYPE_FDO );
        return ParFdoParallelPnp (pDeviceObject, pIrp);
    }    
}

NTSTATUS
ParAcquirePort(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
/*++dvdf

Routine Description:

    This routine acquires the specified parallel port from the parallel 
      port arbiter ParPort via an IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE.

Arguments:

    PortDeviceObject - points to the ParPort device to be acquired

Return Value:

    STATUS_SUCCESS  - if the port was successfully acquired
    !STATUS_SUCCESS - otherwise

--*/
{
    LARGE_INTEGER    localTimeout;
    
    if( Timeout ) {
        localTimeout = *Timeout;           // caller specified
    } else {
        localTimeout = AcquirePortTimeout; // driver global variable default
    }

    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE, 
                                     PortDeviceObject, NULL, 0, NULL, 0, &localTimeout);
}

NTSTATUS
ParReleasePort(
    IN PDEVICE_OBJECT PortDeviceObject
    )
/*++dvdf

Routine Description:

    This routine releases the specified parallel port back to the the parallel 
      port arbiter ParPort via an IOCTL_INTERNAL_PARALLEL_PORT_FREE.

Arguments:

    PortDeviceObject - points to the ParPort device to be released

Return Value:

    STATUS_SUCCESS  - if the port was successfully released
    !STATUS_SUCCESS - otherwise

--*/
{
    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_PARALLEL_PORT_FREE, 
                                     PortDeviceObject, NULL, 0, NULL, 0, NULL);
}

NTSTATUS
ParInit1284_3Bus(
    IN PDEVICE_OBJECT PortDeviceObject
    )
/*++dvdf

Routine Description:

    This routine reinitializes the 1284.3 daisy chain "bus" via an 
      IOCTL_INTERNAL_INIT_1284_3_BUS sent to the ParPort device to
      reinitialize. 

    Reinitializing the 1284.3 bus assigns addresses [0..3] to the 
      daisy chain devices based on their position in the 1284.3 daisy chain. 
      Address 0 is closest to the host port and address 3 is closest to the 
      end of the chain. 

    New devices must be assigned an address before they will respond to 
      1284.3 SELECT and DESELECT commands.

    A 1284.3 daisy chain device whose position in the 1284.3 daisy chain 
      has changed due to the addition or removal of another 1284.3 daisy 
      chain device between the existing device and the host port will be 
      assigned a new addresses based on its new position in the chain.

Preconditions:

    Caller must have already Acquired the Port via ParAcquirePort()prior 
      to calling this function.

Preconditions:

    Caller still owns the port after calling this function and is responsible
      for freeing the port when it is no longer required via ParReleasePort().

Arguments:

    PortDeviceObject - points to the ParPort that the device is connected to.

Return Value:

    STATUS_SUCCESS   - if the initialization was successful

    !STATUS_SUCCESS  - otherwise

--*/
{
    return ParBuildSendInternalIoctl(IOCTL_INTERNAL_INIT_1284_3_BUS, 
                                     PortDeviceObject, NULL, 0, NULL, 0, NULL);
}


VOID
ParMarkPdoHardwareGone(
    IN PDEVICE_EXTENSION Extension
    )
/*++dvdf

Routine Description:

    This routine is called to mark a device as "Hardware Gone", i.e., the
      hardware associated with this device is no longer there.

      - set DeviceState flag so that we know the device is no longer present
      - mark extension so FDO no longer reports the device to PnP during BusRelation query
      - delete symbolic link
      - delete registry Parallelx -> LPTy mapping

Arguments:

    Extension - points to the device extension of the device that has gone away

Return Value:

    None.

--*/
{
    //
    // Mark our extension so that we know our hardware is gone.
    //
    Extension->DeviceStateFlags  = PAR_DEVICE_HARDWARE_GONE;

    //
    // Mark our extension so that the ParClass FDO no longer reports us to PnP 
    //   in response to QUERY_DEVICE_RELATIONS/BusRelations.
    //
    Extension->DeviceIdString[0] = 0;
    
    //
    // Cleanup Symbolic Link and Registry
    //
    if( Extension->CreatedSymbolicLink ) {
        NTSTATUS status;

        // Remove symbolic link NOW so that the name can be reused by another device
        status = IoDeleteSymbolicLink( &Extension->SymbolicLinkName );
        if( !NT_SUCCESS(status) ) {
            ParDumpV( ("IoDeleteSymbolicLink FAILED for %wZ\n", &Extension->SymbolicLinkName) );
        }

        status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, (PWSTR)L"PARALLEL PORTS", Extension->ClassName.Buffer);

        // Remove our Parallelx -> LPTy mapping from HKLM\HARDWARE\DEVICEMAP\PARALLEL PORTS
        if( !NT_SUCCESS(status) ) {
            ParDumpV( ("RtlDeleteRegistryValue FAILED for PARALLEL PORTS %wZ->%wZ\n",
                       &Extension->ClassName, &Extension->SymbolicLinkName) );
        }

        Extension->CreatedSymbolicLink = FALSE;
    }
}

NTSTATUS
ParPnpNotifyTargetDeviceChange(
    IN  PDEVICE_INTERFACE_CHANGE_NOTIFICATION pDeviceInterfaceChangeNotification,
    IN  PDEVICE_OBJECT                        pDeviceObject
    )

/*++

Routine Description:

    This routine is the PlugPlay notification callback routine that
      gets called when our ParPort gets QUERY_REMOVE, REMOVE, or
      REMOVE_CANCELLED.

Arguments:

    pDeviceInterfaceChangeNotification  - Structure defining the change.

    pDeviceObject                       - The ParClass ejected device object
                                            receiving the notification 
                                            (context passed when we registered 
                                            for notification)

Return Value:

    STATUS_SUCCESS - always

--*/

{
    PDEVICE_EXTENSION Extension = (PDEVICE_EXTENSION)pDeviceObject->DeviceExtension;

    ParDump2(PARDUMP_PNP_PARPORT, 
             ("ParPnpNotifyTargetDeviceChange(...): "
              "%x %wZ received PLUGPLAY Notification for ParPort Device\n",
              pDeviceObject, &Extension->SymbolicLinkName) );

    if(IsEqualGUID( (LPGUID)&(pDeviceInterfaceChangeNotification->Event), 
                    (LPGUID)&GUID_TARGET_DEVICE_QUERY_REMOVE)) {

        //
        // Our ParPort is going to receive a QUERY_REMOVE
        //


        ParDump2(PARDUMP_PNP_PARPORT, 
                 ("ParPnpNotifyTargetDeviceChange(...): Our ParPort will receive QUERY_REMOVE\n") );

        ExAcquireFastMutex(&Extension->OpenCloseMutex);

        if (Extension->OpenCloseRefCount > 0) {
            //
            // someone has an open handle to us, do nothing,
            //   Our ParPort should fail QUERY_REMOVE because we 
            //   still have a handle to it
            //
            DDPnP1(("## TargetQueryRemoveNotification - %wZ - keep handle open\n",&Extension->SymbolicLinkName));

            ParDump2(PARDUMP_PNP_PARPORT,
                     ("ParPnpNotifyTargetDeviceChange(...): Someone has an open handle to us, "
                      "KEEP our handle to ParPort\n") );
            
        } else if(Extension->PortDeviceFileObject) {
            //
            // close our handle to ParPort to prevent us
            //   from blocking our ParPort from succeeding
            //   its QUERY_REMOVE
            //
            DDPnP1(("## TargetQueryRemoveNotification - %wZ - close handle\n",&Extension->SymbolicLinkName));

            ParDump2(PARDUMP_PNP_PARPORT,
                     ("ParPnpNotifyTargetDeviceChange(...): no one has an open handle to us, "
                      "CLOSE our handle to ParPort\n") );
            ObDereferenceObject(Extension->PortDeviceFileObject);
            Extension->PortDeviceFileObject = NULL;

            //
            // Set DeviceStateFlags accordingly so we handle
            //   IRPs properly while waiting to see if our ParPort gets
            //   REMOVE or REMOVE_CANCELLED
            //

            // We expect to be deleted, our parport is in a remove pending state
            // Extension->DeviceStateFlags |= PAR_DEVICE_DELETE_PENDING;
            Extension->DeviceStateFlags |= PAR_DEVICE_PORT_REMOVE_PENDING;
        }

        ExReleaseFastMutex(&Extension->OpenCloseMutex); 

    } else if(IsEqualGUID( (LPGUID)&(pDeviceInterfaceChangeNotification->Event), 
                           (LPGUID)&GUID_TARGET_DEVICE_REMOVE_COMPLETE)) { 

        DDPnP1(("## TargetRemoveCompleteNotification - %wZ\n",&Extension->SymbolicLinkName));

        //
        // Our ParPort is gone, clean up
        //
        Extension->ParPortDeviceGone = TRUE;

        //
        // First, clean up any worker thread
        //
        if(Extension->ThreadObjectPointer) {

            // set the flag for the worker thread to kill itself
            Extension->TimeToTerminateThread = TRUE;
            
            // wake up the thread so it can kill itself
            KeReleaseSemaphore(&Extension->RequestSemaphore, 0, 1, FALSE);
            
            // allow thread to get past PauseEvent so it can kill self
            KeSetEvent(&Extension->PauseEvent, 0, TRUE);

            // wait for the thread to die
            KeWaitForSingleObject(Extension->ThreadObjectPointer, UserRequest, KernelMode, FALSE, NULL);
            
            // allow the system to release the thread object
            ObDereferenceObject(Extension->ThreadObjectPointer);
            
            // note that we no longer have a worker thread
            Extension->ThreadObjectPointer = NULL;
        }

        if( Extension->DeviceIdString[0] == 0 ) {
            // this is a PODO, PnP doesn't know about us, so kill self now
            PDEVICE_EXTENSION FdoExtension = Extension->ParClassFdo->DeviceExtension;
            ExAcquireFastMutex(&FdoExtension->DevObjListMutex);
            ParKillDeviceObject(pDeviceObject);
            ExReleaseFastMutex(&FdoExtension->DevObjListMutex);
        } else {
            // this is a PDO, note that our hardware is gone and wait for PnP system
            //   to send us a REMOVE
            PDEVICE_EXTENSION FdoExtension;
            Extension->DeviceStateFlags  = PAR_DEVICE_HARDWARE_GONE;
            Extension->DeviceIdString[0] = 0;

            //
            // remove symbolic link NOW in case the interface returns before PnP gets
            //   around to sending us a QUERY_DEVICE_RELATIONS/BusRelations followed by
            //   a REMOVE_DEVICE
            //
            if( Extension->CreatedSymbolicLink ) {
                NTSTATUS status;
                status = IoDeleteSymbolicLink( &Extension->SymbolicLinkName );
                if( !NT_SUCCESS(status) ) {
                    ParDump2(PARDUMP_PNP_PARPORT, 
                             ("IoDeleteSymbolicLink FAILED for %wZ\n", &Extension->SymbolicLinkName) );
                }
                status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, (PWSTR)L"PARALLEL PORTS", Extension->ClassName.Buffer);
                if( !NT_SUCCESS(status) ) {
                    ParDump2(PARDUMP_PNP_PARPORT, 
                             ("RtlDeleteRegistryValue FAILED for PARALLEL PORTS %wZ->%wZ\n",
                              &Extension->ClassName, &Extension->SymbolicLinkName) );
                }
                Extension->CreatedSymbolicLink = FALSE;
            }

            // tell PnP that the set of ParClass enumerated PDOs has changed
            FdoExtension = (PDEVICE_EXTENSION)(Extension->ParClassFdo->DeviceExtension);
            IoInvalidateDeviceRelations(FdoExtension->PhysicalDeviceObject, BusRelations);
        }
    
    } else if(IsEqualGUID( (LPGUID)&(pDeviceInterfaceChangeNotification->Event), 
                           (LPGUID)&GUID_TARGET_DEVICE_REMOVE_CANCELLED)) { 
    
        //
        // Our ParPort is back online (REMOVE_CANCELLED)
        //

        DDPnP1(("## TargetRemoveCancelledNotification - %wZ\n",&Extension->SymbolicLinkName));

        ParDump2(PARDUMP_PNP_PARPORT,
                 ("ParPnpNotifyTargetDeviceChange(...): Our ParPort completed a REMOVE_CANCELLED\n") );
            
        ExAcquireFastMutex(&Extension->OpenCloseMutex);

        if( !Extension->PortDeviceFileObject ) {

            //
            // we dropped our connection to our ParPort prior to
            //   our ParPort receiving QUERY_REMOVE, reestablish
            //   a FILE connection and resume operation
            //

            NTSTATUS       status;
            PFILE_OBJECT   portDeviceFileObject;
            PDEVICE_OBJECT portDeviceObject;
            
            ParDump2(PARDUMP_PNP_PARPORT,
                     ("ParPnpNotifyTargetDeviceChange(...): reopening file against our ParPort\n") );
            
            status = IoGetDeviceObjectPointer(&Extension->PortSymbolicLinkName,
                                              STANDARD_RIGHTS_ALL,
                                              &portDeviceFileObject,
                                              &portDeviceObject);
            
            if(NT_SUCCESS(status) && portDeviceFileObject && portDeviceObject) {

                // save REFERENCED PFILE_OBJECT in our device extension
                Extension->PortDeviceFileObject = portDeviceFileObject;
                // our ParPort device object should not have changed
                ASSERT(Extension->PortDeviceObject == portDeviceObject);

            } else {

                ParDump2(PARDUMP_PNP_PARPORT,
                         ("In ParPnpNotifyTargetDeviceChange(...): Unable to reopen FILE against our ParPort\n") );
                
                //
                // Unable to reestablish connection? Inconceivable!
                //
                ASSERT(FALSE);
            }
        }

        //
        // set DeviceStateFlags accordingly to resume processing IRPs
        //
        Extension->DeviceStateFlags &= ~PAR_DEVICE_PORT_REMOVE_PENDING;

        ExReleaseFastMutex(&Extension->OpenCloseMutex); 

    } else {
        ParDump2(PARDUMP_PNP_PARPORT,
                 ("In ParPnpNotifyTargetDeviceChange(...): Unrecognized GUID_TARGET_DEVICE type\n") );
    }
    return STATUS_SUCCESS;
}

//
// dvdf - former devobj.c follows
//

VOID
ParMakeClassNameFromNumber(
    IN  ULONG           Number,
    OUT PUNICODE_STRING ClassName
    )
/*++dvdf

Routine Description:

    This routine creates a ClassName for a ParClass PODO of the form:
      L"\Device\ParallelN" where N is the wide string representation 
      of the 'Number' parameter.

    Note: On success ClassName->Buffer points to allocated pool. 
      The caller is responsible for freeing this allocation when 
      it is no longer required.

    Note: The returned ClassName->Buffer is UNICODE_NULL terminated.

Arguments:

    Number      - Supplies the number.

    ClassName   - returns classname for device object on success,
                  (ClassName->Buffer == NULL) indicates failure

Return Value:

    None - caller determines success or failure by examining ClassName->Buffer.

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  digits;
    WCHAR           digitsBuffer[10];
    UNICODE_STRING  prefix;

    PAGED_CODE();

    // initialize ClassName to failure state
    RtlInitUnicodeString(ClassName, NULL);


    // create prefix
    RtlInitUnicodeString(&prefix, (PWSTR)L"\\Device\\Parallel");


    // create suffix
    digits.Length        = 0;
    digits.MaximumLength = sizeof(digitsBuffer);
    digits.Buffer        = digitsBuffer;
    status = RtlIntegerToUnicodeString(Number, 10, &digits);
    if ( !NT_SUCCESS(status) ) {
        return;
    }


    // calculate required space, allocate paged pool, and zero buffer
    ClassName->MaximumLength = (USHORT)(prefix.Length + digits.Length + sizeof(WCHAR));
    ClassName->Buffer = ExAllocatePool(PagedPool, ClassName->MaximumLength);
    if( !ClassName->Buffer ) {
        // unable to allocate pool, set ClassName to failure state and return
        RtlInitUnicodeString(ClassName, NULL);
        return;
    }
    RtlZeroMemory(ClassName->Buffer, ClassName->MaximumLength);
    

    // try to catenate prefix and suffix in buffer to form ClassName
    status = RtlAppendUnicodeStringToString(ClassName, &prefix);
    if( !NT_SUCCESS(status) ) {
        // error on prefix, release buffer, set ClassName to error state
        RtlFreeUnicodeString(ClassName);
    } else {
        // prefix ok, try appending suffix
        status = RtlAppendUnicodeStringToString(ClassName, &digits);
        if( !NT_SUCCESS(status) ) {
            // error on suffix, release buffer, set ClassName to failure state
            RtlFreeUnicodeString(ClassName);
        }
    }

    return;
}

VOID
ParMakeDotClassNameFromBaseClassName(
    IN  PUNICODE_STRING BaseClassName,
    IN  ULONG           Number,
    OUT PUNICODE_STRING DotClassName
    )
/*++dvdf - code complete - compiles clean - not tested

Routine Description:


    This routine creates a ClassName for a ParClass PDO of the form:
      L"\Device\ParallelN.M" where L"\Device\ParallelN" is the 
      BaseClassName and M is the wide string representation of 
      the 'Number' parameter. The returned value is intended to be
      used as the ClassName of a ParClass 1284.3 Daisy Chain device
      or a ParClass End-Of-Chain PnP device. BaseClassName is not
      modified.

    Note: On success DotClassName->Buffer points to allocated pool. 
      The caller is responsible for freeing this allocation when 
      it is no longer required.

    Note: The returned DotClassName->Buffer is UNICODE_NULL terminated.

Arguments:

    BaseClassName - points to the ClassName of the PODO for the Raw 
                      host port to which this device is connected

    Number        - supplies the 1284.3 daisy chain device ID [0..3] for
                      a 1284.3 daisy chain device or 4 for an
                      End-Of-Chain PnP device.

    DotClassName  - returns the ClassName to be used for the PDO on success,
                    (DotClassName->Buffer == NULL) indicates failure

Return Value:

    None - caller determines success or failure by examining DotClassName->Buffer.

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  digits;
    UNICODE_STRING  dot;
    WCHAR           digitsBuffer[10];

    PAGED_CODE();

    if( Number > DOT3_LEGACY_ZIP_ID ) {
        // 0..3 are Daisy Chain devices, 4 is End-Of-Chain device, 5 is Legacy Zip
        RtlInitUnicodeString(DotClassName, NULL);
        return;
    }

    RtlInitUnicodeString(&dot, (PWSTR)L".");

    digits.Length        = 0;
    digits.MaximumLength = sizeof(digitsBuffer);
    digits.Buffer        = digitsBuffer;
    status = RtlIntegerToUnicodeString(Number, 10, &digits);
    if ( !NT_SUCCESS(status) ) {
        RtlInitUnicodeString(DotClassName, NULL);
        return;
    }

    DotClassName->MaximumLength = (USHORT)(BaseClassName->Length + digits.Length + dot.Length + 2*sizeof(UNICODE_NULL));
    DotClassName->Buffer = ExAllocatePool(PagedPool, DotClassName->MaximumLength);
    if (!DotClassName->Buffer) {
        RtlInitUnicodeString(DotClassName, NULL);
        return;
    }

    RtlZeroMemory(DotClassName->Buffer, DotClassName->MaximumLength);

    RtlAppendUnicodeStringToString(DotClassName, BaseClassName);
    RtlAppendUnicodeStringToString(DotClassName, &dot);
    RtlAppendUnicodeStringToString(DotClassName, &digits);

    return;
}

VOID
ParAcquireListMutexAndKillDeviceObject(
    IN PDEVICE_OBJECT Fdo, 
    IN PDEVICE_OBJECT DevObj
    ) 
/*++dvdf - code complete - compiles clean - not tested

Routine Description:

    This function provides a wrapper around ParKillDeviceObject() that
      handles acquiring and releasing the Mutex that protects the list
      of ParClass created PDOs and PODOs. 

    ParKillDeviceObject() requires that its caller hold the FDO ListMutex.

Arguments:

    Fdo    - points to the ParClass FDO (The Mutex resides in the FDO extension)

    DevObj - points to the DeviceObject to be killed

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;

    PAGED_CODE();

    ExAcquireFastMutex(&fdoExt->DevObjListMutex);
    ParKillDeviceObject(DevObj);
    ExReleaseFastMutex(&fdoExt->DevObjListMutex);
}

VOID
ParAddDevObjToFdoList(
    IN PDEVICE_OBJECT DevObj
    ) 
/*++dvdf - code complete - compiles clean - not tested

Routine Description:

    This function adds a PDO or PODO to the list of ParClass 
      created PODOs and PDOs. The DevObj is added to the front
      of the list.

Arguments:

    DevObj - points to the DeviceObject (PDO or PODO) to be added to the list

Return Value:

    None   - This function can not fail.

--*/
{
    PDEVICE_EXTENSION devObjExt = DevObj->DeviceExtension;
    PDEVICE_EXTENSION fdoExt    = devObjExt->ParClassFdo->DeviceExtension;

    PAGED_CODE();

    ExAcquireFastMutex(&fdoExt->DevObjListMutex);
    devObjExt->Next     = fdoExt->ParClassPdo;
    fdoExt->ParClassPdo = DevObj;
    ExReleaseFastMutex(&fdoExt->DevObjListMutex);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\power.c ===
//
// This file contains functions that handle Power Management IRPs
//

/*++

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    power.c

Abstract:

    This file contains routines that handle ParClass Power Management IRPs.

Revision History :

--*/

#include "pch.h"


NTSTATUS
ParPower (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   )
/*++

Routine Description:

    This is the ParClass dispatch routine for all Power Management IRPs.

Arguments:

    pDeviceObject           - represents a parallel device

    pIrp                    - Power IRP

Return Value:

    STATUS_SUCCESS          - if successful.
    !STATUS_SUCCESS         - otherwise.

--*/
{
    PDEVICE_EXTENSION Extension = pDeviceObject->DeviceExtension;

    //
    // determine the type of DeviceObject and forward the call as appropriate
    //
    if( Extension->IsPdo ) {
        return ParPdoPower (Extension, pIrp); // this is a PDO (PODOs never get Power IRPs)
    } else {
        return ParFdoPower (Extension, pIrp); // this is the ParClass FDO
    }
}

NTSTATUS
ParPdoPower (
    IN PDEVICE_EXTENSION    Extension,
    IN PIRP                 pIrp
   )
/*++

Routine Description:

    This routine handles all Power IRPs for PDOs.

Arguments:

    pDeviceObject           - represents a parallel device

    pIrp                    - PNP Irp

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    POWER_STATE_TYPE    powerType;
    POWER_STATE         powerState;
    PIO_STACK_LOCATION  pIrpStack;
    NTSTATUS            status = STATUS_SUCCESS;

    ParDump2(PARPOWER, ("ParPdoPower(...)\n") );

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    powerType = pIrpStack->Parameters.Power.Type;
    powerState = pIrpStack->Parameters.Power.State;

    switch (pIrpStack->MinorFunction) {

    case IRP_MN_QUERY_POWER:

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SET_POWER:

        ParDump2(PARPOWER, ("PARCLASS-PnP Setting %s state to %d\n",
                            ((powerType == SystemPowerState) ?  "System" : "Device"),
                            powerState.SystemState) );

        switch (powerType) {
        
        case DevicePowerState:
        
            if (Extension->DeviceState < powerState.DeviceState) {

                //
                // Powering down
                //

                if (PowerDeviceD0 == Extension->DeviceState) {

                    //
                    // Do the power on stuff here.
                    //

                }

            } else if (powerState.DeviceState < Extension->DeviceState) {

                //
                // Powering Up
                //
            }

            PoSetPowerState (Extension->DeviceObject, powerType, powerState);
            Extension->DeviceState = powerState.DeviceState;

            break;

        case SystemPowerState:

            status = STATUS_SUCCESS;
            break;
        }

        break;

    default:

        status = STATUS_NOT_SUPPORTED;
    }

    pIrp->IoStatus.Status = status;
    PoStartNextPowerIrp (pIrp);
    IoCompleteRequest (pIrp, IO_NO_INCREMENT);
    return (status);
}

NTSTATUS
ParPowerComplete (
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp,
    IN PDEVICE_EXTENSION    Extension
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs.

Arguments:

    pDeviceObject           - represents the port device

    pIrp                    - PNP irp

    Extension               - Device Extension

Return Value:

    Status

--*/
{
    POWER_STATE_TYPE    powerType;
    POWER_STATE         powerState;
    PIO_STACK_LOCATION  pIrpStack;

    UNREFERENCED_PARAMETER( pDeviceObject );

    ParDump2(PARPOWER, ("Enter ParPowerComplete(...)\n") );

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    powerType = pIrpStack->Parameters.Power.Type;
    powerState = pIrpStack->Parameters.Power.State;

    switch (pIrpStack->MinorFunction) {

    case IRP_MN_QUERY_POWER:

        ASSERTMSG ("Invalid power completion minor code: Query Power\n", FALSE);
        break;

    case IRP_MN_SET_POWER:

        ParDump2(PARPOWER, ("PARCLASS-PnP Setting %s state to %d\n",
                            ((powerType == SystemPowerState) ?  "System" : "Device"),
                            powerState.SystemState) );

        switch (powerType) {

        case DevicePowerState:

            if (Extension->DeviceState < powerState.DeviceState) {

                //
                // Powering down
                //

                ASSERTMSG ("Invalid power completion Device Down\n", FALSE);

            } else if (powerState.DeviceState < Extension->DeviceState) {

                //
                // Powering Up
                //
                if( Extension->IsPdo ) {
                    // only call for PDOs
                    PoSetPowerState (Extension->DeviceObject, powerType, powerState);
                }

                if (PowerDeviceD0 == Extension->DeviceState) {

                    //
                    // Do the power on stuff here.
                    //

                }
                Extension->DeviceState = powerState.DeviceState;
            }
            break;

        case SystemPowerState:

            if (Extension->SystemState < powerState.SystemState) {

                //
                // Powering down
                //

                ASSERTMSG ("Invalid power completion System Down\n", FALSE);

            } else if (powerState.SystemState < Extension->SystemState) {

                //
                // Powering Up
                //
                if (PowerSystemWorking == powerState.SystemState) {

                    //
                    // Do the system start up stuff here.
                    //

                    powerState.DeviceState = PowerDeviceD0;
                    PoRequestPowerIrp (Extension->DeviceObject,
                                       IRP_MN_SET_POWER,
                                       powerState,
                                       NULL, // no completion function
                                       NULL, // and no context
                                       NULL);
                }

                Extension->SystemState = powerState.SystemState;
            }
            break;
        }

        break;

    default:
        ASSERTMSG ("Power Complete: Bad Power State", FALSE);
    }

    PoStartNextPowerIrp (pIrp);

    return STATUS_SUCCESS;
}

NTSTATUS
ParFdoPower (
    IN PDEVICE_EXTENSION    Extension,
    IN PIRP                 pIrp
   )
/*++

Routine Description:

    This routine handles all Power IRPs Fdos.

Arguments:

    pDeviceObject           - represents a parallel device

    pIrp                    - PNP Irp

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    POWER_STATE_TYPE    powerType;
    POWER_STATE         powerState;
    PIO_STACK_LOCATION  pIrpStack;
    NTSTATUS            status = STATUS_SUCCESS;
    BOOLEAN             hookit = FALSE;

    ParDump2(PARPOWER, ("ParFdoPower(...)\n") );

    {
        NTSTATUS status = ParAcquireRemoveLock(&Extension->RemoveLock, pIrp);
        if (!NT_SUCCESS (status)) {
            pIrp->IoStatus.Status = status;
            pIrp->IoStatus.Information = 0;
            PoStartNextPowerIrp( pIrp );
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            return status;
        }
    }

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    powerType  = pIrpStack->Parameters.Power.Type;
    powerState = pIrpStack->Parameters.Power.State;

    switch (pIrpStack->MinorFunction) {

    case IRP_MN_QUERY_POWER:

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SET_POWER:

        ParDump2(PARPOWER, ("PARCLASS-PnP Setting %s state to %d\n",
                            ((powerType == SystemPowerState) ?  "System" : "Device"),
                            powerState.SystemState) );

        switch (powerType) {

        case DevicePowerState:

            if (Extension->DeviceState < powerState.DeviceState) {
                //
                // Powering down
                //

                // Don't call - this is an FDO
                // PoSetPowerState (Extension->DeviceObject, powerType, powerState);

                if (PowerDeviceD0 == Extension->DeviceState) {

                    //
                    // Do the power on stuff here.
                    //

                    //
                    // WORKWORK
                    //
                    // We must check to see that our children are in a
                    // consistent power state.
                    //

                }
                Extension->DeviceState = powerState.DeviceState;

            } else if (powerState.DeviceState < Extension->DeviceState) {

                //
                // Powering Up
                //
                hookit = TRUE;
            }

            break;

        case SystemPowerState:

            if (Extension->SystemState < powerState.SystemState) {

                //
                // Powering down
                //
                if (PowerSystemWorking == Extension->SystemState) {

                    //
                    // Do the system shut down stuff here.
                    //

                }

                powerState.DeviceState = PowerDeviceD3;
                PoRequestPowerIrp (Extension->DeviceObject,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   NULL, // no completion function
                                   NULL, // and no context
                                   NULL);
                Extension->SystemState = powerState.SystemState;

            } else if (powerState.SystemState < Extension->SystemState) {

                //
                // Powering Up
                //
                hookit = TRUE;
            }
            break;
        }

        break;

    default:

        status = STATUS_NOT_SUPPORTED;
    }

    IoCopyCurrentIrpStackLocationToNext (pIrp);

    if (!NT_SUCCESS (status)) {

        pIrp->IoStatus.Status = status;
        PoStartNextPowerIrp (pIrp);
        IoCompleteRequest (pIrp, IO_NO_INCREMENT);

    } else if (hookit) {

        IoSetCompletionRoutine(pIrp, ParPowerComplete, Extension, TRUE, TRUE, TRUE);
        status = PoCallDriver(Extension->ParentDeviceObject, pIrp);

    } else {

        PoStartNextPowerIrp (pIrp);
        status = PoCallDriver (Extension->ParentDeviceObject, pIrp);

    }

    ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\pnppdo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pnppdo.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with handling IRPs sent to a PDO
//

#include "pch.h"

NTSTATUS
ParPdoParallelPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   )
/*++

Routine Description:

    This routine handles all PNP IRPs for the PDOs.

Arguments:

    pDeviceObject           - represents a parallel device

    pIrp                    - PNP Irp

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    NTSTATUS                        Status = STATUS_SUCCESS;
    PDEVICE_EXTENSION               Extension;
    // PVOID                           pDriverObject;
    PIO_STACK_LOCATION              pIrpStack;
    // PIO_STACK_LOCATION              pNextIrpStack;
    // KEVENT                          Event;
    // ULONG                           cRequired;
    // GUID                            Guid;
    // WCHAR                           wszGuid[64];
    // UNICODE_STRING                  uniGuid;
    // WCHAR                           wszDeviceDesc[64];
    // UNICODE_STRING                  uniDevice;

    //    ParDump(PARDUMP_VERBOSE_MAX, 
    //            ("PARALLEL: "
    //             "Enter ParPdoParallelPnp(...): IRP_MJ_PNP\n") );

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    Extension = pDeviceObject->DeviceExtension;

    //
    // dvdf RMT - don't blindly set information to 0 
    //  - kills info passed down by disk.sys and prevents ZipPlus
    //      from getting assigned a drive letter.
    //
    // pIrp->IoStatus.Information = 0; // dvdr


    //
    // bail out if a delete is pending for this device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_DELETE_PENDING) {
        pIrp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    if(Extension->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {
        ParDumpP( ("PDO PnP Dispatch - PAR_DEVICE_PORT_REMOVE_PENDING - IRP MN == %x\n", pIrpStack->MinorFunction) );
    }

    //
    // The only PnP IRP that a PODO should receive is QDR/TargetDeviceRelation.
    // Any other PnP IRP is an error.
    //
    if( ( Extension->DeviceType == PAR_DEVTYPE_PODO ) &&
        ! ( ( pIrpStack->MinorFunction == IRP_MN_QUERY_DEVICE_RELATIONS               ) &&
            ( pIrpStack->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation ) ) ) {

        ASSERTMSG( "PnP IRP sent to legacy device object ", FALSE);
        pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;
    }


    switch (pIrpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ParDumpP( ("START_DEVICE - %wZ\n", &Extension->SymbolicLinkName) );
        Extension->DeviceStateFlags = PAR_DEVICE_STARTED;
        
        // tell parport device to list us in its PnP QDR/RemovalRelations response
        // yes, we ignore the return value
        Status = ParRegisterForParportRemovalRelations( Extension );

        // initialize WMI context structure and register for WMI
        // yes, we ignore the return value
        Status = ParWmiPdoInitWmi(pDeviceObject);

        pIrp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        KeSetEvent(&Extension->PauseEvent, 0, FALSE);
        return STATUS_SUCCESS;
        
    case IRP_MN_QUERY_CAPABILITIES:

        ParDumpP( ("QUERY_CAPABILITIES - %wZ\n", &Extension->SymbolicLinkName) );
        pIrpStack->Parameters.DeviceCapabilities.Capabilities->RawDeviceOK = TRUE;
        Status = STATUS_SUCCESS;
        break;
        
    case IRP_MN_QUERY_DEVICE_RELATIONS:
        
        ParDumpP( ("QUERY_DEVICE_RELATIONS - %wZ - Type=%d\n", 
                   &Extension->SymbolicLinkName, pIrpStack->Parameters.QueryDeviceRelations.Type) );

        if ( pIrpStack->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation ) {

#if 0            
            //
            // Return a reference to this PDO (self)
            //
            PDEVICE_RELATIONS devRel;

            ParDumpP( ("QUERY_DEVICE_RELATIONS - %wZ - TargetRelation\n", &Extension->SymbolicLinkName) );
        
            devRel = ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS)); 

            if (devRel){
                //
                //  Add a reference to the PDO, since CONFIGMG will free it.
                //
                ObReferenceObject(Extension->DeviceObject);
                devRel->Objects[0] = Extension->DeviceObject;
                devRel->Count = 1;
                pIrp->IoStatus.Information = (ULONG_PTR)devRel;
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
#else
            //
            // Forward PnP QueryTargetRelation IRP to ParPort device
            //
            ParDumpP(("Preparing to forward QDR/TargetDevRel to ParPort\n"));
            IoSkipCurrentIrpStackLocation(pIrp);
            return ParCallDriver(Extension->PortDeviceObject, pIrp);

#endif // 0

        } else {
            //
            // We don't handle this type of DeviceRelations query, so...
            //
            //  Fail this Irp by returning the default status (typically STATUS_NOT_SUPPORTED).
            //

            //            ParDumpP( ("QUERY_DEVICE_RELATIONS - %wZ - unhandled relation (!TargetRelation)\n",
            //                       &Extension->SymbolicLinkName) );
            Status = pIrp->IoStatus.Status;
        }

        //
        // Complete the IRP...
        //
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        return Status;


    case IRP_MN_QUERY_DEVICE_TEXT: 
            
        switch(pIrpStack->Parameters.QueryDeviceText.DeviceTextType) {

        case DeviceTextDescription:
            {
                UCHAR           RawString[MAX_ID_SIZE];
                ANSI_STRING     AnsiTextString;
                UNICODE_STRING  UnicodeDeviceText;
                
                RtlInitAnsiString(&AnsiTextString,Extension->DeviceDescription);
                Status = RtlAnsiStringToUnicodeString(&UnicodeDeviceText,&AnsiTextString,TRUE);
                if( NT_SUCCESS( Status ) ) {
                    ParDumpP( ("QUERY_DEVICE_TEXT - DeviceTextDescription - %wZ\n", &UnicodeDeviceText) );
                    pIrp->IoStatus.Information = (ULONG_PTR)UnicodeDeviceText.Buffer;
                }
            }
            break;

        case DeviceTextLocationInformation:
            {
                //
                // Report SymbolicLinkName without the L"\\DosDevices\\" prefix
                //   as the location
                //
                ULONG prefixLength = sizeof(L"\\DosDevices\\") - sizeof(UNICODE_NULL);
                ULONG bufferLength = Extension->SymbolicLinkName.Length - prefixLength + sizeof(UNICODE_NULL);
                PWSTR buffer;
                ParDumpP( ("QUERY_DEVICE_TEXT - DeviceTextLocationInformation\n") );
                ParDumpP( (" - SymbolicLinkName = %wZ , bufferLength = %d\n",
                           &Extension->SymbolicLinkName, bufferLength) );
                if(bufferLength <= MAX_ID_SIZE) {
                    buffer = ExAllocatePool(PagedPool, bufferLength);
                } else {
                    // assume that something went very wrong
                    buffer = NULL;
                }
                if(!buffer) {
                    // unable to allocate a buffer to hold location information
                    pIrp->IoStatus.Information = 0;
                    Status                     = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    // copy location information to buffer and null terminate it
                    PCHAR src = (PCHAR)Extension->SymbolicLinkName.Buffer + prefixLength;
                    RtlCopyMemory( buffer, src, bufferLength - sizeof(UNICODE_NULL) );
                    buffer[ bufferLength/2 - 1 ] = UNICODE_NULL;
                    pIrp->IoStatus.Information   = (ULONG_PTR)buffer;
                    Status = STATUS_SUCCESS;
                    ParDumpP( ("QUERY_DEVICE_TEXT - Device Location - %S\n", buffer) );
                }
            }
            break; // from case DeviceTextLocationInformation:

        default:
            // unknown request type
            // pIrp->IoStatus.Information = 0;
            Status = pIrp->IoStatus.Status;
        }

        break; // from case IRP_MN_QUERY_DEVICE_TEXT:

    case IRP_MN_QUERY_ID: 
        {
            
            //
            // report the id depending on what the device attached to the port returned us
            //
            
            UCHAR           DeviceIdString[MAX_ID_SIZE] = "LPTENUM\\NoPrinterOrNonPnpModel";
            UCHAR           RawString[MAX_ID_SIZE];
            ANSI_STRING     AnsiIdString;
            UNICODE_STRING  UnicodeDeviceId;
            UNICODE_STRING  UnicodeTemp;
            ULONG           DeviceIdLength;
            HANDLE          KeyHandle;
            
            if (Extension->DeviceIdString[0] == 0) {
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
            
            RtlZeroMemory(RawString, sizeof(RawString));

            Status = STATUS_SUCCESS;
            
            switch(pIrpStack->Parameters.QueryId.IdType) {
                
            case BusQueryDeviceID:
                
                if (Extension->DeviceIdString[0] == 0) {
                    Status = STATUS_NOT_FOUND;
                    break;
                } else {
                    sprintf((PCHAR)RawString,"LPTENUM\\%s",Extension->DeviceIdString );
                    ParFixupDeviceId( (PUCHAR)RawString );
                    RtlInitAnsiString(&AnsiIdString, (PCHAR)RawString);
                    Status = RtlAnsiStringToUnicodeString(&UnicodeDeviceId, &AnsiIdString, TRUE);
                }
                
                if( NT_SUCCESS( Status ) ) {
                    ParDumpP( ("QUERY_ID - BusQueryDeviceID - %wZ\n", &UnicodeDeviceId) );
                    pIrp->IoStatus.Information = (ULONG_PTR)UnicodeDeviceId.Buffer;
                }

                break;
                
            case BusQueryInstanceID:
                
                if (Extension->DeviceIdString[0] == 0) {
                    Status = STATUS_NOT_FOUND;
                    break;
                }
                
                //
                // Report SymbolicLinkName without the L"\\DosDevices\\" prefix
                //   as the instance ID
                //
                {
                    ULONG prefixLength = sizeof(L"\\DosDevices\\") - sizeof(UNICODE_NULL);
                    ULONG bufferLength = Extension->SymbolicLinkName.Length - prefixLength + sizeof(UNICODE_NULL);
                    PWSTR buffer;
                    ParDumpP( ("QUERY_ID - BusQueryInstanceID - "
                               "SymbolicLinkName = %wZ , bufferLength = %d\n",
                               &Extension->SymbolicLinkName, bufferLength) );                    
                    if(bufferLength <= MAX_ID_SIZE) {
                        buffer = ExAllocatePool(PagedPool, bufferLength);
                    } else {
                        // assume that something went very wrong
                        buffer = NULL;
                    }
                    if(!buffer) {
                        // unable to allocate a buffer to hold location information
                        pIrp->IoStatus.Information = 0;
                        Status                     = STATUS_INSUFFICIENT_RESOURCES;
                    } else {
                        // copy location information to buffer and null terminate it
                        PCHAR src = (PCHAR)Extension->SymbolicLinkName.Buffer + prefixLength;
                        RtlCopyMemory( buffer, src, bufferLength - sizeof(UNICODE_NULL) );
                        buffer[ bufferLength/2 - 1 ] = UNICODE_NULL;
                        pIrp->IoStatus.Information   = (ULONG_PTR)buffer;
                        Status = STATUS_SUCCESS;
                        ParDumpP( ("QUERY_ID - BusQueryInstanceID - %S\n", buffer) );
                    }
                }
                break;

            case BusQueryHardwareIDs:
                
                if (Extension->DeviceIdString[0] == 0) {
                    // bail out if we don't have a device id
                    Status = STATUS_NOT_FOUND;
                    break;
                }
                
                //
                // Store the port we are attached in the registry under our device instance
                //
                
                Status = IoOpenDeviceRegistryKey( pDeviceObject, PLUGPLAY_REGKEY_DEVICE, KEY_ALL_ACCESS, &KeyHandle );

                if ( NT_SUCCESS(Status) ) {
                    
                    //
                    // Create a new value under our instance, for the port number
                    //
                    sprintf((PCHAR)RawString,"PortName");
                    RtlInitAnsiString(&AnsiIdString,(PCHAR)RawString);

                    //
                    // Now we have to build the actual value contents
                    //
                    {
                        //
                        // - Start with the SymbolicLinkName
                        // - Discard the L"\\DosDevices\\" prefix
                        // WORKWORK/RMT TODO: - Discard the L".N" suffix if this is an End-Of-Chain device
                        // - Append L':'
                        //
                        ULONG prefixLength = sizeof(L"\\DosDevices\\") - sizeof(UNICODE_NULL);
                        ULONG bufferLength = Extension->SymbolicLinkName.Length 
                            - prefixLength + sizeof(PAR_UNICODE_COLON) + sizeof(UNICODE_NULL);
                        PWSTR buffer;
                        ParDumpV( ( "QUERY_ID - BusQueryHardwareIDs - SymbolicLinkName = %wZ , bufferLength = %d\n",
                                    &Extension->SymbolicLinkName, bufferLength) );                    
                        
                        if(bufferLength > MAX_ID_SIZE) {
                            // we had a rollover and our bufferLength is not valid
                            buffer = NULL;
                        } else {
                            buffer = ExAllocatePool(PagedPool, bufferLength);
                        }
                        if(!buffer) {
                            // unable to allocate a buffer to hold location information
                            pIrp->IoStatus.Information = 0;
                            pIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                            return STATUS_INSUFFICIENT_RESOURCES;
                        } else {
                            // copy location information to buffer and null terminate it
                            PCHAR src = (PCHAR)Extension->SymbolicLinkName.Buffer + prefixLength;
                            RtlCopyMemory( buffer, src, bufferLength - sizeof(UNICODE_NULL) );
                            buffer[ bufferLength/2 - 2 ] = PAR_UNICODE_COLON;
                            buffer[ bufferLength/2 - 1 ] = UNICODE_NULL;
                            {
                                // if this is an End-Of-Chain device, discard the L".N" suffix
                                // WARNING - HACKHACK until spooler is fully PnP
                                if( ( (Extension->Ieee1284_3DeviceId == DOT3_END_OF_CHAIN_ID) || Extension->EndOfChain ) &&
                                    (buffer[bufferLength/2 - 3] <= L'9') && 
                                    (buffer[bufferLength/2 - 3] >= L'0') && 
                                    (buffer[bufferLength/2 - 4] == L'.') ) {

                                    buffer[bufferLength/2 - 4] = PAR_UNICODE_COLON;
                                    buffer[bufferLength/2 - 3] = UNICODE_NULL;
                                }                                    
                            }
                            RtlInitUnicodeString(&UnicodeTemp, buffer);
                        }
                    }
                    
                    {
                        UNICODE_STRING UnicodeRegValueName;
                        NTSTATUS       status;
                        
                        status = RtlAnsiStringToUnicodeString(&UnicodeRegValueName,&AnsiIdString,TRUE);

                        if( NT_SUCCESS ( status ) ) {
                            ZwSetValueKey( KeyHandle, &UnicodeRegValueName, 0, REG_SZ, UnicodeTemp.Buffer, UnicodeTemp.Length*sizeof(UCHAR) );
                            RtlFreeUnicodeString(&UnicodeRegValueName);
                        }

                    }

                    ZwClose(KeyHandle);

                }
                
                ParDumpP( ("QUERY_ID - BusQueryHardwareIDs\n") );

                //
                // continue on, to return the actual HardwareID string
                //
                
            case BusQueryCompatibleIDs:
                
                if (Extension->DeviceIdString[0] == 0) {
                    Status = STATUS_NOT_FOUND;
                    break;
                }
                
                Status = ParPnpGetId(Extension->DeviceIdString,pIrpStack->Parameters.QueryId.IdType,RawString, NULL);
                
                if( NT_SUCCESS( Status ) ) {
                    
                    RawString[strlen((PCHAR)RawString)+1]=0;
                    RawString[strlen((PCHAR)RawString)]=32;
                    ParFixupDeviceId( (PUCHAR)RawString );
                    RtlInitAnsiString(&AnsiIdString,(PCHAR)RawString);

                    Status = RtlAnsiStringToUnicodeString(&UnicodeDeviceId,&AnsiIdString,TRUE);

                    if( NT_SUCCESS( Status ) ) {

                        ParDumpP( ("QUERY_ID - BusQueryHardwareIDs/BusQueryCompatibleIDs - %wZ\n", &UnicodeDeviceId) );

                        // Now append another NULL, to terminate the multi_sz
                        UnicodeTemp.Buffer = UnicodeDeviceId.Buffer;
                        ((PSTR)UnicodeTemp.Buffer) += (UnicodeDeviceId.Length-2);
                        RtlZeroMemory(UnicodeTemp.Buffer,sizeof(WCHAR));
                        pIrp->IoStatus.Information = (ULONG_PTR)UnicodeDeviceId.Buffer;
                    }

                }
                break;

            default:

                //
                // unrecognized IdType
                //
                Status = pIrp->IoStatus.Status;

            } // end switch(pIrpStack->Parameters.QueryId.IdType)

            break;
        }

    case IRP_MN_QUERY_STOP_DEVICE:
        
        ParDumpP( ("QUERY_STOP_DEVICE - %wZ\n", &Extension->SymbolicLinkName) );
        Extension->DeviceStateFlags |= (PAR_DEVICE_STOP_PENDING | PAR_DEVICE_PAUSED);
        KeClearEvent(&Extension->PauseEvent);
        Status = STATUS_SUCCESS;
        break;
        
    case IRP_MN_CANCEL_STOP_DEVICE:
        
        ParDumpP( ("IRP_MN_CANCEL_STOP_DEVICE - %wZ\n", &Extension->SymbolicLinkName) );
        Extension->DeviceStateFlags &= ~PAR_DEVICE_STOP_PENDING;
        KeSetEvent(&Extension->PauseEvent, 0, FALSE);
        Status = STATUS_SUCCESS;
        break;
        
    case IRP_MN_STOP_DEVICE:
        
        ParDumpP( ("IRP_MN_STOP_DEVICE - %wZ\n", &Extension->SymbolicLinkName) );
        Extension->DeviceStateFlags |=  PAR_DEVICE_PAUSED;
        Extension->DeviceStateFlags &= ~PAR_DEVICE_STARTED;
        KeClearEvent(&Extension->PauseEvent);
        Status = STATUS_SUCCESS;
        break;
        
    case IRP_MN_QUERY_REMOVE_DEVICE:
        
        // Succeed if no one has an open handle to us, fail otherwise
        ExAcquireFastMutex(&Extension->OpenCloseMutex);
        if(Extension->OpenCloseRefCount > 0) {
            DDPnP1(("## Fail QueryRemove - %wZ\n",&Extension->SymbolicLinkName));
            ParDump2(PARPNP1, ("QUERY_REMOVE_DEVICE - %wZ - FAIL - open handles to us\n", &Extension->SymbolicLinkName) );
            Status = STATUS_DEVICE_BUSY;
        } else {
            DDPnP1(("## Succeed QueryRemove - %wZ\n",&Extension->SymbolicLinkName));
            ParDump2(PARPNP1, ("IRP_MN_QUERY_REMOVE_DEVICE - %wZ - SUCCEED\n", &Extension->SymbolicLinkName) );
            Extension->DeviceStateFlags |= (PAR_DEVICE_REMOVE_PENDING | PAR_DEVICE_PAUSED);
            KeClearEvent(&Extension->PauseEvent);
            if( Extension->PortDeviceFileObject ) {
                //
                // close our handle to parport so we don't block a parport removal
                //
                ParDump2(PARPNP1, ("CLOSE our handle to ParPort\n") );
                ObDereferenceObject( Extension->PortDeviceFileObject );
                Extension->PortDeviceFileObject = NULL;
            }
            Status = STATUS_SUCCESS;
        }
        ExReleaseFastMutex(&Extension->OpenCloseMutex);
        break;
            
    case IRP_MN_CANCEL_REMOVE_DEVICE:

        DDPnP1(("## CancelRemove - %wZ\n",&Extension->SymbolicLinkName));

        ParDumpP( ("CANCEL_REMOVE_DEVICE - %wZ\n", &Extension->SymbolicLinkName) );

        Extension->DeviceStateFlags &= ~(PAR_DEVICE_REMOVE_PENDING | PAR_DEVICE_PAUSED);

        if( !Extension->PortDeviceFileObject ) {
            
            //
            // we dropped our connection to our ParPort prior to
            //   our ParPort receiving QUERY_REMOVE, reestablish
            //   a FILE connection and resume operation
            //

            NTSTATUS       status;
            PFILE_OBJECT   portDeviceFileObject;
            PDEVICE_OBJECT portDeviceObject;
            
            ParDump2(PARPNP1, ("reopening file against our ParPort\n") );
            
            status = IoGetDeviceObjectPointer(&Extension->PortSymbolicLinkName,
                                              STANDARD_RIGHTS_ALL,
                                              &portDeviceFileObject,
                                              &portDeviceObject);
            
            if(NT_SUCCESS(status) && portDeviceFileObject && portDeviceObject) {
                // save REFERENCED PFILE_OBJECT in our device extension
                Extension->PortDeviceFileObject = portDeviceFileObject;
                // our ParPort device object should not have changed
                ASSERT(Extension->PortDeviceObject == portDeviceObject);

            } else {
                ParDump2(PARPNP1, ("Unable to reopen FILE against our ParPort\n") );
                
                //
                // Unable to reestablish connection? Inconceivable!
                //
                ASSERT(FALSE);
            }
        }

        KeSetEvent(&Extension->PauseEvent, 0, FALSE);
        Status = STATUS_SUCCESS;
        break;  
     
    case IRP_MN_REMOVE_DEVICE:
        
        DDPnP1(("## RemoveDevice - %wZ\n",&Extension->SymbolicLinkName));

        ParDumpP( ("REMOVE_DEVICE - %x <%wZ>\n", Extension->DeviceObject, &Extension->SymbolicLinkName) );

        Status = ParUnregisterForParportRemovalRelations( Extension );

        //
        // Unregister with WMI
        //
        ParWMIRegistrationControl(pDeviceObject, WMIREG_ACTION_DEREGISTER);

        ParDumpP( ("REMOVE_DEVICE - %wZ - Checking if device still there...\n",
                   &Extension->SymbolicLinkName) );

        if( !(Extension->DeviceStateFlags & PAR_DEVICE_HARDWARE_GONE) && ParDeviceExists(Extension,FALSE) ) {
            ParDumpP( ("REMOVE_DEVICE - %wZ - Device still there - Keep DO\n",
                       &Extension->SymbolicLinkName) );
            Extension->DeviceStateFlags = PAR_DEVICE_PAUSED;
        } else {
            ParDumpP( ("REMOVE_DEVICE - %wZ - Device no longer present - Kill DO\n",
                       &Extension->SymbolicLinkName) );

            {
                //
                // Clean up the device object
                //
                PDEVICE_EXTENSION FdoExtension = Extension->ParClassFdo->DeviceExtension;
                ExAcquireFastMutex(&FdoExtension->DevObjListMutex);
                ParKillDeviceObject(pDeviceObject);
                ExReleaseFastMutex(&FdoExtension->DevObjListMutex);
            }
        }

        Status = STATUS_SUCCESS;
        break;
        

    case IRP_MN_SURPRISE_REMOVAL:

#define PAR_HANDLE_SURPRISE_REMOVAL 1
#if PAR_HANDLE_SURPRISE_REMOVAL

        ParDumpP( ("SURPRISE_REMOVAL - %wZ - handled\n", &Extension->SymbolicLinkName) );

        // note in our extension that we received SURPRISE_REMOVAL
        Extension->DeviceStateFlags |= PAR_DEVICE_SURPRISE_REMOVAL;

        // stop the worker thread
        KeClearEvent(&Extension->PauseEvent);        
        Status = STATUS_SUCCESS;
        break;

#else
        ParDumpP( ("SURPRISE_REMOVAL - %wZ - NOT handled\n", &Extension->SymbolicLinkName) );
        // we don't handle yet - fall through to default

#endif

    default:
        
        ParDumpP(("ParPdoParallelPnp - %wZ - Unhandled IRP %x\n",
                  &Extension->SymbolicLinkName, pIrpStack->MinorFunction) );
        Status = pIrp->IoStatus.Status; // Don't modify status
        break;
    }

    //
    // Complete the IRP...
    //
    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\pnpfdo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       pnpfdo.c
//
//--------------------------------------------------------------------------

//
// This file contains functions for handing AddDevice and PnP IRPs sent to the FDO
//

#include "pch.h"

NTSTATUS
ParPnpNotifyHwProfileChange(
    IN PHWPROFILE_CHANGE_NOTIFICATION NotificationStructure,
    IN PDEVICE_OBJECT                 Fdo
    )
//
// We just completed either a dock or an undock - trigger bus rescan to check for new devices
//
{
    PDEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PAGED_CODE();

    if( IsEqualGUID( (LPGUID)&(NotificationStructure->Event), (LPGUID)&GUID_HWPROFILE_CHANGE_COMPLETE) ) {
        IoInvalidateDeviceRelations( fdoExt->PhysicalDeviceObject, BusRelations );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
ParPnpFdoStartDevice(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
{
    NTSTATUS                        status = STATUS_NOT_SUPPORTED;
    PDEVICE_EXTENSION               fdoExt = Fdo->DeviceExtension;
    KEVENT                          event;

    ParDumpP( ("IRP_MN_START_DEVICE - FDO\n") );
        
    //
    // The stack below us must successfully START before we can START.
    //
    // Pass the IRP down the stack and catch it on the way back up in our
    //   completion routine. Our completion routine simply sets "event" 
    //   to its signalled state and returns STATUS_MORE_PROCESSING_REQUIRED,
    //   which allows us to regain control of the IRP in this routine after
    //   the stack below us has finished processing the START.
    // 

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, ParSynchCompletionRoutine, &event, TRUE, TRUE, TRUE );
    status = ParCallDriver(fdoExt->ParentDeviceObject, Irp);
        
    // wait for our completion routine to signal that it has caught the IRP
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    //
    // We have control of the IRP again and the stack below us has finished processing.
    //

    if( status == STATUS_PENDING ) {
        // IRP completed asynchronously below us - extract "real" status from the IRP
        status = Irp->IoStatus.Status;
    }
        
    //
    // did anyone below us FAIL the IRP?
    //
    if( !NT_SUCCESS(status) ) {
        // someone below us FAILed the IRP, bail out
        ParDump2(PARERRORS, ("START IRP FAILED below us in stack, status=%x\n", status) );
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        ParReleaseRemoveLock(&fdoExt->RemoveLock, Irp);
        return status;
    }
        
    //
    // The stack below us is STARTed.
    //

    //
    // Register for ParPort PnP Interface changes. 
    //
    // We will get an ARRIVAL callback for every ParPort device that is STARTed and 
    //   a REMOVAL callback for every ParPort that is REMOVEd
    //

#if 0 // disable parclass enumeration to work with new parport enumerator - DFritz - 2000-03-25
    status = IoRegisterPlugPlayNotification (EventCategoryDeviceInterfaceChange,
                                             PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,
                                             (PVOID)&GUID_PARALLEL_DEVICE,
                                             Fdo->DriverObject,
                                             (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)ParPnpNotifyInterfaceChange,
                                             (PVOID)Fdo,
                                             &fdoExt->NotificationHandle);
        
    if (!NT_SUCCESS(status)) {
        // registration failed, we will never have any ParPort devices to talk to
        ParDumpP( ("IoRegisterPlugPlayNotification InterfaceChange FAILED, status= %x\n", status) );
    }
        
    status = IoRegisterPlugPlayNotification( EventCategoryHardwareProfileChange,
                                             0,
                                             NULL,
                                             Fdo->DriverObject,
                                             (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE)ParPnpNotifyHwProfileChange,
                                             (PVOID)Fdo,
                                             &fdoExt->HwProfileChangeNotificationHandle );

    if (!NT_SUCCESS(status)) {
        // registration failed, we will never have any ParPort devices to talk to
        ParDumpP( ("IoRegisterPlugPlayNotification HwProfileChange FAILED, status= %x\n", status) );
    }
#endif // 0 

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    ParReleaseRemoveLock(&fdoExt->RemoveLock, Irp);
    return status;
}

NTSTATUS
ParPnpFdoQueryCapabilities(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
{
    NTSTATUS                        status;
    PDEVICE_EXTENSION               fdoExt = Fdo->DeviceExtension;
    // KEVENT                          event;
    PIO_STACK_LOCATION              irpStack;

    ParDumpP( ("IRP_MN_QUERY_CAPABILITIES - FDO\n") );

    irpStack = IoGetCurrentIrpStackLocation( Irp );

    // - does RawDeviceOK = TRUE make sense for the FDO?


    //
    // Start us even if no function driver or filter driver is found.
    //
    irpStack->Parameters.DeviceCapabilities.Capabilities->RawDeviceOK = TRUE;

    //
    // The instance ID's that we report are system wide unique.
    //
    // irpStack->Parameters.DeviceCapabilities.Capabilities->UniqueID    = TRUE; 
    // - change to FALSE because we reuse names for LPTx.y during rescan 
    //     when we detect that the daisy chain devices changed
    //
    irpStack->Parameters.DeviceCapabilities.Capabilities->UniqueID    = FALSE; 

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    status = ParCallDriver(fdoExt->ParentDeviceObject, Irp);
    ParReleaseRemoveLock(&fdoExt->RemoveLock, Irp);
    return status;
}


NTSTATUS
ParFdoParallelPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   )
/*++

Routine Description:

    This routine handles all PNP IRPs sent to the ParClass FDO.
    We got here because !(Extension->IsPdo)

Arguments:

    pDeviceObject           - The ParClass FDO

    pIrp                    - PNP Irp

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    NTSTATUS                        Status = STATUS_NOT_SUPPORTED;
    PDEVICE_EXTENSION               Extension;
    PVOID                           pDriverObject;
    PIO_STACK_LOCATION              pIrpStack;
    PIO_STACK_LOCATION              pNextIrpStack;
    KEVENT                          Event;
    ULONG                           cRequired;
    // GUID                            Guid;
    WCHAR                           wszGuid[64];
    UNICODE_STRING                  uniGuid;
    // WCHAR                           wszDeviceDesc[64];
    UNICODE_STRING                  uniDevice;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    Extension = pDeviceObject->DeviceExtension; // FDO Extension

    {
        NTSTATUS status = ParAcquireRemoveLock(&Extension->RemoveLock, pIrp);
        if ( !NT_SUCCESS( status ) ) {
            //
            // Someone gave us a pnp irp after a remove.  Unthinkable!
            //
            // ASSERT(FALSE);
            pIrp->IoStatus.Information = 0;
            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            return status;
        }
    }

    // dvdr 
    // pIrp->IoStatus.Information = 0;

    switch (pIrpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:
        
        return ParPnpFdoStartDevice(pDeviceObject, pIrp);

    case IRP_MN_QUERY_CAPABILITIES:
        
        ParDumpP( ("IRP_MN_QUERY_CAPABILITIES - FDO\n") );
        pIrpStack->Parameters.DeviceCapabilities.Capabilities->RawDeviceOK = TRUE; // no Function Driver required
        pIrpStack->Parameters.DeviceCapabilities.Capabilities->UniqueID    = TRUE; // ID's reported are system wide unique
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation(pIrp);
        ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
        return ParCallDriver(Extension->ParentDeviceObject, pIrp);


    case IRP_MN_QUERY_DEVICE_RELATIONS: {
        
        ParDumpP( ("QUERY_DEVICE_RELATIONS - FDO\n") );
        
        if(pIrpStack->Parameters.QueryDeviceRelations.Type != BusRelations) {
            break;              // bail out if we don't handle this query type 
        } else {
            return ParPnpFdoQueryDeviceRelationsBusRelations(pDeviceObject, pIrp);
        }
    }
    

    case IRP_MN_QUERY_STOP_DEVICE:
        
        // always SUCCEED
        ParDumpP( ( "QUERY_STOP_DEVICE - FDO\n") );
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (pIrp);
        ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
        return ParCallDriver(Extension->ParentDeviceObject, pIrp);
        

    case IRP_MN_CANCEL_STOP_DEVICE:
        
        ParDumpP( ("CANCEL_STOP_DEVICE - FDO\n") );

        // handle IRP synchronously:
        //  - set completion routine and event to wake on
        //  - pass IRP down the stack
        //  - our completion routine sets the event which wakes us
        //  - we wake on the event and regain control of 
        //      the IRP on its way back up

        // setup
        IoCopyCurrentIrpStackLocationToNext(pIrp);
        IoSetCompletionRoutine(pIrp, ParSynchCompletionRoutine, &Event, TRUE, TRUE, TRUE);
        KeInitializeEvent(&Event, NotificationEvent, FALSE);

        // pass IRP down the stack
        Status = ParCallDriver(Extension->ParentDeviceObject, pIrp);
        
        // wait for our completion routine to wake us up
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

        // we have NOW regained control of the IRP on its way back up the stack

        // extract "real" status from IRP if IoCallDriver returned PENDING
        if (Status == STATUS_PENDING) {
            Status = pIrp->IoStatus.Status;
        }
        
        // check if anyone below us in the stack failed the IRP
        if ( !NT_SUCCESS(Status) && (Status != STATUS_NOT_SUPPORTED) ) {
            ParDumpP( ("CANCEL_STOP_DEVICE failed at parent, Status= %x\n", Status) );
            break;
        }
        
        // SUCCESS
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
        return STATUS_SUCCESS;
        

    case IRP_MN_STOP_DEVICE:
        
        // always SUCCEED
        ParDumpP( ("STOP_DEVICE - FDO\n") );
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation (pIrp);
        ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
        return ParCallDriver(Extension->ParentDeviceObject, pIrp);
        

    case IRP_MN_QUERY_REMOVE_DEVICE:
        
        // SUCCEED if no PODOs (i.e., no parallel ports), FAIL otherwise
        if( Extension->ParClassPdo ) {
            ParDumpP( ("QUERY_REMOVE_DEVICE - FDO - FAIL - Legacy PODOs may be using Ports\n") );
            pIrp->IoStatus.Status = STATUS_DEVICE_BUSY;
            ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
            ParCompleteRequest(pIrp, IO_NO_INCREMENT);
            return STATUS_DEVICE_BUSY;
        } else {
            ParDumpP( ("QUERY_REMOVE_DEVICE - FDO - SUCCESS - no ParPorts exist\n") );
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation (pIrp);
            ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
            return ParCallDriver(Extension->ParentDeviceObject, pIrp);
        }

    case IRP_MN_CANCEL_REMOVE_DEVICE:
        
        ParDumpP( ( "CANCEL_REMOVE_DEVICE - FDO\n") );

        // handle IRP synchronously:
        //  - set completion routine and event to wake on
        //  - pass IRP down the stack
        //  - our completion routine sets the event which wakes us
        //  - we wake on the event and regain control of 
        //      the IRP on its way back up

        // setup
        IoCopyCurrentIrpStackLocationToNext(pIrp);
        IoSetCompletionRoutine(pIrp, ParSynchCompletionRoutine, &Event, TRUE, TRUE, TRUE);
        KeInitializeEvent(&Event, NotificationEvent, FALSE);

        // pass IRP down the stack
        Status = ParCallDriver(Extension->ParentDeviceObject, pIrp);
        
        // wait for our completion routine to wake us up
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

        // we have NOW regained control of the IRP on its way back up the stack

        // extract "real" status from IRP if IoCallDriver returned PENDING
        if (Status == STATUS_PENDING) {
            Status = pIrp->IoStatus.Status;
        }

        // check if anyone below us in the stack failed the IRP
        if (!NT_SUCCESS(Status)) {
            ParDumpP( ("CANCEL_REMOVE_DEVICE FAILED, Status = %x\n", Status) );
            break;
        }
        
        // SUCCESS
        pIrp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
        return STATUS_SUCCESS;

        
    case IRP_MN_REMOVE_DEVICE:
        
        ParDumpP( ("REMOVE_DEVICE - FDO\n") );
        
        Extension->DeviceStateFlags |= PAR_DEVICE_REMOVED;
        
        if(Extension->NotificationHandle) {
            IoUnregisterPlugPlayNotification (Extension->NotificationHandle);
            Extension->NotificationHandle = 0;
        }
        
        if( Extension->HwProfileChangeNotificationHandle ) {
            IoUnregisterPlugPlayNotification( Extension->HwProfileChangeNotificationHandle );
            Extension->HwProfileChangeNotificationHandle = 0;
        }
        
        IoSkipCurrentIrpStackLocation(pIrp);

        pIrp->IoStatus.Status = STATUS_SUCCESS;

        Status = ParCallDriver(Extension->ParentDeviceObject, pIrp);
        
        ParReleaseRemoveLockAndWait(&Extension->RemoveLock, pIrp);

        IoDetachDevice(Extension->ParentDeviceObject);
        
        if (Extension->ClassName.Buffer) {
            ExFreePool(Extension->ClassName.Buffer);
        }    
        
        //
        // walk the list of remaining ParClass ejected device objects and kill them
        //
        {
            PDEVICE_OBJECT current;
            PDEVICE_EXTENSION FdoExtension = Extension; // fix alanmo discovered bug from machine where parport not started

            ExAcquireFastMutex(&FdoExtension->DevObjListMutex);
            current = Extension->ParClassPdo;
            while(current) {
                PDEVICE_OBJECT next = ( (PDEVICE_EXTENSION)(current->DeviceExtension) )->Next;
                ParKillDeviceObject(current);
                current = next;
            }
            ExReleaseFastMutex(&FdoExtension->DevObjListMutex);
        }
        
        Extension->DeviceStateFlags |= PAR_DEVICE_DELETED;
        IoDeleteDevice(pDeviceObject);
        
        return Status;
        

    case IRP_MN_SURPRISE_REMOVAL:

        // ParClass FDO is root enumerated - we should never get this IRP
        ParDumpP( ("IRP_MN_SURPRISE_REMOVAL - FDO - We are not supposed to get this IRP!!!\n") );

        // fall through into default case since we don't handle this

    default:
        
        // We don't handle this request, simply pass it down the stack
        ParDumpP( ("Unhandled PNP IRP: %x - FDO\n", pIrpStack->MinorFunction) );
        IoSkipCurrentIrpStackLocation(pIrp);
        ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
        return ParCallDriver(Extension->ParentDeviceObject, pIrp);

    }
    

    //
    // Set the return code only if we have something to add.
    //
    if( Status != STATUS_NOT_SUPPORTED ) {
        pIrp->IoStatus.Status = Status ;
    }

    //
    // Complete immediately if we have failed the Irp for any reason other 
    // than STATUS_NOT_SUPPORTED. Otherwise, pass down.
    //
    if( NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED) ) {
        IoSkipCurrentIrpStackLocation(pIrp);
        ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
        return ParCallDriver(Extension->ParentDeviceObject, pIrp);
    }

    //
    // Complete the IRP...
    //
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    ParReleaseRemoveLock(&Extension->RemoveLock, pIrp);
    return Status;
}



NTSTATUS
ParPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is the ParClass AddDevice routine.

    This routine creates the ParClass FDO and attaches it to the device stack

Arguments:

    pDriverObject           - pointer to the driver object for this instance of parport.

    pPhysicalDeviceObject   - pointer to the device object that represents the port.

Return Value:

    STATUS_SUCCESS          - if successful.
    !STATUS_SUCCESS         - otherwise.

--*/
{
    PDEVICE_OBJECT      pDeviceObject;
    PDEVICE_EXTENSION   Extension;
    NTSTATUS            Status;

    ParBreak(PAR_BREAK_ON_ADD_DEVICE, ("ParPnpAddDevice(PDRIVER_OBJECT, PDEVICE_OBJECT)\n") );

    //
    // Create the device object for this device.
    //

    Status = ParCreateDevice(pDriverObject, sizeof(DEVICE_EXTENSION), NULL, 
                            FILE_DEVICE_PARALLEL_PORT, 0, TRUE, &pDeviceObject);

    if (!NT_SUCCESS(Status)) {
        ParLogError(pDriverObject, NULL, PhysicalZero, PhysicalZero, 0, 0, 0, 9, STATUS_SUCCESS, Status);
        ParDump(PARERRORS, ("PARALLEL: Could not create a Device Object for FDO\n") );
        return Status;
    }

    //
    // Setup buffered I/O
    //
    pDeviceObject->Flags |= DO_BUFFERED_IO;

    Extension = pDeviceObject->DeviceExtension;

    RtlZeroMemory(Extension, sizeof(DEVICE_EXTENSION));

    Extension->DeviceType = PAR_DEVTYPE_FDO;

    ExInitializeFastMutex(&Extension->OpenCloseMutex);
    ExInitializeFastMutex(&Extension->DevObjListMutex); // only FDO has this Mutex
    IoInitializeRemoveLock(&Extension->RemoveLock, PARCLASS_POOL_TAG, 1, 10);

    Extension->ExtensionSignature    = PARCLASS_EXTENSION_SIGNATURE;
    Extension->ExtensionSignatureEnd = PARCLASS_EXTENSION_SIGNATURE;

    Extension->DeviceObject = pDeviceObject;


    //
    // Attach our new Device to our parent's stack.
    //

    Extension->ParentDeviceObject = IoAttachDeviceToDeviceStack( pDeviceObject, pPhysicalDeviceObject);

    ParDumpV( ("ParPnpAddDevice(...): "
               "pDeviceObject= %08x , Extension= %08x , ParentDeviceObject= %08x\n",
               pDeviceObject, Extension, Extension->ParentDeviceObject) );

    if (NULL == Extension->ParentDeviceObject) {
        ParDump2(PARERRORS, ("ParPnpAddDevice(...): IoAttachDeviceToDeviceStack FAILED\n") );
        IoDeleteDevice(pDeviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Done initializing
    //

    Extension->PhysicalDeviceObject = pPhysicalDeviceObject;
    
    pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\port.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    port.c

Abstract:

    This module contains the code to acquire and release the port
    from the port driver parport.sys.

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PDEVICE_EXTENSION   Extension
    );

VOID
ParReleasePortInfoToPortDevice(
    IN  PDEVICE_EXTENSION   Extension
    );
    
VOID
ParFreePort(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    );

BOOLEAN
ParAllocPort(
    IN  PDEVICE_EXTENSION   Extension
    );


NTSTATUS
ParGetPortInfoFromPortDevice(
    IN OUT  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine will request the port information from the port driver
    and fill it in the device extension.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - Success.
    !STATUS_SUCCESS - Failure.

--*/

{
    KEVENT                      Event;
    PIRP                        Irp;
    PARALLEL_PORT_INFORMATION   PortInfo;
    PARALLEL_PNP_INFORMATION    PnpInfo;
    IO_STATUS_BLOCK             IoStatus;
    NTSTATUS                    Status;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Get Parallel Port Info
    //

    ASSERT(Extension->PortDeviceObject != NULL);

    Irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO,
                                        Extension->PortDeviceObject,
                                        NULL, 
                                        0, 
                                        &PortInfo,
                                        sizeof(PARALLEL_PORT_INFORMATION),
                                        TRUE, 
                                        &Event, 
                                        &IoStatus);

    ASSERT(Irp->StackCount > 0);

    if (!Irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = ParCallDriver(Extension->PortDeviceObject, Irp);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = IoStatus.Status;

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Extension->OriginalController   = PortInfo.OriginalController;
    Extension->Controller           = PortInfo.Controller;
    Extension->SpanOfController     = PortInfo.SpanOfController;
    Extension->TryAllocatePort      = PortInfo.TryAllocatePort;
    Extension->FreePort             = PortInfo.FreePort;
    Extension->QueryNumWaiters      = PortInfo.QueryNumWaiters;
    Extension->PortContext          = PortInfo.Context;
    
    if (Extension->SpanOfController < PARALLEL_REGISTER_SPAN) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get Parallel Pnp Info
    //
    Irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO,
                                        Extension->PortDeviceObject,
                                        NULL, 
                                        0, 
                                        &PnpInfo,
                                        sizeof(PARALLEL_PNP_INFORMATION),
                                        TRUE, 
                                        &Event, 
                                        &IoStatus);

    if (!Irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = ParCallDriver(Extension->PortDeviceObject, Irp);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = IoStatus.Status;

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Extension->EcrController        = PnpInfo.EcpController;
    Extension->HardwareCapabilities = PnpInfo.HardwareCapabilities;
    Extension->TrySetChipMode       = PnpInfo.TrySetChipMode;
    Extension->ClearChipMode        = PnpInfo.ClearChipMode;
    Extension->TrySelectDevice      = PnpInfo.TrySelectDevice;
    Extension->DeselectDevice       = PnpInfo.DeselectDevice;
    Extension->FifoDepth            = PnpInfo.FifoDepth;
    Extension->FifoWidth            = PnpInfo.FifoWidth;
    

    //
    // get symbolic link name to use for this end of chain device
    //   object from ParPort
    //
    // if anything goes wrong, simply leave Extension->SymbolicLinkName alone 
    //   as it was cleared to all zeros via an RtlZeroMemory in 
    //   ParPnpCreateDevice(...) in parpnp.c
    //

    if( ( 0 == Extension->SymbolicLinkName.Length ) && PnpInfo.PortName ) {
      //
      // If we have no SymbolicLinkName and we have a port name, use the port
      //   name to initialize our symbolic link name in our device extension
      //
      UNICODE_STRING pathPrefix;
      UNICODE_STRING portName;
      ULONG          length;
      PWSTR          buffer;

      RtlInitUnicodeString(&pathPrefix, (PWSTR)L"\\DosDevices\\");
      RtlInitUnicodeString(&portName,   PnpInfo.PortName);

      length = pathPrefix.Length + portName.Length + sizeof(UNICODE_NULL);
      buffer = ExAllocatePool(PagedPool, length);

      if(buffer) {
        Extension->SymbolicLinkName.Buffer        = buffer;
        Extension->SymbolicLinkName.Length        = 0;
        Extension->SymbolicLinkName.MaximumLength = (USHORT)length;
        RtlAppendUnicodeStringToString(&Extension->SymbolicLinkName, &pathPrefix);
        RtlAppendUnicodeStringToString(&Extension->SymbolicLinkName, &portName);
      }
    }

    ParDumpV( ("ParGetPortInfoFromPortDevice(...):\n") );
    ParDumpV( (" - ClassName= %wZ , SymbolicLinkName= %wZ , PortDeviceObject= %08x\n", 
               &Extension->ClassName, &Extension->SymbolicLinkName, Extension->PortDeviceObject) );

    return Status;
}


VOID
ParReleasePortInfoToPortDevice(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine will release the port information back to the port driver.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    //
    // ParPort treats this as a NO-OP in Win2K, so don't bother sending the IOCTL.
    //
    // In follow-on to Win2K parport may use this to page the entire driver as
    //   it was originally intended, so we'll turn this back on then.
    //

    return;
#if 0
    KEVENT          Event;
    PIRP            Irp;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS        Status;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    Irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO,
                                        Extension->PortDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0,
                                        TRUE, 
                                        &Event, 
                                        &IoStatus);

    if (!Irp) {
        return;
    }

    Status = ParCallDriver(Extension->PortDeviceObject, Irp);

    if (!NT_SUCCESS(Status)) {
        return;
    }

    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
#endif
}

VOID
ParFreePort(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine calls the internal free port ioctl.  This routine
    should be called before completing an IRP that has allocated
    the port.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    // Don't allow multiple releases

    if (Extension->bAllocated) {
        ParDump2(PARALLOCFREEPORT, ("port::ParFreePort: %x - calling ParPort's FreePort function\n", Extension->Controller) );
        Extension->FreePort(Extension->PortContext);
    } else {
        ParDump2(PARALLOCFREEPORT, ("port::ParFreePort: %x - we don't have the Port!!! (!Ext->bAllocated)\n", Extension->Controller) );
    }
        
    Extension->bAllocated = FALSE;
}


NTSTATUS
ParAllocPortCompletionRoutine(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Event
    )

/*++

Routine Description:

    This routine is the completion routine for a port allocate request.

Arguments:

    DeviceObject    - Supplies the device object.
    Irp             - Supplies the I/O request packet.
    Context         - Supplies the notification event.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - The Irp still requires processing.

--*/

{
    UNREFERENCED_PARAMETER( Irp );
    UNREFERENCED_PARAMETER( DeviceObject );

    KeSetEvent((PKEVENT) Event, 0, FALSE);
    
    return STATUS_MORE_PROCESSING_REQUIRED;
}

BOOLEAN
ParAllocPort(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine takes the given Irp and sends it down as a port allocate
    request.  When this request completes, the Irp will be queued for
    processing.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    FALSE   - The port was not successfully allocated.
    TRUE    - The port was successfully allocated.

--*/

{
    PIO_STACK_LOCATION  NextSp;
    KEVENT              Event;
    PIRP                Irp;
    BOOLEAN             bAllocated;
    NTSTATUS            Status;
    LARGE_INTEGER       Timeout;
/*
    ParDump(PARDUMP_VERBOSE_MAX,
            ("PARALLEL: "
             "ParAllocPort(...): %wZ\n",
             &Extension->SymbolicLinkName) );

    // Don't allow multiple allocations
    if (Extension->bAllocated) {
        ParDump(PARDUMP_VERBOSE_MAX,
                ("PARALLEL: "
                 "ParAllocPort(...): %wZ\n",
                 &Extension->SymbolicLinkName) );
        return TRUE;
    }
*/        
    ParDump2(PARALLOCFREEPORT,
            ("ParAllocPort: Enter %x\n", Extension->Controller) );

    // Don't allow multiple allocations
    if (Extension->bAllocated) {
        ParDump2(PARALLOCFREEPORT,
                ("ParAllocPort: %x Already allocated\n", Extension->Controller) );
        return TRUE;
    }

    Irp = Extension->CurrentOpIrp;
    
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    NextSp = IoGetNextIrpStackLocation(Irp);
    NextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    NextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE;

    IoSetCompletionRoutine(Irp, 
                           ParAllocPortCompletionRoutine, 
                           &Event,
                           TRUE, 
                           TRUE, 
                           TRUE);

    ParCallDriver(Extension->PortDeviceObject, Irp);

    Timeout.QuadPart = -((LONGLONG) Extension->TimerStart*10*1000*1000);

    Status = KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, &Timeout);

    if (Status == STATUS_TIMEOUT) {
    
        IoCancelIrp(Irp);
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
    }

    bAllocated = (BOOLEAN)NT_SUCCESS(Irp->IoStatus.Status);
    
    Extension->bAllocated = bAllocated;
    
    if (!bAllocated) {
        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        ParDump2(PARALLOCFREEPORT,
                ("ParAllocPort: %x FAILED - DEVICE_BUSY\n", Extension->Controller) );
/*
        ParDump(PARDUMP_VERBOSE_MAX,
                ("PARALLEL: "
                 "ParAllocPort(...): %wZ FAILED - DEVICE_BUSY\n",
                 &Extension->SymbolicLinkName) );
*/
    }

    return bAllocated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\ppa3x.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ppa3x.c
//
//--------------------------------------------------------------------------

#include "pch.h"


VOID
ParCheckEnableLegacyZipFlag()
/*++

Routine Description:

    Initialize debugging variables from registry; set to default values
      if anything fails.

Arguments:

    RegistryPath            - Root path in registry where we should look

Return Value:

    None

--*/

{
    NTSTATUS                 Status;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG                    defaultZipEnabled = 0;
    PWSTR                    suffix            = L"\\Parameters";
    UNICODE_STRING           path              = {0,0,0};
    ULONG                    length;

    //
    // set up table entries for call to RtlQueryRegistryValues
    //
    RtlZeroMemory( paramTable, sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = (PWSTR)L"ParEnableLegacyZip";
    paramTable[0].EntryContext  = &ParEnableLegacyZip;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &defaultZipEnabled;
    paramTable[0].DefaultLength = sizeof(ULONG);

    //
    // leave paramTable[2] as all zeros - this terminates the table
    //

    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     RegistryPath.Buffer,
                                     &paramTable[0],
                                     NULL,
                                     NULL);

    ParDump2(PARPNP4, ("ppa3x::ParCheckEnableLegacyZipFlag - status from RtlQueryRegistryValues = %x\n", Status) );

    if( !NT_SUCCESS( Status ) ) {
        // registry read failed, use defaults
        ParEnableLegacyZip = defaultZipEnabled;
        return;
    }

    if( ParEnableLegacyZip ) {
        // we found a non-zero value - enable PnP for old parallel port Zip
        ParDump2(PARPNP1, ("ppa3x::ParCheckEnableLegacyZipFlag - FOUND - ParEnableLegacyZip Flag = %08x\n", ParEnableLegacyZip) );
        return;
    }


    //
    // We didn't find the registry flag, maybe it's under the Parameters subkey
    //


    // compute the size of the path including the "parameters" suffix
    ParDump2(PARPNP4, ("ppa3x::ParCheckEnableLegacyZipFlag - RegPath length    = %d\n", RegistryPath.Length) );

    length = ( sizeof(WCHAR) * wcslen( suffix ) ) + sizeof(UNICODE_NULL);
    ParDump2(PARPNP4, ("ppa3x::ParCheckEnableLegacyZipFlag - suffix length     = %d\n", length) );

    length += RegistryPath.Length;
    ParDump2(PARPNP4, ("ppa3x::ParCheckEnableLegacyZipFlag - total dest length = %d\n", length) );


    // build the path
    path.Buffer = ExAllocatePool( PagedPool, length );
    if( NULL == path.Buffer ) {
        // out of pool, use defaults
        ParEnableLegacyZip = defaultZipEnabled;
        return;
    }

    RtlZeroMemory( path.Buffer, length );
    path.MaximumLength = (USHORT)length;
    RtlCopyUnicodeString( &path, &RegistryPath );
    RtlAppendUnicodeToString( &path, suffix );
    ParDump2(PARPNP4, ("ppa3x::ParCheckEnableLegacyZipFlag - path = <%wZ>\n", &path) );


    // query at new location in registry
    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     path.Buffer,
                                     &paramTable[0],
                                     NULL,
                                     NULL);

    RtlFreeUnicodeString( &path );

    ParDump2(PARPNP4, ("ppa3x::ParCheckEnableLegacyZipFlag - status from RtlQueryRegistryValues on SubKey = %x\n", Status) );

    if( !NT_SUCCESS( Status ) ) {
        // registry read failed, use defaults
        ParEnableLegacyZip = defaultZipEnabled;
        return;
    }

    ParDump2(PARPNP1, ("ppa3x::ParCheckEnableLegacyZipFlag - FOUND SubKey ParEnableLegacyZip Flag = %08x\n", ParEnableLegacyZip) );

}

BOOLEAN
ParLegacyZipCheckDevice(
    PUCHAR  Controller
    )
{
    WRITE_PORT_UCHAR( Controller+DCR_OFFSET, (UCHAR)(DCR_NOT_INIT | DCR_AUTOFEED) );

    if ( (READ_PORT_UCHAR( Controller+DSR_OFFSET ) & DSR_NOT_FAULT) == DSR_NOT_FAULT ) {

        WRITE_PORT_UCHAR( Controller+DCR_OFFSET, (UCHAR)DCR_NOT_INIT );

        if ( (READ_PORT_UCHAR( Controller+DSR_OFFSET ) & DSR_NOT_FAULT) != DSR_NOT_FAULT ) {
            // A device was found
            return TRUE;
        }
    }

    // No device is there
    return FALSE;

} // end PptLegacyZipCheckDevice()

PCHAR ParBuildLegacyZipDeviceId()
{
    ULONG size = sizeof(PAR_LGZIP_PSEUDO_1284_ID_STRING) + sizeof(NULL);
    PCHAR id = ExAllocatePool(PagedPool, size);
    if( id ) {
        RtlZeroMemory( id, size );
        RtlCopyMemory( id, ParLegacyZipPseudoId, size - sizeof(NULL) );
        return id;
    } else {
        return NULL;
    }
}
PCHAR
Par3QueryLegacyZipDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PCHAR               CallerDeviceIdBuffer, OPTIONAL
    IN  ULONG               CallerBufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString // TRUE ==  include the 2 size bytes in the returned string
                                             // FALSE == discard the 2 size bytes
    )
{
    USHORT deviceIdSize;
    PCHAR  deviceIdBuffer;

    UNREFERENCED_PARAMETER( Extension );

    // initialize returned size in case we have an error
    *DeviceIdSize = 0;

    deviceIdBuffer = ParBuildLegacyZipDeviceId();
    if( !deviceIdBuffer ) {
        // error, likely out of resources
        return NULL;
    }

    deviceIdSize = (USHORT) strlen(deviceIdBuffer);
    *DeviceIdSize = deviceIdSize;
    if( (NULL != CallerDeviceIdBuffer) && (CallerBufferSize >= deviceIdSize) ) {
        // caller supplied buffer is large enough, use it
        RtlZeroMemory( CallerDeviceIdBuffer, CallerBufferSize );
        RtlCopyMemory( CallerDeviceIdBuffer, deviceIdBuffer, deviceIdSize );
        ExFreePool( deviceIdBuffer );
        return CallerDeviceIdBuffer;
    } else {
        // caller buffer too small, return pointer to our buffer
        return deviceIdBuffer;
    }
}

PDEVICE_OBJECT
ParCreateLegacyZipPdo(
    IN PDEVICE_OBJECT LegacyPodo,
    UCHAR             Dot3Id
    )
/*++

Routine Description:

    Create PDO for legacy Zip Drive

    LegacyPodo - points to the Legacy PODO for the port

Return Value:

    PDEVICE_OBJECT - on success, points to the PDO we create
    NULL           - otherwise

--*/
{
    PDEVICE_EXTENSION  legacyExt            = LegacyPodo->DeviceExtension;
    PDRIVER_OBJECT     driverObject         = LegacyPodo->DriverObject;
    PDEVICE_OBJECT     fdo                  = legacyExt->ParClassFdo;
    UNICODE_STRING     className            = {0,0,NULL};
    NTSTATUS           status;
    PCHAR              deviceIdString       = NULL;
    ULONG              deviceIdLength       = 0;
    PDEVICE_OBJECT     newDevObj            = NULL;
    PDEVICE_EXTENSION  newDevExt;
    ULONG              idTry                = 1;
    ULONG              maxIdTries           = 3;

    BOOLEAN            useModifiedClassName = FALSE;
    UNICODE_STRING     modifiedClassName;
    UNICODE_STRING     suffix;
    UNICODE_STRING     dash;
    WCHAR              suffixBuffer[10];
    ULONG              number               = 0;
    ULONG              maxNumber            = 256;
    ULONG              newLength;


    PAGED_CODE();

    //
    // Query for PnP device
    //
    while( (NULL == deviceIdString) && (idTry <= maxIdTries) ) {
        if( Dot3Id == DOT3_LEGACY_ZIP_ID) {
            ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - calling ParBuildLegacyZipDeviceId()\n"));
            deviceIdString = ParBuildLegacyZipDeviceId();
			if(deviceIdString)
			{
	            deviceIdLength = strlen( deviceIdString );
			}
        } else{
            ASSERT(FALSE); // should never get here
            deviceIdString = Par3QueryDeviceId(legacyExt, NULL, 0, &deviceIdLength, FALSE, FALSE);
        }

        if( NULL == deviceIdString ) {
            ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - no 1284 ID on try %d\n", idTry) );
            KeStallExecutionProcessor(1);
            ++idTry;
        } else {
             ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - devIdString=<%s> on try %d\n", deviceIdString, idTry) );
        }
    }

    if( !deviceIdString ) {
        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - no 1284 ID, bail out\n") );
        return NULL;
    }


    //
    // Found PnP Device, create a PDO to represent the device
    //  - create classname
    //  - create device object
    //  - initialize device object and extension
    //  - create symbolic link
    //  - register for PnP TargetDeviceChange notification
    //


    //
    // Create a class name of the form \Device\ParallelN,
    //
    ParMakeDotClassNameFromBaseClassName(&legacyExt->ClassName, Dot3Id, &className);
    if( !className.Buffer ) {
        // unable to construct ClassName
        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - unable to construct ClassName for device\n") );
        ExFreePool(deviceIdString);
        return NULL;
    }


    //
    // create device object
    //
    status = ParCreateDevice(driverObject, sizeof(DEVICE_EXTENSION), &className,
                            FILE_DEVICE_PARALLEL_PORT, 0, TRUE, &newDevObj);

    ///
    if( status == STATUS_OBJECT_NAME_COLLISION ) {
        //
        // old name is still in use, appending a suffix and try again
        //

        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - ParCreateDevice FAILED due to name Collision on <%wZ> - retry\n", &className));

        useModifiedClassName = TRUE;

        suffix.Length            = 0;
        suffix.MaximumLength     = sizeof(suffixBuffer);
        suffix.Buffer            = suffixBuffer;

        RtlInitUnicodeString( &dash, (PWSTR)L"-" );

        newLength = className.MaximumLength + 5*sizeof(WCHAR); // L"-XXX" suffix
        modifiedClassName.Length        = 0;
        modifiedClassName.MaximumLength = (USHORT)newLength;
        modifiedClassName.Buffer        = ExAllocatePool(PagedPool, newLength);
        if( NULL == modifiedClassName.Buffer ) {
            ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - ParCreateDevice FAILED - no PagedPool avail\n"));
            ExFreePool(deviceIdString);
            RtlFreeUnicodeString( &className );
            return NULL;
        }

        while( ( status == STATUS_OBJECT_NAME_COLLISION ) && ( number <= maxNumber ) ) {

            status = RtlIntegerToUnicodeString(number, 10, &suffix);
            if ( !NT_SUCCESS(status) ) {
                ExFreePool(deviceIdString);
                RtlFreeUnicodeString( &className );
                RtlFreeUnicodeString( &modifiedClassName );
                return NULL;
            }

            RtlCopyUnicodeString( &modifiedClassName, &className );
            RtlAppendUnicodeStringToString( &modifiedClassName, &dash );
            RtlAppendUnicodeStringToString( &modifiedClassName, &suffix );

            ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - trying ParCreateDevice with className <%wZ>\n", &modifiedClassName));
            status = ParCreateDevice(driverObject, sizeof(DEVICE_EXTENSION), &modifiedClassName,
                                    FILE_DEVICE_PARALLEL_PORT, 0, TRUE, &newDevObj);
            if( NT_SUCCESS( status ) ) {
                ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - ParCreateDevice returned SUCCESS with className <%wZ>\n", &modifiedClassName));
            } else {
                ++number;
            }
        }
    }
    ///

    if( useModifiedClassName ) {
        // copy modifiedClassName to className
        RtlFreeUnicodeString( &className );
        className = modifiedClassName;
        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - copy useModifiedClassName to className - className=<%wZ>\n", &className));
    }


    if( !NT_SUCCESS(status) ) {
        // unable to create device object, bail out
        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - unable to create device object "
                           "className=<%wZ>, bail out - status=%x\n", &className, status) );
        ExFreePool(deviceIdString);
        RtlFreeUnicodeString(&className);
        ParLogError(fdo->DriverObject, NULL, PhysicalZero, PhysicalZero,
                    0, 0, 0, 9, STATUS_SUCCESS, PAR_INSUFFICIENT_RESOURCES);
        return NULL;
    } else {
        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - device created <%wZ>\n", &className));
    }
    //
    // device object created
    //
    newDevExt = newDevObj->DeviceExtension;


    //
    // initialize device object and extension
    //
    ParInitCommonDOPre(newDevObj, fdo, &className);

    status = ParInitPdo(newDevObj, (PUCHAR)deviceIdString, deviceIdLength, LegacyPodo, Dot3Id);
    if( !NT_SUCCESS( status ) ) {
        // initialization failed, clean up and bail out
        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - call to ParInitPdo failed, bail out\n") );
        ParAcquireListMutexAndKillDeviceObject(fdo, newDevObj);
        return NULL;
    }
    ParInitCommonDOPost(newDevObj);

    //
    // create symbolic link
    //
    if( newDevExt->SymbolicLinkName.Buffer ) {

        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - ready to create symlink - SymbolicLinkName <%wZ>, ClassName <%wZ>\n",
                           &newDevExt->SymbolicLinkName, &newDevExt->ClassName) );
        ParDump2(PARPNP1, (" - Length=%hd, MaximumLength=%hd\n", newDevExt->ClassName.Length, newDevExt->ClassName.MaximumLength) );

        ASSERT(newDevExt->ClassName.Length < 100);

        PAGED_CODE();
        status = IoCreateUnprotectedSymbolicLink(&newDevExt->SymbolicLinkName, &newDevExt->ClassName);

        if ( NT_SUCCESS(status) ) {
            // note this in our extension for later cleanup
            ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - SymbolicLinkName -> ClassName = <%wZ> -> <%wZ>\n",
                               &newDevExt->SymbolicLinkName, &newDevExt->ClassName) );
            newDevExt->CreatedSymbolicLink = TRUE;

            // Write symbolic link map info to the registry.
            status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                           (PWSTR)L"PARALLEL PORTS",
                                           newDevExt->ClassName.Buffer,
                                           REG_SZ,
                                           newDevExt->SymbolicLinkName.Buffer,
                                           newDevExt->SymbolicLinkName.Length +
                                               sizeof(WCHAR));

            if (!NT_SUCCESS(status)) {
                // unable to write map info to registry - continue anyway
                ParLogError(newDevObj->DriverObject, newDevObj,
                            newDevExt->OriginalController, PhysicalZero,
                            0, 0, 0, 6, status, PAR_NO_DEVICE_MAP_CREATED);
            }

        } else {

            // unable to create the symbolic link.
            ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - unable to create SymbolicLink - status = %x\n",status));
            newDevExt->CreatedSymbolicLink = FALSE;
            RtlFreeUnicodeString(&newDevExt->SymbolicLinkName);
            ParLogError(newDevObj->DriverObject, newDevObj,
                        newDevExt->OriginalController, PhysicalZero,
                        0, 0, 0, 5, status, PAR_NO_SYMLINK_CREATED);
        }

    } else {
        // extension does not contain a symbolic link name for us to use
        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - extension does not contain a symbolic link for us to use\n"));
        newDevExt->CreatedSymbolicLink = FALSE;
    }

    // End-Of-Chain PDO - register for PnP TargetDeviceChange notification
    status = IoRegisterPlugPlayNotification(EventCategoryTargetDeviceChange,
                                            0,
                                            (PVOID)newDevExt->PortDeviceFileObject,
                                            driverObject,
                                            (PDRIVER_NOTIFICATION_CALLBACK_ROUTINE) ParPnpNotifyTargetDeviceChange,
                                            (PVOID)newDevObj,
                                            &newDevExt->NotificationHandle);

    if( !NT_SUCCESS(status) ) {
        // PnP registration for TargetDeviceChange notification failed,
        //   clean up and bail out
        ParDump2(PARPNP1, ("ppa3x::ParCreateLegacyZipPdo - PnP registration failed, killing PDO\n") );
        ParAcquireListMutexAndKillDeviceObject(fdo, newDevObj);
        return NULL;
    }

    return newDevObj;
}

PDEVICE_OBJECT
ParCreateAddLegacyZipPdo(
    IN PDEVICE_OBJECT LegacyPodo
    )
/*++

    Create a new PDO for the legacy Zip and add the PDO to the list
      of PDOs

--*/
{
    PDEVICE_OBJECT newPdo = ParCreateLegacyZipPdo( LegacyPodo, DOT3_LEGACY_ZIP_ID );

    if( newPdo ) {
        ParAddDevObjToFdoList( newPdo );
    }

    return newPdo;
}

NTSTATUS
ParSelectLegacyZip( IN  PDEVICE_OBJECT PortDeviceObject )
//
// Select Legacy Zip Drive
//
//    Note: Caller must have already Acquired the Port prior to calling this function.
//
// Returns: STATUS_SUCCESS if drive selected, !STATUS_SUCCESS otherwise
//
{
    PARALLEL_1284_COMMAND  par1284Command;
    NTSTATUS               status;

    ParDump2(PARLGZIP, ("rescan::ParSelectLegacyZip - Enter\n"));

    par1284Command.ID           = 0;
    par1284Command.Port         = 0;
    par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT | PAR_LEGACY_ZIP_DRIVE;

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_SELECT_DEVICE,
                                     PortDeviceObject,
                                     &par1284Command, sizeof(PARALLEL_1284_COMMAND),
                                     NULL, 0, NULL);

    ParDump2(PARLGZIP, ("rescan::ParSelectLegacyZip - returning status = %x\n", status));
    return status;
}

NTSTATUS
ParDeselectLegacyZip( IN  PDEVICE_OBJECT PortDeviceObject )
//
// Select Legacy Zip Drive
//
//    Note: This function does not Release the port so the Caller still has
//            the port after this function returns.
//
// Returns: STATUS_SUCCESS if drive deselected, !STATUS_SUCCESS otherwise
//            (we don't expect this call to ever fail, but check just
//              in case)
//
{
    PARALLEL_1284_COMMAND  par1284Command;
    NTSTATUS               status;

    ParDump2(PARLGZIP, ("rescan::ParDeselectLegacyZip - Enter\n"));

    par1284Command.ID           = 0;
    par1284Command.Port         = 0;
    par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT | PAR_LEGACY_ZIP_DRIVE;

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_DESELECT_DEVICE,
                                     PortDeviceObject,
                                     &par1284Command, sizeof(PARALLEL_1284_COMMAND),
                                     NULL, 0, NULL);
    ParDump2(PARLGZIP, ("rescan::ParDeselectLegacyZip - returning status = %x\n", status));
    return status;
}

BOOLEAN
ParZipPresent( PDEVICE_OBJECT LegacyPodo )
//
// Legacy Zip is present if we can SELECT it
//
{
    BOOLEAN zipPresent = FALSE;
    PDEVICE_EXTENSION legacyExt = LegacyPodo->DeviceExtension;
    PDEVICE_OBJECT portDeviceObject = legacyExt->PortDeviceObject;

    if( NT_SUCCESS( ParSelectLegacyZip( portDeviceObject ) ) ) {
        ParDeselectLegacyZip( portDeviceObject );
        zipPresent = TRUE;
    }

    return zipPresent;
}

VOID
ParRescanLegacyZip( IN PPAR_DEVOBJ_STRUCT CurrentNode )
//
// Rescan for change in Legacy Zip Drive, update PDO list if change detected
//
{
    BOOLEAN           hadZip;
    BOOLEAN           foundZip;
    PDEVICE_OBJECT    zipPdo;

    ParDump2(PARLGZIP, ("rescan::ParRescanLegacyZip - Enter\n"));
    if( !ParEnableLegacyZip ) {
        //
        // legacy zip detection is disabled
        //
        ParDump2(PARLGZIP, ("rescan::ParRescanLegacyZip - !ParEnableLegacyZip\n"));

        //
        // if we had a Legacy Zip then automatically mark it as hardware gone
        //
        zipPdo = CurrentNode->LegacyZipPdo;
        if( zipPdo ) {
            // we should never get here, but handle it if we do
            ParMarkPdoHardwareGone( zipPdo->DeviceExtension );
        }
        return;
    }


    //
    // Check for presence of Legacy Zip - update PDO list if we detect a change
    //
    hadZip   = (NULL != CurrentNode->LegacyZipPdo);
    foundZip = ParZipPresent( CurrentNode->LegacyPodo );

    ParDump2(PARLGZIP, ("rescan::ParRescanLegacyZip - hadZip=%s, foundZip=%s\n",
                      hadZip?"TRUE":"FALSE", foundZip?"TRUE":"FALSE"));

    if( foundZip && !hadZip ) {
        // we found a new Zip - create a PDO for it
        ParDump2(PARLGZIP, ("rescan::ParRescanLegacyZip - Found new Legacy Zip\n"));
        ParCreateAddLegacyZipPdo( CurrentNode->LegacyPodo );
    } else if( !foundZip && hadZip ) {
        // our Zip went away - mark PDO as hardware gone
        ParDump2(PARLGZIP, ("rescan::ParRescanLegacyZip - Had a Legacy Zip but now it's gone\n"));
        zipPdo = CurrentNode->LegacyZipPdo;
        ParMarkPdoHardwareGone( zipPdo->DeviceExtension );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\queue.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    queue.c

Abstract:

   Creates a simple Queue that works in Kernel Mode.

Author:

    Robbie Harris (Hewlett-Packard) 22-May-1998

Environment:

    Kernel mode

Revision History :

--*/
#include "pch.h"

void Queue_Create(Queue *pQueue, int size)
{
    if (!pQueue)
    {
        ParDump(PARERRORS, ("Queue_Create: Queue is Bad"));
        return;
    }

    if (pQueue->theArray)
        Queue_Delete(pQueue);
        
    pQueue->theArray = (UCHAR *)ExAllocatePool(NonPagedPool, size);
    pQueue->max      = size;
    pQueue->head     = pQueue->tail = 0;
}

BOOLEAN Queue_Delete(Queue *pQueue)
{
    if (!pQueue)
    {
        return FALSE;
    }

    if (pQueue->theArray) {
    
        ExFreePool(pQueue->theArray);
        pQueue->theArray = NULL;
    }
    
    pQueue->head = 0;
    pQueue->tail = 0;
    pQueue->max  = 0;
    // NOTE: This can come back to haunt you!
    pQueue = 0;
    
    return TRUE;
}

BOOLEAN Queue_Dequeue(Queue *pQueue, PUCHAR data)
{
    // Validity of pQueue is checked in Queue_IsEmpty proc. 
    if (Queue_IsEmpty(pQueue))
    {
        ParDump(PARERRORS, ("Queue_Dequeue: Queue is Empty"));
        return FALSE;
    }

    *data = pQueue->theArray[pQueue->head++];
    return TRUE;
}

BOOLEAN Queue_Enqueue(Queue *pQueue, UCHAR data)
{
    // Validity of pQueue is checked in Queue_IsFull proc. 
    if (Queue_IsFull(pQueue)) {
    
        ParDump(PARERRORS, ("Queue_Enqueue: Queue is full. Data is lost"));
        return FALSE;
    
    } else {
        pQueue->theArray[pQueue->tail++] = data;
    }

    return TRUE;
}

/* Return TRUE if we were able to free some space in the Queue
*/
BOOLEAN Queue_GarbageCollect(Queue *pQueue)
{
    int     iListSize;
    int     i;

    if (!pQueue)
    {
        ParDump(PARERRORS, ("Queue_GarbageCollect: Queue is Bad"));
        return FALSE;
    }

    iListSize = pQueue->tail - pQueue->head;

    // Check to see if there is any free entries
    if (pQueue->head == 0 && pQueue->tail == pQueue->max)
        return FALSE;
         
    for (i = 0; i < iListSize; i++) {
    
        pQueue->theArray[i] = pQueue->theArray[pQueue->head+i];
    }

    pQueue->head = 0;
    pQueue->tail = iListSize;

    return TRUE;
}

//============================================================================
// NAME:    HPKQueue::IsEmpty()
//  
// PARAMETERS: None
//
// RETURNS: True is Queue is empty or doesn't exist.  Otherwise False.
//
//============================================================================
BOOLEAN Queue_IsEmpty(Queue *pQueue)
{
    if (!pQueue)
    {
        ParDump(PARERRORS, ("Queue_IsEmpty: Queue is Bad"));
        return TRUE;
    }

    if (pQueue->theArray) {
    
        return ((BOOLEAN) (pQueue->head == pQueue->tail));
    }
    ParDump(PARERRORS, ("Queue_IsEmpty: Queue->theArray is Bad"));
    return TRUE;
}

//============================================================================
// NAME:    HPKQueue::IsFull()
//  
// PARAMETERS: None
//
// RETURNS: True is Queue is full or doesn't exist.  Otherwise False.
//
//============================================================================
BOOLEAN Queue_IsFull(Queue *pQueue)
{
    if (!pQueue)
    {
        ParDump(PARERRORS, ("Queue_IsFull: Queue is Bad"));
        return TRUE;
    }

    if (pQueue->theArray) {
    
        if (pQueue->tail == pQueue->max)
            return !(Queue_GarbageCollect(pQueue));

        return FALSE;
    }
    ParDump(PARERRORS, ("Queue_IsFull: Queue->theArray is Bad"));
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\readwrit.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    readwrit.h

Abstract:

    This module contains Read/Write and bus flip logic used by other 1284 modules.

Author:

    Robbie Harris (Hewlett-Packard) 13-June-1998

Environment:

    Kernel mode

Revision History :

--*/
#ifndef _READWRIT_
#define _READWRIT_

NTSTATUS
ParForwardToReverse(
    IN  PDEVICE_EXTENSION   Extension
    );

BOOLEAN 
ParHaveReadData(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS 
ParPing(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParReverseToForward(
    IN  PDEVICE_EXTENSION   Extension
    );


NTSTATUS
ParRead(
    IN PDEVICE_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead
    );

VOID
ParReadIrp(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParSetFwdAddress(
    IN  PDEVICE_EXTENSION   Extension
    );

VOID
ParTerminate(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParWrite(
    IN PDEVICE_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten
    );

VOID
ParWriteIrp(
    IN  PDEVICE_EXTENSION   Extension
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\sppieee.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1998

Module Name:

    sppieee.c

Abstract:

    This module contains code for the host to utilize an ieee version of
    compatibility mode

Author:

    Robbie Harris (Hewlett-Packard) 29-July-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
#include "readwrit.h"

NTSTATUS
SppIeeeWrite(
    IN  PDEVICE_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    )

/*++

Routine Description:

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS    status = STATUS_SUCCESS;
    PUCHAR      Controller = Extension->Controller;
    PUCHAR      pPortDSR = Extension->Controller + OFFSET_DSR;
    PUCHAR      pPortDCR = Extension->Controller + OFFSET_DCR;
    PUCHAR      pPortData = Extension->Controller + OFFSET_DATA;
    ULONG       wByteCount = BytesToWrite;
    UCHAR       bDCRstrobe;		// Holds precomputed value for state 35
    UCHAR       bDCRnormal;		// Holds precomputed value for state 37
    PUCHAR      lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type

    
    // Make precomputed DCR values for strobe and periph ack
    bDCRstrobe = SET_DCR(DIR_WRITE, IRQEN_DISABLE, ACTIVE, ACTIVE, ACTIVE, INACTIVE);
    bDCRnormal = SET_DCR(DIR_WRITE, IRQEN_DISABLE, ACTIVE, ACTIVE, ACTIVE, ACTIVE);

    // Wait a bit to give nBusy a chance to settle, because 
    // WriteComm will bail immediately if the device says busy
    if ( CHECK_DSR( Controller,
                    INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE,
                    IEEE_MAXTIME_TL ) )
    {
        while (wByteCount)
        {
                // Place a data byte on the bus
            WRITE_PORT_UCHAR(pPortData, *lpsBufPtr);
            
                // Start handshake by dropping strobe
            WRITE_PORT_UCHAR(pPortDCR, bDCRstrobe);
            
                // Wait for Periph Busy Response
            if ( !CHECK_DSR(Controller, ACTIVE, DONT_CARE, DONT_CARE,
                    DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL) )        
            {
                status = STATUS_DEVICE_BUSY;
                break;
            }

                // Printer responded by making Busy high -- the byte has
            // been accepted.  Adjust the data pointer.
            lpsBufPtr++;
            
                // Finish handshake by raising strobe
            WRITE_PORT_UCHAR(pPortDCR, bDCRnormal);

                // Adjust count while we're waiting for the peripheral
            // to respond with state 32
            wByteCount--;
            
                // Wait for PeriphAck and PeriphBusy response
            if ( !CHECK_DSR(Controller, INACTIVE, ACTIVE, DONT_CARE, DONT_CARE,
                    DONT_CARE, IEEE_MAXTIME_TL) )
            {
                // Set appropriate error based on relaxed timeout.
                status = STATUS_DEVICE_BUSY;
                break;
            }
        }	// while...                            
    
        *BytesTransferred  = BytesToWrite - wByteCount;      // Set current count.
    }
                
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\readwrit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       readwrit.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with handling Read and Write requests
//

#include "pch.h"
#include "ecp.h"
#include "readwrit.h"


NTSTATUS
ParForwardToReverse(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine flips the bus from Forward to Reverse direction.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Do a quick check to see if we are where we want to be.  
    // Happy punt if everything is ok.
    if (Extension->Connected &&
        (Extension->CurrentPhase == PHASE_REVERSE_IDLE ||
            Extension->CurrentPhase == PHASE_REVERSE_XFER))
    {
            ParDump2(PARINFO, ( "ParForwardToReverse: Already in Reverse Mode!\r\n" ));
            return Status;
    }

    if (Extension->Connected) {
    
        if (Extension->CurrentPhase != PHASE_REVERSE_IDLE &&
            Extension->CurrentPhase != PHASE_REVERSE_XFER) {
        
            if (afpForward[Extension->IdxForwardProtocol].ProtocolFamily ==
                arpReverse[Extension->IdxReverseProtocol].ProtocolFamily) {

                ParDump2(PARINFO, ( "ParForwardToReverse: Protocol families match!\r\n" ));

                // Protocol Families match and we are in Fwd.  Exit Fwd to cleanup the state
                // machine, fifo, etc.  We will call EnterReverse later to
                // actually bus flip.  Also only do this if in safe mode
                if ( (afpForward[Extension->IdxForwardProtocol].fnExitForward) ) {
                    Status = afpForward[Extension->IdxForwardProtocol].fnExitForward(Extension);
                }
                    
            } else {

                ParDump2(PARINFO, ( "ParForwardToReverse: Protocol families DO NOT match!\r\n" ));
                //
                // Protocol Families don't match...need to terminate from the forward mode
                //
                if (afpForward[Extension->IdxForwardProtocol].fnDisconnect)
                {
                    ParDump2(PARINFO, ("ParForwardToReverse: Calling afpForward.fnDisconnect\r\n"));
                    afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
                }
                if ((Extension->ForwardInterfaceAddress != DEFAULT_ECP_CHANNEL) &&    
                    (afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress))
                    Extension->SetForwardAddress = TRUE;
            }
            
        }                
    }

    if ((!Extension->Connected) &&
        (arpReverse[Extension->IdxReverseProtocol].fnConnect)) {

        ParDump2(PARINFO, ( "ParForwardToReverse: Not Connected so Calling Reverse Connect!\r\n" ));

        //
        // If we are still connected the protocol families match...
        //
        Status = arpReverse[Extension->IdxReverseProtocol].fnConnect(Extension, FALSE);

        //
        // Makes the assumption that the connected address is always 0
        //
        if ((NT_SUCCESS(Status)) &&
            (arpReverse[Extension->IdxReverseProtocol].fnSetInterfaceAddress) &&
            (Extension->ReverseInterfaceAddress != DEFAULT_ECP_CHANNEL)) {
            
            Extension->SetReverseAddress = TRUE;
        }    
    }

    //
    // Set the channel address if we need to.
    //
    if (NT_SUCCESS(Status) && Extension->SetReverseAddress &&    
        (arpReverse[Extension->IdxReverseProtocol].fnSetInterfaceAddress)) {

        Status  = arpReverse[Extension->IdxReverseProtocol].fnSetInterfaceAddress (
                                                                    Extension,
                                                                    Extension->ReverseInterfaceAddress);
        if (NT_SUCCESS(Status))
            Extension->SetReverseAddress = FALSE;
        else
            Extension->SetReverseAddress = TRUE;
    }

    //
    // Do we need to reverse?
    //
    if ( (NT_SUCCESS(Status)) && 
           ((Extension->CurrentPhase != PHASE_REVERSE_IDLE) &&
            (Extension->CurrentPhase != PHASE_REVERSE_XFER)) ) {
            
        ParDump2(PARINFO, ( "ParForwardToReverse: Not IN REVERSE IDLE so Calling Reverse ENTER!\r\n" ));

        if ((arpReverse[Extension->IdxReverseProtocol].fnEnterReverse))
            Status = arpReverse[Extension->IdxReverseProtocol].fnEnterReverse(Extension);
    }

    ParDump2(PAREXIT, ( "ParForwardToReverse: Exit [%d]\r\n", NT_SUCCESS(Status)));
    return Status;
}

BOOLEAN 
ParHaveReadData(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:
    This method determines if the peripheral has any data ready
to send to the host.

Arguments:
    Extension    - Supplies the device EXTENSION.   

Return Value:
    TRUE    - Either the peripheral has data
    FALSE   - No data
--*/
{
    if (Extension->CurrentPhase == PHASE_REVERSE_IDLE ||
        Extension->CurrentPhase == PHASE_REVERSE_XFER)
    {
        if (arpReverse[Extension->IdxReverseProtocol].fnHaveReadData)
        {
            if (arpReverse[Extension->IdxReverseProtocol].fnHaveReadData(Extension))
                return TRUE;
            // Don't have data.  This could be a fluke. Let's
            // flip the bus and try in Fwd mode.
            ParReverseToForward(Extension);
        }
    }

    if (Extension->CurrentPhase == PHASE_FORWARD_IDLE ||
        Extension->CurrentPhase == PHASE_FORWARD_XFER)
    {
        if (afpForward[Extension->IdxForwardProtocol].ProtocolFamily == FAMILY_BECP ||
                afpForward[Extension->IdxForwardProtocol].Protocol & ECP_HW_NOIRQ ||
                afpForward[Extension->IdxForwardProtocol].Protocol & ECP_HW_IRQ)
        {
            if (ParEcpHwHaveReadData(Extension))
                return TRUE;
            // Hmmm.  No data. Is the chip stuck?
#define DVRH_DO_RETRY 0
#if (1 == DVRH_DO_RETRY) 
            // retry - slap periph to wake it up, then try again
            ParPing(Extension);
            return ParEcpHwHaveReadData(Extension);
#else
            return FALSE;
#endif
        }
        else if (afpForward[Extension->IdxForwardProtocol].Protocol & ECP_SW)
            return ParEcpHaveReadData(Extension);
    }
    // DVRH  RMT
    // We got here because the protocol doesn't support peeking.
    // Let's go ahead and flip the bus to see if there is anything
    // there.
    return TRUE;
}

NTSTATUS 
ParPing(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:
    This method pings the device.

Arguments:
    Extension    - Supplies the device EXTENSION.   

Return Value:
    none
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
#if 0
    if ((Extension->CurrentPhase == PHASE_REVERSE_IDLE) ||
        (Extension->CurrentPhase == PHASE_REVERSE_XFER))
    {
        ParReverseToForward(Extension);
        if (arpReverse[Extension->IdxReverseProtocol].fnDisconnect)
        {
            ParDump2(PARINFO, ("ParPing: Calling arpReverse.fnDisconnect\n"));
            arpReverse[Extension->IdxReverseProtocol].fnDisconnect(Extension);
        }
    } else if ((Extension->CurrentPhase != PHASE_REVERSE_IDLE) &&
               (Extension->CurrentPhase != PHASE_REVERSE_XFER))
    {
        if (afpForward[Extension->IdxForwardProtocol].fnDisconnect)
            {
                ParDump2(PARINFO, ("ParPing: Calling afpForward.fnDisconnect\n"));
                afpForward[Extension->IdxForwardProtocol].fnDisconnect(Extension);
            }
    }

    if (afpForward[Extension->IdxForwardProtocol].fnConnect)
    {
        NtStatus = afpForward[Extension->IdxForwardProtocol].fnConnect(Extension, FALSE);
        if (NT_SUCCESS(NtStatus) &&
            (Extension->ForwardInterfaceAddress != DEFAULT_ECP_CHANNEL) &&    
            (afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress))
        {
            NtStatus  = afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress(Extension, Extension->ForwardInterfaceAddress);
        }
    }
#endif
    return NtStatus;
}

NTSTATUS
ParReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This is the dispatch routine for READ and WRITE requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_PENDING              - Request pending - a worker thread will carry
                                    out the request at PASSIVE_LEVEL IRQL

    STATUS_SUCCESS              - Success - asked for a read or write of
                                    length zero.

    STATUS_INVALID_PARAMETER    - Invalid parameter.

    STATUS_DELETE_PENDING       - This device object is being deleted.

--*/

{
    PIO_STACK_LOCATION  IrpSp;
    PDEVICE_EXTENSION   Extension;

    Irp->IoStatus.Information = 0;

    IrpSp     = IoGetCurrentIrpStackLocation(Irp);
    Extension = DeviceObject->DeviceExtension;

    ParTimerMainCheck( ("Enter ParReadWrite(...) - %wZ\r\n", &Extension->SymbolicLinkName) );


    //
    // bail out if a delete is pending for this device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_DELETE_PENDING) {

        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }
    
    //
    // bail out if a remove is pending for our ParPort device object
    //
    if(Extension->DeviceStateFlags & PAR_DEVICE_PORT_REMOVE_PENDING) {

        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    //
    // bail out if device has been removed
    //
    if(Extension->DeviceStateFlags & (PAR_DEVICE_REMOVED|PAR_DEVICE_SURPRISE_REMOVAL) ) {

        Irp->IoStatus.Status = STATUS_DEVICE_REMOVED;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_REMOVED;
    }


    //
    // Note that checks of the Write IRP parameters also handles Read IRPs
    //   because the Write and Read structures are identical in the
    //   IO_STACK_LOCATION.Parameters union
    //


    //
    // bail out on nonzero offset
    //
    if( (IrpSp->Parameters.Write.ByteOffset.HighPart != 0) ||
        (IrpSp->Parameters.Write.ByteOffset.LowPart  != 0) ) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }


    //
    // immediately succeed read or write request of length zero
    //
    if (IrpSp->Parameters.Write.Length == 0) {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        ParCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }


    //
    // Request appears to be valid, queue it for our worker thread to handle at
    // PASSIVE_LEVEL IRQL and wake up the thread to do the work
    //
    {
        KIRQL               OldIrql;

        // make sure IRP isn't cancelled out from under us
        IoAcquireCancelSpinLock(&OldIrql);
        if (Irp->Cancel) {
            
            // IRP has been cancelled, bail out
            IoReleaseCancelSpinLock(OldIrql);
            return STATUS_CANCELLED;
            
        } else {
            BOOLEAN needToSignalSemaphore = IsListEmpty( &Extension->WorkQueue );
            IoSetCancelRoutine(Irp, ParCancelRequest);
            IoMarkIrpPending(Irp);
            InsertTailList(&Extension->WorkQueue, &Irp->Tail.Overlay.ListEntry);
            IoReleaseCancelSpinLock(OldIrql);
            if( needToSignalSemaphore ) {
                KeReleaseSemaphore(&Extension->RequestSemaphore, 0, 1, FALSE);
            }
            return STATUS_PENDING;
        }
    }
}

NTSTATUS
ParRead(
    IN PDEVICE_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToRead,
    OUT PULONG              NumBytesRead
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR   lpsBufPtr = (PUCHAR)Buffer;    // Pointer to buffer cast to desired data type
    ULONG    Bytes = 0;
#if (1 == DVRH_RAISE_IRQL)
    KIRQL               OldIrql;
#endif

    *NumBytesRead = Bytes;
#if (1 == DVRH_RAISE_IRQL)
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
#endif

    // only do this if we are in safe mode
    if ( Extension->ModeSafety == SAFE_MODE ) {

        if (arpReverse[Extension->IdxReverseProtocol].fnReadShadow) {
            Queue     *pQueue;
   
            pQueue = &(Extension->ShadowBuffer);
            arpReverse[Extension->IdxReverseProtocol].fnReadShadow(pQueue,
                                                                    lpsBufPtr,
                                                                    NumBytesToRead,
                                                                    &Bytes);
            NumBytesToRead -= Bytes;
            *NumBytesRead += Bytes;
            lpsBufPtr += Bytes;
            if ( 0 == NumBytesToRead ) {
                ParDump2(PARINFO, ( "ParRead: Read everything from the ShadowBuffer\r\n" ));
                Status = STATUS_SUCCESS;
                if ((!Queue_IsEmpty(pQueue)) &&
                    (TRUE == Extension->P12843DL.bEventActive) ) {
                    KeSetEvent(Extension->P12843DL.Event, 0, FALSE);
                }
    	        goto ParRead_ExitLabel;
            }
        }

        if (arpReverse[Extension->IdxReverseProtocol].fnHaveReadData) {
            if (!arpReverse[Extension->IdxReverseProtocol].fnHaveReadData(Extension))
            {
                ParDump2(PARINFO, ( "ParRead: Periph doesn't have data. Happy punt to give cycles to someone else.\r\n" ));
	            Status = STATUS_SUCCESS;
	            goto ParRead_ExitLabel;
            }
        }

    }

    // Go ahead and flip the bus if need be.  The proc will just make sure we're properly
    // connected and pointing in the right direction.
    Status = ParForwardToReverse( Extension );


    //
    // The read mode will vary depending upon the currently negotiated mode.
    // Default: Nibble
    //

    if (NT_SUCCESS(Status))
    {
    #if (1 == DVRH_USE_CORRECT_PTRS)
        if (Extension->fnRead || arpReverse[Extension->IdxReverseProtocol].fnRead) {
            //
            // Do the read...
            //
            if(Extension->fnRead) {
                Status = ((PPROTOCOL_READ_ROUTINE)Extension->fnRead)(Extension,
                                                                     (PVOID)lpsBufPtr,
                                                                     NumBytesToRead,
                                                                     &Bytes);
            } else {
                Status = arpReverse[Extension->IdxReverseProtocol].fnRead(Extension,
                                                                          (PVOID)lpsBufPtr,
                                                                          NumBytesToRead,
                                                                          &Bytes);
            }
    #else
        if (arpReverse[Extension->IdxReverseProtocol].fnRead) {
            //
            // Do the read...
            //
            Status = arpReverse[Extension->IdxReverseProtocol].fnRead(Extension,
                                                                    (PVOID)lpsBufPtr,
                                                                    NumBytesToRead,
                                                                    &Bytes);
    #endif
            *NumBytesRead += Bytes;
            NumBytesToRead -= Bytes;

            #if DVRH_SHOW_BYTE_LOG
                {
                    ULONG i=0;
                    DbgPrint("Parallel:Read: ");
                    for (i=0; i<*NumBytesRead; ++i) {
                        DbgPrint(" %02x",((PUCHAR)lpsBufPtr)[i]);
                    }
                    DbgPrint("\n");
                }
            #endif

        }
#if DBG
        else {
            ParDump2(PARERRORS, ( "ParRead: Don't have a fnRead! Can't Read!\r\n" ));
            ParDump2(PARERRORS, ( "ParRead: You're hosed man.\r\n" ));
            ParDump2(PARERRORS, ( "ParRead: If you are here, you've got a bug somewhere else.\r\n" ));
            ParDump2(PARERRORS, ( "ParRead: Go fix it!\r\n" ));
        }
#endif
    }
#if DBG
    else {
        ParDump2(PARERRORS, ( "ParRead: Failure from Above! Didn't call Read!\r\n" ));
        ParDump2(PARERRORS, ( "ParRead: You're hosed man.\r\n" ));
        ParDump2(PARERRORS, ( "ParRead: If you are here, you've got a bug somewhere else.\r\n" ));
        ParDump2(PARERRORS, ( "ParRead: Go fix it!\r\n" ));
    }
#endif

ParRead_ExitLabel:
#if (1 == DVRH_RAISE_IRQL)
    KeLowerIrql(OldIrql);
#endif
    return Status;
}


VOID
ParReadIrp(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine implements a READ request with the extension's current irp.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    ULONG               NumBytesRead;

    Irp    = Extension->CurrentOpIrp;
    IrpSp  = IoGetCurrentIrpStackLocation(Irp);

    ParDump2(PARENTRY, ( "ParReadIrp: Start. BytesToRead[%d]\r\n", IrpSp->Parameters.Read.Length ));
    ParTimerCheck(( "ParReadIrp: Start. BytesToRead[%d]\r\n", IrpSp->Parameters.Read.Length ));

    Irp->IoStatus.Status = ParRead( Extension,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.Read.Length,
                                    &NumBytesRead);

    Irp->IoStatus.Information = NumBytesRead;
    ParTimerCheck(( "ParReadIrp: End. BytesRead[%d]\r\n", NumBytesRead ));
}

NTSTATUS
ParReverseToForward(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

    This routine flips the bus from Reverse to Forward direction.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    // dvdr
    ParDump2(PARINFO, ("ParReverseToForward: Entering\n"));

    if (Extension->Connected)
    {
        // Do a quick check to see if we are where we want to be.  
        // Happy punt if everything is ok.
        if (Extension->CurrentPhase == PHASE_FORWARD_IDLE ||
            Extension->CurrentPhase == PHASE_FORWARD_XFER)
        {
            ParDump2(PAREXIT, ( "ParReverseToForward: Already in Fwd. Exit STATUS_SUCCESS\n" ));
            return Status;
        }
        else
        {
            if (afpForward[Extension->IdxForwardProtocol].ProtocolFamily !=
                arpReverse[Extension->IdxReverseProtocol].ProtocolFamily)
            {            
                //
                // Protocol Families don't match...need to terminate from the forward mode
                //
                if (arpReverse[Extension->IdxReverseProtocol].fnDisconnect) {
                    ParDump2(PARINFO, ("ParReverseToForward: Calling arpReverse.fnDisconnect\r\n"));
                    arpReverse[Extension->IdxReverseProtocol].fnDisconnect (Extension);
                }
                if ((Extension->ReverseInterfaceAddress != DEFAULT_ECP_CHANNEL) &&    
                    (arpReverse[Extension->IdxReverseProtocol].fnSetInterfaceAddress))
                    Extension->SetReverseAddress = TRUE;
            }
            else if ((Extension->CurrentPhase == PHASE_REVERSE_IDLE) ||
                        (Extension->CurrentPhase == PHASE_REVERSE_XFER))
            {
                if ( (arpReverse[Extension->IdxReverseProtocol].fnExitReverse) ) {
                    Status = arpReverse[Extension->IdxReverseProtocol].fnExitReverse(Extension);
                }
            }
            else
            {
                // We are in a screwy state.
                ParDump2(PARERRORS, ( "ParReverseToForward: We're lost! Gonna start spewing!\r\n" ));
                ParDump2(PARERRORS, ( "ParReverseToForward: You're hosed man.\r\n" ));
                ParDump2(PARERRORS, ( "ParReverseToForward: If you are here, you've got a bug somewhere else.\r\n" ));
                ParDump2(PARERRORS, ( "ParReverseToForward: Go fix it!\r\n" ));
                Status = STATUS_IO_TIMEOUT;     // I picked a RetVal from thin air!
            }
        }
    }

    // Yes, we stil want to check for connection since we might have temrinated in the previous
    // code block!
    if (!Extension->Connected &&
        afpForward[Extension->IdxForwardProtocol].fnConnect) {

        Status = afpForward[Extension->IdxForwardProtocol].fnConnect (
                            Extension,
                            FALSE);
        //
        // Makes the assumption that the connected address is always 0
        //
        if ((NT_SUCCESS(Status)) &&                 
            (Extension->ForwardInterfaceAddress != DEFAULT_ECP_CHANNEL)) {
            
            Extension->SetForwardAddress = TRUE;
        }    
    }

    //
    // Do we need to enter a forward mode?
    //
    if ( (NT_SUCCESS(Status)) && 
         (Extension->CurrentPhase != PHASE_FORWARD_IDLE) &&
         (Extension->CurrentPhase != PHASE_FORWARD_XFER) &&
         (afpForward[Extension->IdxForwardProtocol].fnEnterForward) ) {
        
        Status = afpForward[Extension->IdxForwardProtocol].fnEnterForward(Extension);
    }

    ParDump2(PAREXIT, ( "ParReverseToForward: Exit [%d]\r\n", NT_SUCCESS(Status) ));
    return Status;
}

NTSTATUS
ParSetFwdAddress(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;

    ParDump2( PARENTRY, ("ParSetFwdAddress: Start: Channel [%x]\n", Extension->ForwardInterfaceAddress));
    if (afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress)
    {
        Status = ParReverseToForward(Extension);
        if (!NT_SUCCESS(Status))
        {
            ParDump2(PARERRORS, ("ParSetFwdAddress: FAIL. Couldn't flip the bus for Set ECP/EPP Channel failed.\n") );
            goto ParSetFwdAddress_ExitLabel;
        }
        Status  = afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress (
                                                                    Extension,
                                                                    Extension->ForwardInterfaceAddress);
        if (NT_SUCCESS(Status))
            Extension->SetForwardAddress = FALSE;
        else
        {
            ParDump2(PARERRORS, ("ParSetFwdAddress: FAIL. Set ECP/EPP Channel failed.\n") );
            goto ParSetFwdAddress_ExitLabel;
        }
    }
    else
    {
        ParDump2(PARERRORS, ("ParSetFwdAddress: FAIL. Protocol doesn't support SetECP/EPP Channel\n") );
        Status = STATUS_UNSUCCESSFUL;
        goto ParSetFwdAddress_ExitLabel;
    }

ParSetFwdAddress_ExitLabel:
    return Status;
}

VOID
ParTerminate(
    IN  PDEVICE_EXTENSION   Extension
    )
{
    if (!Extension->Connected)
        return;

    if (Extension->CurrentPhase == PHASE_REVERSE_IDLE ||
            Extension->CurrentPhase == PHASE_REVERSE_XFER)
    {
        if (afpForward[Extension->IdxForwardProtocol].ProtocolFamily !=
            arpReverse[Extension->IdxReverseProtocol].ProtocolFamily)
        {
            if (arpReverse[Extension->IdxReverseProtocol].fnDisconnect)
            {
                ParDump2(PARINFO, ("ParTerminate: Calling arpReverse.fnDisconnect\r\n"));
                arpReverse[Extension->IdxReverseProtocol].fnDisconnect (Extension);
            }
            return;
        }
        ParReverseToForward(Extension);
    }
    if (afpForward[Extension->IdxForwardProtocol].fnDisconnect)
    {
        ParDump2(PARINFO, ("ParTerminate: Calling afpForward.fnDisconnect\r\n"));
        afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
    }
}

NTSTATUS
ParWrite(
    IN PDEVICE_EXTENSION    Extension,
    OUT PVOID               Buffer,
    IN  ULONG               NumBytesToWrite,
    OUT PULONG              NumBytesWritten
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
#if (1 == DVRH_RAISE_IRQL)
    KIRQL               OldIrql;
#endif

#if (1 == DVRH_RAISE_IRQL)
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
#endif

    // dvdr
    ParDump2(PARINFO, ("ParWrite: Entering\n"));

    //
    // The routine which performs the write varies depending upon the currently
    // negotiated mode.  Start I/O moves the IRP into the Extension (CurrentOpIrp)
    //
    // Default mode: Centronics
    //

    // dvdr
    ParDump2(PARINFO, ("ParWrite: Calling ParReverseToForward\n"));

    // Go ahead and flip the bus if need be.  The proc will just make sure we're properly
    // connected and pointing in the right direction.
    Status = ParReverseToForward( Extension );

    // only do this if we are in safe mode
    if ( Extension->ModeSafety == SAFE_MODE ) {

        //
        // Set the channel address if we need to.
        //
        if (NT_SUCCESS(Status) && Extension->SetForwardAddress &&    
            (afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress))
        {
            // dvdr
            ParDump2(PARINFO, ("ParWrite: Calling Protocol %x\n", Extension->IdxForwardProtocol));

            Status  = afpForward[Extension->IdxForwardProtocol].fnSetInterfaceAddress (
                                                                    Extension,
                                                                    Extension->ForwardInterfaceAddress);
            if (NT_SUCCESS(Status))
                Extension->SetForwardAddress = FALSE;
            else
                Extension->SetForwardAddress = TRUE;
        }
    }

    if (NT_SUCCESS(Status)) {
    #if (1 == DVRH_USE_CORRECT_PTRS)
        if (Extension->fnWrite || afpForward[Extension->IdxForwardProtocol].fnWrite) {
    #else
        if (afpForward[Extension->IdxForwardProtocol].fnWrite) {
    #endif
            *NumBytesWritten = 0;

            #if DVRH_SHOW_BYTE_LOG
                {
                    ULONG i=0;
                    DbgPrint("Parallel:Write: ");
                    for (i=0; i<NumBytesToWrite; ++i) { DbgPrint(" %02x",*((PUCHAR)Buffer+i)); }
                    DbgPrint("\n");
                }
            #endif

            #if (1 == DVRH_USE_CORRECT_PTRS)
                if( Extension->fnWrite) {
                    Status = ((PPROTOCOL_WRITE_ROUTINE)Extension->fnWrite)(Extension,
                                                                           Buffer,
                                                                           NumBytesToWrite,
                                                                           NumBytesWritten);
                } else {
                    Status = afpForward[Extension->IdxForwardProtocol].fnWrite(Extension,
                                                                               Buffer,
                                                                               NumBytesToWrite,
                                                                               NumBytesWritten);
                }
            #else
                Status = afpForward[Extension->IdxForwardProtocol].fnWrite(Extension,
                                                                           Buffer,
                                                                           NumBytesToWrite,
                                                                           NumBytesWritten);
            #endif
        }
#if DBG
        else {
            ParDump2(PARERRORS, ( "ParReadIrp: Don't have a fnWrite!\r\n" ));
            ParDump2(PARERRORS, ( "ParReadIrp: You're hosed man.\r\n" ));
            ParDump2(PARERRORS, ( "ParReadIrp: If you are here, you've got a bug somewhere else.\r\n" ));
            ParDump2(PARERRORS, ( "ParReadIrp: Go fix it!\r\n" ));
        }    
#endif

    }
#if DBG
    else {
        ParDump2(PARERRORS, ( "ParReadIrp: Failure from above! Didn't call Write!\r\n" ));
        ParDump2(PARERRORS, ( "ParReadIrp: You're hosed man.\r\n" ));
        ParDump2(PARERRORS, ( "ParReadIrp: If you are here, you've got a bug somewhere else.\r\n" ));
        ParDump2(PARERRORS, ( "ParReadIrp: Go fix it!\r\n" ));
    }
#endif

#if (1 == DVRH_RAISE_IRQL)
    KeLowerIrql(OldIrql);
#endif

    // dvdr
    ParDump2(PARINFO, ("ParWrite: Leaving\n"));

    return Status;
}


VOID
ParWriteIrp(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine implements a WRITE request with the extension's current irp.

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/

{
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    ULONG               NumBytesWritten = 0;

    Irp    = Extension->CurrentOpIrp;
    IrpSp  = IoGetCurrentIrpStackLocation(Irp);

    ParTimerCheck(( "ParWriteIrp: Start. BytesToWrite[%d]\r\n", IrpSp->Parameters.Write.Length ));

    Irp->IoStatus.Status = ParWrite(Extension,
                                    Irp->AssociatedIrp.SystemBuffer,
                                    IrpSp->Parameters.Write.Length,
                                    &NumBytesWritten);

    Irp->IoStatus.Information = NumBytesWritten;
    ParTimerCheck(( "ParWriteIrp: End. BytesWritten[%d]\r\n", NumBytesWritten ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\swepp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    epp.c

Abstract:

    This module contains the code to perform all EPP related tasks (including
    EPP Software and EPP Hardware modes.)

Author:

    Timothy T. Wells (WestTek, L.L.C.) - April 16, 1997

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


BOOLEAN
ParIsEppSwWriteSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
BOOLEAN
ParIsEppSwReadSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterEppSwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID
ParTerminateEppSwMode(
    IN  PDEVICE_EXTENSION   Extension
    );

NTSTATUS
ParEppSwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEppSwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    

BOOLEAN
ParIsEppSwWriteSupported(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine determines whether or not EPP mode is suported
    in the write direction by trying negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    // dvdr
    ParDump2(PARINFO, ("ParIsEppSwWriteSupported: Entering\n"));

    if (!(Extension->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Extension->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        ParDump2(PARINFO, ("ParIsEppSwWriteSupported: Hardware Not Supported Leaving\n"));
        // Only use EPP Software in the reverse direction if an ECR is 
        // present or we know that we can put the data register into Byte mode.
        return FALSE;
    }
        

    if (Extension->BadProtocolModes & EPP_SW) {
        // dvdr
        ParDump2(PARINFO, ("ParIsEppSwWriteSupported: Not Supported Leaving\n"));
        return FALSE;
    }

    if (Extension->ProtocolModesSupported & EPP_SW) {
        // dvdr
        ParDump2(PARINFO, ("ParIsEppSwWriteSupported: Supported Leaving\n"));
        return TRUE;
    }

    // Must use SWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppSwMode (Extension, FALSE);
    ParTerminateEppSwMode (Extension);
    
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParIsEppSwWriteSupported: Negotiated Supported Leaving\n"));
        Extension->ProtocolModesSupported |= EPP_SW;
        return TRUE;
    }
   
    ParDump2(PARINFO, ("ParIsEppSwWriteSupported: Not Negotiated Not Supported Leaving\n"));
    return FALSE;    
}

BOOLEAN
ParIsEppSwReadSupported(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine determines whether or not EPP mode is suported
    in the read direction (need to be able to float the data register
    drivers in order to do byte wide reads) by trying negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (!(Extension->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Extension->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        ParDump2(PARINFO, ("ParIsEppSwReadSupported: Hardware Not Supported Leaving\n"));
        // Only use EPP Software in the reverse direction if an ECR is 
        // present or we know that we can put the data register into Byte mode.
        return FALSE;
    }
        
    if (Extension->BadProtocolModes & EPP_SW)
        return FALSE;

    if (Extension->ProtocolModesSupported & EPP_SW)
        return TRUE;

    // Must use SWEPP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEppSwMode (Extension, FALSE);
    ParTerminateEppSwMode (Extension);
    
    if (NT_SUCCESS(Status)) {
        ParDump2(PARINFO, ("ParIsEppSwReadSupported: Negotiated Supported Leaving\n"));
        Extension->ProtocolModesSupported |= EPP_SW;
        return TRUE;
    }
   
    ParDump2(PARINFO, ("ParIsEppSwReadSupported: Not Negotiated Not Supported Leaving\n"));
    return FALSE;    
}

NTSTATUS
ParEnterEppSwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    EPP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    // dvdr
    ParDump2(PARINFO, ("ParEnterEppSwMode: Entering\n"));

    // Parport Set Chip mode will put the Chip into Byte Mode if Capable
    // We need it for Epp Sw Mode
    Status = Extension->TrySetChipMode( Extension->PortContext, ECR_BYTE_PIO_MODE );

    if ( NT_SUCCESS(Status) ) {
        if ( Extension->ModeSafety == SAFE_MODE ) {
            if (DeviceIdRequest) {
                // dvdr
                ParDump2(PARINFO, ("ParEnterEppSwMode: Calling IeeeEnter1284Mode with DEVICE_ID_REQUEST\n"));
                Status = IeeeEnter1284Mode (Extension, EPP_EXTENSIBILITY | DEVICE_ID_REQ);
            } else {
                // dvdr
                ParDump2(PARINFO, ("ParEnterEppSwMode: Calling IeeeEnter1284Mode\n"));
                Status = IeeeEnter1284Mode (Extension, EPP_EXTENSIBILITY);
            }
        } else {
            ParDump2(PARINFO, ("ParEnterEppSwMode: In UNSAFE_MODE.\n"));
            Extension->Connected = TRUE;
        }
    }
        
    if ( NT_SUCCESS(Status) ) {
        // dvdr
        ParDump2(PARINFO, ("ParEnterEppSwMode: IeeeEnter1284Mode returned success\n"));
        Extension->CurrentPhase = PHASE_FORWARD_IDLE;
        Extension->IsIeeeTerminateOk = TRUE;

    } else {
        // dvdr
        ParDump2(PARINFO, ("ParEnterEppSwMode: IeeeEnter1284Mode returned unsuccessful\n"));
        Extension->CurrentPhase = PHASE_UNKNOWN;
        Extension->IsIeeeTerminateOk = FALSE;
    }
    
    ParDump2(PARINFO, ("ParEnterEppSwMode: Leaving with Status : %x \n", Status));

    return Status; 
}    

VOID
ParTerminateEppSwMode(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Extension  - The Device Extension which has the parallel port's controller address.

Return Value:

    None.

--*/

{
    // dvdr
    ParDump2(PARINFO, ("ParTerminateEppMode: Entering\n"));
    if ( Extension->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Extension);
    } else {
        ParDump2(PARINFO, ("ParTerminateEppMode: In UNSAFE_MODE.\n"));
        Extension->Connected = FALSE;
    }
    Extension->ClearChipMode( Extension->PortContext, ECR_BYTE_PIO_MODE );
    ParDump2(PARINFO, ("ParTerminateEppMode: Leaving\n"));
    return;    
}

NTSTATUS
ParEppSwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the EPP protocol under software
    control.
    
Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    PUCHAR          pBuffer = (PUCHAR)Buffer;
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           i, j;
    UCHAR           HDReady, HDAck, HDFinished;
    
    // dvdr
    ParDump2(PARINFO, ("ParEppSwWrite: Entering\n"));

    Controller = Extension->Controller;

    Extension->CurrentPhase = PHASE_FORWARD_XFER;
    
    // BIT5 of DCR needs to be low to be in BYTE forward mode
    HDReady = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, INACTIVE, INACTIVE );
    HDAck = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, INACTIVE );
    HDFinished = SET_DCR( INACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, ACTIVE );

    for (i = 0; i < BufferSize; i++) {

        // dvdr
        ParDump2(PARINFO, ("ParEppSwWrite: Writing Byte to port\n"));

        WRITE_PORT_BUFFER_UCHAR( Controller,
                                 pBuffer++,
                                 (ULONG)0x01 );

        //
        // Event 62
        //
        StoreControl (Controller, HDReady);

        // =============== Periph State 58     ===============
        // Should wait up to 10 micro Seconds but waiting up
        // to 15 micro just in case
        for ( j = 16; j > 0; j-- ) {
            if( !(GetStatus(Controller) & DSR_NOT_BUSY) )
                break;
            KeStallExecutionProcessor(1);
        }

        // see if we timed out on state 58
        if ( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            ParDump2(PARERRORS, ("ParEppSwModeWrite:Failed State 58: Controller %x\n", Controller));
            Extension->CurrentPhase = PHASE_UNKNOWN;
            break;
        }

        //
        // Event 63
        //
        StoreControl (Controller, HDAck);

        // =============== Periph State 60     ===============
        // Should wait up to 125 nano Seconds but waiting up
        // to 5 micro seconds just in case
        for ( j = 6; j > 0; j-- ) {
            if( GetStatus(Controller) & DSR_NOT_BUSY )
                break;
            KeStallExecutionProcessor(1);
        }

        if( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            ParDump2(PARERRORS, ("ParEppSwModeWrite:Failed State 60: Controller %x\n", Controller));
            Extension->CurrentPhase = PHASE_UNKNOWN;
            break;
        }
            
        //
        // Event 61
        //
        StoreControl (Controller, HDFinished);
            
        // Stall a little bit between data bytes
        KeStallExecutionProcessor(1);

    }
        
    *BytesTransferred = i;

    // dvdr
    ParDump2(PARINFO, ("ParEppSwWrite: Leaving with %i Bytes Transferred\n", i));

    if ( Status == STATUS_SUCCESS )
        Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    
    return Status;

}

NTSTATUS
ParEppSwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 EPP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          pBuffer = (PUCHAR)Buffer;
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           i, j;
    UCHAR           dcr;
    UCHAR           HDReady, HDAck;
    
    // dvdr
    ParDump2(PARINFO, ("ParEppSwRead: Entering\n"));

    Controller = Extension->Controller;

    Extension->CurrentPhase = PHASE_REVERSE_XFER;
    
    // Save off Control
    dcr = GetControl (Controller);
    
    // BIT5 of DCR needs to be high to be in BYTE reverse mode
    HDReady = SET_DCR( ACTIVE, INACTIVE, ACTIVE, ACTIVE, INACTIVE, ACTIVE );
    HDAck = SET_DCR( ACTIVE, INACTIVE, ACTIVE, ACTIVE, ACTIVE, ACTIVE );

    // First time to get into reverse mode quickly
    StoreControl (Controller, HDReady);

    for (i = 0; i < BufferSize; i++) {

        //
        // Event 67
        //
        StoreControl (Controller, HDReady);
            
        // =============== Periph State 58     ===============
        // Should wait up to 10 micro Seconds but waiting up
        // to 15 micro just in case
        for ( j = 16; j > 0; j-- ) {
            if( !(GetStatus(Controller) & DSR_NOT_BUSY) )
                break;
            KeStallExecutionProcessor(1);
        }

        // see if we timed out on state 58
        if ( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            ParDump2(PARERRORS, ("ParEppSwRead:Failed State 58: Controller %x\n", Controller));
            Extension->CurrentPhase = PHASE_UNKNOWN;
            break;
        }

        // Read the Byte                
        READ_PORT_BUFFER_UCHAR( Controller, 
                                pBuffer++, 
                                (ULONG)0x01 );

        //
        // Event 63
        //
        StoreControl (Controller, HDAck);
            
        // =============== Periph State 60     ===============
        // Should wait up to 125 nano Seconds but waiting up
        // to 5 micro seconds just in case
        for ( j = 6; j > 0; j-- ) {
            if( GetStatus(Controller) & DSR_NOT_BUSY )
                break;
            KeStallExecutionProcessor(1);
        }

        if( !j ) {
            // Time out.
            // Bad things happened - timed out on this state,
            // Mark Status as bad and let our mgr kill current mode.
            Status = STATUS_IO_DEVICE_ERROR;

            ParDump2(PARERRORS, ("ParEppSwRead:Failed State 60: Controller %x\n", Controller));
            Extension->CurrentPhase = PHASE_UNKNOWN;
            break;
        }
        
        // Stall a little bit between data bytes
        KeStallExecutionProcessor(1);
    }
    
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);
    
    *BytesTransferred = i;

    // dvdr
    ParDump2(PARINFO, ("ParEppSwRead: Leaving with %x Bytes Transferred\n", i));

    if ( Status == STATUS_SUCCESS )
        Extension->CurrentPhase = PHASE_FORWARD_IDLE;

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\rescan.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       rescan.c
//
//--------------------------------------------------------------------------

// rescan a parallel port for changes in the connected devices

#include "pch.h"

// typedef struct _PAR_DEVOBJ_STRUCT {
//     PUCHAR                    Controller;    // host controller address for devices in this structure
//     PDEVICE_OBJECT            LegacyPodo;    // legacy or "raw" port device
//     PDEVICE_OBJECT            EndOfChainPdo; // End-Of-Chain PnP device
//     PDEVICE_OBJECT            Dot3Id0Pdo;    // 1284.3 daisy chain device, 1284.3 deviceID == 0
//     PDEVICE_OBJECT            Dot3Id1Pdo;
//     PDEVICE_OBJECT            Dot3Id2Pdo;
//     PDEVICE_OBJECT            Dot3Id3Pdo;    // 1284.3 daisy chain device, 1284.3 deviceID == 3
//     PDEVICE_OBJECT            LegacyZipPdo;  // Legacy Zip Drive
//     PFILE_OBJECT              pFileObject;   // Need an open handle to ParPort device to prevent it
//                                              //    from being removed out from under us
//     struct _PAR_DEVOBJ_STRUCT *Next;
// } PAR_DEVOBJ_STRUCT, *PPAR_DEVOBJ_STRUCT;

typedef struct _DEVOBJ_ID_PAIR {
    PDEVICE_OBJECT DevObj;
    PCHAR          Id;
} DEVOBJ_ID_PAIR, *PDEVOBJ_ID_PAIR;


ULONG gsuc = 1;

ULONG
ParTst() {
    return gsuc;
}

PPAR_DEVOBJ_STRUCT 
ParLockPortDeviceObjects(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead
    )
{
    NTSTATUS           status;
    PPAR_DEVOBJ_STRUCT head        = DevObjStructHead;
    PPAR_DEVOBJ_STRUCT currentNode = head;
    PPAR_DEVOBJ_STRUCT prevNode    = NULL;
    PPAR_DEVOBJ_STRUCT delNode;

    DDPnP1(("## ParLockPortDeviceObjects - enter\n"));

    while( currentNode ) {

        PDEVICE_OBJECT     currentDevObj;
        PDEVICE_EXTENSION  currentDevExt;
        PUNICODE_STRING    portDevName;
        PFILE_OBJECT       portFileObj;
        PDEVICE_OBJECT     portDevObj;

        currentDevObj = currentNode->LegacyPodo;
        currentDevExt = currentDevObj->DeviceExtension;
        portDevName   = &currentDevExt->PortSymbolicLinkName;
        
        status = IoGetDeviceObjectPointer(portDevName,
                                          STANDARD_RIGHTS_ALL,
                                          &portFileObj,
                                          &portDevObj);
            

        if( NT_SUCCESS(status) && portFileObj && portDevObj ) {
            //
            // We have a FILE open against the ParPort Device to
            //   lock the device into memory until we're done with the rescan.
            //
            // Save the pointer to the file object so we can unlock when we're done.
            //
            currentNode->pFileObject = portFileObj;
            DDPnP1(("## ParLockPortDeviceObjects - opened FILE - PFILE= %x , %x\n",portFileObj,currentNode->Controller));
            
            // advance pointers
            prevNode    = currentNode;
            currentNode = currentNode->Next;

        } else {
            //
            // we couldn't open a FILE open against the ParPort Device so the
            //   port must be gone. Remove this port from the list of ports to rescan.
            //
            DDPnP1(("## ParLockPortDeviceObjects - open FILE FAILED - %x\n",currentNode->Controller));
            delNode = currentNode; // this is the node to delete
            currentNode = currentNode->Next;
            if( head == delNode ) {
                // deleted node was list head - save updated current node as new list head
                head = currentNode;
            } else {
                // link around node to be deleted
                prevNode->Next = currentNode;
            }
            ExFreePool( delNode );
        }            
    }

    DDPnP1(("## ParLockPortDeviceObjects - exit\n"));

    return head;
}

VOID
ParUnlockPortDeviceObjects(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead
    )
{
    PPAR_DEVOBJ_STRUCT currentNode = DevObjStructHead;

    DDPnP1(("## ParUnlockPortDeviceObjects - enter\n"));
    while( currentNode ) {
        if( currentNode->pFileObject ) {
            ObDereferenceObject( currentNode->pFileObject );
            DDPnP1(("## ParUnlockPortDeviceObjects - closed FILE - PFILE= %x , %x\n",currentNode->pFileObject,currentNode->Controller));
            currentNode->pFileObject = NULL;
        }
        currentNode = currentNode->Next;
    }
    DDPnP1(("## ParUnlockPortDeviceObjects - exit\n"));
}

PCHAR 
Par3Get1284InfString(PDEVICE_EXTENSION LegacyExt, UCHAR Dot3DeviceId)
{
    NTSTATUS       status;
    PCHAR          devId             = NULL;
    PCHAR          infString         = NULL;
    ULONG          devIdSize;
    PDEVICE_OBJECT portDeviceObject  = LegacyExt->PortDeviceObject;
    ULONG          maxIdTries        = 3;
    ULONG          idTry             = 1;
    BOOLEAN        bBuildStlDeviceId = FALSE ;

    bBuildStlDeviceId = ParStlCheckIfStl (LegacyExt, Dot3DeviceId) ;
    
    //
    // Select the .3 daisy chain device, query for 1284 ID, and deselect device.
    //

    status = ParSelect1284_3Device(portDeviceObject, Dot3DeviceId);
    if( !NT_SUCCESS( status ) ) {
        // unable to select device, bail out
        ParDump2(PARPNP1, ("rescan::Par3Get1284InfString - SELECT FAILED\n") );
        goto targetExit;
    }

    while( (NULL==devId) && (idTry <= maxIdTries) ) {
        devId = Par3QueryDeviceId(LegacyExt, NULL, 0, &devIdSize, FALSE, bBuildStlDeviceId);
        if( NULL == devId ) {
            ParDump2(PARPNP1, ("rescan::Par3Get1284InfString - no 1284 ID on try %d\n", idTry) );
            KeStallExecutionProcessor(1);
            ++idTry;
        } else {
            ParDump2(PARPNP1, ("rescan::Par3Get1284InfString - <%s> on try %d\n", devId, idTry) );
        }
    }

    status = ParDeselect1284_3Device(portDeviceObject, Dot3DeviceId);
    if( !NT_SUCCESS( status ) ) {
        ASSERTMSG("Unable to Deselect? - ParPort probably blocked now - this should never happen \n", FALSE);
        goto targetExit;
    }

    if( NULL == devId ) {
        // we didn't get a 1284 ID, bail out
        ParDump2(PARPNP1, ("rescan::Par3Get1284InfString - didn't get a 1284 ID, bail out\n") );
        goto targetExit;
    }


    //
    // Massage the 1284 ID into the format used in the INF.
    //

    infString = ExAllocatePool( PagedPool, MAX_ID_SIZE + 1 );
    if( NULL == infString ) {
        ParDump2(PARPNP1, ("rescan::Par3Get1284InfString - no pool avail, bail out\n") );
        // no pool available, bail out
        goto targetExit;
    }

    RtlZeroMemory( infString, MAX_ID_SIZE + 1 );
    
    status = ParPnpGetId(devId, BusQueryDeviceID, infString, NULL);

    if( !NT_SUCCESS(status) ) {
        // massage failed, bail out
        ParDump2(PARPNP1, ("rescan::Par3Get1284InfString - ID massage failed, bail out\n") );
        ExFreePool( infString );
        infString = NULL;
    }

targetExit:

    if( NULL != devId ) {
        ExFreePool( devId );
    }

    return infString;
}

VOID
dot3rescan( IN PPAR_DEVOBJ_STRUCT CurrentNode )
{
    NTSTATUS          status;
    UCHAR             oldDeviceCount;
    UCHAR             newDeviceCount;
    UCHAR             idx;
    PDEVICE_OBJECT    *oldDevObj;
    DEVOBJ_ID_PAIR    newDevObjIdPair[ IEEE_1284_3_DAISY_CHAIN_MAX_ID + 1 ];
    BOOLEAN           changeDetected   = FALSE;
    PDEVICE_OBJECT    legacyPodo       = CurrentNode->LegacyPodo;
    PDEVICE_EXTENSION legacyExtension  = legacyPodo->DeviceExtension;
    PDEVICE_OBJECT    portDeviceObject = legacyExtension->PortDeviceObject;

    ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - Enter\n") );

    //
    // Count the number of .3 daisy chain devices we had on last scan
    //   of this port
    //
    idx = 0;
    oldDevObj = &CurrentNode->Dot3Id0Pdo;
    while( NULL != oldDevObj[idx] ) {
        ++idx;
    }
    oldDeviceCount = idx;
    ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - Dot3 DeviceCount Before Rescan = %d\n", idx) );


    //
    // Reinitialize the 1284.3 daisy chain (reassign .3 IDs)
    //
    ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - reinitializing Dot3 bus\n") );
    status = ParInit1284_3Bus( portDeviceObject );
    if( !NT_SUCCESS(status) ) {
        ASSERT(FALSE); // this should never happen
        return;
    }


    //
    // Ask ParPort how many .3 daisy chain devices were detected after
    //   the .3 reinitialize. Does the number differ from the number that
    //   we had prior to rescan?
    //
    newDeviceCount = ParGet1284_3DeviceCount( portDeviceObject );


    //
    // Did we detect a change in the .3 device daisy chain?
    // 
    if( oldDeviceCount != newDeviceCount ) {

        ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - deviceCount changed - old=%d, new=%d\n", oldDeviceCount, newDeviceCount) );
        changeDetected=TRUE;

    } else {

        //
        // The number of .3 devices stayed the same. Compare 1284 IDs read from
        //   the device with those saved in the PDOs from the previous rescan.
        //
        ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - deviceCount unchanged - old=new=%d - comparing IDs\n", newDeviceCount) );
        for( idx=0 ; idx < oldDeviceCount ; ++idx ) {
            ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - checking ID's - idx = %d\n", idx) );
            if( NULL != oldDevObj[idx] ) {
                //
                // We had a PDO, check if the device is still here
                //
                PDEVICE_EXTENSION ext = oldDevObj[idx]->DeviceExtension;
                PCHAR dot3InfString   = Par3Get1284InfString( legacyExtension, idx );

                if( NULL == dot3InfString ) {

                    //
                    // We had a PDO, but now we don't detect any device
                    //
                    ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - DEVICE GONE        - idx = %d\n", idx) );
                    changeDetected = TRUE;
                    break;

                } else {

                    //
                    // We had a PDO, but the device we detect differs from what we expected
                    //
                    if( 0 == strcmp( ext->DeviceIdString, dot3InfString ) ) {
                        ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - DEVICE STILL THERE - idx = %d\n", idx) );
                    } else {
                        ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - DEVICE CHANGED     - idx = %d\n", idx) );
                        changeDetected = TRUE;
                    }

                    ExFreePool( dot3InfString );

                    if( changeDetected ) {
                        break;
                    }

                }

            } // if( NULL != oldDevObj[idx] ...

        } // for( idx=0 ; ...

    } // if( oldDeviceCount != newDeviceCount ) {...} else {...}
        

    if( changeDetected ) {

        //
        // Mark all existing .3 PDOs for devices connected to the port as "hardware gone"
        //
        ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - CHANGE DETECTED\n") );

        for( idx=0 ; idx <= IEEE_1284_3_DAISY_CHAIN_MAX_ID ; ++idx ) {
            if( NULL != oldDevObj[idx] ) {
                ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - marking PDO %p as HARDWARE GONE\n", oldDevObj[idx]) );
                ParMarkPdoHardwareGone( oldDevObj[idx]->DeviceExtension );
            }
        }

        //
        // Create a new PDO for each .3 device.
        //
        for( idx = 0 ; idx < newDeviceCount ; ++idx ) {

            PDEVICE_OBJECT newDevObj;
            BOOLEAN        bBuildStlDeviceId; 

            bBuildStlDeviceId = ParStlCheckIfStl(legacyPodo->DeviceExtension, idx ) ;

            //
            // Select Device
            //
            status = ParSelect1284_3Device(portDeviceObject, idx);
            if( !NT_SUCCESS( status ) ) {
                ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - creating of new PDO for idx=%d FAILED\n", idx) );
                continue;
            }

            //
            // Create new PDO
            //
            newDevObj = ParDetectCreatePdo( legacyPodo, idx, bBuildStlDeviceId );

            //
            // Deselect Device
            //
            status = ParDeselect1284_3Device(portDeviceObject, idx);
            if( !NT_SUCCESS( status ) ) {
                ASSERTMSG("Unable to Deselect? - ParPort probably blocked now - this should never happen \n", FALSE);
                if( NULL != newDevObj ) {
                    ParKillDeviceObject( newDevObj );
                    newDevObj = NULL;
                }
            }

            //
            // Add new PDO to FDO's list of children
            //
            if( NULL != newDevObj ) {
                ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - adding new PDO %p - idx=%d to FDO list\n", newDevObj, idx) );
                ParAddDevObjToFdoList(newDevObj);
            } else {
                ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - creating of new PDO for idx=%d FAILED\n", idx) );
            }
        }

    }

    return;
}

VOID
ParCreateDot3DeviceIdList(
    IN OUT PCHAR             deviceIdArray[], 
    IN     PDEVICE_EXTENSION legacyExt, 
    IN     UCHAR             dot3DeviceCount
)
{
    PDEVICE_OBJECT portDeviceObject = legacyExt->PortDeviceObject;
    NTSTATUS status;
    UCHAR    idx=0;
    ULONG    deviceIdSize;
    BOOLEAN  bBuildStlDeviceId;

    ParDump2(PARPNP1, ("ParCreateDot3DeviceIdList() - Enter\n") );
    while( idx < dot3DeviceCount ) {
        bBuildStlDeviceId = ParStlCheckIfStl (legacyExt, idx) ;
        status = ParSelect1284_3Device(portDeviceObject, idx);
        if( NT_SUCCESS( status ) ) {
            ParDump2(PARPNP1,  ("rescan::ParCreateDot3DeviceIdList: - select SUCCESS - idx=%d\n", idx) );
            deviceIdArray[idx] = Par3QueryDeviceId(legacyExt, NULL, 0, &deviceIdSize, FALSE, bBuildStlDeviceId);
            if(deviceIdArray[idx]) {
                ParDump2(PARPNP1, ("rescan::ParCreateDot3DeviceIdList: - id=<%s>\n", deviceIdArray[idx]) );
            } else {
                ParDump2(PARPNP1, ("rescan::ParCreateDot3DeviceIdList: - Par3QueryDeviceId FAILED\n") );
            }
            ParDeselect1284_3Device(portDeviceObject, idx);
        } else {
            ParDump2(PARPNP1, ("rescan::ParCreateDot3DeviceIdList: - select FAILED  - idx=%d\n", idx) );
            deviceIdArray[idx] = NULL;
        }
        ++idx;
    }
}

NTSTATUS
ParPnpFdoQueryDeviceRelationsBusRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
{
    NTSTATUS           status;
    PDEVICE_EXTENSION  fdoExt = Fdo->DeviceExtension;
    PPAR_DEVOBJ_STRUCT devObjStructHead = NULL;
    ULONG              DeviceRelationsSize = 0;
    ULONG              Idx                 = 0;
    PDEVICE_RELATIONS  DeviceRelations     = NULL;
    PDEVICE_OBJECT     pNextDeviceObject;  // used for walking the ParClass DO list
    PDEVICE_EXTENSION  pExtension;         // used for walking the ParClass DO list

    ParDump2(PARPNP1, ("ParFdoQueryDeviceRelationsBusRelations - Enter\n") );

    //
    // Build a list of PAR_DEVOBJ_STRUCTs, one per ParPort device,
    //   from the FDO's list of device objects that were found connected
    //   to the ports the last time we checked.
    //
    // Create FILE against each ParPort Device to prevent it from being 
    //   deleted out from under us.
    //
    ExAcquireFastMutex(&fdoExt->DevObjListMutex); 
    devObjStructHead = ParBuildDevObjStructList(Fdo);
    devObjStructHead = ParLockPortDeviceObjects( devObjStructHead );
    ExReleaseFastMutex(&fdoExt->DevObjListMutex);

    if( !devObjStructHead ) {
        // something went wrong, likely either no parallel ports, or unable to alloc pool
        DDPnP1(("## ParPnpFdoQueryDeviceRelationsBusRelations - empty devObjStructHead - goto rescanComplete\n"));
        goto rescanComplete;
    }

    //
    // Dump the list of device objects that we have before rescan (debug only)
    //
#if DBG
    ParDumpDevObjStructList(devObjStructHead);
#endif

    //
    // Rescan all ports for changes in attached devices and
    //   update the ParClass FDO's list of device objects accordingly.
    //   (side effects - big time!!!)
    //
    ParDoParallelBusRescan(devObjStructHead);

    //
    // Close FDO FILEs against ParPort Devices (release FDO locks)
    //
    ParUnlockPortDeviceObjects(devObjStructHead);

    //
    // Delete the previous PAR_DEVOBJ_STRUCT list and create a 
    //   new list from the FDO's list of devices after the rescan.
    //
    ParDestroyDevObjStructList(devObjStructHead);

    ExAcquireFastMutex(&fdoExt->DevObjListMutex); 
    devObjStructHead = ParBuildDevObjStructList(Fdo);
    ExReleaseFastMutex(&fdoExt->DevObjListMutex);

    if( !devObjStructHead ) {
        // something went wrong, likely either no parallel ports, or unable to alloc pool
        goto rescanComplete;
    }

    //
    // Dump the list of device objects that we have after rescan (debug only)
    //
#if DBG
    ParDumpDevObjStructList(devObjStructHead);
#endif

    //
    // Delete the PAR_DEVOBJ_STRUCT list, we no longer need it
    //
    ParDestroyDevObjStructList(devObjStructHead);

rescanComplete:    

    //
    // The rescan is now complete, report the current set of attached devices to PnP
    //

    //
    // Lock list while we scan it twice
    //
    ExAcquireFastMutex(&fdoExt->DevObjListMutex); 

    //
    // Get list head
    //
    pNextDeviceObject = fdoExt->ParClassPdo; 
    
    //
    // Walk list and count number of PDOs
    //
    while( pNextDeviceObject ) {
        pExtension = pNextDeviceObject->DeviceExtension;
        if ( pExtension->DeviceIdString[0] != 0 ) {
            Idx++;
            ParDump2(PARPNP1, ("found PDO  %wZ - Extension: %x\n", &pExtension->SymbolicLinkName, pExtension) );
            ParDump2(PARPNP1, (" - %s\n", pExtension->DeviceIdString) );
        } else if ( pExtension->DeviceStateFlags & PAR_DEVICE_HARDWARE_GONE ) {
            ParDump2(PARPNP1, ("found PDO  %wZ - marked HARDWARE_GONE - Extension: %x\n", &pExtension->SymbolicLinkName, pExtension) );
            ParDump2(PARPNP1, (" - %s\n", pExtension->DeviceIdString) );
        } else {
            ParDump2(PARPNP1, ("found PODO %wZ - Extension: %x\n", &pExtension->SymbolicLinkName, pExtension) );
        }
        pNextDeviceObject = pExtension->Next;
    }
    
    //
    // allocate and initialize pool to hold DeviceRelations
    //
    DeviceRelationsSize = sizeof(DEVICE_RELATIONS) + (Idx * sizeof(PDEVICE_OBJECT));
    DeviceRelations     = ExAllocatePool(PagedPool, DeviceRelationsSize);
    if( !DeviceRelations ) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        ExReleaseFastMutex(&fdoExt->DevObjListMutex);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        ParReleaseRemoveLock(&fdoExt->RemoveLock, Irp);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(DeviceRelations, DeviceRelationsSize);
    
    //
    // Walk the list again to construct DeviceRelations
    //
    Idx = 0;
    pNextDeviceObject = fdoExt->ParClassPdo;
    
    while( pNextDeviceObject ) {
        pExtension = pNextDeviceObject->DeviceExtension;
        ParDump2(PARPNP1, ("rescan::ParPnpFdoQDR/BusRelations - Examining DO= %x , Ext= %x\n", pNextDeviceObject, pExtension));
        if(  (pExtension->DeviceIdString[0] != 0) && 
            !(pExtension->DeviceStateFlags & PAR_DEVICE_HARDWARE_GONE) &&
             (pExtension->SymbolicLinkName.Length > 0) ) {
            // If this is a PDO, that is not marked "hardware gone", and has a SymbolicLink
            DeviceRelations->Objects[Idx++] = pNextDeviceObject;
            DeviceRelations->Count++;
            ParDump2(PARPNP1, ("adding PDO %x <%wZ> to DeviceRelations, new PDO count=%d\n", 
                       pNextDeviceObject, &pExtension->SymbolicLinkName,DeviceRelations->Count) );
            ASSERT( ( pExtension->SymbolicLinkName.Length > 0 ) );
            status = ObReferenceObjectByPointer(pNextDeviceObject, 0, NULL, KernelMode);
            if(!NT_SUCCESS(status)) {
                ParDumpP( ("Error Referencing PDO\n") );
                ExFreePool(DeviceRelations);
                Irp->IoStatus.Status = status;
                ExReleaseFastMutex(&fdoExt->DevObjListMutex); // error - release Mutex
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                ParReleaseRemoveLock(&fdoExt->RemoveLock, Irp);
                return status;
            }
        } else {
            ParDump2(PARPNP1, (" - skipping DO= %x\n", pNextDeviceObject));
            if( pExtension->DeviceStateFlags & PAR_DEVICE_HARDWARE_GONE ) {
                ParDump2(PARPNP1, ("   - because PAR_DEVICE_HARDWARE_GONE\n"));
            } else if( pExtension->DeviceIdString[0] == 0 ) {
                ParDump2(PARPNP1, ("   - because DeviceIdString[0] == 0 - may be a PODO\n"));
            } else if( pExtension->SymbolicLinkName.Length == 0 ) {
                ParDump2(PARPNP1, ("   - because pExtension->SymbolicLinkName.Length == 0\n"));
            } else {
                ParDump2(PARPNP1, ("   - WHY are we skipping this?\n"));
                ASSERT(FALSE);
            }
        }
        pNextDeviceObject = pExtension->Next;
    }
    
    ParDump2(PARPNP1, ("rescan::ParPnpFdoQDR/BusRelations - DeviceRelations->Count = %d\n", DeviceRelations->Count));

    //
    // SUCCESS - set IRP fields and pass the IRP down the stack
    // 
    Irp->IoStatus.Information = (ULONG_PTR)DeviceRelations;
    Irp->IoStatus.Status = STATUS_SUCCESS;
    ExReleaseFastMutex(&fdoExt->DevObjListMutex); // done - release Mutex
    IoSkipCurrentIrpStackLocation(Irp);
    ParReleaseRemoveLock(&fdoExt->RemoveLock, Irp);
    ParDump2(PARPNP1, ("ParFdoQueryDeviceRelationsBusRelations - Leave\n") );
    return ParCallDriver(fdoExt->ParentDeviceObject, Irp);
}

PPAR_DEVOBJ_STRUCT 
ParBuildDevObjStructList(
    IN PDEVICE_OBJECT Fdo
    ) 
/*++dvdf - code complete

Routine Description:

    This routine creates a list of PAR_DEVOBJ_STRUCT structures and returns
      a pointer to the first structure. Each PAR_DEVOBJ_STRUCT describes
      all ParClass devices associated with a single PortPort device.


Arguments:

    Fdo - points to the ParClass FDO

Return Value:

    PPAR_DEVOBJ_STRUCT - on success, points to the first structure created.

    NULL               - otherwise

--*/
{ 
    PPAR_DEVOBJ_STRUCT devObjStructHead = NULL;
    PDEVICE_EXTENSION  fdoExt = Fdo->DeviceExtension;
    PDEVICE_OBJECT     currentDo;
    PDEVICE_EXTENSION  currentExt;

    ParDump2(PARPNP1, ("Enter ParBuildDevObjStructList()\n") );

    //
    // do a quick exit if there are no ParClass Created PODOs or PDOs
    //
    currentDo = fdoExt->ParClassPdo;
    if( !currentDo ) {
        ParDump2(PARPNP1, ("No ParClass PODOs or PDOs exist\n") );
        return NULL;
    }
    
    // 
    // create an initial PAR_DEVOBJ_STRUCT
    // 
    currentExt       = currentDo->DeviceExtension;
    devObjStructHead = ParFindCreateDevObjStruct(NULL, currentExt->Controller);
    if( !devObjStructHead ) {
        return NULL;
    }

    //
    // walk linear list of ParClass created PODOs and PDOs and 
    //   create structured list of PAR_DEVOBJ_STRUCTs based on 
    //   Controller address and DevObj type
    //
    ParDump2(PARPNP1, ("walking FDO's list of created PODOs and PDOs\n") );
    while( currentDo ) {
        currentExt = currentDo->DeviceExtension;
        if( currentExt->DeviceStateFlags & PAR_DEVICE_HARDWARE_GONE ) {
            // this is a PDO that is waiting for PnP to send it a REMOVE, skip it
            ParDump2(PARPNP1, ("found PDO waiting to be REMOVEd - skipping - DO= %x , Ext= %x\n", 
                       currentDo, currentExt) );
        } else if( currentExt->DeviceIdString[0] == 0 ) {
            // this is a Legacy PODO
            ParDump2(PARPNP1, ("found PODO        - DO= %x , Ext= %x , Controller=%x\n", 
                       currentDo, currentExt, currentExt->Controller) );
            ParAddPodoToDevObjStruct(devObjStructHead, currentDo);
        } else if( currentExt->EndOfChain ) {
            // this is an End-Of-Chain PDO
            ParDump2(PARPNP1, ("found EOC PDO     - DO= %x , Ext= %x , Controller=%x\n", 
                       currentDo, currentExt, currentExt->Controller) );
            ParAddEndOfChainPdoToDevObjStruct(devObjStructHead, currentDo);
        } else if( currentExt->Ieee1284_3DeviceId == DOT3_LEGACY_ZIP_ID ) {
            // this is a Legacy Zip PDO
            ParDump2(PARPNP1, ("found LGZIP  PDO  - DO= %x , Ext= %x , Controller=%x\n", 
                       currentDo, currentExt, currentExt->Controller) );
            ParAddLegacyZipPdoToDevObjStruct(devObjStructHead, currentDo);
        } else {
            // this is a 1284.3 Daisy Chain PDO
            ParDump2(PARPNP1, ("found Dot3 DC PDO - DO= %x , Ext= %x , Controller=%x , Dot3ID=%d\n", 
                       currentDo, currentExt, currentExt->Controller, currentExt->Ieee1284_3DeviceId) );
            ParAddDot3PdoToDevObjStruct(devObjStructHead, currentDo);
        }
        currentDo = currentExt->Next;
    }


    //
    // It is possible for this function to construct a node with 
    //   a NULL LegacyPodo if the parport goes away while we still have a PDO
    //   marked PAR_DEVICE_HARDWARE_GONE that is waiting to be cleaned up.
    //
    // Discard any such nodes that don't have a LegacyPodo since the lack of a
    //   LegacyPodo indicates that the parport device is gone, and attempting to
    //   communicate with the parport will likely bugcheck.
    //
    {
        PPAR_DEVOBJ_STRUCT currentNode = devObjStructHead;
        PPAR_DEVOBJ_STRUCT prevNode    = NULL;

        while( currentNode ) {

            if( currentNode->LegacyPodo ) {

                // keep this node - advance pointers
                prevNode    = currentNode;
                currentNode = currentNode->Next;

            } else {

                // no PODO? - remove this node
                PPAR_DEVOBJ_STRUCT delNode = currentNode;
                currentNode                = currentNode->Next;

                if( prevNode ) {
                    // node to be removed is not first node - link around node to be deleted
                    prevNode->Next   = currentNode;
                } else {
                    // node to be removed was head of list - update list head
                    devObjStructHead = currentNode;
                }

                ExFreePool( delNode );

            } // end if/else currentNode->LegacyPodo

        } // end while currentNode

    } // end localblock

    return devObjStructHead;
}

VOID 
ParAddPodoToDevObjStruct(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead, 
    IN PDEVICE_OBJECT     CurrentDo
    )
{
    PDEVICE_EXTENSION  ext  = CurrentDo->DeviceExtension;
    PPAR_DEVOBJ_STRUCT node = ParFindCreateDevObjStruct(DevObjStructHead, ext->Controller);
    if( node ) {
        node->LegacyPodo    = CurrentDo;
    }
    return;
}

VOID 
ParAddEndOfChainPdoToDevObjStruct(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead, 
    IN PDEVICE_OBJECT     CurrentDo
    )
{
    PDEVICE_EXTENSION  ext  = CurrentDo->DeviceExtension;
    PPAR_DEVOBJ_STRUCT node = ParFindCreateDevObjStruct(DevObjStructHead, ext->Controller);
    if( node ) {
        node->EndOfChainPdo = CurrentDo;
    }
    return;
}

VOID 
ParAddLegacyZipPdoToDevObjStruct(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead, 
    IN PDEVICE_OBJECT     CurrentDo
    )
{
    PDEVICE_EXTENSION  ext  = CurrentDo->DeviceExtension;
    PPAR_DEVOBJ_STRUCT node = ParFindCreateDevObjStruct(DevObjStructHead, ext->Controller);
    if( node ) {
        ParDump2(PARPNP1, ("rescan::ParAddLegacyZipPdoToDevObjStruct - Controller=%x\n", ext->Controller) );
        node->LegacyZipPdo = CurrentDo;
    }
    return;
}

VOID 
ParAddDot3PdoToDevObjStruct(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead, 
    IN PDEVICE_OBJECT     CurrentDo
    )
{
    PDEVICE_EXTENSION  ext  = CurrentDo->DeviceExtension;
    PPAR_DEVOBJ_STRUCT node = ParFindCreateDevObjStruct(DevObjStructHead, ext->Controller);
    if( node ) {
        *( (&node->Dot3Id0Pdo) + (ext->Ieee1284_3DeviceId) ) = CurrentDo;
    }
    return;
}

PPAR_DEVOBJ_STRUCT ParFindCreateDevObjStruct(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead, 
    IN PUCHAR             Controller
    ) 
/*++

Routine Description:

    This function searches a list of PAR_DEVOBJ_STRUCTs for a
      PAR_DEVOBJ_STRUCT whose Controller field matches the Controller
      parameter. 

    If no match is found, then a new PAR_DEVOBJ_STRUCT that matches 
      is created, initialized (Controller field set, other fields
      initialized to NULL), and appended to the end of the list.

Arguments:

    DevObjStructHead - points to the head of the list to be searched
                     - NULL indicates that we should create an initial
                         element for the list

    Controller       - specifies the Controller that we should try to match

Return Value:

    PPAR_DEVOBJ_STRUCT - on success, points to a PAR_DEVOBJ_STRUCT whose 
                           Controller field matches the Controller parameter

    NULL               - insufficient resources failure (ExAllocatePool failed)

--*/
{ 
    PPAR_DEVOBJ_STRUCT current;
    PPAR_DEVOBJ_STRUCT previous;

    ParDump2(PARPNP1, ("rescan::ParFindCreateDevObjStruct - Enter\n"));

    //
    // If list is empty, create the initial element and return a pointer to it.
    //
    if( !DevObjStructHead ) {
        ParDump2(PARPNP1, ("rescan::ParFindCreateDevObjStruct - Empty List - Creating Initial Element - %x\n", Controller));
        current = ExAllocatePool(PagedPool, sizeof(PAR_DEVOBJ_STRUCT));
        if( !current ) {
            return NULL;        // insufficient resources
        }
        RtlZeroMemory(current, sizeof(PAR_DEVOBJ_STRUCT));
        current->Controller = Controller;
        return current;
    }

    //
    // list is not empty - scan for a matching Controller
    // 
    current = DevObjStructHead;
    while( current ) {
        if( current->Controller == Controller ) {
            break;              // found match, break out of loop
        }
        previous = current;     // not found, advance pointers to next element
        current  = current->Next;
    }

    //
    // did we find a match?
    //
    if( current ) {
        ParDump2(PARPNP1, ("rescan::ParFindCreateDevObjStruct - Found Match - %x\n", Controller));
        return current;         // we found a match, return pointer to it
    }

    //
    // we didn't find a match, create a new list item, append it to the list,
    //   and return a pointer to it
    //
    current = ExAllocatePool(PagedPool, sizeof(PAR_DEVOBJ_STRUCT));
    if( !current ) {
        return NULL;        // insufficient resources
    }
    RtlZeroMemory(current, sizeof(PAR_DEVOBJ_STRUCT));
    current->Controller = Controller;
    previous->Next      = current;
    ParDump2(PARPNP1, ("rescan::ParFindCreateDevObjStruct - Match not found - Creating New - %x\n", Controller));
    return current;
}

VOID
ParDestroyDevObjStructList(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead
    ) 
{
    PPAR_DEVOBJ_STRUCT current = DevObjStructHead;
    PPAR_DEVOBJ_STRUCT next;

    while( current ) {
        next = current->Next;
        ExFreePool( current );
        current = next;
    }
}

VOID 
ParDoParallelBusRescan(
    IN PPAR_DEVOBJ_STRUCT DevObjStructHead
    )
/*++

Routine Description:

    This routine rescans the parallel port "buses" for
      changes in the PnP devices connected to each parallel port.

Arguments:

    DevObjStructHead - points to a list of structures where each structure
                         contains info about a single parallel port

Return Value:

    None.

--*/
{
    PPAR_DEVOBJ_STRUCT currentNode = DevObjStructHead;
    PDEVICE_OBJECT     legacyPodo;
    PDEVICE_EXTENSION  legacyExt;
    NTSTATUS           status;
    LARGE_INTEGER      acquirePortTimeout;

    //
    // Process each parallel port (controller)
    //
    while( currentNode ) {

        legacyPodo = currentNode->LegacyPodo;
        if( NULL == legacyPodo ) {
            //
            // associated ParPort device object has been removed, so skip 
            //   processing of this PAR_DEVOBJ_STRUCT
            //
            ParDump2(PARPNP1, ("ParDoParallelBusRescan - NULL legacyPodo for Controller=%x"
                       " - skipping rescan of this port\n",
                       currentNode->Controller) );
            currentNode = currentNode->Next;
            continue;
        }

        legacyExt  = legacyPodo->DeviceExtension;

        //
        // Acquire the port from ParPort
        // 

        // timeout is in 100 ns units
        acquirePortTimeout.QuadPart = -(10 * 1000 * 1000 * 2); // 2 seconds

        status = ParAcquirePort(legacyExt->PortDeviceObject, &acquirePortTimeout);
        if( !NT_SUCCESS(status) ) {
            ParDump2(PARPNP1, ("ParDoParallelBusRescan - Unable to acquire port/"
                       "Controller=%x - skipping rescan of this port\n",
                       currentNode->Controller) );
            currentNode = currentNode->Next;
            continue;
        }

        //
        // Port is acquired
        //

        //
        // Rescan for change in End-Of-Chain Device
        //
        ParRescanEndOfChain( currentNode );

        //
        // Rescan for changes in 1284.3 Daisy Chain Devices
        // 
        // ParRescan1284_3DaisyChain(currentNode);
        dot3rescan( currentNode );

        //
        // Rescan for change in Legacy Zip Drive
        //
        {
            ULONG OldParEnableLegacyZipFlag = ParEnableLegacyZip;
            ParCheckEnableLegacyZipFlag();
            if( (OldParEnableLegacyZipFlag == 1) && (ParEnableLegacyZip == 0) ) {
                // We can handle enable ( 0 -> 1 ) without a reboot, but not disable ( 1 -> 0 )
                ParEnableLegacyZip = OldParEnableLegacyZipFlag;
            }
            ParRescanLegacyZip( currentNode );
        }

        //
        // Release the port back to ParPort
        //
        status = ParReleasePort( legacyExt->PortDeviceObject );
        if( !NT_SUCCESS(status) ) {
            ASSERTMSG("Unable to free port??? - this should never happen ", FALSE);
        }

        //
        // Advance pointer to next PAR_DEVOBJ_STRUCT
        //
        currentNode = currentNode->Next;

    } // end while
}

VOID
ParRescanEndOfChain(
    IN PPAR_DEVOBJ_STRUCT CurrentNode
    )
{
    PDEVICE_OBJECT    legacyPodo = CurrentNode->LegacyPodo;
    PDEVICE_EXTENSION legacyExt  = legacyPodo->DeviceExtension;
    PUCHAR            deviceId;
    ULONG             deviceIdLength;
    UCHAR             resultString[MAX_ID_SIZE];
    NTSTATUS          status;
    ULONG             deviceIdTryCount = 1;
    ULONG             maxIdTries       = 3;

        
    // Query for an End-Of-Chain 1284 device ID

retryDeviceIdQuery:

    deviceId = Par3QueryDeviceId(legacyExt, NULL, 0, &deviceIdLength, FALSE, FALSE);

    if( ( deviceId == NULL ) && ( deviceIdTryCount < maxIdTries ) ) {

        //
        // we didn't find a device - give any device that might be connected
        //   another chance to tell us that it is there
        //
        ParDump2(PARRESCAN, ("rescan::ParRescanEndOfChain - no EOC detected on "
                             "try %d - retrying 1284 id query\n", deviceIdTryCount) );
        ++deviceIdTryCount;
        KeStallExecutionProcessor(1); // allow the signals on the wires to stabilize
        goto retryDeviceIdQuery;

    }

    //
    // Done with retries, we either found a device or we did not.
    //

    if( !deviceId ) {

        //
        // We didn't find an EOC device
        //
        if( CurrentNode->EndOfChainPdo ) {
            //
            // we had a device but now it is gone - mark extension as "hardware gone"
            //
            ParDump2(PARRESCAN, ("rescan::ParRescanEndOfChain - EOC device went away\n"));
            ParMarkPdoHardwareGone(CurrentNode->EndOfChainPdo->DeviceExtension);
        } else {
            ParDump2(PARRESCAN, ("rescan::ParRescanEndOfChain - No end of chain device detected\n"));
        }

    } else {

        //
        // we found an EOC device
        //
        ParDump2(PARRESCAN, ("rescan::ParRescanEndOfChain - EOC device detected - tries required == %d\n",deviceIdTryCount));
        ParDump2(PARRESCAN, ("\"RAW\" ID string = <%s>\n", deviceId) );
        
        //
        // did we already have an EOC device?
        //
        if( CurrentNode->EndOfChainPdo ) {
            //
            // we already had an EOC device - compare its ID from its extension 
            //   with the ID we just read from the hardware
            //
            PDEVICE_EXTENSION endOfChainExt = CurrentNode->EndOfChainPdo->DeviceExtension;
            
            //
            // massage the ID read from the hardware into the form needed for compare
            //
            RtlZeroMemory(resultString, MAX_ID_SIZE);
            status = ParPnpGetId(deviceId, BusQueryDeviceID, resultString, NULL);
            if( NT_SUCCESS(status) ) {
                //
                // massage succeeded - do compare
                //
                if(0 == strcmp(endOfChainExt->DeviceIdString, resultString)) {
                    //
                    // id matches - we found the same device we previously found
                    //
                } else {
                    //
                    // id differs - we have different device that we previously had
                    //
                    // mark previous device extension as "hardware gone"
                    //
                    ParMarkPdoHardwareGone(CurrentNode->EndOfChainPdo->DeviceExtension);
                    
                    //
                    // create device object for new device and add it to FDO's list
                    //
                    ParDetectCreateEndOfChainPdo(legacyPodo);
                } 
            } else {
                // massage failed - unable to extract valid ID
                
                // mark previous extension as "hardware gone"
                ParMarkPdoHardwareGone(CurrentNode->EndOfChainPdo->DeviceExtension);
            }
        } else {
            // we didn't have an EOC device on previous scan, but ID detected on this scan
            
            // create device object for new device and add it to FDO's list
            ParDetectCreateEndOfChainPdo(legacyPodo);
        }
        ExFreePool( deviceId );

    } // end if/else ( !deviceId ) - end of chain device rescan complete for this port
}

#if 0 
VOID
ParRescan1284_3DaisyChain(
    IN PPAR_DEVOBJ_STRUCT CurrentNode
    )
{
    PDEVICE_OBJECT    legacyPodo       = CurrentNode->LegacyPodo;
    PDEVICE_EXTENSION legacyExt        = legacyPodo->DeviceExtension;
    PDEVICE_OBJECT    portDeviceObject = legacyExt->PortDeviceObject;
    PDEVICE_OBJECT    currentDeviceObject;
    UCHAR             newDot3DeviceCount;
    NTSTATUS          status;
    UCHAR             idx;
    UCHAR             oldDot3DeviceCount;
    PUCHAR            deviceId;
    ULONG             deviceIdLength;
    UCHAR             tempIdBuffer[MAX_ID_SIZE];
    PCHAR             deviceIdArray[IEEE_1284_3_DAISY_CHAIN_MAX_ID+1] = {NULL,NULL,NULL,NULL};
    BOOLEAN           chainWasBroken;
    UCHAR             firstDeviceGone;
  
    ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - Enter\n") );

    //
    // Count the number of .3 daisy chain devices we had on last scan
    //   of this port
    //
    idx = 0;
    while( NULL != *( (&CurrentNode->Dot3Id0Pdo) + idx ) ) {
        ++idx;
    }
    oldDot3DeviceCount = idx;
    ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - Dot3 DeviceCount Before Rescan = %d\n", idx) );


    //
    // Walk the daisy chain and verify that each device is still here
    //
    chainWasBroken = FALSE;
    idx=0;
    while( idx < oldDot3DeviceCount ) {
        PDEVICE_OBJECT    curDevObj = *( (&CurrentNode->Dot3Id0Pdo) + idx );
        PDEVICE_EXTENSION curDevExt = curDevObj->DeviceExtension;
        if( ParDeviceExists( curDevExt, HAVE_PORT_KEEP_PORT ) ) {
            ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - Dot3 device %d still there\n", idx) );            
            ++idx;
        } else {
            ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - Dot3 device %d GONE - chain broken\n", idx) );
            chainWasBroken=TRUE;
            firstDeviceGone = idx;
            break;
        }
    }

    //
    // If chain was broken, nuke PDO for missing device and for all 
    //   .3 daisy chain devices connected beyond that device in 
    //   the daisy chain.
    //
    if( chainWasBroken ) {
        for( idx = firstDeviceGone ; idx < oldDot3DeviceCount ; ++idx ) {
            PDEVICE_OBJECT    curDevObj = *( (&CurrentNode->Dot3Id0Pdo) + idx );
            PDEVICE_EXTENSION curDevExt = curDevObj->DeviceExtension;
            ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - Nuking DevObj= %x , idx=%d\n", curDevObj, idx) );
            ParMarkPdoHardwareGone( curDevExt );
            *( (&CurrentNode->Dot3Id0Pdo) + idx ) = NULL;            
            --oldDot3DeviceCount;
        }
        ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - Dot3 DeviceCount - post-Nuking= %d\n", oldDot3DeviceCount) );
    }

    //
    // Step through the list of Dot3 device objects associated with
    //   this port, read the device ID from the corresponding device and
    //   compare with the ID stored in the device extension. Mark any
    //   device extension whose device doesn't answer the query or
    //   answers the query with a different ID than the one in the
    //   extension as "hardware gone".
    //


    //
    // Reinitialize 1284.3 daisy chain device IDs
    // 
    ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - reinitializing Dot3 bus\n") );
    status = ParInit1284_3Bus(portDeviceObject);
    if( !NT_SUCCESS(status) ) {
        ASSERT(FALSE); // this should never happen
        return;
    }
    

    //
    // Get count of 1284.3 daisy chain devices connected to port
    // 
    newDot3DeviceCount = ParGet1284_3DeviceCount(legacyExt->PortDeviceObject);
    ParDump2(PARPNP1, ("rescan::ParRescan1284_3DaisyChain - newDot3DeviceCount = %d\n", newDot3DeviceCount) );


    //
    // scan for 1284.3 daisy chain changes
    //
    for(idx = 0 ; idx <= IEEE_1284_3_DAISY_CHAIN_MAX_ID ; ++idx) {
        // get a pointer to the existing 1284.3 dc device object, if any
        PDEVICE_OBJECT devObj = *( (&CurrentNode->Dot3Id0Pdo) + idx );        
        PDEVICE_EXTENSION devExt;
        
        if( (devObj == NULL) && ( idx >= newDot3DeviceCount ) ) {

            // no device object, no device, done, exit loop early
            ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - idx = %d, no DO - no device - exit loop early\n",idx) );
            break;

        } else if( (devObj == NULL) && ( idx < newDot3DeviceCount ) ) {

            //
            // no device object, but we have a device
            //  - create new device object
            //
            ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - idx = %d, no DO - have device - create device\n",idx) );
            {
                PDEVICE_OBJECT newPdo;

                ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - selecting idx = %d\n",idx) );
                status = ParSelect1284_3Device(legacyExt->PortDeviceObject, idx);

                if( NT_SUCCESS( status ) ) {
                    ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - select succeeded on idx=%d\n",idx) );                    
                    ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - creating PDO for idx=%d\n",idx) );                    
                    newPdo = ParDetectCreatePdo(legacyPodo, idx);
                    // add to FDO list
                    if( newPdo ) {
                        ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - PDO %x created for idx=%d\n", newPdo, idx) );
                        ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - adding new Dot3 PDO to FDO list\n") );
                        ParAddDevObjToFdoList(newPdo);
                    } else {
                        ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - create of PDO for idx=%d FAILED\n", idx) );
                    }
                    ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - deselecting idx = %d\n",idx) );
                    status = ParDeselect1284_3Device(legacyExt->PortDeviceObject, idx);
                    if( !NT_SUCCESS( status ) ) {
                        ASSERTMSG("DESELECT FAILED??? - This should never happen ", FALSE);
                    }
                } else {
                    ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - select FAILED on idx=%d\n",idx) );                    
                }
            }

        } else if( (devObj != NULL) && ( idx >= newDot3DeviceCount ) ) {

            //
            // have a device object, but no device - this should not happen
            //   because we should have cleaned up in the code above
            //
            ASSERT(FALSE);

        } else if( (devObj != NULL) && ( idx < newDot3DeviceCount ) ) {

            // have a device object and a device
            devExt = devObj->DeviceExtension;

            //  - compare ID's between device object and device
            ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - idx = %d, have DO - have device - compare id's\n",idx) );

            // do 1284.3 selection to select the device 
            status = ParSelect1284_3Device(portDeviceObject, idx);
            if( NT_SUCCESS( status ) ) {

                // device selected
                
                // query ID from device
                deviceId = Par3QueryDeviceId(legacyExt, NULL, 0, &deviceIdLength, FALSE);

                // deselect the 1284.3 dc device
                status = ParDeselect1284_3Device(portDeviceObject, idx);
                if( !NT_SUCCESS(status) ) {
                    // deselect should not fail, however not much we can do except complain if it does
                    ParDump2(PARERRORS, ("rescan::ParRescan1284_3DaisyChain - call to ParDeselect1284_3Device() FAILED\n") );
                }

                // did we get a device id from the hardware?
                if( deviceId ) {

                    // massage deviceId into format saved in extension
                    RtlZeroMemory(tempIdBuffer, sizeof(tempIdBuffer));
                
                    status = ParPnpGetId(deviceId, BusQueryDeviceID, tempIdBuffer, NULL);
                    if( !NT_SUCCESS(status) ) {
                        // RMT - don't bother to compare
                        sprintf(tempIdBuffer, "rescan::ParRescan1284_3DaisyChain - ParPnpGetId Failed - don't compare\0");
                    }

                    // got a device id from hardware - do compare
                    ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - device id = <%s>\n", tempIdBuffer) );
                    ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - ext    id = <%s>\n", devExt->DeviceIdString) );

                    devExt = devObj->DeviceExtension;
                    if( strcmp(tempIdBuffer, devExt->DeviceIdString) == 0 ) {
                        // match - do nothing - device is same that was there before rescan
                        ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - MATCH - KEEP device, idx=%d\n", idx) );
                    } else {
                        PDEVICE_OBJECT newPdo;
                        // no match
                        ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - "
                                           "NO MATCH - mark hardware gone and create new device, idx = %d\n", idx) );
                        //  - mark device object as hardware gone
                        devExt = devObj->DeviceExtension;
                        ParMarkPdoHardwareGone( devExt );
                        
                        // - create device object for new device
                        newPdo = ParDetectCreatePdo(legacyPodo, idx);

                        // add to FDO list
                        if( newPdo ) {
                            ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - adding new Dot3 PDO to FDO list\n") );
                            ParAddDevObjToFdoList(newPdo);
                        }
                    }
                    // done with temp ID string
                    ExFreePool( deviceId );

                } else {

                    // unable to read device id
                    ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - didn't get device id, idx=%d\n", idx) );

                    //  - mark device object as hardware gone
                    devExt = devObj->DeviceExtension;
                    ParMarkPdoHardwareGone( devExt );
                }

            } else {

                // unable to select device
                ParDump2(PARPNP2, ("rescan::ParRescan1284_3DaisyChain - unable to select device, idx=%d\n", idx) );

                //  - mark device object as hardware gone
                devExt = devObj->DeviceExtension;
                ParMarkPdoHardwareGone( devExt );

            }

        }  // end if have a device object and a device

    } // end for(idx = 0 ; ...)

}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\spp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    spp.c

Abstract:

    This module contains the code for standard parallel ports
    (centronics mode).

Author:

    Anthony V. Ercolano 1-Aug-1992
    Norbert P. Kusters 22-Oct-1993

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    );
    
ULONG
SppCheckBusyDelay(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    );

NTSTATUS
SppWrite(
    IN  PDEVICE_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    );

NTSTATUS
SppQueryDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PUCHAR              DeviceIdBuffer,
    IN  ULONG               BufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    );
    
NTSTATUS
ParEnterSppMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )
{
    ParDump2(PARENTRY, ( "ParEnterSppMode: Enter!\r\n" ));
    Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    Extension->Connected = TRUE;	
    return STATUS_SUCCESS;
}

ULONG
SppWriteLoopPI(
    IN  PUCHAR  Controller,
    IN  PUCHAR  WriteBuffer,
    IN  ULONG   NumBytesToWrite,
    IN  ULONG   BusyDelay
    )

/*++

Routine Description:

    This routine outputs the given write buffer to the parallel port
    using the standard centronics protocol.

Arguments:

    Controller  - Supplies the base address of the parallel port.

    WriteBuffer - Supplies the buffer to write to the port.

    NumBytesToWrite - Supplies the number of bytes to write out to the port.

    BusyDelay   - Supplies the number of microseconds to delay before
                    checking the busy bit.

Return Value:

    The number of bytes successfully written out to the parallel port.

--*/

{
    ULONG   i;
    UCHAR   DeviceStatus;
    BOOLEAN atPassiveIrql = FALSE;
    LARGE_INTEGER sppLoopDelay;

    sppLoopDelay.QuadPart   = -(LONG)(gSppLoopDelay);    // in 100ns units

    if( KeGetCurrentIrql() == PASSIVE_LEVEL ) {
        atPassiveIrql = TRUE;
    }

    ParDump2(PARENTRY, ("spp::SppWriteLoopPI - Enter\n") );
                    
    if (!BusyDelay) {
        BusyDelay = 1;
    }

    for (i = 0; i < NumBytesToWrite; i++) {

        DeviceStatus = GetStatus(Controller);

        if (PAR_ONLINE(DeviceStatus)) {

            //
            // Anytime we write out a character we will restart
            // the count down timer.
            //

            WRITE_PORT_UCHAR(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);

            KeStallExecutionProcessor(1);

            StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                      PAR_CONTROL_SLIN |
                                      PAR_CONTROL_NOT_INIT |
                                      PAR_CONTROL_STROBE));

            KeStallExecutionProcessor(1);

            StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                      PAR_CONTROL_SLIN |
                                      PAR_CONTROL_NOT_INIT));

            KeStallExecutionProcessor(BusyDelay);

        } else {
            ParDump2(PARINFO, ("spp::SppWriteLoopPI - DeviceStatus = %x - NOT ONLINE\n", DeviceStatus) );
            break;
        }

        //
        // Try to reduce CPU util by parallel?
        //
        if( gSppLoopDelay && gSppLoopBytesPerDelay && atPassiveIrql && (i != 0) && !(i % gSppLoopBytesPerDelay) ) {
            // every SppLoopBytesPerDelay bytes - sleep to let other threads run
            KeDelayExecutionThread(KernelMode, FALSE, &sppLoopDelay);
        }

    }

    ParDump2(PAREXIT, ("Leaving SppWriteLoopPI(...): Bytes Written = %ld\n", i) );

    return i;
}

ULONG
SppCheckBusyDelay(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PUCHAR              WriteBuffer,
    IN  ULONG               NumBytesToWrite
    )

/*++

Routine Description:

    This routine determines if the current busy delay setting is
    adequate for this printer.

Arguments:

    Extension       - Supplies the device extension.

    WriteBuffer     - Supplies the write buffer.

    NumBytesToWrite - Supplies the size of the write buffer.

Return Value:

    The number of bytes strobed out to the printer.

--*/

{
    PUCHAR          Controller;
    ULONG           BusyDelay;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   PerfFreq;
    LARGE_INTEGER   End;
    LARGE_INTEGER   GetStatusTime;
    LARGE_INTEGER   CallOverhead;
    UCHAR           DeviceStatus;
    ULONG           i;
    ULONG           NumberOfCalls;
    ULONG           maxTries;
    #if (0 == DVRH_RAISE_IRQL)
        KIRQL           OldIrql;
    #endif

    // ParDumpV( ("Enter SppCheckBusyDelay(...): NumBytesToWrite = %d\n", NumBytesToWrite) );
                    
    Controller = Extension->Controller;
    BusyDelay  = Extension->BusyDelay;
    
    // If the current busy delay value is 10 or greater then something
    // is weird and settle for 10.

    if (Extension->BusyDelay >= 10) {
        Extension->BusyDelayDetermined = TRUE;
        return 0;
    }

    // Take some performance measurements.

    #if (0 == DVRH_RAISE_IRQL)
        if (0 == SppNoRaiseIrql)
            KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    #endif

    Start = KeQueryPerformanceCounter(&PerfFreq);
    
    DeviceStatus = GetStatus(Controller);
    
    End = KeQueryPerformanceCounter(&PerfFreq);
    
    GetStatusTime.QuadPart = End.QuadPart - Start.QuadPart;

    Start = KeQueryPerformanceCounter(&PerfFreq);
    End   = KeQueryPerformanceCounter(&PerfFreq);
    
    #if (0 == DVRH_RAISE_IRQL)
        if (0 == SppNoRaiseIrql)
            KeLowerIrql(OldIrql);
    #endif

    CallOverhead.QuadPart = End.QuadPart - Start.QuadPart;
    
    GetStatusTime.QuadPart -= CallOverhead.QuadPart;
    
    if (GetStatusTime.QuadPart <= 0) {
        GetStatusTime.QuadPart = 1;
    }

    // Figure out how many calls to 'GetStatus' can be made in 20 us.

    NumberOfCalls = (ULONG) (PerfFreq.QuadPart*20/GetStatusTime.QuadPart/1000000) + 1;

    //
    // - check to make sure the device is ready to receive a byte before we start clocking
    //    data out
    // 
    // DVDF - 25Jan99 - added check
    // 

    //
    // - nothing magic about 25 - just catch the case where NumberOfCalls may be bogus
    //    and try something reasonable - empirically NumberOfCalls has ranged from 8-24
    //
    maxTries = (NumberOfCalls > 25) ? 25 : NumberOfCalls;

    for( i = 0 ; i < maxTries ; i++ ) {
        // spin for slow device to get ready to receive data - roughly 20us max
        DeviceStatus = GetStatus( Controller );
        if( PAR_ONLINE( DeviceStatus ) ) {
            // break out of loop as soon as device is ready
            break;
        }
    }
    if( !PAR_ONLINE( DeviceStatus ) ) {
        // device is still not online - bail out
        return 0;
    }

    // The printer is ready to accept a byte.  Strobe one out
    // and check out the reaction time for BUSY.

    if (BusyDelay) {

        #if (0 == DVRH_RAISE_IRQL)
            if (0 == SppNoRaiseIrql)
                KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
        #endif

        WRITE_PORT_UCHAR(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT |
                                  PAR_CONTROL_STROBE));
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT));
        KeStallExecutionProcessor(BusyDelay);

        for (i = 0; i < NumberOfCalls; i++) {
            DeviceStatus = GetStatus(Controller);
            if (!(DeviceStatus & PAR_STATUS_NOT_BUSY)) {
                break;
            }
        }

        #if (0 == DVRH_RAISE_IRQL)
            if (0 == SppNoRaiseIrql)
                KeLowerIrql(OldIrql);
        #endif

    } else {

        #if (0 == DVRH_RAISE_IRQL)
            if (0 == SppNoRaiseIrql)
                KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
        #endif

        WRITE_PORT_UCHAR(Controller + PARALLEL_DATA_OFFSET, *WriteBuffer++);
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT |
                                  PAR_CONTROL_STROBE));
        KeStallExecutionProcessor(1);
        StoreControl(Controller, (PAR_CONTROL_WR_CONTROL |
                                  PAR_CONTROL_SLIN |
                                  PAR_CONTROL_NOT_INIT));

        for (i = 0; i < NumberOfCalls; i++) {
            DeviceStatus = GetStatus(Controller);
            if (!(DeviceStatus & PAR_STATUS_NOT_BUSY)) {
                break;
            }
        }

        #if (0 == DVRH_RAISE_IRQL)
            if (0 == SppNoRaiseIrql)
                KeLowerIrql(OldIrql);
        #endif
    }

    if (i == 0) {

        // In this case the BUSY was set as soon as we checked it.
        // Use this busyDelay with the PI code.

        Extension->UsePIWriteLoop = TRUE;
        Extension->BusyDelayDetermined = TRUE;

    } else if (i == NumberOfCalls) {

        // In this case the BUSY was never seen.  This is a very fast
        // printer so use the fastest code possible.

        Extension->BusyDelayDetermined = TRUE;

    } else {

        // The test failed.  The lines showed not BUSY and then BUSY
        // without strobing a byte in between.

        Extension->UsePIWriteLoop = TRUE;
        Extension->BusyDelay++;
    }

    return 1;
}

NTSTATUS
SppWrite(
    IN  PDEVICE_EXTENSION Extension,
    IN  PVOID             Buffer,
    IN  ULONG             BytesToWrite,
    OUT PULONG            BytesTransferred
    )

/*++

Routine Description:

Arguments:

    Extension   - Supplies the device extension.

Return Value:

    None.

--*/
{
    NTSTATUS            status;
    UCHAR               DeviceStatus;
    ULONG               TimerStart;
    LONG                CountDown;
    PUCHAR              IrpBuffer;
    LARGE_INTEGER       StartOfSpin;
    LARGE_INTEGER       NextQuery;
    LARGE_INTEGER       Difference;
    BOOLEAN             DoDelays;
    BOOLEAN             PortFree;
    ULONG               NumBytesWritten; 
    ULONG               LoopNumber;
    ULONG               NumberOfBusyChecks;
    ULONG               MaxBusyDelay;
    ULONG               MaxBytes;
    
    ParDump2(PARINFO, ("Enter SppWrite(...): %wZ, BytesToWrite = %d\n", &Extension->SymbolicLinkName, BytesToWrite) );

    IrpBuffer  = (PUCHAR)Buffer;
    MaxBytes   = BytesToWrite;
    TimerStart = Extension->TimerStart;
    CountDown  = (LONG)TimerStart;
    
    NumberOfBusyChecks = 9;
    MaxBusyDelay = 0;
    
    ParGetDriverParameterDword( &RegistryPath, (PWSTR)L"SppLoopDelay",  &gSppLoopDelay );
    // 0==feature disabled, otherwise min==1 (100ns), max==10000 (1ms)
    if( gSppLoopDelay > 10000 ) {
        gSppLoopDelay = 10000;
    }

    ParGetDriverParameterDword( &RegistryPath, (PWSTR)L"SppLoopBytesPerDelay",  &gSppLoopBytesPerDelay );
    // 0==feature disabled, otherwise min==32, max==4096
    if( gSppLoopBytesPerDelay ) {
        if( gSppLoopBytesPerDelay < 32 ) {
            gSppLoopBytesPerDelay = 32;
        } else if( gSppLoopBytesPerDelay > 4096 ) {
            gSppLoopBytesPerDelay = 4096;
        }
    }

#if DBG
    // RMT - remove following line - inserted only for testing to reduce timeout
    // TimerStart = 10;
#endif


    // ParDumpV( ("TimerStart is: %d\n", TimerStart) );

    // Turn off the strobe in case it was left on by some other device sharing
    // the port.
    
    StoreControl(Extension->Controller, (PAR_CONTROL_WR_CONTROL |
                                         PAR_CONTROL_SLIN |
                                         PAR_CONTROL_NOT_INIT));

PushSomeBytes:

    //
    // While we are strobing data we don't want to get context
    // switched away.  Raise up to dispatch level to prevent that.
    //
    // The reason we can't afford the context switch is that
    // the device can't have the data strobe line on for more
    // than 500 microseconds.
    //
    // We never want to be at raised irql form more than
    // 200 microseconds, so we will do no more than 100
    // bytes at a time.
    //

    LoopNumber = 512;
    if (LoopNumber > BytesToWrite) {
        LoopNumber = BytesToWrite;
    }

    //
    // Enter the write loop
    //
    
    if (!Extension->BusyDelayDetermined) {
        ParDump2(PARINFO, ("SppWrite: Calling SppCheckBusyDelay\n"));
        NumBytesWritten = SppCheckBusyDelay(Extension, IrpBuffer, LoopNumber);
        
        if (Extension->BusyDelayDetermined) {
        
            if (Extension->BusyDelay > MaxBusyDelay) {
                MaxBusyDelay = Extension->BusyDelay;
                NumberOfBusyChecks = 10;
            }
            
            if (NumberOfBusyChecks) {
                NumberOfBusyChecks--;
                Extension->BusyDelayDetermined = FALSE;
                
            } else {
            
                Extension->BusyDelay = MaxBusyDelay + 1;
            }
        }
        
    } else if (Extension->UsePIWriteLoop) {
    
        NumBytesWritten = SppWriteLoopPI(Extension->Controller, 
                                         IrpBuffer,
                                         LoopNumber, 
                                         Extension->BusyDelay);
    } else {
    
        NumBytesWritten = SppWriteLoop(Extension->Controller, 
                                       IrpBuffer,
                                       LoopNumber);
    }


    if (NumBytesWritten) {
    
        CountDown     = TimerStart;
        IrpBuffer    += NumBytesWritten;
        BytesToWrite -= NumBytesWritten;
        
    }

    //
    // Check to see if the io is done.  If it is then call the
    // code to complete the request.
    //

    if (!BytesToWrite) {
    
        *BytesTransferred = MaxBytes;

        status = STATUS_SUCCESS;
        goto returnTarget;

    } else if ((Extension->CurrentOpIrp)->Cancel) {

        //
        // See if the IO has been canceled.  The cancel routine
        // has been removed already (when this became the
        // current irp).  Simply check the bit.  We don't even
        // need to capture the lock.   If we miss a round
        // it won't be that bad.
        //

        *BytesTransferred = MaxBytes - BytesToWrite;

        status = STATUS_CANCELLED;
        goto returnTarget;

    } else {

        //
        // We've taken care of the reasons that the irp "itself"
        // might want to be completed.
        // printer to see if it is in a state that might
        // cause us to complete the irp.
        //
        // First let's check if the device status is
        // ok and online.  If it is then simply go back
        // to the byte pusher.
        //


        DeviceStatus = GetStatus(Extension->Controller);

        if (PAR_ONLINE(DeviceStatus)) {
            ParDump2(PARINFO, ("SppWrite: We are online.  Push more bytes.\n"));
            goto PushSomeBytes;
        }

        //
        // Perhaps the operator took the device off line,
        // or forgot to put in enough paper.  If so, then
        // let's hang out here for the until the timeout
        // period has expired waiting for them to make things
        // all better.
        //

        if (PAR_PAPER_EMPTY(DeviceStatus) ||
            PAR_OFF_LINE(DeviceStatus)) {

            if (CountDown > 0) {

                //
                // We'll wait 1 second increments.
                //

                ParDump(PARTHREAD | PARDUMP_VERBOSE_MAX,
                        ("PARALLEL: "
                         "decrementing countdown for PAPER_EMPTY/OFF_LINE - "
                         "countDown: %d status: 0x%x\n",
                         CountDown, DeviceStatus) );
                    
                CountDown--;

                // If anyone is waiting for the port then let them have it,
                // since the printer is busy.

                ParFreePort(Extension);

                KeDelayExecutionThread(
                    KernelMode,
                    FALSE,
                    &Extension->OneSecond
                    );

                if (!ParAllocPort(Extension)) {
                
                    *BytesTransferred = MaxBytes - BytesToWrite;

                    ParDump(PARDUMP_VERBOSE_MAX,
                            ("PARALLEL: "
                             "In SppWrite(...): returning STATUS_DEVICE_BUSY\n") );
                    
                    status = STATUS_DEVICE_BUSY;
                    goto returnTarget;
                }

                goto PushSomeBytes;

            } else {

                //
                // Timer has expired.  Complete the request.
                //

                *BytesTransferred = MaxBytes - BytesToWrite;
                                                
                ParDump(PARTHREAD | PARDUMP_VERBOSE_MAX,
                        ("PARALLEL: "
                         "In SppWrite(...): Timer expired - "
                         "DeviceStatus = %08x\n",
                         DeviceStatus) );

                if (PAR_OFF_LINE(DeviceStatus)) {

                    ParDump(PARDUMP_VERBOSE_MAX,
                            ("PARALLEL: "
                             "In SppWrite(...): returning STATUS_DEVICE_OFF_LINE\n") );

                    status = STATUS_DEVICE_OFF_LINE;
                    goto returnTarget;
                    
                } else if (PAR_NO_CABLE(DeviceStatus)) {

                    ParDump(PARDUMP_VERBOSE_MAX,
                            ("PARALLEL: "
                             "In SppWrite(...): returning STATUS_DEVICE_NOT_CONNECTED\n") );

                    status = STATUS_DEVICE_NOT_CONNECTED;
                    goto returnTarget;

                } else {

                    ParDump(PARDUMP_VERBOSE_MAX,
                            ("PARALLEL: "
                             "In SppWrite(...): returning STATUS_DEVICE_PAPER_EMPTY\n") );

                    status = STATUS_DEVICE_PAPER_EMPTY;
                    goto returnTarget;

                }
            }


        } else if (PAR_POWERED_OFF(DeviceStatus) ||
                   PAR_NOT_CONNECTED(DeviceStatus) ||
                   PAR_NO_CABLE(DeviceStatus)) {

            //
            // We are in a "bad" state.  Is what
            // happened to the printer (power off, not connected, or
            // the cable being pulled) something that will require us
            // to reinitialize the printer?  If we need to
            // reinitialize the printer then we should complete
            // this IO so that the driving application can
            // choose what is the best thing to do about it's
            // io.
            //

            ParDumpV( ("In SppWrite(...): \"bad\" state - need to reinitialize printer?") );

            *BytesTransferred = MaxBytes - BytesToWrite;
                        
            if (PAR_POWERED_OFF(DeviceStatus)) {

                ParDump(PARDUMP_VERBOSE_MAX,
                        ("PARALLEL: "
                         "In SppWrite(...): returning STATUS_DEVICE_POWERED_OFF\n") );

                status = STATUS_DEVICE_POWERED_OFF;
                goto returnTarget;
                
            } else if (PAR_NOT_CONNECTED(DeviceStatus) ||
                       PAR_NO_CABLE(DeviceStatus)) {

                ParDump(PARDUMP_VERBOSE_MAX,
                        ("PARALLEL: "
                         "In SppWrite(...): returning STATUS_DEVICE_NOT_CONNECTED\n") );

                status = STATUS_DEVICE_NOT_CONNECTED;
                goto returnTarget;

            }
        }

        //
        // The device could simply be busy at this point.  Simply spin
        // here waiting for the device to be in a state that we
        // care about.
        //
        // As we spin, get the system ticks.  Every time that it looks
        // like a second has passed, decrement the countdown.  If
        // it ever goes to zero, then timeout the request.
        //

        KeQueryTickCount(&StartOfSpin);
        DoDelays = FALSE;
        
        do {

            //
            // After about a second of spinning, let the rest of the
            // machine have time for a second.
            //

            if (DoDelays) {

                ParFreePort(Extension);
                PortFree = TRUE;

                ParDump2(PARINFO,
                        ("Before delay thread of one second, dsr=%x DCR[%x]\n",
                         READ_PORT_UCHAR(Extension->Controller + OFFSET_DSR),
                         READ_PORT_UCHAR(Extension->Controller + OFFSET_DCR)) );
                KeDelayExecutionThread(KernelMode, FALSE, &Extension->OneSecond);

                ParDump2(PARINITDEV,
                        ("Did delay thread of one second, CountDown=%d\n",
                         CountDown) );

                CountDown--;

            } else {

                if (Extension->QueryNumWaiters(Extension->PortContext)) {
                
                    ParFreePort(Extension);
                    PortFree = TRUE;
                    
                } else {
                
                    PortFree = FALSE;
                }

                KeQueryTickCount(&NextQuery);

                Difference.QuadPart = NextQuery.QuadPart - StartOfSpin.QuadPart;

                if (Difference.QuadPart*KeQueryTimeIncrement() >=
                    Extension->AbsoluteOneSecond.QuadPart) {

                    ParDump(PARTHREAD | PARDUMP_VERBOSE_MAX,
                            ("PARALLEL: "
                             "Countdown: %d - device Status: "
                             "%x lowpart: %x highpart: %x\n",
                             CountDown, 
                             DeviceStatus, 
                             Difference.LowPart,
                             Difference.HighPart) );
                        
                    CountDown--;
                    DoDelays = TRUE;

                }
            }

            if (CountDown <= 0) {
            
                *BytesTransferred = MaxBytes - BytesToWrite;
                status = STATUS_DEVICE_BUSY;
                goto returnTarget;

            }

            if (PortFree && !ParAllocPort(Extension)) {
            
                *BytesTransferred = MaxBytes - BytesToWrite;
                status = STATUS_DEVICE_BUSY;
                goto returnTarget;
            }

            DeviceStatus = GetStatus(Extension->Controller);

        } while ((!PAR_ONLINE(DeviceStatus)) &&
                 (!PAR_PAPER_EMPTY(DeviceStatus)) &&
                 (!PAR_POWERED_OFF(DeviceStatus)) &&
                 (!PAR_NOT_CONNECTED(DeviceStatus)) &&
                 (!PAR_NO_CABLE(DeviceStatus)) &&
                  !(Extension->CurrentOpIrp)->Cancel);

        if (CountDown != (LONG)TimerStart) {

            ParDump(PARTHREAD | PARDUMP_VERBOSE_MAX,
                    ("PARALLEL: "
                     "Leaving busy loop - countdown %d status %x\n",
                     CountDown, DeviceStatus) );

        }
        
        goto PushSomeBytes;

    }

returnTarget:
    // added single return point so we can save log of bytes transferred
    Extension->log.SppWriteCount += *BytesTransferred;
    return status;

}

NTSTATUS
SppQueryDeviceId(
    IN  PDEVICE_EXTENSION   Extension,
    OUT PUCHAR              DeviceIdBuffer,
    IN  ULONG               BufferSize,
    OUT PULONG              DeviceIdSize,
    IN BOOLEAN              bReturnRawString
    )
/*++

Routine Description:

    This routine is now a wrapper function around Par3QueryDeviceId that
      preserves the interface of the original SppQueryDeviceId function.

    Clients of this function should consider switching to Par3QueryDeviceId
      if possible because Par3QueryDeviceId will allocate and return a pointer
      to a buffer if the caller supplied buffer is too small to hold the 
      device ID.
    
Arguments:

    Extension         - DeviceExtension/Legacy - used to get controller.
    DeviceIdBuffer    - Buffer used to return ID.
    BufferSize        - Size of supplied buffer.
    DeviceIdSize      - Size of returned ID.
    bReturnRawString  - Should the 2 byte size prefix be included? (TRUE==Yes)

Return Value:

    STATUS_SUCCESS          - ID query was successful
    STATUS_BUFFER_TOO_SMALL - We were able to read an ID from the device but the caller
                                supplied buffer was not large enough to hold the ID. The
                                size required to hold the ID is returned in DeviceIdSize.
    STATUS_UNSUCCESSFUL     - ID query failed - Possibly interface or device is hung, missed
                                timeouts during the handshake, or device may not be connected.

--*/
{
    PCHAR idBuffer;

    ParDumpV(("spp::SppQueryDeviceId: Enter - buffersize=%d\n", BufferSize));
    if ( Extension->Ieee1284Flags & ( 1 << Extension->Ieee1284_3DeviceId ) ) {
        idBuffer = Par3QueryDeviceId( Extension, DeviceIdBuffer, BufferSize, DeviceIdSize, bReturnRawString, TRUE );
    }
    else {
        idBuffer = Par3QueryDeviceId( Extension, DeviceIdBuffer, BufferSize, DeviceIdSize, bReturnRawString, FALSE );
    }

    if( idBuffer == NULL ) {
        //
        // Error at lower level - FAIL query
        //
        ParDumpV( ("spp::SppQueryDeviceId: call to Par3QueryDeviceId hard FAIL\n") );
        return STATUS_UNSUCCESSFUL;
    } else if( idBuffer != DeviceIdBuffer ) {
        //
        // We got a deviceId from the device, but caller's buffer was too small to hold it.
        //   Free the buffer and tell the caller that the supplied buffer was too small.
        //
        ParDumpV( ("spp::SppQueryDeviceId: buffer too small - have buffer size=%d, need buffer size=%d\n", 
                   BufferSize, *DeviceIdSize) );
        ExFreePool( idBuffer );
        return STATUS_BUFFER_TOO_SMALL;
    } else {
        //
        // Query succeeded using caller's buffer (idBuffer == DeviceIdBuffer)
        //
        ParDumpV( ("spp::SppQueryDeviceId: SUCCESS - deviceId=<%s>\n", idBuffer) );
        return STATUS_SUCCESS;
    }
}

VOID
ParTerminateSppMode(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    ParDump2(PARENTRY, ( "ParTerminateSppMode: Enter!\r\n" ));
    Extension->Connected = FALSE;
    Extension->CurrentPhase = PHASE_TERMINATE;
    return;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\swecp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    swecp.c

Abstract:

    Enhanced Capabilities Port (ECP)
    
    This module contains the code to perform all ECP related tasks (including
    ECP Software and ECP Hardware modes.)

Author:

    Tim Wells (WESTTEK) - April 16, 1997

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
#include "ecp.h"

BOOLEAN
ParIsEcpSwWriteSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
BOOLEAN
ParIsEcpSwReadSupported(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEnterEcpSwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    );
    
VOID 
ParCleanupSwEcpPort(
    IN  PDEVICE_EXTENSION   Extension
    );
    
VOID
ParTerminateEcpMode(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEcpSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    );
    
NTSTATUS
ParEcpSwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEcpSwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    );
    
NTSTATUS
ParEcpForwardToReverse(
    IN  PDEVICE_EXTENSION   Extension
    );
    
NTSTATUS
ParEcpReverseToForward(
    IN  PDEVICE_EXTENSION   Extension
    );



BOOLEAN
ParIsEcpSwWriteSupported(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (Extension->BadProtocolModes & ECP_SW)
        return FALSE;

    if (Extension->ProtocolModesSupported & ECP_SW)
        return TRUE;

    Status = ParEnterEcpSwMode (Extension, FALSE);
    ParTerminateEcpMode (Extension);
    
    if (NT_SUCCESS(Status)) {
    
        Extension->ProtocolModesSupported |= ECP_SW;
        return TRUE;
    }
    
    return FALSE;
    
}

BOOLEAN
ParIsEcpSwReadSupported(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the read direction (need to be able to float the data register
    drivers in order to do byte wide reads) by trying negotiate when asked.

Arguments:

    Extension  - The device extension.

Return Value:

    BOOLEAN.

--*/

{
    
    NTSTATUS Status;
    
    if (!(Extension->HardwareCapabilities & PPT_ECP_PRESENT) &&
        !(Extension->HardwareCapabilities & PPT_BYTE_PRESENT)) {

        // Only use ECP Software in the reverse direction if an
        // ECR is present or we know that we can put the data register into Byte mode.

        return FALSE;
    }
        
    if (Extension->BadProtocolModes & ECP_SW)
        return FALSE;

    if (Extension->ProtocolModesSupported & ECP_SW)
        return TRUE;

    // Must use SWECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterEcpSwMode (Extension, FALSE);
    ParTerminateEcpMode (Extension);
    
    if (NT_SUCCESS(Status)) {
    
        Extension->ProtocolModesSupported |= ECP_SW;
        return TRUE;
    }
   
    return FALSE;    
}

NTSTATUS
ParEnterEcpSwMode(
    IN  PDEVICE_EXTENSION   Extension,
    IN  BOOLEAN             DeviceIdRequest
    )

/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    ECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/

{
    NTSTATUS        Status = STATUS_SUCCESS;

    if ( Extension->ModeSafety == SAFE_MODE ) {
        if (DeviceIdRequest) {
            Status = IeeeEnter1284Mode (Extension, ECP_EXTENSIBILITY | DEVICE_ID_REQ);
        } else {
            Status = IeeeEnter1284Mode (Extension, ECP_EXTENSIBILITY);
        }
    } else {
        ParDump2(PARINFO, ("ParEnterEcpSwMode: In UNSAFE_MODE.\n"));
        Extension->Connected = TRUE;
    }
    
    if (NT_SUCCESS(Status)) {
        Status = ParEcpSetupPhase(Extension);
    }
      
    return Status; 
}    

VOID 
ParCleanupSwEcpPort(
    IN  PDEVICE_EXTENSION   Extension
    )
/*++

Routine Description:

   Cleans up prior to a normal termination from ECP mode.  Puts the
   port HW back into Compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    PUCHAR  Controller;
    UCHAR   dcr;           // Contents of DCR

    Controller = Extension->Controller;

    //----------------------------------------------------------------------
    // Set data bus for output
    //----------------------------------------------------------------------
    dcr = READ_PORT_UCHAR(Controller + OFFSET_DCR);               // Get content of DCR
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE );
    WRITE_PORT_UCHAR( Controller + OFFSET_DCR, dcr );
    return;
}


VOID
ParTerminateEcpMode(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/

{
    ParCleanupSwEcpPort(Extension);
    if ( Extension->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode (Extension);
    } else {
        ParDump2(PARINFO, ("ParTerminateEcpMode: In UNSAFE_MODE.\n"));
        Extension->Connected = FALSE;
    }
    return;    
}

NTSTATUS
ParEcpSetAddress(
    IN  PDEVICE_EXTENSION   Extension,
    IN  UCHAR               Address
    )

/*++

Routine Description:

    Sets the ECP Address.
    
Arguments:

    Extension           - Supplies the device extension.

    Address             - The bus address to be set.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    PUCHAR          DCRController;
    UCHAR           dsr;
    UCHAR           dcr;
    
    ParDump2( PARENTRY, ("ParEcpSetAddress: Start: Channel [%x]\n", Address));
    Controller = Extension->Controller;
    DCRController = Controller + OFFSET_DCR;
    
    //
    // Event 34
    //
    // HostAck low indicates a command byte
    Extension->CurrentEvent = 34;
    dcr = READ_PORT_UCHAR(DCRController);
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE );
    WRITE_PORT_UCHAR(DCRController, dcr);
    // Place the channel address on the bus
    // Bit 7 of the byte sent must be 1 to indicate that this is an address
    // instead of run length count.
    //
    WRITE_PORT_UCHAR(Controller + DATA_OFFSET, (UCHAR)(Address | 0x80));
    
    //
    // Event 35
    //
    // Start handshake by dropping HostClk
    Extension->CurrentEvent = 35;
    dcr = UPDATE_DCR( dcr, DIR_WRITE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE );
    WRITE_PORT_UCHAR(DCRController, dcr);


    // =============== Periph State 36     ===============8
    // PeriphAck/PtrBusy        = High (signals state 36)
    // PeriphClk/PtrClk         = Don't Care
    // nAckReverse/AckDataReq   = Don't Care
    // XFlag                    = Don't Care
    // nPeriphReq/nDataAvail    = Don't Care
    Extension->CurrentEvent = 35;
    if (!CHECK_DSR(Controller,
                  ACTIVE, DONT_CARE, DONT_CARE,
                  DONT_CARE, DONT_CARE,
                  DEFAULT_RECEIVE_TIMEOUT))
    {
	    ParDump2(PARERRORS, ("ECP::SendChannelAddress:State 36 Failed: Controller %x\n",
                            Controller));
        // Make sure both HostAck and HostClk are high before leaving
        // HostClk should be high in forward transfer except when handshaking
        // HostAck should be high to indicate that what follows is data (not commands)
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        WRITE_PORT_UCHAR(DCRController, dcr);
        return STATUS_IO_DEVICE_ERROR;
    }
        
    //
    // Event 37
    //
    // Finish handshake by raising HostClk
    // HostClk is high when it's 0
    //
    Extension->CurrentEvent = 37;
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE );
    WRITE_PORT_UCHAR(DCRController, dcr);
            
    // =============== Periph State 32     ===============8
    // PeriphAck/PtrBusy        = Low (signals state 32)
    // PeriphClk/PtrClk         = Don't Care
    // nAckReverse/AckDataReq   = Don't Care
    // XFlag                    = Don't Care
    // nPeriphReq/nDataAvail    = Don't Care
    Extension->CurrentEvent = 32;
    if (!CHECK_DSR(Controller,
                  INACTIVE, DONT_CARE, DONT_CARE,
                  DONT_CARE, DONT_CARE,
                  DEFAULT_RECEIVE_TIMEOUT))
    {
	    ParDump2(PARERRORS, ("ECP::SendChannelAddress:State 32 Failed: Controller %x\n",
                            Controller));
        // Make sure both HostAck and HostClk are high before leaving
        // HostClk should be high in forward transfer except when handshaking
        // HostAck should be high to indicate that what follows is data (not commands)
        //
        dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
        WRITE_PORT_UCHAR(DCRController, dcr);
        return STATUS_IO_DEVICE_ERROR;
    }
    
    // Make sure both HostAck and HostClk are high before leaving
    // HostClk should be high in forward transfer except when handshaking
    // HostAck should be high to indicate that what follows is data (not commands)
    //
    dcr = UPDATE_DCR( dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE );
    WRITE_PORT_UCHAR(DCRController, dcr);

    ParDump2( PAREXIT, ("ParEcpSetAddress, Exit [%d]\n", NT_SUCCESS(STATUS_SUCCESS)));
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpSwWrite(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    Writes data to the peripheral using the ECP protocol under software
    control.
    
Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to write from.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.
    
Return Value:

    None.

--*/
{
    PUCHAR          Controller;
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          pBuffer;
    LARGE_INTEGER   Timeout;
    LARGE_INTEGER   StartWrite;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    ULONG           i;

    Controller = Extension->Controller;
    pBuffer    = Buffer;

    Status = ParTestEcpWrite(Extension);

    if (!NT_SUCCESS(Status))
    {
        Extension->CurrentPhase = PHASE_UNKNOWN;                     
        Extension->Connected = FALSE;                                
        ParDump2(PARERRORS,("ParEcpSwWrite: Invalid Entry State\r\n"));
        goto ParEcpSwWrite_ExitLabel;
    }

    Wait.QuadPart = DEFAULT_RECEIVE_TIMEOUT * 10 * 1000 + KeQueryTimeIncrement();
    
    Timeout.QuadPart  = Extension->AbsoluteOneSecond.QuadPart * 
                            Extension->TimerStart;
    
    KeQueryTickCount(&StartWrite);
    
    dcr = GetControl (Controller);
    
    // clear direction bit - enable output
    dcr &= ~(DCR_DIRECTION);
    StoreControl(Controller, dcr);
    KeStallExecutionProcessor(1);

    for (i = 0; i < BufferSize; i++) {

        //
        // Event 34
        //
        Extension->CurrentEvent = 34;
        WRITE_PORT_UCHAR(Controller + DATA_OFFSET, *pBuffer++);
    
        //
        // Event 35
        //
        Extension->CurrentEvent = 35;
        dcr &= ~DCR_AUTOFEED;
        dcr |= DCR_STROBE;
        StoreControl (Controller, dcr);
            
        //
        // Waiting for Event 36
        //
        Extension->CurrentEvent = 36;
        while (TRUE) {

            KeQueryTickCount(&End);

            dsr = GetStatus(Controller);
            if (!(dsr & DSR_NOT_BUSY)) {
                break;
            }

            if ((End.QuadPart - StartWrite.QuadPart) * 
                    KeQueryTimeIncrement() > Timeout.QuadPart) {

                dsr = GetStatus(Controller);
                if (!(dsr & DSR_NOT_BUSY)) {
                    break;
                }
                //
                // Return the device to Idle.
                //
                dcr &= ~(DCR_STROBE);
                StoreControl (Controller, dcr);
            
                *BytesTransferred = i;
                Extension->log.SwEcpWriteCount += *BytesTransferred;
                return STATUS_DEVICE_BUSY;
            }
        }
        
        //
        // Event 37
        //
        Extension->CurrentEvent = 37;
        dcr &= ~DCR_STROBE;
        StoreControl (Controller, dcr);
            
        //
        // Waiting for Event 32
        //
        Extension->CurrentEvent = 32;
        KeQueryTickCount(&Start);
        while (TRUE) {

            KeQueryTickCount(&End);

            dsr = GetStatus(Controller);
            if (dsr & DSR_NOT_BUSY) {
                break;
            }

            if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() >
                Wait.QuadPart) {

                dsr = GetStatus(Controller);
                if (dsr & DSR_NOT_BUSY) {
                    break;
                }
                #if DVRH_BUS_RESET_ON_ERROR
                    BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
                #endif
                *BytesTransferred = i;
                Extension->log.SwEcpWriteCount += *BytesTransferred;
                return STATUS_IO_DEVICE_ERROR;
            }
        }
    }

ParEcpSwWrite_ExitLabel:

    *BytesTransferred = i;
    Extension->log.SwEcpWriteCount += *BytesTransferred;
    ParDumpReg(PAREXIT | PARECPTRACE, ("ParEcpSwWrite: Exit[%d] BytesTransferred[%lx]",
                NT_SUCCESS(Status),
                (long)*BytesTransferred),
                Controller + ECR_OFFSET,
                Controller + OFFSET_DCR,
                Controller + OFFSET_DSR);


    return Status;

}

NTSTATUS
ParEcpSwRead(
    IN  PDEVICE_EXTENSION   Extension,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )

/*++

Routine Description:

    This routine performs a 1284 ECP mode read under software control
    into the given buffer for no more than 'BufferSize' bytes.

Arguments:

    Extension           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/

{
    PUCHAR          Controller;
    PUCHAR          pBuffer;
    USHORT          usTime;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    ULONG           i;
    UCHAR           ecr;
    
    Controller = Extension->Controller;
    pBuffer    = Buffer;

    dcr = GetControl (Controller);
    
    Extension->CurrentPhase = PHASE_REVERSE_XFER;
    
    //
    // Put ECR into PS/2 mode and float the drivers.
    //
    if (Extension->HardwareCapabilities & PPT_ECP_PRESENT) {
        // Save off the ECR register 
        ecr = READ_PORT_UCHAR(Controller + ECR_OFFSET);
        
        #if (1 == PARCHIP_ECR_ARBITRATOR)
        #else
            WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_PS2);
        #endif
    }
        
    dcr |= DCR_DIRECTION;
    StoreControl (Controller, dcr);
    KeStallExecutionProcessor(1);
    
    for (i = 0; i < BufferSize; i++) {

        // dvtw - READ TIMEOUTS
        //
        // If it is the first byte then give it more time
        //
        if (!(GetStatus (Controller) & DSR_NOT_FAULT) || i == 0) {
        
            usTime = DEFAULT_RECEIVE_TIMEOUT;
            
        } else {
        
            usTime = IEEE_MAXTIME_TL;
        }        
        
        // *************** State 43 Reverse Phase ***************8
        // PeriphAck/PtrBusy        = DONT CARE
        // PeriphClk/PtrClk         = LOW ( State 43 )
        // nAckReverse/AckDataReq   = LOW 
        // XFlag                    = HIGH
        // nPeriphReq/nDataAvail    = DONT CARE
        
        Extension->CurrentEvent = 43;
        if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, INACTIVE, ACTIVE, DONT_CARE,
                      usTime)) {
                  
            Extension->CurrentPhase = PHASE_UNKNOWN;
            
            dcr &= ~DCR_DIRECTION;
            StoreControl (Controller, dcr);
                
            // restore ecr register
            if (Extension->HardwareCapabilities & PPT_ECP_PRESENT) {
                #if (1 == PARCHIP_ECR_ARBITRATOR)
                #else
                    WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
                #endif
                WRITE_PORT_UCHAR(Controller + ECR_OFFSET, ecr);
            }
                
            *BytesTransferred = i;
            Extension->log.SwEcpReadCount += *BytesTransferred;                
            return STATUS_IO_DEVICE_ERROR;
    
        }

        // *************** State 44 Setup Phase ***************8
        //  DIR                     = DONT CARE
        //  IRQEN                   = DONT CARE
        //  1284/SelectIn           = DONT CARE
        //  nReverseReq/**(ECP only)= DONT CARE
        //  HostAck/HostBusy        = HIGH ( State 44 )
        //  HostClk/nStrobe         = DONT CARE
        //
        Extension->CurrentEvent = 44;
        dcr = READ_PORT_UCHAR(Controller + OFFSET_DCR);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, DONT_CARE);
        WRITE_PORT_UCHAR(Controller + OFFSET_DCR, dcr);

        // *************** State 45 Reverse Phase ***************8
        // PeriphAck/PtrBusy        = DONT CARE
        // PeriphClk/PtrClk         = HIGH ( State 45 )
        // nAckReverse/AckDataReq   = LOW 
        // XFlag                    = HIGH
        // nPeriphReq/nDataAvail    = DONT CARE
        Extension->CurrentEvent = 45;
        if (!CHECK_DSR(Controller, DONT_CARE, ACTIVE, INACTIVE, ACTIVE, DONT_CARE,
                      IEEE_MAXTIME_TL)) {
                  
            Extension->CurrentPhase = PHASE_UNKNOWN;
            
            dcr &= ~DCR_DIRECTION;
            StoreControl (Controller, dcr);
                
            // restore ecr register
            if (Extension->HardwareCapabilities & PPT_ECP_PRESENT) {
                #if (1 == PARCHIP_ECR_ARBITRATOR)
                #else
                    WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
                #endif
                WRITE_PORT_UCHAR(Controller + ECR_OFFSET, ecr);
            }
                
            *BytesTransferred = i;
            Extension->log.SwEcpReadCount += *BytesTransferred;                
            return STATUS_IO_DEVICE_ERROR;
    
        }

        //
        // Read the data
        //
        *pBuffer = READ_PORT_UCHAR (Controller + DATA_OFFSET);
        pBuffer++;
        
        // *************** State 46 Setup Phase ***************8
        //  DIR                     = DONT CARE
        //  IRQEN                   = DONT CARE
        //  1284/SelectIn           = DONT CARE
        //  nReverseReq/**(ECP only)= DONT CARE
        //  HostAck/HostBusy        = LOW ( State 46 )
        //  HostClk/nStrobe         = DONT CARE
        //
        Extension->CurrentEvent = 46;
        dcr = READ_PORT_UCHAR(Controller + OFFSET_DCR);
        dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, INACTIVE, DONT_CARE);
        WRITE_PORT_UCHAR(Controller + OFFSET_DCR, dcr);

    }
    
    Extension->CurrentPhase = PHASE_REVERSE_IDLE;
    
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);
    
    // restore ecr register
    if (Extension->HardwareCapabilities & PPT_ECP_PRESENT) {
        #if (1 == PARCHIP_ECR_ARBITRATOR)
        #else
            WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
        #endif
        WRITE_PORT_UCHAR(Controller + ECR_OFFSET, ecr);
    }

    *BytesTransferred = i;
    Extension->log.SwEcpReadCount += *BytesTransferred;                
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpForwardToReverse(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine reverses the channel (ECP).

Arguments:

    Extension  - Supplies the device extension.

--*/

{
    PUCHAR          Controller;
    LARGE_INTEGER   Wait35ms;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    UCHAR           ecr;
    
    Controller = Extension->Controller;

    Wait35ms.QuadPart = 10*35*1000 + KeQueryTimeIncrement();
    
    dcr = GetControl (Controller);
    
    //
    // Put ECR into PS/2 mode to flush the FIFO.
    //
        // Save off the ECR register 

    // Note: Don't worry about checking to see if it's
    // safe to touch the ecr since we've already checked 
    // that before we allowed this mode to be activated.
        ecr = READ_PORT_UCHAR(Controller + ECR_OFFSET);

        #if (1 == PARCHIP_ECR_ARBITRATOR)
        #else
            WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_PS2);
        #endif
    //
    // Event 38
    //
    Extension->CurrentEvent = 38;
    dcr |= DCR_AUTOFEED;
    StoreControl (Controller, dcr);
    KeStallExecutionProcessor(1);
    
    //
    // Event  39
    //
    Extension->CurrentEvent = 39;
    dcr &= ~DCR_NOT_INIT;
    StoreControl (Controller, dcr);
    
    //
    // Wait for Event 40
    //
    Extension->CurrentEvent = 40;
    KeQueryTickCount(&Start);
    while (TRUE) {

        KeQueryTickCount(&End);

        dsr = GetStatus(Controller);
        if (!(dsr & DSR_PERROR)) {
            break;
        }

        if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() >
            Wait35ms.QuadPart) {

            dsr = GetStatus(Controller);
            if (!(dsr & DSR_PERROR)) {
                break;
            }
            #if DVRH_BUS_RESET_ON_ERROR
                BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
            #endif
            // restore the ecr register
            if (Extension->HardwareCapabilities & PPT_ECP_PRESENT) {
                #if (1 == PARCHIP_ECR_ARBITRATOR)
                #else
                    WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
                #endif
                WRITE_PORT_UCHAR(Controller + ECR_OFFSET, ecr);
            }
            
            ParDump2(PARERRORS,("ParEcpForwardToReverse: Failed to get State 40\r\n"));
            return STATUS_IO_DEVICE_ERROR;
        }
    }
        
    // restore the ecr register
    if (Extension->HardwareCapabilities & PPT_ECP_PRESENT) {
        #if (1 == PARCHIP_ECR_ARBITRATOR)
        #else
            WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
        #endif
        WRITE_PORT_UCHAR(Controller + ECR_OFFSET, ecr);
    }

	Extension->CurrentPhase = PHASE_REVERSE_IDLE;
    return STATUS_SUCCESS;

}

NTSTATUS
ParEcpReverseToForward(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine puts the channel back into forward mode (ECP).

Arguments:

    Extension           - Supplies the device extension.

--*/

{
    PUCHAR          Controller;
    LARGE_INTEGER   Wait35ms;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    UCHAR           dsr;
    UCHAR           dcr;
    UCHAR           ecr;
    
    Controller = Extension->Controller;

    Wait35ms.QuadPart = 10*35*1000 + KeQueryTimeIncrement();
    
    dcr = GetControl (Controller);
    
    //
    // Put ECR into PS/2 mode to flush the FIFO.
    //
        // Save off the ECR register 
    
    // Note: Don't worry about checking to see if it's
    // safe to touch the ecr since we've already checked 
    // that before we allowed this mode to be activated.
    ecr = READ_PORT_UCHAR(Controller + ECR_OFFSET);
    #if (1 == PARCHIP_ECR_ARBITRATOR)
    #else
        WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_PS2);
    #endif    
    //
    // Event 47
    //
    Extension->CurrentEvent = 47;
    dcr |= DCR_NOT_INIT;
    StoreControl (Controller, dcr);
    
    //
    // Wait for Event 49
    //
    Extension->CurrentEvent = 49;
    KeQueryTickCount(&Start);
    while (TRUE) {

        KeQueryTickCount(&End);

        dsr = GetStatus(Controller);
        if (dsr & DSR_PERROR) {
            break;
        }

        if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() >
            Wait35ms.QuadPart) {

            dsr = GetStatus(Controller);
            if (dsr & DSR_PERROR) {
                break;
            }
            #if DVRH_BUS_RESET_ON_ERROR
                BusReset(Controller+OFFSET_DCR);  // Pass in the dcr address
            #endif
            // Restore the ecr register
            if (Extension->HardwareCapabilities & PPT_ECP_PRESENT) {
                #if (1 == PARCHIP_ECR_ARBITRATOR)
                #else
                    WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
                #endif
                WRITE_PORT_UCHAR(Controller + ECR_OFFSET, ecr);
            }

            ParDump2(PARERRORS,("ParEcpReverseToForward: Failed to get State 49\r\n"));
            return STATUS_IO_DEVICE_ERROR;
        }
    }
        
    // restore the ecr register
    if (Extension->HardwareCapabilities & PPT_ECP_PRESENT) {
        #if (1 == PARCHIP_ECR_ARBITRATOR)
        #else   
            WRITE_PORT_UCHAR(Controller + ECR_OFFSET, DEFAULT_ECR_COMPATIBILITY);
        #endif
        WRITE_PORT_UCHAR(Controller + ECR_OFFSET, ecr);
    }

    Extension->CurrentPhase = PHASE_FORWARD_IDLE;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\test.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       test.c
//
//--------------------------------------------------------------------------

//
// This file contains functions that are used for testing the ParClass driver.
// 
// This file differs from debug.c in that these functions may 
// also be available in a fre build
//

#include "pch.h"
#include "test.h"

NTSTATUS
MfSendPnpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION Location,
    OUT PULONG_PTR Information OPTIONAL
    )

/*++

Routine Description:

    This builds and send a pnp irp to a device.
    
Arguments:

    DeviceObject - The a device in the device stack the irp is to be sent to - 
        the top of the device stack is always found and the irp sent there first.
    
    Location - The initial stack location to use - contains the IRP minor code
        and any parameters
    
    Information - If provided contains the final value of the irps information
        field.

Return Value:

    The final status of the completed irp or an error if the irp couldn't be sent
    
--*/

{

    NTSTATUS status;                         
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_OBJECT targetDevice = NULL;
    KEVENT irpCompleted;
    IO_STATUS_BLOCK statusBlock;
    
    ASSERT(Location->MajorFunction == IRP_MJ_PNP);

    //
    // Find out where we are sending the irp
    //
    
    targetDevice = IoGetAttachedDeviceReference(DeviceObject);

    //
    // Get an IRP
    //
    
    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       targetDevice,
                                       NULL,    // Buffer
                                       0,       // Length
                                       0,       // StartingOffset
                                       &irpCompleted,
                                       &statusBlock
                                       );
    
    
    if (!irp) {
        goto cleanup;
    }
    
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;
    
    //
    // Initialize the stack location
    //

    irpStack = IoGetNextIrpStackLocation(irp);
    
    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

    irpStack->MinorFunction = Location->MinorFunction;
    irpStack->Parameters = Location->Parameters;
    
    //
    // Call the driver and wait for completion
    //

    status = IoCallDriver(targetDevice, irp);

    if (status == STATUS_PENDING) {
    
        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    if (!NT_SUCCESS(status)) {
        goto cleanup;
    }

    //
    // Return the information
    //

    if (ARGUMENT_PRESENT(Information)) {
        *Information = statusBlock.Information;
    }

    ObDereferenceObject(targetDevice);
    
    ASSERT(status == STATUS_PENDING || status == statusBlock.Status);

    return statusBlock.Status;

cleanup:

    if (targetDevice) {
        ObDereferenceObject(targetDevice);
    }

    return status;
}

VOID
regTst(PDEVICE_OBJECT PortDeviceObject) {
    NTSTATUS          status;
    PIRP              irp;
    PDEVICE_OBJECT    pdo;
    IO_STACK_LOCATION request;
    IO_STATUS_BLOCK   ioStatus;
    ULONG_PTR         info;
    HANDLE            handle;
    PKEY_VALUE_FULL_INFORMATION buffer;
    ULONG                       bufferLength;
    ULONG                       resultLength;
    PWSTR                       valueNameWstr;
    UNICODE_STRING              valueName;
    PWSTR                       portName;


    
    ///

    // RtlZeroMemory(&request, sizeof(IO_STACK_LOCATION));
    
    request.MajorFunction                        = IRP_MJ_PNP;
    request.MinorFunction                        = IRP_MN_QUERY_DEVICE_RELATIONS;
    request.Parameters.QueryDeviceRelations.Type = TargetDeviceRelation;

    status = MfSendPnpIrp(PortDeviceObject, &request, &info);
    if( !NT_SUCCESS(status) ) {
        return;
    }

    pdo = ((PDEVICE_RELATIONS)info)->Objects[0];
    ExFreePool((PVOID)info);

    if( !pdo ) {
        // NULL pdo?, bail out
        return;
    }

    status = IoOpenDeviceRegistryKey(pdo, PLUGPLAY_REGKEY_DEVICE, STANDARD_RIGHTS_ALL, &handle);

    if( !NT_SUCCESS(status) ) {
        // unable to open key, bail out
        return;    
    }

    //
    // we have a handle to the registry key
    //
    // loop trying to read registry value until either we succeed or
    //   we get a hard failure, grow the result buffer as needed
    //

    bufferLength  = 0;          // we will ask how large a buffer we need
    buffer        = NULL;
    valueNameWstr = L"PortName";
    RtlInitUnicodeString(&valueName, valueNameWstr);
    status        = STATUS_BUFFER_TOO_SMALL;

    while(status == STATUS_BUFFER_TOO_SMALL) {

      status = ZwQueryValueKey(handle,
                               &valueName,
                               KeyValueFullInformation,
                               buffer,
                               bufferLength,
                               &resultLength);

      if(status == STATUS_BUFFER_TOO_SMALL) {
        // 
        // buffer too small, free it and allocate a larger buffer
        //
        if(buffer) ExFreePool(buffer);
        buffer       = ExAllocatePool(PagedPool, resultLength);
        bufferLength = resultLength;
        if(!buffer) {
          // unable to allocate pool, clean up and exit
            ZwClose(handle);
            return;
        }
      }

    } // end while BUFFER_TOO_SMALL

    //
    // query is complete
    //


    // write something new as a test
    {
        UNICODE_STRING unicodeName;
        ULONG data=0x0fa305ff;
        RtlInitUnicodeString(&unicodeName, L"TestNameOKtoDelete");
        status = ZwSetValueKey(handle, &unicodeName, 0, REG_DWORD, &data, sizeof(ULONG));
        // ParDumpV( ("ZwSetValueKey returned status=%x\n", status) );
    }


    // no longer need the handle so close it
    ZwClose(handle);

    // check the status of our query
    if( !NT_SUCCESS(status) ) {
        if(buffer) ExFreePool(buffer);
        return;
    }

    // sanity check our result
    if( (buffer->Type != REG_SZ) || (!buffer->DataLength) ) {
        // ParDumpV( (" - either bogus PortName data type or zero length\n", status) );
        ExFreePool(buffer);       // query succeeded, so we know we have a buffer
        return;
    }
    

    // 
    // result looks ok, copy PortName to its own allocation of the proper size
    //   and return a pointer to it
    //

    portName = ExAllocatePool(PagedPool, buffer->DataLength);
    if(!portName) {
      // unable to allocate pool, clean up and exit
        // ParDumpV( (" - unable to allocate pool to hold PortName(SymbolicLinkName)\n") );
        ExFreePool(buffer);
        return;
    }

    RtlCopyMemory(portName, (PUCHAR)buffer + buffer->DataOffset, buffer->DataLength);

    // ParDumpV( ("fred: PortName== <%S>\n",portName) );

    ExFreePool(portName);
    ExFreePool(buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\util.h ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    util.h

Abstract:

    This module contains utility code used by other 1284 modules.

Author:

    Robbie Harris (Hewlett-Packard) 20-May-1998

Environment:

    Kernel mode

Revision History :

--*/
#ifndef _UTIL_
#define _UTIL_

// Standard Maximum Timing values
#define IEEE_MAXTIME_TL    35       // Max time Tl from the IEEE spec
#define DEFAULT_RECEIVE_TIMEOUT     330

#define ParEnterCriticalSection(Xtension)  xTension->bCriticalSection = TRUE
#define ParExitCriticalSection(Xtension)   xTension->bCriticalSection = FALSE

// The following macros may be used to test the contents of the Device
// Status Regisger (DSR).  These macros account for the hardware
// inversion of the nBusy (aka PtrBusy, PeriphAck) signal.
//////////////////////////////////////////////////////////////////////////////

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)(b7==DONT_CARE? 0:  BIT_7_SET) | \
            (b6==DONT_CARE? 0:  BIT_6_SET) | \
            (b5==DONT_CARE? 0:  BIT_5_SET) | \
            (b4==DONT_CARE? 0:  BIT_4_SET) | \
            (b3==DONT_CARE? 0:  BIT_3_SET) )
#else
    #define DSR_TEST_MASK(b7,b6,b5,b4,b3)  \
    ((UCHAR)((b7==DONT_CARE?0:1)<<BIT_7) | \
            ((b6==DONT_CARE?0:1)<<BIT_6) | \
            ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) )
#endif

#if (1 == DVRH_USE_FAST_MACROS)
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) ((b7==DONT_CARE?0:(b7==ACTIVE?0        : BIT_7_SET)) | \
            (b6==DONT_CARE?0:(b6==ACTIVE?  BIT_6_SET: 0)) | \
            (b5==DONT_CARE?0:(b5==ACTIVE?  BIT_5_SET: 0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET: 0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  BIT_3_SET: 0)) ) )
#else
    #define DSR_TEST_VALUE(b7,b6,b5,b4,b3)  \
    ((UCHAR) (((b7==DONT_CARE?0:(b7==ACTIVE?0:1))<<BIT_7) | \
            ((b6==DONT_CARE?0:(b6==ACTIVE?1:0))<<BIT_6) | \
            ((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?1:0))<<BIT_3) ) )
#endif

#define TEST_DSR(registerValue,b7,b6,b5,b4,b3)  \
(((registerValue) & DSR_TEST_MASK(b7,b6,b5,b4,b3)) == DSR_TEST_VALUE(b7,b6,b5,b4,b3))


#define CHECK_DSR( addr, b7, b6, b5, b4, b3, msTime )                    \
    (TEST_DSR(READ_PORT_UCHAR(addr + OFFSET_DSR), b7, b6, b5, b4, b3 ) ? TRUE :   \
    CheckPort( addr + OFFSET_DSR,                                               \
             DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                                   \
             DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),                                  \
             msTime ) )

////////////////////////////////////////////////////////////////////////////////
// The CHECK_DSR_AND_FIFO macro may be used to invoke the CheckPort2 function, 
// without having to specify the mask and value components twice.
// CHECK_DSR_AND_FIFO does quick tests of the DSR and ECR ports first.
// If the peripheral has already responded with either of the
//  desired values, CheckPort2 need not be called.
////////////////////////////////////////////////////////////////////////////////

#define CHECK_DSR_WITH_FIFO( addr, b7, b6, b5, b4, b3, ecr_mask, ecr_value, msTime ) \
( TEST_DSR( READ_PORT_UCHAR( addr + OFFSET_DSR ), b7, b6, b5, b4, b3 ) ? TRUE :       \
  CheckTwoPorts( addr + OFFSET_DSR,                                  \
                 DSR_TEST_MASK( b7, b6, b5, b4, b3 ),                \
                 DSR_TEST_VALUE( b7, b6, b5, b4, b3 ),               \
                 addr + ECR_OFFSET,                                  \
                 ecr_mask,                                           \
                 ecr_value,                                          \
                 msTime) )

//////////////////////////////////////////////////////////////////////////////
// The following defines and macros may be used to set, test, and
// update the Device Control Register (DCR).
//////////////////////////////////////////////////////////////////////////////

// The DCR_AND_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   BIT_5_SET:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    BIT_4_SET:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    BIT_3_SET:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    BIT_2_SET:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    BIT_1_SET:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    BIT_0_SET:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_AND_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?1:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?1:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?1:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?1:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?1:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?1:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif  

// The DCR_OR_MASK macro generates a byte constant that is used by
// the UPDATE_DCR macro.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==DONT_CARE?   0:(b5==ACTIVE?  BIT_5_SET:  0)) | \
            (b4==DONT_CARE?    0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?    0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?    0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?    0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?    0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_OR_MASK(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The UPDATE_DCR macro generates provides a selective update of specific bits
// in the DCR.  Any bit positions specified as DONT_CARE will be left
// unchanged.  The macro accounts for the hardware inversion of
// certain signals.

#define UPDATE_DCR(registerValue,b5,b4,b3,b2,b1,b0) \
((UCHAR)(((registerValue) & DCR_AND_MASK(b5,b4,b3,b2,b1,b0)) | DCR_OR_MASK(b5,b4,b3,b2,b1,b0)))

// The DCR_TEST_MASK macro generates a byte constant which may be used
// to mask of DCR bits that we don't care about

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:BIT_5_SET) | \
            (b4==DONT_CARE?0:BIT_4_SET) | \
            (b3==DONT_CARE?0:BIT_3_SET) | \
            (b2==DONT_CARE?0:BIT_2_SET) | \
            (b1==DONT_CARE?0:BIT_1_SET) | \
            (b0==DONT_CARE?0:BIT_0_SET) ) )
#else
    #define DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)( ((b5==DONT_CARE?0:1)<<BIT_5) | \
            ((b4==DONT_CARE?0:1)<<BIT_4) | \
            ((b3==DONT_CARE?0:1)<<BIT_3) | \
            ((b2==DONT_CARE?0:1)<<BIT_2) | \
            ((b1==DONT_CARE?0:1)<<BIT_1) | \
            ((b0==DONT_CARE?0:1)<<BIT_0) ) )
#endif
// The DCR_TEST_VALUE macro generates a byte constant that may be used
// to compare against a masked DCR value.  This macro takes into
// account which signals are inverted by hardware before driving the
// signal line.

#if (1 == DVRH_USE_FAST_MACROS)
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)((b5==DONT_CARE?0:(b5==ACTIVE? BIT_5_SET:  0)) | \
            (b4==DONT_CARE?0:(b4==ACTIVE?  BIT_4_SET:  0)) | \
            (b3==DONT_CARE?0:(b3==ACTIVE?  0:          BIT_3_SET)) | \
            (b2==DONT_CARE?0:(b2==ACTIVE?  BIT_2_SET:  0)) | \
            (b1==DONT_CARE?0:(b1==ACTIVE?  0:          BIT_1_SET)) | \
            (b0==DONT_CARE?0:(b0==ACTIVE?  0:          BIT_0_SET)) ) )
#else
    #define DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0)  \
    ((UCHAR)(((b5==DONT_CARE?0:(b5==ACTIVE?1:0))<<BIT_5) | \
            ((b4==DONT_CARE?0:(b4==ACTIVE?1:0))<<BIT_4) | \
            ((b3==DONT_CARE?0:(b3==ACTIVE?0:1))<<BIT_3) | \
            ((b2==DONT_CARE?0:(b2==ACTIVE?1:0))<<BIT_2) | \
            ((b1==DONT_CARE?0:(b1==ACTIVE?0:1))<<BIT_1) | \
            ((b0==DONT_CARE?0:(b0==ACTIVE?0:1))<<BIT_0) ) )
#endif
// The TEST_DCR macro may be used to generate a boolean result that is
// TRUE if the DCR value matches the specified signal levels and FALSE
// otherwise.

#define TEST_DCR(registerValue,b5,b4,b3,b2,b1,b0)  \
(((registerValue) & DCR_TEST_MASK(b5,b4,b3,b2,b1,b0)) == DCR_TEST_VALUE(b5,b4,b3,b2,b1,b0))

//  mask all but AckDataReq, XFlag, and nDataAvail to validate if it is still NIBBLE mode
//  00111000b
//#define DSR_NIBBLE_VALIDATION       (0x38)
#define DSR_NIBBLE_VALIDATION       (0x30)
//  AckDataReq high, XFlag low, nDataAvail high
//  00101000b
//#define DSR_NIBBLE_TEST_RESULT      (0x28)
#define DSR_NIBBLE_TEST_RESULT      (0x20)

//  mask all but AckDataReq, XFlag, and nDataAvail to validate if it is still BYTE mode
//  00111000b
#define DSR_BYTE_VALIDATION         (0x38)
//  AckDataReq high, XFlag high, nDataAvail high
//  00111000b
#define DSR_BYTE_TEST_RESULT        (0x38)

#define DVRH_LOGIC_ANALYZER_START(CNT)      \
            int DVRH_temp;                  \
            int DVRH_max = CNT;             \
            int DVRH_cnt = 0;               \
            UCHAR DVRH_dsr;                 \
            UCHAR DVRH_Statedsr[CNT];       \
            LARGE_INTEGER DVRH_Statetime[CNT];
#define DVRH_LOGIC_ANALYZER_READ_TIMER(DSR)          \
            DVRH_dsr = READ_PORT_UCHAR(DSR);                \
            KeQuerySystemTime(&DVRH_Statetime[DVRH_cnt]);   \
            DVRH_Statedsr[DVRH_cnt++] = DVRH_dsr;
#define DVRH_LOGIC_ANALYZER_READ_STATE(DSR)          \
            DVRH_dsr = READ_PORT_UCHAR(DSR);                \
            KeQuerySystemTime(&DVRH_Statetime[DVRH_cnt]);   \
            DVRH_Statedsr[DVRH_cnt ? ((DVRH_dsr != DVRH_Statedsr[DVRH_cnt-1]) ? DVRH_cnt++ : DVRH_cnt) : 0] = DVRH_dsr;

#define DVRH_LOGIC_ANALYZER_END                                 \
        KdPrint("0. %10u-%10u dsr [%x]\n",                      \
            DVRH_Statetime[0].HighPart,                         \
            DVRH_Statetime[0].LowPart/10,                       \
            DVRH_Statedsr[0]);                                  \
        for (DVRH_temp=1; DVRH_temp<DVRH_cnt; DVRH_temp++)      \
        {                                                       \
            KdPrint("%d. %10u-%10u diff [%10u]us dsr [%x]\n",   \
                DVRH_temp,                                      \
                DVRH_Statetime[DVRH_temp].HighPart,             \
                DVRH_Statetime[DVRH_temp].LowPart/10,           \
                ((DVRH_Statetime[DVRH_temp].LowPart/10) - (DVRH_Statetime[DVRH_temp-1].LowPart/10)),    \
                DVRH_Statedsr[DVRH_temp]);                      \
        }

void BusReset(
    IN  PUCHAR DCRController
    );

BOOLEAN CheckPort(IN PUCHAR offset_Controller,
                  IN UCHAR dsrMask,
                  IN UCHAR dsrValue,
                  IN USHORT msTimeDelay);

BOOLEAN
CheckTwoPorts(
    PUCHAR  pPortAddr1,
    UCHAR   bMask1,
    UCHAR   bValue1,
    PUCHAR  pPortAddr2,
    UCHAR   bMask2,
    UCHAR   bValue2,
    USHORT  msTimeDelay
    );

#if (1 == DVRH_DELAY_THEORY)
    void DVRH_Diagnostic_Delay();
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\test.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       test.h
//
//--------------------------------------------------------------------------

#define TST 1                   // enable test functions

#if TST

VOID
regTst(PDEVICE_OBJECT PortDeviceObject);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\wmipdo.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for 
      parallel driver PDOs and PODOs.

Environment:

    Kernel mode

Revision History :
--*/

#include "pch.h"
#include <wmistr.h>
#include "wmipdo.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEPARWMI0, ParWmiPdoInitWmi)
#pragma alloc_text(PAGEPARWMI0, ParWmiPdoSystemControlDispatch)
#pragma alloc_text(PAGEPARWMI0, ParWmiPdoQueryWmiRegInfo)
#pragma alloc_text(PAGEPARWMI0, ParWmiPdoQueryWmiDataBlock)
#endif

#define PAR_WMI_PDO_GUID_COUNT               1
#define PAR_WMI_BYTES_TRANSFERRED_GUID_INDEX 0

GUID ParWmiPdoBytesTransferredGuid = PARALLEL_WMI_BYTES_TRANSFERRED_GUID;

WMIGUIDREGINFO ParWmiPdoGuidList[ PAR_WMI_PDO_GUID_COUNT ] =
{
    { &ParWmiPdoBytesTransferredGuid, 1, 0 }
};


NTSTATUS
ParWmiPdoInitWmi(PDEVICE_OBJECT DeviceObject) 
{
    PDEVICE_EXTENSION devExt     = DeviceObject->DeviceExtension;
    PWMILIB_CONTEXT   wmiContext = &devExt->WmiLibContext;

    PAGED_CODE();

    wmiContext->GuidCount = sizeof(ParWmiPdoGuidList) / sizeof(WMIGUIDREGINFO);
    wmiContext->GuidList  = ParWmiPdoGuidList;

    wmiContext->QueryWmiRegInfo    = ParWmiPdoQueryWmiRegInfo;
    wmiContext->QueryWmiDataBlock  = ParWmiPdoQueryWmiDataBlock;
    wmiContext->SetWmiDataBlock    = NULL;
    wmiContext->SetWmiDataItem     = NULL;
    wmiContext->ExecuteWmiMethod   = NULL;
    wmiContext->WmiFunctionControl = NULL;

    return ParWMIRegistrationControl( DeviceObject, WMIREG_ACTION_REGISTER );
}

NTSTATUS
ParWmiPdoSystemControlDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS               status;
    PDEVICE_EXTENSION      pDevExt = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    PAGED_CODE();

    status = WmiSystemControl( &pDevExt->WmiLibContext, DeviceObject, Irp, &disposition);
    switch(disposition) {
    case IrpProcessed:

        //
        // This irp has been processed and may be completed or pending.
        //
        break;

    case IrpNotCompleted:

        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);                
        break;

    case IrpForward:
    case IrpNotWmi:
    default:

        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        // If this was an FDO we would pass the IRP down the stack, but
        //   this is a PDO (or PODO) so there no one below us in the 
        //   stack.
        //
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        status               = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);                
        break;

    }
    
    return status;

}

NTSTATUS
ParWmiPdoQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  PDevObj, 
    OUT PULONG          PRegFlags,
    OUT PUNICODE_STRING PInstanceName,
    OUT PUNICODE_STRING *PRegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo 
)
{
   PDEVICE_EXTENSION devExt = (PDEVICE_EXTENSION)PDevObj->DeviceExtension;
   
   PAGED_CODE();

   if( ParIsPodo(PDevObj) ) {
       // This is a PODO
       PWSTR buffer = ExAllocatePool(PagedPool, devExt->SymbolicLinkName.MaximumLength);
       ParDumpV( ("wmipdo::ParWmiPdoQueryWmiRegInfo: PODO - %wZ\n", &devExt->SymbolicLinkName) );
       if( !buffer ) {
           PInstanceName->Length        = 0;
           PInstanceName->MaximumLength = 0;
           PInstanceName->Buffer        = NULL;
       } else {
           PInstanceName->Length        = 0;
           PInstanceName->MaximumLength = devExt->SymbolicLinkName.MaximumLength;
           PInstanceName->Buffer        = buffer;
           *PRegFlags                   = WMIREG_FLAG_INSTANCE_BASENAME;
           RtlCopyUnicodeString( PInstanceName, &devExt->SymbolicLinkName );
       }
       *PRegistryPath = &RegistryPath;
   } else {
       // this is a PDO
       ParDumpV( ("wmipdo::ParWmiPdoQueryWmiRegInfo: PDO - %x\n", PDevObj) );
       *PRegFlags     = WMIREG_FLAG_INSTANCE_PDO;
       *PRegistryPath = &RegistryPath;
       *Pdo           = PDevObj;
   }
   return STATUS_SUCCESS;
}

NTSTATUS
ParWmiPdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
{
    NTSTATUS          status;
    ULONG             size   = sizeof(PARALLEL_WMI_LOG_INFO);
    PDEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();

    //
    // Only ever registers 1 instance per guid
    //
    ASSERT(InstanceIndex == 0 && InstanceCount == 1);
    
    switch (GuidIndex) {
    case PAR_WMI_BYTES_TRANSFERRED_GUID_INDEX:

        //
        // Request is for Bytes Transferred
        //
        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        *( (PPARALLEL_WMI_LOG_INFO)Buffer ) = devExt->log;
        *InstanceLengthArray = size;
        status = STATUS_SUCCESS;
        break;

    default:
        //
        // Index value larger than our largest supported - invalid request
        //
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest( DeviceObject, Irp, status, size, IO_NO_INCREMENT );

    return status;
}

NTSTATUS 
ParWMIRegistrationControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN ULONG          Action
    )
/*+ 

    Wrapper function for IoWMIRegistrationControl that uses Device
      Extension variable WmiRegistrationCount to prevent device from
      registering more than once or from unregistering if not
      registered.

-*/
{
    PDEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS          status;
    LONG              count;
    
    ParDumpV( ("wmipdo::ParWMIRegistrationControl: enter - %wZ\n", &devExt->SymbolicLinkName) );

    switch( Action ) {

    case WMIREG_ACTION_REGISTER :

        //
        // Verify that we don't register more than once
        //
        count = InterlockedIncrement(&devExt->WmiRegistrationCount);
        if( count == 1 ) {
            status = IoWMIRegistrationControl(DeviceObject, Action);
            if( !NT_SUCCESS(status) ) {
                ParDumpV( ("wmipdo::ParWMIRegistrationControl: REGISTER - FAIL\n") );
                // registration failed - back out the increment
                InterlockedDecrement(&devExt->WmiRegistrationCount);
            } else {
                ParDumpV( ("wmipdo::ParWMIRegistrationControl: REGISTER - SUCCEED\n") );
            }
        } else {
            ParDumpV( ("wmipdo::ParWMIRegistrationControl: REGISTER - ABORT - already REGISTERed\n") );
            // back out the increment
            InterlockedDecrement(&devExt->WmiRegistrationCount);
            status = STATUS_UNSUCCESSFUL;
            // ASSERTMSG( "Already registered for WMI registration, fail registration", FALSE );
        }
        break;

    case WMIREG_ACTION_DEREGISTER :

        //
        // verify that we don't unregister if we are not registered
        // 
        count = InterlockedDecrement(&devExt->WmiRegistrationCount);
        if( count == 0 ) {
            status = IoWMIRegistrationControl(DeviceObject, Action);
            if( !NT_SUCCESS(status) ) {
                ParDumpV( ("wmipdo::ParWMIRegistrationControl: DEREGISTER - FAIL\n") );
                // unregistration failed?
                // ASSERTMSG( "WMI unregistration failed?", FALSE );
                InterlockedIncrement(&devExt->WmiRegistrationCount);
            } else {
                ParDumpV( ("wmipdo::ParWMIRegistrationControl: DEREGISTER - SUCCEED\n") );
            }
        } else {
            ParDumpV( ("wmipdo::ParWMIRegistrationControl: DEREGISTER - ABORT - not registered\n") );
            //  unregistration failed - back out the decrement
            InterlockedIncrement(&devExt->WmiRegistrationCount);
            status = STATUS_UNSUCCESSFUL;
            // ASSERTMSG( "Not registered for WMI, fail unregister", FALSE );
        }
        break;

    default:

        // unrecognized action
        status = STATUS_UNSUCCESSFUL;
        ASSERTMSG("wmipdo::ParWMIRegistrationControl: Unrecognized WMI registration Action \n",FALSE);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\adddevice.c ===
//
// addDevice.c
//

#include "pch.h"

NTSTATUS
P5AddDevice(
    IN PDRIVER_OBJECT  DriverObject,
    IN PDEVICE_OBJECT  Pdo
    )
/*++

Routine Description:

    This is the WDM AddDevice routine for parport devices.

Arguments:

    DriverObject - Driver Object
    Pdo          - PDO

Return Value:

    STATUS_SUCCESS - on SUCCESS
    Error Status   - otherwise

--*/
{
    NTSTATUS        status              = STATUS_SUCCESS;
    PDEVICE_OBJECT  fdo                 = NULL;
    PDEVICE_OBJECT  lowerDevObj         = NULL;
    PFDO_EXTENSION  fdx                 = NULL;
    BOOLEAN         haveDeviceInterface = FALSE;

    __try {

        fdo = PptBuildFdo( DriverObject, Pdo );
        if( !fdo ) {
            status = STATUS_UNSUCCESSFUL;
            __leave;
        }
        fdx = fdo->DeviceExtension;
        
        status = IoRegisterDeviceInterface( Pdo, &GUID_PARALLEL_DEVICE, NULL, &fdx->DeviceInterface);
        if( status != STATUS_SUCCESS ) {
            __leave;
        }
        haveDeviceInterface = TRUE;
        
        lowerDevObj = IoAttachDeviceToDeviceStack( fdo, Pdo );
        if( !lowerDevObj ) {
            status = STATUS_UNSUCCESSFUL;
            __leave;
        }
        fdx->ParentDeviceObject = lowerDevObj;
        
        KeInitializeEvent( &fdx->FdoThreadEvent, NotificationEvent, FALSE );

        // legacy drivers may use this count
        IoGetConfigurationInformation()->ParallelCount++;
        
        // done initializing - tell IO system we are ready to receive IRPs
        fdo->Flags &= ~DO_DEVICE_INITIALIZING;
        
        DD((PCE)fdx,DDT,"P5AddDevice - SUCCESS\n");

    } 
    __finally {

        if( status != STATUS_SUCCESS ) {
            if( haveDeviceInterface ) {
                RtlFreeUnicodeString( &fdx->DeviceInterface );
            }
            if( fdo ) {
                IoDeleteDevice( fdo );
            }
        }

    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\i386\parloopa.asm ===
title  "Parallel Write Loop"
;++
;
;Copyright (c) 1994 Microsoft Corporation
;
;Module Name:
;
;    parloop.c
;
;Abstract:
;
;    This module contains the i386 version of the
;    write loop for the parallel driver.
;
;Author:
;
;    Norbert P. Kusters 9-Mar-1994
;
;Environment:
;
;    Kernel mode
;
;Notes:
;
;   This module makes use of the IN and OUT commands.  Making
;   use of these commands is generally not portable and so using
;   IN and OUT should only be used when performance is critical.
;
;Revision History :
;
;--

.386p

        .xlist
include callconv.inc
        .list

;
; Parallel control register definitions.
;

L_NORMAL equ 0CCH
L_STROBE equ 0CDH

;
; Parallel status "ok to send" definition.
;

L_INVERT    equ 098H
L_NOT_READY equ 0B8H

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;Routine Description:
;
;    This routine outputs the given write buffer to the parallel port
;    using the standard centronics protocol.
;
;Arguments:
;
;    Controller  - Supplies the base address of the parallel port.
;
;    WriteBuffer - Supplies the buffer to write to the port.
;
;    NumBytesToWrite - Supplies the number of bytes to write out to the port.
;
;Return Value:
;
;    The number of bytes successfully written out to the parallel port.
;
;Notes:
;
;    This routine runs at DISPATCH_LEVEL.
;
;--

Controller      equ [esp + 8]
WriteBuffer     equ [esp + 12]
NumBytesToWrite equ [esp + 16]

cPublicProc _ParWriteLoop, 3
cPublicFpo 3, 1

        push ebx
        mov edx,Controller          ; Set up DX for OUT
        mov ecx,NumBytesToWrite     ; Set up CX for LOOP
        mov ebx,WriteBuffer         ; Start of write buffer

        inc edx                     ; Point to status register

align 4
@@:

; Get the status lines, read until two sucessive reads are the same.

        in al,dx
        mov ah,al
        in al,dx
        cmp al,ah
        jnz @b

; Check the status lines.

        xor al,L_INVERT
        and al,L_NOT_READY
        jnz short @f                ; If the printer isn't ready then abort

; Output a character to the printer

        mov al,[ebx]
        dec edx                     ; Point to data register
        inc ebx
        out dx,al                   ; Set data lines
        add edx,2                   ; Point to control register
        mov al,L_STROBE
        out dx,al                   ; Turn strobe on
        mov al,L_NORMAL
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        out dx,al                   ; Turn strobe off
        dec edx                     ; Point to status register

        dec ecx
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jmp $+2
        jnz short @b                ; Continue until ECX = 0

@@:

; return the number of bytes output in EAX

        mov eax,NumBytesToWrite     ; Put 'NumBytesToWrite' in EAX
        sub eax,ecx                 ; Subtract the number of bytes not written
        pop ebx

        stdRET    _ParWriteLoop

stdENDP _ParWriteLoop

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\thread.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       thread.c
//
//--------------------------------------------------------------------------

//
// This file contains functions associated with ParClass worker threads
//

#include "pch.h"
#include "readwrit.h"

VOID
ParallelThread(
    IN PVOID Context
    )

/*++

Routine Description:

    This is the parallel thread routine.  Loops performing I/O operations.

Arguments:

    Context -- Really the extension

Return Value:

    None

--*/

{
    
    PDEVICE_EXTENSION   Extension;
    LONG                ThreadPriority;
    KIRQL               OldIrql;
    NTSTATUS            Status;
    LARGE_INTEGER       Timeout;
    PIRP                CurrentIrp;
    BOOLEAN             bRetry = TRUE;  // REVISIT, dvrh's big usbly hack.

    Extension = Context;

    ParDumpV( ("Enter ParallelThread(...) - %wZ\r\n",
               &Extension->SymbolicLinkName) );

    //
    // Lower ourselves down just at tad so that we compete a
    // little less.
    //
    // If the registry indicates we should be running at the old
    // priority, don't lower our priority as much.
    //

    ThreadPriority = -2;

    if(Extension->UseNT35Priority) {
        ThreadPriority = -1;
    }
    // dvtw, 
    // dvrh Wants higher prioroity on threads.
#if 0
    ThreadPriority = 16;
    KeSetBasePriorityThread(
        KeGetCurrentThread(),
        ThreadPriority
        );
#endif

    do {

        Timeout = Extension->IdleTimeout;
        // Timeout = - (250*10*1000);

// dvdr we try to aquire this twice after we have locked the port
// when we try to unlock the port this gets called also and we already have
// mutex so we hang
//        ExAcquireFastMutex (&Extension->LockPortMutex);
        
ParallelThread_WaitRetry:
        Status = KeWaitForSingleObject(
            &Extension->RequestSemaphore,
            UserRequest,
            KernelMode,
            FALSE,
            &Timeout
            );
// dvdr
//        ExReleaseFastMutex (&Extension->LockPortMutex);
        
        if (Status == STATUS_TIMEOUT) {

            if ((TRUE == Extension->P12843DL.bEventActive) ) {
                if (ParHaveReadData(Extension)) {
                    ParDump2(PARINFO, ("ParallelThread: Signaling Event [%x]\n", Extension->P12843DL.Event) );
                    // D D(("-- thread::timeout - set event\n"));
                    KeSetEvent(Extension->P12843DL.Event, 0, FALSE);
                    ParDump2(PARINFO, ("ParallelThread: Event was signaled\n") );
                }
            }

            // dvrh's big ugly hack
            if (Extension->IsCritical) {
                ParDumpV( ("We're critical and want to terminate threads\n") );
                if (bRetry) {
                    ParDumpV( ("Gonna give the thread more time\n") );
                    bRetry = FALSE;
                    goto ParallelThread_WaitRetry;
                }
                ParDumpV( ("Gonna hose our periph since we're killing threads\n") );
                //                __asm int 3   
            }
            // dvrh, Test hypothesis of potential port contention problems between
            // spooler and those going through.
            // if (!Extension->Connected)
            if (Extension->QueryNumWaiters(Extension->PortContext) != 0)
            {
#define PAR_USE_TERMINATE_FUNCTION 1
#if PAR_USE_TERMINATE_FUNCTION
                ParTerminate(Extension);
#else
                if (afpForward[Extension->IdxForwardProtocol].fnDisconnect)
                {
                    ParDump2(PARINFO, ("ParallelThread: STATUS_TIMEOUT: Calling afpForward.fnDisconnect\r\n"));
                    afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
                }
#endif
                ParFreePort(Extension);
                continue;
            }
        }

        // wait here if PnP has paused us (e.g., QUERY_STOP, STOP, QUERY_REMOVE)
        KeWaitForSingleObject(&Extension->PauseEvent, Executive, KernelMode, FALSE, 0);

        if ( Extension->TimeToTerminateThread ) {

            //
            // If we are currently connected...disconnect.
            //

            if (Extension->Connected) {

            #if PAR_USE_TERMINATE_FUNCTION
                ParTerminate(Extension);
            #else
                if (afpForward[Extension->IdxForwardProtocol].fnDisconnect)
                { 
                    ParDump2(PARINFO, ("ParallelThread: TimeToTerminateThread: Calling afpForward.fnDisconnect\r\n"));
                    afpForward[Extension->IdxForwardProtocol].fnDisconnect (Extension);
                }
            #endif
                    
                ParFreePort(Extension);
            }

            ParDumpV( ( "%wZ thread killing self\r\n", &Extension->SymbolicLinkName) );
            
            PsTerminateSystemThread( STATUS_SUCCESS );
        }

        //
        // While we are manipulating the queue we capture the
        // cancel spin lock.
        //

        IoAcquireCancelSpinLock(&OldIrql);

        ASSERT(!Extension->CurrentOpIrp);

        while (!IsListEmpty(&Extension->WorkQueue)) {

            // get next IRP from our list of work items
            PLIST_ENTRY HeadOfList;
            HeadOfList = RemoveHeadList(&Extension->WorkQueue);
            CurrentIrp = CONTAINING_RECORD(HeadOfList, IRP, Tail.Overlay.ListEntry);

            // we have started processing, this IRP can no longer be cancelled
            IoSetCancelRoutine(CurrentIrp, NULL);
            ASSERT(NULL == CurrentIrp->CancelRoutine);
            ASSERT(!CurrentIrp->Cancel);

            Extension->CurrentOpIrp = CurrentIrp;

            IoReleaseCancelSpinLock(OldIrql);

            //
            // Do the Io.
            //
            ParStartIo(Extension);

            if ((TRUE == Extension->P12843DL.bEventActive) && (ParHaveReadData(Extension))) {
                ParDump2(PARINFO, ("ParallelThread: Signaling Event [%x]\n", Extension->P12843DL.Event) );
                ASSERT(Extension->P12843DL.Event);
                KeSetEvent(Extension->P12843DL.Event, 0, FALSE);
                ParDump2(PARINFO, ("ParallelThread: Event was signaled\n") );
            }

            // wait here if PnP has paused us (e.g., QUERY_STOP, STOP, QUERY_REMOVE)
            KeWaitForSingleObject(&Extension->PauseEvent, Executive, KernelMode, FALSE, 0);

            IoAcquireCancelSpinLock(&OldIrql);
        }
        IoReleaseCancelSpinLock(OldIrql);

    } while (TRUE);
}

NTSTATUS
ParCreateSystemThread(
    PDEVICE_EXTENSION Extension
    )

{
    NTSTATUS        Status;
    HANDLE          ThreadHandle;
    OBJECT_ATTRIBUTES objAttrib;

    ParDump2(PARTHREAD, ("Enter ParCreateSystemThread(...)\r\n") );

    //
    // Start the thread and capture the thread handle into the extension
    //
    InitializeObjectAttributes( &objAttrib, NULL, OBJ_KERNEL_HANDLE, NULL, NULL );

    Status = PsCreateSystemThread( &ThreadHandle, THREAD_ALL_ACCESS, &objAttrib, NULL, NULL, 
                                   ParallelThread, Extension );

    if (!NT_ERROR(Status)) {

        //
        // We've got the thread.  Now get a pointer to it.
        //

        // assert that this DO does not already have a thread
        ASSERT(!Extension->ThreadObjectPointer);

        Status = ObReferenceObjectByHandle( ThreadHandle, THREAD_ALL_ACCESS, NULL, KernelMode,
                                            &Extension->ThreadObjectPointer, NULL );

        if (NT_ERROR(Status)) {

            ParDump2(PARTHREAD, ("Bad status on open from ref by handle: %x\r\n", Status) );

            Extension->TimeToTerminateThread = TRUE;

            KeReleaseSemaphore( &Extension->RequestSemaphore, 0, 1, FALSE );

        } else {

            //
            // Now that we have a reference to the thread
            // we can simply close the handle.
            //
            ZwClose(ThreadHandle);

        }

    } else {
        ParDump2(PARTHREAD, ("Bad status on open from ref by handle: %x\r\n", Status) );
    }

    return Status;
}

VOID
ParStartIo(
    IN  PDEVICE_EXTENSION   Extension
    )

/*++

Routine Description:

    This routine starts an I/O operation for the driver and
    then returns

Arguments:

    Extension - The parallel device extension

Return Value:

    None

--*/

{
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    KIRQL                   CancelIrql;
    NTSTATUS                NtStatus;

    // ParDumpV( ("Enter ParStartIo\r\n") );

    Irp = Extension->CurrentOpIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Information = 0;

    if (!Extension->Connected && !ParAllocPort(Extension)) {
        #pragma message( "dvrh Left bad stuff in thread.c") 
        ParDump2(PARTHREAD, ("Threads are hosed\n") );
        //        __asm int 3   
        //
        // If the allocation didn't succeed then fail this IRP.
        //
        goto CompleteIrp;
    }

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_WRITE:
            ParDump2(PARTHREAD, ("ParStartIo: IRP \t[%x]\t Calling ParWriteIrp\n", Irp) );
            ParTimerMainCheck( ("SIo: IRP \t[%x]\t Pre WrtIrp\r\n", Irp) );
            Extension->IsCritical = TRUE;
            ParWriteIrp(Extension);
            Extension->IsCritical = FALSE;
            ParTimerMainCheck( ("SIo: IRP \t[%x]\t Post WrtIrp\r\n", Irp) );
            break;

        case IRP_MJ_READ:
            ParDump2(PARTHREAD, ("ParStartIo: IRP \t[%x]\t Calling ParReadIrp\n", Irp) );
            ParTimerMainCheck( ("SIo: IRP \t[%x]\t Pre RdIrp\r\n", Irp) );
            Extension->IsCritical = TRUE;
            ParReadIrp(Extension);
            Extension->IsCritical = FALSE;
            ParTimerMainCheck( ("SIo: IRP \t[%x]\t Post RdIrp\r\n", Irp) );
            break;

        default:
            ParDump2(PARTHREAD, ("ParStartIo: IRP \t[%x]\t Calling ParDeviceIo\n", Irp) );
            ParTimerMainCheck( ("SIo: IRP \t[%x]\t Pre DevIo\r\n", Irp) );
            ParDeviceIo(Extension);
            ParTimerMainCheck( ("SIo: IRP \t[%x]\t Post DevIo\r\n", Irp) );
            break;

    }

    if (!Extension->Connected && !Extension->AllocatedByLockPort) {
    
        // if we're not connected in a 1284 mode, then release host port
        // otherwise let the watchdog timer do it.

        ParFreePort(Extension);
    }

CompleteIrp:

    IoAcquireCancelSpinLock(&CancelIrql);
    Extension->CurrentOpIrp = NULL;
    IoReleaseCancelSpinLock(CancelIrql);

    ParCompleteRequest(Irp, (CCHAR)(NT_SUCCESS(Irp->IoStatus.Status) ?
        IO_PARALLEL_INCREMENT : IO_NO_INCREMENT));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    util.c

Abstract:

    This module contains utility code used by other 1284 modules.

Author:

    Robbie Harris (Hewlett-Packard) 20-May-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
#include "ecp.h"

//============================================================================
// NAME:    BusReset()
//
//    Performs a bus reset as defined in Chapter 7.2 of the
//    1284-1994 spec.
//
// PARAMETERS:
//      DCRController   - Supplies the base address of of the DCR.
//
// RETURNS:
//      nothing
//============================================================================
void BusReset(
    IN  PUCHAR DCRController
    )
{
    UCHAR dcr;

    dcr = READ_PORT_UCHAR(DCRController);
    // Set 1284 and nInit low.
    dcr = UPDATE_DCR(dcr, DONT_CARE, DONT_CARE, INACTIVE, INACTIVE, DONT_CARE, DONT_CARE);
    WRITE_PORT_UCHAR(DCRController, dcr);
    KeStallExecutionProcessor(100); // Legacy Zip will hold what looks to be
                                    // a bus reset for 9us.  Since this proc is used
                                    // to trigger a logic analyzer... let's hold
                                    // for 100us
}    

BOOLEAN
CheckPort(
    IN  PUCHAR  wPortAddr,
    IN  UCHAR   bMask,
    IN  UCHAR   bValue,
    IN  USHORT  msTimeDelay
    )
/*++

Routine Description:
    This routine will loop for a given time period (actual time is
    passed in as an arguement) and wait for the dsr to match
    predetermined value (dsr value is passed in).

Arguments:
    wPortAddr   - Supplies the base address of the parallel port + some offset.
                  This will have us point directly to the dsr (controller + 1).
    bMask       - Mask used to determine which bits we are looking at
    bValue      - Value we are looking for.
    msTimeDelay - Max time to wait for peripheral response (in ms)

Return Value:
    TRUE if a dsr match was found.
    FALSE if the time period expired before a match was found.
--*/

{
    UCHAR  dsr;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;

    // Do a quick check in case we have one stinkingly fast peripheral!
    dsr = READ_PORT_UCHAR(wPortAddr);
    if ((dsr & bMask) == bValue)
        return TRUE;

    Wait.QuadPart = (msTimeDelay * 10 * 1000) + KeQueryTimeIncrement();
    KeQueryTickCount(&Start);

CheckPort_Start:
    KeQueryTickCount(&End);
    dsr = READ_PORT_UCHAR(wPortAddr);
    if ((dsr & bMask) == bValue)
        return TRUE;

    if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart)
    {
        // We timed out!!!

        // do one last check
        dsr = READ_PORT_UCHAR(wPortAddr);
        if ((dsr & bMask) == bValue)
            return TRUE;

        #if DVRH_BUS_RESET_ON_ERROR
            BusReset(wPortAddr+1);  // Pass in the dcr address
        #endif

        #if DBG
            ParDump2(PARERRORS, ("CheckPort: Timeout\n"));
            ParDump2(PARERRORS, ("<==========================================================\n"));
            {
                int i;

                for (i = 3; i < 8; i++) {
        
                    if ((bMask >> i) & 1) {
                    
                        if (((bValue >> i) & 1) !=  ((dsr >> i) & 1)) {
                        
                            ParDump2(PARERRORS, ("\t\t Bit %d is %d and should be %d!!!\n",
                                        i, (dsr >> i) & 1, (bValue >> i) & 1));
                        }
                    }
                }
            }
            ParDump2(PARERRORS, ("<==========================================================\n"));
        #endif
        goto CheckPort_TimeOut;
    }
    goto CheckPort_Start;

CheckPort_TimeOut:

    return FALSE;    
}


BOOLEAN
CheckTwoPorts(
    PUCHAR  pPortAddr1,
    UCHAR   bMask1,
    UCHAR   bValue1,
    PUCHAR  pPortAddr2,
    UCHAR   bMask2,
    UCHAR   bValue2,
    USHORT  msTimeDelay
    )
{
    int             i;
    UCHAR           bPort1;
    UCHAR           bPort2;
    LARGE_INTEGER   Wait;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;

    // Do a quick check in case we have one stinkingly fast peripheral!
    bPort1 = READ_PORT_UCHAR( pPortAddr1 );
    if ( ( bPort1 & bMask1 ) == bValue1 )
    {
        return TRUE;
    }
    bPort2 = READ_PORT_UCHAR( pPortAddr2 );
    if ( ( bPort2 & bMask2 ) == bValue2 )
    {
        return FALSE;
    }

    Wait.QuadPart = (msTimeDelay * 10 * 1000) + KeQueryTimeIncrement();
    KeQueryTickCount(&Start);

CheckTwoPorts_Start:
    KeQueryTickCount(&End);

    bPort1 = READ_PORT_UCHAR( pPortAddr1 );
    if ( ( bPort1 & bMask1 ) == bValue1 )
    {
        return TRUE;
    }
    bPort2 = READ_PORT_UCHAR( pPortAddr2 );
    if ( ( bPort2 & bMask2 ) == bValue2 )
    {
        return FALSE;
    }

    if ((End.QuadPart - Start.QuadPart) * KeQueryTimeIncrement() > Wait.QuadPart)
    {
        // We timed out!!!
        // Recheck the values
        bPort1 = READ_PORT_UCHAR( pPortAddr1 );
        if ( ( bPort1 & bMask1 ) == bValue1 )
        {
            return TRUE;
        }
        bPort2 = READ_PORT_UCHAR( pPortAddr2 );
        if ( ( bPort2 & bMask2 ) == bValue2 )
        {
            return FALSE;
        }

        #if DVRH_BUS_RESET_ON_ERROR
            BusReset(pPortAddr1+1);  // Pass in the dcr address
        #endif
        // Device never responded, return timeout status.
        return FALSE;
    }
    goto CheckTwoPorts_Start;

    return FALSE;
} // CheckPort2...


PWSTR
ParCreateWideStringFromUnicodeString(PUNICODE_STRING UnicodeString)
/*++

Routine Description:

    Create a UNICODE_NULL terminated WSTR given a UNICODE_STRING.

    This function allocates PagedPool, copies the UNICODE_STRING buffer
      to the allocation, and appends a UNICODE_NULL to terminate the WSTR
    
    *** This function allocates pool. ExFreePool must be called to free
          the allocation when the buffer is no longer needed.

Arguments:

    UnicodeString - The source

Return Value:

    PWSTR  - if successful

    NULL   - otherwise

--*/
{
    PWSTR buffer;
    ULONG length = UnicodeString->Length;

    buffer = ExAllocatePool( PagedPool, length + sizeof(UNICODE_NULL) );
    if(!buffer) {
        return NULL;      // unable to allocate pool, bail out
    } else {
        RtlCopyMemory(buffer, UnicodeString->Buffer, length);
        buffer[length/2] = UNICODE_NULL;
        return buffer;
    }
}

NTSTATUS
ParCreateDevice(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  ULONG           DeviceExtensionSize,
    IN  PUNICODE_STRING DeviceName OPTIONAL,
    IN  DEVICE_TYPE     DeviceType,
    IN  ULONG           DeviceCharacteristics,
    IN  BOOLEAN         Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    )
{
    NTSTATUS status;
    status = IoCreateDevice( DriverObject,
                             DeviceExtensionSize,
                             DeviceName,
                             DeviceType,
                             (DeviceCharacteristics | FILE_DEVICE_SECURE_OPEN),
                             Exclusive,
                             DeviceObject );
    return status;
}

VOID
ParInitializeExtension1284Info(
    IN PDEVICE_EXTENSION Extension
    )
// make this a function since it is now called from two places:
//  - 1) when initializing a new devobj
//  - 2) from CreateOpen
{
    USHORT i;

    Extension->Connected               = FALSE;
    if (DefaultModes)
    {
        USHORT rev = (USHORT) (DefaultModes & 0xffff);
        USHORT fwd = (USHORT)((DefaultModes & 0xffff0000)>>16);
        
        switch (fwd)
        {
            case BOUNDED_ECP:
                Extension->IdxForwardProtocol      = BOUNDED_ECP_FORWARD;       
                break;
            case ECP_HW_NOIRQ:
            case ECP_HW_IRQ:
                Extension->IdxForwardProtocol      = ECP_HW_FORWARD_NOIRQ;       
                break;
            case ECP_SW:
                Extension->IdxForwardProtocol      = ECP_SW_FORWARD;       
                break;
            case EPP_HW:
                Extension->IdxForwardProtocol      = EPP_HW_FORWARD;       
                break;
            case EPP_SW:
                Extension->IdxForwardProtocol      = EPP_SW_FORWARD;       
                break;
            case IEEE_COMPATIBILITY:
                Extension->IdxForwardProtocol      = IEEE_COMPAT_MODE;
                break;
            case CENTRONICS:
            default:
                Extension->IdxForwardProtocol      = CENTRONICS_MODE;       
                break;
        }
        
        switch (rev)
        {
            case BOUNDED_ECP:
                Extension->IdxReverseProtocol      = BOUNDED_ECP_REVERSE;       
                break;
            case ECP_HW_NOIRQ:
            case ECP_HW_IRQ:
                Extension->IdxReverseProtocol      = ECP_HW_REVERSE_NOIRQ;       
                break;
            case ECP_SW:
                Extension->IdxReverseProtocol      = ECP_SW_REVERSE;       
                break;
            case EPP_HW:
                Extension->IdxReverseProtocol      = EPP_HW_REVERSE;       
                break;
            case EPP_SW:
                Extension->IdxReverseProtocol      = EPP_SW_REVERSE;       
                break;
            case BYTE_BIDIR:
                Extension->IdxReverseProtocol      = BYTE_MODE;       
                break;
            case CHANNEL_NIBBLE:
            case NIBBLE:
            default:
                Extension->IdxReverseProtocol      = NIBBLE_MODE;
                break;
        }
    }
    else
    {
        Extension->IdxReverseProtocol      = NIBBLE_MODE;
        Extension->IdxForwardProtocol      = CENTRONICS_MODE;
    }
    Extension->bShadowBuffer           = FALSE;
    Extension->ProtocolModesSupported  = 0;
    Extension->BadProtocolModes        = 0;
    Extension->IsCritical              = FALSE;
#if (1 == DVRH_USE_CORRECT_PTRS)
    Extension->fnRead  = NULL;
    Extension->fnWrite = NULL;
    //        Extension->fnRead  = arpReverse[Extension->IdxReverseProtocol].fnRead;
    //        Extension->fnWrite = afpForward[Extension->IdxForwardProtocol].fnWrite;
#endif

    Extension->ForwardInterfaceAddress = DEFAULT_ECP_CHANNEL;
    Extension->ReverseInterfaceAddress = DEFAULT_ECP_CHANNEL;
    Extension->SetForwardAddress       = FALSE;
    Extension->SetReverseAddress       = FALSE;
    Extension->bIsHostRecoverSupported = FALSE;
    Extension->IsIeeeTerminateOk       = FALSE;

    for (i = FAMILY_NONE; i < FAMILY_MAX; i++) {
        Extension->ProtocolData[i] = 0;
    }
}

#if (1 == DVRH_DELAY_THEORY)
void DVRH_Diagnostic_Delay()
{
       LARGE_INTEGER Interval;

    //in 100ns increments
    Interval.QuadPart = 1000;
   KeDelayExecutionThread(
       KernelMode,
       FALSE,
       &Interval
       );
}
#endif

VOID
ParGetDriverParameterDword(
    IN     PUNICODE_STRING ServicePath,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    )
/*++

  Read registry DWORD from <ServicePath>\Parameters

--*/
{
    NTSTATUS                 status;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    PWSTR                    suffix       = L"\\Parameters";
    ULONG                    defaultValue;
    UNICODE_STRING           path         = {0,0,0};
    ULONG                    length;


    //
    // Sanity check parameters
    //
    if( ( NULL == ServicePath->Buffer ) || ( NULL == ParameterName ) || ( NULL == ParameterValue ) ) {
        return;
    }

    //
    // set up table entries for call to RtlQueryRegistryValues
    //
    RtlZeroMemory( paramTable, sizeof(paramTable));

    defaultValue = *ParameterValue;

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = ParameterName;
    paramTable[0].EntryContext  = ParameterValue;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &defaultValue;
    paramTable[0].DefaultLength = sizeof(ULONG);


    //
    // leave paramTable[2] as all zeros - this terminates the table
    //


    //
    // compute the size of the path including the "parameters" suffix
    //
    length = ( sizeof(WCHAR) * wcslen( suffix ) ) + sizeof(UNICODE_NULL);
    length += RegistryPath.Length;


    //
    // construct the path as: <ServiceName>\Parameters
    //
    path.Buffer = ExAllocatePool( PagedPool, length );
    if( NULL == path.Buffer ) {
        return;
    }

    RtlZeroMemory( path.Buffer, length );
    path.MaximumLength = (USHORT)length;
    RtlCopyUnicodeString( &path, &RegistryPath );
    RtlAppendUnicodeToString( &path, suffix );
    ParDump2(PARREG,("util::ParGetDriverParameterDword - path = <%wZ>\n", &path));

    ParDump2(PARREG,("util::ParGetDriverParameterDword - pre-query value = %x\n", *ParameterValue));

    //
    // query registry
    //
    status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     path.Buffer,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    RtlFreeUnicodeString( &path );

    ParDump2(PARREG,("util::ParGetDriverParameterDword - post-query value = %x\n", *ParameterValue));
    ParDump2(PARREG,("util::ParGetDriverParameterDword - status from RtlQueryRegistryValues on SubKey = %x\n", status) );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parclass\wmipdo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       wmipdo.h
//
//--------------------------------------------------------------------------

NTSTATUS
ParWmiPdoQueryWmiDataBlock(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  ULONG           GuidIndex,
    IN  ULONG           InstanceIndex,
    IN  ULONG           InstanceCount,
    IN  OUT PULONG      InstanceLengthArray,
    IN  ULONG           OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
ParWmiPdoQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  PDevObj, 
    OUT PULONG          PRegFlags,
    OUT PUNICODE_STRING PInstanceName,
    OUT PUNICODE_STRING *PRegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo 
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\byte.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    Byte.c

Abstract:

    This module contains the code to do byte mode reads.

Author:

    Don Redford 30-Aug-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"
    

BOOLEAN
ParIsByteSupported(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine determines whether or not byte mode is suported
    by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    NTSTATUS Status;
    
    if (Pdx->BadProtocolModes & BYTE_BIDIR) {
        DD((PCE)Pdx,DDT,"ParIsByteSupported - BAD PROTOCOL\n");
        return FALSE;
    }

    if (!(Pdx->HardwareCapabilities & PPT_BYTE_PRESENT)) {
        DD((PCE)Pdx,DDT,"ParIsByteSupported - NO\n");
        return FALSE;
    }

    if (Pdx->ProtocolModesSupported & BYTE_BIDIR) {
        DD((PCE)Pdx,DDT,"ParIsByteSupported - Already Checked - YES\n");
        return TRUE;
    }

    // Must use Byte Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    Status = ParEnterByteMode (Pdx, FALSE);
    ParTerminateByteMode (Pdx);
    
    if (NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDT,"ParIsByteSupported - SUCCESS\n");
        Pdx->ProtocolModesSupported |= BYTE_BIDIR;
        return TRUE;
    }
   
    DD((PCE)Pdx,DDT,"ParIsByteSupported - UNSUCCESSFUL\n");
    return FALSE;    
}

NTSTATUS
ParEnterByteMode(
    IN  PPDO_EXTENSION   Pdx,
    IN  BOOLEAN             DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    byte mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - Supplies whether or not this is a request for a device
                        id.

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    
    // Make sure Byte mode Harware is still there
    Status = Pdx->TrySetChipMode( Pdx->PortContext, ECR_BYTE_PIO_MODE );
    
    if( NT_SUCCESS(Status) ) {

        if ( SAFE_MODE == Pdx->ModeSafety ) {

            if( DeviceIdRequest ) {
                // RMT - not sure if we want to support non-nibble 1284 ID query
                Status = IeeeEnter1284Mode( Pdx, BYTE_EXTENSIBILITY | DEVICE_ID_REQ );
            } else {
                Status = IeeeEnter1284Mode( Pdx, BYTE_EXTENSIBILITY );
            }

        } else {
            // UNSAFE_MODE
            Pdx->Connected = TRUE;
        }

    }
    
    if (NT_SUCCESS(Status)) {

        P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
        Pdx->IsIeeeTerminateOk = TRUE;

    } else {

        ParTerminateByteMode ( Pdx );
        P5SetPhase( Pdx, PHASE_UNKNOWN );
        Pdx->IsIeeeTerminateOk = FALSE;
    }

    DD((PCE)Pdx,DDT,"ParEnterByteMode - exit w/Status=%x\n",Status);
    
    return Status; 
}    

VOID
ParTerminateByteMode(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    if ( Pdx->ModeSafety == SAFE_MODE ) {

        IeeeTerminate1284Mode( Pdx );

    } else {

        Pdx->Connected = FALSE;

    }

    Pdx->ClearChipMode( Pdx->PortContext, ECR_BYTE_PIO_MODE );

    DD((PCE)Pdx,DDT,"ParTerminateByteMode - exit\n");
}

NTSTATUS
ParByteModeRead(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
/*++

Routine Description:

    This routine performs a 1284 byte mode read into the given
    buffer for no more than 'BufferSize' bytes.

Arguments:

    Pdx           - Supplies the device extension.

    Buffer              - Supplies the buffer to read into.

    BufferSize          - Supplies the number of bytes in the buffer.

    BytesTransferred     - Returns the number of bytes transferred.

--*/
{
    PUCHAR          Controller;    
    NTSTATUS        Status = STATUS_SUCCESS;
    PUCHAR          lpsBufPtr = (PUCHAR)Buffer;
    ULONG           i;
    UCHAR           dsr, dcr;
    UCHAR           HDReady, HDAck, HDFinished;

    Controller = Pdx->Controller;

    // Read Byte according to 1284 spec.
    DD((PCE)Pdx,DDT,"ParByteModeRead: Start\n");

    dcr = GetControl (Controller);

    // Set Direction to be in reverse
    dcr |= DCR_DIRECTION;
    StoreControl (Controller, dcr);    

    HDReady = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, INACTIVE, ACTIVE );
    HDAck = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, ACTIVE, INACTIVE );
    HDFinished = SET_DCR( ACTIVE, INACTIVE, ACTIVE, INACTIVE, ACTIVE, ACTIVE );

    switch( Pdx->CurrentPhase ) {
    
        case PHASE_REVERSE_IDLE:

            // Check to see if the peripheral has indicated Interrupt Phase and if so, 
            // get us ready to reverse transfer.

            for (;;) {

                // See if data is available (looking for state 7)
                dsr = GetStatus(Controller);

                if (dsr & DSR_NOT_DATA_AVAIL) {

                    // Data is NOT available - do nothing
                    // The device doesn't report any data, it still looks like it is
                    // in ReverseIdle.  Just to make sure it hasn't powered off or somehow
                    // jumped out of Byte mode, test also for AckDataReq high and XFlag low
                    // and nDataAvaul high.
                    if( (dsr & DSR_BYTE_VALIDATION) != DSR_BYTE_TEST_RESULT ) {

                        Status = STATUS_IO_DEVICE_ERROR;
                        P5SetPhase( Pdx, PHASE_UNKNOWN );

                        DD((PCE)Pdx,DDE,"ParByteModeRead - Failed State 7 - dcr=%x\n",dcr);
                    }
                    goto ByteReadExit;

                } else {

                    // Data is available, go to Reverse Transfer Phase
                    P5SetPhase( Pdx, PHASE_REVERSE_XFER);
                    // Go to Reverse XFER phase
                    goto PhaseReverseXfer;
                }

            }
        
PhaseReverseXfer:

        case PHASE_REVERSE_XFER: 
        
            for (i = 0; i < BufferSize; i++) {
            
                // Host enters state 7
                StoreControl (Controller, HDReady);

                // =============== Periph State 9     ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = low (signals state 9)
                // nAckReverse/AckDataReq   = Don't Care
                // XFlag                    = Don't Care
                // nPeriphReq/nDataAvail    = Don't Care
                if (!CHECK_DSR(Controller, DONT_CARE, INACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL)) {
                    // Time out.
                    // Bad things happened - timed out on this state,
                    // Mark Status as bad and let our mgr kill current mode.
                    Status = STATUS_IO_DEVICE_ERROR;

                    DD((PCE)Pdx,DDE,"ParByteModeRead - Failed State 9 - dcr=%x\n",dcr);
                    P5SetPhase( Pdx, PHASE_UNKNOWN );
                    goto ByteReadExit;
                }

                // Read the Byte                
                P5ReadPortBufferUchar( Controller, lpsBufPtr++, (ULONG)0x01 );

                // Set host lines to indicate state 10.
                StoreControl (Controller, HDAck);

                // =============== Periph State 11     ===============8
                // PeriphAck/PtrBusy        = Don't Care
                // PeriphClk/PtrClk         = High (signals state 11)
                // nAckReverse/AckDataReq   = Don't Care
                // XFlag                    = Don't Care
                // nPeriphReq/nDataAvail    = Don't Care
                if( !CHECK_DSR(Controller, DONT_CARE, ACTIVE, DONT_CARE, DONT_CARE, DONT_CARE, IEEE_MAXTIME_TL)) {
                    // Time out.
                    // Bad things happened - timed out on this state,
                    // Mark Status as bad and let our mgr kill current mode.
                    Status = STATUS_IO_DEVICE_ERROR;

                    DD((PCE)Pdx,DDE,"ParByteModeRead - Failed State 11 - dcr=%x\n",dcr);
                    P5SetPhase( Pdx, PHASE_UNKNOWN );
                    goto ByteReadExit;
                }


                // Set host lines to indicate state 16.
                StoreControl (Controller, HDFinished);

                // At this point, we've either received the number of bytes we
                // were looking for, or the peripheral has no more data to
                // send, or there was an error of some sort (of course, in the
                // error case we shouldn't get to this comment).  Set the
                // phase to indicate reverse idle if no data available or
                // reverse data transfer if there's some waiting for us
                // to get next time.

                dsr = GetStatus(Controller);
                
                if (dsr & DSR_NOT_DATA_AVAIL) {
                
                    // Data is NOT available - go to Reverse Idle
                    // Really we are going to HBDNA, but if we set
                    // current phase to reverse idle, the next time
                    // we get into this function all we have to do
                    // is set hostbusy low to indicate idle and
                    // we have infinite time to do that.
                    // Break out of the loop so we don't try to read
                    // data that isn't there.
                    // NOTE - this is a successful case even if we
                    // didn't read all that the caller requested
                    P5SetPhase( Pdx, PHASE_REVERSE_IDLE );
                    i++; // account for this last byte transferred
                    break;

                } else {
                    // Data is available, go to (remain in ) Reverse Transfer Phase
                    P5SetPhase( Pdx, PHASE_REVERSE_XFER);
                }

            } // end for i loop

            *BytesTransferred = i;

            dsr = GetStatus(Controller);

            // DON'T FALL THRU THIS ONE
            break;

        default:
        
            Status = STATUS_IO_DEVICE_ERROR;
            P5SetPhase( Pdx, PHASE_UNKNOWN );

            DD((PCE)Pdx,DDE,"ParByteModeRead:Failed State 9: Unknown Phase - dcr=%x\n",dcr);
            goto ByteReadExit;

    } // end switch

ByteReadExit:

    if( Pdx->CurrentPhase == PHASE_REVERSE_IDLE ) {
        // Host enters state 7  - officially in Reverse Idle now
        dcr |= DCR_NOT_HOST_BUSY;

        StoreControl (Controller, dcr);
    }

    // Set Direction to be in forward
    dcr &= ~DCR_DIRECTION;
    StoreControl (Controller, dcr);    

    DD((PCE)Pdx,DDT,"ParByteModeRead - exit, status=%x, bytes read=%d\n", Status, *BytesTransferred);
    Pdx->log.ByteReadCount += *BytesTransferred;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\debug.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       debug.c
//
//--------------------------------------------------------------------------

#include "pch.h"


// Diagnostic globals - used during development
ULONG d1;
ULONG d2;
ULONG d3;
ULONG d4;
ULONG d5;
ULONG d6;
ULONG d7;
ULONG d8;
ULONG d9;

// Debug globals
ULONG Trace;
ULONG Break;
ULONG AllowAsserts = 0;

//
// set bits using PPT_DD_* bit defs to mask off debug spew for a specific device
//
ULONG DbgMaskFdo         = 0;
ULONG DbgMaskRawPort     = 0;
ULONG DbgMaskDaisyChain0 = 0;
ULONG DbgMaskDaisyChain1 = 0;
ULONG DbgMaskEndOfChain  = 0;
ULONG DbgMaskLegacyZip   = 0;
ULONG DbgMaskNoDevice    = 0;

PCHAR PnpIrpName[] = {
    "0x00 - IRP_MN_START_DEVICE",
    "0x01 - IRP_MN_QUERY_REMOVE_DEVICE",
    "0x02 - IRP_MN_REMOVE_DEVICE",
    "0x03 - IRP_MN_CANCEL_REMOVE_DEVICE",
    "0x04 - IRP_MN_STOP_DEVICE",
    "0x05 - IRP_MN_QUERY_STOP_DEVICE",
    "0x06 - IRP_MN_CANCEL_STOP_DEVICE",
    "0x07 - IRP_MN_QUERY_DEVICE_RELATIONS",
    "0x08 - IRP_MN_QUERY_INTERFACE",
    "0x09 - IRP_MN_QUERY_CAPABILITIES",
    "0x0A - IRP_MN_QUERY_RESOURCES",
    "0x0B - IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
    "0x0C - IRP_MN_QUERY_DEVICE_TEXT",
    "0x0D - IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
    "0x0E - unused Pnp MinorFunction",
    "0x0F - IRP_MN_READ_CONFIG",
    "0x10 - IRP_MN_WRITE_CONFIG",
    "0x11 - IRP_MN_EJECT",
    "0x12 - IRP_MN_SET_LOCK",
    "0x13 - IRP_MN_QUERY_ID",
    "0x14 - IRP_MN_QUERY_PNP_DEVICE_STATE",
    "0x15 - IRP_MN_QUERY_BUS_INFORMATION",
    "0x16 - IRP_MN_DEVICE_USAGE_NOTIFICATION",
    "0x17 - IRP_MN_SURPRISE_REMOVAL",
    "0x18 - IRP_MN_QUERY_LEGACY_BUS_INFORMATION"
};

PCHAR PhaseName[] = {
    "PHASE_UNKNOWN",
    "PHASE_NEGOTIATION",
    "PHASE_SETUP",                    // Used in ECP mode only
    "PHASE_FORWARD_IDLE",
    "PHASE_FORWARD_XFER",
    "PHASE_FWD_TO_REV",
    "PHASE_REVERSE_IDLE",
    "PHASE_REVERSE_XFER",
    "PHASE_REV_TO_FWD",
    "PHASE_TERMINATE",
    "PHASE_DATA_AVAILABLE",           // Used in nibble and byte modes only
    "PHASE_DATA_NOT_AVAIL",           // Used in nibble and byte modes only
    "PHASE_INTERRUPT_HOST"            // Used in nibble and byte modes only
};

#if 1 == DBG_SHOW_BYTES
ULONG DbgShowBytes = 1; // turn off via reg setting: Services\Parport\Parameters\DbgShowBytes : REG_DWORD : 0x0 
#endif

#if 1 == PptEnableDebugSpew
VOID
P5TraceIrpArrival( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PCOMMON_EXTENSION cdx = DevObj->DeviceExtension;
    DD(cdx,DDE,"Irp arrival %x\n",Irp);
}

VOID
P5TraceIrpCompletion( PIRP Irp ) {
    //PCOMMON_EXTENSION cdx = DevObj->DeviceExtension;
    DD(NULL,DDE,"Irp completion %x\n",Irp);
}

VOID
P5SetPhase( PPDO_EXTENSION Pdx, P1284_PHASE Phase ) {
    LARGE_INTEGER tickCount;
    KeQueryTickCount( &tickCount );
    if( Pdx->CurrentPhase != Phase ) {
        Pdx->CurrentPhase = Phase;
        PptAssert(Phase < arraysize(PhaseName));
        DD((PCE)Pdx,DDT,"P5SetPhase at %I64x to %2d - %s\n",tickCount,Phase,PhaseName[Phase]);
    }
}

VOID
P5BSetPhase( PIEEE_STATE IeeeState, P1284_PHASE Phase ) {
    LARGE_INTEGER tickCount;
    KeQueryTickCount( &tickCount );
    if( IeeeState->CurrentPhase != Phase ) {
        IeeeState->CurrentPhase = Phase;
        PptAssert(Phase < arraysize(PhaseName));
        DD(NULL,DDT,"P5BSetPhase at %I64x to %2d - %s\n",tickCount,Phase,PhaseName[Phase]);
    }
}

#include "stdarg.h"
VOID
PptPrint( PCOMMON_EXTENSION Ext, ULONG Flags, PCHAR FmtStr, ... )
{
    CHAR            buf[ 256 ];
    LONG            count;
    va_list         va;
    const LONG      bufSize           = sizeof(buf);
    const LONG      maxLocationLength = sizeof("LPTx.y: ");
    ULONG           trace;
    ULONG           mask;
    PPDO_EXTENSION  pdx;
    PCHAR           location;

    PptAssertMsg( "0 == Flags", Flags );
    PptAssertMsg( "NULL FmtStr", FmtStr );

    if( Ext ) {

        location = Ext->Location;

        if( (NULL == location) || ('\0' == *location) ) {
            location = "NoLoc";
        }

        switch( Ext->DevType ) {
            
        case DevTypeFdo:
            mask = DbgMaskFdo;
            break;
            
        case DevTypePdo:
            pdx = (PPDO_EXTENSION)Ext;
            
            switch( pdx->PdoType ) {
                
            case PdoTypeRawPort:
                mask = DbgMaskRawPort;
                break;
                
            case PdoTypeEndOfChain:
                mask = DbgMaskEndOfChain;
                break;
                
            case PdoTypeDaisyChain:
                
                switch( pdx->Ieee1284_3DeviceId ) {
                case 0:
                    mask = DbgMaskDaisyChain0;
                    break;
                case 1:
                    mask = DbgMaskDaisyChain1;
                    break;
                default:
                    mask = 0;
                    PptAssert(FALSE);
                }
                break;
                
            case PdoTypeLegacyZip:
                mask = DbgMaskLegacyZip;
                break;
                
            default:
                // PptAssertMsg( "Invalid PdoType", FALSE );
                mask = 0;
            }
            break;
            
        default:
            // PptAssert(FALSE);
            mask = 0;
        }

    } else {

        // not device specific
        location = "LPTx";
        mask = DbgMaskNoDevice;

    }

    trace = Flags & Trace & ~mask;

    if( trace != 0 ) {

        va_start( va, FmtStr );
        
        __try {
            
            count  = _snprintf( buf, maxLocationLength, "%-6s: ", location );
            if( count < 0 ) {
                __leave;
            }
            
            count += _vsnprintf( buf+count, bufSize-count-1, FmtStr, va );
            if( count >= bufSize ) {
                __leave;
            }
            
            DbgPrint( "%s", buf );

        } 
        __finally {
            va_end( va );
        }

    } // endif ( trace != 0 )
        
    return;
}

UCHAR
P5ReadPortUchar( PUCHAR Port ) {
    UCHAR value;
    value = READ_PORT_UCHAR( Port );
    if( d1 ) {
        DbgPrint("zzz - READ_ PORT_UCHAR %x %02x\n",Port,value);
    }
    return value;
}

VOID
P5ReadPortBufferUchar( PUCHAR Port, PUCHAR Buffer, ULONG Count ) {
    READ_PORT_BUFFER_UCHAR( Port, Buffer, Count );
    return;
}

VOID
P5WritePortUchar( PUCHAR Port, UCHAR Value ) {
    if( d1 ) {
        DbgPrint("zzz - WRITE_PORT_UCHAR %x %02x\n",Port,Value);
    }

    WRITE_PORT_UCHAR( Port, Value );
    return;
}

VOID
P5WritePortBufferUchar( PUCHAR Port, PUCHAR Buffer, ULONG Count )
{
    WRITE_PORT_BUFFER_UCHAR( Port, Buffer, Count );
    return;
}

VOID
PptFdoDumpPnpIrpInfo(
    PDEVICE_OBJECT Fdo,
    PIRP Irp
    ) 
{
    PFDO_EXTENSION      fdx           = Fdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp         = IoGetCurrentIrpStackLocation( Irp );
    ULONG               minorFunction = irpSp->MinorFunction;

    PptAssert( DevTypeFdo == fdx->DevType );

    if( minorFunction < arraysize(PnpIrpName) ) {
        DD((PCE)fdx,DDT,"PptFdoDumpPnpIrpInfo - %s\n",PnpIrpName[ minorFunction ]);
    } else {
        DD((PCE)fdx,DDT,"PptFdoDumpPnpIrpInfo - bogus MinorFunction = %x\n",minorFunction);
    }
}

VOID
PptPdoDumpPnpIrpInfo(
    PDEVICE_OBJECT Pdo,
    PIRP Irp
    ) 
{
    PPDO_EXTENSION      pdx           = Pdo->DeviceExtension;
    PIO_STACK_LOCATION  irpSp         = IoGetCurrentIrpStackLocation( Irp );
    ULONG               minorFunction = irpSp->MinorFunction;

    PptAssert( DevTypePdo == pdx->DevType );

    if( minorFunction < arraysize(PnpIrpName) ) {
        DD((PCE)pdx,DDT,"PptPdoDumpPnpIrpInfo - %s\n",PnpIrpName[ minorFunction ]);
    } else {
        DD((PCE)pdx,DDT,"PptPdoDumpPnpIrpInfo - bogus MinorFunction = %x\n",minorFunction);
    }
}

NTSTATUS
PptAcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    )
{
    return IoAcquireRemoveLock(RemoveLock, Tag);
}

VOID
PptReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag OPTIONAL
    )
{
    IoReleaseRemoveLock(RemoveLock, Tag);
}

VOID
PptReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID           Tag
    )
{
    IoReleaseRemoveLockAndWait(RemoveLock, Tag);
}
#endif // 1 == PptEnableDebugSpew



#if (1 == DVRH_PAR_LOGFILE)

#include "stdarg.h"

/**************************************************************************
Function:	DVRH_LogMessage()
Description:Logs message to configured output
Inputs:		Parameter indicated message log level and 
			Format string and parameters
Outputs:	Boolean value indicating success or failure
***************************************************************************/
BOOLEAN DVRH_LogMessage(PCHAR szFormat, ...)
{
    ULONG Length;
    char messagebuf[256];
    va_list va;
    IO_STATUS_BLOCK  IoStatus;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE FileHandle;
    UNICODE_STRING fileName;
    
    //format the string
    va_start(va,szFormat);
    _vsnprintf(messagebuf,sizeof(messagebuf),szFormat,va);
    va_end(va);
    
    //get a handle to the log file object
    fileName.Buffer = NULL;
    fileName.Length = 0;
    fileName.MaximumLength = sizeof(DEFAULT_LOG_FILE_NAME) + sizeof(UNICODE_NULL);
    fileName.Buffer = ExAllocatePool(PagedPool,
                                     fileName.MaximumLength);
    if (!fileName.Buffer) {
        DD(NULL,DDE,"LogMessage: FAIL. ExAllocatePool Failed.\n");
        return FALSE;
    }
    RtlZeroMemory(fileName.Buffer, fileName.MaximumLength);
    status = RtlAppendUnicodeToString(&fileName, (PWSTR)DEFAULT_LOG_FILE_NAME);
    
    InitializeObjectAttributes (&objectAttributes,
                                (PUNICODE_STRING)&fileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );
    
    status = ZwCreateFile( &FileHandle,
                           FILE_APPEND_DATA,
                           &objectAttributes,
                           &IoStatus,
                           0, 
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,     
                           0 );
    
    if( NT_SUCCESS(status) ) {
        CHAR buf[300];
        LARGE_INTEGER time;
        KeQuerySystemTime(&time);
        
        //put a time stamp on the output message
        sprintf(buf,"%10u-%10u  %s",time.HighPart,time.LowPart,messagebuf);
        
        //format the string to make sure it appends a newline carrage-return to the 
        //end of the string.
        Length=strlen(buf);
        if( buf[Length-1]=='\n' ) {
            buf[Length-1]='\r';
            strcat(buf,"\n");
            Length++;
        } else {
            strcat(buf,"\r\n");
            Length+=2;
        }
        
        ZwWriteFile( FileHandle, NULL, NULL, NULL, &IoStatus, buf, Length, NULL, NULL );
        
        ZwClose( FileHandle );
    }

    if( fileName.Buffer ) {
        ExFreePool (fileName.Buffer);
    }

    return STATUS_SUCCESS;
}

/**************************************************************************
Function:	DVRH_LogByteData()
Description:Formats byte data to be displayed in the configured output
Inputs:		Log level, Whether this is input or output data, a pointer to
			the byte data buffer and the size of the buffer
Outputs:	Boolean indicated success or failure
***************************************************************************/
BOOLEAN DVRH_LogByteData(BOOLEAN READ,PCHAR szBuff,ULONG dwTransferred)
{
	CString	cStr;
	ULONG MAX_SIZE=80;
	UNICODE_STRING UniStr;
	ANSI_STRING AnsiStr;
	WCHAR wStr[8];
	PCHAR   szTemp=szBuff;
	UCHAR   bTemp;  
	ULONG	dwDisplaySize;

	UniStr.Length=0;
	UniStr.MaximumLength=8;
	UniStr.Buffer=wStr;
	AnsiStr.Length=0;
	AnsiStr.MaximumLength=0;
	AnsiStr.Buffer=NULL;

	if(READ)
		cStr=L"<RCV";
	else            
		cStr=L"SND>";

	//make sure the size of the requested string is within the set range
	dwDisplaySize=(((dwTransferred*3)+10) > MAX_SIZE)?((MAX_SIZE-10)/3):dwTransferred;

	//format byte data
	while(dwDisplaySize)
	{   
		bTemp=szTemp[0];
		if(bTemp > 0xF)
			cStr+=L" ";
		else
			cStr+=L" 0";

		RtlIntegerToUnicodeString(bTemp,16,&UniStr);
        		
		cStr+=UniStr.Buffer;

		szTemp++;
		dwDisplaySize--;
	}

	cStr.StringToAnsiString(&AnsiStr);
	LogMessage("%5u %s",dwTransferred,AnsiStr.Buffer);
	RtlFreeAnsiString(&AnsiStr);

	return (TRUE);
}
#endif // (1 == DVRH_PAR_LOGFILE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\daisychain.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    par12843.c

Abstract:

    This is the main module for 1284.3 functionality.  These
      function enable the selection and deselection of 1284.3
      compatable devices on the parallel port.

    The devices can be selected and deselected IRQL <= DISPATCH_LEVEL 
    by calling IOCTL_INTERNAL_SELECT_DEVICE, or 'TrySelectDevice'.
    The first call is the simplest:  the IRP will be queued in the
    parallel port driver until the port is free and then it will 
    try to select the device with the given ID from the structure
    PARALLEL_1284_COMMAND.  If successful it will with a successful 
    status, otherwise it will return with an unsuccessful status.
    The class driver may cancel this IRP at any time which serves 
    as a mechanism to timeout an allocate request.

    The 'TrySelectDevice' call returns immediately from the port
    driver with a TRUE status if the port was allocated and the
    device was able to be selected or a FALSE status if the port 
    was either busy or the device was not able to be selected.

    Once the device is selected, the port is owned by the selecting class
    driver until a 'DeselectDevice' call is made.  This deselects the
    device and also releases the port and wakes up the next caller.

Author:

    Don E. Redford  3-Mar-1998

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

ULONG
PptInitiate1284_3(
    IN  PVOID   Extension
    );

NTSTATUS
PptTrySelectDevice(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    );

NTSTATUS
PptDeselectDevice(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    );

ULONG
Ppt1284_3AssignAddress(
    IN  PFDO_EXTENSION    DeviceExtension
    );

BOOLEAN
PptSend1284_3Command(
    IN  PUCHAR  CurrentPort,
    IN  UCHAR   Command
    );

BOOLEAN
PptCheckIfStl1284_3(
    IN PFDO_EXTENSION    DeviceExtension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    );

BOOLEAN
PptCheckIfNon1284_3Present(
    IN PFDO_EXTENSION    Extension
    );

BOOLEAN
PptCheckIfStlProductId(
    IN PFDO_EXTENSION    Extension,
    IN ULONG   ulDaisyIndex
    );
//
// Beginning of functions
//

ULONG
PptInitiate1284_3(
    IN  PVOID   Extension
    )

/*++

Routine Description:

    This routine initializes all of the 1284.3 devices out on the
    given parallel port.  It does this by assigning 1284.3 addresses to
    each device on the port.

Arguments:

    Extensioon    - Device extension structure.

Return Value:

    None.

--*/

{
    ULONG deviceCount1 = 0;
    ULONG deviceCount2 = 0;
    ULONG loopCount    = 0;
    ULONG maxTries     = 3; // picked 3 out of thin air as a "reasonable" value

    // Send command to assign addresses and count number of 1284.3 daisy chain devices 
    // Try multiple times to make sure we get the same count
    do {

        KeStallExecutionProcessor( 5 );
        deviceCount1 = Ppt1284_3AssignAddress( Extension );

        KeStallExecutionProcessor( 5 );
        deviceCount2 = Ppt1284_3AssignAddress( Extension );

        if( deviceCount1 != deviceCount2 ) {
            DD((PCE)Extension,DDW,"PptInitiate1284_3 - count unstable\n");
            PptAssert(deviceCount1 == deviceCount2);
        }

    } while( (deviceCount1 != deviceCount2) && (++loopCount < maxTries) );

    return deviceCount2;
}

NTSTATUS
PptTrySelectDevice(
    IN  PVOID   Context,
    IN  PVOID   TrySelectCommand
    )
/*++

Routine Description:

    This routine first tries to allocate the port.  If successful
      it will then try to select  the device with the ID given.

Arguments:

    Extension   -   Driver extension.
    Device      -   1284.3 Device Id.
    Command     -   Command to know whether to allocate the port

Return Value:

    TRUE            -  Able to allocate the port and select the device
    FALSE           -  1: Invalid ID    2: Not able to allocate port    3: Not able to select device

--*/
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    PFDO_EXTENSION           Extension = Context;
    PPARALLEL_1284_COMMAND      Command = TrySelectCommand;
    BOOLEAN                     success = FALSE;
    SYNCHRONIZED_COUNT_CONTEXT  SyncContext;
    KIRQL                       CancelIrql;
    UCHAR                       i, DeviceID;

    if( ( Command->CommandFlags & PAR_LEGACY_ZIP_DRIVE ) ||
        ( Command->ID == DOT3_LEGACY_ZIP_ID )) {
        Status = PptTrySelectLegacyZip(Context, TrySelectCommand);
        DD((PCE)Extension,DDT,"PptTrySelectDevice - LegacyZip - status=%x\n",Status);
        return Status;
    }

    // get device ID to select
    DeviceID = Command->ID;
            
    // validate parameters - we will accept:
    //   - a Dot3 device with a valid DeviceID
    //   - an End-of-Chain device indicated by the PAR_END_OF_CHAIN_DEVICE flag, or
    //   - an End-of-Chain device indicated by a DeviceID value one past the last Dot3 device

    if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) && DeviceID > Extension->PnpInfo.Ieee1284_3DeviceCount ) {
                
        // Requested device is not flagged as End-of-Chain device and DeviceID
        //   is more than one past the end of the Dot3 Devices, so FAIL the IRP
        DD((PCE)Extension,DDE,"PptTrySelectDevice - FAIL - invalid DeviceID parameter\n",DeviceID);
        PptAssertMsg("PptTrySelectDevice - FAIL - invalid DeviceID parameter",FALSE);
        Status = STATUS_INVALID_PARAMETER;
                
    } else {
                
        //
        // Request appears valid
        //

        // test to see if we need to grab port
        if( Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT ) {

            //
            // requester has already acquired port, just do a SELECT
            //
            if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) &&
                    DeviceID < Extension->PnpInfo.Ieee1284_3DeviceCount ) {

                // SELECT the device
                for ( i = 0; i < PptDot3Retries && !success; i++ ) {
                    // Send command to to select device in compatability mode
                    success = PptSend1284_3Command( Extension->PortInfo.Controller, (UCHAR)(CPP_SELECT | DeviceID) );
                    // Stall a little in case we have to retry
                    KeStallExecutionProcessor( 5 );
                }                

                if ( success ) {
                    DD((PCE)Extension,DDT,"PptTrySelectDevice - had port - SUCCESS\n");
                    Status = STATUS_SUCCESS;
                } else {
                    DD((PCE)Extension,DDW,"PptTrySelectDevice - FAIL\n");
                    Status = STATUS_UNSUCCESSFUL;
                }
            } else {
                // End-of-Chain device, no SELECT required, SUCCEED the request
                DD((PCE)Extension,DDT,"PptTrySelectDevice - EOC\n");
                Status = STATUS_SUCCESS;
            }

        } else {

            // Don't have the port

            //
            // Try to acquire port and select device
            //
            IoAcquireCancelSpinLock(&CancelIrql);
                
            SyncContext.Count = &Extension->WorkQueueCount;
                    
            if (Extension->InterruptRefCount) {
                KeSynchronizeExecution(Extension->InterruptObject, PptSynchronizedIncrement, &SyncContext);
            } else {
                PptSynchronizedIncrement(&SyncContext);
            }
                    
            if (SyncContext.NewCount) {
                // Port is busy, queue request
                DD((PCE)Extension,DDT,"PptTrySelectDevice - Port Busy - Request Queued\n");
                IoReleaseCancelSpinLock(CancelIrql);
                Status = STATUS_PENDING;

            } else {

                IoReleaseCancelSpinLock(CancelIrql);
                        
                // Port is acquired
                DD((PCE)Extension,DDT,"PptTrySelectDevice - Port Acquired\n");

                Extension->WmiPortAllocFreeCounts.PortAllocates++;

                if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) && DeviceID < Extension->PnpInfo.Ieee1284_3DeviceCount ) {
                            
                    // SELECT the device
                    for ( i = 0; i < PptDot3Retries && !success; i++ ) {
                        // Send command to to select device in compatability mode
                        success = PptSend1284_3Command( Extension->PortInfo.Controller, (UCHAR)(CPP_SELECT | DeviceID) );
                        // Stall a little in case we have to retry
                        KeStallExecutionProcessor( 5 );
                    }                

                    if ( success ) {
                        DD((PCE)Extension,DDT,"PptTrySelectDevice - SUCCESS\n");
                        Status = STATUS_SUCCESS;
                    } else {
                        DD((PCE)Extension,DDW,"PptTrySelectDevice - FAILED\n");

                        // RMT - 000831 - do we still have the port locked!?! - did we hang the port?

                        Status = STATUS_UNSUCCESSFUL;
                    }

                } else {
                    // End-of-Chain device, no SELECT required, SUCCEED the request
                    DD((PCE)Extension,DDT,"PptTrySelectDevice - EOC2\n");
                    Status = STATUS_SUCCESS;
                }

            }  // endif - test for port busy
                    
        } // endif - test if already have port

    } // endif - test for valid parameters

    return Status;
}

NTSTATUS
PptDeselectDevice(
    IN  PVOID   Context,
    IN  PVOID   DeselectCommand
    )
    
/*++

Routine Description:

    This routine deselects the current device and then frees the port

Arguments:


Return Value:

    TRUE            -  Able to deselect the device and free the port
    FALSE           -  1: Invalid ID    2: Not able to deselect the drive

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PFDO_EXTENSION       fdx = Context;
    PPARALLEL_1284_COMMAND  Command = DeselectCommand;
    BOOLEAN                 success = FALSE;
    UCHAR                   i, DeviceID;

    if( ( Command->CommandFlags & PAR_LEGACY_ZIP_DRIVE ) ||
        ( Command->ID == DOT3_LEGACY_ZIP_ID ) ) {
        return PptDeselectLegacyZip( Context, DeselectCommand );
    }

    // get device ID to deselect
    DeviceID = Command->ID;

    // validate ID
    if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) && DeviceID > fdx->PnpInfo.Ieee1284_3DeviceCount ) {

        // not End-of-Chain device and Dot3 DeviceID is invalid
        DD((PCE)fdx,DDE,"PptDeselectDevice - ID=%d - FAIL - invalid parameter\n",DeviceID);
        Status = STATUS_INVALID_PARAMETER;
                
    } else {
                
        // Check for End-of-Chain device
        if ( !(Command->CommandFlags & PAR_END_OF_CHAIN_DEVICE) &&
                DeviceID < fdx->PnpInfo.Ieee1284_3DeviceCount ) {
                    
            // first deselect the device 
            for ( i = 0; i < PptDot3Retries && !success; i++ ) {
                success = PptSend1284_3Command( fdx->PortInfo.Controller, (UCHAR)CPP_DESELECT );
                // Stall a little in case we have to retry
                KeStallExecutionProcessor( 5 );
            }

            if ( success ) {
                // Deselecting device was a success
                DD((PCE)fdx,DDT,"PptDeselectDevice\n");

                // check if requester wants to keep port or free port
                if( !(Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT) ) {
                    PptFreePort( fdx );
                }
                Status = STATUS_SUCCESS;
                        
            } else {
                // Unable to deselect device, something went very wrong,
                //   port is now in an unknown/blocked state
                DD((PCE)fdx,DDE,"PptDeselectDevice - ID=%d - FAIL\n",DeviceID);
                PptAssertMsg("PptDeselectDevice - FAIL - port in unknown state",FALSE);
                Status = STATUS_UNSUCCESSFUL;
            }
                    
        } else {

            // this is End-of-Chain device so no deselect neccessary
            DD((PCE)fdx,DDT,"PptDeselectDevice - End-of-Chain - SUCCESS\n",DeviceID);

            // check if requester wants to keep port or free port
            if( !(Command->CommandFlags & PAR_HAVE_PORT_KEEP_PORT) ) {
                PptFreePort( fdx );
            }
            Status = STATUS_SUCCESS;

        }  // endif - Check if End Of Chain

    } // endif - Validate ID

    return Status;
}


ULONG
Ppt1284_3AssignAddress(
    IN  PFDO_EXTENSION    DeviceExtension
    )

/*++

Routine Description:

    This routine initializes the 1284_3 bus.

Arguments:

    DeviceExtension    - Supplies Device Extension structure of the driver.

Return Value:

    Number of 1284.3 devices out there at the given address.

--*/

{

    //UCHAR  i, ii, value, newvalue, status;
    UCHAR  i, value, newvalue, status;
    PUCHAR CurrentPort, CurrentStatus, CurrentControl;
    ULONG  Delay = 5;
    UCHAR  number = 0;
    BOOLEAN lastdevice = FALSE;
    UCHAR   idx;

    CurrentPort = DeviceExtension->PortInfo.Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                // Device is out there
                KeStallExecutionProcessor( Delay );

                while ( number < 4 && !lastdevice ) {

                    // Asssign address byte
                    P5WritePortUchar( CurrentPort, number );
                    number = (UCHAR)(number + 1);

                    KeStallExecutionProcessor( Delay );                    // wait a bit
                    if ( (P5ReadPortUchar( CurrentStatus ) & (UCHAR)DSR_NOT_BUSY ) == 0 ) {
                        // we saw last device
                        lastdevice = TRUE;    
                    }

                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    KeStallExecutionProcessor( Delay );        // wait a bit
                }

                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

                if ( number ) {
                    BOOLEAN bStlNon1284_3Found ;
                    BOOLEAN bStlNon1284_3Valid ;
                    bStlNon1284_3Found = PptCheckIfNon1284_3Present(DeviceExtension);
                    bStlNon1284_3Valid = FALSE ;
                    // as the earlier 1284 spec does not give the
                    // lastdevice status is BSY, number needs to
                    // be corrected in such cases
                    for ( idx = 0 ; idx < number ; idx++ ) {
                        if ( TRUE == PptCheckIfStl1284_3(DeviceExtension, idx, bStlNon1284_3Found ) ) {
                            continue ;
                        }
                        if ( TRUE == bStlNon1284_3Found ) {
                            if ( TRUE == PptCheckIfStlProductId(DeviceExtension, idx) ) {
                                bStlNon1284_3Valid = TRUE ;
                                continue ;
                            }
                        }
                        break ;
                    }
                    if ( TRUE == bStlNon1284_3Valid ) {
                        // we alter the count only if old adapters
                        // are in the chain
                        number = idx;
                    }
                }

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    // returns last device ID + 1 or number of devices out there
    return ( (ULONG)number );

}

BOOLEAN
PptCheckIfNon1284_3Present(
    IN PFDO_EXTENSION    Extension
    )
/*++

Routine Description:

    Indicates whether one of the devices of the earlier
    specification is present in the chain.


Arguments:

    Extension   - Device Extension structure


Return Value:

    TRUE    : Atleast one of the adapters are of earlier spec.
    FALSE   : None of the adapters of the earlier spec.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;
    UCHAR   ucAckStatus ;

    CurrentPort = Extension->PortInfo.Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        ucAckStatus = status & 0x40 ;

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            if ( ucAckStatus != ( status & 0x40 ) ) {

                // save current ack status
                ucAckStatus = status & 0x40 ;

                // continue with sixth byte
                P5WritePortUchar( CurrentPort, ModeQualifier[5] );
                KeStallExecutionProcessor( Delay );

                // check for correct status
                status = P5ReadPortUchar( CurrentStatus );

                // if status is valid there is a device out there responding
                if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                    bReturnValue = TRUE ;

                } // Third status

            } // ack of earlier adapters not seen

            // last byte
            P5WritePortUchar( CurrentPort, ModeQualifier[6] );

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // PptCheckIfNon1284_3Present


// Define 1284 Commands
#define CPP_QUERY_PRODID    0x10

// 1284 related SHTL prod id equates
#define SHTL_EPAT_PRODID    0xAAFF
#define SHTL_EPST_PRODID    0xA8FF

BOOLEAN
PptCheckIfStl1284_3(
    IN PFDO_EXTENSION    DeviceExtension,
    IN ULONG    ulDaisyIndex,
    IN BOOLEAN  bNoStrobe
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle 1284_3 type of device. 

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

    bNoStrobe       - If set, indicates that the query
                      Ep1284 command issued by this function
                      need not assert strobe to latch the
                      command.

Return Value:

    TRUE            - Yes. Device is Shuttle 1284_3 type of device.
    FALSE           - No. This may mean that this device is either
                      non-shuttle or Shuttle non-1284_3 type of
                      device.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucExpectedPattern ;
    UCHAR   ucReadValue, ucReadPattern;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = DeviceExtension->PortInfo.Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {        

                // Device is out there
                KeStallExecutionProcessor( Delay );

                // issue shuttle specific CPP command
                P5WritePortUchar( CurrentPort, (UCHAR) ( 0x88 | ulDaisyIndex ) );
                KeStallExecutionProcessor( Delay );        // wait a bit

                if ( ulDaisyIndex && ( bNoStrobe == FALSE ) ) {

                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                    KeStallExecutionProcessor( Delay );        // wait a bit

                }

                ucExpectedPattern = 0xF0 ;
                bReturnValue = TRUE ;

                while ( ucExpectedPattern ) {

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentPort, (UCHAR) (0x80 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    P5WritePortUchar( CurrentPort, (UCHAR) (0x88 | ulDaisyIndex )) ;

                    KeStallExecutionProcessor( Delay );        // wait a bit
                    ucReadValue = P5ReadPortUchar( CurrentStatus ) ;
                    ucReadPattern = ( ucReadValue << 1 ) & 0x70 ;
                    ucReadPattern |= ( ucReadValue & 0x80 ) ;

                    if ( ucReadPattern != ucExpectedPattern ) {
                        // not Shuttle 1284_3 behaviour
                        bReturnValue = FALSE ;
                        break ;
                    }

                    ucExpectedPattern -= 0x10 ;
                }


                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // end  PptCheckIfStl1284_3()

BOOLEAN
PptCheckIfStlProductId(
    IN PFDO_EXTENSION    DeviceExtension,
    IN ULONG   ulDaisyIndex
    )
/*++

Routine Description:

    This function checks to see whether the device indicated
    is a Shuttle non-1284_3 type of device. 

Arguments:

    Extension       - Device extension structure.

    ulDaisyIndex    - The daisy chain id of the device that
                      this function will check on.

Return Value:

    TRUE            - Yes. Device is Shuttle non-1284_3 type of device.
    FALSE           - No. This may mean that this device is 
                      non-shuttle.

--*/
{
    BOOLEAN bReturnValue = FALSE ;
    UCHAR   i, value, newvalue, status;
    ULONG   Delay = 3;
    UCHAR   ucProdIdHiByteHiNibble, ucProdIdHiByteLoNibble ;
    UCHAR   ucProdIdLoByteHiNibble, ucProdIdLoByteLoNibble ;
    UCHAR   ucProdIdHiByte, ucProdIdLoByte ;
    USHORT  usProdId ;
    PUCHAR  CurrentPort, CurrentStatus, CurrentControl;

    CurrentPort = DeviceExtension->PortInfo.Controller;
    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );

    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);

    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );    // make sure we can write 

    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );

    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }

    // check for correct status
    status = P5ReadPortUchar( CurrentStatus );

    if ( (status & (UCHAR)0xb8 ) 
         == ( DSR_NOT_BUSY | DSR_PERROR | DSR_SELECT | DSR_NOT_FAULT )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );

        // check for correct status
        status = P5ReadPortUchar( CurrentStatus );

        // note busy is high too but is opposite so we see it as a low
        if (( status & (UCHAR) 0xb8 ) == (DSR_SELECT | DSR_NOT_FAULT)) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );

            // check for correct status
            status = P5ReadPortUchar( CurrentStatus );

            // if status is valid there is a device out there responding
            if ((status & (UCHAR) 0x30 ) == ( DSR_PERROR | DSR_SELECT )) {

                P5WritePortUchar ( CurrentPort, (UCHAR) (CPP_QUERY_PRODID | ulDaisyIndex )) ;
                KeStallExecutionProcessor( Delay );

                // Device is out there
                KeStallExecutionProcessor( Delay );
                ucProdIdLoByteHiNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdLoByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdLoByteLoNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdLoByteLoNibble >>= 4 ;
                ucProdIdLoByte = ucProdIdLoByteHiNibble | ucProdIdLoByteLoNibble ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteHiNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdHiByteHiNibble &= 0xF0 ;

                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                ucProdIdHiByteLoNibble = P5ReadPortUchar( CurrentStatus ) ;
                ucProdIdHiByteLoNibble >>= 4 ;
                ucProdIdHiByte = ucProdIdHiByteHiNibble | ucProdIdHiByteLoNibble ;

                // issue the last strobe
                KeStallExecutionProcessor( Delay );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                usProdId = ( ucProdIdHiByte << 8 ) | ucProdIdLoByte ;

                if ( ( SHTL_EPAT_PRODID == usProdId ) ||\
                     ( SHTL_EPST_PRODID == usProdId ) ) {
                    // one of the devices that conform to the earlier
                    // draft is found
                    bReturnValue = TRUE ;
                }

                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status

        } // Second status

    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    return bReturnValue ;
} // end  PptCheckIfStlProductId()

BOOLEAN
PptSend1284_3Command(
    IN  PUCHAR  CurrentPort,
    IN  UCHAR   Command
    )
/*++

Routine Description:

    This routine sends the 1284_3 Command given to it
    down the parallel bus.

Arguments:


Return Value:

    None.

--*/
{
    UCHAR  i, value, newvalue, test;//, status;
    ULONG  ii;
    PUCHAR CurrentStatus, CurrentControl;
    ULONG  Delay = 3;
    BOOLEAN success = FALSE;

    CurrentStatus  = CurrentPort + 1;
    CurrentControl = CurrentPort + 2;

    // Get Upper 4 bits to see what Command it is
    test = (UCHAR)(Command & (UCHAR)CPP_COMMAND_FILTER);

    // get current ctl reg
    value = P5ReadPortUchar( CurrentControl );
    
    // make sure 1284.3 devices do not get reseted
    newvalue = (UCHAR)((value & ~DCR_SELECT_IN) | DCR_NOT_INIT);
    
    // make sure we can write
    newvalue = (UCHAR)(newvalue & ~DCR_DIRECTION);
    P5WritePortUchar( CurrentControl, newvalue );       // make sure we can write 
    
    // bring nStrobe high
    P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );
    KeStallExecutionProcessor( Delay );
    
    // send first four bytes of the 1284.3 mode qualifier sequence out
    for ( i = 0; i < MODE_LEN_1284_3 - 3; i++ ) {
        P5WritePortUchar( CurrentPort, ModeQualifier[i] );
        KeStallExecutionProcessor( Delay );
    }
    
    // wait up to 5 us : Spec says about 2 but we will be lienient
    if (CHECK_DSR(CurrentPort, INACTIVE, DONT_CARE, ACTIVE, ACTIVE, ACTIVE, 5 )) {

        // continue with fifth byte of mode qualifier
        P5WritePortUchar( CurrentPort, ModeQualifier[4] );
        KeStallExecutionProcessor( Delay );
        
        // wait up to 5 us : Spec says about 2 but we will be lienient
        if (CHECK_DSR(CurrentPort, ACTIVE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE, 5 )) {

            // continue with sixth byte
            P5WritePortUchar( CurrentPort, ModeQualifier[5] );
            KeStallExecutionProcessor( Delay );
            
            // wait up to 5 us : Spec says about 2 but we will be lienient
            if (CHECK_DSR(CurrentPort, DONT_CARE, DONT_CARE, ACTIVE, ACTIVE, DONT_CARE, 5 )) {

                // Device is out there
                
                KeStallExecutionProcessor( Delay );

                // Command byte
                P5WritePortUchar( CurrentPort, Command );
                KeStallExecutionProcessor( Delay );        // wait a bit

                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue | DCR_STROBE) );    // bring nStrobe low
                KeStallExecutionProcessor( Delay );        // wait a bit

                // NOTE NOTE NOTE
                // Assertion of strobe to be done ONLY after checking for the
                // FAULT feedback, as per the 1284_3 specification.

                // Selection does not work correctly yet to be able to check for lines
                switch ( test ) {
                    
                case CPP_SELECT:
                    // Check to make sure we are selected

                    // wait for upto 250 micro Secs for for selection time out.
                    for ( ii = 25000; ii > 0; ii-- ) {
                        
                        if ( ( P5ReadPortUchar( CurrentStatus ) & DSR_NOT_FAULT ) == DSR_NOT_FAULT ) {
                            // selection...
                            success = TRUE;
                            break;
                        }
                    }
                    break;

                case CPP_DESELECT:
                    // Check to make sure we are deselected                    

                    // wait for upto 250 micro Secs for for deselection time out.
                    for ( ii = 25000; ii > 0; ii-- ) {

                        if ( (P5ReadPortUchar( CurrentStatus ) & DSR_NOT_FAULT) != DSR_NOT_FAULT ) {
                            // deselection...
                            success = TRUE;
                            break;
                        }
                    }
                    break;

                default :
                    // there is a device out there and Command completed sucessfully
                    KeStallExecutionProcessor( Delay );        // wait a bit
                    success = TRUE;
                    break;

                } // End Switch

                // NOTE NOTE NOTE
                // the strobe is de-asserted now and the command is completed here
                P5WritePortUchar( CurrentControl, (UCHAR)(newvalue & ~DCR_STROBE) );    // bring nStrobe high
                KeStallExecutionProcessor( Delay );        // wait a bit

                // last byte
                P5WritePortUchar( CurrentPort, ModeQualifier[6] );

            } // Third status
            
        } // Second status
        
    } // First status

    P5WritePortUchar( CurrentControl, value );    // restore everything

    // return TRUE if command succeeded, FALSE otherwise
    return success;
}


BOOLEAN
ParSelectDevice(
    IN  PPDO_EXTENSION  Pdx,
    IN  BOOLEAN         HavePort
    )

/*++

Routine Description:

    This routine acquires the ParPort and selects a 1284.3 device

Arguments:

    Pdx   - Supplies the device extension.

    HavePort    - TRUE  indicates that caller has already acquired port
                    so we should only do a SELECT_DEVICE
                - FALSE indicates that caller has not already acquired port
                    so we should do a combination ACQUIRE_PORT/SELECT_DEVICE

Return Value:

    TRUE    - success - the device was selected (and port acquired if needed)
    FALSE   - failure

--*/
{
    NTSTATUS                    status;
    PDEVICE_OBJECT              pPortDeviceObject;
    PARALLEL_1284_COMMAND       par1284Command;
    LARGE_INTEGER               timeOut;
    enum _PdoType               pdoType;

    //
    // Initialize command structure and extract parameters from the DeviceExtension
    //

    // reserved - always set to 0
    par1284Command.Port = 0;

    if( HavePort ) {
        par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    } else {
        par1284Command.CommandFlags = 0;
    }

    pdoType = Pdx->PdoType;
    switch( pdoType ) {
    case PdoTypeRawPort:
    case PdoTypeEndOfChain:
        par1284Command.ID = 0; // ignored, but set anyway
        par1284Command.CommandFlags |= PAR_END_OF_CHAIN_DEVICE;
        break;
    case PdoTypeLegacyZip:
        par1284Command.ID = DOT3_LEGACY_ZIP_ID;
        break;
    case PdoTypeDaisyChain:
        par1284Command.ID = Pdx->Ieee1284_3DeviceId;
        break;
    default:
        DD((PCE)Pdx,DDE,"Invalid pdoType = %x\n",pdoType);
        PptAssert(FALSE);
        break;
    }

    pPortDeviceObject = Pdx->PortDeviceObject;

    //
    // Send the request
    //
    timeOut.QuadPart = -(10*1000*500); // 500ms ( 100ns units )

    status = ParBuildSendInternalIoctl(IOCTL_INTERNAL_SELECT_DEVICE,
                                       pPortDeviceObject,
                                       &par1284Command, sizeof(PARALLEL_1284_COMMAND),
                                       NULL, 0,
                                       &timeOut);

    if( NT_SUCCESS( status ) ) {
        // SELECT succeeded
        DD((PCE)Pdx,DDT,"ParSelectDevice - SUCCESS\n");
        if( !HavePort ) {
            // note in the device extension that we have the port
            Pdx->bAllocated = TRUE;
        }
        return TRUE;
    } else {
        // SELECT failed
        DD((PCE)Pdx,DDT,"ParSelectDevice - FAIL\n");
        return FALSE;
    }
}

BOOLEAN
ParDeselectDevice(
    IN  PPDO_EXTENSION  Pdx,
    IN  BOOLEAN         KeepPort
    )
/*++

Routine Description:

    This routine deselects a 1284.3 or Legacy Zip device and optionally
    releases the ParPort

Arguments:

    Pdx   - Supplies the device extension.

    KeepPort    - TRUE  indicates that we should keep the port acquired,
                    so we should only do a DESELECT_DEVICE
                - FALSE indicates that we should not keep the port acquired,
                    so we should do a combination DESELECT_DEVICE/FREE_PORT

Return Value:

    TRUE    - The device was deselected (and the port released if requested)

--*/
{
    PARALLEL_1284_COMMAND       par1284Command;
    NTSTATUS                    status;
    enum _PdoType               pdoType;
    PDEVICE_OBJECT              fdo = Pdx->Fdo;
    PFDO_EXTENSION              fdx = fdo->DeviceExtension;

    //
    // If we don't have the port, succeed and return
    //
    if( !Pdx->bAllocated ) {
        DD((PCE)Pdx,DDW,"ParDeselectDevice - we do not have the port\n");
        return TRUE;
    }

    //
    // Initialize command structure and extract parameters from the DeviceExtension
    //

    // reserved - always set to 0
    par1284Command.Port = 0;

    if( KeepPort ) {
        par1284Command.CommandFlags = PAR_HAVE_PORT_KEEP_PORT;
    } else {
        par1284Command.CommandFlags = 0;
    }

    pdoType = Pdx->PdoType;
    switch( pdoType ) {
    case PdoTypeRawPort:
    case PdoTypeEndOfChain:
        par1284Command.ID = 0; // ignored, but set anyway
        par1284Command.CommandFlags |= PAR_END_OF_CHAIN_DEVICE;
        break;
    case PdoTypeLegacyZip:
        par1284Command.ID = DOT3_LEGACY_ZIP_ID;
        break;
    case PdoTypeDaisyChain:
        par1284Command.ID = Pdx->Ieee1284_3DeviceId;
        break;
    default:
        DD((PCE)Pdx,DDE,"Invalid pdoType = %x\n",pdoType);
        par1284Command.ID = 0; // choose a 1284.3 type deselect since this is harmless
        PptAssert(FALSE);
        break;
    }

    status = PptDeselectDevice( fdx, &par1284Command );

    if( status != STATUS_SUCCESS ) {
        // DESELECT failed?!? - there isn't anything that we can do
        DD((PCE)Pdx,DDE,"ParDeselectDevice - FAILED - nothing we can do - status=%x\n", status);
    } else {
        DD((PCE)Pdx,DDT,"ParDeselectDevice - SUCCESS\n", status);
    }

    if( !KeepPort ) {
        // note in the device extension that we gave up the port
        DD((PCE)Pdx,DDT,"ParDeselectDevice - gave up port\n");
        Pdx->bAllocated = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\datalink.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    p12843dl.c

Abstract:

    This module contains utility code used by 1284.3 Data Link.

Author:

    Robbie Harris (Hewlett-Packard) 10-September-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

UCHAR Dot3_StartOfFrame1 = 0x55;  
UCHAR Dot3_StartOfFrame2 = 0xaa;  
UCHAR Dot3_EndOfFrame1 = 0x00; 
UCHAR Dot3_EndOfFrame2 = 0xff; 


NTSTATUS
ParDot3Connect(
    IN  PPDO_EXTENSION    Pdx
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ParFwdSkip = 0, ParRevSkip = 0;
    ULONG ParResetChannel = (ULONG)~0, ParResetByteCount = 4, ParResetByte = 0;
    ULONG ParSkipDefault = 0;
    ULONG ParResetChannelDefault = (ULONG)~0;

    // If an MLC device hangs we can sometimes wake it up by wacking it with 
    //   4 Zeros sent to the reset channel (typically 78 or 0x4E). Make this
    //   configurable via registry setting.
    ULONG ParResetByteCountDefault = 4; // from MLC spec
    ULONG ParResetByteDefault      = 0; // from MLC spec

    BOOLEAN bConsiderEppDangerous = FALSE;

    DD((PCE)Pdx,DDT,"ParDot3Connect: enter\n");

    if (P12843DL_OFF == Pdx->P12843DL.DataLinkMode) {
        DD((PCE)Pdx,DDT,"ParDot3Connect: Neither Dot3 or MLC are supported - FAIL request\n");
        return STATUS_UNSUCCESSFUL;
    }

    if (Pdx->P12843DL.bEventActive) {
        DD((PCE)Pdx,DDT,"ParDot3Connect: Already connected - FAIL request\n");
        return STATUS_UNSUCCESSFUL;
    }

    // Let's get a Device Id so we can pull settings for this device
    ParTerminate(Pdx);

    {   // local block

        PCHAR                     buffer                    = NULL;
        ULONG                     bufferLength;
        UCHAR                     resultString[MAX_ID_SIZE];
        ANSI_STRING               AnsiIdString;
        UNICODE_STRING            UnicodeTemp;
        RTL_QUERY_REGISTRY_TABLE  paramTable[6];
        UNICODE_STRING            Dot3Key;
        USHORT                    Dot3NameSize;
        NTSTATUS                  status;

        RtlZeroMemory(resultString, MAX_ID_SIZE);
        // ask the device how large of a buffer is needed to hold it's raw device id
        if ( Pdx->Ieee1284Flags & ( 1 << Pdx->Ieee1284_3DeviceId ) ) {
            buffer = Par3QueryDeviceId(Pdx, NULL, 0, &bufferLength, FALSE, TRUE);
        } else{
            buffer = Par3QueryDeviceId(Pdx, NULL, 0, &bufferLength, FALSE, FALSE);
        }
        if( !buffer ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - Couldn't alloc pool for DevId - FAIL request\n");
            return STATUS_UNSUCCESSFUL;
        }

        DD((PCE)Pdx,DDT,"ParDot3Connect - 1284 ID string = <%s>\n",buffer);

        // extract the part of the ID that we want from the raw string 
        //   returned by the hardware
        Status = ParPnpGetId( buffer, BusQueryDeviceID, (PCHAR)resultString, NULL );
        StringSubst( (PCHAR)resultString, ' ', '_', (USHORT)strlen((const PCHAR)resultString) );

        DD((PCE)Pdx,DDT,"ParDot3Connect: resultString Post StringSubst = <%s>\n",resultString);

        // were we able to extract the info that we want from the raw ID string?
        if( !NT_SUCCESS(Status) ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - Call to ParPnpGetId Failed - FAIL request\n");
            if( buffer ) {
                ExFreePool( buffer );
            }
            return STATUS_UNSUCCESSFUL;
        }

        // Does the ID that we just retrieved from the device match the one 
        //   that we previously saved in the device extension?
        if(0 != strcmp( (const PCHAR)Pdx->DeviceIdString, (const PCHAR)resultString)) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - strcmp shows NO MATCH\n");
            // DVDF - we may want to trigger a reenumeration since we know that the device changed
        }

        // Ok, now we have what we need to look in the registry
        // and pull some prefs.
        RtlZeroMemory(&paramTable[0], sizeof(paramTable));
        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = (PWSTR)L"ParFwdSkip";
        paramTable[0].EntryContext  = &ParFwdSkip;
        paramTable[0].DefaultType   = REG_DWORD;
        paramTable[0].DefaultData   = &ParSkipDefault;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = (PWSTR)L"ParRevSkip";
        paramTable[1].EntryContext  = &ParRevSkip;
        paramTable[1].DefaultType   = REG_DWORD;
        paramTable[1].DefaultData   = &ParSkipDefault;
        paramTable[1].DefaultLength = sizeof(ULONG);

        paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[2].Name          = (PWSTR)L"ParRC";
        paramTable[2].EntryContext  = &ParResetChannel;
        paramTable[2].DefaultType   = REG_DWORD;
        paramTable[2].DefaultData   = &ParResetChannelDefault;
        paramTable[2].DefaultLength = sizeof(ULONG);

        paramTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[3].Name          = (PWSTR)L"ParRBC";
        paramTable[3].EntryContext  = &ParResetByteCount;
        paramTable[3].DefaultType   = REG_DWORD;
        paramTable[3].DefaultData   = &ParResetByteCountDefault;
        paramTable[3].DefaultLength = sizeof(ULONG);

        paramTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[4].Name          = (PWSTR)L"ParRBD";
        paramTable[4].EntryContext  = &ParResetByte;
        paramTable[4].DefaultType   = REG_DWORD;
        paramTable[4].DefaultData   = &ParResetByteDefault;
        paramTable[4].DefaultLength = sizeof(ULONG);

        Dot3Key.Buffer = NULL;
        Dot3Key.Length = 0;
        Dot3NameSize = sizeof(L"Dot3\\") + sizeof(UNICODE_NULL);
        Dot3Key.MaximumLength = (USHORT)( Dot3NameSize + (sizeof(resultString) * sizeof(WCHAR)) );
        Dot3Key.Buffer = ExAllocatePool(PagedPool,
                                            Dot3Key.MaximumLength);
        if( !Dot3Key.Buffer ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - ExAllocatePool for Registry Check failed - FAIL request\n");
            if( buffer ) {
                ExFreePool( buffer );
            }
            return STATUS_UNSUCCESSFUL;
        }

        DD((PCE)Pdx,DDT,"ParDot3Connect: ready to Zero buffer, &Dot3Key= %x , MaximumLength=%d\n",&Dot3Key, Dot3Key.MaximumLength);
        RtlZeroMemory(Dot3Key.Buffer, Dot3Key.MaximumLength);

        status = RtlAppendUnicodeToString(&Dot3Key, (PWSTR)L"Dot3\\");
        ASSERT( NT_SUCCESS(status) );

        DD((PCE)Pdx,DDT,"ParDot3Connect:\"UNICODE\" Dot3Key S  = <%S>\n",Dot3Key.Buffer);
        DD((PCE)Pdx,DDT,"ParDot3Connect:\"UNICODE\" Dot3Key wZ = <%wZ>\n",&Dot3Key);
        DD((PCE)Pdx,DDT,"ParDot3Connect:\"RAW\" resultString string = <%s>\n",resultString);

        RtlInitAnsiString(&AnsiIdString,(const PCHAR)resultString);

        status = RtlAnsiStringToUnicodeString(&UnicodeTemp,&AnsiIdString,TRUE);
        if( NT_SUCCESS( status ) ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect:\"UNICODE\" UnicodeTemp = <%S>\n",UnicodeTemp.Buffer);

            Dot3Key.Buffer[(Dot3NameSize / sizeof(WCHAR)) - 1] = UNICODE_NULL;
            DD((PCE)Pdx,DDT,"ParDot3Connect:\"UNICODE\" Dot3Key (preappend)  = <%S>\n",Dot3Key.Buffer);

            status = RtlAppendUnicodeStringToString(&Dot3Key, &UnicodeTemp);
            if( NT_SUCCESS( status ) ) {
                DD((PCE)Pdx,DDT,"ParDot3Connect: ready to call RtlQuery...\n");
                Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL, Dot3Key.Buffer, &paramTable[0], NULL, NULL);
                DD((PCE)Pdx,DDT,"ParDot3Connect: RtlQueryRegistryValues Status = %x\n",Status);
            }
            
            RtlFreeUnicodeString(&UnicodeTemp);
        }

        if( Dot3Key.Buffer ) {
            ExFreePool (Dot3Key.Buffer);
        }

        // no longer needed
        ExFreePool(buffer);
        if (!NT_SUCCESS(Status)) {
            // registry read failed
            DD((PCE)Pdx,DDT,"ParDot3Connect: No Periph Defaults in Registry\n");
            DD((PCE)Pdx,DDT,"ParDot3Connect: No Periph Defaults in Registry\n");
            // registry read failed, use defaults and consider EPP to be dangerous
            ParRevSkip = ParFwdSkip = ParSkipDefault;
            bConsiderEppDangerous = TRUE; 
        }

        DD((PCE)Pdx,DDT,"ParDot3Connect: pre IeeeNegotiateBestMode\n");
        // if we don't have registry overrides then use what the
        // peripheral told us otherwise stick with defaults.
        if (ParSkipDefault == ParRevSkip) {
            ParRevSkip = Pdx->P12843DL.RevSkipMask;
        } else {
            Pdx->P12843DL.RevSkipMask = (USHORT)ParRevSkip;
        }

        if (ParSkipDefault == ParFwdSkip) {
            ParFwdSkip = Pdx->P12843DL.FwdSkipMask;
        } else {
            Pdx->P12843DL.FwdSkipMask = (USHORT)ParFwdSkip;
        }

        if( bConsiderEppDangerous ) {
            ParFwdSkip |= EPP_ANY;
            ParRevSkip |= EPP_ANY;
        }

        Status = IeeeNegotiateBestMode(Pdx, (USHORT)ParRevSkip, (USHORT)ParFwdSkip);
        if( !NT_SUCCESS(Status) ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - Peripheral Negotiation Failed - FAIL dataLink connect\n");
            return Status;
        }

        Pdx->ForwardInterfaceAddress = Pdx->P12843DL.DataChannel;
        if (Pdx->P12843DL.DataLinkMode == P12843DL_MLC_DL) {
            if (ParResetChannel != ParResetChannelDefault) {
                Pdx->P12843DL.ResetByte  = (UCHAR) ParResetByte & 0xff;
                Pdx->P12843DL.ResetByteCount = (UCHAR) ParResetByteCount & 0xff;
                if (ParResetChannel == PAR_COMPATIBILITY_RESET) {
                    Pdx->P12843DL.fnReset = ParMLCCompatReset;
                } else {
                    // Max ECP channel is 127 so let's mask off bogus bits.
                    Pdx->P12843DL.ResetChannel = (UCHAR) ParResetChannel & 0x7f;
                    Pdx->P12843DL.fnReset = ParMLCECPReset;
                }
            }
        }

        if (Pdx->P12843DL.fnReset) {
            DD((PCE)Pdx,DDT,"ParDot3Connect: MLCReset is supported on %x\n",Pdx->P12843DL.ResetChannel);
            Status = ((PDOT3_RESET_ROUTINE) (Pdx->P12843DL.fnReset))(Pdx);
        } else {
            DD((PCE)Pdx,DDT,"ParDot3Connect - MLCReset is not supported\n");
            Status = ParSetFwdAddress(Pdx);
        }
        if( !NT_SUCCESS(Status) ) {
            DD((PCE)Pdx,DDT,"ParDot3Connect - Couldn't Set Address - FAIL request\n");
            return Status;
        }

        // Check to make sure we are ECP, BECP, or EPP
        DD((PCE)Pdx,DDT,"ParDot3Connect: pre check of ECP, BECP, EPP\n");

        if (afpForward[Pdx->IdxForwardProtocol].ProtocolFamily != FAMILY_BECP &&
            afpForward[Pdx->IdxForwardProtocol].ProtocolFamily != FAMILY_ECP &&
            afpForward[Pdx->IdxForwardProtocol].ProtocolFamily != FAMILY_EPP) {

            DD((PCE)Pdx,DDT,"ParDot3Connect - We did not reach ECP or EPP - FAIL request\n");
            return STATUS_UNSUCCESSFUL;
        }

    } // end local block

    if (Pdx->P12843DL.DataLinkMode == P12843DL_DOT3_DL) {
        DD((PCE)Pdx,DDT,"ParDot3Connect - P12843DL_DOT3_DL\n");
        Pdx->P12843DL.fnRead  = arpReverse[Pdx->IdxReverseProtocol].fnRead;
        Pdx->P12843DL.fnWrite = afpForward[Pdx->IdxForwardProtocol].fnWrite;
        Pdx->fnRead           = ParDot3Read;
        Pdx->fnWrite          = ParDot3Write;
    }

    DD((PCE)Pdx,DDT,"ParDot3Connect - Exit with status %x\n",Status);

    return Status;
}

VOID
ParDot3CreateObject(
    IN  PPDO_EXTENSION   Pdx,
    IN PCHAR DOT3DL,
    IN PCHAR DOT3C
    )
{
    Pdx->P12843DL.DataLinkMode = P12843DL_OFF;
    Pdx->P12843DL.fnReset = NULL;
    DD((PCE)Pdx,DDT,"ParDot3CreateObject - DOT3DL [%s] DOT3C\n",DOT3DL, DOT3C);
    if (DOT3DL) {
        ULONG   dataChannel;
        ULONG   pid = 0x285; // pid for dot4

        // Only use the first channel.
        if( !String2Num(&DOT3DL, ',', &dataChannel) ) {
            dataChannel = 77;
            DD((PCE)Pdx,DDT,"ParDot3CreateObject - No DataChannel Defined\n");
        }
        if( DOT3C ) {
            if (!String2Num(&DOT3C, ',', &pid)) {
                pid = 0x285;
                DD((PCE)Pdx,DDT,"ParDot3CreateObject - No CurrentPID Defined\n");
            }
            DD((PCE)Pdx,DDT,"ParDot3CreateObject - .3 mode is ON\n");
        }
        Pdx->P12843DL.DataChannel = (UCHAR)dataChannel;
        Pdx->P12843DL.CurrentPID = (USHORT)pid;
        Pdx->P12843DL.DataLinkMode = P12843DL_DOT3_DL;
        DD((PCE)Pdx,DDT,"ParDot3CreateObject - Data [%x] CurrentPID [%x]\n",Pdx->P12843DL.DataChannel, Pdx->P12843DL.CurrentPID);
    }
    if (Pdx->P12843DL.DataLinkMode == P12843DL_OFF) {
        DD((PCE)Pdx,DDT,"ParDot3CreateObject - DANGER: .3 mode is OFF\n");
    }
}

VOID
ParDot4CreateObject(
    IN  PPDO_EXTENSION   Pdx,
    IN  PCHAR DOT4DL
    )
{
    Pdx->P12843DL.DataLinkMode = P12843DL_OFF;
    Pdx->P12843DL.fnReset = NULL;
    DD((PCE)Pdx,DDT,"ParDot3CreateObject: DOT4DL [%s]\n",DOT4DL);
    if (DOT4DL) {
        UCHAR numValues = StringCountValues( (PCHAR)DOT4DL, ',' );
        ULONG dataChannel, resetChannel, ResetByteCount;
        
        DD((PCE)Pdx,DDT,"ParDot3CreateObject: numValues [%d]\n",numValues);
        if (!String2Num(&DOT4DL, ',', &dataChannel)) {
            dataChannel = 77;
            DD((PCE)Pdx,DDT,"ParDot4CreateObject: No DataChannel Defined.\r\n");
        }

        if ((String2Num(&DOT4DL, ',', &resetChannel)) && (numValues > 1)) {

            if (resetChannel == -1) {
                Pdx->P12843DL.fnReset = ParMLCCompatReset;
            } else {
                Pdx->P12843DL.fnReset = ParMLCECPReset;
            }
            DD((PCE)Pdx,DDT,"ParDot4CreateObject: ResetChannel Defined.\r\n");

        } else {
            Pdx->P12843DL.fnReset = NULL;
            DD((PCE)Pdx,DDT,"ParDot4CreateObject: No ResetChannel Defined.\r\n");
        }

        if ((!String2Num(&DOT4DL, 0, &ResetByteCount)) && (numValues > 2)) {
            ResetByteCount = 4;
            DD((PCE)Pdx,DDT,"ParDot4CreateObject: No ResetByteCount Defined.\r\n");
        }

        Pdx->P12843DL.DataChannel = (UCHAR)dataChannel;
        Pdx->P12843DL.ResetChannel = (UCHAR)resetChannel;
        Pdx->P12843DL.ResetByteCount = (UCHAR)ResetByteCount;
        Pdx->P12843DL.DataLinkMode = P12843DL_DOT4_DL;
        DD((PCE)Pdx,DDT,"ParDot4CreateObject: .4DL mode is ON.\r\n");
        DD((PCE)Pdx,DDT,"ParDot4CreateObject: Data [%x] Reset [%x] Bytes [%x]\r\n",
                Pdx->P12843DL.DataChannel,
                Pdx->P12843DL.ResetChannel,
                Pdx->P12843DL.ResetByteCount);
    }
#if DBG
    if (Pdx->P12843DL.DataLinkMode == P12843DL_OFF) {
        DD((PCE)Pdx,DDT,"ParDot4CreateObject: DANGER: .4DL mode is OFF.\r\n");
    }
#endif
}


VOID
ParMLCCreateObject(
    IN  PPDO_EXTENSION   Pdx,
    IN PCHAR CMDField
    )
{
    Pdx->P12843DL.DataLinkMode = P12843DL_OFF;
    Pdx->P12843DL.fnReset = NULL;
    if (CMDField)
    {
        Pdx->P12843DL.DataChannel = 77;

        Pdx->P12843DL.DataLinkMode = P12843DL_MLC_DL;
        DD((PCE)Pdx,DDT,"ParMLCCreateObject: MLC mode is on.\r\n");
    }
#if DBG
    if (Pdx->P12843DL.DataLinkMode == P12843DL_OFF)
    {
        DD((PCE)Pdx,DDT,"ParMLCCreateObject: DANGER: MLC mode is OFF.\r\n");
    }
#endif
}

VOID
ParDot3DestroyObject(
    IN  PPDO_EXTENSION   Pdx
    )
{
    Pdx->P12843DL.DataLinkMode = P12843DL_OFF;
}

NTSTATUS
ParDot3Disconnect(
    IN  PPDO_EXTENSION   Pdx
    )
{
    if (Pdx->P12843DL.DataLinkMode == P12843DL_DOT3_DL) {
        Pdx->fnRead = arpReverse[Pdx->IdxReverseProtocol].fnRead;
        Pdx->fnWrite = afpForward[Pdx->IdxForwardProtocol].fnWrite;
    }

    Pdx->P12843DL.bEventActive = FALSE;
    Pdx->P12843DL.Event        = 0;

    return STATUS_SUCCESS;
}

VOID
ParDot3ParseModes(
    IN  PPDO_EXTENSION   Pdx,
    IN  PCHAR DOT3M
    )
{
    ULONG   fwd = 0;
    ULONG   rev = 0;
    DD((PCE)Pdx,DDT,"ParDot3ParseModes: DOT3M [%s]\n",DOT3M);
    if (DOT3M) {
        UCHAR numValues = StringCountValues((PCHAR)DOT3M, ',');

        if (numValues != 2) {
            // The periph gave me bad values. I'm not gonna read
            // them. I will set the defaults to the lowest
            // common denominator.
            DD((PCE)Pdx,DDT,"ParDot3ParseModes: Malformed 1284.3M field.\r\n");
            Pdx->P12843DL.FwdSkipMask = (USHORT) PAR_FWD_MODE_SKIP_MASK;
            Pdx->P12843DL.RevSkipMask = (USHORT) PAR_REV_MODE_SKIP_MASK;
            return;
        }
        
        // Only use the first channel.
        if (!String2Num(&DOT3M, ',', &fwd)) {
            fwd = (USHORT) PAR_FWD_MODE_SKIP_MASK;
            DD((PCE)Pdx,DDT,"ParDot3ParseModes: Couldn't read fwd of 1284.3M.\r\n");
        }
        if (!String2Num(&DOT3M, ',', &rev)) {
            rev = (USHORT) PAR_REV_MODE_SKIP_MASK;
            DD((PCE)Pdx,DDT,"ParDot3ParseModes: Couldn't read rev of 1284.3M.\r\n");
        }
    }
    Pdx->P12843DL.FwdSkipMask = (USHORT) fwd;
    Pdx->P12843DL.RevSkipMask = (USHORT) rev;
}

NTSTATUS
ParDot3Read(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS Status;
    UCHAR ucScrap1;
    UCHAR ucScrap2[2];
    USHORT usScrap1;
    ULONG bytesToRead;
    ULONG bytesTransferred;
    USHORT Dot3CheckSum;
    USHORT Dot3DataLen;

    // ================================== Read the first byte of SOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the first byte of SOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_StartOfFrame1)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the second byte of SOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the second byte of SOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_StartOfFrame2)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }
    
    // ================================== Read the PID (Should be in Big Endian)
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &usScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the PID
    if (!NT_SUCCESS(Status) || usScrap1 != Pdx->P12843DL.CurrentPID)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the DataLen
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap2[0], bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    Dot3DataLen = (USHORT)((USHORT)(ucScrap2[0]<<8 | ucScrap2[1]));
    // ================================== Check the DataLen
    if (!NT_SUCCESS(Status))
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the Checksum
    bytesToRead = 2;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap2[0], bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    Dot3CheckSum = (USHORT)(ucScrap2[0]<<8 | ucScrap2[1]);
    // ================================== Check the DataLen
    if (!NT_SUCCESS(Status))
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, Buffer, BufferSize, BytesTransferred);

    if (!NT_SUCCESS(Status))
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Data Read Failed.  We're Hosed!\n");
        return(Status);
    }

    // LengthOfData field from the Frame header is really the number of bytes of ClientData - 1
    if ( ((ULONG)Dot3DataLen + 1) > BufferSize)
    {
        // buffer overflow - abort operation
        DD((PCE)Pdx,DDE,"ParDot3Read: Bad 1284.3DL Data Len. Buffer overflow.  We're Hosed!\n");
        return  STATUS_BUFFER_OVERFLOW;
    }

    // Check Checksum
    {
        USHORT  pid = Pdx->P12843DL.CurrentPID;
        USHORT  checkSum;

        // 2's complement sum in 32 bit accumulator
        ULONG   sum = pid + Dot3DataLen + Dot3CheckSum;

        // fold 32 bit sum into 16 bits
        while( sum >> 16 ) {
            sum = (sum & 0xffff) + (sum >> 16);
        }

        // take 1's complement of folded sum - this should be Zero if there were no errors
        checkSum = (USHORT)(0xffff & ~sum);

        if( checkSum != 0 ) {
            DD((PCE)Pdx,DDE,"ParDot3Read: Bad 1284.3DL Checksum.  We're Hosed!\n");
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }


    // ================================== Read the first byte of EOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the first byte of EOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_EndOfFrame1)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }

    // ================================== Read the second byte of EOF
    bytesToRead = 1;
    bytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_READ_ROUTINE) Pdx->P12843DL.fnRead)(Pdx, &ucScrap1, bytesToRead, &bytesTransferred);
    }
    while(NT_SUCCESS(Status) && bytesTransferred != bytesToRead);

    // ================================== Check the second byte of EOF
    if (!NT_SUCCESS(Status) || ucScrap1 != Dot3_EndOfFrame2)
    {
        DD((PCE)Pdx,DDE,"ParDot3Read: Header Read Failed.  We're Hosed!\n");
        *BytesTransferred = 0;
        return(Status);
    }
    return Status;
}

NTSTATUS
ParDot3Write(
    IN  PPDO_EXTENSION   Pdx,
    IN  PVOID               Buffer,
    IN  ULONG               BufferSize,
    OUT PULONG              BytesTransferred
    )
{
    NTSTATUS    Status;
    ULONG       frameBytesTransferred;
    ULONG       bytesToWrite;
    USHORT      scrap1;
    USHORT      scrap2;
    USHORT      scrapHigh;
    USHORT      scrapLow;
    PUCHAR      p;

    // valid range for data payload per Frame is 1..64K
    if( (BufferSize < 1) || (BufferSize > 64*1024) ) {
        return STATUS_INVALID_PARAMETER;
    };

    // =========================  Write out first Byte of SOF
    bytesToWrite = 1;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Dot3_StartOfFrame1, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check first Byte of SOF
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out second Byte of SOF
    bytesToWrite = 1;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Dot3_StartOfFrame2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check second Byte of SOF
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out PID (which should be in Big Endian already)
    bytesToWrite = 2;
    frameBytesTransferred = 0;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Pdx->P12843DL.CurrentPID, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check PID
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out Length of Data
    bytesToWrite = 2;
    frameBytesTransferred = 0;
    scrap1 = (USHORT) (BufferSize - 1);
    scrapLow = (UCHAR) (scrap1 & 0xff);
    scrapHigh = (UCHAR) (scrap1 >> 8);
    p = (PUCHAR)&scrap2;
    *p++ = (UCHAR)scrapHigh;
    *p = (UCHAR)scrapLow;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &scrap2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check Length of Data
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    // =========================  Write out Checksum
    bytesToWrite = 2;
    frameBytesTransferred = 0;

    {
        USHORT  pid                = Pdx->P12843DL.CurrentPID;
        USHORT  dataLengthMinusOne = (USHORT)(BufferSize - 1);
        USHORT  checkSum;

        // 2's complement sum in 32 bit accumulator
        ULONG   sum = pid + dataLengthMinusOne;

        // fold 32 bit sum into 16 bits
        while( sum >> 16 ) {
            sum = (sum & 0xffff) + (sum >> 16);
        }

        // final checksum is 1's complement of folded sum
        checkSum = (USHORT)(0xffff & ~sum);
        scrap1 = checkSum;
    }

    // send checksum big-endian
    scrapLow  = (UCHAR)(scrap1 & 0xff);
    scrapHigh = (UCHAR)(scrap1 >> 8);
    p         = (PUCHAR)&scrap2;
    *p++      = (UCHAR)scrapHigh;
    *p        = (UCHAR)scrapLow;
    do
    {
        Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &scrap2, bytesToWrite, &frameBytesTransferred);
    }
    while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

    // =========================  Check Checksum
    if (!NT_SUCCESS(Status))
    {
        *BytesTransferred = 0;
        return(Status);
    }

    Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, Buffer, BufferSize, BytesTransferred);
    if (NT_SUCCESS(Status))
    {
        // =========================  Write out first Byte of EOF
        bytesToWrite = 1;
        frameBytesTransferred = 0;
        do
        {
            Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Dot3_EndOfFrame1, bytesToWrite, &frameBytesTransferred);
        }
        while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

        // =========================  Check first Byte of EOF
        if (!NT_SUCCESS(Status))
        {
            *BytesTransferred = 0;
            return(Status);
        }

        // =========================  Write out second Byte of EOF
        bytesToWrite = 1;
        frameBytesTransferred = 0;
        do
        {
            Status = ((PPROTOCOL_WRITE_ROUTINE) Pdx->P12843DL.fnWrite)(Pdx, &Dot3_EndOfFrame2, bytesToWrite, &frameBytesTransferred);
        }
        while(NT_SUCCESS(Status) &&  frameBytesTransferred != bytesToWrite);

        // =========================  Check second Byte of EOF
        if (!NT_SUCCESS(Status))
        {
            *BytesTransferred = 0;
            return(Status);
        }
    }
    return Status;
}

NTSTATUS
ParMLCCompatReset(
    IN  PPDO_EXTENSION   Pdx
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR Reset[256];       // Reset should not require more than 256 chars
    const ULONG ResetLen = Pdx->P12843DL.ResetByteCount;
    ULONG BytesWritten; 

    DD((PCE)Pdx,DDT,"ParMLCCompatReset: Start\n");
    if (Pdx->P12843DL.DataLinkMode != P12843DL_MLC_DL &&
        Pdx->P12843DL.DataLinkMode != P12843DL_DOT4_DL)
    {
        DD((PCE)Pdx,DDT,"ParMLCCompatReset: not MLC.\n");
        return STATUS_SUCCESS;
    }

    ParTerminate(Pdx);
    // Sending  NULLs for reset
    DD((PCE)Pdx,DDT,"ParMLCCompatReset: Zeroing Reset Bytes.\n");
    RtlFillMemory(Reset, ResetLen, Pdx->P12843DL.ResetByte);

    DD((PCE)Pdx,DDT,"ParMLCCompatReset: Sending Reset Bytes.\n");
    // Don't use the Dot3Write since we are in MLC Mode.
    Status = SppWrite(Pdx, Reset, ResetLen, &BytesWritten);
    if (!NT_SUCCESS(Status) || BytesWritten != ResetLen)
    {
        DD((PCE)Pdx,DDE,"ParMLCCompatReset: FAIL. Write Failed\n");
        return Status;
    }

    DD((PCE)Pdx,DDT,"ParMLCCompatReset: Reset Bytes were sent.\n");
    return Status;
}

NTSTATUS
ParMLCECPReset(
    IN  PPDO_EXTENSION   Pdx
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UCHAR Reset[256];       // Reset should not require more than 256 chars
    const ULONG ResetLen = Pdx->P12843DL.ResetByteCount;
    ULONG BytesWritten; 

    DD((PCE)Pdx,DDT,"ParMLCECPReset: Start\n");
    if (Pdx->P12843DL.DataLinkMode != P12843DL_MLC_DL &&
        Pdx->P12843DL.DataLinkMode != P12843DL_DOT4_DL)
    {
        DD((PCE)Pdx,DDT,"ParMLCECPReset: not MLC.\n");
        return STATUS_SUCCESS;
    }

    Status = ParReverseToForward(Pdx);
    Pdx->ForwardInterfaceAddress = Pdx->P12843DL.ResetChannel;
    Status = ParSetFwdAddress(Pdx);
    if (!NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDE,"ParMLCECPReset: FAIL. Couldn't Set Reset Channel\n");
        return Status;
    }

    // Sending  NULLs for reset
    DD((PCE)Pdx,DDT,"ParMLCECPReset: Zeroing Reset Bytes.\n");
    RtlFillMemory(Reset, ResetLen, Pdx->P12843DL.ResetByte);
    DD((PCE)Pdx,DDT,"ParMLCECPReset: Sending Reset Bytes.\n");
    // Don't use the Dot3Write since we are in MLC Mode.
    Status = afpForward[Pdx->IdxForwardProtocol].fnWrite(Pdx, Reset, ResetLen, &BytesWritten);
    if (!NT_SUCCESS(Status) || BytesWritten != ResetLen) {
        DD((PCE)Pdx,DDE,"ParMLCECPReset: FAIL. Write Failed\n");
        return Status;
    }

    DD((PCE)Pdx,DDT,"ParMLCECPReset: Reset Bytes were sent.\n");
    Pdx->ForwardInterfaceAddress = Pdx->P12843DL.DataChannel;
    Status = ParSetFwdAddress(Pdx);
    if (!NT_SUCCESS(Status)) {
        DD((PCE)Pdx,DDE,"ParMLCECPReset: FAIL. Couldn't Set Data Channel\n");
        return Status;
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\dispatchredirect.c ===
//
// dispatch.c - Entry points for those Dispatch Routines where the 
//                FDO and the PDOs have distinct handlers.
// 
//            - Redirect calls based on the type of device object
//
#include "pch.h"


NTSTATUS
PptFdoRead(
    IN PDEVICE_OBJECT  Fdo,
    IN PIRP            Irp
    )
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_READ not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS
PptFdoWrite( 
    IN PDEVICE_OBJECT  Fdo,
    IN PIRP            Irp
    )
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_WRITE not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS
PptFdoDeviceControl(
    IN PDEVICE_OBJECT  Fdo,
    IN PIRP            Irp
    )
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_DEVICE_CONTROL not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS PptFdoQueryInformation(PDEVICE_OBJECT Fdo, PIRP Irp)
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_QUERY_INFORMATION not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS PptFdoSetInformation(PDEVICE_OBJECT Fdo, PIRP Irp)
{
    UNREFERENCED_PARAMETER( Fdo );
    PptAssert(!"IRP_MJ_SET_INFORMATION not supported on FDO");
    return P4CompleteRequest( Irp, STATUS_NOT_SUPPORTED, Irp->IoStatus.Information );
}

NTSTATUS PptPdoSystemControl(PDEVICE_OBJECT Pdo, PIRP Irp) {
    PPDO_EXTENSION      pdx    = Pdo->DeviceExtension;
    DD((PCE)pdx,DDT,"PptPdoSystemControl - stub function - %s\n", pdx->Location);
    return P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
}

NTSTATUS 
PptFdoUnhandledRequest(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
    // Unhandled IRP - just pass it down the stack
{
    PFDO_EXTENSION  devExt = DevObj->DeviceExtension;
    NTSTATUS        status = PptAcquireRemoveLock( &devExt->RemoveLock, Irp );

    if( STATUS_SUCCESS == status ) {
        // RemoveLock acquired, forward request to device object below us
        IoSkipCurrentIrpStackLocation( Irp );
        status = IoCallDriver( devExt->ParentDeviceObject, Irp );
        PptReleaseRemoveLock( &devExt->RemoveLock, Irp );
    } else {
        // unable to acquire RemoveLock - FAIL request
        Irp->IoStatus.Status = status;
        P4CompleteRequest( Irp, status, Irp->IoStatus.Information );
    }

    return status;
}

NTSTATUS 
PptPdoUnhandledRequest(
    IN PDEVICE_OBJECT DevObj,
    IN PIRP           Irp
    )
    // Unhandled IRP - extract status from Irp and complete request
{
    NTSTATUS  status = Irp->IoStatus.Status;
    UNREFERENCED_PARAMETER( DevObj );
    P4CompleteRequest( Irp, Irp->IoStatus.Status, Irp->IoStatus.Information );
    return status;
}

NTSTATUS
PptDispatchPnp( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoPnp( DevObj, Irp );
    } else {
        return PptPdoPnp( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchPower( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoPower( DevObj, Irp );
    } else {
        return PptPdoPower( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchCreateOpen( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoCreateOpen( DevObj, Irp );
    } else {
        return PptPdoCreateOpen( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchClose( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoClose( DevObj, Irp );
    } else {
        return PptPdoClose( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchCleanup( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoCleanup( DevObj, Irp );
    } else {
        return PptPdoCleanup( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchRead( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoRead( DevObj, Irp );
    } else {
        return PptPdoReadWrite( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchWrite( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoWrite( DevObj, Irp );
    } else {
        return PptPdoReadWrite( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoDeviceControl( DevObj, Irp );
    } else {
        return ParDeviceControl( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchInternalDeviceControl( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoInternalDeviceControl( DevObj, Irp );
    } else {
        return ParInternalDeviceControl( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchQueryInformation( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoQueryInformation( DevObj, Irp );
    } else {
        return PptPdoQueryInformation( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchSetInformation( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoSetInformation( DevObj, Irp );
    } else {
        return PptPdoSetInformation( DevObj, Irp );
    }
}

NTSTATUS
PptDispatchSystemControl( PDEVICE_OBJECT DevObj, PIRP Irp ) {
    PFDO_EXTENSION fdx = DevObj->DeviceExtension;
    P5TraceIrpArrival( DevObj, Irp );
    if( DevTypeFdo == fdx->DevType ) {
        return PptFdoSystemControl( DevObj, Irp );
    } else {
        return PptPdoSystemControl( DevObj, Irp );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\becp.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    becp.c

Abstract:

    This module contains code for the host to utilize BoundedECP if it has been
    detected and successfully enabled.

Author:

    Robbie Harris (Hewlett-Packard) 27-May-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


NTSTATUS
PptBecpExitReversePhase(
    IN  PPDO_EXTENSION  Pdx
    )
{
    //
    // When using BECP, test nPeriphRequest prior to negotiation 
    // from reverse phase to forward phase.  Do not negotiate unless the 
    // peripheral indicates it is finished sending.  If using any other
    // mode, negotiate immediately.
    //
    if( SAFE_MODE == Pdx->ModeSafety ) {
        if( PHASE_REVERSE_IDLE == Pdx->CurrentPhase ) {
            if( !CHECK_DSR( Pdx->Controller, DONT_CARE, DONT_CARE, DONT_CARE, DONT_CARE, ACTIVE, IEEE_MAXTIME_TL) ) {
                DD((PCE)Pdx,DDT,"PptBecpExitReversePhase: Periph Stuck. Can't Flip Bus\n");
                return STATUS_IO_TIMEOUT;
            }
        }
    }
    return ParEcpHwExitReversePhase( Pdx );
}

//============================================================================
// NAME:    ECPFrame::Read()
//
//
// LAC FRAME  12Dec97
//      This function is used for two different kinds of reads:
//        1) continuing read - where we don't expect to exit reverse mode afterwards
//        2) non-continuing read - where we expect to exit reverse mode afterwards
//      The problem is that we have no way of knowing which is which.  I can
//      either wait after each read for nPeriphRequest to drop, or I can
//      check to see if it has dropped when I enter and handle it then.  
//
//      The other problem is that we have no way of communicating the fact that 
//      we have done this to the PortTuple.  It uses the last_direction member
//      to decide whether it should even look at entering or exiting some phase.
//
//      Lets face it, we are on our own with this.  It is safer to leave it 
//      connected and then try to straighten things out when we come back.  I
//      know that this wastes some time, but so does waiting at the end of 
//      every read when only half of them are going to drop the nPeriphRequest.
//
//      This routine performs a 1284 ECP mode read into the given
//      buffer for no more than 'BufferSize' bytes.
//
//      This routine runs at DISPATCH_LEVEL.
//
// PARAMETERS:
//      Controller      - Supplies the base address of the parallel port.
//      pPortInfoStruct - Supplies port information as defined in p1284.h
//      Buffer          - Supplies the buffer to read into.
//      BufferSize      - Supplies the number of bytes in the buffer.
//      BytesTransferred - Returns the number of bytes transferred.
//
// RETURNS:
//      NTSTATUS STATUS_SUCCESS or...
//      The number of bytes successfully read from the port is
//      returned via one of the arguments passed into this method.
//
// NOTES:
//      - Called ECP_PatchReverseTransfer in the original 16 bit code.
//
//============================================================================
NTSTATUS
PptBecpRead(
    IN  PPDO_EXTENSION  Pdx,
    IN  PVOID           Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          BytesTransferred
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    DD((PCE)Pdx,DDT,"PptBecpRead: Enter BufferSize[%d]\n", BufferSize);
    status = ParEcpHwRead( Pdx, Buffer, BufferSize, BytesTransferred );

    if (NT_SUCCESS(status)) {

        PUCHAR Controller;

        Controller = Pdx->Controller;
        if ( CHECK_DSR_WITH_FIFO( Controller, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, ACTIVE,
                                  ECR_FIFO_EMPTY, ECR_FIFO_SOME_DATA,
                                  DEFAULT_RECEIVE_TIMEOUT) ) {    
            DD((PCE)Pdx,DDT,"PptBecpRead: No more data. Flipping to Fwd\n");
            //
            // Bounded ECP rule - no more data from periph - flip bus to forward
            //
            status = ParReverseToForward( Pdx );

        } else {
            UCHAR bDSR = P5ReadPortUchar( Controller + OFFSET_DSR );
            
            //
            // Periph still has data, check for valid state
            //

            DD((PCE)Pdx,DDT,"PptBecpRead: Periph says there is more data.  Checking for stall.\n");
            // It's OK for the device to continue asserting nPeriphReq,
            // it may have more data to send.  However, nAckReverse and
            // XFlag should be in a known state, so double check them.
            if ( ! TEST_DSR( bDSR, DONT_CARE, DONT_CARE, INACTIVE, ACTIVE, DONT_CARE ) ) {
                #if DVRH_BUS_RESET_ON_ERROR
                    BusReset(Controller + OFFSET_DCR);  // Pass in the dcr address
                #endif
                status = STATUS_LINK_FAILED;
            	DD((PCE)Pdx,DDT,"PptBecpRead: nAckReverse and XFlag are bad.\n");
            } else {
                //
                // Periph has correctly acknowledged that it has data (state valid)
                //
                if ( (TRUE == Pdx->P12843DL.bEventActive) ) {
                    //
                    // Signal transport (e.g., dot4) that data is avail
                    //
                    KeSetEvent(Pdx->P12843DL.Event, 0, FALSE);
                }
            }

        }
    }
    
    DD((PCE)Pdx,DDT,"PptBecpRead: exit - status %x - BytesTransferred[%d]\n", status, *BytesTransferred);

    return status;
}

NTSTATUS
PptEnterBecpMode(
    IN  PPDO_EXTENSION  Pdx,
    IN  BOOLEAN         DeviceIdRequest
    )
/*++

Routine Description:

    This routine performs 1284 negotiation with the peripheral to the
    BECP mode protocol.

Arguments:

    Controller      - Supplies the port address.

    DeviceIdRequest - FALSE - driver only supports Device ID Query in NIBBLE mode

Return Value:

    STATUS_SUCCESS  - Successful negotiation.

    otherwise       - Unsuccessful negotiation.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    
    if( DeviceIdRequest ) {
        // driver error if we hit this assert
        PptAssert(FALSE == DeviceIdRequest);
        status = STATUS_INVALID_PARAMETER;
        goto targetExit;
    }

    if( SAFE_MODE == Pdx->ModeSafety ) {
        status = IeeeEnter1284Mode( Pdx, BECP_EXTENSIBILITY );
    } else {
        Pdx->Connected = TRUE;
    }
    
    if( STATUS_SUCCESS == status ) {
        status = ParEcpHwSetupPhase( Pdx );
        Pdx->bSynchWrites = TRUE;     // NOTE this is a temp hack!!!  dvrh
        if (!Pdx->bShadowBuffer) {
            Queue_Create(&(Pdx->ShadowBuffer), Pdx->FifoDepth * 2);	
            Pdx->bShadowBuffer = TRUE;
        }
        Pdx->IsIeeeTerminateOk = TRUE;
    }

targetExit:

    DD((PCE)Pdx,DDT,"PptEnterBecpMode - exit w/status %x\n", status);
    return status;
}

BOOLEAN
PptIsBecpSupported(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine determines whether or not ECP mode is suported
    in the write direction by trying to negotiate when asked.

Arguments:

    Pdx  - The device extension.

Return Value:

    BOOLEAN.

--*/
{
    NTSTATUS status;

    if( Pdx->BadProtocolModes & BOUNDED_ECP ) {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - FAILED - BOUNDED_ECP in BadProtocolModes\n");
        return FALSE;
    }

    if( Pdx->ProtocolModesSupported & BOUNDED_ECP ) {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - PASSED - BOUNDED_ECP already cheacked\n");
        return TRUE;
    }

    if( !(Pdx->HardwareCapabilities & PPT_ECP_PRESENT) ) {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - FAILED - HWECP not avail\n");
        return FALSE;
    }

    if( 0 == Pdx->FifoWidth ) {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - FAILED - 0 == FifoWidth\n");
        return FALSE;
    }
        
    // Must use BECP Enter and Terminate for this test.
    // Internel state machines will fail otherwise.  --dvrh
    status = PptEnterBecpMode( Pdx, FALSE );
    PptTerminateBecpMode( Pdx );

    if( STATUS_SUCCESS == status ) {
        Pdx->ProtocolModesSupported |= BOUNDED_ECP;
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - PASSED\n");
        return TRUE;
    } else {
        DD((PCE)Pdx,DDT,"PptIsBecpSupported - FAILED - BOUNDED_ECP negotiate failed\n");
        return FALSE;
    }
}

VOID
PptTerminateBecpMode(
    IN  PPDO_EXTENSION   Pdx
    )
/*++

Routine Description:

    This routine terminates the interface back to compatibility mode.

Arguments:

    Controller  - Supplies the parallel port's controller address.

Return Value:

    None.

--*/
{
    DD((PCE)Pdx,DDT,"PptTerminateBecpMode - Enter - CurrentPhase %x\n", Pdx->CurrentPhase);

    // Need to check current phase -- if its reverse, need to flip bus
    // If its not forward -- its an incorrect phase and termination will fail.
    switch (Pdx->CurrentPhase) {

    case  PHASE_FORWARD_IDLE:	// Legal state to terminate

        break;

    case PHASE_REVERSE_IDLE:	// Flip the bus so we can terminate

        {
            NTSTATUS status = ParEcpHwExitReversePhase( Pdx );
            if( STATUS_SUCCESS == status ) {
                status = ParEcpEnterForwardPhase(Pdx );
            } else {
                DD((PCE)Pdx,DDT,"PptTerminateBecpMode: Couldn't flip the bus\n");
            }
        }
        break;

    case  PHASE_FORWARD_XFER:
    case  PHASE_REVERSE_XFER:

        // Dunno what to do here.  We probably will confuse the peripheral.
        DD((PCE)Pdx,DDE,"PptTerminateBecpMode: invalid wCurrentPhase (XFer in progress)\n");
        break;

    case PHASE_TERMINATE:

        // Included PHASE_TERMINATE in the switch so we won't return
        //   an error if we are already terminated.  We are already
        //   terminated, nothing more to do.
        break;

    default:

        DD((PCE)Pdx,DDE,"PptTerminateBecpMode: invalid CurrentPhase %x\n", Pdx->CurrentPhase);
        // Dunno what to do here.  We're lost and don't have a map to figure out where we are!
        break;
        
    }

    ParEcpHwWaitForEmptyFIFO( Pdx );

    ParCleanupHwEcpPort( Pdx );

    if ( Pdx->ModeSafety == SAFE_MODE ) {
        IeeeTerminate1284Mode( Pdx );
    } else {
        Pdx->Connected = FALSE;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\parallel\parport2\chipmode.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    parmode.c

Abstract:

    This is the main module for Extended Parallel Port (ECP) and
    Enhanced Parallel Port (EPP) detection.  This module 
    will detect for invalid chipshets and do ECR detection 
    for ECP and EPP hardware support if the invalid chipset
    is not found.

Author:

    Don Redford (v-donred) 4-Mar-1998

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"

#define USE_PARCHIP_ECRCONTROLLER 1


NTSTATUS
PptDetectChipFilter(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine is called once per DeviceObject to see if the filter driver 
    for detecting parallel chip capabilities is there and to get the chip
    capabilities if there of the port in question.
    
Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if we were able detect the chip and modes possible.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS                    Status = STATUS_NO_SUCH_DEVICE;
    PIRP                        Irp;
    KEVENT                      Event;
    IO_STATUS_BLOCK             IoStatus;
    UCHAR                       ecrLast;
    PUCHAR                      Controller, EcpController;
            
    Controller = Fdx->PortInfo.Controller;
    EcpController = Fdx->PnpInfo.EcpController;
    
    // Setting variable to FALSE to make sure we do not acidentally succeed
    Fdx->ChipInfo.success = FALSE;

    // Setting the Address to send to the filter driver to check the chips
    Fdx->ChipInfo.Controller = Controller;

    // Setting the Address to send to the filter driver to check the chips
    Fdx->ChipInfo.EcrController = EcpController;

#ifndef USE_PARCHIP_ECRCONTROLLER
    // if there is not value in the ECR controller then PARCHIP and PARPORT
    // will conflict and PARCHIP will not work with PARPORT unless we
    // use the ECR controller found by PARCHIP.
    if ( !EcpController ) {
         return Status;
    }
#endif    
    //
    // Initialize
    //
    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    // Send a Pointer to the ChipInfo structure to and from the filter
    Irp = IoBuildDeviceIoControlRequest( IOCTL_INTERNAL_PARCHIP_CONNECT,
                                         Fdx->ParentDeviceObject, 
                                         &Fdx->ChipInfo,
                                         sizeof(PARALLEL_PARCHIP_INFO),
                                         &Fdx->ChipInfo,
                                         sizeof(PARALLEL_PARCHIP_INFO),
                                         TRUE, &Event, &IoStatus);

    if (!Irp) { 
        // couldn't create an IRP
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call down to our parent and see if Filter is present
    //
    Status = IoCallDriver(Fdx->ParentDeviceObject, Irp);
            
    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Suspended, KernelMode, FALSE, NULL);
        Status = Irp->IoStatus.Status;
    }
            
    //
    // If successful then we have a filter driver and we need to get the modes supported
    //
    if ( NT_SUCCESS(Status) ) {

        //
        // check to see if the filter driver was able to determine the I/O chip
        //
        if ( Fdx->ChipInfo.success ) {
            Fdx->PnpInfo.HardwareCapabilities = Fdx->ChipInfo.HardwareModes;
#ifdef USE_PARCHIP_ECRCONTROLLER
            // only replace it if defined
            if ( Fdx->PnpInfo.EcpController != Fdx->ChipInfo.EcrController ) {
                Fdx->PnpInfo.EcpController = Fdx->ChipInfo.EcrController;
                EcpController = Fdx->PnpInfo.EcpController;
            }
#endif
            // Set variable to say we have a filter driver
            Fdx->FilterMode = TRUE;
        }
    }

    // if there is a filter and ECP capable we need to get the Fifo Size
    if ( Fdx->FilterMode && Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT ) {

        Status = Fdx->ChipInfo.ParChipSetMode ( Fdx->ChipInfo.Context, ECR_ECP_MODE );

        // if able to set ECP mode
        if ( NT_SUCCESS( Status ) ) {
            PUCHAR wPortECR;

            wPortECR = EcpController + ECR_OFFSET;

            // get value from ECR reg & save it
            ecrLast = P5ReadPortUchar( wPortECR );

            // Determining Fifo Size
            PptDetermineFifoWidth(Fdx);    
            PptDetermineFifoDepth(Fdx);

            // return ecr to original
            P5WritePortUchar( wPortECR, ecrLast);

            Status = Fdx->ChipInfo.ParChipClearMode ( Fdx->ChipInfo.Context, ECR_ECP_MODE );
        }    
    
    }    

    return Status;
}

NTSTATUS
PptDetectPortType(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This routine is called once per DeviceObject to detect the type of 
    parallel chip capabilities of the port in question.
    
Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if we were able detect the chip and modes possible.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS                    Status;
    UNICODE_STRING              ParportPath;
    RTL_QUERY_REGISTRY_TABLE    RegTable[2];
    ULONG                       IdentifierHex = 12169;
    ULONG                       zero = 0;

    //
    // -- May want to get detection order from Registry.
    // -- May also want to store/retrieve last known good configuration in/from registry.
    // -- Finally we should set a registry flag during dection so that we'll know
    //    if we crashed while attempting to detect and not try it again.
    //
    RtlInitUnicodeString(&ParportPath, (PWSTR)L"Parport");

    // Setting up to get the Parport info
    RtlZeroMemory( RegTable, sizeof(RegTable) );

    RegTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    RegTable[0].Name = (PWSTR)L"ModeCheckedStalled";
    RegTable[0].EntryContext = &IdentifierHex;
    RegTable[0].DefaultType = REG_DWORD;
    RegTable[0].DefaultData = &zero;
    RegTable[0].DefaultLength = sizeof(ULONG);

    //
    // Querying the registry for Parport to see if we tried to go check mode and we crashed
    // the registry key would still be there 
    //
    Status = RtlQueryRegistryValues(
                                RTL_REGISTRY_SERVICES,
                                ParportPath.Buffer,
                                RegTable,
                                NULL,
                                NULL );

    //
    // if registry key is there then we will just check ECP and Byte
    //
    if ( !(NT_SUCCESS( Status ) && IdentifierHex == 0) && (Status != STATUS_OBJECT_NAME_NOT_FOUND) ) {

        // dvtw, Check for ECP anyway!  We just won't turn it on

        PptDetectEcpPort(Fdx);
        PptDetectBytePort(Fdx);

        if( Fdx->PnpInfo.HardwareCapabilities & (PPT_ECP_PRESENT | PPT_BYTE_PRESENT) ) {
            return STATUS_SUCCESS;
        } else {
            return STATUS_NO_SUCH_DEVICE;
        }
    }
    
    IdentifierHex = 12169;
    // Write the registry key out there just in case we crash
    Status = RtlWriteRegistryValue(
                                RTL_REGISTRY_SERVICES,
                                ParportPath.Buffer,
                                (PWSTR)L"ModeCheckedStalled",
                                REG_DWORD,
                                &IdentifierHex,
                                sizeof(ULONG) );
            
    //
    // Now we can start detecting the parallel port chip capabilities
    //
    Status = PptDetectPortCapabilities( Fdx );

    // Delete the registry key out there since we finished
    Status = RtlDeleteRegistryValue( RTL_REGISTRY_SERVICES, ParportPath.Buffer, (PWSTR)L"ModeCheckedStalled" ); 
    return Status;
}

NTSTATUS
PptDetectPortCapabilities(
    IN  PFDO_EXTENSION   Fdx
    )

/*++

Routine Description:

    This is the "default" detection code, which looks for an ECR.  If the ECR
    is present it tries to set mode 100b in <7:5>. If it sticks we'll call it
    EPP.

Arguments:

    Fdx   - Supplies the device extension.

Return Value:

    STATUS_SUCCESS  - if the port type was detected.
   !STATUS_SUCCESS  - otherwise.

--*/

{
    NTSTATUS    Status;

    PptDetectEcpPort( Fdx );
    
    // dvdr 
    // 
    // if we did not detect an ECR for ECP mode and ECP mode failed
    // EPP mode would fail also
    // Also cannot have EPP mode at an address that ends with a "C"
    // 
    if ( (Fdx->PnpInfo.HardwareCapabilities & PPT_ECP_PRESENT) &&
         (((ULONG_PTR)Fdx->PortInfo.Controller & 0x0F) != 0x0C) ) {

        // Need to check for National chipsets before trying EPP mode
        // dvdr - need to add detection for old Winbond

        Status = PptFindNatChip( Fdx );

        if ( NT_SUCCESS( Status ) ) {
            if ( !Fdx->NationalChipFound ) {
                // National chipset was NOT found so we can see if generic EPP is supported

                PptDetectEppPortIfDot3DevicePresent( Fdx );

                if( !Fdx->CheckedForGenericEpp ) {
                    // we didn't have a dot3 device to use for screening, do check anyway
                    //   if user has explicitly requested EPP detection
                    PptDetectEppPortIfUserRequested( Fdx );
                }
            } else {
                // National chipset was found so can't do generic EPP
                Fdx->CheckedForGenericEpp = TRUE; // check is complete - generic EPP is unsafe
            }
        }
    } else {
        // ECP failed no check for Generic EPP
        Fdx->CheckedForGenericEpp = TRUE; // check is complete - generic EPP is unsafe
    }

    PptDetectBytePort( Fdx );
    
    if (Fdx->PnpInfo.HardwareCapabilities & (PPT_ECP_PRESENT | PPT_EPP_PRESENT | PPT_BYTE_PRESENT) ) {
        return STATUS_SUCCESS;
    }

    return STATUS_NO_SUCH_DEVICE;    
}

VOID
PptDetectEcpPort(
    IN  PFDO_EXTENSION   Fdx
    )
    
/*++
      
Routine Description:
      
    This routine looks for the presence of an ECR register to determine that
      it has ECP.
      
Arguments:
      
    Fdx           - Supplies the device extension of the device we are
                            reporting resources for.
      
Return Value:
      
    None.
      
--*/
    
{
    PUCHAR  Controller;
    PUCHAR  wPortDCR;       // IO address of Device Control Register (DCR)
    PUCHAR  wPortECR;       // IO address of Extended Control Register (ECR)
    UCHAR   ecrLast, ecr, dcr;
    
    Controller = Fdx->PortInfo.Controller;
    wPortDCR = Controller + DCR_OFFSET;

    if( 0 == Fdx->PnpInfo.EcpController ) {
        // PnP didn't give us an ECP Register set - we're done here
        return;
    }
    wPortECR = Fdx->PnpInfo.EcpController + ECR_OFFSET;

    ecrLast = ecr = P5ReadPortUchar(wPortECR);

    // Initialize the DCR's nAutoFeed and nStrobe to a harmless combination
    // that could be returned by the ECR, but is not likely to be returned if
    // the ECR isn't present.  Depending on the host's address decode logic,
    // reading a non-existant ECR could have one of two results:  the ECR address
    // could decode on top of the DCR, so we'll read the value we are about to set.
    // Alternately, we might just read a floating bus and get a random value.
    dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, INACTIVE, ACTIVE );
    P5WritePortUchar( wPortDCR, dcr );

    ecrLast = ecr = P5ReadPortUchar(wPortECR);
    
    
    // Attempt to read the ECR.  If ECP hardware is present, the ECR register's
    // bit 1 and bit 0 should read a 00 (some data in the FIFO), 01 (FIFO empty),
    // or 10 (FIFO full).  If we read a 11 (illegal combination) then we know for
    // sure that no ECP hardware is present.  Also, a valid ECR should never return
    // 0xFF (but a nonexistant register probably would), so we'll test for that 
    // specific value also.
    if ( ( TEST_ECR_FIFO( ecr, ECR_FIFO_MASK ) ) || ( ecrLast == 0xFF ) ) {
        // ECR[1:0] returned a value of 11, so this can't be hardware ECP.
        DD((PCE)Fdx,DDT,"ParMode::PptDetectEcpPort:  illegal FIFO status\n");

        // Restore the DCR so that all lines are inactive.
        dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
        P5WritePortUchar( wPortDCR, dcr );
        return;
    }

    // OK, so we got either a 00, 01, or 10 for ECR[1:0].  If it was 10, the
    if( TEST_ECR_FIFO( ecr, ECR_FIFO_FULL ) ) { // Looking for ECR[1:0] of 10...

        // The ECR[1:0] returned 10.  This is a legal value, but possibly the
        // hardware might have just decoded the DCR and we merely read back the
        // DCR value we set earlier.  Or, we might have just read back a value
        // that was hanging on the bus due to bus capacitance.  So, we'll change 
        // the DCR, read the ECR again, and see if the two registers continue to 
        // track each other.  If they do track, we'll conclude that there is no
        // ECP hardware.

        // Put the DCR's nAutoFeed and nStrobe register bits back to zero.
        dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
        P5WritePortUchar( wPortDCR, dcr );

        // Read the ECR again
        ecr = P5ReadPortUchar( wPortECR );

        if ( TEST_ECR_FIFO( ecr, ECR_FIFO_SOME_DATA ) ) {
            // ECR[1:0] is tracking DCR[1:0], so this can't be hardware ECP.

            // Restore the DCR so that all lines are inactive.
            dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
            P5WritePortUchar( wPortDCR, dcr );
            return;
        }
    }
    
    // If we get this far, then the ECR appears to be returning something valid that
    // doesn't track the DCR.  It is beginning to look promising.  We're going
    // to take a chance, and write the ECR to put the chip in compatiblity
    // mode.  Doing so will reset the FIFO, so when we read FIFO status it should
    // come back empty.  However, if we're wrong and this isn't ECP hardware, the
    // value we're about to write will turn on 1284Active (nSelectIn) and this might
    // cause headaches for the peripheral.
    P5WritePortUchar( wPortECR, DEFAULT_ECR_COMPATIBILITY );

    // Read the ECR again
    ecr = P5ReadPortUchar( wPortECR );

    // Now test the ECR snapshot to see if the FIFO status is correct.  The FIFO
    // should test empty.
    if (!TEST_ECR_FIFO( ecr, ECR_FIFO_EMPTY ) )
    {
        // Restore the DCR so that all lines are inactive.
        dcr = SET_DCR( DIR_WRITE, IRQEN_DISABLE, INACTIVE, ACTIVE, ACTIVE, ACTIVE );
        P5WritePortUchar( wPortDCR, dcr );
        return;
    }

    // OK, it looks very promising.  Perform a couple of additional tests that
    // will give us a lot of confidence, as well as providing some information
    // we need about the ECP chip.
    
    // return ecr to original
    P5WritePortUchar(wPortECR, ecrLast);

    //
    // Test here for ECP capable
    //

    // get value from ECR reg & save it
    ecrLast = P5ReadPortUchar( wPortECR );
    ecr     = (UCHAR)(ecrLast & ECR_MODE_MASK);

    // Put the chip into test mode; the FIFO should start out empty
    P5WritePortUchar(wPortECR, (UCHAR)(ecr | ECR_TEST_MODE) );

    PptDetermineFifoWidth(Fdx);    
    if( 0 != Fdx->PnpInfo.FifoWidth) {
        Fdx->PnpInfo.HardwareCapabilities |= PPT_ECP_PRESENT;
 
     