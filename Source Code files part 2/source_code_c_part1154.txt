  define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\trees.h ===
/* header created automatically with -DGEN_TREES_H */

local const ct_data static_ltree[L_CODES+2] = {
{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
};

local const ct_data static_dtree[D_CODES] = {
{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
};

const uch _dist_code[DIST_CODE_LEN] = {
 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
};

const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
};

local const int base_length[LENGTH_CODES] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
64, 80, 96, 112, 128, 160, 192, 224, 0
};

local const int base_dist[D_CODES] = {
    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\zutil.h ===
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _Z_UTIL_H
#define _Z_UTIL_H

#include "zlib.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
    extern int errno;
#else
#   include <errno.h>
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = (char*)ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#ifdef MSDOS
#  define OS_CODE  0x00
#  if defined(__TURBOC__) || defined(__BORLANDC__)
#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
       /* Allow compilation with ANSI keywords only enabled */
       void _Cdecl farfree( void *block );
       void *_Cdecl farmalloc( unsigned long nbytes );
#    else
#     include <alloc.h>
#    endif
#  else /* MSC or DJGPP */
#    include <malloc.h>
#  endif
#endif

#ifdef OS2
#  define OS_CODE  0x06
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#    include <unix.h> /* for fdopen */
#  else
#    ifndef fdopen
#      define fdopen(fd,mode) NULL /* No fdopen() */
#    endif
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600))
#  define fdopen(fd,type)  _fdopen(fd,type)
#endif


        /* Common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#ifdef HAVE_STRERROR
   extern char *strerror OF((int));
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
#endif

#if defined(pyr)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
   extern int z_verbose;
   extern void z_error    OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif


typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
				       uInt len));
voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

#endif /* _Z_UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\zutil.c ===
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zutil.h"

struct internal_state      {int dummy;}; /* for buggy compilers */

#ifndef STDC
extern void exit OF((int));
#endif

const char *z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}

#ifdef DEBUG

#  ifndef verbose
#    define verbose 0
#  endif
int z_verbose = verbose;

void z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char * ZEXPORT zError(err)
    int err;
{
    return ERR_MSG(err);
}


#ifndef HAVE_MEMCPY

void zmemcpy(dest, source, len)
    Bytef* dest;
    const Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int zmemcmp(s1, s2, len)
    const Bytef* s1;
    const Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifdef __TURBOC__
#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
/* Small and medium model in Turbo C are for now limited to near allocation
 * with reduced MAX_WBITS and MAX_MEM_LEVEL
 */
#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}
#endif
#endif /* __TURBOC__ */


#if defined(M_I86) && !defined(__32BIT__)
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* MSC */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
    if (opaque) items += size - size; /* make compiler happy */
    return (voidpf)calloc(items, size);
}

void  zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\inc\ndrshared\ndrmisc.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    ndrmisc.h

Abtract :

    Contains misc. function prototypes, flags, and macros, mainly from
	rpc\ndr20\ndrp.h.

Revision History :

	John Doty   johndoty May 2000  (Assembled from other ndr headers)

--------------------------------------------------------------------*/


#ifndef __NDRMISC_H__
#define __NDRMISC_H__

//
// Type marshalling and buffer manipulation
//
EXTERN_C uchar *
NdrpMemoryIncrement(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat
    );

EXTERN_C void
NdrUnmarshallBasetypeInline(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pArg,
    uchar               Format
    );

EXTERN_C
unsigned char
RPC_ENTRY
NdrGetSimpleTypeBufferAlignment(
    unsigned char FormatChar
    );

EXTERN_C
unsigned char
RPC_ENTRY
NdrGetSimpleTypeBufferSize(
    unsigned char FormatChar
    );

EXTERN_C
unsigned char
RPC_ENTRY
NdrGetSimpleTypeMemorySize(
    unsigned char FormatChar
    );

EXTERN_C
unsigned long
RPC_ENTRY
NdrGetTypeFlags(
    unsigned char FormatChar
    );

EXTERN_C
void
RPC_ENTRY
NdrTypeSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

EXTERN_C
unsigned char *
RPC_ENTRY
NdrTypeMarshall(
    PMIDL_STUB_MESSAGE                   pStubMsg,
    unsigned char __RPC_FAR *            pMemory,
    PFORMAT_STRING                       pFormat
    );

EXTERN_C
unsigned char *
RPC_ENTRY
NdrTypeUnmarshall(
    PMIDL_STUB_MESSAGE                   pStubMsg,
    unsigned char __RPC_FAR **           ppMemory,
    PFORMAT_STRING                       pFormat,
    unsigned char                        fSkipRefCheck
    );

EXTERN_C
void
RPC_ENTRY
NdrTypeFree(
	PMIDL_STUB_MESSAGE                   pStubMsg,
	unsigned char __RPC_FAR *            pMemory,
	PFORMAT_STRING                       pFormat
    );

// used by callframe guys
EXTERN_C void
NdrOutInit(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    uchar **                ppArg
    );


// This definition is adjusted for a native platform.
// The wire size is fixed for DCE NDR regardless of platform.

#define PTR_MEM_SIZE                    sizeof(void *)
#define PTR_MEM_ALIGN                   (sizeof(void *)-1)
#define PTR_WIRE_SIZE                   (4)
#define NDR_MAX_BUFFER_ALIGNMENT        (16)

#define CONTEXT_HANDLE_WIRE_SIZE        20

#define IGNORED(Param)


//
// Alignment macros.
//

#define ALIGN( pStuff, cAlign ) \
                pStuff = (uchar *)((LONG_PTR)((pStuff) + (cAlign)) \
                                   & ~ ((LONG_PTR)(cAlign)))

#define LENGTH_ALIGN( Length, cAlign ) \
                Length = (((Length) + (cAlign)) & ~ (cAlign))


//
// Simple type alignment and size lookup macros.
//
#ifdef _RPCRT4_

#define SIMPLE_TYPE_ALIGNMENT(FormatChar)   SimpleTypeAlignment[FormatChar]

#define SIMPLE_TYPE_BUFSIZE(FormatChar)     SimpleTypeBufferSize[FormatChar]

#define SIMPLE_TYPE_MEMSIZE(FormatChar)     SimpleTypeMemorySize[FormatChar]

#else

#define SIMPLE_TYPE_ALIGNMENT(FormatChar)   NdrGetSimpleTypeBufferAlignment(FormatChar)

#define SIMPLE_TYPE_BUFSIZE(FormatChar)     NdrGetSimpleTypeBufferSize(FormatChar)

#define SIMPLE_TYPE_MEMSIZE(FormatChar)     NdrGetSimpleTypeMemorySize(FormatChar)

#endif

//
// Format character attribute bits used in global NdrTypesFlags defined in
// global.c.
//
#define     _SIMPLE_TYPE_       0x0001L
#define     _POINTER_           0x0002L
#define     _STRUCT_            0x0004L
#define     _ARRAY_             0x0008L
#define     _STRING_            0x0010L
#define     _UNION_             0x0020L
#define     _XMIT_AS_           0x0040L

#define     _BY_VALUE_          0x0080L

#define     _HANDLE_            0x0100L

#define     _BASIC_POINTER_     0x0200L

//
// Format character query macros.
//
#ifdef __RPCRT4__

#define _FC_FLAGS(FC)  NdrTypeFlags[(FC)]

#else

#define _FC_FLAGS(FC)  NdrGetTypeFlags(FC)

#endif

#define IS_SIMPLE_TYPE(FC)     (_FC_FLAGS(FC) & _SIMPLE_TYPE_)

#define IS_POINTER_TYPE(FC)    (_FC_FLAGS(FC) & _POINTER_)

#define IS_BASIC_POINTER(FC)   (_FC_FLAGS(FC) & _BASIC_POINTER_)

#define IS_ARRAY(FC)           (_FC_FLAGS(FC) & _ARRAY_)

#define IS_STRUCT(FC)          (_FC_FLAGS(FC) & _STRUCT_)

#define IS_UNION(FC)           (_FC_FLAGS(FC) & _UNION_)

#define IS_STRING(FC)          (_FC_FLAGS(FC) & _STRING_)

#define IS_ARRAY_OR_STRING(FC) (_FC_FLAGS(FC) & (_STRING_ | _ARRAY_))

#define IS_XMIT_AS(FC)         (_FC_FLAGS(FC) & _XMIT_AS_)

#define IS_BY_VALUE(FC)        (_FC_FLAGS(FC) & _BY_VALUE_)

#define IS_HANDLE(FC)          (NdrTypeFlags[(FC)] & _HANDLE_)

//
// Pointer attribute extraction and querying macros.
//
#define ALLOCATE_ALL_NODES( FC )    ((FC) & FC_ALLOCATE_ALL_NODES)

#define DONT_FREE( FC )             ((FC) & FC_DONT_FREE)

#define ALLOCED_ON_STACK( FC )      ((FC) & FC_ALLOCED_ON_STACK)

#define SIMPLE_POINTER( FC )        ((FC) & FC_SIMPLE_POINTER)

#define POINTER_DEREF( FC )         ((FC) & FC_POINTER_DEREF)

//
// Handle query macros.
//
#define IS_HANDLE_PTR( FC )         ((FC) & HANDLE_PARAM_IS_VIA_PTR)

#define IS_HANDLE_IN( FC )          ((FC) & HANDLE_PARAM_IS_IN)

#define IS_HANDLE_OUT( FC )         ((FC) & HANDLE_PARAM_IS_OUT)

#define IS_HANDLE_RETURN( FC )      ((FC) & HANDLE_PARAM_IS_RETURN)


//
// Stack and argument defines.
//
#if defined(_AMD64_) || defined(_IA64_)
#define REGISTER_TYPE               _int64
#else
#define REGISTER_TYPE               int
#endif

#define RETURN_SIZE                 8

//
// Argument retrieval macros.
//

#define INIT_ARG(argptr,arg0)   va_start(argptr, arg0)

#ifndef _ALPHA_
//
// Both MIPS and x86 are 4 byte aligned stacks, with MIPS supporting 8byte
// alignment on the stack as well. Their va_list is essentially an
// unsigned char *.
//

#if defined(_IA64_)
#define GET_FIRST_IN_ARG(argptr)
#define GET_FIRST_OUT_ARG(argptr)
#elif defined(_AMD64_)
#define GET_FIRST_IN_ARG(argptr)            
#define GET_FIRST_OUT_ARG(argptr)           
#else
#define GET_FIRST_IN_ARG(argptr)            argptr = *(va_list *)argptr
#define GET_FIRST_OUT_ARG(argptr)           argptr = *(va_list *)argptr
#endif

#define GET_NEXT_C_ARG(argptr,type)         va_arg(argptr,type)

#define SKIP_STRUCT_ON_STACK(ArgPtr, Size)	ArgPtr += Size

#define GET_STACK_START(ArgPtr)			    ArgPtr
#define GET_STACK_POINTER(ArgPtr, mode)		ArgPtr

#else	// _ALPHA_
//
// The Alpha has an 8byte aligned stack, with its va_list being a structure
// consisting of an unsigned char *, a0 and an int offset. See stdarg.h for
// the gory details.
//

#define GET_FIRST_IN_ARG(argptr)    \
            argptr.a0 = va_arg(argptr, char *); \
            argptr.offset = 0
#define GET_FIRST_OUT_ARG(argptr)   \
            argptr.a0 = va_arg(argptr, char *); \
            argptr.offset = 0

//
// Note that this macro does nothing for the Alpha. The stack incrementing is
// folded into the GET_STACK_POINTER below.
//
#define GET_NEXT_C_ARG(argptr,type)

#define SKIP_STRUCT_ON_STACK(ArgPtr, Size)  \
		    Size += 7; Size &= ~7;	 \
		    for(Size /= sizeof(_int64);Size;--Size){va_arg(ArgPtr, _int64);}

#define GET_STACK_START(ArgPtr)		   ArgPtr.a0

//
// Ok, this ugly mess is just a trimmed dowm version of the va_arg macro for
// the alpha. What is missing is the dereference operator (*) and the test for
// a float (__builtin_isfloat()).
//
#define GET_STACK_POINTER(ArgPtr, mode)                             \
            (                                                       \
              ((ArgPtr).offset += ((int)sizeof(mode) + 7) & -8) ,   \
              (mode *)((ArgPtr).a0 +                                \
                       (ArgPtr).offset -                            \
		               (((int)sizeof(mode) + 7) & -8))              \
            )

#endif	// _ALPHA_

//
// Use the following macro _after_ argptr has been saved or processed
//
#define SKIP_PROCESSED_ARG(argptr, type) \
                    GET_NEXT_C_ARG(argptr, type); \
                    GET_STACK_POINTER(argptr,type)

#define GET_NEXT_S_ARG(argptr,type)     argptr += sizeof(type)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\zlib\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.4, March 11th, 2002

  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\inc\ndrshared\ndrtoken.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    ndrtoken.h

Abtract :

    Format character definitions, type flags, and other such stuff.
	Mainly from rpc\midl\inc\ndrtypes.h

Revision History :

	John Doty   johndoty May 2000  (Assembled from other ndr headers)

--------------------------------------------------------------------*/
#ifndef __NDRTOKEN_H__
#define __NDRTOKEN_H__

#ifdef __cplusplus
extern "C"
{
#endif

//
// Format character definitions.
//
// !!! WARNING WARNING WARNING !!!
//
// All of the format character values up to FC_PAD can no longer be changed,
// in order to preserve NT 3.5 compatability (excluding those marked as
// FC_UNUSED*, these were unused format characters in NDR library version 1.1).
// Their ordinal number, as well as semantics, must remain.
//
// When additional format characters are added (at the end), changes must
// be made in ndr20 as well as codegen\frmtstr.cxx to handle the new type.
// In particular, there is a pFormatCharNames table and a pNdrRoutineNames table
// that should be kept in ssync.
//
// !!! WARNING WARNING WARNING !!!
//

typedef enum {


    //
    // This might catch some errors, probably can be removed after debugging.
    //
    FC_ZERO,

    //
    // Simple integer and floating point types.
    //

    FC_BYTE,                    // 0x01
    FC_CHAR,                    // 0x02
    FC_SMALL,                   // 0x03
    FC_USMALL,                  // 0x04

    FC_WCHAR,                   // 0x05
    FC_SHORT,                   // 0x06
    FC_USHORT,                  // 0x07

    FC_LONG,                    // 0x08
    FC_ULONG,                   // 0x09

    FC_FLOAT,                   // 0x0a

    FC_HYPER,                   // 0x0b

    FC_DOUBLE,                  // 0x0c

    //
    // Enums.
    //
    FC_ENUM16,                  // 0x0d
    FC_ENUM32,                  // 0x0e

    //
    // !!!IMPORTANT!!!
    // All format charaters which appear before this comment must have an
    // enum value which will fit in 4 bits.
    //

    //
    // Special.
    //
    FC_IGNORE,                  // 0x0f
    FC_ERROR_STATUS_T,          // 0x10

    //
    // Pointer types :
    //     RP - reference pointer
    //     UP - unique pointer
    //     OP - OLE unique pointer
    //     FP - full pointer
    //

    FC_RP,                      // 0x11
    FC_UP,                      // 0x12
    FC_OP,                      // 0x13
    FC_FP,                      // 0x14

    //
    // Structures
    //

    //
    // Structure containing only simple types and fixed arrays.
    //
    FC_STRUCT,                  // 0x15

    //
    // Structure containing only simple types, pointers and fixed arrays.
    //
    FC_PSTRUCT,                 // 0x16

    //
    // Structure containing a conformant array plus all those types
    // allowed by FC_STRUCT.
    //
    FC_CSTRUCT,                 // 0x17

    //
    // Struct containing a conformant array plus all those types allowed by
    // FC_PSTRUCT.
    //
    FC_CPSTRUCT,                // 0x18

    //
    // Struct containing either a conformant varying array or a conformant
    // string, plus all those types allowed by FC_PSTRUCT.
    //
    FC_CVSTRUCT,                // 0x19

    //
    // Complex struct - totally bogus!
    //
    FC_BOGUS_STRUCT,            // 0x1a

    //
    // Arrays.
    //

    //
    // Conformant arrray.
    //
    FC_CARRAY,                  // 0x1b

    //
    // Conformant varying array.
    //
    FC_CVARRAY,                 // 0x1c

    //
    // Fixed array, small and large.
    //
    FC_SMFARRAY,                // 0x1d
    FC_LGFARRAY,                // 0x1e

    //
    // Varying array, small and large.
    //
    FC_SMVARRAY,                // 0x1f
    FC_LGVARRAY,                // 0x20

    //
    // Complex arrays - totally bogus!
    //
    FC_BOGUS_ARRAY,             // 0x21

    //
    // Strings :
    //
    // The order of these should have been moved around, but it's too late
    // now.
    //
    //     CSTRING - character string
    //     BSTRING - byte string (Beta2 compatability only)
    //     SSTRING - structure string
    //     WSTRING - wide charater string
    //

    //
    // Conformant strings.
    //
    FC_C_CSTRING,               // 0x22
    FC_C_BSTRING,               // 0x23
    FC_C_SSTRING,               // 0x24
    FC_C_WSTRING,               // 0x25

    //
    // Non-conformant strings.
    //
    FC_CSTRING,                 // 0x26
    FC_BSTRING,                 // 0x27
    FC_SSTRING,                 // 0x28
    FC_WSTRING,                 // 0x29

    //
    // Unions
    //
    FC_ENCAPSULATED_UNION,      // 0x2a
    FC_NON_ENCAPSULATED_UNION,  // 0x2b

    //
    // Byte count pointer.
    //
    FC_BYTE_COUNT_POINTER,      // 0x2c

    //
    // transmit_as and represent_as
    //
    FC_TRANSMIT_AS,             // 0x2d
    FC_REPRESENT_AS,            // 0x2e

    //
    // Cairo Interface pointer.
    //
    FC_IP,                      // 0x2f

    //
    // Binding handle types
    //
    FC_BIND_CONTEXT,            // 0x30
    FC_BIND_GENERIC,            // 0x31
    FC_BIND_PRIMITIVE,          // 0x32
    FC_AUTO_HANDLE,             // 0x33
    FC_CALLBACK_HANDLE,         // 0x34
    FC_UNUSED1,                 // 0x35

    // Embedded pointer - used in complex structure layouts only.
    FC_POINTER,                 // 0x36

    //
    // Alignment directives, used in structure layouts.
    // No longer generated with post NT5.0 MIDL.
    //

    FC_ALIGNM2,                 // 0x37 
    FC_ALIGNM4,                 // 0x38
    FC_ALIGNM8,                 // 0x39

    FC_UNUSED2,                 // 0x3a
    FC_UNUSED3,                 // 0x3b
    FC_UNUSED4,                 // 0x3c

    //
    // Structure padding directives, used in structure layouts only.
    //
    FC_STRUCTPAD1,              // 0x3d
    FC_STRUCTPAD2,              // 0x3e
    FC_STRUCTPAD3,              // 0x3f
    FC_STRUCTPAD4,              // 0x40
    FC_STRUCTPAD5,              // 0x41
    FC_STRUCTPAD6,              // 0x42
    FC_STRUCTPAD7,              // 0x43

    //
    // Additional string attribute.
    //
    FC_STRING_SIZED,            // 0x44

    FC_UNUSED5,                 // 0x45

    //
    // Pointer layout attributes.
    //
    FC_NO_REPEAT,               // 0x46
    FC_FIXED_REPEAT,            // 0x47
    FC_VARIABLE_REPEAT,         // 0x48
    FC_FIXED_OFFSET,            // 0x49
    FC_VARIABLE_OFFSET,         // 0x4a

    // Pointer section delimiter.
    FC_PP,                      // 0x4b

    // Embedded complex type.
    FC_EMBEDDED_COMPLEX,        // 0x4c

    // Parameter attributes.
    FC_IN_PARAM,                // 0x4d
    FC_IN_PARAM_BASETYPE,       // 0x4e
    FC_IN_PARAM_NO_FREE_INST,   // 0x4d
    FC_IN_OUT_PARAM,            // 0x50
    FC_OUT_PARAM,               // 0x51
    FC_RETURN_PARAM,            // 0x52
    FC_RETURN_PARAM_BASETYPE,   // 0x53

    //
    // Conformance/variance attributes.
    //
    FC_DEREFERENCE,             // 0x54
    FC_DIV_2,                   // 0x55
    FC_MULT_2,                  // 0x56
    FC_ADD_1,                   // 0x57
    FC_SUB_1,                   // 0x58
    FC_CALLBACK,                // 0x59

    // Iid flag.
    FC_CONSTANT_IID,            // 0x5a

    FC_END,                     // 0x5b
    FC_PAD,                     // 0x5c
    FC_EXPR,                    // 0x5d
    FC_PARTIAL_IGNORE_PARAM,    // 0x5e

    //
    // split Conformance/variance attributes.
    //
    FC_SPLIT_DEREFERENCE = 0x74,      // 0x74
    FC_SPLIT_DIV_2,                   // 0x75
    FC_SPLIT_MULT_2,                  // 0x76
    FC_SPLIT_ADD_1,                   // 0x77
    FC_SPLIT_SUB_1,                   // 0x78
    FC_SPLIT_CALLBACK,                // 0x79

    //
    // **********************************
    // New Post NT 3.5 format characters.
    // **********************************
    //

    //
    // Attributes, directives, etc.
    //

    //
    // New types.
    //
    // These start at 0xb1 (0x31 + 0x80) so that their routines can simply be
    // placed sequentially in the various routine tables, while using
    // a new ROUTINE_INDEX() macro which strips off the most significant bit
    // of the format character.  The value 0x31 is the next value after
    // FC_BIND_CONTEXT, whose routines were previously the last to appear
    // in the routine tables.
    //
    FC_HARD_STRUCT = 0xb1,      // 0xb1

    FC_TRANSMIT_AS_PTR,         // 0xb2
    FC_REPRESENT_AS_PTR,        // 0xb3

    FC_USER_MARSHAL,            // 0xb4

    FC_PIPE,                    // 0xb5

    FC_BLKHOLE,                 // 0xb6

    FC_RANGE,                   // 0xb7     NT 5 beta2 MIDL 3.3.110

    FC_INT3264,                 // 0xb8     NT 5 beta2, MIDL64, 5.1.194+
    FC_UINT3264,                // 0xb9     NT 5 beta2, MIDL64, 5.1.194+

    //
    // Post NT 5.0 strings
    //

    //
    // Arrays of international characters
    //
    FC_CSARRAY,                 // 0xba
    FC_CS_TAG,                  // 0xbb

    // Replacement for alignment in structure layout.
    FC_STRUCTPADN,              // 0xbc

    FC_INT128,                  // 0xbd
    FC_UINT128,                 // 0xbe
    FC_FLOAT80,                 // 0xbf
    FC_FLOAT128,                // 0xc0

    FC_BUFFER_ALIGN,            // 0xc1

    //
    // New Ndr64 codes
    //

    FC_ENCAP_UNION,             // 0xc2

    // new arrays types

    FC_FIX_ARRAY,               // 0xc3
    FC_CONF_ARRAY,              // 0xc4
    FC_VAR_ARRAY,               // 0xc5 
    FC_CONFVAR_ARRAY,           // 0xc6
    FC_FIX_FORCED_BOGUS_ARRAY,  // 0xc7
    FC_FIX_BOGUS_ARRAY,         // 0xc8 
    FC_FORCED_BOGUS_ARRAY,      // 0xc9

    FC_CHAR_STRING,             // 0xca
    FC_WCHAR_STRING,            // 0xcb
    FC_STRUCT_STRING,           // 0xcc

    FC_CONF_CHAR_STRING,        // 0xcd
    FC_CONF_WCHAR_STRING,       // 0xce
    FC_CONF_STRUCT_STRING,      // 0xcf

    // new structures types
    FC_CONF_STRUCT,             // 0xd0
    FC_CONF_PSTRUCT,            // 0xd1
    FC_CONFVAR_STRUCT,          // 0xd2
    FC_CONFVAR_PSTRUCT,         // 0xd3
    FC_FORCED_BOGUS_STRUCT,     // 0xd4
    FC_CONF_BOGUS_STRUCT,       // 0xd5
    FC_FORCED_CONF_BOGUS_STRUCT,// 0xd7
    
    FC_END_OF_UNIVERSE          // 0xd8

} FORMAT_CHARACTER;

//
// Conformance and variance constants
//
#define FC_NORMAL_CONFORMANCE           (unsigned char) 0x00
#define FC_POINTER_CONFORMANCE          (unsigned char) 0x10
#define FC_TOP_LEVEL_CONFORMANCE        (unsigned char) 0x20
#define FC_CONSTANT_CONFORMANCE         (unsigned char) 0x40
#define FC_TOP_LEVEL_MULTID_CONFORMANCE (unsigned char) 0x80

#define FC_NORMAL_VARIANCE              FC_NORMAL_CONFORMANCE
#define FC_POINTER_VARIANCE             FC_POINTER_CONFORMANCE
#define FC_TOP_LEVEL_VARIANCE           FC_TOP_LEVEL_CONFORMANCE
#define FC_CONSTANT_VARIANCE            FC_CONSTANT_CONFORMANCE
#define FC_TOP_LEVEL_MULTID_VARIANCE    FC_TOP_LEVEL_MULTID_CONFORMANCE

#define FC_NORMAL_SWITCH_IS             FC_NORMAL_CONFORMANCE
#define FC_POINTER_SWITCH_IS            FC_POINTER_CONFORMANCE
#define FC_TOP_LEVEL_SWITCH_IS          FC_TOP_LEVEL_CONFORMANCE
#define FC_CONSTANT_SWITCH_IS           FC_CONSTANT_CONFORMANCE

//
// Pointer attributes.
//
#define FC_ALLOCATE_ALL_NODES       0x01
#define FC_DONT_FREE                0x02
#define FC_ALLOCED_ON_STACK         0x04
#define FC_SIMPLE_POINTER           0x08
#define FC_POINTER_DEREF            0x10

#define NDR_DEFAULT_CORR_CACHE_SIZE 400

#if !defined(__RPC_MAC__)
//
// Interpreter bit flag structures.
//

// These are the old Oi interpreter proc flags.

typedef struct
    {
    unsigned char   FullPtrUsed             : 1;    // 0x01
    unsigned char   RpcSsAllocUsed          : 1;    // 0x02
    unsigned char   ObjectProc              : 1;    // 0x04
    unsigned char   HasRpcFlags             : 1;    // 0x08
    unsigned char   IgnoreObjectException   : 1;    // 0x10
    unsigned char   HasCommOrFault          : 1;    // 0x20
    unsigned char   UseNewInitRoutines      : 1;    // 0x40
    unsigned char   Unused                  : 1;
    } INTERPRETER_FLAGS, *PINTERPRETER_FLAGS;

// These are the Oi2 parameter flags.

typedef struct
    {
    unsigned short  MustSize            : 1;    // 0x0001
    unsigned short  MustFree            : 1;    // 0x0002
    unsigned short  IsPipe              : 1;    // 0x0004
    unsigned short  IsIn                : 1;    // 0x0008
    unsigned short  IsOut               : 1;    // 0x0010
    unsigned short  IsReturn            : 1;    // 0x0020
    unsigned short  IsBasetype          : 1;    // 0x0040
    unsigned short  IsByValue           : 1;    // 0x0080
    unsigned short  IsSimpleRef         : 1;    // 0x0100
    unsigned short  IsDontCallFreeInst  : 1;    // 0x0200
    unsigned short  SaveForAsyncFinish  : 1;    // 0x0400
    unsigned short  IsPartialIgnore     : 1;    // 0x0800
    unsigned short  IsForceAllocate     : 1;    // 0x1000
    unsigned short  ServerAllocSize     : 3;    // 0xe000
    } PARAM_ATTRIBUTES, *PPARAM_ATTRIBUTES;

// These are the new Oi2 proc flags.

typedef struct
    {
    unsigned char   ServerMustSize      : 1;    // 0x01
    unsigned char   ClientMustSize      : 1;    // 0x02
    unsigned char   HasReturn           : 1;    // 0x04
    unsigned char   HasPipes            : 1;    // 0x08
    unsigned char   Unused              : 1;
    unsigned char   HasAsyncUuid        : 1;    // 0x20
    unsigned char   HasExtensions       : 1;    // 0x40
    unsigned char   HasAsyncHandle      : 1;    // 0x80
    } INTERPRETER_OPT_FLAGS, *PINTERPRETER_OPT_FLAGS;

// This is the proc header layout for object procs starting with MIDL 3.3.129,
// introduced for the async_uuid() support in dcom but generated for ony object
// interface, regardless of the compiler mode and interface being async.
// Handle is always autohandle and so there never is explicit handle descriptor.
// RpcFlags are always present to make the layout fixed.

typedef struct _NDR_DCOM_OI2_PROC_HEADER
    {
    unsigned char               HandleType;          // The old Oi header
    INTERPRETER_FLAGS           OldOiFlags;          //
    unsigned short              RpcFlagsLow;         //
    unsigned short              RpcFlagsHi;          //
    unsigned short              ProcNum;             //
    unsigned short              StackSize;           //
    // expl handle descr is never generated          //
    unsigned short              ClientBufferSize;    // The Oi2 header
    unsigned short              ServerBufferSize;    //
    INTERPRETER_OPT_FLAGS       Oi2Flags;            //
    unsigned char               NumberParams;        //
    } NDR_DCOM_OI2_PROC_HEADER, *PNDR_DCOM_OI2_PROC_HEADER;

// These are extended Oi2 interpreter proc flags.
// They have been introduced for NT5 beta2.

typedef struct
    {
    unsigned char   HasNewCorrDesc      : 1;    // 0x01
    unsigned char   ClientCorrCheck     : 1;    // 0x02
    unsigned char   ServerCorrCheck     : 1;    // 0x04
    unsigned char   HasNotify           : 1;    // 0x08
    unsigned char   HasNotify2          : 1;    // 0x10
    unsigned char   HasComplexReturn    : 1;    // 0x20
    unsigned char   Unused              : 2;
    } INTERPRETER_OPT_FLAGS2, *PINTERPRETER_OPT_FLAGS2;

// This is the layout of the proc header extensions introduced for denial of
// attacks for NT5 beta2, MIDL version 3.3.129.
// The extensions would be announced by the HasExtensions Oi2 flag and would
// follow directly after the ParameterCount field of Oi2 header.

typedef struct
    {
    unsigned char               Size;   // size as the extension version
    INTERPRETER_OPT_FLAGS2      Flags2;
    unsigned short              ClientCorrHint;
    unsigned short              ServerCorrHint;
    unsigned short              NotifyIndex;
    } NDR_PROC_HEADER_EXTS, *PNDR_PROC_HEADER_EXTS;

typedef struct
    {
    unsigned char               Size;   // size as the extension version
    INTERPRETER_OPT_FLAGS2      Flags2;
    unsigned short              ClientCorrHint;
    unsigned short              ServerCorrHint;
    unsigned short              NotifyIndex;
    unsigned short              FloatArgMask;
    } NDR_PROC_HEADER_EXTS64, *PNDR_PROC_HEADER_EXTS64;


// Context handle flags

typedef struct
    {
    unsigned char   CannotBeNull        : 1;    // 0x01
    unsigned char   Serialize           : 1;    // 0x02
    unsigned char   NoSerialize         : 1;    // 0x04
    unsigned char   IsStrict            : 1;    // 0x08
    unsigned char   IsReturn            : 1;    // 0x10
    unsigned char   IsOut               : 1;    // 0x20
    unsigned char   IsIn                : 1;    // 0x40
    unsigned char   IsViaPtr            : 1;    // 0x80

    } NDR_CONTEXT_HANDLE_FLAGS, *PNDR_CONTEXT_HANDLE_FLAGS;

typedef struct
    {
    unsigned char               Fc;
    NDR_CONTEXT_HANDLE_FLAGS    Flags;
    unsigned char               RundownRtnIndex;
    unsigned char               ParamOrdinal;   // Oicf: ordinal, /Oi param num
    } NDR_CONTEXT_HANDLE_ARG_DESC, *PNDR_CONTEXT_HANDLE_ARG_DESC;

// Type pickling flags

typedef struct _MIDL_TYPE_PICKLING_FLAGS
    {
    unsigned long   Oicf                : 1;
    unsigned long   HasNewCorrDesc      : 1;
    unsigned long   Unused              : 30;
    } MIDL_TYPE_PICKLING_FLAGS, *PMIDL_TYPE_PICKLING_FLAGS;

/*

typedef struct 
    {
    unsigned long   HandleType          : 3;
    unsigned long   ProcType            : 3;
    unsigned long   IsInterpreted       : 2;
    unsigned long   IsObject            : 1;
    unsigned long   IsAsync             : 1;
    unsigned long   IsPickled           : 2;
    unsigned long   UsesFullPtrPackage  : 1;
    unsigned long   UsesRpcSmPackage    : 1;
    unsigned long   UsesPipes           : 1;
    unsigned long   HandlesExceptions   : 2;
    unsigned long   ServerMustsize      : 1;
    unsigned long   ClientMustsize      : 1;
    unsigned long   HasReturn           : 1;
    unsigned long   ClientCorrelation   : 1;
    unsigned long   ServerCorrelation   : 1;   
    unsigned long   HasNotify           : 1;
    unsigned long   HasOtherExtensions  : 1;
    unsigned long   Unused              : 8;
    } NDR64_FLAGS;

typedef struct
    {
    unsigned short  MustSize            : 1;    // 0x0001
    unsigned short  MustFree            : 1;    // 0x0002
    unsigned short  IsPipe              : 1;    // 0x0004
    unsigned short  IsIn                : 1;    // 0x0008
    unsigned short  IsOut               : 1;    // 0x0010
    unsigned short  IsReturn            : 1;    // 0x0020
    unsigned short  IsBasetype          : 1;    // 0x0040
    unsigned short  IsByValue           : 1;    // 0x0080
    unsigned short  IsSimpleRef         : 1;    // 0x0100
    unsigned short  IsDontCallFreeInst  : 1;    // 0x0200
    unsigned short  SaveForAsyncFinish  : 1;    // 0x0400
    unsigned short  Unused              : 5;
    unsigned short  UseCache            : 1;    // new
    } NDR64_PARAM_ATTRIBUTES, *PNDR64_PARAM_ATTRIBUTES;


typedef struct 
    {
    NDR64_PARAM_ATTRIBUTES  ParamAttr;
    union 
        {
        unsigned short      ParamOffset;
        struct 
            {
            unsigned char       Type;
            unsigned char       Unused;
            }   SimpleType;
    };
    unsigned long       StackOffset;
    } NDR64_PARAM_DESCRIPTION, *PNDR64_PARAM_DESCRIPTION;
*/

#else
// now Mac defs: bits are flipped on Mac.

typedef struct
    {
    unsigned char   Unused              : 3;
    unsigned char   HasNotify2          : 1;    // 0x10
    unsigned char   HasNotify           : 1;    // 0x08
    unsigned char   ServerCorrCheck     : 1;    // 0x04
    unsigned char   ClientCorrCheck     : 1;    // 0x02
    unsigned char   HasNewCorrDec       : 1;    // 0x01
    } INTERPRETER_OPT_FLAGS2, *PINTERPRETER_OPT_FLAGS2;

typedef struct
    {
    unsigned char   Unused                  : 1;
    unsigned char   UseNewInitRoutines      : 1;    // 0x40
    unsigned char   HasCommOrFault          : 1;    // 0x20
    unsigned char   IgnoreObjectException   : 1;    // 0x10
    unsigned char   HasRpcFlags             : 1;    // 0x08
    unsigned char   ObjectProc              : 1;    // 0x04
    unsigned char   RpcSsAllocUsed          : 1;    // 0x02
    unsigned char   FullPtrUsed             : 1;    // 0x01
    } INTERPRETER_FLAGS, *PINTERPRETER_FLAGS;

typedef struct
    {
    unsigned char   HasAsyncHandle      : 1;    // 0x80
    unsigned char   HasExtensions       : 1;    // 0x40
    unsigned char   Unused              : 2;
    unsigned char   HasPipes            : 1;    // 0x08
    unsigned char   HasReturn           : 1;    // 0x04
    unsigned char   ClientMustSize      : 1;    // 0x02
    unsigned char   ServerMustSize      : 1;    // 0x01
    } INTERPRETER_OPT_FLAGS, *PINTERPRETER_OPT_FLAGS;

typedef struct
    {
    unsigned short  ServerAllocSize     : 3;    // 0xe000
    unsigned short  Unused              : 2;
    unsigned short  SaveForAsyncFinish  : 1;    // 0x0400
    unsigned short  IsDontCallFreeInst  : 1;    // 0x0200
    unsigned short  IsSimpleRef         : 1;    // 0x0100
//
    unsigned short  IsByValue           : 1;    // 0x0080
    unsigned short  IsBasetype          : 1;    // 0x0040
    unsigned short  IsReturn            : 1;    // 0x0020
    unsigned short  IsOut               : 1;    // 0x0010
    unsigned short  IsIn                : 1;    // 0x0008
    unsigned short  IsPipe              : 1;    // 0x0004
    unsigned short  MustFree            : 1;    // 0x0002
    unsigned short  MustSize            : 1;    // 0x0001
    } PARAM_ATTRIBUTES, *PPARAM_ATTRIBUTES;

#endif

#pragma pack(2)
    typedef struct 
        {
        PARAM_ATTRIBUTES    ParamAttr;
        unsigned short      StackOffset;
        union 
            {
            unsigned short  TypeOffset;
            struct 
                {
                unsigned char  Type;
				unsigned char  Unused;
                } SimpleType;
            };
        } PARAM_DESCRIPTION, *PPARAM_DESCRIPTION;
#pragma pack()

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\daytona.inc ===
#
# This file contains the common stuff related to SENS on NT5 platforms.
#

C_DEFINES=$(C_DEFINES) -DSENS_NT5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\chicago.inc ===
#
# This file contains the common stuff related to SENS on Win9x platforms.
#


C_DEFINES=$(C_DEFINES) -DSENS_CHICAGO -D_WIN32_DCOM

CHICAGO_PRODUCT=1
ALT_PROJECT_TARGET=chicago
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\sens.inc ===
#
# This file contains the common stuff related to SENS on all platforms.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\inc\ndrshared\ndrtypegen.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    ndrtypegen.h

Abtract :

    Functions for generating type format strings from ITypeInfo *s.

	NOTE: I'd like to move this into either ndrmisc.h or ndrtoken.h,
	      but neither of those can include oaidl.h, which is needed for
		  ITypeInfo and it's related structures.

Revision History :

	John Doty   johndoty May 2000  

--------------------------------------------------------------------*/
#ifndef __NDRTYPEGEN_H__
#define __NDRTYPEGEN_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Type Format String Generation
//
HRESULT 
NdrpGetTypeGenCookie(void **ppvTypeGenCookie);

HRESULT
NdrpReleaseTypeGenCookie(void *pvTypeGenCookie);

HRESULT
NdrpGetProcFormatString(IN  void      *pvTypeGenCookie,
						IN  ITypeInfo *pTypeInfo,
						IN  FUNCDESC  *pFuncDesc,
						IN  USHORT     iMethod,
						OUT PFORMAT_STRING pProcFormatString,
						OUT USHORT    *pcbFormat);

HRESULT
NdrpGetTypeFormatString(IN void *            pvTypeGenCookie,
						OUT PFORMAT_STRING * pTypeFormatString,
						OUT USHORT *         pLength);

HRESULT
NdrpReleaseTypeFormatString(PFORMAT_STRING pTypeFormatString);

HRESULT 
NdrpVarVtOfTypeDesc(IN ITypeInfo *pTypeInfo,
					IN TYPEDESC  *ptdesc,
					OUT VARTYPE  *vt);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\nt4.inc ===
#
# This file contains the common stuff related to SENS on NT4 platforms.
#

#
# Do this to assure that we run on NT 4.0 and Win95, even with
# NT5/Memphis headers.
!if !defined(WIN32_WINNT_VERSION)
WIN32_WINNT_VERSION=0x0400
!endif
!if !defined(WIN32_IE_VERSION)
WIN32_IE_VERSION=0x0500
!endif

# Override NT5 settings
SUBSYSTEM_VERSION=4.00

C_DEFINES=$(C_DEFINES) -DSENS_NT4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\notify\stub_usertok_c.c ===
#include <usertok_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\notify\stub_irnotify_s.c ===
#include <irnotify_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\common\sysinc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sysinc.h

Abstract:

    This contains all the platform-independent stuff for the SENS project.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          3/6/1998         Start.

--*/


#ifndef __SYSINC_H__
#define __SYSINC_H__

//
// Global defines
//

#ifndef SENS_CHICAGO

#define SENS_NT
#define UNICODE
#define _UNICODE

#else // SENS_CHICAGO

#undef UNICODE
#undef _UNICODE

#endif // SENS_CHICAGO



//
// Includes
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>


//
// Typedefs
//
typedef WCHAR               SENS_CHAR;
typedef SHORT               SENS_SCHAR;

typedef WCHAR               *PSENS_CHAR;
typedef SHORT               *PSENS_SCHAR;

//
// Defines
//
#define SENS_STRING(string)     L##string
#define SENS_BSTR(bstr)         L##bstr

//
// Function Mappings
//

//
// Threadpool Apis
//

#define SENS_TIMER_CALLBACK_RETURN          VOID NTAPI
#define SENS_LONG_ITEM                      (WT_EXECUTELONGFUNCTION)
#define SENS_TIMER_CREATE_FAILED(bStatus, hTimer) \
        (FALSE == bStatus)

// Use KERNEL32's Win32 functions
#define SensQueueUserWorkItem               QueueUserWorkItem
#define SensRegisterWaitForSingleObject     RegisterWaitForSingleObject
#define SensUnregisterWait                  UnregisterWait
#define SensCreateTimerQueue                CreateTimerQueue
#define SensDeleteTimerQueue                DeleteTimerQueue
#define SensCancelTimerQueueTimer(TimerQueue, Timer, Event) \
        DeleteTimerQueueTimer(TimerQueue, Timer, Event)      
#define SensSetTimerQueueTimer(bStatus, hTimer, hQueue, pfnCallback, pContext, dwDueTime, dwPeriod, dwFlags) \
        bStatus = CreateTimerQueueTimer(&hTimer, hQueue, pfnCallback, pContext, dwDueTime, dwPeriod, SENS_LONG_ITEM)        

//
// Output Macros and functions
//
#ifdef DBG

//
// Currently these macros get preprocesed as some some variants of printf.
// Eventually, these will be replaced by a function more comprehensive than
// printf.
//
// Notes:
//
// o SensDbgPrintW works like ntdll!DbgPrint() except that it can handle wide
//   strings.
//
#define SensPrint(_LEVEL_, _X_)             SensDbgPrintW _X_
#define SensPrintA(_LEVEL_, _X_)            SensDbgPrintA _X_
#define SensPrintW(_LEVEL_, _X_)            SensDbgPrintW _X_
#define SensPrintToDebugger(_LEVEL_, _X_)   DbgPrint      _X_
#define SensBreakPoint()                    DebugBreak()

#else // RETAIL

//
// The following functions do nothing and they should be optimized and no
// code should be generated by the compiler.
//
#define SensPrint(_LEVEL_, _X_)             // Nothing
#define SensPrintA(_LEVEL_, _X_)            // Nothing
#define SensPrintW(_LEVEL_, _X_)            // Nothing
#define SensPrintToDebugger(_LEVEL_, _X_)   // Nothing
#define SensBreakPoint()                    // Nothing

#endif // DBG


#endif // __SYSINC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\notify\token.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       token.cxx
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <usertok.h>
#include <malloc.h>

extern "C"
{
HANDLE
GetCurrentUserTokenW(
                      WCHAR Winsta[],
                      DWORD DesiredAccess
                      );

HANDLE
GetCurrentUserTokenA(
                     char Winsta[],
                     DWORD DesiredAccess
                     );
}

HANDLE
GetCurrentUserTokenW(
                      WCHAR Winsta[],
                      DWORD DesiredAccess
                      )
{
    unsigned long handle = 0;
    error_status_t status;
    handle_t binding;

    //
    // Use a dynamic binding - it will pick up the endpoint from the interfaace.
    //
    status = RpcBindingFromStringBinding(L"ncacn_np:", &binding);
    if (status)
        {
        SetLastError(status);
        return 0;
        }

    RPC_SECURITY_QOS Qos;

    Qos.Version = 1;
    Qos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    Qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    Qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    status = RpcBindingSetAuthInfoEx( binding,
                                      NULL,
                                      RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                                      RPC_C_AUTHN_WINNT,
                                      NULL,                           // default credentials
                                      RPC_C_AUTHZ_NONE,
                                      &Qos
                                      );
    if (status)
        {
        RpcBindingFree( &binding );
        SetLastError(status);
        return 0;
        }

    status = SecpGetCurrentUserToken( binding, Winsta, GetCurrentProcessId(), &handle, DesiredAccess);
    if (status)
        {
        RpcBindingFree( &binding );
        if (status == RPC_S_UNKNOWN_AUTHN_SERVICE ||
            status == RPC_S_SERVER_UNAVAILABLE    ||
            status == RPC_S_CALL_FAILED )
            {
            status = ERROR_NOT_LOGGED_ON;
            }

        SetLastError(status);
        return 0;
        }

    RpcBindingFree( &binding );

    return ULongToPtr(handle);
}

HANDLE
GetCurrentUserTokenA(
                     char Winsta[],
                     DWORD DesiredAccess
                     )
{
    wchar_t * UnicodeWinsta;
    unsigned Length;

    Length = strlen(Winsta);

    UnicodeWinsta = (wchar_t *) _alloca(sizeof(wchar_t) * (Length + 1));
    if (!UnicodeWinsta)
        {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
        }

    if (MultiByteToWideChar( CP_ACP,
                             0,        // no special flags
                             Winsta,
                             Length,
                             UnicodeWinsta,
                             Length+1
                             ))
        {
        return 0;
        }

    return GetCurrentUserTokenW( UnicodeWinsta, DesiredAccess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\idl\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

#
# Common MIDL related define
#

CPP_CMD = -cpp_cmd "$(MIDL_CPP)"
CPP_OPT = $(MIDL_FLAGS)
MIDL_INC = -I$(COM_INC_PATH) -I$(SDK_INC_PATH) -I$(CRT_INC_PATH) -I..\sensapi -I..\sensapip
COMMON_FLAGS= -Oicf -error all -robust -c_ext -ms_ext -oldnames -char unsigned $(CPP_CMD) $(CPP_OPT) $(MIDL_INC)

#
# Common variables
#

OUTPUT =$(_OBJ_DIR)\$(TARGET_DIRECTORY)
SENSAPI =api
NOTIFY =notify
IRNOTIFY =irnotify
TOKEN =usertok

#
# Destination for generated files
#

SENSAPI_HDR =..\senssvc\$(SENSAPI).h
SENSAPI_CSTUB=..\sensapi\$(SENSAPI)_c.c
SENSAPI_SSTUB=..\senssvc\$(SENSAPI)_s.c

NOTIFY_HDR =..\senssvc\$(NOTIFY).h
NOTIFY_CSTUB=..\sensapip\$(NOTIFY)_c.c
NOTIFY_CSTUB2=..\senslogn\$(NOTIFY)_c.c
NOTIFY_SSTUB=..\senssvc\$(NOTIFY)_s.c

IRNOTIFY_HDR =..\senslogn\$(IRNOTIFY).h
IRNOTIFY_CSTUB=..\senslogn\$(IRNOTIFY)_c.c
IRNOTIFY_SSTUB=..\notify\$(IRNOTIFY)_s.c

TOKEN_HDR=..\senslogn\$(TOKEN).h
TOKEN_CSTUB=..\notify\$(TOKEN)_c.c
TOKEN_SSTUB=..\senslogn\$(TOKEN)_s.c


#
# Targets
#

allidl: sensapi notify token irnotify


#
# SENS Connectivity APIs
#
sensapi: $(OUTPUT)\$(SENSAPI).h $(OUTPUT)\$(SENSAPI)_c.c $(OUTPUT)\$(SENSAPI)_s.c

$(OUTPUT)\$(SENSAPI).h $(OUTPUT)\$(SENSAPI)_c.c $(OUTPUT)\$(SENSAPI)_s.c: $(SENSAPI).idl $(SENSAPI).acf
        midl $(COMMON_FLAGS) -out $(OUTPUT) $(SENSAPI).idl

#
# SENS Notify APIs (Private)
#
notify: $(OUTPUT)\$(NOTIFY).h $(OUTPUT)\$(NOTIFY)_c.c $(OUTPUT)\$(NOTIFY)_s.c

$(OUTPUT)\$(NOTIFY).h $(OUTPUT)\$(NOTIFY)_c.c $(OUTPUT)\$(NOTIFY)_s.c: $(NOTIFY).idl $(NOTIFY).acf
        midl $(COMMON_FLAGS) /prefix client "SensApip_" -out $(OUTPUT) $(NOTIFY).idl


#
# Info about currently logged-in user (Private)
#
token: $(OUTPUT)\$(TOKEN).h $(OUTPUT)\$(TOKEN)_c.c $(OUTPUT)\$(TOKEN)_s.c

$(OUTPUT)\$(TOKEN).h $(OUTPUT)\$(TOKEN)_c.c $(OUTPUT)\$(TOKEN)_s.c: $(TOKEN).idl $(TOKEN).acf
        midl $(COMMON_FLAGS) -prefix server _ -out $(OUTPUT) $(TOKEN).idl


irnotify: $(OUTPUT)\$(IRNOTIFY).h $(OUTPUT)\$(IRNOTIFY)_c.c $(OUTPUT)\$(IRNOTIFY)_s.c

$(OUTPUT)\$(IRNOTIFY).h $(OUTPUT)\$(IRNOTIFY)_c.c $(OUTPUT)\$(IRNOTIFY)_s.c: $(IRNOTIFY).idl $(IRNOTIFY).acf
        midl $(COMMON_FLAGS) -prefix server _ -out $(OUTPUT) $(IRNOTIFY).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\common\common.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    common.cxx

Abstract:

    This file contains some common stuff for SENS project.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include "common.hxx"
#include <windows.h>


#ifdef DBG
extern DWORD gdwDebugOutputLevel;
#endif // DBG

//
// Constants
//

#define MAX_DBGPRINT_LEN        512



#if defined(SENS_CHICAGO)

//
// Macros
//
#define UnicodeStrLen(str)      lstrlenW(str)




char *
SensUnicodeStringToAnsi(
    unsigned short * StringW
    )
/*++

Routine Description:

    Converts UNICODE string to it's ANSI equivalent.

Arguments:

    StringW - The UNICODE string.

Notes:

    a. The returned ANSI string is to be freed using the "delete" operator.

Return Value:

    The equivalent ANSI string, if successful.

    NULL, otherwise

--*/
{
    int retVal;
    short Length;
    char * StringA;

    // Simple check
    if (NULL == StringW)
        {
        return (NULL);
        }

    // Allocate Multi-byte buffer
    Length = UnicodeStrLen(StringW);
    StringA = new char [Length * 2 + 2];
    if (NULL == StringA)
        {
        return (NULL);
        }

    // Perform the conversion
    retVal = WideCharToMultiByte(
                 CP_ACP,                // Code Page
                 0,                     // Performance and mapping flags
                 (LPCWSTR) StringW,     // Wide String
                 -1,                    // Number of characters in Wide String
                 (LPSTR) StringA,       // Multi-byte string buffer
                 Length * 2 + 2,        // Size of the Multi-byte string buffer
                 NULL,                  // Default for unmappable characters
                 NULL                   // Flag when default character is used
                 );
    if (0 == retVal)
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] WideCharToMultiByte() failed with %d\n",
                            GetLastError()));
        delete StringA;
        return (NULL);
        }

    return (StringA);
}



unsigned short *
SensAnsiStringToUnicode(
    char * StringA
    )
/*++

Routine Description:

    Converts ANSI string to it's UNICODE equivalent.

Arguments:

    StringA - The ANSI string.

Notes:

    a. The returned UNICODE string is to be freed using the "delete" operator.

Return Value:

    The equivalent UNICODE string, if successful.

    NULL, otherwise

--*/
{
    int retVal;
    short Length;
    unsigned short * StringW;

    // Simple check
    if (NULL == StringA)
        {
        return (NULL);
        }

    // Allocate UNICODE buffer
    Length = strlen((const char *) StringA);
    StringW = new unsigned short [Length + 1];
    if (NULL == StringW)
        {
        return (NULL);
        }

    retVal = MultiByteToWideChar(
                 CP_ACP,            // Code page
                 0,                 // Character type options
                 (LPCSTR) StringA,  // Multi-byte string
                 -1,                // Number of characters in multi-byte string
                 (LPWSTR) StringW,  // UNICODE string buffer
                 Length * 2 + 2     // Length of the UNICODE string buffer
                 );
    if (0 == retVal)
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] MultiByteToWideChar() failed with %d\n",
                            GetLastError()));
        delete StringW;
        return (NULL);
        }

    return (StringW);
}



#endif // SENS_CHICAGO


//
// Available only on Debug builds.
//

#if DBG



ULONG _cdecl
SensDbgPrintA(
    CHAR * Format,
    ...
    )
/*++

Routine Description:

    Equivalent of NT's DbgPrint().

Arguments:

    Same as for printf()

Return Value:

    0, if successful.

--*/
{
    va_list arglist;
    CHAR OutputBuffer[MAX_DBGPRINT_LEN];
    ULONG length;
    static BeginningOfLine = 1;
    static LineCount = 0;

    // See if we are supposed to print
    if (0x0 == gdwDebugOutputLevel)
        {
        return -1;
        }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if (BeginningOfLine)
        {
        //
        // If we're writing to the debug terminal,
        // indicate this is a SENS message.
        //
        length += (ULONG) wsprintfA(&OutputBuffer[length], "[SENS] ");
        }

    //
    // Put the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) wvsprintfA(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );
    if (OutputBuffer[length-1] == '\n')
        {
        OutputBuffer[length-1] = '\r';
        OutputBuffer[length]   = '\n';
        OutputBuffer[length+1] = '\0';
        }

    va_end(arglist);

    if (length > MAX_DBGPRINT_LEN)
        {
        SensBreakPoint();
        }

    //
    //  Just output to the debug terminal
    //

#ifdef PRINT_TO_CONSOLE

    printf("%s\n", OutputBuffer);

#else // PRINT_TO_CONSOLE

#if !defined(SENS_CHICAGO)
    DbgPrint(OutputBuffer);
#else
    OutputDebugStringA(OutputBuffer);
#endif // SENS_CHICAGO

#endif // PRINT_TO_CONSOLE

    return (0);
}




ULONG _cdecl
SensDbgPrintW(
    WCHAR * Format,
    ...
    )
/*++

Routine Description:

    Equivalent of NT's DbgPrint().

Arguments:

    Same as for printf()

Return Value:

    0, if successful.

--*/
{
    va_list arglist;
    WCHAR OutputBuffer[MAX_DBGPRINT_LEN];
    ULONG length;
    static BeginningOfLine = 1;
    static LineCount = 0;

    // See if we are supposed to print
    if (0x0 == gdwDebugOutputLevel)
        {
        return -1;
        }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if (BeginningOfLine)
        {
        //
        // If we're writing to the debug terminal,
        // indicate this is a SENS message.
        //
        length += (ULONG) wsprintfW(&OutputBuffer[length], SENS_BSTR("[SENS] "));
        }

    //
    // Put the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) wvsprintfW(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == (WCHAR)'\n' );
    if (OutputBuffer[length-1] == (WCHAR)'\n')
        {
        OutputBuffer[length-1] = (WCHAR)'\r';
        OutputBuffer[length]   = (WCHAR)'\n';
        OutputBuffer[length+1] = (WCHAR)'\0';
        }

    va_end(arglist);

    if (length > MAX_DBGPRINT_LEN)
        {
        SensBreakPoint();
        }

    //
    //  Just output to the debug terminal
    //

#ifdef PRINT_TO_CONSOLE
    wprintf(SENS_BSTR("%s\n"), OutputBuffer);
#else
    OutputDebugStringW(OutputBuffer);
#endif

    return (0);
}





BOOL
ValidateError(
    IN int Status,
    IN unsigned int Count,
    IN const int ErrorList[])
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            // more error codes here
            } END_VALIDATE;

     This function is called with the RpcStatus and expected errors codes
     as parameters.  If RpcStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.
    Count - number of variable length arguments

    ... - One or more expected status codes.  Terminated with 0 (RPC_S_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    unsigned int i;

    for (i = 0; i < Count; i++)
        {
        if (ErrorList[i] == Status)
            {
            return TRUE;
            }
        }

    SensPrintToDebugger(SENS_DEB, ("[SENS] Assertion: unexpected failure %lu (0x%08x)\n",
                        (unsigned long)Status, (unsigned long)Status));

    return(FALSE);
}



void
EnableDebugOutputIfNecessary(
    void
    )
/*++

    This routine tries to set gdwDebugOuputLevel to the value defined
    in the regitry at HKLM\Software\Microsoft\Mobile\SENS\Debug value.
    All binaries using this function need to define the following
    global value:

        DWORD gdwDebugOutputLevel;

--*/
{
    HRESULT hr;
    HKEY hKeySens;
    LONG RegStatus;
    BOOL bStatus;
    DWORD dwType;
    DWORD cbData;
    LPBYTE lpbData;

    hr = S_OK;
    hKeySens = NULL;
    RegStatus = ERROR_SUCCESS;
    bStatus = FALSE;
    dwType = 0x0;
    cbData = 0x0;
    lpbData = NULL;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, // Handle of the key
                    SENS_REGISTRY_KEY,  // String which represents the sub-key to open
                    0,                  // Reserved (MBZ)
                    KEY_QUERY_VALUE,    // Security Access mask
                    &hKeySens           // Returned HKEY
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintToDebugger(SENS_ERR, ("[SENS] RegOpenKeyEx(Sens) returned %d.\n", RegStatus));
        goto Cleanup;
        }

    //
    // Query the Configured value
    //
    lpbData = (LPBYTE) &gdwDebugOutputLevel;
    cbData = sizeof(DWORD);

    RegStatus = RegQueryValueEx(
                    hKeySens,           // Handle of the sub-key
                    SENS_DEBUG_LEVEL,   // Name of the Value
                    NULL,               // Reserved (MBZ)
                    &dwType,            // Address of the type of the Value
                    lpbData,            // Address of the data of the Value
                    &cbData             // Address of size of data of the Value
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintToDebugger(SENS_ERR, ("[SENS] RegQueryValueEx(SENS_DEBUG_LEVEL) failed with 0x%x\n", RegStatus));
        gdwDebugOutputLevel = 0x0;
        goto Cleanup;
        }

    SensPrintToDebugger(SENS_INFO, ("[SENS] Debug Output is turned %s. The level is 0x%x.\n",
                        gdwDebugOutputLevel ? "ON" : "OFF", gdwDebugOutputLevel));

Cleanup:
    //
    // Cleanup
    //
    if (hKeySens)
        {
        RegCloseKey(hKeySens);
        }

    return;
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\sensapi\sensapi.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensapi.cxx

Abstract:

    Implementation of the SENS Connectivity APIs. These are just stubs
    which call into SENS to do the actual work.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/4/1997         Start.

--*/



#include <common.hxx>
#include <windows.h>
#include <api.h>
#include <sensapi.h>
#include <sensapi.hxx>
#include <cache.hxx>


//
// Globals
//

RPC_BINDING_HANDLE  ghSens;
CRITICAL_SECTION    gSensapiLock;
DWORD               gdwCacheLastUpdatedTime;
DWORD               gdwCacheFirstReadTime;
HANDLE              ghSensFileMap;
PSENS_CACHE         gpSensCache;


BOOL
IsNetworkAlive(
    OUT LPDWORD lpdwFlags
    )
/*++

Routine Description:

    We try to find out if this machine has any network connectivity.

Arguments:

    lpdwFlags - Receives information regarding the nature of the machine's
        network connectivity. It can be on of the following:
        o NETWORK_ALIVE_WAN
        o NETWORK_ALIVE_LAN

Notes:

    a. This is available only for TCP/IP
    b. This API does not generate any Network traffic.

Return Value:

    TRUE, if there is network connectivity

    FALSE, otherwise. Use GetLastError() to retrieve more error information.

--*/
{
    BOOL bNetState;
    RPC_STATUS RpcStatus;
    DWORD fNetNature;
    DWORD dwLastError;

    // Basic parameter checks
    if (lpdwFlags == NULL)
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    // OUT parameter intialization.
    *lpdwFlags = 0x0;
    fNetNature = 0x0;
    dwLastError = ERROR_SUCCESS;
    bNetState = FALSE;

    if (TRUE == ReadConnectivityCache(lpdwFlags))
        {
        return TRUE;
        }

    //
    // Need to contact SENS for information.
    //
    RpcStatus = DoRpcSetup();

    //
    // Try to get the state information.
    //
    if (RPC_S_OK == RpcStatus)
        {
        RpcStatus = RPC_IsNetworkAlive(
                        ghSens,
                        &fNetNature,
                        &bNetState,
                        &dwLastError
                        );
        }

    if (   (RPC_S_OK != RpcStatus)
        || (RPC_S_SERVER_UNAVAILABLE == dwLastError))
        {
        //
        // An RPC failure occurred. We treat this as a success and
        // set to return values to default values.
        //
        bNetState = TRUE;
        fNetNature = NETWORK_ALIVE_LAN;

        if (RPC_S_OK != RpcStatus)
            {
            dwLastError = RpcStatus;
            }
        }

    ASSERT((bNetState == TRUE) || (bNetState == FALSE));
    ASSERT(fNetNature <= (NETWORK_ALIVE_LAN | NETWORK_ALIVE_WAN | NETWORK_ALIVE_AOL));

    *lpdwFlags = fNetNature;
    SetLastError(dwLastError);

    // Since we retrieved information from SENS directly, reset the flag that
    // that indicates that we read from the cache.
    gdwCacheFirstReadTime = 0x0;

    return (bNetState);
}



#if !defined(SENS_CHICAGO)


BOOL
IsDestinationReachableA(
    LPCSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    )
/*++

Routine Description:

    Given the name of a destination (IP Address, UNC, URL etc), we try to
    see if it is reachable.

Arguments:

    lpszDestination - The destination (an ANSI string) whose rechability
        is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

Notes:

    a. This is available only for TCP/IP

Return Value:

    TRUE, if the destination is reachable.

    FALSE, otherwise. Use GetLastError() to retrieve more error information.

--*/
{
    BOOL bReachable;
    NTSTATUS NtStatus;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    size_t uiLength;

    // Basic parameter checks
    if (   (lpszDestination == NULL)
        || ((uiLength = strlen(lpszDestination)) > MAX_DESTINATION_LENGTH)
        || (uiLength == 0))
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    // OUT parameter intialization.
    bReachable = FALSE;

    RtlInitAnsiString(&AnsiString, (PSZ)lpszDestination);

    NtStatus = RtlAnsiStringToUnicodeString(
                   &UnicodeString,
                   &AnsiString,
                   TRUE
                   );
    if (!NT_SUCCESS(NtStatus))
        {
        SetLastError(ERROR_OUTOFMEMORY);  // Only possible error.
        return bReachable;
        }

    // Call the Unicode version.
    bReachable = IsDestinationReachableW(
                     UnicodeString.Buffer,
                     lpQOCInfo
                     );

    ASSERT((bReachable == TRUE) || (bReachable == FALSE));

    RtlFreeUnicodeString(&UnicodeString);

    return (bReachable);
}




BOOL
IsDestinationReachableW(
    LPCWSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    )
/*++

Routine Description:

    Given the name of a destination (IP Address, UNC, URL etc), we try to
    see if it is reachable.

Arguments:

    lpszDestination - The destination (a UNICODE string) whose rechability
        is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

Notes:

    a. This is available only for TCP/IP

Return Value:

    TRUE, if the destination is reachable.

    FALSE, otherwise. Use GetLastError() to retrieve more error information.

--*/
{
    BOOL bReachable;
    RPC_STATUS RpcStatus;
    DWORD dwLastError;
    DWORD dwCallerQOCInfoSize;
    size_t uiLength;

    // Basic parameter checks
    if (   (lpszDestination == NULL)
        || ((uiLength = wcslen(lpszDestination)) > MAX_DESTINATION_LENGTH)
        || (uiLength == 0))
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    // OUT parameter intialization.
    dwLastError = ERROR_SUCCESS;
    bReachable = FALSE;
    if (lpQOCInfo != NULL)
        {
        dwCallerQOCInfoSize = lpQOCInfo->dwSize;
        memset(lpQOCInfo, 0, lpQOCInfo->dwSize);
        lpQOCInfo->dwSize = dwCallerQOCInfoSize;
        }

    RpcStatus = DoRpcSetup();

    //
    // Try to get the state information.
    //
    if (RPC_S_OK == RpcStatus)
        {
        RpcStatus = RPC_IsDestinationReachableW(
                        ghSens,
                        (PSENS_CHAR) lpszDestination,
                        lpQOCInfo,
                        &bReachable,
                        &dwLastError
                        );
        }

    if (   (RPC_S_OK != RpcStatus)
        || (RPC_S_SERVER_UNAVAILABLE == dwLastError))
        {
        //
        // An RPC failure occurred. We treat this as a success and
        // set to return values to default values.
        //
        if (lpQOCInfo != NULL)
            {
            lpQOCInfo->dwFlags  = NETWORK_ALIVE_LAN;
            lpQOCInfo->dwInSpeed  = DEFAULT_LAN_BANDWIDTH;
            lpQOCInfo->dwOutSpeed = DEFAULT_LAN_BANDWIDTH;
            }
        bReachable = TRUE;

        if (RPC_S_OK != RpcStatus)
            {
            dwLastError = RpcStatus;
            }
        }

    ASSERT((bReachable == TRUE) || (bReachable == FALSE));

    SetLastError(dwLastError);

    return (bReachable);
}


#else // SENS_CHICAGO




BOOL
IsDestinationReachableA(
    LPCSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    )
/*++

Routine Description:

    Given the name of a destination (IP Address, UNC, URL etc), we try to
    see if it is reachable.

Arguments:

    lpszDestination - The destination (a UNICODE string) whose rechability
        is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

Notes:

    a. This is available only for TCP/IP

Return Value:

    TRUE, if the destination is reachable.

    FALSE, otherwise. Use GetLastError() to retrieve more error information.

--*/
{
    BOOL bReachable;
    RPC_STATUS RpcStatus;
    DWORD dwLastError;
    DWORD dwCallerQOCInfoSize;
    size_t uiLength;

    // Basic parameter checks
    if (   (lpszDestination == NULL)
        || ((uiLength = strlen(lpszDestination)) > MAX_DESTINATION_LENGTH)
        || (uiLength == 0))
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    // OUT parameter intialization.
    dwLastError = ERROR_SUCCESS;
    bReachable = FALSE;
    if (lpQOCInfo != NULL)
        {
        dwCallerQOCInfoSize = lpQOCInfo->dwSize;
        memset(lpQOCInfo, 0, lpQOCInfo->dwSize);
        lpQOCInfo->dwSize = dwCallerQOCInfoSize;
        }

    RpcStatus = DoRpcSetup();

    //
    // Try to get the state information.
    //
    if (RPC_S_OK == RpcStatus)
        {
        RpcStatus = RPC_IsDestinationReachableA(
                        ghSens,
                        (LPSTR) lpszDestination,
                        lpQOCInfo,
                        &bReachable,
                        &dwLastError
                        );
        }

    if (   (RPC_S_OK != RpcStatus)
        || (RPC_S_SERVER_UNAVAILABLE == dwLastError))
        {
        //
        // An RPC failure occurred. We treat this as a success and
        // set to return values to default values.
        //
        if (lpQOCInfo != NULL)
            {
            lpQOCInfo->dwFlags  = NETWORK_ALIVE_LAN;
            lpQOCInfo->dwInSpeed  = DEFAULT_LAN_BANDWIDTH;
            lpQOCInfo->dwOutSpeed = DEFAULT_LAN_BANDWIDTH;
            }
        bReachable = TRUE;

        if (RPC_S_OK != RpcStatus)
            {
            dwLastError = RpcStatus;
            }
        }

    ASSERT((bReachable == TRUE) || (bReachable == FALSE));

    SetLastError(dwLastError);

    return (bReachable);
}




BOOL
IsDestinationReachableW(
    LPCWSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    )
/*++

Routine Description:

    This is just a stub on Win9x platforms. It returns FALSE always. This
    is provided for consistency between NT and Win9x platforms.

Arguments:

    lpszDestination - The destination (a UNICODE string) whose rechability
        is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

Return Value:

    FALSE, always. Use GetLastError() to retrieve more error information.

--*/
{
    SetLastError(ERROR_NOT_SUPPORTED);

    return FALSE;
}

#endif // SENS_CHICAGO




inline RPC_STATUS
DoRpcSetup(
    void
    )
/*++

Routine Description:

    Do the miscellaneous work to talk to SENS via RPC.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS status;
    SENS_CHAR * BindingString;
    RPC_BINDING_HANDLE hServer = NULL;

    status = RPC_S_OK;
    BindingString = NULL;

    if (ghSens != NULL)
        {
        return (status);
        }

    RequestLock();

    if (ghSens != NULL)
        {
        ReleaseLock();
        return (status);
        }

    status = RpcStringBindingCompose(
                 NULL,               // NULL ObjUuid
                 SENS_PROTSEQ,
                 NULL,               // Local machine
                 SENS_ENDPOINT,
                 NULL,               // No Options
                 &BindingString
                 );

    if (BindingString)
        {
        status = RpcBindingFromStringBinding(BindingString, &hServer);
        }

    if (status == RPC_S_OK)
        {
        RPC_SECURITY_QOS RpcSecQos;

        RpcSecQos.Version= RPC_C_SECURITY_QOS_VERSION_1;
        RpcSecQos.ImpersonationType= RPC_C_IMP_LEVEL_IMPERSONATE;
        RpcSecQos.IdentityTracking= RPC_C_QOS_IDENTITY_DYNAMIC;
        RpcSecQos.Capabilities= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;

        status= RpcBindingSetAuthInfoEx(hServer,
                                        L"NT Authority\\System",
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                        RPC_C_AUTHN_WINNT,
                                        NULL,
                                        RPC_C_AUTHZ_NONE,
                                        (RPC_SECURITY_QOS *)&RpcSecQos);

        if (RPC_S_OK != status)
            {
            RpcBindingFree(&hServer);
            hServer = NULL;
            }
        }

    ghSens = hServer;
    ReleaseLock();

    if (BindingString != NULL)
        {
        RpcStringFree(&BindingString);
        }

    return (status);
}


BOOL
MapSensCacheView(
    void
    )
/*++

Routine Description:

    Prepare to read SENS information cache.

Arguments:

    None.

Notes:

    Should call it under a lock.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    //
    // First, open the SENS cache file mapping object
    //
    ghSensFileMap = OpenFileMapping(
                        FILE_MAP_READ,      // Protection for mapping object
                        FALSE,              // Inherit flag
                        SENS_CACHE_NAME     // Name of the file mapping object
                        );
    if (NULL == ghSensFileMap)
        {
        goto Cleanup;
        }
    //
    // Map a view of SENS cache into the address space
    //
    gpSensCache = (PSENS_CACHE) MapViewOfFile(
                      ghSensFileMap,    // Map file object
                      FILE_MAP_READ,    // Access mode
                      0,                // High-order 32 bits of file offset
                      0,                // Low-order 32 bits of file offset
                      0                 // Number of bytes to map
                      );
    if (NULL == gpSensCache)
        {
        goto Cleanup;
        }

    ASSERT(gpSensCache->dwCacheVer  >= SENS_CACHE_VERSION);
    ASSERT(gpSensCache->dwCacheSize >= sizeof(SENS_CACHE));

    return TRUE;

Cleanup:
    //
    // Cleanup
    //
    if (ghSensFileMap != NULL)
        {
        CloseHandle(ghSensFileMap);
        }
    if (gpSensCache != NULL)
        {
        UnmapViewOfFile(gpSensCache);
        }

    ghSensFileMap = NULL;
    gpSensCache = NULL;

    return FALSE;
}



void
UnmapSensCacheView(
    void
    )
/*++

Routine Description:

    Cleanup resources related to SENS information cache.

Arguments:

    None.

Notes:

    None.

Return Value:

    None.

--*/
{
    BOOL bStatus;

    //
    // Unmap the view of SENS cache from the address space
    //
    if (gpSensCache != NULL)
        {
        bStatus = UnmapViewOfFile(gpSensCache);
        ASSERT(bStatus);
        }

    //
    // Close File Mapping object
    //
    if (ghSensFileMap != NULL)
        {
        bStatus = CloseHandle(ghSensFileMap);
        ASSERT(bStatus);
        }
}




BOOL
ReadConnectivityCache(
    OUT LPDWORD lpdwFlags
    )
/*++

Routine Description:

    Try to read SENS connectivity cache. Talk to SENS iff one of the following
    conditions is TRUE:

        o Failed to read the connectivity cache.
        o Read the cache but connectivity state is FALSE.
        o Read the cache and connectivity state is TRUE but stale.
        o Read the cache and there is updated information available.

Arguments:

    lpdwFlags - OUT parameter that contains the connectivity state.

Return Value:

    TRUE, successfully got cached information.

    FALSE, SENS needs to be contacted.

--*/
{
    DWORD dwNow;

    dwNow = GetTickCount();

    RequestLock();

    // Failed to initialize/read Sens Cache
    if (   (NULL == gpSensCache)
        && (FALSE == MapSensCacheView()))
        {
        goto Cleanup;
        }

    // Cache has been updated since we last read. Note that dwLastUpdateTime
    // can wrap around.
    if (gpSensCache->dwLastUpdateTime != gdwCacheLastUpdatedTime)
        {
        gdwCacheLastUpdatedTime = gpSensCache->dwLastUpdateTime;
        goto Cleanup;
        }

    // It's been a while.
    if (   (gdwCacheFirstReadTime != 0x0)
        && (dwNow - gdwCacheFirstReadTime) > CACHE_VALID_INTERVAL)
        {
        goto Cleanup;
        }

    // Cached state is FALSE
    if (0x0 == gpSensCache->dwLastUpdateState)
        {
        goto Cleanup;
        }

    *lpdwFlags = gpSensCache->dwLastUpdateState;
    if (0 == gdwCacheFirstReadTime)
        {
        gdwCacheFirstReadTime = dwNow;
        }
    ASSERT(gdwCacheLastUpdatedTime == gpSensCache->dwLastUpdateTime);

    ReleaseLock();

    SetLastError(ERROR_SUCCESS);

    return TRUE;

Cleanup:
    //
    // Cleanup
    //
    ReleaseLock();

    // Don't need to SetLastError() as we will go to SENS to retrieve it.

    return FALSE;
}



extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpvReserved
    )
/*++

Routine Description:

    This routine will get called either when a process attaches to this dll
    or when a process detaches from this dll.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    BOOL bSuccess;
    RPC_STATUS RpcStatus;

    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
            // Disable Thread attach/detach calls
            bSuccess = DisableThreadLibraryCalls(hInstance);
            ASSERT(bSuccess == TRUE);

            // Initialize the lock
            InitializeCriticalSection(&gSensapiLock);
            break;

        case DLL_PROCESS_DETACH:
            // Clean the lock
            DeleteCriticalSection(&gSensapiLock);

            // Cleanup cache related resources
            UnmapSensCacheView();

            // Cleanup RPC Binding handle
            if (ghSens != NULL)
                {
                RpcStatus = RpcBindingFree(&ghSens);
                ASSERT(RPC_S_OK == RpcStatus);
                }
            break;

        }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\sensapi\sensutil.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensutil.cxx

Abstract:

    Utility routines for SENS Connectivity API implementation.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/4/1997         Start.

--*/


#include "memfunc.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\sensapi\stub_api_c.c ===
#include <api_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\sensapip\stub_notify_c.c ===
#include <notify_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senslogn\ntfysens.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ntfysens.cxx

Abstract:

    File to include portions of sensapip.cxx which are relevant to
    notify SENS of Winlogon events. 

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/15/1999         Start.

--*/

//
// If SENSNOTIFY_WINLOGON_EVENT is defined, then Winlogon parts of the
// sensapip.cxx file are included.
//

#define SENSNOTIFY_WINLOGON_EVENT

#include <..\sensapip\sensapip.cxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\sensapip\sensapip.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensapip.cxx

Abstract:

    Code for SensNotify* APIs which are called by external components
    to notify SENS of external events.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/4/1997         Start.

--*/



#include <common.hxx>
#include <rpc.h>
#include <notify.h>
#include <windows.h>


//
// Constants
//
#define FREE_NETCON_PROPERTIES  "NcFreeNetconProperties"
#define NETSHELL_DLL            SENS_STRING("netshell.dll")

//
// Define these constants to include respective portions of this
// file.
//
// #define SENSNOTIFY_OTHER_EVENT
// #define SENSNOTIFY_WINLOGON_EVENT
//

//
// Typedefs
//
typedef  void (STDAPICALLTYPE *PFN_FREE_NETCON_PROPERTIES) (NETCON_PROPERTIES* pProps);

//
// Globals
//

RPC_BINDING_HANDLE ghSensNotify = NULL;




inline RPC_STATUS
DoRpcSetup(
    void
    )
/*++

Routine Description:

    Do the miscellaneous work to talk to SENS via RPC.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS status = RPC_S_OK;
    SENS_CHAR * BindingString = NULL;

    //
    // NOTE: This is called very early in the system startup and so, it is
    // guaranteed to be serialized. So, a lock is not necessary.
    //

    if (ghSensNotify != NULL)
        {
        return (status);
        }

    status = RpcStringBindingCompose(
                 NULL,               // NULL ObjUuid
                 SENS_PROTSEQ,
                 NULL,               // Local machine
                 SENS_ENDPOINT,
                 NULL,               // No Options
                 &BindingString
                 );

    if (BindingString != NULL)
        {
        RPC_BINDING_HANDLE hServer = NULL;

        status = RpcBindingFromStringBinding(BindingString, &hServer);

        RpcStringFree(&BindingString);

        if (status == RPC_S_OK)
            {
            RPC_SECURITY_QOS RpcSecQos;

            RpcSecQos.Version= RPC_C_SECURITY_QOS_VERSION_1;
            RpcSecQos.ImpersonationType= RPC_C_IMP_LEVEL_IMPERSONATE;
            RpcSecQos.IdentityTracking= RPC_C_QOS_IDENTITY_DYNAMIC;
            RpcSecQos.Capabilities= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;

            status= RpcBindingSetAuthInfoEx(hServer,
                                            L"NT Authority\\System",
                                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                            RPC_C_AUTHN_WINNT,
                                            NULL,
                                            RPC_C_AUTHZ_NONE,
                                            (RPC_SECURITY_QOS *)&RpcSecQos);

            if (status != RPC_S_OK)
                {
                RpcBindingFree(&hServer);
                }
            else
                {
                ghSensNotify = hServer;
                }
            }
        }

    return (status);
}



#if defined(SENSNOTIFY_WINLOGON_EVENT)


DWORD
SensNotifyWinlogonEvent(
    PSENS_NOTIFY_WINLOGON pEvent
    )
/*++

Routine Description:



Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = DoRpcSetup();
    if (RPC_S_OK != RpcStatus)
        {
        return RpcStatus;
        }

    RpcStatus = SensApip_RPC_SensNotifyWinlogonEvent(
                    ghSensNotify,
                    pEvent
                    );
    if (RpcStatus)
        {
        return RpcStatus;
        }

    return (ERROR_SUCCESS);
}


#endif // SENSNOTIFY_WINLOGON_EVENT

#if defined(SENSNOTIFY_OTHER_EVENT)


DWORD
SensNotifyRasEvent(
    PSENS_NOTIFY_RAS pEvent
    )
/*++

Routine Description:

    Entry point for RAS to notify SENS of various RAS Events.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = DoRpcSetup();
    if (RPC_S_OK != RpcStatus)
        {
        return RpcStatus;
        }

    RpcStatus = SensApip_RPC_SensNotifyRasEvent(
                    ghSensNotify,
                    pEvent
                    );
    if (RpcStatus)
        {
        return RpcStatus;
        }

    return (ERROR_SUCCESS);
}





DWORD
SensNotifyNetconEvent(
    PSENS_NOTIFY_NETCON pEvent
    )
/*++

Routine Description:

    Entry point for Network UI to notify SENS of LAN Connect/Disconnect events.

Arguments:

    pEvent - Pointer to Netcon event notification data.

Return Value:

    S_OK, if successful.

    Failed hr, otherwise

--*/
{
    HRESULT hr;
    RPC_STATUS RpcStatus;
    SENS_NOTIFY_NETCON_P Data;
    NETCON_PROPERTIES *pNetconProperties;

    hr = S_OK;
    pNetconProperties = NULL;

    //
    // Fill-in the data.
    //

    ASSERT(pEvent && pEvent->pINetConnection);
    ASSERT(   (pEvent->eType == SENS_NOTIFY_LAN_CONNECT)
           || (pEvent->eType == SENS_NOTIFY_LAN_DISCONNECT));

    hr = pEvent->pINetConnection->GetProperties(&pNetconProperties);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    if (   (NULL == pNetconProperties)
        || (pNetconProperties->MediaType != NCM_LAN)
        || (   (pNetconProperties->Status != NCS_CONNECTED)
            && (pNetconProperties->Status != NCS_DISCONNECTED)))
        {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Cleanup;
        }

    Data.eType = pEvent->eType;
    Data.Status = pNetconProperties->Status;
    Data.Type = pNetconProperties->MediaType;
    Data.Name = pNetconProperties->pszwName;


    //
    // Send the data across.
    //

    RpcStatus = DoRpcSetup();
    if (RPC_S_OK != RpcStatus)
        {
        hr = HRESULT_FROM_WIN32(RpcStatus);
        goto Cleanup;
        }

    RpcStatus = SensApip_RPC_SensNotifyNetconEvent(
                    ghSensNotify,
                    &Data
                    );
    if (RpcStatus)
        {
        hr = HRESULT_FROM_WIN32(RpcStatus);
        goto Cleanup;
        }

Cleanup:
    //
    // Cleanup
    //

    // Free NetconProperties, if necessary.
    if (pNetconProperties)
        {
        HMODULE hDll;
        PFN_FREE_NETCON_PROPERTIES pfnFreeNetconProperties;

        hDll = LoadLibrary(NETSHELL_DLL);
        if (NULL == hDll)
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            return hr;
            }

        pfnFreeNetconProperties = (PFN_FREE_NETCON_PROPERTIES)
                                  GetProcAddress(
                                       hDll,
                                       FREE_NETCON_PROPERTIES
                                       );
        if (NULL == pfnFreeNetconProperties)
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            FreeLibrary(hDll);
            return hr;
            }

        (*pfnFreeNetconProperties)(pNetconProperties);

        FreeLibrary(hDll);
        }

    return (hr);
}




DWORD
SyncMgrExecCmd(
    DWORD nCmdID,
    DWORD nCmdExecOpt
    )
/*++

Routine Description:

    Private function for Syncmgr to execute work on it's behalf.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = DoRpcSetup();
    if (RPC_S_OK != RpcStatus)
        {
        return RpcStatus;
        }

    RpcStatus = SensApip_RPC_SyncMgrExecCmd(
                    ghSensNotify,
                    nCmdID,
                    nCmdExecOpt
                    );
    if (RpcStatus)
        {
        return RpcStatus;
        }

    return (ERROR_SUCCESS);
}


#endif // SENSNOTIFY_OTHER_EVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senscfg\guids.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       guids.c
//
//--------------------------------------------------------------------------

INTERFACENAME = { /* d5978621-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978621,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978622-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978622,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978623-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978623,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978624-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978624,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978625-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978625,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978626-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978626,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978627-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978627,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978628-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978628,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978629-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978629,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862a-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862a,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862b-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862b,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862c-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862c,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862d-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862d,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862e-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862e,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862f-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862f,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978630-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978630,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978631-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978631,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978632-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978632,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978633-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978633,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978634-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978634,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978635-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978635,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978636-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978636,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978637-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978637,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978638-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978638,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978639-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978639,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597863a-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597863a,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597863b-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597863b,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597863c-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597863c,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597863d-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597863d,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senscfg\senscfg.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senscfg.cxx

Abstract:

    Code to do the configuration (install/uninstall) for SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/11/1997         Start.

--*/


#define INITGUID


#include <common.hxx>
#include <objbase.h>
#include <coguid.h>
#include <eventsys.h>
#include <sensevts.h>
#include <sens.h>
#include <wininet.h>
#include <winineti.h>
#include "senscfg.hxx"
#include "sensinfo.hxx"
#include "memfunc.hxx"


#define MAJOR_VER           1
#define MINOR_VER           0
#define DEFAULT_LCID        0x0
#define MAX_QUERY_SIZE      512
#define SENS_SETUP          "SENSCFG: "
#define SENS_SERVICEA       "SENS"
#define SENS_SETUPW         SENS_BSTR("SENSCFG: ")
#define SENS_SERVICE        SENS_STRING("SENS")
#define SENS_DISPLAY_NAME   SENS_STRING("System Event Notification")
#define SENS_SERVICE_GROUP  SENS_STRING("Network")
#define EVENTSYSTEM_REMOVE  SENS_STRING("esserver /remove")
#define EVENTSYSTEM_INSTALL SENS_STRING("esserver /install")
#define SENS_WINLOGON_DLL   SENS_STRING("senslogn.dll")
#define GUID_STR_SIZE       sizeof("{12345678-1234-1234-1234-123456789012}")
#define EVENTSYSTEM_KEY     SENS_STRING("SOFTWARE\\Microsoft\\EventSystem")
#define WINLOGON_NOTIFY_KEY SENS_STRING("SOFTWARE\\Microsoft\\Windows NT\\")   \
                            SENS_STRING("CurrentVersion\\Winlogon\\Notify\\")  \
                            SENS_STRING("senslogn")
#define WININET_SENS_EVENTS INETEVT_RAS_CONNECT     |   \
                            INETEVT_RAS_DISCONNECT  |   \
                            INETEVT_LOGON           |   \
                            INETEVT_LOGOFF


//
// DLL vs EXE dependent constants
//
#if defined(SENS_NT4)
#define SENS_TLBA           "SENS.EXE"
#define SENS_BINARYA        "SENS.EXE"
#define SENS_TLB            SENS_STRING("SENS.EXE")
#define SENS_BINARY         SENS_STRING("SENS.EXE")
#else  // SENS_NT4
#define SENS_TLBA           "SENS.DLL"
#define SENS_BINARYA        "SENS.DLL"
#define SENS_TLB            SENS_STRING("SENS.DLL")
#define SENS_BINARY         SENS_STRING("SENS.DLL")
#endif // SENS_NT4


//
// Misc debugging constants
//
#ifdef STRICT_HRESULT_CHECKS

#ifdef SUCCEEDED
#undef SUCCEEDED
#define SUCCEEDED(_HR_) (_HR_ == S_OK)
#endif // SUCCEEDED

#ifdef FAILED
#undef FAILED
#define FAILED(_HR_)    (_HR_ != S_OK)
#endif // FAILED

#endif // STRICT_HRESULT_CHECKS



//
// Globals
//

IEventSystem    *gpIEventSystem;
ITypeLib        *gpITypeLib;

#ifdef DBG
DWORD           gdwDebugOutputLevel;
#endif // DBG



HRESULT APIENTRY
SensRegister(
    void
    )
/*++

Routine Description:

    Register SENS.

Arguments:

    None.

Return Value:

    HRESULT returned from SensConfigurationHelper()

--*/
{
    return (SensConfigurationHelper(FALSE));
}




HRESULT APIENTRY
SensUnregister(
    void
    )
/*++

Routine Description:

    Unregister SENS.

Arguments:

    None.

Return Value:

    HRESULT returned from SensConfigurationHelper()

--*/
{
    return (SensConfigurationHelper(TRUE));
}




HRESULT
SensConfigurationHelper(
    BOOL bUnregister
    )
/*++

Routine Description:

    Main entry into the SENS configuration utility.

Arguments:

    bUnregister - If TRUE, then unregister SENS as a publisher.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;

    hr = S_OK;
    gpIEventSystem = NULL;
    gpITypeLib = NULL;

#ifdef DBG
    EnableDebugOutputIfNecessary();
#endif // DBG


#if !defined(SENS_CHICAGO)

    //
    // Configure EventSystem first during an install and last during an uninstall.
    //
    if (FALSE == bUnregister)
        {
        hr = SensConfigureEventSystem(FALSE);
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "Failed to configure EventSystem, HRESULT=%x\n", hr));
            goto Cleanup;
            }
        SensPrintA(SENS_INFO, (SENS_SETUP "Successfully configured EventSystem\n"));
        }

#endif // SENS_CHICAGO

    //
    // Instantiate the Event System
    //
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &gpIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to create CEventSystem, HRESULT=%x\n", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "Successfully created CEventSystem\n"));

    //
    // Register Event Classes (and hence, indirectly events) published by SENS.
    //
    hr = RegisterSensEventClasses(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS Events"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "%segistered SENS Publisher Events.\n",
               bUnregister ? "Unr" : "R", hr));

    //
    // Register the subscriptions of SENS.
    //
    hr = RegisterSensSubscriptions(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS Subscriptions"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_ERR, (SENS_SETUP "%segistered SENS Subscriptions.\n",
               bUnregister ? "Unr" : "R", hr));

    //
    // Register the SENS TypeLibs.
    //
    hr = RegisterSensTypeLibraries(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS Type Libraries"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        // Abort only during the Install phase...
        if (bUnregister == FALSE)
            {
            goto Cleanup;
            }
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "%segistered SENS Type Libraries.\n",
               bUnregister ? "Unr" : "R", hr));


#if !defined(SENS_CHICAGO)

#if defined(SENS_NT4)
    //
    // Register SENS as a service with SCM.
    //
    hr = RegisterSensAsService(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS as a Service"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "%segistered SENS as a Service.\n",
               bUnregister ? "Unr" : "R", hr));
#endif // SENS_NT4

    //
    // Configure EventSystem first during an install and last during an uninstall.
    //
    if (TRUE == bUnregister)
        {
        hr = SensConfigureEventSystem(TRUE);
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "Failed to configure EventSystem, HRESULT=%x\n", hr));
            goto Cleanup;
            }
        SensPrintA(SENS_INFO, (SENS_SETUP "Successfully configured EventSystem\n"));
        }

#endif // SENS_CHICAGO

    //
    // Register SENS CLSID in the registry.
    //
    hr = RegisterSensCLSID(
             SENSGUID_SUBSCRIBER_LCE,
             SENS_SUBSCRIBER_NAME_EVENTOBJECTCHANGE,
             bUnregister
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS CLSID"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "%segistered SENS CLSID.\n",
               bUnregister ? "Unr" : "R", hr));

    //
    // Update Configured value
    //
    hr = SensUpdateVersion(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to update SENS version"
                   " - hr = <%x>\n", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "Updated SENS version.\n"));


Cleanup:
    //
    // Cleanup
    //
    if (gpIEventSystem)
        {
        gpIEventSystem->Release();
        }

    if (gpITypeLib)
        {
        gpITypeLib->Release();
        }

    SensPrintA(SENS_ERR, ("\n" SENS_SETUP "SENS Configuration %s.\n",
               SUCCEEDED(hr) ? "successful" : "failed"));

    return (hr);
}




HRESULT
RegisterSensEventClasses(
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister all the Events published by SENS.

Arguments:

    bUnregister - If TRUE, then unregister all SENS Events.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    int             i;
    int             errorIndex;
    HRESULT         hr;
    LPOLESTR        strGuid;
    LPOLESTR        strEventClassID;
    WCHAR           szQuery[MAX_QUERY_SIZE];
    BSTR            bstrEventClassID;
    BSTR            bstrEventClassName;
    BSTR            bstrFiringInterface;
    IEventClass     *pIEventClass;

    hr = S_OK;
    strGuid = NULL;
    errorIndex = 0;
    strEventClassID = NULL;
    bstrEventClassID = NULL;
    bstrEventClassName = NULL;
    bstrFiringInterface = NULL;
    pIEventClass = NULL;

    for (i = 0; i < SENS_PUBLISHER_EVENTCLASS_COUNT; i++)
        {
        // Get a new IEventClass.
        hr = CoCreateInstance(
                 CLSID_CEventClass,
                 NULL,
                 CLSCTX_SERVER,
                 IID_IEventClass,
                 (LPVOID *) &pIEventClass
                 );
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensEventClasses() failed to create "
                       "IEventClass - hr = <%x>\n", hr));
            goto Cleanup;
            }

        if (bUnregister)
            {
            // Form the query
            wcscpy(szQuery,  SENS_BSTR("EventClassID"));
            wcscat(szQuery,  SENS_BSTR("="));
            AllocateStrFromGuid(strEventClassID, *(gSensEventClasses[i].pEventClassID));
            wcscat(szQuery,  strEventClassID);
            wcscat(szQuery,  SENS_BSTR(""));

            hr = gpIEventSystem->Remove(
                                     PROGID_EventClass,
                                     szQuery,
                                     &errorIndex
                                     );
            FreeStr(strEventClassID);
            if (FAILED(hr))
                {
                SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensEventClasses(%d) failed to Store"
                           " - hr = <%x>\n", i, hr));
                goto Cleanup;
                }

            pIEventClass->Release();
            pIEventClass = NULL;

            continue;
            }

        AllocateBstrFromGuid(bstrEventClassID, *(gSensEventClasses[i].pEventClassID));
        hr = pIEventClass->put_EventClassID(bstrEventClassID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrEventClassName, gSensEventClasses[i].strEventClassName);
        hr = pIEventClass->put_EventClassName(bstrEventClassName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrFiringInterface, *(gSensEventClasses[i].pFiringInterfaceGUID));
        hr = pIEventClass->put_FiringInterfaceID(bstrFiringInterface);
        ASSERT(SUCCEEDED(hr));

        FreeBstr(bstrEventClassID);
        FreeBstr(bstrEventClassName);
        FreeBstr(bstrFiringInterface);

        hr = gpIEventSystem->Store(PROGID_EventClass, pIEventClass);
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensEventClasses(%d) failed to Store"
                       " - hr = <%x>\n", i, hr));
            goto Cleanup;
            }

        pIEventClass->Release();

        pIEventClass = NULL;
        } // for loop

Cleanup:
    //
    // Cleanup
    //
    if (pIEventClass)
        {
        pIEventClass->Release();
        }

    FreeStr(strGuid);

    return (hr);
}




HRESULT
RegisterSensSubscriptions(
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister the Event subscriptions of SENS.

Arguments:

    bUnregister - If TRUE, then unregister all subscriptions of SENS.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    int                 i;
    int                 errorIndex;
    HRESULT             hr;
    LPOLESTR            strGuid;
    LPOLESTR            strSubscriptionID;
    LPOLESTR            strEventClassID;
    WCHAR               szQuery[MAX_QUERY_SIZE];
    BSTR                bstrEventClassID;
    BSTR                bstrInterfaceID;
    BSTR                bstrPublisherID;
    BSTR                bstrSubscriptionID;
    BSTR                bstrSubscriptionName;
    BSTR                bstrSubscriberCLSID;
    BSTR                bstrMethodName;
    BSTR                bstrPublisherPropertyName;
    BSTR                bstrPublisherPropertyValue;
    VARIANT             variantPublisherPropertyValue;
    BSTR                bstrPROGID_EventSubscription;
    IEventSubscription  *pIEventSubscription;

    hr = S_OK;
    strGuid = NULL;
    errorIndex = 0;
    strEventClassID = NULL;
    bstrEventClassID = NULL;
    bstrInterfaceID = NULL;
    bstrPublisherID = NULL;
    strSubscriptionID = NULL;
    bstrSubscriptionID = NULL;
    bstrSubscriberCLSID = NULL;
    bstrSubscriptionName = NULL;
    bstrMethodName = NULL;
    bstrPublisherPropertyName = NULL;
    bstrPublisherPropertyValue = NULL;
    bstrPROGID_EventSubscription = NULL;
    pIEventSubscription = NULL;

    AllocateBstrFromGuid(bstrPublisherID, SENSGUID_PUBLISHER);
    AllocateBstrFromGuid(bstrSubscriberCLSID, SENSGUID_SUBSCRIBER_LCE);
    AllocateBstrFromString(bstrPROGID_EventSubscription, PROGID_EventSubscription);

    for (i = 0; i < SENS_SUBSCRIPTIONS_COUNT; i++)
        {
        if (bUnregister)
            {
            // Form the query
            wcscpy(szQuery,  SENS_BSTR("SubscriptionID"));
            wcscat(szQuery,  SENS_BSTR("="));
            AllocateStrFromGuid(strSubscriptionID, *(gSensSubscriptions[i].pSubscriptionID));
            wcscat(szQuery,  strSubscriptionID);

            hr = gpIEventSystem->Remove(
                                     PROGID_EventSubscription,
                                     szQuery,
                                     &errorIndex
                                     );
            FreeStr(strSubscriptionID);

            if (FAILED(hr))
                {
                SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensSubscriptionis(%d) failed to Remove"
                           " - hr = <%x>\n", i, hr));
                goto Cleanup;
                }

            continue;
            }

        // Get a new IEventSubscription object to play with.
        hr = CoCreateInstance(
                 CLSID_CEventSubscription,
                 NULL,
                 CLSCTX_SERVER,
                 IID_IEventSubscription,
                 (LPVOID *) &pIEventSubscription
                 );
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensSubscriptions(%d) failed to create "
                       "IEventSubscriptions - hr = <%x>\n", i, hr));
            goto Cleanup;
            }

        AllocateBstrFromGuid(bstrSubscriptionID, *(gSensSubscriptions[i].pSubscriptionID));
        hr = pIEventSubscription->put_SubscriptionID(bstrSubscriptionID);
        ASSERT(SUCCEEDED(hr));

        hr = pIEventSubscription->put_PublisherID(bstrPublisherID);
        ASSERT(SUCCEEDED(hr));

        hr = pIEventSubscription->put_SubscriberCLSID(bstrSubscriberCLSID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrSubscriptionName, gSensSubscriptions[i].strSubscriptionName);
        hr = pIEventSubscription->put_SubscriptionName(bstrSubscriptionName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrMethodName, gSensSubscriptions[i].strMethodName);
        hr = pIEventSubscription->put_MethodName(bstrMethodName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrEventClassID, *(gSensSubscriptions[i].pEventClassID));
        hr = pIEventSubscription->put_EventClassID(bstrEventClassID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrInterfaceID, *(gSensSubscriptions[i].pInterfaceID));
        hr = pIEventSubscription->put_InterfaceID(bstrInterfaceID);
        ASSERT(SUCCEEDED(hr));

        if (gSensSubscriptions[i].bPublisherPropertyPresent == TRUE)
            {
            if (NULL != (gSensSubscriptions[i].pPropertyEventClassIDValue))
                {
                // Create the Query string.
                wcscpy(szQuery,  gSensSubscriptions[i].strPropertyEventClassID);
                wcscat(szQuery,  SENS_BSTR("="));
                AllocateStrFromGuid(strEventClassID, *(gSensSubscriptions[i].pPropertyEventClassIDValue));
                wcscat(szQuery,  strEventClassID);
                wcscat(szQuery,  SENS_BSTR(" AND "));
                wcscat(szQuery,  gSensSubscriptions[i].strPropertyMethodName);
                wcscat(szQuery,  SENS_BSTR("=\'"));
                wcscat(szQuery,  gSensSubscriptions[i].strPropertyMethodNameValue);
                wcscat(szQuery,  SENS_BSTR("\'"));

                AllocateBstrFromString(bstrPublisherPropertyName, SENS_BSTR("Criteria"));
                AllocateBstrFromString(bstrPublisherPropertyValue, szQuery);
                InitializeBstrVariant(&variantPublisherPropertyValue, bstrPublisherPropertyValue);
                hr = pIEventSubscription->PutPublisherProperty(
                                              bstrPublisherPropertyName,
                                              &variantPublisherPropertyValue
                                              );
                ASSERT(SUCCEEDED(hr));
                SensPrintA(SENS_INFO, (SENS_SETUP "PutPublisherProperty(Criteria) returned 0x%x\n", hr));

                FreeStr(strEventClassID);
                FreeBstr(bstrPublisherPropertyName);
                FreeBstr(bstrPublisherPropertyValue);
                }
            else
                {
                //
                // We are dealing with the "ANY" subscription of SENS.
                //

                // Create the Query string.
                wcscpy(szQuery,  gSensSubscriptions[i].strPropertyEventClassID);
                wcscat(szQuery,  SENS_BSTR("="));
                AllocateStrFromGuid(strEventClassID, SENSGUID_EVENTCLASS_NETWORK);
                wcscat(szQuery,  strEventClassID);
                wcscat(szQuery,  SENS_BSTR(" OR "));
                FreeStr(strEventClassID);

                wcscat(szQuery,  gSensSubscriptions[i].strPropertyEventClassID);
                wcscat(szQuery,  SENS_BSTR("="));
                AllocateStrFromGuid(strEventClassID, SENSGUID_EVENTCLASS_LOGON);
                wcscat(szQuery,  strEventClassID);
                wcscat(szQuery,  SENS_BSTR(" OR "));
                FreeStr(strEventClassID);

                wcscat(szQuery,  gSensSubscriptions[i].strPropertyEventClassID);
                wcscat(szQuery,  SENS_BSTR("="));
                AllocateStrFromGuid(strEventClassID, SENSGUID_EVENTCLASS_ONNOW);
                wcscat(szQuery,  strEventClassID);
                FreeStr(strEventClassID);


                AllocateBstrFromString(bstrPublisherPropertyName, SENS_BSTR("Criteria"));
                AllocateBstrFromString(bstrPublisherPropertyValue, szQuery);
                InitializeBstrVariant(&variantPublisherPropertyValue, bstrPublisherPropertyValue);
                hr = pIEventSubscription->PutPublisherProperty(
                                              bstrPublisherPropertyName,
                                              &variantPublisherPropertyValue
                                              );
                ASSERT(SUCCEEDED(hr));
                SensPrintA(SENS_INFO, (SENS_SETUP "PutPublisherProperty(Criteria) returned 0x%x\n", hr));

                FreeBstr(bstrPublisherPropertyName);
                FreeBstr(bstrPublisherPropertyValue);
                }
            }

        FreeBstr(bstrSubscriptionID);
        FreeBstr(bstrSubscriptionName);
        FreeBstr(bstrMethodName);
        FreeBstr(bstrEventClassID);
        FreeBstr(bstrInterfaceID);

        hr = gpIEventSystem->Store(bstrPROGID_EventSubscription, pIEventSubscription);
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensSubscriptions(%d) failed to Store"
                       " - hr = <%x>\n", i, hr));

            goto Cleanup;
            }

        pIEventSubscription->Release();

        pIEventSubscription = NULL;
        } // for loop

Cleanup:
    //
    // Cleanup
    //
    if (pIEventSubscription)
        {
        pIEventSubscription->Release();
        }

    FreeBstr(bstrPublisherID);
    FreeBstr(bstrSubscriberCLSID);
    FreeBstr(bstrPROGID_EventSubscription);
    FreeStr(strGuid);

    return (hr);
}




HRESULT
RegisterSensTypeLibraries(
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister the Type Libraries of SENS.

Arguments:

    bUnregister - If TRUE, then unregister all subscriptions of SENS.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    UINT uiLength;
    TCHAR buffer[MAX_PATH+1+sizeof(SENS_BINARYA)+1];    // +1 for '\'
    WCHAR *bufferW;

    hr = S_OK;
    uiLength = 0;
    bufferW = NULL;

    //
    // Get the Full path name to the SENS TLB (which is a resource in SENS.EXE)
    //
    uiLength = GetSystemDirectory(
                   buffer,
                   MAX_PATH
                   );
    if (uiLength == 0)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrintA(SENS_ERR, (SENS_SETUP "GetSystemDirectory(%s) failed - hr = <%x>\n",
                   SENS_TLBA, hr));
        goto Cleanup;
        }
    _tcscat(buffer, SENS_STRING("\\"));
    _tcscat(buffer, SENS_TLB);

    //
    // Convert the string to UNICODE, if necessary
    //
#if !defined(SENS_CHICAGO)

    bufferW = buffer;

#else // SENS_CHICAGO

    bufferW = SensAnsiStringToUnicode(buffer);
    if (NULL == bufferW)
        {
        goto Cleanup;
        }

#endif // SENS_CHICAGO

    hr = LoadTypeLibEx(
             bufferW,
             REGKIND_NONE,
             &gpITypeLib
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "LoadTypeLib(%s) failed "
                   " - hr = <%x>\n", SENS_TLBA, hr));
        goto Cleanup;
        }

    //
    // Ensure that the TypeLib is (un)registered
    //
    if (bUnregister)
        {
        hr = UnRegisterTypeLib(
                 LIBID_SensEvents,
                 MAJOR_VER,
                 MINOR_VER,
                 DEFAULT_LCID,
                 SYS_WIN32
                 );
        }
    else
        {
        hr = RegisterTypeLib(
                 gpITypeLib,
                 bufferW,
                 NULL
                 );
        }

    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "%sRegisterTypeLib(%s) failed "
                   " - hr = <%x>\n", (bUnregister ? "Un" : ""), SENS_TLBA, hr));
        }

Cleanup:
    //
    // Cleanup
    //

#if defined(SENS_CHICAGO)

    if (bufferW != NULL)
        {
        delete bufferW;
        }

#endif // SENS_CHICAGO

    return (hr);
}




HRESULT
RegisterSensCLSID(
    REFIID clsid,
    TCHAR* strSubscriberName,
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister the CLSID of SENS.

Arguments:

    clsid - CLSID of the Subscriber for LCE events.

    strSubscriberName - Name of the Subscriber.

    bUnregister - If TRUE, then unregister the CLSID of SENS.

Notes:

    This function also registers SENS to receive IE5's WININET events.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    HMODULE hModule;
    HKEY appidKey;
    HKEY clsidKey;
    HKEY serverKey;
    WCHAR *szCLSID;
    WCHAR *szCLSID2;
    WCHAR *szLIBID;
    TCHAR *szCLSID_t;
    TCHAR *szCLSID2_t;
    TCHAR *szLIBID_t;
    TCHAR *szFriendlyName;
    TCHAR szPath[MAX_PATH+1+sizeof(SENS_BINARYA)+1];    // +1 for '\'
    UINT uiLength;
    DWORD dwDisposition;
    LONG lResult;

    hr = S_OK;
    appidKey = NULL;
    clsidKey = NULL;
    serverKey = NULL;
    szCLSID = NULL;
    szCLSID2 = NULL;
    szLIBID = NULL;
    szCLSID_t = NULL;
    szCLSID2_t = NULL;
    szLIBID_t = NULL;
    uiLength = 0;
    dwDisposition = 0x0;
    szFriendlyName = strSubscriberName;

    //
    // Get the Full path name to the SENS executable
    //
    uiLength = GetSystemDirectory(
                   szPath,
                   MAX_PATH
                   );
    if (uiLength == 0)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrintA(SENS_ERR, (SENS_SETUP "GetSystemDirectory(%s) failed - hr = <%x>\n",
                   SENS_BINARYA, hr));
        goto Cleanup;
        }
    _tcscat(szPath, SENS_STRING("\\"));
    _tcscat(szPath, SENS_BINARY);


    //
    // Convert the CLSID into a WCHAR.
    //

    hr = StringFromCLSID(clsid, &szCLSID);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    if (bUnregister == FALSE)
        {
        hr = StringFromCLSID(LIBID_SensEvents, &szLIBID);
        if (FAILED(hr))
            {
            goto Cleanup;
            }
        }

    //
    // Convert UNICODE strings into ANSI, if necessary
    //
#if !defined(SENS_CHICAGO)

    szCLSID_t  = szCLSID;
    szLIBID_t  = szLIBID;

#else // SENS_CHICAGO

    szCLSID_t  = SensUnicodeStringToAnsi(szCLSID);
    szLIBID_t  = SensUnicodeStringToAnsi(szLIBID);
    if (   (NULL == szCLSID_t)
        || (NULL == szLIBID_t))
        {
        goto Cleanup;
        }

#endif // SENS_CHICAGO


    // Build the key CLSID\\{clsid}
    TCHAR clsidKeyName[sizeof "CLSID\\{12345678-1234-1234-1234-123456789012}"];

    _tcscpy(clsidKeyName, SENS_STRING("CLSID\\"));
    _tcscat(clsidKeyName, szCLSID_t);

    // Build the key AppID\\{clsid}
    TCHAR appidKeyName[sizeof "AppID\\{12345678-1234-1234-1234-123456789012}"];
    _tcscpy(appidKeyName, SENS_STRING("AppID\\"));
    _tcscat(appidKeyName, szCLSID_t);

    if (bUnregister)
        {
        hr = RecursiveDeleteKey(HKEY_CLASSES_ROOT, clsidKeyName);
        if (FAILED(hr))
            {
            goto Cleanup;
            }

        hr = RecursiveDeleteKey(HKEY_CLASSES_ROOT, appidKeyName);

        goto Cleanup;
        }

    // Create the CLSID\\{clsid} key
    hr = CreateKey(
             HKEY_CLASSES_ROOT,
             clsidKeyName,
             szFriendlyName,
             &clsidKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Under the CLSID\\{clsid} key, create a named value
    //          AppID = {clsid}
    hr = CreateNamedValue(clsidKey, SENS_STRING("AppID"), szCLSID_t);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Create the appropriate server key beneath the clsid key.
    // For servers, this is CLSID\\{clsid}\\LocalServer32.
    // In both cases, the default value is the module path name.
    //
    hr = CreateKey(
             clsidKey,
             SENS_STRING("LocalServer32"),
             szPath,
             &serverKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }
    RegCloseKey(serverKey);

    //
    // Create CLSID\\{clsid}\\TypeLib subkey with a default value of
    // the LIBID of the TypeLib
    //
    hr = CreateKey(
             clsidKey,
             SENS_STRING("TypeLib"),
             szLIBID_t,
             &serverKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }
    RegCloseKey(serverKey);


    // Register APPID.
    hr = CreateKey(
             HKEY_CLASSES_ROOT,
             appidKeyName,
             szFriendlyName,
             &appidKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }

#if !defined(SENS_CHICAGO)

    // Under AppId\{clsid} key, create a named value [LocalService = "SENS"]
    hr = CreateNamedValue(appidKey, SENS_STRING("LocalService"), SENS_STRING("SENS"));
    if (FAILED(hr))
        {
        goto Cleanup;
        }

#else // SENS_CHICAGO

    // Under AppId\{clsid} key, create a named value [RunAs = "Interactive User"]
    hr = CreateNamedValue(appidKey, SENS_STRING("RunAs"), SENS_STRING("Interactive User"));
    if (FAILED(hr))
        {
        goto Cleanup;
        }

#endif // SENS_CHICAGO


Cleanup:
    //
    // Cleanup
    //
    CoTaskMemFree(szCLSID);
    CoTaskMemFree(szLIBID);

    if (clsidKey != NULL)
        {
        RegCloseKey(clsidKey);
        }
    if (appidKey != NULL)
        {
        RegCloseKey(appidKey);
        }

#if defined(SENS_CHICAGO)

    if (szCLSID_t != NULL)
        {
        delete szCLSID_t;
        }
    if (szLIBID_t != NULL)
        {
        delete szLIBID_t;
        }

#endif // SENS_CHICAGO

    return hr;
}



#if defined(SENS_NT4)


HRESULT
RegisterSensAsService(
    BOOL bUnregister
    )
/*++

Routine Description:

    Configure SENS as a Win32 System service.

Arguments:

    bUnregister - If TRUE, then unregister SENS as a service.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;

    hr = S_OK;

    if (bUnregister)
        {
        hr = RemoveService();
        }
    else
        {
        hr = InstallService();
        }

    return hr;
}




HRESULT
InstallService(
    void
    )
/*++

Routine Description:

    Install SENS as a service with the Service Control Manager.

Arguments:

    None.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH+1+sizeof(SENS_BINARYA)+1];    // +1 for '\'
    LPTSTR pFilePart;
    UINT uiLength;
    SC_HANDLE hSCM;
    SC_HANDLE hSens;

    hr = S_OK;
    pFilePart = NULL;
    uiLength = 0;
    hSCM = NULL;
    hSens = NULL;

    //
    // Get the Full path name to the SENS executable
    //
    uiLength = GetSystemDirectory(
                   szPath,
                   MAX_PATH
                   );
    if (uiLength == 0)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrintA(SENS_ERR, (SENS_SETUP "GetSystemDirectory(%s) failed - hr = <%x>\n",
                   SENS_BINARYA, hr));
        goto Cleanup;
        }
    _tcscat(szPath, SENS_STRING("\\"));
    _tcscat(szPath, SENS_BINARY);


    //
    // Register ourselves with the SCM
    //

    // Open the SCM for the local machine.
    hSCM = OpenSCManager(
               NULL,
               NULL,
               SC_MANAGER_ALL_ACCESS
               );
    if (NULL == hSCM)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrint(SENS_ERR, (SENS_SETUPW SENS_STRING("OpenSCManager(%s) failed - hr = <%x>\n"),
                  SENS_SERVICE, hr));
        goto Cleanup;
        }

    hSens = CreateService(
                hSCM,                       // Handle to SCM
                SENS_SERVICE,               // Name of the service executable
                SENS_DISPLAY_NAME,          // Service Display name
                SERVICE_ALL_ACCESS,         // Access to the service
                SERVICE_WIN32_OWN_PROCESS,  // Type of the service
                SERVICE_DEMAND_START,       // Start type of the service
                SERVICE_ERROR_NORMAL,       // Severity of the error during startup
                szPath,                     // Binary path name
                SENS_SERVICE_GROUP,         // Load ordering group
                NULL,                       // No tag identifier
                SENS_STRING("EventSystem\0"),   // Dependencies
                NULL,                       // LocalSystem account
                NULL                        // No password
                );
    if (NULL == hSens)
        {
        if (GetLastError() != ERROR_SERVICE_EXISTS)
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            SensPrint(SENS_ERR, (SENS_SETUPW SENS_STRING("CreateService(%s) failed - hr = <%x>\n"),
                      SENS_SERVICE, hr));
            }
        else
            {
            SensPrint(SENS_WARN, (SENS_SETUPW SENS_STRING("SENS service is already installed.\n")));

            BOOL bRetValue;

            //
            // Get a handle to SCM
            //
            hSens = OpenService(
                        hSCM,
                        SENS_SERVICE,
                        SERVICE_ALL_ACCESS
                        );
            if (NULL == hSens)
                {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
                }

            //
            // Mark the service to demand-start by default.
            // NULL parameter implies no change.
            //
            bRetValue = ChangeServiceConfig(
                            hSens,              // Handle to service
                            SERVICE_NO_CHANGE,  // Type of service
                            SERVICE_DEMAND_START, // When to start service
                            SERVICE_NO_CHANGE,  // Severity if service fails to start
                            NULL,               // Pointer to service binary file name
                            NULL,               // Pointer to load ordering group name
                            NULL,               // Pointer to variable to get tag identifier
                            NULL,               // Pointer to array of dependency names
                            NULL,               // Pointer to account name of service
                            NULL,               // Pointer to password for service account
                            NULL                // Pointer to display name
                            );
            if (FALSE == bRetValue)
                {
                hr = HRESULT_FROM_WIN32(GetLastError());
                }
            SensPrint(SENS_ERR, (SENS_SETUPW SENS_STRING("ChangeServiceConfig(%s)")
                      SENS_STRING(" returned hr - <%x>\n"), SENS_SERVICE, hr));
            }

        goto Cleanup;
        }

    SensPrint(SENS_INFO, (SENS_SETUPW SENS_STRING("SENS service successfully installed.\n")));

Cleanup:
    //
    // Cleanup
    //
    if (hSens != NULL)
        {
        //
        // Give everyone the ability to start the service.
        //
        hr = SetServiceWorldAccessMask(hSens, SERVICE_START);
        SensPrint(SENS_ERR, (SENS_SETUPW SENS_STRING("SerServiceWorldAccessMask(%s)")
                  SENS_STRING(" returned hr - <%x>\n"), SENS_SERVICE, hr));
        CloseServiceHandle(hSens);
        }
    if (hSCM != NULL)
        {
        CloseServiceHandle(hSCM);
        }

    return hr;
}





HRESULT
RemoveService(
    void
    )
/*++

Routine Description:

    Remove SENS as a service.

Arguments:

    None.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    SC_HANDLE hSCM;
    SC_HANDLE hSens;
    BOOL bSuccess;
    SERVICE_STATUS SvcStatus;

    hr = S_OK;
    hSCM = NULL;
    hSens = NULL;
    bSuccess = FALSE;

    //
    // Unregister ourselves from the SCM
    //

    // Open the SCM for the local machine.
    hSCM = OpenSCManager(
               NULL,
               NULL,
               SC_MANAGER_ALL_ACCESS
               );
    if (NULL == hSCM)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrint(SENS_ERR, (SENS_SETUPW SENS_STRING("OpenSCManager() failed - hr = <%x>\n"), hr));
        goto Cleanup;
        }

    hSens = OpenService(
                hSCM,
                SENS_SERVICE,
                SERVICE_ALL_ACCESS
                );
    if (NULL == hSens)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrint(SENS_ERR, (SENS_SETUPW SENS_STRING("OpenService(%s) failed - hr = <%x>\n"),
                  SENS_SERVICE, hr));
        goto Cleanup;
        }

    //
    // Try to stop the service
    //
    bSuccess = ControlService(
                   hSens,
                   SERVICE_CONTROL_STOP,
                   &SvcStatus
                   );
    if (bSuccess == TRUE)
        {
        SensPrint(SENS_INFO, (SENS_SETUPW SENS_STRING("Stopping %s."), SENS_SERVICE));

        do
            {
            Sleep(1000);
            if (SvcStatus.dwCurrentState == SERVICE_STOP_PENDING)
                {
                SensPrint(SENS_INFO, (SENS_STRING(".")));
                }
            else
                {
                SensPrint(SENS_INFO, (SENS_STRING("\n")));
                break;
                }
            }
        while (QueryServiceStatus(hSens, &SvcStatus));

        if (SvcStatus.dwCurrentState == SERVICE_STOPPED)
            {
            SensPrint(SENS_INFO, (SENS_SETUPW SENS_STRING("\n%s stopped.\n"), SENS_SERVICE));
            }
        else
            {
            SensPrint(SENS_ERR, (SENS_SETUPW SENS_STRING("\n%s failed to stop.\n"), SENS_SERVICE));
            }
        }

    //
    // Now, remove the service
    //
    if (DeleteService(hSens))
        {
        SensPrint(SENS_INFO, (SENS_SETUPW SENS_STRING("%s removed.\n"), SENS_SERVICE));
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrint(SENS_ERR, (SENS_SETUPW SENS_STRING("%s removal failed.\n"), SENS_SERVICE));
        }

Cleanup:
    //
    // Cleanup
    //
    if (hSens != NULL)
        {
        CloseServiceHandle(hSens);
        }
    if (hSCM != NULL)
        {
        CloseServiceHandle(hSCM);
        }

    return hr;
}




HRESULT
SetServiceWorldAccessMask(
    SC_HANDLE hService,
    DWORD dwAccessMask
    )
/*++

Routine Description:

    Add the access rights specified in the dwAccessMask to Everyone (World)
    with respect to this service. This was written to add SERVICE_START right
    to Everyone wrt SENS.

Arguments:

    hService - The service in question.

    dwAccessMask - The desired access rights to be set.

Notes:

    a. This code assumes that the WorldSid is present in the DACL of SENS
       service. This is true for NT4.
    b. This  a security hole. This security hole is not going to be plugged
       in future Service Packs of NT4 since some applications will break.
    c. This code needs to be modified to make it work on NT5.

Return Value:

    S_OK, if successful.

    HRESULT, on failure.

--*/
{
    int i;
    PSID pWorldSid;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DWORD dwError;
    DWORD dwSize;
    PSECURITY_DESCRIPTOR pSD;
    PACL pDacl;
    BOOL bStatus;
    BOOL bDaclPresent;
    BOOL bDaclDefaulted;
    PACCESS_ALLOWED_ACE pAce;

    i = 0;
    pWorldSid = NULL;
    pSD = NULL;
    pDacl = NULL;
    dwSize = 0x0;
    dwError = ERROR_SUCCESS;
    bStatus = FALSE;
    bDaclPresent = FALSE;
    bDaclDefaulted = FALSE;
    pAce = NULL;

    //
    // Allocate WorldSid
    //
    bStatus = AllocateAndInitializeSid(
                  &WorldAuthority,      // Pointer to identifier authority
                  1,                    // Count of subauthority
                  SECURITY_WORLD_RID,   // Subauthority 0
                  0,                    // Subauthority 1
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pWorldSid            // pointer to pointer to SID
                  );
    if (FALSE == bStatus)
        {
        dwError = GetLastError();
        SensPrintA(SENS_ERR, ("SetServiceWorldAccessMask(): AllocateAndInitiali"
                  "zeSid() failed with %d.\n", dwError));
        goto Cleanup;
        }

    //
    // Figure out how much buffer is needed for holding the service's
    // Security Descriptor (SD).
    //
    // NOTE: We pass &pSD instead of pSD because this parameter should
    //       not be NULL. For this call to QueryServiceObjectSecurity()
    //       we just need to pass some non-zero and valid buffer.
    //
    bStatus = QueryServiceObjectSecurity(
                  hService,                     // Handle of the service
                  DACL_SECURITY_INFORMATION,    // Type of info requested
                  &pSD,                         // Address of Security descriptor
                  0,                            // Size of SD buffer
                  &dwSize                       // Size of buffer needed
                  );
    if (   (TRUE == bStatus)
        || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
        {
        dwError = GetLastError();
        SensPrintA(SENS_ERR, ("SetServiceWorldAccessMask(): QueryServiceObject"
                  "Security() returned unexpected result - %d.\n", dwError));
        goto Cleanup;
        }

    //
    // Allocate the SD
    //
    pSD = (PSECURITY_DESCRIPTOR) new char[dwSize];
    if (NULL == pSD)
        {
        dwError = ERROR_OUTOFMEMORY;
        SensPrintA(SENS_ERR, ("SetServiceWorldAccessMask(): Failed to allocate"
                  "memory for a Security Descriptor.\n"));
        goto Cleanup;
        }

    //
    // Now, we are ready to get the service's SD.
    //
    bStatus = QueryServiceObjectSecurity(
                  hService,                     // Handle of the service
                  DACL_SECURITY_INFORMATION,    // Type of info requested
                  pSD,                          // Address of Security descriptor
                  dwSize,                       // Size of SD buffer
                  &dwSize                       // Size of buffer needed
                  );
    if (FALSE == bStatus)
        {
        dwError = GetLastError();
        ASSERT(dwError != ERROR_INSUFFICIENT_BUFFER);
        SensPrintA(SENS_ERR, ("SetServiceWorldAccessMask(): QueryServiceObject"
                  "Security() failed with %d.\n", dwError));
        goto Cleanup;
        }

    //
    // Get the DACL from SD, if present.
    //
    bStatus = GetSecurityDescriptorDacl(
                  pSD,                  // Address of SD
                  &bDaclPresent,        // Address of flag for presence of DACL
                  &pDacl,               // Address of pointer to DACL
                  &bDaclDefaulted       // Address of flag that indicates if
                  );                    // DACL was defaulted.
    if (FALSE == bStatus)
        {
        dwError = GetLastError();
        SensPrintA(SENS_ERR, ("SetServiceWorldAccessMask(): GetSecurityDescriptor"
                  "Dacl() failed with %d.\n", dwError));
        goto Cleanup;
        }

    //
    // For a service, we always expect to see a DACL.
    //
    ASSERT(bDaclPresent && (pDacl != NULL));
    if (   (FALSE == bDaclPresent)
        || (NULL == pDacl))
        {
        dwError = E_UNEXPECTED;
        SensPrintA(SENS_ERR, ("SetServiceWorldAccessMask(): DACL is not present"
                  "or DACL is NULL. Returning %d.\n", dwError));
        goto Cleanup;
        }

    //
    // Find the WorldSid ACE in the ACL and update it's Mask.
    //
    for (i = 0; i < pDacl->AceCount; i++)
        {
        bStatus = GetAce(
                      pDacl,            // pointer to ACL
                      i,                // index of ACE to retrieve
                      (LPVOID*) &pAce   // pointer to pointer to ACE
                      );
        if (FALSE == bStatus)
            {
            dwError = GetLastError();
            SensPrintA(SENS_ERR, ("SetServiceWorldAccessMask(): GetAce()"
                      "failed with %d.\n", dwError));
            goto Cleanup;
            }

        if (EqualSid(pWorldSid, &(pAce->SidStart)))
            {
            pAce->Mask |= dwAccessMask;
            }
        } // for ()

    //
    // Set the new SD on the service handle
    //
    bStatus = SetServiceObjectSecurity(
                hService,                   // Handle to the service.
                DACL_SECURITY_INFORMATION,  // Type of info being set
                pSD                         // Address of the new SD
                );
    if (FALSE == bStatus)
        {
        dwError = GetLastError();
        SensPrintA(SENS_ERR, ("SetServiceWorldAccessMask(): SetServiceObject"
                  "Security() failed with %d.\n", dwError));
        goto Cleanup;
        }


Cleanup:
    //
    // Cleanup
    //
    if (NULL != pWorldSid)
        {
        FreeSid(pWorldSid);
        }
    if (NULL != pSD)
        {
        delete pSD;
        }

    return HRESULT_FROM_WIN32(dwError);
}




void CALLBACK
MarkSensAsDemandStart(
    HWND hwnd,
    HINSTANCE hinst,
    LPSTR lpszCmdLine,
    int nCmdShow
    )
/*++

Routine Description:

    A function compatible with RunDll32 that will mark SENS as manual start.

Arguments:

    hwnd - Window handle that should be used as the owner window for
        any windows this DLL creates.

    hinst - This DLL's instance handle

    lpszCmdLine - ASCII command line the DLL should parse

    nCmdShow - Describes how the DLL's windows should be displayed

Return Value:

    None.

--*/
{
    SC_HANDLE hSCM;
    SC_HANDLE hSens;

    BOOL bStatus;
    DWORD dwError;
    SERVICE_STATUS ServiceStatus;

    bStatus = FALSE;
    dwError = ERROR_SUCCESS;

#ifdef DBG
    EnableDebugOutputIfNecessary();
#endif // DBG

    hSCM = OpenSCManager(
               NULL,                   // Local machine
               NULL,                   // Default database - SERVICES_ACTIVE_DATABASE
               SC_MANAGER_ALL_ACCESS   // NT4 NOTE: Only for Administrators.
               );
    if (NULL == hSCM)
        {
        dwError = GetLastError();
        SensPrintA(SENS_ERR, (SENS_SETUP "OpenSCManager() failed with 0x%x\n", dwError));
        goto Cleanup;
        }

    //
    // Get a handle to SCM
    //
    hSens = OpenService(
                hSCM,               // Handle to SCM database
                SENS_SERVICE,       // Name of the service in question
                SERVICE_ALL_ACCESS  // Type of access requested to the service
                );
    if (NULL == hSens)
        {
        dwError = GetLastError();
        SensPrintA(SENS_ERR, (SENS_SETUP "OpenService() failed with 0x%x\n", dwError));
        goto Cleanup;
        }

    //
    // Mark the service to Manual. NULL parameter implies no change.
    //
    bStatus = ChangeServiceConfig(
                  hSens,                // Handle to service
                  SERVICE_NO_CHANGE,    // Type of service
                  SERVICE_DEMAND_START, // When to start service
                  SERVICE_NO_CHANGE,    // Severity if service fails to start
                  NULL,                 // Pointer to service binary file name
                  NULL,                 // Pointer to load ordering group name
                  NULL,                 // Pointer to variable to get tag identifier
                  NULL,                 // Pointer to array of dependency names
                  NULL,                 // Pointer to account name of service
                  NULL,                 // Pointer to password for service account
                  NULL                  // Pointer to display name
                  );
    if (FALSE == bStatus)
        {
        dwError = GetLastError();
        SensPrintA(SENS_ERR, (SENS_SETUP "ChangeServiceConfig() failed with 0x%x\n", dwError));
        goto Cleanup;
        }

    SensPrintA(SENS_ERR, (SENS_SETUP "SENS now marked as DEMAND START\n\n"));

Cleanup:
    //
    // Cleanup
    //
    if (NULL != hSCM)
        {
        CloseServiceHandle(hSCM);
        }
    if (NULL != hSens)
        {
        CloseServiceHandle(hSens);
        }
}

#endif // SENS_NT4




HRESULT
CreateKey(
    HKEY hParentKey,
    const TCHAR* KeyName,
    const TCHAR* defaultValue,
    HKEY* hKey
    )
/*++

Routine Description:

    Create a key (with an optional default value).  The handle to the key is
    returned as an [out] parameter.  If NULL is passed as the key parameter,
    the key is created in the registry, then closed.

Arguments:

    hParentKey - Handle to the parent Key.

    KeyName - Name of the key to create.

    defaultValue - The default value for the key to create.

    hKey - OUT Handle to key that was created.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HKEY hTempKey;
    LONG lResult;

    hTempKey = NULL;

    lResult = RegCreateKeyEx(
                  hParentKey,               // Handle to open key
                  KeyName,                  // Subkey name
                  0,                        // Reserved
                  NULL,                     // Class string
                  REG_OPTION_NON_VOLATILE,  // Options Flag
                  KEY_ALL_ACCESS,           // Desired Security access
                  NULL,                     // Pointer to Security Attributes structure
                  &hTempKey,                // Handle of the opened/created key
                  NULL                      // Disposition value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32(lResult);
        }

    // Set the default value for the key
    if (defaultValue != NULL)
        {
        lResult = RegSetValueEx(
                      hTempKey,             // Key to set Value for.
                      NULL,                 // Value to set
                      0,                    // Reserved
                      REG_SZ,               // Value Type
                      (BYTE*) defaultValue, // Address of Value data
                      sizeof(TCHAR) * (_tcslen(defaultValue)+1) // Size of Value
                      );

        if (lResult != ERROR_SUCCESS)
            {
            RegCloseKey(hTempKey);
            return HRESULT_FROM_WIN32(lResult);
            }
        }

    if (hKey == NULL)
        {
        RegCloseKey(hTempKey);
        }
    else
        {
        *hKey = hTempKey;
        }

    return S_OK;
}




HRESULT
CreateNamedValue(
    HKEY hKey,
    const TCHAR* title,
    const TCHAR* value
    )
/*++

Routine Description:

    Create a named value under a key

Arguments:

    hKey - Handle to the parent Key.

    title - Name of the Value to create.

    value - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    LONG lResult;

    hr = S_OK;

    lResult = RegSetValueEx(
                  hKey,             // Key to set Value for.
                  title,            // Value to set
                  0,                // Reserved
                  REG_SZ,           // Value Type
                  (BYTE*) value,    // Address of Value data
                  sizeof(TCHAR) * (_tcslen(value)+1) // Size of Value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        hr = HRESULT_FROM_WIN32(lResult);
        }

    return hr;
}




HRESULT
CreateNamedDwordValue(
    HKEY hKey,
    const TCHAR* title,
    DWORD dwValue
    )
/*++

Routine Description:

    Create a named DWORD value under a key

Arguments:

    hKey - Handle to the parent Key.

    title - Name of the Value to create.

    dwValue - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    LONG lResult;

    hr = S_OK;

    lResult = RegSetValueEx(
                  hKey,             // Key to set Value for.
                  title,            // Value to set
                  0,                // Reserved
                  REG_DWORD,        // Value Type
                  (BYTE*) &dwValue, // Address of Value data
                  sizeof(DWORD)     // Size of Value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        hr = HRESULT_FROM_WIN32(lResult);
        }

    return hr;
}




HRESULT
RecursiveDeleteKey(
    HKEY hKeyParent,
    const TCHAR* lpszKeyChild
    )
/*++

Routine Description:

    Delete a key and all of its descendents.

Arguments:

    hKeyParent - Handle to the parent Key.

    lpszKeyChild - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HKEY hKeyChild;
    LONG lResult;

    //
    // Open the child.
    //
    lResult = RegOpenKeyEx(
                  hKeyParent,       // Handle to the Parent
                  lpszKeyChild,     // Name of the child key
                  0,                // Reserved
                  KEY_ALL_ACCESS,   // Security Access Mask
                  &hKeyChild        // Handle to the opened key
                  );

    if (lResult != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32(lResult);
        }

    //
    // Enumerate all of the decendents of this child.
    //
    FILETIME time;
    TCHAR szBuffer[MAX_PATH+1];
    const DWORD bufSize = sizeof szBuffer / sizeof szBuffer[0];
    DWORD dwSize = bufSize;

    while (TRUE)
        {
        lResult = RegEnumKeyEx(
                      hKeyChild,    // Handle of the key to enumerate
                      0,            // Index of the subkey to retrieve
                      szBuffer,     // OUT Name of the subkey
                      &dwSize,      // OUT Size of the buffer for name of subkey
                      NULL,         // Reserved
                      NULL,         // OUT Class of the enumerated subkey
                      NULL,         // OUT Size of the class of the subkey
                      &time         // OUT Last time the subkey was written to
                      );

        if (lResult != ERROR_SUCCESS)
            {
            break;
            }

        // Delete the decendents of this child.
        lResult = RecursiveDeleteKey(hKeyChild, szBuffer);
        if (lResult != ERROR_SUCCESS)
            {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild);
            return HRESULT_FROM_WIN32(lResult);
            }

        dwSize = bufSize;
        } // while

    // Close the child.
    RegCloseKey(hKeyChild);

    // Delete this child.
    lResult = RegDeleteKey(hKeyParent, lpszKeyChild);

    return HRESULT_FROM_WIN32(lResult);
}




HRESULT
SensConfigureEventSystem(
    BOOL bUnregister
    )
/*++

Routine Description:

    As of NTbuild 1750, EventSystem is not auto-configured. So, SENS does
    the work of configuring EventSystem.

Arguments:

    bUnregister - If TRUE, then install EventSystem.

Notes:

    o This is a dummy call on NT4 because we don't need to configure
      EventSystem on NT4. IE5 setup (Webcheck.dll) configures LCE.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    return S_OK;
}




HRESULT
SensUpdateVersion(
    BOOL bUnregister
    )
/*++

Routine Description:

    Update the version of SENS in the registry.

Arguments:

    bUnregister - usual.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    HKEY hKeySens;
    LONG RegStatus;
    DWORD dwConfigured;

    hr = S_OK;
    hKeySens = NULL;
    RegStatus = ERROR_SUCCESS;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, // Handle of the key
                    SENS_REGISTRY_KEY,  // String which represents the sub-key to open
                    0,                  // Reserved (MBZ)
                    KEY_ALL_ACCESS,     // Security Access mask
                    &hKeySens           // Returned HKEY
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "RegOpenKeyEx(Sens) returned %d.\n", RegStatus));
        hr = HRESULT_FROM_WIN32(RegStatus);
        goto Cleanup;
        }

    if (TRUE == bUnregister)
        {
        dwConfigured = CONFIG_VERSION_NONE;
        }
    else
        {
        dwConfigured = CONFIG_VERSION_CURRENT;
        }

    // Update registry to reflect that SENS is now configured.
    RegStatus = RegSetValueEx(
                  hKeySens,             // Key to set Value for.
                  IS_SENS_CONFIGURED,   // Value to set
                  0,                    // Reserved
                  REG_DWORD,            // Value Type
                  (BYTE*) &dwConfigured,// Address of Value data
                  sizeof(DWORD)         // Size of Value
                  );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "RegSetValueEx(IS_SENS_CONFIGURED) failed with 0x%x\n", RegStatus));
        hr = HRESULT_FROM_WIN32(RegStatus);
        goto Cleanup;
        }

    SensPrintA(SENS_INFO, (SENS_SETUP "SENS is now configured successfully. "
               "Registry updated to 0x%x.\n", dwConfigured));

Cleanup:
    //
    // Cleanup
    //
    if (hKeySens)
        {
        RegCloseKey(hKeySens);
        }

    return hr;
}



#if defined(SENS_CHICAGO)

extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpvReserved
    )
/*++

Routine Description:

    This routine will get called either when a process attaches to this dll
    or when a process detaches from this dll.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    BOOL bSuccess;

    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
            // Disable Thread attach/detach calls
            bSuccess = DisableThreadLibraryCalls(hInstance);
            ASSERT(bSuccess == TRUE);
            break;

        case DLL_PROCESS_DETACH:
            break;

        }

    return(TRUE);
}

#endif // SENS_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senslogn\onestop.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    onestop.hxx

Abstract:

    This file contains the common functions that are helpful in notifying
    OneStop of logon/logoff events.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    a. This is being used in senslogn.dll on NT5.
    b. It is also being used in sens.dll on NT4 and Win9x.

Revision History:

    GopalP          4/29/1998         Start.

--*/


#include <mobsyncp.h>
#include "onestop.hxx"




HRESULT
SensNotifyOneStop(
    HANDLE hToken,
    TCHAR *pCommandLine,
    BOOL bSync
    )
{
    TCHAR szCommandLine[256];
    DWORD dwLastError;
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;

    dwLastError = 0;

    // CreateProcess* APIs require an editable buffer for command-line parameter
    ASSERT(_tcslen(pCommandLine) < 255);
    _tcscpy(szCommandLine, pCommandLine);

    // Fill in the STARTUPINFO structure.
    memset(&si, 0x0, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = NULL;
    si.lpDesktop = NULL;
    si.dwX = 0x0;
    si.dwY = 0x0;
    si.dwXSize = 0x0;
    si.dwYSize = 0x0;
    si.dwFlags = 0x0;
    si.wShowWindow = SW_SHOW;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;

    LogMessage((SENSLOGN "[%d] Launching OneStop...\n", GetTickCount()));
#if !defined(SENS_CHICAGO)
    if (CreateProcessAsUser(
            hToken,             // Handle to the Token of the logged-on user
#else  // SENS_CHICAGO
    if (CreateProcess(
#endif // SENS_CHICAGO
            NULL,               // Name of the executable module
            szCommandLine,      // Command-line string
            NULL,               // Security attributes
            NULL,               // Thread security attributes
            FALSE,              // Don't inherit handles
            0,                  // Creation flags
            NULL,               // New environment block
            NULL,               // Current directory name
            &si,                // Startup info
            &ProcessInformation // Process information
            ))
        {
        //
        // Wait until the process terminates
        //
        if (bSync)
            {
            LogMessage((SENSLOGN "[%d] Waiting for OneStop to return...\n", GetTickCount()));
            WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
            LogMessage((SENSLOGN "[%d] OneStop returned successfully.\n", GetTickCount()));
            }

        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);

        return S_OK;
        }
    else
        {
        dwLastError = GetLastError();
        SensPrintToDebugger(SENS_DBG, (SENSLOGN "SensNotifyOneStop() - CreateProcessXXX() "
                            "failed with 0x%x\n", dwLastError));
        return HRESULT_FROM_WIN32(dwLastError);
        }

    LogMessage((SENSLOGN "[%d] Successfully notified OneStop.\n", GetTickCount()));

    return S_OK;
}




BOOL
IsAutoSyncEnabled(
    HANDLE hToken,
    DWORD dwMask
    )
{
    HKEY hKeyAutoSync;
    LONG lResult;
    BOOL bEnabled;
    BOOL bImpersonated;
    DWORD dwType;
    DWORD dwAutoSyncFlags;
    DWORD cbData;
    LPBYTE lpbData;

    hKeyAutoSync = NULL;
    lResult = 0;
    bEnabled = FALSE;
    bImpersonated = FALSE;
    dwType = 0x0;
    dwAutoSyncFlags = 0x0;
    cbData = 0x0;
    lpbData = NULL;

    //
    // Impersonate the Logged on user so that we can access the user-specific
    // registry entries.
    //
#if !defined(SENS_CHICAGO)

    bImpersonated = ImpersonateLoggedOnUser(hToken);
    if (bImpersonated == FALSE)
        {
        LogMessage((SENSLOGN "ImpersonateLoggedOnUser(token = 0x%x) failed - "
                    "0x%x\n", hToken, GetLastError()));
        }
    else
        {
        LogMessage((SENSLOGN "ImpersonateLoggedUser() succeeded!\n"));
        }

#endif // SENS_CHICAGO

    //
    // Open AutoSync sub-key for this user.
    //
    lResult = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,   // Handle of the open Key
                  AUTOSYNC_KEY,         // Name of the sub-key
                  0,                    // Reserved (MBZ)
                  KEY_QUERY_VALUE,      // Security access mask
                  &hKeyAutoSync         // Address of the handle of new key
                  );
    if (lResult != ERROR_SUCCESS)
        {
        SensPrintToDebugger(SENS_DBG, (SENSLOGN "RegOpenKeyEx(AUTOSYNC) failed with 0x%x\n", lResult));
        goto Cleanup;
        }

    //
    // Query the Flags value
    //
    lpbData = (LPBYTE) &dwAutoSyncFlags;
    cbData = sizeof(DWORD);

    lResult = RegQueryValueEx(
                  hKeyAutoSync,     // Handle of the sub-key
                  AUTOSYNC_FLAGS,   // Name of the Value
                  NULL,             // Reserved (MBZ)
                  &dwType,          // Address of the type of the Value
                  lpbData,          // Address of the data of the Value
                  &cbData           // Address of size of data of the Value
                  );
    if (lResult != ERROR_SUCCESS)
        {
        LogMessage((SENSLOGN "RegQueryValueEx(AUTOSYNC_FLAGS) failed with 0x%x\n", lResult));
        goto Cleanup;
        }
    ASSERT(dwType == REG_DWORD);

    //
    // Check to see if the Mask bit is set
    //
    if (dwMask == AUTOSYNC_ON_STARTSHELL)
        {
        if (  (dwAutoSyncFlags & AUTOSYNC_LAN_LOGON)
           || (dwAutoSyncFlags & AUTOSYNC_WAN_LOGON))
            {
            LogMessage((SENSLOGN "AutoSync is enabled for StartShell\n"));
            bEnabled = TRUE;
            goto Cleanup;
            }
        else
            {
            LogMessage((SENSLOGN "AutoSync is NOT enabled for Logon\n"));
            }
        }
    else
    if (dwMask == AUTOSYNC_ON_LOGOFF)
        {
        if (  (dwAutoSyncFlags & AUTOSYNC_LAN_LOGOFF)
           || (dwAutoSyncFlags & AUTOSYNC_WAN_LOGOFF))
            {
            LogMessage((SENSLOGN "AutoSync is enabled for Logoff\n"));
            bEnabled = TRUE;
            goto Cleanup;
            }
        else
            {
            LogMessage((SENSLOGN "AutoSync is NOT enabled for Logoff\n"));
            }
        }
    else
    if (dwMask == AUTOSYNC_ON_SCHEDULE)
        {
        if (dwAutoSyncFlags != NULL)
            {
            LogMessage((SENSLOGN "AutoSync is enabled for Schedule\n"));
            bEnabled = TRUE;
            goto Cleanup;
            }
        else
            {
            LogMessage((SENSLOGN "AutoSync is NOT enabled for Schedule\n"));
            }
        }

    //
    // Autosync is not enabled.
    //


Cleanup:
    //
    // Cleanup
    //
    if (hKeyAutoSync)
        {
        RegCloseKey(hKeyAutoSync);
        }

#if !defined(SENS_CHICAGO)

    // Stop Impersonating
    if (bImpersonated)
        {
        RevertToSelf();
        }

#endif // SENS_CHICAGO

    return bEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senscfg\senscfgt\senscfgt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senscfgt.cxx

Abstract:

    BVT for the SENS Configuration.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/13/1997         Start.

--*/


#include <common.hxx>
#include <malloc.h>
#include <ole2.h>
#include <windows.h>


inline void
Usage(
    void
    )
{
    printf("\nUsage:    senscfgt [option] \n\n");
    printf("    option\n");
    printf("        -i      Perform SENS install.\n");
    printf("        -u      Perform SENS uninstall.\n");
}


int
main(
    int argc,
    const char * argv[]
    )
{
    BOOL config = TRUE;

    if (argc != 2)
        {
        Usage();
        return -1;
        }

    if (   (argc == 2)
        && (   (strcmp(argv[1], "-?") == 0)
            || (strcmp(argv[1], "/?") == 0)
            || (strcmp(argv[1], "-help") == 0)
            || (strcmp(argv[1], "/help") == 0)))
        {
        Usage();
        return -1;
        }

    if (   (strcmp(argv[1], "/u") == 0)
        || (strcmp(argv[1], "-u") == 0))
        {
        config = FALSE;
        }
    else
    if (   (strcmp(argv[1], "/i") != 0)
        && (strcmp(argv[1], "-i") != 0))
        {
        Usage();
        return -1;
        }

    //
    // Do SENS install/uninstall testing
    //
    {
        HMODULE hSensCfgDll = NULL;
        FARPROC pRegisterFunc = NULL;
        HRESULT hr = S_OK;
        BOOL bComInitialized = FALSE;

        // Initialize COM
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (FAILED(hr))
            {
            printf("CoInitializeEx() failed, HRESULT=%x\n", hr);
            goto Cleanup;
            }
        bComInitialized = TRUE;
        
        // Try to Load the Configuration Dll
        hSensCfgDll = LoadLibrary(TEXT("senscfg.dll"));
        if (hSensCfgDll == NULL)
            {
            printf("LoadLibrary returned 0x%x.\n", GetLastError());
            goto Cleanup;
            }

        // Get the required entry point.
        pRegisterFunc = GetProcAddress(hSensCfgDll, config ? "SensRegister" : "SensUnregister");
        if (pRegisterFunc == NULL)
            {
            printf("GetProcAddress(Register) returned 0x%x.\n", GetLastError());
            goto Cleanup;
            }

        // Do it
        hr = (*pRegisterFunc)();
        if (FAILED(hr))
            {
            printf("SENS configuration returned with 0x%x\n", hr);
            goto Cleanup;
            }

Cleanup:
        //
        // Cleanup
        //
        if (hSensCfgDll)
            {
            FreeLibrary(hSensCfgDll);
            }

        if (TRUE == bComInitialized)
            {               
            CoUninitialize();
            }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senslogn\stub_irnotify_c.c ===
#include <irnotify_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senslogn\stub_notify_c.c ===
#include <notify_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senslogn\senslogn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senslogn.cxx

Abstract:

    This file contains the implementation of a Stub DLL to notify SENS of
    events generated by Winlogon.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    a. This DLL notifies the following components:
        o EventSystem (contact DMcCrady)
        o IR service (contact JRoberts)
        o SENS service (contact GopalP)

    b. This DLL also maintains tokens of the currently logged on user. This
       is used by COM for activation.

Revision History:

    GopalP          12/7/1997         Start.

--*/



#include <common.hxx>
#include <stdio.h>
#include <windows.h>
#include <malloc.h>
#include <winwlx.h>
#include <sensapip.h>
#include <rpc.h>
#include "mutex.hxx"
#include "irnotify.h"
#include "usertok.h"
#include "senslogn.hxx"
#include "onestop.cxx"


//
// Constants
//
#define NOTIFY_LCE_STARTSHELL   0x00000003
#define NOTIFY_LCE_LOGOFF       0x00000004

#define SENS_START_WAIT_TIMEOUT 180*1000    // 3 minutes
#define NOTIFY_LCE_LOGONUSER    "NotifyLogonUser"
#define NOTIFY_LCE_LOGOFFUSER   "NotifyLogoffUser"
#define NOTIFY_IR_LOGONUSER     "OnUserLogon"
#define NOTIFY_IR_LOGOFFUSER    "OnUserLogoff"
#define NOTIFY_IR_INIT          "InitializeDll"
#define SENS_SERVICE            SENS_STRING("SENS")
#define EVENTSYSTEM_DLL         SENS_STRING("ES.DLL")
#define IR_DLL                  SENS_STRING("IRNOTIFY.DLL")
#define SENS_STARTED_EVENT      SENS_STRING("SENS Started Event")


//
// Globals
//

PWLX_NOTIFICATION_INFO gpStartShellInfo;
HANDLE ghSensStartedEvent;
MUTEX * SetupMutex;
BOOL gbIsTokenCodeInitialized;

// For GetCurrentUserToken
PSID LocalSystemSid;
USER_LOGON_TABLE * ActiveUserList;

// For IR notification of logon/logoff
RPC_BINDING_HANDLE g_hIrxfer;


//
// Some useful Macros
//

#ifdef DETAIL_DEBUG


#define DUMP_INFO(_EventType_)                                                      \
                                                                                    \
    char buf[512];                                                                  \
    PWLX_NOTIFICATION_INFO pInfo = (PWLX_NOTIFICATION_INFO) lpvParam;               \
                                                                                    \
    LogMessage(("------------------------------------------------------\n"));       \
    LogMessage((SENSLOGN " Received a %s Event.\n", _EventType_));                  \
    LogMessage(("          Size        - %d\n", pInfo->Size));                      \
    LogMessage(("          Flags       - 0x%x\n", pInfo->Flags));                   \
    LogMessage(("          UserName    - %s\n", UnicodeToAnsi(pInfo->UserName, buf)));      \
    LogMessage(("          Domain      - %s\n", UnicodeToAnsi(pInfo->Domain, buf)));        \
    LogMessage(("          WinStation  - %s\n", UnicodeToAnsi(pInfo->WindowStation, buf))); \
    LogMessage(("          hToken      - 0x%x\n", pInfo->hToken));                  \
    LogMessage(("          hDesktop    - 0x%x\n", pInfo->hDesktop));                \
    LogMessage(("          pCallback   - 0x%x\n", pInfo->pStatusCallback));         \
    LogMessage(("          dwSessionId - 0x%x\n", NtCurrentPeb()->SessionId));      \
    LogMessage(("------------------------------------------------------\n"));


//
// Functions
//

PCHAR
UnicodeToAnsi(
    PWSTR in,
    PCHAR out
    )
{
    PCHAR pSave = out;

    if (in == NULL)
        {
        return "<NULL>";
        }

    if (*in == (WCHAR)'\0')
        {
        return "<Null String>";
        }

    while( *out++ = (CHAR)*in++)
        ;

    return pSave;
}


#else // ! DETAIL_DEBUG

#define DUMP_INFO(_EventType_)

#endif // DETAIL_DEBUG



#define FIRE_EVENT(_EventType_)                                             \
    {                                                                       \
                                                                            \
    SENS_NOTIFY_WINLOGON Data;                                              \
                                                                            \
    Data.eType = _EventType_;                                               \
    Data.Info.Size = sizeof(SENS_NOTIFY_WINLOGON);                          \
    Data.Info.Flags = ((PWLX_NOTIFICATION_INFO)lpvParam)->Flags;            \
    Data.Info.UserName = ((PWLX_NOTIFICATION_INFO)lpvParam)->UserName;      \
    Data.Info.Domain = ((PWLX_NOTIFICATION_INFO)lpvParam)->Domain;          \
    Data.Info.WindowStation = ((PWLX_NOTIFICATION_INFO)lpvParam)->WindowStation;    \
    Data.Info.hToken = HandleToUlong(((PWLX_NOTIFICATION_INFO)lpvParam)->hToken);   \
    Data.Info.hDesktop = HandleToUlong(((PWLX_NOTIFICATION_INFO)lpvParam)->hDesktop); \
    Data.Info.dwSessionId = NtCurrentPeb()->SessionId;                      \
                                                                            \
    status = SensNotifyWinlogonEvent(&Data);                                \
                                                                            \
    if (status) {SensPrintToDebugger(SENS_DBG, (SENSLOGN "SensNotifyWinlogonEvent(0x%x) returned %d\n", _EventType_, status));}    \
    }


/*****************************************************************************
 *
 *  IsRemoteSession
 *
 *  On a Terminal Server: returns TRUE if current Session is the not the physical
 *  console , FALSE if it is the console session (SessionId == 0)
 *  On non-Hydra NT: always returns FALSE
 *
 * ENTRY:
 *   nothing
 *
 * EXIT:
 *   nothing
 *
 ****************************************************************************/

typedef BOOL (__stdcall * PFNPROCESSIDTOSESSIONID)(DWORD, PDWORD);
#define PFN_FIRSTTIME   (PFNPROCESSIDTOSESSIONID(-1))

BOOL
IsRemoteSession(VOID)
{
    static PFNPROCESSIDTOSESSIONID s_pfn = PFN_FIRSTTIME;
    static BOOL bCachedIsRemoteSession = FALSE;

    DWORD dwSessionId;

    if (PFN_FIRSTTIME == s_pfn)
        {
        HINSTANCE hinst = GetModuleHandle(L"KERNEL32.DLL");

        if (hinst)
            {
            s_pfn = (PFNPROCESSIDTOSESSIONID)GetProcAddress(hinst, "ProcessIdToSessionId");
            }
        else
            {
            s_pfn = NULL;
            }
    }

    if (s_pfn && s_pfn(GetCurrentProcessId(), &dwSessionId))
        {
        bCachedIsRemoteSession = (dwSessionId != 0);
        }

    // we set s_pfn = NULL to guarntee we only ever call ProcessIdToSessionId
    // once, and after that we just use the bCachedIsRemoteSession value
    s_pfn = NULL;

    return bCachedIsRemoteSession;
}




DWORD WINAPI
SensLogonEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Logon Event. In addition, we do the following:

    a. Populate our token table with the current token.
    b. Initialize The token RPC interface, if necessary.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;
    PWLX_NOTIFICATION_INFO pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    DUMP_INFO("Logon");

    ActiveUserList->Add( pTempInfo );

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_LOGON);

    return status;
}




DWORD WINAPI
SensLogoffEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Logoff Event. We notify various components
    (like IR, OneStop, EventSystem, SENS) of the Logoff event.

Arguments:

    lpvParam - Winlogon notification info.

Notes:

    a. The system logoff will block till this call returns. Be very
       careful in adding code here.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;
    DWORD dwError;
    HRESULT hr;
    PWLX_NOTIFICATION_INFO pTempInfo;

    hr = S_OK;
    dwError = 0x0;
    pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    LogMessage((SENSLOGN "[%d] Entered Logoff.\n", GetTickCount()));

    DUMP_INFO("Logoff");

    // Try to fire SENS Event
    LogMessage((SENSLOGN "[%d] Notifying SENS...\n", GetTickCount()));
    FIRE_EVENT(SENS_NOTIFY_WINLOGON_LOGOFF);
    LogMessage((SENSLOGN "[%d] SensNotifyWinlogonEvent(LOGOFF) succeeded.\n", GetTickCount()));

    // Notify IR
    LogMessage((SENSLOGN "[%d] Notifying IR...\n", GetTickCount()));
    OnUserLogoff( pTempInfo );
    LogMessage((SENSLOGN "[%d] OnUserLogoff() succeeded, notified IR.\n", GetTickCount()));

    // Start OneStop if necessary, except on Restart.
    if (   ((pTempInfo->Flags & EWX_REBOOT) == 0)
        && (IsAutoSyncEnabled(pTempInfo->hToken, AUTOSYNC_ON_LOGOFF)))
        {
        //
        // NOTE: If SENS ever becomes demandstarted on NT5, there are a couple
        //       of things that can be done:
        //          o Call StartSensIfNecessary() here. (OR)
        //          o Make Sens APIs call StartSensIfNecessary().
        //
        LogMessage((SENSLOGN "[%d] Notifying OneStop...\n", GetTickCount()));
        hr = SensNotifyOneStop(pTempInfo->hToken, SYNC_MANAGER_LOGOFF, TRUE);
        LogMessage((SENSLOGN "[%d] SensNotifyOneStop() returned 0x%x\n", GetTickCount(), hr));
        }

    // Notify EventSystem
    LogMessage((SENSLOGN "[%d] Notifying EventSystem...\n", GetTickCount()));
    hr = SensNotifyEventSystem(NOTIFY_LCE_LOGOFF, lpvParam);
    LogMessage((SENSLOGN "[%d] SensNotifyEventSystem() returned 0x%x\n", GetTickCount(), hr));

    //
    // Remove token handle from the list at the end so that COM activation
    // works till SENS gets done with event firings.
    //
    ActiveUserList->Remove( pTempInfo );
    LogMessage((SENSLOGN "Removed current user's token!\n"));

    return status;
}




DWORD WINAPI
SensStartupEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Startup Event. Do some token management related
    initialization.

Arguments:

    lpvParam - Winlogon notification info.

Notes:

    a. This occurs very early in the bootup sequence. At this time,
       SENS service hasn't yet started up.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;
    DWORD dwLastError;

    status = 0x0;
    gbIsTokenCodeInitialized = FALSE;

    //
    // Create a SID representing the Local System account.
    //
    SID_IDENTIFIER_AUTHORITY Authority = SECURITY_NT_AUTHORITY;

    status = RtlAllocateAndInitializeSid(
                 &Authority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 0,
                 &LocalSystemSid
                 );
    if (!NT_SUCCESS(status))
        {
        return RtlNtStatusToDosError(status);
        }

    //
    // Create the table of logged-in users.
    //
    ActiveUserList = new USER_LOGON_TABLE( &status );
    if (!ActiveUserList || status)
        {
        delete ActiveUserList;
        return ERROR_NOT_ENOUGH_MEMORY;
        }

    SetupMutex = new MUTEX( &status );
    if (!SetupMutex || status)
        {
        delete SetupMutex;
        return ERROR_NOT_ENOUGH_MEMORY;
        }

    InitializeNotifyInterface();

    //
    // We are ready to use Token Code.
    //
    gbIsTokenCodeInitialized = TRUE;
    LogMessage((SENSLOGN "**** Token code initialized successfully ****\n"));

    //
    // Create an Event to indicate the starting of SENS.
    //
    ghSensStartedEvent = CreateEvent(
                             NULL,      // Specific Security Attributes
                             TRUE,      // Event is ManualReset
                             FALSE,     // Initial state is not Signalled
                             SENS_STARTED_EVENT
                             );
    if (ghSensStartedEvent == NULL)
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartupEvent() - CreateEvent() failed - %x.\n",
                    dwLastError));
        }
    else
        {
        LogMessage((SENSLOGN "SensStartedEvent created successfully\n"));
        }

    DUMP_INFO("Startup");

    return status;
}




BOOLEAN
InitializeNotifyInterface(
    void
    )
/*++

Routine Description:

    Initialize RPC interface for accepting calls to GetCurrentUserToken() API.

Arguments:

    None.

Return Value:

    TRUE, if successful

    FALSE, otherwise.

--*/
{
    unsigned i;
    DWORD status;

    SetupMutex->Enter();

    //
    // Register the interface for GetCurrentUserToken().
    //
    status = RpcServerRegisterAuthInfo(
                 NULL,
                 RPC_C_AUTHN_WINNT,
                 NULL,
                 NULL
                 );
    if (status)
        {
        SetupMutex->Leave();
        return FALSE;
        }

    status = RpcServerUseAllProtseqsIf( RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                        _GetUserToken_ServerIfHandle,
                                        NULL
                                        );
    if (status)
        {
        SetupMutex->Leave();
        return FALSE;
        }

    //
    // We expect another part of the process has already called RpcServerListen.
    //
    status = RpcServerRegisterIfEx(
                 _GetUserToken_ServerIfHandle,
                 NULL,
                 NULL,
                 0,
                 RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                 AllowLocalSystem
                 );
    if (status)
        {
        SetupMutex->Leave();
        return FALSE;
        }

    if (!IsRemoteSession())
        {
        //
        // Make a handle to the Infrared Monitor app.
        //
        RPC_BINDING_HANDLE hServer;
        status = RpcBindingFromStringBinding(L"ncalrpc:[,security=impersonation dynamic false]", &hServer);
        if (status)
            {
            SetupMutex->Leave();
            return FALSE;
            }

        RPC_SECURITY_QOS RpcSecQos;

        RpcSecQos.Version= RPC_C_SECURITY_QOS_VERSION_1;
        RpcSecQos.ImpersonationType= RPC_C_IMP_LEVEL_IMPERSONATE;
        RpcSecQos.IdentityTracking= RPC_C_QOS_IDENTITY_DYNAMIC;
        RpcSecQos.Capabilities= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;

        status= RpcBindingSetAuthInfoEx(hServer,
                                        L"NT Authority\\System",
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                        RPC_C_AUTHN_WINNT,
                                        NULL,
                                        RPC_C_AUTHZ_NONE,
                                        (RPC_SECURITY_QOS *)&RpcSecQos);
        if (RPC_S_OK != status)
            {
            RpcBindingFree(&hServer);
            SetupMutex->Leave();
            return FALSE;
            }

        g_hIrxfer = hServer;
        }

    SetupMutex->Leave();
    return TRUE;
}




DWORD WINAPI
SensStartShellEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the StartShell Event. We treat this as Logon and notify
    various components (IR, OneStop, SENS, EventSystem) of Logon.

Arguments:

    lpvParam - Winlogon notification info.

Notes:

    a. When this function is called by Winlogon, the shell has begun starting.
       There is no guarantee that shell has started completely and is up and
       running.

    b. We create a thread to do bulk of the work and allow the function
       to return.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    BOOL bRetVal;
    DWORD status;
    DWORD dwLastError;
    PWLX_NOTIFICATION_INFO pTempInfo;

    dwLastError = 0;
    bRetVal = TRUE;

    DUMP_INFO("StartShell");

    //
    // Allocate space for the parameters
    //
    pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;
    gpStartShellInfo = (PWLX_NOTIFICATION_INFO) new char[(sizeof(WLX_NOTIFICATION_INFO))];
    if (gpStartShellInfo == NULL)
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartShellEvent(): new() failed - %x.\n", dwLastError));
        return dwLastError;
        }
    memcpy(gpStartShellInfo, pTempInfo, sizeof(WLX_NOTIFICATION_INFO));

    // String in WLX_NOTIFICATION_INFO are Unicode
    gpStartShellInfo->UserName = (PWSTR) new WCHAR[(wcslen(pTempInfo->UserName) + 1)];
    gpStartShellInfo->Domain = (PWSTR) new WCHAR[(wcslen(pTempInfo->Domain) + 1)];
    gpStartShellInfo->WindowStation = (PWSTR) new WCHAR[(wcslen(pTempInfo->WindowStation) + 1)];
    if (   (gpStartShellInfo->UserName == NULL)
        || (gpStartShellInfo->Domain == NULL)
        || (gpStartShellInfo->WindowStation == NULL))
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartShellEvent(): new() of strings failed - %x.\n", dwLastError));
        delete gpStartShellInfo->UserName;
        delete gpStartShellInfo->Domain;
        delete gpStartShellInfo->WindowStation;
        delete gpStartShellInfo;
        gpStartShellInfo = NULL;
        return dwLastError;
        }

    //
    // Copy the parameters
    //
    wcscpy(gpStartShellInfo->UserName, pTempInfo->UserName);
    wcscpy(gpStartShellInfo->Domain, pTempInfo->Domain);
    wcscpy(gpStartShellInfo->WindowStation, pTempInfo->WindowStation);

    //
    // Create a thread to wait on the StartShell event
    //
    bRetVal = SensQueueUserWorkItem(
                  (LPTHREAD_START_ROUTINE) SensWaitToStartRoutine,
                  gpStartShellInfo, // Winlogon event info
                  SENS_LONG_ITEM    // Flags
                  );
    if (FALSE == bRetVal)
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartShellEvent(): SensQueueUserWorkItem() failed with %x.\n",
                    dwLastError));

        // Cleanup
        delete gpStartShellInfo->UserName;
        delete gpStartShellInfo->Domain;
        delete gpStartShellInfo->WindowStation;
        delete gpStartShellInfo;
        gpStartShellInfo = NULL;
        }

    return dwLastError;
}




DWORD WINAPI
SensPostShellEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Post Shell Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Post Shell");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_POSTSHELL);

    return status;
}




DWORD WINAPI
SensDisconnectEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Session Disconnect Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Session Disconnect");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_SESSION_DISCONNECT);

    return status;
}




DWORD WINAPI
SensReconnectEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Session Reconnect Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Session Reconnect");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_SESSION_RECONNECT);

    return status;
}




DWORD WINAPI
SensShutdownEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Shutdown Event. Do some cleanup.

Arguments:

    lpvParam - Winlogon notification info.

Notes:

    a. It is guaranteed that COM activation will not work when this event
       is received.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    status = ERROR_SUCCESS;

    DUMP_INFO("Shutdown");

    return status;
}




DWORD WINAPI
SensLockEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Display Lock Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Display Lock");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_LOCK);

    return status;
}




DWORD WINAPI
SensUnlockEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Display unlock Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Display Unlock");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_UNLOCK);

    return status;
}




DWORD WINAPI
SensStartScreenSaverEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the ScreenSaver Start Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("StartScreenSaver");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_STARTSCREENSAVER);

    return status;
}





DWORD WINAPI
SensStopScreenSaverEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Screen Saver Stop Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("StopScreenSaver");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_STOPSCREENSAVER);

    return status;
}




DWORD WINAPI
SensWaitToStartRoutine(
    LPVOID lpvParam
    )
/*++

Routine Description:

    This routine implements the work item that is queued when the StartShell
    event is received.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    ERROR_SUCCESS, always

--*/
{
    DWORD dwError;
    DWORD dwWaitStatus;
    DWORD status;
    HRESULT hr;
    PWLX_NOTIFICATION_INFO pTempInfo;

    dwError = ERROR_SUCCESS;
    dwWaitStatus = 0x0;
    pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    // Give SENS a chance to start if it has not already stated.
    // Give up after a short time in case sens is has been set to manual start
    // We could check the service configuration but the thread as already been
    // created so we save won't very much.

    ASSERT(ghSensStartedEvent);

    dwError = WaitForSingleObject(ghSensStartedEvent, 20*1000);
    if (dwError != STATUS_WAIT_0)
        {
        LogMessage((SENSLOGN "[%d] Wait for sens start event timed out...\n", GetTickCount()));
        }

    // Notify EventSystem
    LogMessage((SENSLOGN "[%d] Notifying EventSystem...\n", GetTickCount()));
    hr = SensNotifyEventSystem(NOTIFY_LCE_STARTSHELL, lpvParam);
    LogMessage((SENSLOGN "[%d] SensNotifyEventSystem() returned 0x%x\n", GetTickCount(), hr));

    // Notify IR
    LogMessage((SENSLOGN "[%d] Notifying IR...\n", GetTickCount()));
    OnUserLogon( pTempInfo );
    LogMessage((SENSLOGN "[%d] OnUserLogon succeeded.\n", GetTickCount()));

    // Try to fire SENS Event
    LogMessage((SENSLOGN "[%d] Notifying SENS...\n", GetTickCount()));
    FIRE_EVENT(SENS_NOTIFY_WINLOGON_STARTSHELL);
    LogMessage((SENSLOGN "[%d] SensNotifyWinlogonEvent(STARTSHELL) succeeded.\n", GetTickCount()));

    // Cleanup
    delete pTempInfo->UserName;
    delete pTempInfo->Domain;
    delete pTempInfo->WindowStation;
    delete pTempInfo;
    gpStartShellInfo = NULL;

    return ERROR_SUCCESS;
}




HRESULT
SensNotifyEventSystem(
    DWORD dwEvent,
    LPVOID lpvParam
    )
/*++

Routine Description:

    This routine notifies EventSystem of the Logon/Logoff events.

Arguments:

    dwEvent - Tells if the event is Logon or Logoff.

    lpvParam - Winlogon notification info.

Notes:

    a. EventSystem's notify routine has been observed sometimes to take
       a long time causing Logoff to take longer time to complete.

Return Value:

    HRESULT from EventSystem's Notify routine.

--*/
{
    HRESULT hr;

    hr = S_OK;

    PWLX_NOTIFICATION_INFO pTempInfo = (PWLX_NOTIFICATION_INFO)lpvParam;

    //
    // Notify the COM+ Event System that a user has just logged on.
    // Per-user subscriptions will be activated.
    //

    typedef HRESULT (__stdcall *LPFN_NOTIFICATION)(HANDLE);

    HMODULE hDLL;
    LPFN_NOTIFICATION lpfnNotify = NULL;

    hDLL = (HMODULE) LoadLibrary(EVENTSYSTEM_DLL);
    if (hDLL == NULL)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        }
    else
        {
        if (dwEvent == NOTIFY_LCE_STARTSHELL)
            {
            lpfnNotify = (LPFN_NOTIFICATION) GetProcAddress(hDLL, NOTIFY_LCE_LOGONUSER);
            }
        else
        if (dwEvent == NOTIFY_LCE_LOGOFF)
            {
            lpfnNotify = (LPFN_NOTIFICATION) GetProcAddress(hDLL, NOTIFY_LCE_LOGOFFUSER);
            }

        hr = (lpfnNotify == NULL) ? HRESULT_FROM_WIN32(GetLastError()) : (*lpfnNotify)(pTempInfo->hToken);

        FreeLibrary(hDLL);
        }

    return hr;
}




void
OnUserLogon(
    WLX_NOTIFICATION_INFO * User
    )
{
    DWORD status = 0;

    if (FALSE == gbIsTokenCodeInitialized)
        {
        return;
        }

    if (IsRemoteSession())
        {
        return;
        }

    if (!ImpersonateLoggedOnUser( User->hToken ))
        {
        return;
        }

    UserLoggedOn( g_hIrxfer, &status );

    RevertToSelf();
}




void
OnUserLogoff(
    WLX_NOTIFICATION_INFO * User
    )
{
    DWORD status;

    if (FALSE == gbIsTokenCodeInitialized)
        {
        return;
        }

    if (IsRemoteSession())
        {
        return;
        }

    if (!ImpersonateLoggedOnUser( User->hToken ))
        {
        return;
        }

    UserLoggedOff( g_hIrxfer, &status );

    RevertToSelf();
}

#define MAX_WINDOWSTATION_NAME_LENGTH 1000


DWORD
_SecpGetCurrentUserToken(
    handle_t      Binding,
    wchar_t       WindowStation[],
    unsigned long ProcessId,
    unsigned long * pToken,
    unsigned long DesiredAccess
    )
{
    HANDLE LocalToken;
    HANDLE RemoteToken;
    HANDLE RemoteProcess;

    if (FALSE == gbIsTokenCodeInitialized)
        {
        return ERROR_OUTOFMEMORY;
        }

    //
    // Validate arguments.  The only one that can cause us harm is the window station.
    //
    if (IsBadStringPtr( WindowStation, MAX_WINDOWSTATION_NAME_LENGTH))
        {
        return ERROR_ACCESS_DENIED;
        }

    //
    // Clone the token into the requested process.
    //
    LocalToken = ActiveUserList->CurrentUserTokenFromWindowStation( WindowStation );
    if (!LocalToken)
        {
        LogMessage((SENSLOGN "GetCurrentUserToken(): User not logged on!\n"));
        return ERROR_NOT_LOGGED_ON;
        }

    RemoteProcess = OpenProcess(
                        PROCESS_DUP_HANDLE,
                        FALSE,         // not inheritable
                        ProcessId
                        );
    if (!RemoteProcess)
        {
        LogMessage((SENSLOGN "GetCurrentUserToken(): OpenProcess() failed!\n"));
        return GetLastError();
        }

    if (!DuplicateHandle(
             GetCurrentProcess(),
             LocalToken,
             RemoteProcess,
             &RemoteToken,
             DesiredAccess,
             FALSE,                // not inheritable
             0                     // no funny options
             ))
        {
        LogMessage((SENSLOGN "GetCurrentUserToken(): DuplicateHandle() failed!\n"));
        CloseHandle( RemoteProcess );
        return GetLastError();
        }

    CloseHandle( RemoteProcess );
    *pToken = HandleToUlong(RemoteToken);

    LogMessage((SENSLOGN "GetCurrentUserToken(): Succeeded. Returning 0x%x.\n", *pToken));

    return ERROR_SUCCESS;
}




BOOL
USER_LOGON_TABLE::Add(
    WLX_NOTIFICATION_INFO * User
    )
{
    USER_INFO_NODE * Entry;

    if (FALSE == gbIsTokenCodeInitialized)
        {
        return FALSE;
        }

    CLAIM_MUTEX Lock( Mutex );

    Entry = FindInactiveEntry();
    if (!Entry)
        {
        Entry = new USER_INFO_NODE;
        if (!Entry)
            {
            return FALSE;
            }

        Entry->fActive = FALSE;

        InsertTailList( &List, &Entry->Links );
        }

    Entry->Info.Size   = sizeof(WLX_NOTIFICATION_INFO);
    Entry->Info.Flags  = User->Flags;
    Entry->Info.hToken = User->hToken;

    WCHAR * Buffer = new WCHAR[ 1+wcslen(User->UserName) +
                                1+wcslen(User->Domain)   +
                                1+wcslen(User->WindowStation) ];
    if (!Buffer)
        {
        Entry->Info.UserName      = 0;
        Entry->Info.Domain        = 0;
        Entry->Info.WindowStation = 0;

        return FALSE;
        }

    //
    // This must match the code in Remove().
    //
    Entry->Info.UserName      = Buffer;
    Entry->Info.Domain        = Entry->Info.UserName+1+wcslen(User->UserName);
    Entry->Info.WindowStation = Entry->Info.Domain  +1+wcslen(User->Domain);

    wcscpy(Entry->Info.UserName,      User->UserName);
    wcscpy(Entry->Info.Domain,        User->Domain);
    wcscpy(Entry->Info.WindowStation, User->WindowStation);

    Entry->fActive = TRUE;

    return TRUE;
}




BOOL
USER_LOGON_TABLE::Remove(
    WLX_NOTIFICATION_INFO * User
    )
{
    if (FALSE == gbIsTokenCodeInitialized)
        {
        return FALSE;
        }

    USER_INFO_NODE * Entry = FromWindowStation( User->WindowStation );

    if (Entry)
        {
        //
        // This must match the code in Add().
        //
        delete Entry->Info.UserName;

        Entry->fActive = FALSE;

        Mutex.Leave();
        return TRUE;
        }

    Mutex.Leave();
    return FALSE;
}




HANDLE
USER_LOGON_TABLE::CurrentUserTokenFromWindowStation(
    wchar_t WindowStation[]
    )
{
    HANDLE Token = NULL;
    USER_INFO_NODE * Node = FromWindowStation(WindowStation);

    if (Node)
        {
        Token = Node->Info.hToken;
        }

    Mutex.Leave();
    return Token;
}




USER_INFO_NODE *
USER_LOGON_TABLE::FromWindowStation(
    wchar_t WindowStation[]
    )
/*++

    Note that the mutex is held on exit, to avoid race conditions.

--*/
{
    USER_INFO_NODE * Node;
    LIST_ENTRY *     Link;

    Mutex.Enter();

    for (Link = List.Flink,  Node = CONTAINING_RECORD(Link, USER_INFO_NODE, Links);
         Link != &List;
         Link = Link->Flink, Node = CONTAINING_RECORD(Link, USER_INFO_NODE, Links))
        {
        if (Node->fActive && 0 == wcscmp(Node->Info.WindowStation, WindowStation))
            {
            return Node;
            }
        }

    return 0;
}




USER_INFO_NODE *
USER_LOGON_TABLE::FindInactiveEntry(
    void
    )
{
    USER_INFO_NODE * Node;
    LIST_ENTRY *     Link;

    for (Link = List.Flink,  Node = CONTAINING_RECORD(Link, USER_INFO_NODE, Links);
         Link != &List;
         Link = Link->Flink, Node = CONTAINING_RECORD(Link, USER_INFO_NODE, Links))
        {
        if (!Node->fActive)
            {
            return Node;
            }
        }

    return 0;
}




RPC_STATUS RPC_ENTRY
AllowLocalSystem (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    )
{
    if (RpcImpersonateClient(Context))
        {
        return ERROR_ACCESS_DENIED;
        }

    //
    // Clone the user's token so we can launch apps on the desktop.
    //
    HANDLE ImpersonationToken;

    if (!OpenThreadToken(
             GetCurrentThread(),
             TOKEN_QUERY,
             TRUE,                 // use process token for access check
             &ImpersonationToken
             ))
        {
        return GetLastError();
        }

    //
    // Get the SID from the token.
    //
    DWORD SizeNeeded = 0;
    TOKEN_USER * TokenData = NULL;

    // Get the size first.
    if (!GetTokenInformation(
             ImpersonationToken,
             TokenUser,
             0,
             0,
             &SizeNeeded
             ))
        {
        DWORD dwLastError = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER != dwLastError)
            {
            CloseHandle( ImpersonationToken );
            return dwLastError;
            }
        }

    __try
        {
        TokenData = (TOKEN_USER *) _alloca( SizeNeeded );
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
        // Nothing
        }

    if (!TokenData)
        {
        CloseHandle( ImpersonationToken );
        return ERROR_NOT_ENOUGH_MEMORY;
        }

    if (!GetTokenInformation(
             ImpersonationToken,
             TokenUser,
             TokenData,
             SizeNeeded,
             &SizeNeeded
             ))
        {
        CloseHandle( ImpersonationToken );
        return GetLastError();
        }

    CloseHandle(ImpersonationToken);

    if (!RtlEqualSid(
             TokenData->User.Sid,
             LocalSystemSid
             ))
        {
        return ERROR_ACCESS_DENIED;
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senslogn\stub_usertok_s.c ===
#include <usertok_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\cfacpwr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfacpwr.cxx

Abstract:

    Implements the Class Factory for the SENS ISensOnNow Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <sensevts.h>
#include "sinkcomn.hxx"
#include "cfacpwr.hxx"
#include "cimppwr.hxx"


//
// Global counts for the number of objects in the server and the number of
// locks.
//

extern ULONG g_cObj;
extern ULONG g_cLock;



//
// Constructor and Destructor
//
CISensOnNowCF::CISensOnNowCF(
    void
    ) : m_cRef(1L)
{

}

CISensOnNowCF::~CISensOnNowCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CISensOnNowCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CISensOnNowCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CISensOnNowCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CISensOnNowCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSONNOW pObjPower;
    HRESULT hr;

    DebugTraceGuid("CISensOnNowCF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjPower = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensOnNow) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensNetwork)\n"));
        pObjPower = new CImpISensOnNow(ObjectDestroyed);
        if (NULL != pObjPower)
            {
            hr = pObjPower->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensOnNow returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CISensOnNowCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\cfaclogn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfaclogn.cxx

Abstract:

    Implements the Class Factory for the SENS ISensLogon Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <sensevts.h>
#include "sinkcomn.hxx"
#include "cfaclogn.hxx"
#include "cimplogn.hxx"


//
// Global counts for the number of objects in the server and the number of
// locks.
//

extern ULONG g_cObj;
extern ULONG g_cLock;



//
// Constructor and Destructor
//
CISensLogonCF::CISensLogonCF(
    void
    ) : m_cRef(1L)
{

}

CISensLogonCF::~CISensLogonCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CISensLogonCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CISensLogonCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CISensLogonCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CISensLogonCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSLOGON pObjLogn;
    HRESULT hr;

    DebugTraceGuid("CISensLogonCF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjLogn = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensLogon) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensLogon)\n"));
        pObjLogn = new CImpISensLogon(ObjectDestroyed);
        if (NULL != pObjLogn)
            {
            hr = pObjLogn->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensLogon returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CISensLogonCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}


//
// Class Factory for ISensLogon2 implementation
//



//
// Constructor and Destructor
//
CISensLogon2CF::CISensLogon2CF(
    void
    ) : m_cRef(1L)
{

}

CISensLogon2CF::~CISensLogon2CF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CISensLogon2CF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CISensLogon2CF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CISensLogon2CF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CISensLogon2CF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSLOGON2 pObjLogn2;
    HRESULT hr;

    DebugTraceGuid("CISensLogon2CF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjLogn2 = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensLogon2) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensLogon2)\n"));
        pObjLogn2 = new CImpISensLogon2(ObjectDestroyed);
        if (NULL != pObjLogn2)
            {
            hr = pObjLogn2->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensLogon2 returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CISensLogon2CF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senslogn\logoncli\logoncli.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    logoncli.cxx

Abstract:

    This file contains code to trigger the Winlogon Events for SENS. This
    is a test DLL and these private SENS APIs should not be called directly.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/17/1998         Start.

--*/


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winwlx.h>
#include <sensapip.h>
#include "senslogn.hxx"



void
Usage(
    void
    )
{
    printf("\nUsage:    logoncli [Winlogon Event Number] \n\n");
    printf("Options:\n\n");
    printf("    WinlogonEventNumber  1 - Logon\n"
           "                         2 - Logoff\n"
           "                         3 - Startup\n"
           "                         4 - StartShell\n"
           "                         5 - Shutdown\n"
           "                         6 - Lock\n"
           "                         7 - Unlock\n"
           "                         8 - StartScreenSaver\n"
           "                         9 - StopScreenSaver\n"
           "\n\n");

    exit(-1);
}


int
main(
    int argc,
    char **argv
    )
{

    if (argc != 2)
        {
        Usage();
        }

    if ((atoi(argv[1]) < 1) ||
        (atoi(argv[1]) > 9))
        {
        Usage();
        }


    WLX_NOTIFICATION_INFO Info;

    Info.Size = 24;
    Info.Flags = 0x0;
    Info.UserName = L"JohnDoe";
    Info.Domain = L"REDMOND";
    Info.WindowStation = L"Default";
    Info.hToken = NULL;


    switch (atoi(argv[1]))
        {
        case 1:
            SensLogonEvent(&Info);
            break;

        case 2:
            SensLogoffEvent(&Info);
            break;

        case 3:
            SensStartupEvent(&Info);
            break;

        case 4:
            SensStartShellEvent(&Info);
            break;

        case 5:
            SensShutdownEvent(&Info);
            break;

        case 6:
            SensLockEvent(&Info);
            break;

        case 7:
            SensUnlockEvent(&Info);
            break;

        case 8:
            SensStartScreenSaverEvent(&Info);
            break;

        case 9:
            SensStopScreenSaverEvent(&Info);
            break;

        default:
            printf("Bad Event id!\n");
            break;
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\cimpnet.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cimpnet.cxx

Abstract:

    The core implementation for the ISensNetwork interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <oleauto.h>
#include <tchar.h>
#include "sinkcomn.hxx"
#include "sensevts.h"
#include "cimpnet.hxx"


extern ITypeInfo *gpITypeInfoNetwork;




//
// Constructors and Destructors
//
CImpISensNetwork::CImpISensNetwork(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensNetwork::CImpISensNetwork(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensNetwork::~CImpISensNetwork(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensNetwork::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensNetwork::QueryInterface()", riid);
    
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensNetwork
    if (IsEqualIID(riid, IID_ISensNetwork))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensNetwork::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensNetwork::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::Release(m_cRef = %d) called.\n"), m_cRef));

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//

STDMETHODIMP
CImpISensNetwork::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::GetTypeInfoCount() called.\n")));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensNetwork::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::GetTypeInfo() called.\n")));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfoNetwork->AddRef();

    *ppITypeInfo = gpITypeInfoNetwork;

    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::GetIDsOfNames() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoNetwork->GetIDsOfNames(
                                 arrNames,
                                 cNames,
                                 arrDispIDs
                                 );

    return hr;
}

STDMETHODIMP
CImpISensNetwork::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::Invoke() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoNetwork->Invoke(
                                (IDispatch*) this,
                                dispID,
                                wFlags,
                                pDispParams,
                                pvarResult,
                                pExecpInfo,
                                puArgErr
                                );
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetwork::Invoke() returned 0x%x\n"), hr));

    return hr;
}




//
// IDispatch member function implementations.
//

STDMETHODIMP
CImpISensNetwork::ConnectionMade(
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO lpQOCInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::ConnectionMade() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("         lpQOCInfo - 0x%x\n"), lpQOCInfo));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwSize     - 0x%x\n"), lpQOCInfo->dwSize));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwFlags    - 0x%x\n"), lpQOCInfo->dwFlags));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwInSpeed  - %d bits/sec.\n"), lpQOCInfo->dwInSpeed));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwOutSpeed - %d bits/sec.\n"), lpQOCInfo->dwOutSpeed));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::ConnectionMadeNoQOCInfo(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::ConnectionMadeNoQOCInfo() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::ConnectionLost(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::ConnectionLost() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::DestinationReachable(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO lpQOCInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::DestinationReachable() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrDestination - %s\n"), bstrDestination));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("         lpQOCInfo - 0x%x\n"), lpQOCInfo));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwSize     - 0x%x\n"), lpQOCInfo->dwSize));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwFlags    - 0x%x\n"), lpQOCInfo->dwFlags));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwInSpeed  - %d bits/sec.\n"), lpQOCInfo->dwInSpeed));
    SensPrint(SENS_INFO, (SENS_STRING("             o dwOutSpeed - %d bits/sec.\n"), lpQOCInfo->dwOutSpeed));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::DestinationReachableNoQOCInfo(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetwork::DestinationReachableNoQOCInfo() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrDestination - %s\n"), bstrDestination));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\cimppwr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cimppwr.cxx

Abstract:

    The core implementation for the ISensOnNow interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <oleauto.h>
#include <tchar.h>
#include "sinkcomn.hxx"
#include "cimppwr.hxx"
#include "sensevts.h"


extern ITypeInfo *gpITypeInfoLogon;




//
// Constructors and Destructors
//
CImpISensOnNow::CImpISensOnNow(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensOnNow::CImpISensOnNow(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensOnNow::~CImpISensOnNow(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensOnNow::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensOnNow::QueryInterface()", riid);
    
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensOnNow
    if (IsEqualIID(riid, IID_ISensOnNow))
        {
        *ppv = (ISensOnNow *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensOnNow::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensOnNow::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//




STDMETHODIMP
CImpISensOnNow::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::GetTypeInfoCount() called.\n")));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensOnNow::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::GetTypeInfo() called.\n")));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfoLogon->AddRef();

    *ppITypeInfo = gpITypeInfoLogon;

    return S_OK;
}

STDMETHODIMP
CImpISensOnNow::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::GetIDsOfNames() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );

    return hr;
}

STDMETHODIMP
CImpISensOnNow::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::Invoke() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon->Invoke(
                               (IDispatch*) this,
                               dispID,
                               wFlags,
                               pDispParams,
                               pvarResult,
                               pExecpInfo,
                               puArgErr
                               );
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensOnNow::Invoke() returned 0x%x\n"), hr));

    return hr;
}


STDMETHODIMP
CImpISensOnNow::OnACPower(
    void
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensOnNow::OnACPower() called\n")));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}


STDMETHODIMP
CImpISensOnNow::OnBatteryPower(
    DWORD dwBatteryLifePercent
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensOnNow::OnBatteryPower() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("    dwBatteryLifePercent - %d\n"), dwBatteryLifePercent));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensOnNow::BatteryLow(
    DWORD dwBatteryLifePercent
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensOnNow::BatteryLow() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("    dwBatteryLifePercent - %d\n"), dwBatteryLifePercent));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\cfacnet.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfacnet.cxx

Abstract:

    Implements the Class Factory for the SENS ISensNetwork Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <sensevts.h>
#include "sinkcomn.hxx"
#include "cfacnet.hxx"
#include "cimpnet.hxx"
#include "cimplogn.hxx"


//
// Global counts for the number of objects in the server and the number of
// locks.
//

extern DWORD  gTid;
extern HANDLE ghEvent;

ULONG g_cObj    = 0L;
ULONG g_cLock   = 0L;


//
// Constructor and Destructor
//
CISensNetworkCF::CISensNetworkCF(
    void
    ) : m_cRef(1L)
{

}

CISensNetworkCF::~CISensNetworkCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CISensNetworkCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CISensNetworkCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CISensNetworkCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CISensNetworkCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSNETWORK pObjNet;
    HRESULT hr;

    DebugTraceGuid("CISensNetworkCF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjNet = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensNetwork) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensNetwork)\n"));
        pObjNet = new CImpISensNetwork(ObjectDestroyed);
        if (NULL != pObjNet)
            {
            hr = pObjNet->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensNetwork returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CISensNetworkCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}



//
// ObjectDestroyed
//
void FAR PASCAL
ObjectDestroyed(
    void
    )
{
    BOOL bSuccess = FALSE;

    if ((0 == InterlockedDecrement((PLONG) &g_cObj)) &&
        (0 == g_cLock))
        {
        SensPrintA(SENS_INFO, ("\t| ObjectDestroyed: g_cObj = %d and g_cLock = %d\n", g_cObj, g_cLock));
        SensPrintA(SENS_INFO, ("\t| Shutting down the app. Calling SetEvent()\n"));

        Sleep(2000);
        SetEvent(ghEvent);

        /*
        SensPrintA(SENS_INFO, ("\t| Shutting down the app. Calling PostThreadMessage()\n"));

        bSuccess = PostThreadMessage(gTid, WM_QUIT, 0, 0);
        if (bSuccess == FALSE)
            {
            SensPrintA(SENS_ERR, ("\t| PostThreadMessage(Tid = %d) failed!\n"));
            }
        */
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\cimplogn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cimplogn.cxx

Abstract:

    The core implementation for the ISensLogon interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <oleauto.h>
#include <tchar.h>
#include "sinkcomn.hxx"
#include "cimplogn.hxx"
#include "sensevts.h"


extern ITypeInfo *gpITypeInfoLogon;
extern ITypeInfo *gpITypeInfoLogon2;




//
// Constructors and Destructors
//
CImpISensLogon::CImpISensLogon(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensLogon::CImpISensLogon(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensLogon::~CImpISensLogon(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensLogon::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensLogon::QueryInterface()", riid);

    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensLogon
    if (IsEqualIID(riid, IID_ISensLogon))
        {
        *ppv = (ISensLogon *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensLogon::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensLogon::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//




STDMETHODIMP
CImpISensLogon::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::GetTypeInfoCount() called.\n")));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensLogon::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::GetTypeInfo() called.\n")));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfoLogon->AddRef();

    *ppITypeInfo = gpITypeInfoLogon;

    return S_OK;
}

STDMETHODIMP
CImpISensLogon::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::GetIDsOfNames() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );

    return hr;
}

STDMETHODIMP
CImpISensLogon::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::Invoke() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon->Invoke(
                               (IDispatch*) this,
                               dispID,
                               wFlags,
                               pDispParams,
                               pvarResult,
                               pExecpInfo,
                               puArgErr
                               );
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon::Invoke() returned 0x%x\n"), hr));

    return hr;
}


STDMETHODIMP
CImpISensLogon::Logon(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::Logon() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}


STDMETHODIMP
CImpISensLogon::Logoff(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::Logoff() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::StartShell(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::StartShell() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::DisplayLock(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::DisplayLock() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::DisplayUnlock(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::DisplayUnlock() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::StartScreenSaver(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::StartScreenSaver() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon::StopScreenSaver(
    BSTR bstrUserName
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon::StopScreenSaver() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}



//
// ISensLogon2 Implementation
//



//
// Constructors and Destructors
//
CImpISensLogon2::CImpISensLogon2(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensLogon2::CImpISensLogon2(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensLogon2::~CImpISensLogon2(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensLogon2::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensLogon2::QueryInterface()", riid);

    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensLogon
    if (IsEqualIID(riid, IID_ISensLogon2))
        {
        *ppv = (ISensLogon2 *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensLogon2::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensLogon2::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//




STDMETHODIMP
CImpISensLogon2::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::GetTypeInfoCount() called.\n")));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensLogon2::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::GetTypeInfo() called.\n")));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfoLogon2->AddRef();

    *ppITypeInfo = gpITypeInfoLogon2;

    return S_OK;
}

STDMETHODIMP
CImpISensLogon2::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::GetIDsOfNames() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon2->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );

    return hr;
}

STDMETHODIMP
CImpISensLogon2::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::Invoke() called.\n")));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfoLogon2->Invoke(
                               (IDispatch*) this,
                               dispID,
                               wFlags,
                               pDispParams,
                               pvarResult,
                               pExecpInfo,
                               puArgErr
                               );
    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensLogon2::Invoke() returned 0x%x\n"), hr));

    return hr;
}


STDMETHODIMP
CImpISensLogon2::Logon(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::Logon() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}


STDMETHODIMP
CImpISensLogon2::Logoff(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::Logoff() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon2::PostShell(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::PostShell() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon2::SessionDisconnect(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::SessionDisconnect() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}

STDMETHODIMP
CImpISensLogon2::SessionReconnect(
    BSTR bstrUserName,
    DWORD dwSessionId
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensLogon2::SessionReconnect() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrUserName - %s\n"), bstrUserName));
    SensPrint(SENS_INFO, (SENS_STRING("    dwSessionId - %d\n"), dwSessionId));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\cimpsens.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cimpsens.cxx

Abstract:

    The core implementation for the ISensNetwork interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/



#include <common.hxx>
#include <ole2.h>
#include <oleauto.h>
#include "sinkcomn.hxx"
#include "cimpsens.hxx"
#include "sensevts.h"


extern ITypeInfo *gpITypeInfo;




//
// Constructors and Destructors
//
CImpISensNetwork::CImpISensNetwork(
    void
    ) : m_cRef(0L), m_pfnDestroy(NULL)
{

}

CImpISensNetwork::CImpISensNetwork(
    LPFNDESTROYED pfnDestroy
    ) : m_cRef(0L), m_pfnDestroy(pfnDestroy)
{

}

CImpISensNetwork::~CImpISensNetwork(
    void
    )
{
    // Empty destructor
}



//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensNetwork::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    DebugTraceGuid("CImpISensNetwork::QueryInterface()", riid);
    
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IDispatch
    if (IsEqualIID(riid, IID_IDispatch))
        {
        *ppv = (IDispatch *) this;
        }
    else
    // ISensNetwork
    if (IsEqualIID(riid, IID_ISensNetwork))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensNetwork::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensNetwork::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        if (NULL != m_pfnDestroy)
            {
            (*m_pfnDestroy)();
            }
        delete this;
        }

    return cRefT;
}



//
// IDispatch member function implementations.
//




STDMETHODIMP
CImpISensNetwork::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    SensPrintA(SENS_INFO, ("\t| CImpISensNetwork::GetTypeInfoCount() called.\n"));
    // We implement GetTypeInfo, so return 1.
    *pCountITypeInfo = 1;

    return NOERROR;

}


STDMETHODIMP
CImpISensNetwork::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    SensPrintA(SENS_INFO, ("\t| CImpISensNetwork::GetTypeInfo() called.\n"));
    *ppITypeInfo = NULL;

    if (iTypeInfo != 0)
        {
        return DISP_E_BADINDEX;
        }

    // Call AddRef and return the pointer.
    gpITypeInfo->AddRef();

    *ppITypeInfo = gpITypeInfo;

    return S_OK;
}

STDMETHODIMP
CImpISensNetwork::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    HRESULT hr;

    SensPrintA(SENS_INFO, ("\t| CImpISensNetwork::GetIDsOfNames() called.\n"));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfo->GetIDsOfNames(
                          arrNames,
                          cNames,
                          arrDispIDs
                          );

    return hr;
}

STDMETHODIMP
CImpISensNetwork::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    HRESULT hr;

    SensPrintA(SENS_INFO, ("\t| CImpISensNetwork::Invoke() called.\n"));

    if (riid != IID_NULL)
        {
        return DISP_E_UNKNOWNINTERFACE;
        }

    hr = gpITypeInfo->Invoke(
                          (IDispatch*) this,
                          dispID,
                          wFlags,
                          pDispParams,
                          pvarResult,
                          pExecpInfo,
                          puArgErr
                          );

    return hr;
}

STDMETHODIMP_(void)
CImpISensNetwork::ConnectionMade(
    BSTR bstrConnection,
    ULONG ulType,
    SENS_QOCINFO QOCInfo
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::ConnectionMade() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("           QOCInfo - 0x%x\n", QOCInfo));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::ConnectionMadeNoQOCInfo(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::ConnectionMadeNoQOCInfo() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::ConnectionLost(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::ConnectionLost() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::BeforeDisconnect(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::BeforeDisconnect() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::DestinationReachable(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType,
    SENS_QOCINFO QOCInfo
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::DestinationReachable() called\n\n"));
    SensPrintW(SENS_INFO, (L"   bstrDestination - %s\n", bstrDestination));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("           QOCInfo - 0x%x\n", QOCInfo));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::DestinationReachableNoQOCInfo(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::DestinationReachableNoQOCInfo() called\n\n"));
    SensPrintW(SENS_INFO, (L"   bstrDestination - %s\n", bstrDestination));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("            ulType - 0x%x\n", ulType));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}

STDMETHODIMP_(void)
CImpISensNetwork::FooFunc(
    BSTR bstrConnection
    )
{
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
    SensPrintA(SENS_INFO, ("CImpISensNetwork::FooFunc() called\n\n"));
    SensPrintW(SENS_INFO, (L"    bstrConnection - %s\n", bstrConnection));
    SensPrintA(SENS_INFO, ("---------------------------------------------------------\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\senssink.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senssink.cxx

Abstract:

    Main entry point for the Sample SENS Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/



// Define this once and only once per exe.
#define INITGUIDS

#include <common.hxx>
#include <objbase.h>
#include <windows.h>
#include <ole2ver.h>
#include <initguid.h>
#include <eventsys.h>
#include <sensevts.h>
#include <sens.h>
#include "sinkcomn.hxx"
#include "sinkguid.hxx"
#include "senssink.hxx"
#include "cfacnet.hxx"
#include "cfaclogn.hxx"
#include "cfacpwr.hxx"


#if defined(SENS_NT4)
#define SENS_TLB        SENS_BSTR("SENS.EXE")
#else  // SENS_NT4
#define SENS_TLB        SENS_BSTR("SENS.DLL")
#endif // SENS_NT4

#define SUBSCRIBER      SENS_STRING("SENS_SUBSCRIBER: ")
#define MAX_QUERY_SIZE  512
#define MAJOR_VER       1
#define MINOR_VER       0
#define DEFAULT_LCID    0x0


//
// Globals
//
IEventSystem    *gpIEventSystem;
ITypeInfo       *gpITypeInfoNetwork;
ITypeInfo       *gpITypeInfoLogon;
ITypeInfo       *gpITypeInfoLogon2;
ITypeInfo       *gpITypeInfoOnNow;
DWORD           gTid;
HANDLE          ghEvent;


#if defined(SENS_CHICAGO)

#ifdef DBG
DWORD           gdwDebugOutputLevel;
#endif // DBG

#endif // SENS_CHICAGO



int __cdecl
main(
    int argc,
    char ** argv
    )
{
    HRESULT hr;
    DWORD   dwVer;
    DWORD   dwRegCO;
    DWORD   dwWaitStatus;
    BOOL    fInitialized;
    BOOL    bUnregister;
    BOOL    bSetupPhase;
    MSG     msg;
    LPCLASSFACTORY pNetCF;
    LPCLASSFACTORY pLogonCF;
    LPCLASSFACTORY pLogon2CF;
    LPCLASSFACTORY pPowerCF;
    ITypeLib *pITypeLib;

    hr = S_OK;
    dwRegCO = 0x0;
    bUnregister = FALSE;
    bSetupPhase = FALSE;
    fInitialized = FALSE;
    pNetCF = NULL;
    pLogonCF = NULL;
    pLogon2CF = NULL;
    pPowerCF = NULL;
    gpIEventSystem = NULL;
    pITypeLib = NULL;
    gpITypeInfoNetwork = NULL;
    gpITypeInfoLogon = NULL;
    gpITypeInfoLogon2 = NULL;
    gpITypeInfoOnNow = NULL;

    dwVer = CoBuildVersion();
    if (rmm != HIWORD(dwVer))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoBuildVersion() returned incompatible version.\n")));
        return -1;
        }

    if (FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoInitializeEx() returned 0x%x.\n"), hr));
        goto Cleanup;
        }
    fInitialized = TRUE;

    //
    // Check the command-line args
    //
    if (   ((argc == 2) && ((argv[1][0] != '-') && (argv[1][0] != '/')))
        || (argc > 2))
        {
        Usage();
        return (-1);
        }

    if (argc == 2)
        {
        switch (argv[1][1])
            {
            case 'i':
            case 'I':
                bSetupPhase = TRUE;
                bUnregister = FALSE;
                break;

            case 'u':
            case 'U':
                bSetupPhase = TRUE;
                bUnregister = TRUE;
                break;

            case 'e':
            case 'E':
                // SCM calls me with /Embedding flag
                break;

            default:
                Usage();
                return (-1);
            }
        }

    if (bSetupPhase == TRUE)
        {
        hr = RegisterWithES(bUnregister);
        if (FAILED(hr))
            {
            goto Cleanup;
            }

        // Network Subscriber
        hr = RegisterSubscriberCLSID(
                 CLSID_SensTestSubscriberNetwork,
                 TEST_SUBSCRIBER_NAME_NETWORK,
                 bUnregister
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister Test Subscriber Network CLSID")
                      SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
            }
        else
            {
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered Test Subscriber Network CLSID.\n"),
                      bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));
            }

        // Logon Subscriber
        hr = RegisterSubscriberCLSID(
                 CLSID_SensTestSubscriberLogon,
                 TEST_SUBSCRIBER_NAME_LOGON,
                 bUnregister
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister Test Subscriber Logon CLSID")
                      SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
            }
        else
            {
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered Test Subscriber Logon CLSID.\n"),
                      bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));
            }

        // Logon2 Subscriber
        hr = RegisterSubscriberCLSID(
                 CLSID_SensTestSubscriberLogon2,
                 TEST_SUBSCRIBER_NAME_LOGON2,
                 bUnregister
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister Test Subscriber Logon2 CLSID")
                      SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
            }
        else
            {
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered Test Subscriber Logon2 CLSID.\n"),
                      bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));
            }

        // Power Subscriber
        hr = RegisterSubscriberCLSID(
                 CLSID_SensTestSubscriberOnNow,
                 TEST_SUBSCRIBER_NAME_POWER,
                 bUnregister
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister Test Subscriber Power CLSID")
                      SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
            }
        else
            {
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered Test Subscriber Power CLSID.\n"),
                      bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));
            }
        goto Cleanup;
        }


    //
    // Get the ITypeInfo pointer.
    //
    hr = LoadRegTypeLib(
             LIBID_SensEvents,
             MAJOR_VER,
             MINOR_VER,
             DEFAULT_LCID,
             &pITypeLib
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("LoadRegTypeLib() returned 0x%x\n"), hr));

    if (FAILED(hr))
        {
        hr = LoadTypeLib(
                 SENS_TLB,
                 &pITypeLib
                 );
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("LoadTypeLib() returned 0x%x\n"), hr));

        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
            goto Cleanup;
            }
        }

    // Get type information for the ISensNetwork interface.
    hr = pITypeLib->GetTypeInfoOfGuid(
             IID_ISensNetwork,
             &gpITypeInfoNetwork
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ITypeLib::GetTypeInfoOfGuid(ISensNetwork) returned 0x%x\n"), hr));
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
        goto Cleanup;
        }

    // Get type information for the ISensLogon interface.
    hr = pITypeLib->GetTypeInfoOfGuid(
             IID_ISensLogon,
             &gpITypeInfoLogon
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ITypeLib::GetTypeInfoOfGuid(ISensLogon) returned 0x%x\n"), hr));
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
        goto Cleanup;
        }

    // Get type information for the ISensLogon2 interface.
    hr = pITypeLib->GetTypeInfoOfGuid(
             IID_ISensLogon2,
             &gpITypeInfoLogon2
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ITypeLib::GetTypeInfoOfGuid(ISensLogon2) returned 0x%x\n"), hr));
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
        goto Cleanup;
        }

    // Get type information for the ISensOnNow interface.
    hr = pITypeLib->GetTypeInfoOfGuid(
             IID_ISensOnNow,
             &gpITypeInfoOnNow
             );
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ITypeLib::GetTypeInfoOfGuid(ISensOnNow) returned 0x%x\n"), hr));
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Exiting...\n")));
        goto Cleanup;
        }

    //
    // Create the event
    //
    ghEvent = CreateEvent(
                  NULL,  // Security Attributes
                  FALSE, // bManualReset
                  FALSE, // Initial state
                  SENS_STRING("SENS Test Subscriber Quit Event")
                  );
    if (ghEvent == NULL)
        {
        SensPrint(SENS_ERR, (SUBSCRIBER  SENS_STRING("CreateEvent() failed.\n")));
        goto Cleanup;
        }

    //
    // Create the Network ClassFactory and register it with COM.
    //

    pNetCF = new CISensNetworkCF;
    if (NULL == pNetCF)
        {
        goto Cleanup;
        }
    pNetCF->AddRef(); // Because we hold on to it.
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ClassFactory created successfully.\n")));

    // Register the CLSID
    hr = CoRegisterClassObject(
             CLSID_SensTestSubscriberNetwork,
             (LPUNKNOWN) pNetCF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &dwRegCO
             );

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoRegisterClassObject(Network) returned 0x%x.\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully registered the ISensNetwork Class Factory.\n")));
        }

    //
    // Create the Logon ClassFactory and register it with COM.
    //

    pLogonCF = new CISensLogonCF;
    if (NULL == pLogonCF)
        {
        goto Cleanup;
        }
    pLogonCF->AddRef(); // Because we hold on to it.
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ClassFactory created successfully.\n")));

    hr = CoRegisterClassObject(
             CLSID_SensTestSubscriberLogon,
             (LPUNKNOWN) pLogonCF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &dwRegCO
             );

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoRegisterClassObject(Logon) returned 0x%x.\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully registered the ISensLogon Class Factory.\n")));
        }

    //
    // Create the Logon2 ClassFactory and register it with COM.
    //

    pLogon2CF = new CISensLogon2CF;
    if (NULL == pLogon2CF)
        {
        goto Cleanup;
        }
    pLogon2CF->AddRef(); // Because we hold on to it.
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ClassFactory created successfully.\n")));

    hr = CoRegisterClassObject(
             CLSID_SensTestSubscriberLogon2,
             (LPUNKNOWN) pLogon2CF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &dwRegCO
             );

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoRegisterClassObject(Logon2) returned 0x%x.\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully registered the ISensLogon2 Class Factory.\n")));
        }

    //
    // Create the Power ClassFactory and register it with COM.
    //

    pPowerCF = new CISensOnNowCF;
    if (NULL == pPowerCF)
        {
        goto Cleanup;
        }
    pPowerCF->AddRef(); // Because we hold on to it.
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("ClassFactory created successfully.\n")));

    hr = CoRegisterClassObject(
             CLSID_SensTestSubscriberOnNow,
             (LPUNKNOWN) pPowerCF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &dwRegCO
             );

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("CoRegisterClassObject(Power) returned 0x%x.\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully registered the ISensOnNow Class Factory.\n")));
        }

    //
    // Wait to quit.
    //
    dwWaitStatus = WaitForSingleObject(ghEvent, INFINITE);
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("WaitForSingleObject returned %d\n"), dwWaitStatus));


//
// Cleanup
//
Cleanup:

    if (   (0L != dwRegCO)
        && (bSetupPhase == TRUE)
        && (bUnregister == TRUE))
        {
        CoRevokeClassObject(dwRegCO);
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("CoRevokeClassObject() returned 0x%x.\n"), hr));
        }

    if (bSetupPhase == TRUE)
        {
        SensPrint(SENS_INFO, (SENS_STRING("\n") SUBSCRIBER SENS_STRING("Sens Test Subscriber Configuration %s.\n"),
                  FAILED(hr) ? SENS_STRING("failed") : SENS_STRING("successful")));
        }

    if (NULL != pNetCF)
        {
        pNetCF->Release();
        }
    if (NULL != pLogonCF)
        {
        pLogonCF->Release();
        }
    if (NULL != pLogon2CF)
        {
        pLogon2CF->Release();
        }
    if (NULL != pPowerCF)
        {
        pPowerCF->Release();
        }
    if (NULL != pITypeLib)
        {
        pITypeLib->Release();
        }
    if (NULL != gpITypeInfoNetwork)
        {
        gpITypeInfoNetwork->Release();
        }
    if (NULL != gpITypeInfoLogon)
        {
        gpITypeInfoLogon->Release();
        }
    if (NULL != gpITypeInfoLogon2)
        {
        gpITypeInfoLogon2->Release();
        }
    if (NULL != gpITypeInfoOnNow)
        {
        gpITypeInfoOnNow->Release();
        }

    if (fInitialized)
        {
        CoUninitialize();
        }

    return 0;
}


HRESULT
RegisterWithES(
    BOOL bUnregister
    )
{
    HRESULT      hr;

    hr = S_OK;

    //
    // Instantiate the Event System
    //
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &gpIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to create CEventSystem, HRESULT=%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Successfully created CEventSystem\n")));

#if 0
    //
    // Test to see if we can get the MachineName
    //
    BSTR bstrMachineName;

    hr = gpIEventQuery->get_MachineName(&bstrMachineName);

    if (SUCCEEDED(hr))
        SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("Configuring Test Subscriber on %s...\n"), bstrMachineName));
    else
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("get_MachineName failed, hr = %x\n"), hr));
#endif // 0

    //
    // Register my Subscriber's subscriptions with SENS.
    //
    hr = RegisterSubscriptions(bUnregister);
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("Failed to %sregister SensSink Subscriptions")
                  SENS_STRING(" - hr = <%x>\n"), bUnregister ? SENS_STRING("un") : SENS_STRING(""), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("%segistered SensSink Subscriptions.\n"),
              bUnregister ? SENS_STRING("Unr") : SENS_STRING("R")));

Cleanup:
    //
    // Cleanup
    //
    if (gpIEventSystem)
        {
        gpIEventSystem->Release();
        }

    return hr;
}



HRESULT
RegisterSubscriptions(
    BOOL bUnregister
    )
{
    int                 i;
    int                 errorIndex;
    HRESULT             hr;
    LPOLESTR            strGuid;
    LPOLESTR            strSubscriptionID;
    WCHAR               szQuery[MAX_QUERY_SIZE];
    BSTR                bstrEventClassID;
    BSTR                bstrInterfaceID;
    BSTR                bstrSubscriberCLSID;
    BSTR                bstrPublisherID;
    BSTR                bstrSubscriptionID;
    BSTR                bstrSubscriptionName;
    BSTR                bstrMethodName;
    BSTR                bstrPropertyName;
    BSTR                bstrPropertyValue;
    ULONG               ulPropertyValue;
    VARIANT             variantPropertyValue;
    BSTR                bstrPROGID_EventSubscription;
    IEventSubscription  *pIEventSubscription;

    hr = S_OK;
    strGuid = NULL;
    errorIndex = 0;
    strSubscriptionID = NULL;
    bstrEventClassID = NULL;
    bstrInterfaceID = NULL;
    bstrSubscriberCLSID = NULL;
    bstrPublisherID = NULL;
    bstrSubscriptionID = NULL;
    bstrSubscriptionName = NULL;
    bstrMethodName = NULL;
    bstrPropertyName = NULL;
    bstrPropertyValue = NULL;
    ulPropertyValue = 0x0;
    bstrPROGID_EventSubscription = NULL;
    pIEventSubscription = NULL;

    //
    // Build a Subscriber
    //
    AllocateBstrFromGuid(bstrPublisherID, SENSGUID_PUBLISHER);
    AllocateBstrFromString(bstrPROGID_EventSubscription, PROGID_EventSubscription);

    for (i = 0; i < TEST_SUBSCRIPTIONS_COUNT; i++)
        {
        if (bUnregister)
            {
            // Form the query
            wcscpy(szQuery,  SENS_BSTR("SubscriptionID"));
            wcscat(szQuery,  SENS_BSTR("="));
            AllocateStrFromGuid(strSubscriptionID, *(gTestSubscriptions[i].pSubscriptionID));
            wcscat(szQuery,  strSubscriptionID);

            hr = gpIEventSystem->Remove(
                                     PROGID_EventSubscription,
                                     szQuery,
                                     &errorIndex
                                     );
            FreeStr(strSubscriptionID);

            if (FAILED(hr))
                {
                SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("RegisterSubscriptions(%d) failed to unregister")
                          SENS_STRING(" - hr = <%x>\n"), i, hr));
                goto Cleanup;
                }

            continue;
            }

        // Get a new IEventSubscription object to play with.
        hr = CoCreateInstance(
                 CLSID_CEventSubscription,
                 NULL,
                 CLSCTX_SERVER,
                 IID_IEventSubscription,
                 (LPVOID *) &pIEventSubscription
                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("RegisterSubscriptions(%d) failed to create ")
                      SENS_STRING("IEventSubscriptions - hr = <%x>\n"), i, hr));
            goto Cleanup;
            }

        AllocateBstrFromGuid(bstrSubscriptionID, *(gTestSubscriptions[i].pSubscriptionID));
        hr = pIEventSubscription->put_SubscriptionID(bstrSubscriptionID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrSubscriberCLSID, *(gTestSubscriptions[i].pSubscriberCLSID));
        hr = pIEventSubscription->put_SubscriberCLSID(bstrSubscriberCLSID);
        ASSERT(SUCCEEDED(hr));

        hr = pIEventSubscription->put_PublisherID(bstrPublisherID);
        ASSERT(SUCCEEDED(hr));

        hr = pIEventSubscription->put_SubscriptionID(bstrSubscriptionID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrSubscriptionName, gTestSubscriptions[i].strSubscriptionName);
        hr = pIEventSubscription->put_SubscriptionName(bstrSubscriptionName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrMethodName, gTestSubscriptions[i].strMethodName);
        hr = pIEventSubscription->put_MethodName(bstrMethodName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrEventClassID, *(gTestSubscriptions[i].pEventClassID));
        hr = pIEventSubscription->put_EventClassID(bstrEventClassID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrInterfaceID, *(gTestSubscriptions[i].pInterfaceID));
        hr = pIEventSubscription->put_InterfaceID(bstrInterfaceID);
        ASSERT(SUCCEEDED(hr));

        if (wcscmp(gTestSubscriptions[i].strMethodName, SENS_BSTR("ConnectionMadeNoQOCInfo")) == 0)
            {
            AllocateBstrFromString(bstrPropertyName, SENS_BSTR("ulConnectionMadeTypeNoQOC"));
            ulPropertyValue = CONNECTION_LAN;
            InitializeDwordVariant(&variantPropertyValue, ulPropertyValue);
            hr = pIEventSubscription->PutPublisherProperty(
                                          bstrPropertyName,
                                          &variantPropertyValue
                                          );
            ASSERT(SUCCEEDED(hr));
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("PutPublisherProperty(WAN/LAN) returned 0x%x\n"), hr));
            FreeBstr(bstrPropertyName);
            ulPropertyValue = 0x0;
            }
        else
        if (   (wcscmp(gTestSubscriptions[i].strMethodName, SENS_BSTR("DestinationReachable")) == 0)
            || (wcscmp(gTestSubscriptions[i].strMethodName, SENS_BSTR("DestinationReachableNoQOCInfo")) == 0))
            {
            // Set the DestinationName for which we want to be notified for.
            AllocateBstrFromString(bstrPropertyName, gTestSubscriptions[i].strPropertyMethodName);
            AllocateBstrFromString(bstrPropertyValue, gTestSubscriptions[i].strPropertyMethodNameValue);
            InitializeBstrVariant(&variantPropertyValue, bstrPropertyValue);
            hr = pIEventSubscription->PutPublisherProperty(
                                          bstrPropertyName,
                                          &variantPropertyValue
                                          );
            ASSERT(SUCCEEDED(hr));
            SensPrint(SENS_INFO, (SUBSCRIBER SENS_STRING("PutPublisherProperty(DestinationName) returned 0x%x\n"), hr));
            FreeBstr(bstrPropertyName);
            FreeBstr(bstrPropertyValue);
            }

        FreeBstr(bstrSubscriptionID);
        FreeBstr(bstrSubscriberCLSID);
        FreeBstr(bstrEventClassID);
        FreeBstr(bstrInterfaceID);
        FreeBstr(bstrSubscriptionName);
        FreeBstr(bstrMethodName);

        hr = gpIEventSystem->Store(bstrPROGID_EventSubscription, pIEventSubscription);
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SUBSCRIBER SENS_STRING("RegisterSubscriptions(%d) failed to commit")
                      SENS_STRING(" - hr = <%x>\n"), i, hr));
            goto Cleanup;
            }

        pIEventSubscription->Release();

        pIEventSubscription = NULL;
        } // for loop

Cleanup:
    //
    // Cleanup
    //
    if (pIEventSubscription)
        {
        pIEventSubscription->Release();
        }

    FreeBstr(bstrPublisherID);
    FreeBstr(bstrSubscriberCLSID);
    FreeStr(strGuid);

    return (hr);
}




HRESULT
RegisterSubscriberCLSID(
    REFIID clsid,
    TCHAR* strSubscriberName,
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister the CLSID of the Test subscriber.

Arguments:

    clsid - CLSID of the Subscriber.

    strSubscriberName - Name of the Subscriber.

    bUnregister - If TRUE, then unregister all subscriptions of SENS Test subscriber.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    HMODULE hModule;
    HKEY appidKey = 0;
    HKEY clsidKey = 0;
    HKEY serverKey = 0;
    TCHAR szModule[MAX_PATH+1];
    WCHAR *szCLSID = 0;
    WCHAR *szLIBID = 0;
    TCHAR *szCLSID_t = 0;
    TCHAR *szLIBID_t = 0;
    TCHAR *szFriendlyName = strSubscriberName;

    hr = S_OK;

    // Convert the CLSID into a TCHAR.
    hr = StringFromCLSID(clsid, &szCLSID);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    if (bUnregister == FALSE)
        {
        hr = StringFromCLSID(LIBID_SensEvents, &szLIBID);
        if (FAILED(hr))
            {
            goto Cleanup;
            }

        hModule = GetModuleHandle(0);

        // Get Subscriber location.
        const size_t moduleBufSize = sizeof szModule / sizeof szModule[0];
        DWORD dwResult = GetModuleFileName(hModule, szModule, moduleBufSize);
        if (dwResult == 0)
            {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto Cleanup;
            }
        }

    //
    // Convert UNICODE strings into ANSI, if necessary
    //
#if !defined(SENS_CHICAGO)

    szCLSID_t = szCLSID;
    szLIBID_t = szLIBID;

#else // SENS_CHICAGO

    szCLSID_t = SensUnicodeStringToAnsi(szCLSID);
    szLIBID_t = SensUnicodeStringToAnsi(szLIBID);
    if (   (NULL == szCLSID_t)
        || (NULL == szLIBID_t))
        {
        goto Cleanup;
        }

#endif // SENS_CHICAGO


    // Build the key CLSID\\{clsid}
    TCHAR clsidKeyName[sizeof "CLSID\\{12345678-1234-1234-1234-123456789012}"];

    _tcscpy(clsidKeyName, SENS_STRING("CLSID\\"));
    _tcscat(clsidKeyName, szCLSID_t);

    // Build the key AppID\\{clsid}
    TCHAR appidKeyName[sizeof "AppID\\{12345678-1234-1234-1234-123456789012}"];
    _tcscpy(appidKeyName, SENS_STRING("AppID\\"));
    _tcscat(appidKeyName, szCLSID_t);

    if (bUnregister)
        {
        hr = RecursiveDeleteKey(HKEY_CLASSES_ROOT, clsidKeyName);
        if (FAILED(hr))
            {
            goto Cleanup;
            }

        hr = RecursiveDeleteKey(HKEY_CLASSES_ROOT, appidKeyName);

        goto Cleanup;
        }

    // Create the CLSID\\{clsid} key
    hr = CreateKey(
             HKEY_CLASSES_ROOT,
             clsidKeyName,
             szFriendlyName,
             &clsidKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Under the CLSID\\{clsid} key, create a named value
    //          AppID = {clsid}
    hr = CreateNamedValue(clsidKey, SENS_STRING("AppID"), szCLSID_t);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Create the appropriate server key beneath the clsid key.
    // For servers, this is CLSID\\{clsid}\\LocalServer32.
    // In both cases, the default value is the module path name.
    //
    hr = CreateKey(
             clsidKey,
             SENS_STRING("LocalServer32"),
             szModule,
             &serverKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }
    RegCloseKey(serverKey);

    //
    // Create CLSID\\{clsid}\\TypeLib subkey with a default value of
    // the LIBID of the TypeLib
    //
    hr = CreateKey(
             clsidKey,
             SENS_STRING("TypeLib"),
             szLIBID_t,
             &serverKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }
    RegCloseKey(serverKey);


    // We're finished with the CLSID\\{clsid} key
    RegCloseKey(clsidKey);

    // Register APPID.
    hr = CreateKey(
             HKEY_CLASSES_ROOT,
             appidKeyName,
             szFriendlyName,
             &appidKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    // Under AppId\{clsid} key, create a named value [RunAs = "Interactive User"]
    hr = CreateNamedValue(appidKey, SENS_STRING("RunAs"), SENS_STRING("Interactive User"));
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    RegCloseKey(appidKey);


Cleanup:
    //
    // Cleanup
    //
    CoTaskMemFree(szCLSID);
    CoTaskMemFree(szLIBID);

#if defined(SENS_CHICAGO)

    if (szCLSID_t != NULL)
        {
        delete szCLSID_t;
        }
    if (szLIBID_t != NULL)
        {
        delete szLIBID_t;
        }

#endif // SENS_CHICAGO

    return hr;
}




HRESULT
CreateKey(
    HKEY hParentKey,
    const TCHAR* KeyName,
    const TCHAR* defaultValue,
    HKEY* hKey
    )
/*++

Routine Description:

    Create a key (with an optional default value).  The handle to the key is
    returned as an [out] parameter.  If NULL is passed as the key parameter,
    the key is created in the registry, then closed.

Arguments:

    hParentKey - Handle to the parent Key.

    KeyName - Name of the key to create.

    defaultValue - The default value for the key to create.

    hKey - OUT Handle to key that was created.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HKEY hTempKey;
    LONG lResult;

    hTempKey = NULL;

    lResult = RegCreateKeyEx(
                  hParentKey,               // Handle to open key
                  KeyName,                  // Subkey name
                  0,                        // Reserved
                  NULL,                     // Class string
                  REG_OPTION_NON_VOLATILE,  // Options Flag
                  KEY_ALL_ACCESS,           // Desired Security access
                  NULL,                     // Pointer to Security Attributes structure
                  &hTempKey,                // Handle of the opened/created key
                  NULL                      // Disposition value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32(lResult);
        }

    // Set the default value for the key
    if (defaultValue != NULL)
        {
        lResult = RegSetValueEx(
                      hTempKey,             // Key to set Value for.
                      NULL,                 // Value to set
                      0,                    // Reserved
                      REG_SZ,               // Value Type
                      (BYTE*) defaultValue, // Address of Value data
                      sizeof(TCHAR) * (_tcslen(defaultValue)+1) // Size of Value
                      );

        if (lResult != ERROR_SUCCESS)
            {
            RegCloseKey(hTempKey);
            return HRESULT_FROM_WIN32(lResult);
            }
        }

    if (hKey == NULL)
        {
        RegCloseKey(hTempKey);
        }
    else
        {
        *hKey = hTempKey;
        }

    return S_OK;
}




HRESULT
CreateNamedValue(
    HKEY hKey,
    const TCHAR* title,
    const TCHAR* value
    )
/*++

Routine Description:

    Create a named value under a key

Arguments:

    hKey - Handle to the parent Key.

    title - Name of the Value to create.

    value - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    LONG lResult;

    hr = S_OK;

    lResult = RegSetValueEx(
                  hKey,             // Key to set Value for.
                  title,            // Value to set
                  0,                // Reserved
                  REG_SZ,           // Value Type
                  (BYTE*) value,    // Address of Value data
                  sizeof(TCHAR) * (_tcslen(value)+1) // Size of Value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        hr = HRESULT_FROM_WIN32(lResult);
        }

    return hr;
}




HRESULT
RecursiveDeleteKey(
    HKEY hKeyParent,
    const TCHAR* lpszKeyChild
    )
/*++

Routine Description:

    Delete a key and all of its descendents.

Arguments:

    hKeyParent - Handle to the parent Key.

    lpszKeyChild - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HKEY hKeyChild;
    LONG lResult;

    //
    // Open the child.
    //
    lResult = RegOpenKeyEx(
                  hKeyParent,       // Handle to the Parent
                  lpszKeyChild,     // Name of the child key
                  0,                // Reserved
                  KEY_ALL_ACCESS,   // Security Access Mask
                  &hKeyChild        // Handle to the opened key
                  );

    if (lResult != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32(lResult);
        }

    //
    // Enumerate all of the decendents of this child.
    //
    FILETIME time;
    TCHAR szBuffer[MAX_PATH+1];
    const DWORD bufSize = sizeof szBuffer / sizeof szBuffer[0];
    DWORD dwSize = bufSize;

    while (TRUE)
        {
        lResult = RegEnumKeyEx(
                      hKeyChild,    // Handle of the key to enumerate
                      0,            // Index of the subkey to retrieve
                      szBuffer,     // OUT Name of the subkey
                      &dwSize,      // OUT Size of the buffer for name of subkey
                      NULL,         // Reserved
                      NULL,         // OUT Class of the enumerated subkey
                      NULL,         // OUT Size of the class of the subkey
                      &time         // OUT Last time the subkey was written to
                      );

        if (lResult != ERROR_SUCCESS)
            {
            break;
            }

        // Delete the decendents of this child.
        lResult = RecursiveDeleteKey(hKeyChild, szBuffer);
        if (lResult != ERROR_SUCCESS)
            {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild);
            return HRESULT_FROM_WIN32(lResult);
            }

        dwSize = bufSize;
        } // while

    // Close the child.
    RegCloseKey(hKeyChild);

    // Delete this child.
    lResult = RegDeleteKey(hKeyParent, lpszKeyChild);

    return HRESULT_FROM_WIN32(lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\classfac.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    classfac.cxx

Abstract:

    Implements the Class Factory for the SENS Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/


#include <common.hxx>
#include <ole2.h>
#include <sensevts.h>
#include "sinkcomn.hxx"
#include "classfac.hxx"
#include "cimpnet.hxx"
#include "cimplogn.hxx"


//
// Global counts for the number of objects in the server and the number of
// locks.
//

ULONG g_cObj    = 0L;
ULONG g_cLock   = 0L;



//
// Constructor and Destructor
//
CSensSinkCF::CSensSinkCF(
    void
    ) : m_cRef(1L)
{

}

CSensSinkCF::~CSensSinkCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CSensSinkCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CSensSinkCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CSensSinkCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        ObjectDestroyed();
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CSensSinkCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPISENSNETWORK pObjNet;
    LPCIMPISENSLOGON pObjLogn;
    HRESULT hr;

    DebugTraceGuid("CSensSinkCF::CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjNet = NULL;
    pObjLogn = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_ISensNetwork) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensNetwork)\n"));
        pObjNet = new CImpISensNetwork(ObjectDestroyed);
        if (NULL != pObjNet)
            {
            hr = pObjNet->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensNetwork returned 0x%x\n", hr));
            }
        }
    else
    if (IsEqualIID(riid, IID_ISensLogon))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(ISensLogon)\n"));
        pObjLogn = new CImpISensLogon(ObjectDestroyed);
        if (NULL != pObjLogn)
            {
            hr = pObjLogn->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpISensLogon returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CSensSinkCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cLock);

        InterlockedIncrement((PLONG) &g_cObj);
        ObjectDestroyed(); // this does a --g_cObj
        }

    return NOERROR;
}



//
// ObjectDestroyed
//
void FAR PASCAL
ObjectDestroyed(
    void
    )
{
    if ((0 == InterlockedDecrement((PLONG) &g_cObj)) &&
        (0 == g_cLock))
        {
        SensPrintA(SENS_INFO, ("\t| ObjectDestroyed: g_cObj = %d and g_cLock = %d\n", g_cObj, g_cLock));
        SensPrintA(SENS_INFO, ("\t| Shutting down the app. Calling PostQuitMessage(0)\n"));

        PostQuitMessage(0);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\cfacchng.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfacchng.cxx

Abstract:

    Implements the Class Factory for the SENS IEventObjectChange Subscriber.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/17/1997         Start.

--*/

#include <precomp.hxx>


//
// Global counts for the number of objects in the server and the number of
// locks.
//

ULONG g_cCFObj    = 0L;
ULONG g_cCFLock   = 0L;


//
// Constructor and Destructor
//
CIEventObjectChangeCF::CIEventObjectChangeCF(
    void
    ) : m_cRef(1L)
{

}

CIEventObjectChangeCF::~CIEventObjectChangeCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CIEventObjectChangeCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CIEventObjectChangeCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CIEventObjectChangeCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CIEventObjectChangeCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPIEVENTOBJECTCHANGE pObjChange;
    HRESULT hr;

    DebugTraceGuid("CIEventObjectChangeCF:CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjChange = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_IEventObjectChange) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(IEventObjectChange)\n"));
        pObjChange = new CImpIEventObjectChange();
        if (NULL != pObjChange)
            {
            hr = pObjChange->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpIEventObjectChange returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cCFObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CIEventObjectChangeCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cCFLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cCFLock);

        InterlockedIncrement((PLONG) &g_cCFObj);
        }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssink\subcli\subcli.cxx ===
/*++

Copyright (C) 1997-998 Microsoft Corporation

Module Name:

    subcli.cxx

Abstract:

    Code to test the COM/OleAutomation aspect of the Test Subscriber for
    SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/17/1998         Start.

--*/


#include <stdio.h>
#include <ole2.h>
#include <oleauto.h>
#include <initguid.h>
#include <sens.h>
#include <sensevts.h>
#include "sinkguid.hxx"


#define SENS_SERVICE    L"SENS.DLL"
#define MAJOR_VER       1
#define MINOR_VER       0
#define DEFAULT_LCID    0x0


int
main(
    int argc,
    char **argv
    )
{
    HRESULT hr = S_OK;
    IDispatch *pIDispatchNetwork = NULL;
    IDispatch *pIDispatchLogon = NULL;
    ISensNetwork *pISensNetwork = NULL;
    ISensNetwork *pISensLogon = NULL;
    ITypeLib *pITypeLib = NULL;
    ITypeInfo *pITypeInfo = NULL;
    IRecordInfo * pIRecordInfo = NULL;

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    printf("CoInitializeEx() returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }


    DISPID dispIDNetwork;
    DISPID dispIDLogon;
    OLECHAR *name;

    printf("--------------------------------------------------------------\n");
    hr = CoCreateInstance(
             CLSID_SensTestSubscriberNetwork,
             NULL,
             CLSCTX_LOCAL_SERVER,
             IID_IDispatch,
             (LPVOID *) &pIDispatchNetwork
             );

    printf("CoCreateInstance(IDispatchNetwork) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    hr = CoCreateInstance(
             CLSID_SensTestSubscriberNetwork,
             NULL,
             CLSCTX_LOCAL_SERVER,
             IID_ISensNetwork,
             (LPVOID *) &pISensNetwork
             );

    printf("CoCreateInstance(ISensNetwork) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    /*
    printf("Calling pISensNetwork->ConnectionMade()\n");
    pISensNetwork->ConnectionMade(
              SysAllocString(L"A dummy Connection Name"),
              0x1234,
              NULL
              );
    printf("Calling pISensNetwork->ConnectionMade() - DONE.\n");
    */

    name = L"FooFunc";
    hr = pIDispatchNetwork->GetIDsOfNames(
                                IID_NULL,
                                &name,
                                1,
                                GetUserDefaultLCID(),
                                &dispIDNetwork
                                );
    printf("GetIDsOfNames(FooFunc) returned 0x%x, dispID = %d\n",
           hr, dispIDNetwork);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Call Invoke on a function with 1 argument.
    //
    BSTR bstrTemp;
    VARIANTARG varg;

    bstrTemp = SysAllocString(L"A Dummy Connection Name");
    VariantInit(&varg);
    varg.vt = VT_BSTR;
    varg.bstrVal = bstrTemp;

    // Fill in the DISPPARAMS structure.
    DISPPARAMS param;
    param.cArgs = 1;
    param.rgvarg = &varg;
    param.cNamedArgs = 0;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatchNetwork->Invoke(
                                dispIDNetwork,
                                IID_NULL,
                                GetUserDefaultLCID(),
                                DISPATCH_METHOD,
                                &param,
                                NULL,
                                NULL,
                                NULL
                                );
    printf("Invoke(FooFunc) returned 0x%x\n", hr);
    SysFreeString(bstrTemp);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    printf("--------------------------------------------------------------\n");
    name = L"ConnectionMadeNoQOCInfo";
    hr = pIDispatchNetwork->GetIDsOfNames(
                                IID_NULL,
                                &name,
                                1,
                                GetUserDefaultLCID(),
                                &dispIDNetwork
                                );
    printf("GetIDsOfNames(ConnectionMadeNoQOCInfo) returned 0x%x, dispID = %d\n",
           hr, dispIDNetwork);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Call Invoke on a function with 2 arguments (parameters in reverse order).
    //
    VARIANTARG vargarr[2];

    bstrTemp = SysAllocString(L"A Dummy Connection Name");
    VariantInit(&vargarr[1]);
    vargarr[1].vt = VT_BSTR;
    vargarr[1].bstrVal = bstrTemp;

    VariantInit(&vargarr[0]);
    vargarr[0].vt = VT_UI4;
    vargarr[0].ulVal = 0x00000001;

    // Fill in the DISPPARAMS structure.
    param.cArgs = 2;
    param.rgvarg = vargarr;
    param.cNamedArgs = 0;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatchNetwork->Invoke(
                                dispIDNetwork,
                                IID_NULL,
                                GetUserDefaultLCID(),
                                DISPATCH_METHOD,
                                &param,
                                NULL,
                                NULL,
                                NULL
                                );
    printf("Invoke(ConnectionMadeNoQOCInfo) returned 0x%x\n", hr);
    SysFreeString(bstrTemp);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    printf("--------------------------------------------------------------\n");
    hr = CoCreateInstance(
             CLSID_SensTestSubscriberLogon,
             NULL,
             CLSCTX_LOCAL_SERVER,
             IID_IDispatch,
             (LPVOID *) &pIDispatchLogon
             );

    printf("CoCreateInstance(IDispatchLogon) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    hr = CoCreateInstance(
             CLSID_SensTestSubscriberLogon,
             NULL,
             CLSCTX_LOCAL_SERVER,
             IID_ISensLogon,
             (LPVOID *) &pISensLogon
             );

    printf("CoCreateInstance(ISensLogon) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }


    name = L"Logon";
    hr = pIDispatchLogon->GetIDsOfNames(
                              IID_NULL,
                              &name,
                              1,
                              GetUserDefaultLCID(),
                              &dispIDLogon
                              );
    printf("GetIDsOfNames(Logon) returned 0x%x, dispID = %d\n",
           hr, dispIDLogon);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Call Invoke on a function with 1 argument.
    //
    bstrTemp = SysAllocString(L"REDMOND\\JohnDoe");
    VariantInit(&varg);
    varg.vt = VT_BSTR;
    varg.bstrVal = bstrTemp;

    // Fill in the DISPPARAMS structure.
    param.cArgs = 1;
    param.rgvarg = &varg;
    param.cNamedArgs = 0;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatchLogon->Invoke(
                             dispIDLogon,
                             IID_NULL,
                             GetUserDefaultLCID(),
                             DISPATCH_METHOD,
                             &param,
                             NULL,
                             NULL,
                             NULL
                             );
    printf("Invoke(Logon) returned 0x%x\n", hr);
    SysFreeString(bstrTemp);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    printf("--------------------------------------------------------------\n");

    //
    // Call Invoke with multiple arguments and UDT
    //

    name = L"ConnectionMade";
    hr = pIDispatchNetwork->GetIDsOfNames(
                                IID_NULL,
                                &name,
                                1,
                                GetUserDefaultLCID(),
                                &dispIDNetwork
                                );
    printf("GetIDsOfNames(ConnectionMade) returned 0x%x, dispID = %d\n",
           hr, dispIDNetwork);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    // Get the ITypeInfo pointer.
    hr = LoadRegTypeLib(
             LIBID_SensEvents,
             MAJOR_VER,
             MINOR_VER,
             DEFAULT_LCID,
             &pITypeLib
             );
    printf("LoadRegTypeLib returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        hr = LoadTypeLib(
                 SENS_SERVICE,
                 &pITypeLib
                 );
        printf("LoadTypeLib() returned 0x%x\n", hr);
        if (FAILED(hr))
            {
            goto Cleanup;
            }
        }

    hr = pITypeLib->GetTypeInfo(0, &pITypeInfo);
    printf("GetTypeInfo returned 0x%x - (pITypeInfo = 0x%x)\n", hr, pITypeInfo);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    hr = GetRecordInfoFromTypeInfo(pITypeInfo, &pIRecordInfo);
    printf("GetRecordInfoFromTypeInfo returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    VARIANTARG arrvarg[3];
    SENS_QOCINFO QOCInfo;

    //
    // Parameters are filled in the reverse order.
    //
    VariantInit(&arrvarg[2]);
    arrvarg[2].vt = VT_BSTR;
    arrvarg[2].bstrVal = SysAllocString(L"A dummy connection name");

    VariantInit(&arrvarg[1]);
    arrvarg[1].vt = VT_UI4;
    arrvarg[1].ulVal = 0x1234abcd;

    // Setup QOCInfo.
    QOCInfo.ulSize = sizeof(SENS_QOCINFO);
    QOCInfo.ulFlags = 0x00000003;
    QOCInfo.ulInSpeed = 33600;
    QOCInfo.ulOutSpeed = 33600;

    VariantInit(&arrvarg[0]);
    arrvarg[0].vt = VT_RECORD | VT_BYREF;
    arrvarg[0].pRecInfo = pIRecordInfo;
    arrvarg[0].pvRecord = &QOCInfo;

    // Fill in the DISPPARAMS structure.
    param.cArgs = 3;
    param.rgvarg = arrvarg;
    param.cNamedArgs = 0;
    param.rgdispidNamedArgs = NULL;

    hr = pIDispatchNetwork->Invoke(
                                dispIDNetwork,
                                IID_NULL,
                                GetUserDefaultLCID(),
                                DISPATCH_METHOD,
                                &param,
                                NULL,
                                NULL,
                                NULL
                                );
    printf("Invoke(ConnectionMade) returned 0x%x\n", hr);
    if (FAILED(hr))
        {
        goto Cleanup;
        }


//
// Cleanup stuff
//
Cleanup:

    if (pIDispatchNetwork)
        {
        pIDispatchNetwork->Release();
        }

    if (pIDispatchLogon)
        {
        pIDispatchLogon->Release();
        }

    if (pISensNetwork)
        {
        pISensNetwork->Release();
        }

    if (pISensLogon)
        {
        pISensLogon->Release();
        }

    if (pITypeLib)
        {
        pITypeLib->Release();
        }

    if (pITypeInfo)
        {
        pITypeInfo->Release();
        }

    CoUninitialize();

    printf("--------------------------------------------------------------\n");

    return (SUCCEEDED(hr) ? 0 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\cfaccmd.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cfacchng.cxx

Abstract:

    Implements the Class Factory for the IOleCommandTarget implementation
    in SENS.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    This can be merged with the Class Factory implementation in cfacchng.?xx

Revision History:

    GopalP          11/17/1997         Start.

--*/

#include <precomp.hxx>


//
// Global counts for the number of objects in the server and the number of
// locks.
//

ULONG g_cCmdCFObj    = 0L;
ULONG g_cCmdCFLock   = 0L;


//
// Constructor and Destructor
//
CIOleCommandTargetCF::CIOleCommandTargetCF(
    void
    ) : m_cRef(1L)
{

}

CIOleCommandTargetCF::~CIOleCommandTargetCF(
    void
    )
{
    // Empty Destructor.
}



//
// QI
//
STDMETHODIMP
CIOleCommandTargetCF::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr = S_OK;

    *ppv = NULL; // To handle failure cases

    // IUnknown or IClassFactory
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}



//
// AddRef
//
STDMETHODIMP_(ULONG)
CIOleCommandTargetCF::AddRef(
    void
    )
{
    return InterlockedIncrement((PLONG) &m_cRef);
}


//
// Release
//
STDMETHODIMP_(ULONG)
CIOleCommandTargetCF::Release(
    void
    )
{
    ULONG cRefT;

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        // Invoke the callback function.
        delete this;
        }

    return cRefT;
}



//
// CreateInstance
//
STDMETHODIMP
CIOleCommandTargetCF::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID *ppvObj
    )
{
    LPCIMPIOLECOMMANDTARGET  pObjCommand;
    HRESULT hr;

    DebugTraceGuid("CIOleCommandTargetCF:CreateInstance()", riid);

    hr = E_OUTOFMEMORY;
    *ppvObj = NULL;
    pObjCommand = NULL;

    //
    // Return the appropriate interface pointer.
    //
    if (IsEqualIID(riid, IID_IOleCommandTarget) ||
        IsEqualIID(riid, IID_IUnknown))
        {
        SensPrintA(SENS_INFO, ("\t| ClassFactory::CreateInstance(IOleCommandTarget)\n"));
        pObjCommand = new CImpIOleCommandTarget();
        if (NULL != pObjCommand)
            {
            hr = pObjCommand->QueryInterface(riid, ppvObj);
            SensPrintA(SENS_INFO, ("\t| QI on CImpIOleCommandTarget returned 0x%x\n", hr));
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppvObj)
        {
        InterlockedIncrement((PLONG) &g_cCmdCFObj);
        }

    SensPrintA(SENS_INFO, ("\t| Returning 0x%x from CF:CreateInstance\n", hr));

    return hr;
}



//
// LockServer
//
STDMETHODIMP
CIOleCommandTargetCF::LockServer(
    BOOL fLock
    )
{
    if (fLock)
        {
        InterlockedIncrement((PLONG) &g_cCmdCFLock);
        }
    else
        {
        InterlockedDecrement((PLONG) &g_cCmdCFLock);

        InterlockedIncrement((PLONG) &g_cCmdCFObj);
        }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\cenumsub.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cenumsub.cxx

Abstract:

    This file contains the implementation of the IEnumEventObject
    interface. This is used in implementing SENS publisher-side filtering.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/26/1998         Start.

--*/



#include <precomp.hxx>



//
// Globals
//
LONG g_cEnumSubObj;    // Count of active components
LONG g_cEnumSubLock;   // Count of Server locks




//
// Constructors and Destructors
//
CImpIEnumSub::CImpIEnumSub(
    void
    ) : m_cRef(1L), // Add a reference.
        m_FiredEvent(EVENT_INVALID),
        m_ulConnectionMadeType(0x0),
        m_ulConnectionMadeTypeNoQOC(0x0),
        m_ulConnectionLostType(0x0),
        m_bstrDestination(NULL),
        m_bstrDestinationNoQOC(NULL),
        m_ulDestinationType(0x0),
        m_ulDestinationTypeNoQOC(0x0)
{
    InterlockedIncrement(&g_cEnumSubObj);
}

CImpIEnumSub::~CImpIEnumSub(
    void
    )
{
    if (m_bstrDestination != NULL)
        {
        ::SysFreeString(m_bstrDestination);
        }

    if (m_bstrDestinationNoQOC != NULL)
        {
        ::SysFreeString(m_bstrDestinationNoQOC);
        }

    InterlockedDecrement(&g_cEnumSubObj);
}




//
// Standard QueryInterface
//
STDMETHODIMP
CImpIEnumSub::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr;

    DebugTraceGuid("CImpIEnumSub:QueryInterface()", riid);

    hr = S_OK;
    *ppv = NULL;

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (LPUNKNOWN) this;
        }
    else
    // IEnumEventObject
    if (IsEqualIID(riid, IID_IEnumEventObject))
        {
        *ppv = (IEnumEventObject *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}




//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpIEnumSub::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CImpIEnumSub::Release(
    void
    )
{
    LONG cRefT;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpIEnumSub::Release(m_cRef = %d) called.\n"), m_cRef));

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        delete this;
        }

    return cRefT;
}




//
// IDispatch member function implementations. These are dummy implementations
// as EventSystem never calls them.
//

STDMETHODIMP
CImpIEnumSub::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    return E_NOTIMPL;

}

STDMETHODIMP
CImpIEnumSub::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImpIEnumSub::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImpIEnumSub::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    return E_NOTIMPL;
}





//
// IEnumEventObject Implementation.
//

STDMETHODIMP
CImpIEnumSub::Clone(
    LPUNKNOWN *ppIUnknown
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImpIEnumSub::Count(
    ULONG *pcAvailableElem
    )
{
    HRESULT hr;
    USHORT  i;
    ULONG   cRequestCount;
    ULONG   cReturnCount;
    BSTR    bstrPropertyValue;
    BSTR    bstrPropertyDestination;
    BSTR    bstrPropertyType;
    ULONG   cPubCacheSubs;
    IEventSubscription  *pIEventSubscription;

    hr = S_OK;
    bstrPropertyValue = NULL;
    bstrPropertyDestination = NULL;
    bstrPropertyType = NULL;
    pIEventSubscription = NULL;
    *pcAvailableElem = 0;

    //
    // First, count ALL of subscriptions from PubCache.
    //
    hr = m_pIEnumSubs->Count(&cPubCacheSubs);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    *pcAvailableElem = cPubCacheSubs;

Cleanup:
    //
    // Cleanup
    //

    return hr;
}



STDMETHODIMP
CImpIEnumSub::Next(
    ULONG cRequestElem,
    LPUNKNOWN *ppIEventSubscription,
    ULONG *pcReturnElem
    )
{
    HRESULT hr;
    ULONG   cPubCacheSubs;
    ULONG   cCount;
    ULONG   ulCompareType;
    WCHAR   szCompareType[10];  // To fit a stringized DWORD
    BOOL    bPropertyPresent;
    BSTR    bstrCompareDest;
    BSTR    bstrPropertyDestination;
    BSTR    bstrPropertyType;
    BSTR    bstrPropertyValue;
    VARIANT variantPropertyValue;
    IEventSubscription *pIEventSubscription;

    hr = S_OK;
    *pcReturnElem = 0;
    cCount = 1;
    ulCompareType = 0x0;
    bstrCompareDest = NULL;
    bstrPropertyDestination = NULL;
    bstrPropertyType = NULL;
    bstrPropertyValue = NULL;
    pIEventSubscription = NULL;

    switch (m_FiredEvent)
        {
        case EVENT_CONNECTION_MADE:
            bstrPropertyType = ::SysAllocString(PROPERTY_CONNECTION_MADE_TYPE);
            if (bstrPropertyType == NULL)
                {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
                }
            ulCompareType = m_ulConnectionMadeType;
            break;

        case EVENT_CONNECTION_MADE_NOQOC:
            bstrPropertyType = ::SysAllocString(PROPERTY_CONNECTION_MADE_NOQOC_TYPE);
            if (bstrPropertyType == NULL)
                {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
                }
            ulCompareType = m_ulConnectionMadeTypeNoQOC;
            break;

        case EVENT_CONNECTION_LOST:
            bstrPropertyType = ::SysAllocString(PROPERTY_CONNECTION_LOST_TYPE);
            if (bstrPropertyType == NULL)
                {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
                }
            ulCompareType = m_ulConnectionLostType;
            break;

        case EVENT_DESTINATION_REACHABLE:
            bstrPropertyDestination = ::SysAllocString(PROPERTY_DESTINATION);
            bstrPropertyType = ::SysAllocString(PROPERTY_DESTINATION_TYPE);
            if (   (bstrPropertyDestination == NULL)
                || (bstrPropertyType == NULL))
                {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
                }
            bstrCompareDest = m_bstrDestination;
            ulCompareType = m_ulDestinationTypeNoQOC;
            break;

        case EVENT_DESTINATION_REACHABLE_NOQOC:
            bstrPropertyDestination = ::SysAllocString(PROPERTY_DESTINATION_NOQOC);
            bstrPropertyType = ::SysAllocString(PROPERTY_DESTINATION_NOQOC_TYPE);
            if (   (bstrPropertyDestination == NULL)
                || (bstrPropertyType == NULL))
                {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
                }
            bstrCompareDest = m_bstrDestinationNoQOC;
            ulCompareType = m_ulDestinationTypeNoQOC;
            break;

        case EVENT_INVALID:
        default:
            hr = E_UNEXPECTED;
            goto Cleanup;
        } // switch

    for (;;)
        {
        bPropertyPresent = TRUE;

        hr = m_pIEnumSubs->Next(
                               cCount,
                               (LPUNKNOWN *)&pIEventSubscription,
                               &cCount
                               );
        if (hr != S_OK)
            {
            // Return S_FALSE to cause EventSystem loop to stop
            hr = S_FALSE;
            goto Cleanup;
            }

        switch (m_FiredEvent)
            {
            case EVENT_CONNECTION_MADE:
            case EVENT_CONNECTION_MADE_NOQOC:
            case EVENT_CONNECTION_LOST:
                VariantInit(&variantPropertyValue);
                hr = pIEventSubscription->GetPublisherProperty(
                                              bstrPropertyType,
                                              &variantPropertyValue
                                              );
                if (hr != S_OK)
                    {
                    // We consider this a successful match.
                    SensPrint(SENS_INFO, (SENS_STRING("\t| Subscription::GetPublisherProperty() returned 0x%x\n"), hr));
                    bPropertyPresent = FALSE;
                    }
                else
                    {
                    ASSERT(variantPropertyValue.vt == VT_UI4);
                    SensPrintW(SENS_INFO, (SENS_BSTR("\t| Property %s has value 0x%x\n"), bstrPropertyType, variantPropertyValue.ulVal));
                    }

                //
                // Compare ulType here and pass back if they match
                //
                if (   (bPropertyPresent == TRUE)
                    && (variantPropertyValue.ulVal != ulCompareType))
                    {
                    SensPrintW(SENS_INFO, (SENS_BSTR("\t| Subscription::PropertyValue was 0x%x!\n"), ulCompareType));
                    break; // skip to next subscription
                    }

                goto FoundMatchingSubscription;

                break;

            case EVENT_DESTINATION_REACHABLE:
            case EVENT_DESTINATION_REACHABLE_NOQOC:
                //
                // Compare Destination Name here and pass back if they match
                //
                VariantInit(&variantPropertyValue);
                hr = pIEventSubscription->GetPublisherProperty(
                                              bstrPropertyDestination,
                                              &variantPropertyValue
                                              );
                if (hr != S_OK)
                    {
                    // We consider this a successful match.
                    SensPrint(SENS_INFO, (SENS_STRING("\t| Subscription::GetPublisherProperty() returned 0x%x\n"), hr));
                    bPropertyPresent = FALSE;
                    }
                else
                    {
                    ASSERT(variantPropertyValue.vt == VT_BSTR);
                    bstrPropertyValue = variantPropertyValue.bstrVal;
                    SensPrintW(SENS_INFO, (SENS_BSTR("\t| Property %s has value %s\n"), bstrPropertyDestination, bstrPropertyValue));
                    }

                if (   (bPropertyPresent == TRUE)
                    && (wcscmp(bstrPropertyValue, bstrCompareDest) != 0))
                    {
                    SensPrintW(SENS_INFO, (SENS_BSTR("\t| Subscription::PropertyValue was %s!\n"), bstrCompareDest));
                    break; // skip to next subscription
                    }

                //
                // Compare ulType here and pass back if they match
                //
                FreeVariant(&variantPropertyValue);
                VariantInit(&variantPropertyValue);

                bPropertyPresent = TRUE;
                hr = pIEventSubscription->GetPublisherProperty(
                                              bstrPropertyType,
                                              &variantPropertyValue
                                              );
                if (hr != S_OK)
                    {
                    // We consider this a successful match.
                    SensPrint(SENS_INFO, (SENS_STRING("\t| Subscription::GetPublisherProperty() returned 0x%x\n"), hr));
                    bPropertyPresent = FALSE;
                    }
                else
                    {
                    ASSERT(variantPropertyValue.vt == VT_UI4);
                    SensPrint(SENS_INFO, (SENS_STRING("\t| Property %s has value 0x%x\n"), bstrPropertyType, variantPropertyValue.ulVal));
                    }

                if (   (bPropertyPresent == TRUE)
                    && (variantPropertyValue.ulVal == ulCompareType))
                    {
                    SensPrintW(SENS_INFO, (SENS_BSTR("\t| Subscription::PropertyValue was %s!\n"), szCompareType));
                    break; // skip to next subscription
                    }

                goto FoundMatchingSubscription;

                break;

            case EVENT_INVALID:
            default:
                hr = E_UNEXPECTED;
                goto Cleanup;

            } // end of switch


ContinueToNextSubscription:

        FreeVariant(&variantPropertyValue);

        pIEventSubscription->Release();
        } // for loop

        // Didn't find a matching subscription.
        goto Cleanup;

FoundMatchingSubscription:

    FreeVariant(&variantPropertyValue);

    *ppIEventSubscription = pIEventSubscription;
    *pcReturnElem = 1;
    hr = S_OK;


Cleanup:
    //
    // Cleanup
    //
    if (bstrPropertyDestination)
        {
        SysFreeString(bstrPropertyDestination);
        }
    if (bstrPropertyType)
        {
        SysFreeString(bstrPropertyType);
        }

    return hr;
}

STDMETHODIMP
CImpIEnumSub::Reset(
    )
{
    return (m_pIEnumSubs->Reset());
}

STDMETHODIMP
CImpIEnumSub::Skip(
    ULONG cSkipElements
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\apiproc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    apiproc.cxx

Abstract:

    This file contains the implementations of all the RPC Server
    Manager routines exported by SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include <precomp.hxx>
#include <notify.h>



error_status_t
RPC_IsNetworkAlive(
    IN  handle_t hRpc,
    OUT LPDWORD lpdwFlags,
    OUT LPBOOL lpbAlive,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Get the current Network State that is maintained by this service.
    If either WAN or LAN connectivity is not present, we try to re-evaluate
    and update the state, if possible.

Arguments:

    hRpc - The RPC Binding handle.

    lpdwFlags - The flags indicating which type of network connectivity is
        present. The possible values are
            NETWORK_ALIVE_WAN
            NETWORK_ALIVE_LAN

    lpbAlive - Boolean indicating whether the network is alive or not.

    lpdwLastError - The out parameter that holds the error code returned
        from GetLastError() when there is no network connectivity.

Return Value:

    RPC_S_OK, normally.

    RPC Error, if there is an RPC-related problem.

--*/
{
    DWORD dwNow;
    DWORD fNetNature;
    BOOL bNetAlive;
    BOOL bLanAlive;
    BOOL bWanAlive;
    DWORD dwWanLastError;
    DWORD dwLanLastError;
    DWORD dwNetState;

    //
    // Some basic argument checks
    //
    if (NULL == lpdwLastError)
        {
        return RPC_S_INVALID_ARG;
        }

    if (   (NULL == lpdwFlags)
        || (NULL == lpbAlive))
        {
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }


    *lpdwFlags = 0x0;
    *lpbAlive = FALSE;
    *lpdwLastError = ERROR_SUCCESS;

    dwNow = GetTickCount();
    fNetNature = 0x0;
    dwNetState = 0;
    bLanAlive = FALSE;
    bWanAlive = FALSE;
    bNetAlive = FALSE;

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    SensPrintA(SENS_INFO, ("RPC_IsNetworkAlive() - Current Statistics"
               "\n\tLAN State (%s), LAN (%d sec),"
               "\n\tWAN State (%s) WAN Time (%d sec)\n",
               gdwLANState ? "TRUE" : "FALSE",
               (dwNow - gdwLastLANTime)/1000,
               gdwWANState ? "TRUE" : "FALSE",
               (dwNow - gdwLastWANTime)/1000)
               );

#if defined(AOL_PLATFORM)
    SensPrintA(SENS_INFO, (""
               "\n\tAOL State (%s) AOL Time (%d sec)\n",
               gdwAOLState ? "TRUE" : "FALSE",
               (dwNow - gdwLastWANTime)/1000));
#endif // AOL_PLATFORM


    //
    // First, get information about the WAN
    //
    if ((dwNow - gdwLastWANTime) > MAX_WAN_INTERVAL)
        {
        SensPrintA(SENS_INFO, ("WAN State information expired. Trying again.\n"));

        // WAN state is stale, refresh it.
        bWanAlive = EvaluateWanConnectivity(&dwWanLastError);

        if (bWanAlive)
            {
            fNetNature |= NETWORK_ALIVE_WAN;
            bNetAlive = TRUE;
            }
        else
            {
            *lpdwLastError = MapLastError(dwWanLastError);
            }
        }
    else
        {
        // Return the WAN state.
        if (gdwWANState)
            {
            fNetNature |= NETWORK_ALIVE_WAN;
            bNetAlive = TRUE;
            bWanAlive = TRUE;
            }
        }

#if defined(AOL_PLATFORM)
    if (bWanAlive && gdwAOLState)
        {
        fNetNature |= NETWORK_ALIVE_AOL;
        }
#endif // AOL_PLATFORM

    //
    // If we can determine both types of connectivity at this stage, return.
    //
    if (   ((dwNow - gdwLastLANTime) <= MAX_LAN_INTERVAL)
        && (gdwLANState == TRUE))
        {
        fNetNature |= NETWORK_ALIVE_LAN;
        bNetAlive = TRUE;

        *lpdwFlags = fNetNature;
        *lpbAlive = bNetAlive;
        *lpdwLastError = ERROR_SUCCESS;

        SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

        return (RPC_S_OK);
        }

    //
    // One of the following is TRUE at this stage.
    //
    // a. Information about LAN is stale.
    // b. Information about LAN is current but there is no LAN connectivity.
    //    So, we go and check for it again.
    //

    if (gdwLANState == FALSE)
        {
        SensPrintA(SENS_INFO, ("LAN State either stale or there is no connectivity. Trying again.\n"));
        }
    else
        {
        SensPrintA(SENS_INFO, ("LAN State information expired. Trying again.\n"));
        }

    bLanAlive = EvaluateLanConnectivity(&dwLanLastError);
    if (bLanAlive)
        {
        fNetNature |= NETWORK_ALIVE_LAN;
        bNetAlive = TRUE;
        }
    else
        {
        *lpdwLastError = MapLastError(dwLanLastError);
        }

    *lpdwFlags = fNetNature;
    *lpbAlive = bNetAlive;

    if (bNetAlive)
        {
        *lpdwLastError = ERROR_SUCCESS;
        }

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    return (RPC_S_OK);
}




error_status_t
RPC_IsDestinationReachableW(
    IN handle_t h,
    IN wchar_t * lpszDestination,
    IN OUT LPQOCINFO lpQOCInfo,
    OUT LPBOOL lpbReachable,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Check to see if the given destination is reachable. If so, return Quality
    Of Connection (QOC) information, if necessary.

Arguments:

    hRpc - The RPC Binding handle.

    lpszDestination - The destination whose reachability is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

    lpbReachable - Boolean indicating whether the destination is reachable
        or not.

    lpdwLastError - The out parameter that holds the error code returned
        from GetLastError() when the destination is not reachable.

Notes:

    This function does nothing on Win9x platforms. It should never be called on Win9x
    platforms.

Return Value:

    RPC_S_OK, normally.

    RPC Error, if there is an RPC-related problem.

--*/
{
    BOOL bPingStatus;
    BOOL bFound;
    DWORD dwStatus;
    DWORD dwIpAddress;
    DWORD dwReachGLE;
    ULONG ulRTT;
    size_t uiLength;

#if !defined(SENS_CHICAGO)

    //
    // Some basic argument checks
    //
    if (NULL == lpdwLastError)
        {
        return RPC_S_INVALID_ARG;
        }

    if (   (NULL == lpszDestination)
        || (NULL == lpbReachable))
        {
        // Not likely.
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }

    uiLength = wcslen(lpszDestination);
    if (   (uiLength > MAX_DESTINATION_LENGTH)
        || (uiLength == 0))
        {
        *lpbReachable = FALSE;
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }

    *lpdwLastError = ERROR_SUCCESS;
    *lpbReachable = FALSE;

    ulRTT = 0;
    dwStatus = 0;
    dwIpAddress = 0;
    dwReachGLE = ERROR_SUCCESS;
    bPingStatus = FALSE;
    bFound = FALSE;

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    SensPrint(SENS_INFO, (SENS_STRING("RPC_IsDestinationReachableW(%s, 0x%x) called.\n"),
              lpszDestination, lpQOCInfo));

    dwStatus = ResolveName(lpszDestination, &dwIpAddress);

    if (dwStatus)
        {
        *lpdwLastError = MapLastError(dwStatus);
        *lpbReachable = FALSE;

        SensPrint(SENS_INFO, (SENS_STRING("The Destination %s cannot be resolved - %d\n"),
                  lpszDestination, dwStatus));
        SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

        return RPC_S_OK;
        }

    SensPrint(SENS_INFO, (SENS_STRING("Destination \"%s\" is resolved as 0x%x\n"),
              lpszDestination, dwIpAddress));

    bFound = CheckForReachability(
                dwIpAddress,
                lpQOCInfo,
                &dwReachGLE
                );

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    *lpbReachable = bFound;
    *lpdwLastError = MapLastError(dwReachGLE);

#endif // SENS_CHICAGO

    return RPC_S_OK;
}




error_status_t
RPC_IsDestinationReachableA(
    IN handle_t h,
    IN char * lpszDestination,
    IN OUT LPQOCINFO lpQOCInfo,
    OUT LPBOOL lpbReachable,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Check to see if the given destination is reachable. If so, return Quality
    Of Connection (QOC) information, if necessary.

Arguments:

    hRpc - The RPC Binding handle.

    lpszDestination - The destination whose reachability is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

    lpbReachable - Boolean indicating whether the destination is reachable
        or not.

    lpdwLastError - The out parameter that holds the error code returned
        from GetLastError() when the destination is not reachable.

Notes:

    This function does nothing on NT platforms. It should never be called on NT
    platforms.

Return Value:

    RPC_S_OK, normally.

    RPC Error, if there is an RPC-related problem.

--*/
{
    BOOL bPingStatus;
    BOOL bFound;
    DWORD dwStatus;
    DWORD dwIpAddress;
    DWORD dwReachGLE;
    ULONG ulRTT;
    size_t uiLength;

#if defined(SENS_CHICAGO)

    //
    // Some basic argument checks
    //
    if (NULL == lpdwLastError)
        {
        return RPC_S_INVALID_ARG;
        }

    if (   (NULL == lpszDestination)
        || (NULL == lpbReachable))
        {
        // Not likely.
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }

    uiLength = strlen(lpszDestination);
    if (   (uiLength > MAX_DESTINATION_LENGTH)
        || (uiLength == 0))
        {
        *lpbReachable = FALSE;
        *lpdwLastError = ERROR_INVALID_PARAMETER;
        return RPC_S_OK;
        }

    *lpdwLastError = ERROR_SUCCESS;
    *lpbReachable = FALSE;

    ulRTT = 0;
    dwStatus = 0;
    dwIpAddress = 0;
    dwReachGLE = ERROR_SUCCESS;
    bPingStatus = FALSE;
    bFound = FALSE;

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    SensPrint(SENS_INFO, (SENS_STRING("RPC_IsDestinationReachableA(%s, 0x%x) called.\n"),
              lpszDestination, lpQOCInfo));

    dwStatus = ResolveName(lpszDestination, &dwIpAddress);

    if (dwStatus)
        {
        *lpdwLastError = MapLastError(dwStatus);
        *lpbReachable = FALSE;

        SensPrint(SENS_INFO, (SENS_STRING("The Destination %s cannot be resolved - %d\n"),
                  lpszDestination, dwStatus));
        SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

        return RPC_S_OK;
        }

    SensPrint(SENS_INFO, (SENS_STRING("Destination \"%s\" is resolved as 0x%x\n"),
              lpszDestination, dwIpAddress));

    bFound = CheckForReachability(
                dwIpAddress,
                lpQOCInfo,
                &dwReachGLE
                );

    SensPrintA(SENS_INFO, ("--------------------------------------------------------------\n"));

    *lpbReachable = bFound;
    *lpdwLastError = MapLastError(dwReachGLE);

#endif // SENS_CHICAGO

    return RPC_S_OK;
}




error_status_t
RPC_SensNotifyWinlogonEvent(
    handle_t h,
    PSENS_NOTIFY_WINLOGON pEvent
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    SENSEVENT_WINLOGON Data;

    switch (pEvent->eType)
        {
        case SENS_NOTIFY_WINLOGON_LOGON:
            Data.eType = SENS_EVENT_LOGON;
            break;

        case SENS_NOTIFY_WINLOGON_LOGOFF:
            Data.eType = SENS_EVENT_LOGOFF;
            break;

        case SENS_NOTIFY_WINLOGON_STARTSHELL:
            Data.eType = SENS_EVENT_STARTSHELL;
            break;

        case SENS_NOTIFY_WINLOGON_POSTSHELL:
            Data.eType = SENS_EVENT_POSTSHELL;
            break;

        case SENS_NOTIFY_WINLOGON_SESSION_DISCONNECT:
            Data.eType = SENS_EVENT_SESSION_DISCONNECT;
            break;

        case SENS_NOTIFY_WINLOGON_SESSION_RECONNECT:
            Data.eType = SENS_EVENT_SESSION_RECONNECT;
            break;

        case SENS_NOTIFY_WINLOGON_LOCK:

            // If already locked, there is nothing to do.
            if (TRUE == gdwLocked)
                {
                return RPC_S_OK;
                }

            // Update info in cache.
            gdwLocked = TRUE;
            UpdateSensCache(LOCK);

            Data.eType = SENS_EVENT_LOCK;
            break;

        case SENS_NOTIFY_WINLOGON_UNLOCK:

            // If already unlocked, there is nothing to do.
            if (FALSE == gdwLocked)
                {
                return RPC_S_OK;
                }

            // Update info in cache.
            gdwLocked = FALSE;
            UpdateSensCache(LOCK);


            Data.eType = SENS_EVENT_UNLOCK;
            break;

        case SENS_NOTIFY_WINLOGON_STARTSCREENSAVER:
            Data.eType = SENS_EVENT_STARTSCREENSAVER;
            break;

        case SENS_NOTIFY_WINLOGON_STOPSCREENSAVER:
            Data.eType = SENS_EVENT_STOPSCREENSAVER;
            break;

        default:
            SensPrintA(SENS_WARN, ("BOGUS WINLOGON EVENT\n"));
            ASSERT(0 && "BOGUS WINLOGON EVENT");
            return RPC_S_OK;
        }

    memcpy(&Data.Info, &pEvent->Info, sizeof(WINLOGON_INFO));

    //
    // PERFORMANCE NOTE:
    //
    //  o We want the Logoff event to be synchronous. That is, until all
    //    the subscribers to this event are done handling this event,
    //    System Logoff should not occur.
    //  o As of today, LCE fires events to the subscribers on the publishers
    //    thread. If we fire on a threadpool thread, it will release the
    //    publisher thread which will go and allow System Logoff to continue.
    //  o This has performance implications. We need to make sure that we
    //    don't impact System Logoff time when there are no subscriptions
    //    to this event.
    //

    if (SENS_EVENT_LOGOFF != Data.eType)
        {
        // Queue workitem to threadpool
        SensFireEvent(&Data);
        }
    else
        {
        PVOID pAllocatedData;

        pAllocatedData = AllocateEventData(&Data);
        if (NULL == pAllocatedData)
            {
            SensPrintA(SENS_ERR, ("RPC_NotifyWinlogonEvent(): Failed to allocate Event Data!\n"));
            return (RPC_S_OUT_OF_MEMORY);
            }

        // Synchronously call LCE and then free allocated Data.
        SensFireEventHelper(pAllocatedData);
        }

    return (RPC_S_OK);
}




error_status_t
RPC_SensNotifyRasEvent(
    handle_t h,
    PSENS_NOTIFY_RAS pEvent
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    DWORD dwIgnore;
    SENSEVENT_RAS Data;

    switch (pEvent->eType)
        {
        case SENS_NOTIFY_RAS_STARTED:
            Data.eType = SENS_EVENT_RAS_STARTED;
            break;

        case SENS_NOTIFY_RAS_STOPPED:
            Data.eType = SENS_EVENT_RAS_STOPPED;
            break;

        case SENS_NOTIFY_RAS_CONNECT:
            Data.eType = SENS_EVENT_RAS_CONNECT;
            break;

        case SENS_NOTIFY_RAS_DISCONNECT:
            Data.eType = SENS_EVENT_RAS_DISCONNECT;
            break;

        case SENS_NOTIFY_RAS_DISCONNECT_PENDING:
            Data.eType = SENS_EVENT_RAS_DISCONNECT_PENDING;
            break;

        default:
            SensPrintA(SENS_WARN, ("\t| BOGUS RAS EVENT - Type is %d\n", pEvent->eType));
            return RPC_S_OK;
        }

    Data.hConnection = pEvent->hConnection;

    SensFireEvent(&Data);

    EvaluateConnectivity(TYPE_WAN);

    return (RPC_S_OK);
}




error_status_t
RPC_SensNotifyNetconEvent(
    handle_t h,
    PSENS_NOTIFY_NETCON_P pEvent
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    SENSEVENT_LAN Data;

    switch (pEvent->eType)
        {
        case SENS_NOTIFY_LAN_CONNECT:
            Data.eType = SENS_EVENT_LAN_CONNECT;
            break;

        case SENS_NOTIFY_LAN_DISCONNECT:
            Data.eType = SENS_EVENT_LAN_DISCONNECT;
            break;

        default:
            SensPrintA(SENS_WARN, ("\t| BOGUS LAN EVENT - Type is %d\n", pEvent->eType));
            return RPC_S_OK;
        }

    Data.Name = pEvent->Name;
    Data.Status = pEvent->Status;
    Data.Type = pEvent->Type;

    // Force a recalculation of LAN Connectivity
    gdwLastLANTime -= (MAX_LAN_INTERVAL + 1);

    SensFireEvent(&Data);

    EvaluateConnectivity(TYPE_LAN);

    return (RPC_S_OK);
}




DWORD
MapLastError(
    DWORD dwInGLE
    )
/*++

Routine Description:

    This rountine maps the GLEs returned by the SENS Connecitivity engine to
    GLEs that describe the failure of the SENS APIs more accurately.

Arguments:

    dwInGLE - The GLE that needs to be mapped

Return Value:

    The mapped (and better) GLE.

--*/
{
    DWORD dwOutGLE;

    switch (dwInGLE)
        {
        //
        // When IP stack is not present, we typically get these errors.
        //
        case ERROR_INVALID_FUNCTION:
        case ERROR_NOT_SUPPORTED:
            dwOutGLE = ERROR_NO_NETWORK;
            break;

        //
        // No mapping by default.
        //
        default:
            dwOutGLE = dwInGLE;
            break;

        } // switch

    return dwOutGLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\cache.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cache.cxx

Abstract:

    Code to create, destroy and manipulate SENS cache. Initially, it
    contains system connectivity state.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          2/8/1999         Start.

--*/


#include <precomp.hxx>


//
// Globals
//

HANDLE          ghSensFileMap;
PSENS_CACHE     gpSensCache;


#if !defined(SENS_CHICAGO)


BOOL
CreateCachePermissions(
    PSECURITY_ATTRIBUTES psa,
    PSECURITY_DESCRIPTOR psd,
    PACL *ppOutAcl
    )
/*++

Routine Description:

    Create security attributes for SENS Cache. It has following permissions:
        o Everyone    - READ
        o LocalSystem - READ & WRITE

Arguments:

    psa - Pointer to a security attributes structure.

    psd - Pointer to a security descriptor structure.

    pOutAcl - Pointer to an ACL. Needs to be cleaned when the return
        value is TRUE. Should be cleaned up on failure.

Notes:

    This code should work on NT4 also.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    BOOL bRetVal;
    int cbAcl;
    PACL pAcl;
    PSID pWorldSid;
    PSID pLocalSystemSid = NULL;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSystemAuthority = SECURITY_NT_AUTHORITY;

    bRetVal = FALSE;
    *ppOutAcl = NULL;
    pAcl = NULL;
    pWorldSid = NULL;
    pLocalSystemSid = NULL;


    //
    // Allocate WorldSid
    //
    bRetVal = AllocateAndInitializeSid(
                  &WorldAuthority,      // Pointer to identifier authority
                  1,                    // Count of subauthority
                  SECURITY_WORLD_RID,   // Subauthority 0
                  0,                    // Subauthority 1
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pWorldSid            // pointer to pointer to SID
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): AllocateAndInitiali"
                  "zeSid(World) failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    //
    // Allocate LocalSystemSid
    //
    bRetVal = AllocateAndInitializeSid(
                  &LocalSystemAuthority,// Pointer to identifier authority
                  1,                    // Count of subauthority
                  SECURITY_LOCAL_SYSTEM_RID,   // Subauthority 0
                  0,                    // Subauthority 1
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pLocalSystemSid      // pointer to pointer to SID
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): AllocateAndInitiali"
                  "zeSid(LocalSystem) failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    //
    // Create the ACL with the desired ACEs
    //

    // Calculate the length of the required ACL buffer with 2 ACEs.
    cbAcl =   sizeof (ACL)
            + 2 * sizeof (ACCESS_ALLOWED_ACE)
            + GetLengthSid(pWorldSid)
            + GetLengthSid(pLocalSystemSid);

    // Allocate the ACL buffer.
    pAcl = (PACL) new char[cbAcl];
    if (NULL == pAcl)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): Failed to allocate"
                  "an ACL.\n"));
        goto Cleanup;
        }

    // Initialize the ACL.
    bRetVal = InitializeAcl(
                  pAcl,             // Pointer to the ACL
                  cbAcl,            // Size of ACL
                  ACL_REVISION      // Revision level of ACL
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): InitializeAcl() "
                  "failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    // Add ACE with FILE_MAP_READ for Everyone
    bRetVal = AddAccessAllowedAce(
                  pAcl,             // Pointer to the ACL
                  ACL_REVISION,     // ACL revision level
                  FILE_MAP_READ,    // Access Mask
                  pWorldSid         // Pointer to SID
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): AddAccessAllowedAce()"
                  " failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    // Add ACE with FILE_MAP_WRITE for LocalSystem
    bRetVal = AddAccessAllowedAce(
                  pAcl,             // Pointer to the ACL
                  ACL_REVISION,     // ACL revision level
                  FILE_MAP_WRITE,   // Access Mask
                  pLocalSystemSid   // Pointer to SID
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): AddAccessAllowedAce()"
                  " failed with %d.\n", GetLastError()));
        goto Cleanup;
        }

    // Initialize Security Descriptor.
    bRetVal = InitializeSecurityDescriptor(
                  psd,                          // Pointer to SD
                  SECURITY_DESCRIPTOR_REVISION  // SD revision
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): "
                   "InitializeSecurityDescriptor() failed with a GLE of %d\n",
                   GetLastError()));
        goto Cleanup;
        }

    // Set the Dacl.
    bRetVal = SetSecurityDescriptorDacl(
                  psd,              // Security Descriptor
                  TRUE,             // Dacl present
                  pAcl,             // The Dacl
                  FALSE             // Not defaulted
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateCachePermissions(): "
                   "SetSecurityDescriptorDacl() failed with a GLE of %d\n",
                   GetLastError()));
        goto Cleanup;
        }

    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = psd;
    psa->bInheritHandle = FALSE;

    bRetVal = TRUE;

Cleanup:
    //
    // Cleanup
    //
    if (pWorldSid)
        {
        FreeSid(pWorldSid);
        }
    if (pLocalSystemSid)
        {
        FreeSid(pLocalSystemSid);
        }

    //
    // On failure, we clean the ACL up. On success, the caller cleans
    // it up after using it.
    //
    if (FALSE == bRetVal)
        {
        if (pAcl)
            {
            delete pAcl;
            }
        }
    else
        {
        *ppOutAcl = pAcl;
        }

    return bRetVal;
}

#endif // SENS_CHICAGO




BOOL
CreateSensCache(
    void
    )
/*++

Routine Description:

    Create a cache for information maintained by SENS.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    BOOL bRetVal;

    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa, *psa;
    PACL pAcl;

#if !defined(SENS_CHICAGO)

    bRetVal = CreateCachePermissions(&sa, &sd, &pAcl);
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("CreateSensCache(): CreateCachePermissions() "
                   "failed with a GLE of %d\n", GetLastError()));
        goto Cleanup;
        }

    psa = &sa;

#else  // SENS_CHICAGO

    psa = NULL;
    pAcl = NULL;
    bRetVal = FALSE;

#endif // SENS_CHICAGO

    //
    // First, create a file mapping object
    //
    ghSensFileMap = CreateFileMapping(
                        INVALID_HANDLE_VALUE, // Handle of file to map
                        psa,                  // Optional security attributes
                        PAGE_READWRITE,       // Protection for mapping object
                        0,                    // High-order 32 bits of size
                        SENS_CACHE_SIZE,      // Low-order 32 bits of size
                        SENS_CACHE_NAME       // Name of the file mapping object
                        );

    // Free Acl.
    delete pAcl;

    if (NULL == ghSensFileMap)
        {
        SensPrintA(SENS_ERR, ("CreateSensCache(): CreateFileMapping() failed "
                   "with a GLE of %d\n", GetLastError()));
        goto Cleanup;
        }
    else
    if (GetLastError() == ERROR_ALREADY_EXISTS)
        {
        SensPrintA(SENS_ERR, ("CreateSensCache(): File Mapping exists!\n"));
        }

    //
    // Now, map a view of the file into the address space
    //
    gpSensCache = (PSENS_CACHE) MapViewOfFile(
                      ghSensFileMap,    // Map file object
                      FILE_MAP_WRITE,   // Access mode
                      0,                // High-order 32 bits of file offset
                      0,                // Low-order 32 bits of file offset
                      0                 // Number of bytes to map
                      );
    if (NULL == gpSensCache)
        {
        SensPrintA(SENS_ERR, ("CreateSensCache(): MapViewOfFile() failed with "
                   "a GLE of %d\n", GetLastError()));
        goto Cleanup;
        }

    //
    // Initialize the cache.
    //
    memset(gpSensCache, 0x0, sizeof(SENS_CACHE));
    gpSensCache->dwCacheVer  = SENS_CACHE_VERSION;
    gpSensCache->dwCacheSize = sizeof(SENS_CACHE);
    gpSensCache->dwCacheInitTime = GetTickCount();

    bRetVal = TRUE;

    SensPrintA(SENS_INFO, ("[%d] CreateSensCache(): Cache initialized\n",
               GetTickCount(), gpSensCache->dwCacheInitTime));

    return bRetVal;

Cleanup:
    //
    // Cleanup
    //
    if (ghSensFileMap != NULL)
        {
        CloseHandle(ghSensFileMap);

        ghSensFileMap = NULL;
        gpSensCache = NULL;
        }

    return bRetVal;
}





void
DeleteSensCache(
    void
    )
/*++

Routine Description:

    Cleanup the previously create SENS cache.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (gpSensCache != NULL)
        {
        BOOL bStatus = FALSE;

        ASSERT(ghSensFileMap != NULL);

        bStatus = UnmapViewOfFile((LPVOID) gpSensCache);
        SensPrintA(SENS_INFO, ("DeleteSensCache(): UnmapViewOfFile() returned"
                   " 0x%x with a GLE of %d\n.", bStatus, GetLastError()));
        ASSERT(bStatus != FALSE);

		gpSensCache = 0;
        }

    if (ghSensFileMap != NULL)
        {
        CloseHandle(ghSensFileMap);
		ghSensFileMap = 0;
        }

    SensPrintA(SENS_INFO, ("DeleteSensCache(): Successfully cleaned up SENS"
               " Cache.\n"));
    return;
}




void
UpdateSensCache(
    CACHE_TYPE Type
    )
/*++

Routine Description:

    Updates the requested part of the SENS cache.

Arguments:

    Type - That part of the cache that needs to be updated.

Return Value:

    None.

--*/
{
    //
    // Make sure Cache is initialized.
    //
    if (NULL == gpSensCache)
        {
        return;
        }

    switch (Type)
        {

        case LAN:
            gpSensCache->dwLANState = gdwLANState;
            gpSensCache->dwLastLANTime = gdwLastLANTime;
            UpdateSensNetworkCache();
            break;

        case WAN:
            gpSensCache->dwWANState = gdwWANState;
            gpSensCache->dwLastWANTime = gdwLastWANTime;
            UpdateSensNetworkCache();
            break;

#if defined(AOL_PLATFORM)

        case AOL:
            gpSensCache->dwAOLState = gdwAOLState;
            // We don't update the Network cache when AOL
            // connectivity is updated.
            break;

#endif // (AOL_PLATFORM)

        case LOCK:
            gpSensCache->dwLocked = gdwLocked;
            SensPrintA(SENS_INFO, ("CACHE: Updated Locked State to %d.\n", gpSensCache->dwLocked));
            break;

        case INVALID:
        default:
            SensPrintA(SENS_ERR, ("UpdateSensCache(): Received an invalid Type"
                       " (0x%x)\n", Type));
            ASSERT(0);
            break;

        } // switch

    SensPrintA(SENS_INFO, ("UpdateSensCache(): Succeeded.\n"));
}




inline void
UpdateSensNetworkCache(
    void
    )
/*++

    Convenient Macro to update the whole Network state.

--*/
{
    DWORD dwNetState;

    dwNetState = 0x0;

    RequestSensLock();

    if (gdwLANState)
        {
        dwNetState |= NETWORK_ALIVE_LAN;
        }

    if (gdwWANState)
        {
        dwNetState |= NETWORK_ALIVE_WAN;
        }

#if defined(AOL_PLATFORM)

    if (gdwAOLState)
        {
        dwNetState |= NETWORK_ALIVE_AOL;
        }

#endif // AOL_PLATFORM

    gpSensCache->dwLastUpdateState = dwNetState;

    gpSensCache->dwLastUpdateTime = GetTickCount();

    ReleaseSensLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\cpubfilt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    cpubfilt.cxx

Abstract:

    This file contains the implementation of the PublisherFilter
    for the ISensNetwork interface exposed by SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/26/1998         Start.

--*/



#include <precomp.hxx>


//
// Globals
//
LONG g_cFilterObj;      // Count of active components
LONG g_cFilterLock;     // Count of Server locks





//
// Constructors and Destructors
//
CImpISensNetworkFilter::CImpISensNetworkFilter(
    void
    ) : m_cRef(1L), // Add a reference.
        m_pConnectionMade_Enum(NULL),
        m_pConnectionMadeNoQOC_Enum(NULL),
        m_pConnectionLost_Enum(NULL),
        m_pDestinationReachable_Enum(NULL),
        m_pDestinationReachableNoQOC_Enum(NULL),
        m_pConnectionMade_FiringControl(NULL),
        m_pConnectionMadeNoQOC_FiringControl(NULL),
        m_pConnectionLost_FiringControl(NULL),
        m_pDestinationReachable_FiringControl(NULL),
        m_pDestinationReachableNoQOC_FiringControl(NULL)
{
    InterlockedIncrement(&g_cFilterObj);
}

CImpISensNetworkFilter::~CImpISensNetworkFilter(
    void
    )
{
    InterlockedDecrement(&g_cFilterObj);

    //
    // Release all references that we added to IEnumEventObject pointers,
    // if any.
    //
    if (m_pConnectionMade_Enum)
        {
        m_pConnectionMade_Enum->Release();
        }

    if (m_pConnectionMadeNoQOC_Enum)
        {
        m_pConnectionMadeNoQOC_Enum->Release();
        }

    if (m_pConnectionLost_Enum)
        {
        m_pConnectionLost_Enum->Release();
        }

    if (m_pDestinationReachable_Enum)
        {
        m_pDestinationReachable_Enum->Release();
        }

    if (m_pDestinationReachableNoQOC_Enum)
        {
        m_pDestinationReachableNoQOC_Enum->Release();
        }

    //
    // Release all references that we added to IFiringControl pointers,
    // if any (and there shouldn't be any).
    //
    if (m_pConnectionMade_FiringControl)
        {
        m_pConnectionMade_FiringControl->Release();
        }

    if (m_pConnectionMadeNoQOC_FiringControl)
        {
        m_pConnectionMadeNoQOC_FiringControl->Release();
        }

    if (m_pConnectionLost_FiringControl)
        {
        m_pConnectionLost_FiringControl->Release();
        }

    if (m_pDestinationReachable_FiringControl)
        {
        m_pDestinationReachable_FiringControl->Release();
        }

    if (m_pDestinationReachableNoQOC_FiringControl)
        {
        m_pDestinationReachableNoQOC_FiringControl->Release();
        }
}




//
// Standard QueryInterface
//
STDMETHODIMP
CImpISensNetworkFilter::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr;

    DebugTraceGuid("CImpISensNetworkFilter:QueryInterface()", riid);

    hr = S_OK;
    *ppv = NULL;

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
    // ISensNetwork
    if (IsEqualIID(riid, IID_ISensNetwork))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
    // IPublisherFilter
    if (IsEqualIID(riid, IID_IPublisherFilter))
        {
        *ppv = (IPublisherFilter *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}




//
// IDispatch member function implementations. These are dummy implementations
// as EventSystem never calls them.
//

STDMETHODIMP
CImpISensNetworkFilter::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    return E_NOTIMPL;

}

STDMETHODIMP
CImpISensNetworkFilter::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImpISensNetworkFilter::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImpISensNetworkFilter::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
    return E_NOTIMPL;
}




//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpISensNetworkFilter::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CImpISensNetworkFilter::Release(
    void
    )
{
    LONG cRefT;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpISensNetworkFilter::Release(m_cRef = %d) called.\n"), m_cRef));

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        delete this;
        }

    return cRefT;
}



//
// ISensNetwork Implementation.
//

STDMETHODIMP
CImpISensNetworkFilter::ConnectionMade(
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO lpQOCInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::ConnectionMade() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    HRESULT hr = S_OK;
    ConnectionFilter filter(PROPERTY_CONNECTION_MADE_TYPE, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pConnectionMade_Enum,
                 m_pConnectionMade_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pConnectionMade_FiringControl->Release();
    m_pConnectionMade_FiringControl = NULL;

    return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::ConnectionMadeNoQOCInfo(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::ConnectionMadeNoQOCInfo() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    HRESULT hr = S_OK;
    ConnectionFilter filter(PROPERTY_CONNECTION_MADE_NOQOC_TYPE, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pConnectionMadeNoQOC_Enum,
                 m_pConnectionMadeNoQOC_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pConnectionMadeNoQOC_FiringControl->Release();
    m_pConnectionMadeNoQOC_FiringControl = NULL;

    return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::ConnectionLost(
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::ConnectionLost() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    HRESULT hr = S_OK;
    ConnectionFilter filter(PROPERTY_CONNECTION_LOST_TYPE, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pConnectionLost_Enum,
                 m_pConnectionLost_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pConnectionLost_FiringControl->Release();
    m_pConnectionLost_FiringControl = NULL;

    return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::DestinationReachable(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO lpQOCInfo
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::DestinationReachable() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrDestination - %s\n"), bstrDestination));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    HRESULT hr = S_OK;
    ReachabilityFilter filter(PROPERTY_DESTINATION, PROPERTY_DESTINATION_TYPE, bstrDestination, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pDestinationReachable_Enum,
                 m_pDestinationReachable_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pDestinationReachable_FiringControl->Release();
    m_pDestinationReachable_FiringControl = NULL;

    return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::DestinationReachableNoQOCInfo(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpISensNetworkFilter::DestinationReachableNoQOCInfo() called\n\n")));
    SensPrintW(SENS_INFO, (SENS_BSTR("   bstrDestination - %s\n"), bstrDestination));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrConnection - %s\n"), bstrConnection));
    SensPrint(SENS_INFO, (SENS_STRING("            ulType - 0x%x\n"), ulType));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));


    HRESULT hr = S_OK;
    ReachabilityFilter filter(PROPERTY_DESTINATION_NOQOC, PROPERTY_DESTINATION_NOQOC_TYPE, bstrDestination, ulType, hr);
    if (SUCCEEDED(hr))
        {
        hr = FilterAndFire(
                 filter,
                 m_pDestinationReachableNoQOC_Enum,
                 m_pDestinationReachableNoQOC_FiringControl
                 );
        }

    // We're done with this IFiringControl object.
    m_pDestinationReachableNoQOC_FiringControl->Release();
    m_pDestinationReachableNoQOC_FiringControl = NULL;

    return hr;
}




//
// IPublisherFilter Implementation.
//
STDMETHODIMP
CImpISensNetworkFilter::Initialize(
    BSTR bstrMethodName,
    IDispatch* dispUserDefined
    )
{
    HRESULT hr = E_INVALIDARG;

    IEnumEventObject** ppEnum = NULL;
    if (wcscmp(bstrMethodName, CONNECTION_MADE_METHOD) == 0)
        {
        ppEnum = &m_pConnectionMade_Enum;
        }
    else
    if (wcscmp(bstrMethodName, CONNECTION_MADE_NOQOC_METHOD) == 0)
        {
        ppEnum = &m_pConnectionMadeNoQOC_Enum;
        }
    else
    if (wcscmp(bstrMethodName, CONNECTION_LOST_METHOD) == 0)
        {
        ppEnum = &m_pConnectionLost_Enum;
        }
    else
    if (wcscmp(bstrMethodName, DESTINATION_REACHABLE_METHOD) == 0)
        {
        ppEnum = &m_pDestinationReachable_Enum;
        }
    else
    if (wcscmp(bstrMethodName, DESTINATION_REACHABLE_NOQOC_METHOD) == 0)
        {
        ppEnum = &m_pDestinationReachableNoQOC_Enum;
        }

    if (ppEnum != NULL)
        {
        IEventControl* control = NULL;
        hr = dispUserDefined->QueryInterface(IID_IEventControl, (void**)&control);
        if (FAILED(hr))
            {
            return hr;
            }

        IEventObjectCollection* collection = NULL;
        hr = control->GetSubscriptions(bstrMethodName, NULL, NULL, &collection);
        if (SUCCEEDED(hr))
            {
            hr = collection->get_NewEnum(ppEnum);

            // Don't need the collection any more... just keep the enum
            collection->Release();
            }

        control->Release();
        }

        return hr;
}


STDMETHODIMP
CImpISensNetworkFilter::PrepareToFire(
    BSTR bstrMethodName,
    IFiringControl* pIFiringControl
    )
{
    HRESULT hr = E_INVALIDARG;

    IFiringControl** ppFiringControl = NULL;
    if (wcscmp(bstrMethodName, CONNECTION_MADE_METHOD) == 0)
        {
        ppFiringControl = &m_pConnectionMade_FiringControl;
        }
    else
    if (wcscmp(bstrMethodName, CONNECTION_MADE_NOQOC_METHOD) == 0)
        {
        ppFiringControl = &m_pConnectionMadeNoQOC_FiringControl;
        }
    else
    if (wcscmp(bstrMethodName, CONNECTION_LOST_METHOD) == 0)
        {
        ppFiringControl = &m_pConnectionLost_FiringControl;
        }
    else
    if (wcscmp(bstrMethodName, DESTINATION_REACHABLE_METHOD) == 0)
        {
        ppFiringControl = &m_pDestinationReachable_FiringControl;
        }
    else
    if (wcscmp(bstrMethodName, DESTINATION_REACHABLE_NOQOC_METHOD) == 0)
        {
        ppFiringControl = &m_pDestinationReachableNoQOC_FiringControl;
        }

    if (ppFiringControl != NULL)
        {
        *ppFiringControl = pIFiringControl;
        pIFiringControl->AddRef();
        hr = S_OK;
        }

    return hr;
}




//
// Filter helper implementations.
//


//
// ConnectionFilter implementation.
//

ConnectionFilter::ConnectionFilter(
    const wchar_t* connectionTypeProperty,
    ULONG connectionType,
    HRESULT& hr
    ) : m_connectionTypeProperty(SysAllocString(connectionTypeProperty)),
        m_connectionType(connectionType)
{
    if (m_connectionTypeProperty == NULL)
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        hr = S_OK;
        }
}


ConnectionFilter::~ConnectionFilter(
    void
    )
{
    SysFreeString(m_connectionTypeProperty);
}


HRESULT
ConnectionFilter::CheckMatch(
    IEventSubscription* pSubscription
    ) const
{
    VARIANT value;
    VariantInit(&value);
    HRESULT hr = pSubscription->GetPublisherProperty(m_connectionTypeProperty, &value);

    if (hr == S_FALSE)
        {
        // If the property isn't present, consider it a successful match.
        hr = S_OK;
        }
    else
    if (hr == S_OK)
        {
        // If the property is there, it must match the incoming parameter value.
        ASSERT(value.vt == VT_UI4);
        SensPrintW(SENS_INFO, (SENS_BSTR("\t| Property %s has value 0x%x\n"), m_connectionTypeProperty, value.ulVal));
        hr = (m_connectionType == value.ulVal) ? S_OK : S_FALSE;
        }

    VariantClear(&value);

    return hr;
}



//
// ReachabilityFilter implementation
//

ReachabilityFilter::ReachabilityFilter(
    const wchar_t* destinationProperty,
    const wchar_t* destinationTypeProperty,
    BSTR destination,
    ULONG destinationType,
    HRESULT& hr
    ) : m_destinationProperty(SysAllocString(destinationProperty)),
        m_destinationTypeProperty(SysAllocString(destinationTypeProperty)),
        m_destination(destination),
        m_destinationType(destinationType)
{
    if (m_destinationProperty == NULL || m_destinationTypeProperty == NULL)
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        hr = S_OK;
        }
}


ReachabilityFilter::~ReachabilityFilter(
    void
    )
{
    SysFreeString(m_destinationProperty);
    SysFreeString(m_destinationTypeProperty);
}


HRESULT
ReachabilityFilter::CheckMatch(
    IEventSubscription* pSubscription
    ) const
{
    HRESULT hr;

    // Check the destination property
    VARIANT value;
    VariantInit(&value);
    hr = pSubscription->GetPublisherProperty(m_destinationProperty, &value);

    if (hr == S_FALSE)
        {
        // If the property isn't present, consider it a successful match.
        hr = S_OK;
        SensPrintW(SENS_INFO, (SENS_BSTR("\t\t\t| Subscription (0x%x) has no %s Dest Property\n"), pSubscription, m_destinationProperty));
        }
    else
    if (hr == S_OK)
        {
        // If the property is there, it must match the incoming parameter value.
        ASSERT(value.vt == VT_BSTR);
        SensPrintW(SENS_INFO, (SENS_BSTR("\t\t\t| Property %s has value %s\n"), m_destinationProperty, value.bstrVal));
        hr = (wcscmp(m_destination, value.bstrVal) == 0) ? S_OK : S_FALSE;
        }

    VariantClear(&value);

    if (hr == S_OK)
        {
        // If we have a match so far, check the destination type property
        VARIANT value;
        VariantInit(&value);
        hr = pSubscription->GetPublisherProperty(m_destinationTypeProperty, &value);

        if (hr == S_FALSE)
            {
            // If the property isn't present, consider it a successful match.
            hr = S_OK;
            SensPrintW(SENS_INFO, (SENS_BSTR("\t\t\t| Subscription (0x%x) has no %s Type Property\n"), pSubscription, m_destinationTypeProperty));
            }
        else
        if (hr == S_OK)
            {
            // If the property is there, it must match the incoming parameter value.
            ASSERT(value.vt == VT_UI4);
            SensPrintW(SENS_INFO, (SENS_BSTR("\t\t\t| Property %s has value 0x%x\n"), m_destinationTypeProperty, value.ulVal));
            hr = (m_destinationType == value.ulVal) ? S_OK : S_FALSE;
            }

        VariantClear(&value);
        }

    return hr;
}




//
// Generic filter and fire method.
//
HRESULT
FilterAndFire(
    const Filter& filter,
    IEnumEventObject* enumerator,
    IFiringControl* firingControl
    )
{
    HRESULT hr;
    IEventSubscription* pSubscription = NULL;
    int i = 0;

    //
    // Reset the enum back to the start
    //
    hr = enumerator->Reset();

    //
    // Loop through all the candidate subscriptions and fire the ones
    // that match the filter criteria.
    //
    for (;;)
        {
        ULONG cCount = 1;

        hr = enumerator->Next(cCount, (IUnknown**)&pSubscription, &cCount);
        if (hr != S_OK || cCount != 1)
            {
            break;
            }

        SensPrintA(SENS_INFO, ("\t\t\t| ****** Count for 0x%x is %d\n", enumerator, ++i));

        hr = filter.CheckMatch(pSubscription);
        if (hr == S_OK)
            {
            SensPrintA(SENS_INFO, ("\t\t\t| FilterAndFire(0x%x): CheckMatch() succeeded\n", enumerator));
            firingControl->FireSubscription(pSubscription);
            }

        pSubscription->Release();
        pSubscription = NULL;
        }

    //
    // Cleanup, including any left-over stuff in case of premature exit from the loop.
    //
    if (pSubscription != NULL)
        {
        pSubscription->Release();
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\ciolecmd.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ciolecmd.cxx

Abstract:

    This file contains the implementation of the IOleCommandTarget
    interface for receiving events from IE5.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    These events are not used on NT5. They are used on Win9x and NT4
    platforms.

Revision History:

    GopalP          1/26/1998         Start.

--*/



#include <precomp.hxx>
#include <onestop.cxx>  // This is a source file!


//
// IOleCommandTarget group for WININET events.
//
// Should have the IE5 folks put it in a header file. This is moot as this
// file is no longer used on any platform.
//

CLSID CLSID_EVENTGROUP_WININET = { /* ab8ed004-b86a-11d1-b1f8-00c04fa357fa */
    0xab8ed004,
    0xb86a,
    0x11d1,
    {0xb1, 0xf8, 0x00, 0xc0, 0x4f, 0xa3, 0x57, 0xfa}
};



//
// Globals
//
LONG g_cCommandObj;      // Count of active components
LONG g_cCommandLock;     // Count of Server locks




//
// Constructors and Destructors
//
CImpIOleCommandTarget::CImpIOleCommandTarget(
    void
    ) : m_cRef(1L) // Add a reference.
{
    InterlockedIncrement(&g_cCommandObj);
}

CImpIOleCommandTarget::~CImpIOleCommandTarget(
    void
    )
{
    InterlockedDecrement(&g_cCommandObj);
}




//
// Standard QueryInterface
//
STDMETHODIMP
CImpIOleCommandTarget::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr;

    DebugTraceGuid("CImpIOleCommandTarget:QueryInterface()", riid);

    hr = S_OK;
    *ppv = NULL;

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (IOleCommandTarget *) this;
        }
    else
    // IOleCommandTarget
    if (IsEqualIID(riid, IID_IOleCommandTarget))
        {
        *ppv = (IOleCommandTarget *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}




//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpIOleCommandTarget::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CImpIOleCommandTarget::Release(
    void
    )
{
    LONG cRefT;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpIOleCommandTarget::Release(m_cRef = %d) called.\n"), m_cRef));

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        delete this;
        }

    return cRefT;
}




//
// IOleCommandTarget Implementation.
//

STDMETHODIMP
CImpIOleCommandTarget::QueryStatus(
    const GUID *pguidCmdGroup,
    ULONG cCmds,
    OLECMD prgCmds[],
    OLECMDTEXT *pCmdText
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpIOleCommandTarget::QueryStatus() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("    pguidCmdGroup - 0x%x\n"), pguidCmdGroup));
    SensPrint(SENS_INFO, (SENS_STRING("            cCmds - 0x%x\n"), cCmds));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    if (IsEqualGUID(*pguidCmdGroup, CLSID_EVENTGROUP_WININET))
        {
        // Subscribe to WININET events
        return S_OK;
        }

    return(OLECMDERR_E_UNKNOWNGROUP);
}

STDMETHODIMP
CImpIOleCommandTarget::Exec(
    const GUID *pguidCmdGroup,
    DWORD nCmdID,
    DWORD nCmdexecopt,
    VARIANT *pvaIn,
    VARIANT *pvaOut
    )
{
    HRESULT hr;

    hr = S_OK;

    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpIOleCommandTarget::Exec() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("    pguidCmdGroup - 0x%x\n"), pguidCmdGroup));
    SensPrint(SENS_INFO, (SENS_STRING("            cCmds - 0x%x\n"), nCmdID));
    SensPrint(SENS_INFO, (SENS_STRING("      cCmdexecopt - 0x%x\n"), nCmdexecopt));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    if (   (NULL  == pguidCmdGroup)
        || (FALSE == IsEqualGUID(*pguidCmdGroup, CLSID_EVENTGROUP_WININET)))
        {
        return(E_NOTIMPL);
        }

    //
    // Handle WININET events...
    //
    switch (nCmdID)
        {
        case INETEVT_RAS_CONNECT:
            ASSERT(VT_BSTR == pvaIn->vt);
            hr = WininetRasConnect(pvaIn->bstrVal);
            break;

        case INETEVT_RAS_DISCONNECT:
            ASSERT(VT_BSTR == pvaIn->vt);
            hr = WininetRasDisconnect(pvaIn->bstrVal);
            break;

        case INETEVT_ONLINE:
            hr = WininetOnline();
            break;

        case INETEVT_OFFLINE:
            hr = WininetOffline();
            break;

        case INETEVT_LOGON:
            ASSERT(VT_BSTR == pvaIn->vt);
            hr = WininetLogon(pvaIn->bstrVal);
            break;

        case INETEVT_LOGOFF:
            //ASSERT(VT_BSTR == pvaIn->vt);
            //hr = WininetLogoff(pvaIn->bstrVal);
            hr = WininetLogoff(SENS_BSTR("<Not Available>"));
            break;
        } // switch

    return S_OK;
}




HRESULT
WininetRasConnect(
    BSTR bstrPhonebookEntry
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    HRESULT hr;
    ULONG ulIgnore;
    SENSEVENT_RAS Data;

    hr = S_OK;

    SensPrintA(SENS_INFO, ("WininetRasConnect() - RAS Connect Event!\n"));
    Data.eType = SENS_EVENT_RAS_CONNECT;
    Data.hConnection = NULL;
    SensFireEvent(&Data);

    // Do necessary work here
    EvaluateConnectivity(TYPE_WAN);

    return hr;
}





HRESULT
WininetRasDisconnect(
    BSTR bstrPhonebookEntry
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    HRESULT hr;
    ULONG ulIgnore;
    SENSEVENT_RAS Data;

    hr = S_OK;

    SensPrintA(SENS_INFO, ("WininetRasDisconnect() - RAS Disconnect Event!\n"));
    Data.eType = SENS_EVENT_RAS_DISCONNECT;
    Data.hConnection = NULL;
    SensFireEvent(&Data);

    // Do necessary work here
    EvaluateConnectivity(TYPE_WAN);

    return hr;
}





HRESULT
WininetOnline(
    void
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    HRESULT hr;

    hr = S_OK;

    return hr;
}





HRESULT
WininetOffline(
    void
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    HRESULT hr;

    hr = S_OK;

    return hr;
}





HRESULT
WininetLogon(
    BSTR bstrUserName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    HRESULT hr;
    SENS_NOTIFY_WINLOGON Data;

    hr = S_OK;

    //
    // Setup the data.
    //
    memset(&Data.Info, 0x0, sizeof(SENS_NOTIFY_WINLOGON));

    Data.eType = SENS_EVENT_LOGON;
    Data.Info.Size = sizeof(WINLOGON_INFO);
    Data.Info.Flags = 0x0;
    Data.Info.UserName = bstrUserName;
    Data.Info.Domain = NULL;
    Data.Info.WindowStation = NULL;
    Data.Info.hToken = NULL;;

    // First order of business - start OneStop if necessary.
    if (IsAutoSyncEnabled(NULL, AUTOSYNC_ON_STARTSHELL))
        {
        hr = SensNotifyOneStop(NULL, SYNC_MANAGER_LOGON, FALSE);
        LogMessage((SENSLOGN "SensNotifyOneStop() returned 0x%x\n", hr));
        }

    // Fire the event.
    SensFireEvent(&Data);

    return hr;
}





HRESULT
WininetLogoff(
    BSTR bstrUserName
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    HRESULT hr;
    SENS_NOTIFY_WINLOGON Data;

    hr = S_OK;

    //
    // Setup the data.
    //
    memset(&Data.Info, 0x0, sizeof(SENS_NOTIFY_WINLOGON));

    Data.eType = SENS_EVENT_LOGOFF;
    Data.Info.Size = sizeof(WINLOGON_INFO);
    Data.Info.Flags = 0x0;
    Data.Info.UserName = bstrUserName;
    Data.Info.Domain = NULL;
    Data.Info.WindowStation = NULL;
    Data.Info.hToken = NULL;;

    // First order of business - start OneStop if necessary.
    if (IsAutoSyncEnabled(NULL, AUTOSYNC_ON_LOGOFF))
        {
        hr = SensNotifyOneStop(NULL, SYNC_MANAGER_LOGOFF, FALSE);
        LogMessage((SENSLOGN "SensNotifyOneStop() returned 0x%x\n", hr));
        }

    // Fire the event.
    SensFireEvent(&Data);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\ipname.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ipname.cxx

Abstract:

    Miscellaneous helper routines to resolve names to IP Addresses.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    a. Class IP_ADDRESS_RESOLVER cloned from RPC Runtime Transport sources
       (rpc\runtime\trans\winnt\common\wstrans.cxx).

Revision History:

    GopalP          10/13/1997         Start.

--*/


#include <precomp.hxx>


#define BACKSLASH       ((SENS_CHAR) '\\')
#define HTTP_PREFIX1    (SENS_STRING("http://"))
#define HTTP_PREFIX2    (SENS_STRING("http:\\\\"))
#define HTTP_PREFIX_LEN 7




BOOL
GetNetBIOSName(
    IN TCHAR *ActualName,
    IN OUT TCHAR *SanitizedName
    )
/*++

Routine Description:

    Sanitize the name of the destination to make it more suitable for
    name resolution.

Arguments:

    ActualName - Original Name of the destination.

    SanitizedName - On return, this contains the sanitized version of the
        Actual Name. Memory is allocated by the caller.

Return Value:

    TRUE, if successful.

    FALSE, if the address if the address in invalid.

--*/
{
    TCHAR *pchTemp;

    //
    // Remove the leading \\ characters, if present.
    //
    pchTemp = ActualName;
    if (*pchTemp == BACKSLASH)
        {
        // Check for another slash
        if (*++pchTemp == BACKSLASH)
            {
            if (NULL != _tcschr(++pchTemp, BACKSLASH))
                {
                // Found yet another slash!
                return FALSE;
                }

            _tcscpy(SanitizedName, pchTemp);

            return TRUE;
            }
        else
            {
            return FALSE;
            }
        }

    //
    // Remove the "http://" prefix, if present.
    //
    pchTemp = ActualName;
    if (   (_tcsnicmp(HTTP_PREFIX1, ActualName, HTTP_PREFIX_LEN) == 0)
        || (_tcsnicmp(HTTP_PREFIX2, ActualName, HTTP_PREFIX_LEN) == 0))
        {
        _tcscpy(SanitizedName, (pchTemp + HTTP_PREFIX_LEN));

        return TRUE;
        }

    _tcscpy(SanitizedName, pchTemp);

    return TRUE;
}




DWORD
ResolveName(
    IN TCHAR *lpszDestination,
    OUT LPDWORD lpdwIpAddr
    )
/*++

Routine Description:

    Resolve the destination name to its IP Address.

Arguments:

    lpszDestination - Name of the destination of interest.

    lpdwIpAddr - On success, this contains the IP Address of the destination.

Note:

    Since this function depends on Winsock2 being loaded, there are 2 different
    implementations - one for Win9x and one for NT.

Return Value:

    ERROR_SUCCESS, if successful

    Error code from GetLastError(), otherwise

--*/
{
    RPC_STATUS status;
    TCHAR *lpszSanitizedName;
    DWORD dwReturnCode;
    DWORD bufsize;
    PVOID buf;
    BOOL bSuccess;

    if (   (lpdwIpAddr == NULL)
        || (lpszDestination == NULL))
        {
        return ERROR_INVALID_PARAMETER;
        }

    *lpdwIpAddr = 0x0;
    lpszSanitizedName = NULL;
    dwReturnCode = ERROR_HOST_UNREACHABLE;
    bSuccess = FALSE;

    lpszSanitizedName = (TCHAR*) new char[(sizeof(TCHAR) * (_tcslen(lpszDestination)+1))];
    if (!lpszSanitizedName)
        {
        return (ERROR_OUTOFMEMORY);
        }

    bSuccess = GetNetBIOSName(lpszDestination, lpszSanitizedName);
    if (bSuccess == FALSE)
        {
        SensPrint(SENS_INFO, (SENS_STRING("Bad format for destination name - %s\n"), lpszDestination));
        delete lpszSanitizedName;
        return (ERROR_INVALID_PARAMETER);
        }

    SensPrint(SENS_INFO, (SENS_STRING("Actual Name    - [%s]\n"), lpszDestination));
    SensPrint(SENS_INFO, (SENS_STRING("Sanitized Name - [%s]\n"), lpszSanitizedName));

#if !defined(SENS_CHICAGO)

    bufsize = sizeof(WSAQUERYSET) + IP_BUFFER_SIZE;
    buf = (PVOID) new char[bufsize];
    if (NULL == buf)
        {
        delete lpszSanitizedName;
        return (ERROR_OUTOFMEMORY);
        }

    IP_ADDRESS_RESOLVER resolver(lpszSanitizedName, bufsize, buf);

    status = resolver.NextAddress(lpdwIpAddr);

    switch (status)
        {
        case RPC_S_OK:
            dwReturnCode = ERROR_SUCCESS;
            break;

        case RPC_S_OUT_OF_MEMORY:
            dwReturnCode = ERROR_OUTOFMEMORY;
            break;

        case RPC_S_SERVER_UNAVAILABLE:
        default:
            //
            // Should we return HOST_NOT_FOUND in some cases depending
            // upon the WSAGetLastError() value? Maybe. But, the error
            // ERROR_HOST_UNREACHABLE is pretty close enough.
            //
            dwReturnCode = ERROR_HOST_UNREACHABLE;
            break;
        }


    //
    // Cleanup
    //
    if (NULL != lpszSanitizedName)
        {
        delete lpszSanitizedName;
        }
    if (NULL != buf)
        {
        delete buf;
        }

#else // SENS_CHICAGO

    struct hostent     *phostentry;
    unsigned long      host_addr;

    phostentry = NULL;
    host_addr = 0x0;

    if (*lpszDestination == '\0')
        {
        //
        // An empty hostname means the local machine
        //
        host_addr = htonl(INADDR_LOOPBACK);
        dwReturnCode = ERROR_SUCCESS;
        }
    else
        {
        //
        // First, assume a numeric address
        //
        host_addr = inet_addr(lpszDestination);
        if (host_addr == INADDR_NONE)
            {
            //
            // Not a numeric address. Try a friendly name
            //
            phostentry = gethostbyname(lpszDestination);

            if (phostentry == (struct hostent *)NULL)
                {
                dwReturnCode = ERROR_HOST_UNREACHABLE;
                SensPrintA(SENS_INFO, ("gethostbyname(%s) failed with a "
                           "WSAGetLastError() of %d!\n", lpszDestination,
                           WSAGetLastError()));
                }
            else
                {
                host_addr = *(unsigned long *)phostentry->h_addr;
                dwReturnCode = ERROR_SUCCESS;
                }
            }
        else
            {
            //
            // Destination is an IP address.
            //

            //
            // NOTE:
            //
            // a. gethostbyaddr() sometimes fails to resolve valid IP
            //    addresses. WSAGetLastError() returns WSANO_DATA. This
            //    is a problem with Win9x name resolution.
            // b. gethostbyaddr() is visibly slow on Win9x platforms. In
            //    SENS's case, is better to avoid this call.
            // c. We will just go ahead and use the host_addr returned
            //    from inet_addr() and try to do a programmatic ping.
            //

            dwReturnCode = ERROR_SUCCESS;
            }
        }

    *lpdwIpAddr = host_addr;

    SensPrintA(SENS_INFO, ("Resolved IP Address - [0x%x], dwReturnCode - %d\n",
               *lpdwIpAddr, dwReturnCode));

#endif // SENS_CHICAGO

    return (dwReturnCode);
}



#if !defined(SENS_CHICAGO)


RPC_STATUS
IP_ADDRESS_RESOLVER::NextAddress(
    OUT LPDWORD lpdwIpAddr
    )
/*++

Routine Description:

    Returns the next IP address associated with the Name
    parameter to the constructor.

    During the first call if check for loopback and for dotted numeric IP
    address formats.  If these fail then it begins a complex lookup
    (WSALookupServiceBegin) and returns the first available address.

    During successive calls in which a complex lookup was started
    it returns sucessive addressed returned by WSALookupServiceNext().

Arguments:

    lpdwIpAddr - If successful, the member is set to an IP address.

Return Value:

    RPC_S_OK - lpdwIpAddr points to a new IP address

    RPC_S_SERVER_UNAVAILABLE - Unable to find any more addresses

    RPC_S_OUT_OF_MEMORY - otherwise

--*/
{
    int err;
    RPC_STATUS status;

    *lpdwIpAddr = 0x0;

    // If this is the first call, _Name will be non-NULL and
    // we need to start the lookup process.

    if (_Name)
        {
        TCHAR *Name = _Name;
        _Name = 0;

        // Check for loopback first.
        if (! *Name)
            {
            // Loopback - assign result of htonl(INADDR_LOOPBACK)
            // Little-endian dependence.
            *lpdwIpAddr = 0x0100007F;
            return(RPC_S_OK);
            }

        // Assume dot address since this is faster to check.
        int size = sizeof(SOCKADDR_IN);
        SOCKADDR_IN addr;
        err = WSAStringToAddress(Name,
                                 AF_INET,
                                 0,
                                 (PSOCKADDR)&addr,
                                 &size);

        if (err != SOCKET_ERROR)
            {
            *lpdwIpAddr = addr.sin_addr.s_addr;
            return(RPC_S_OK);
            }

        ASSERT(GetLastError() == WSAEINVAL);

        // Start a complex query operation

        const static AFPROTOCOLS aIpProtocols[2] =
            {
            {AF_INET, IPPROTO_UDP},
            {AF_INET, IPPROTO_TCP}
            };

        const static GUID guidHostAddressByName = SVCID_INET_HOSTADDRBYNAME;
        WSAQUERYSET wsqs;

        memset(&wsqs, 0, sizeof(wsqs));
        wsqs.dwSize = sizeof(WSAQUERYSET);
        // wsqs.dwNameSpace = NS_ALL;
        ASSERT(NS_ALL == 0);
        wsqs.lpszServiceInstanceName = Name;
        wsqs.lpServiceClassId = (GUID *)&guidHostAddressByName;
        wsqs.dwNumberOfProtocols = 2;
        wsqs.lpafpProtocols = (PAFPROTOCOLS)&aIpProtocols[0];

        err = WSALookupServiceBegin(&wsqs,
                                    LUP_RETURN_ADDR,
                                    &_hRnr);

        if (err == SOCKET_ERROR)
            {
            SensPrintA(SENS_INFO, ("WSALookupServiceBegin() failed: %d\n", GetLastError()));
            return(RPC_S_SERVER_UNAVAILABLE);
            }

        _index = 0;

        if (_pwsqs)
            {
            _pwsqs->dwNumberOfCsAddrs = 0;
            }
        }
    else
        {
        if (!_hRnr)
            {
            // First call finished but didn't start a complex query.  Abort now.
            return(RPC_S_SERVER_UNAVAILABLE);
            }
        }

    // A complex query has been started.

    ASSERT(_hRnr);

    // If the cached query structure is empty, call WSALookupNext to get
    // more addresses.

    if (!_pwsqs || (_index >= _pwsqs->dwNumberOfCsAddrs))
        {

        DWORD needed = _size;

        // Loop needed to realloc a larger _pwsqs buffer.

        for(;;)
            {
            err = WSALookupServiceNext(_hRnr,
                                       0, // flags
                                       &needed,
                                       _pwsqs);

            // Success, break out of the loop.
            if (err != SOCKET_ERROR)
                {
                ASSERT(_pwsqs->dwNumberOfCsAddrs > 0);
                ASSERT(_pwsqs->lpcsaBuffer);

                // Reset to start of new result set.
                _index = 0;
                break;
                }

            status = GetLastError();

            // WSAEFAULT means the buffer was too small.

            if (status != WSAEFAULT)
                {
                // WSA_E_NO_MORE means all matching address have
                // already been returned.

                VALIDATE(status)
                    {
                    WSA_E_NO_MORE,
                    WSANO_DATA,
                    WSASERVICE_NOT_FOUND,
                    WSAHOST_NOT_FOUND,
                    WSATRY_AGAIN,
                    WSANO_RECOVERY,
                    WSANO_DATA,
                    WSAEINVAL   // In response to out of resources scenarios.
                    } END_VALIDATE;

                SensPrintA(SENS_ERR, ("WSALookupServiceNext() failed: %d\n", status));

                return(RPC_S_SERVER_UNAVAILABLE);
                }

            // Allocate a larger buffer.

            if (needed <= _size)
                {
                ASSERT(needed > _size);
                return(RPC_S_SERVER_UNAVAILABLE);
                }

            if (_fFree)
                {
                delete _pwsqs;
                }

            _pwsqs = (PWSAQUERYSET) new char[needed];
            //_pwsqs = new WSAQUERYSETW[(needed - sizeof(WSAQUERYSETW))];
            //_pwsqs = (PWSAQUERYSETW) new char(needed - sizeof(WSAQUERYSETW));
            if (!_pwsqs)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }

            _fFree = TRUE;
            _pwsqs->dwNumberOfCsAddrs = 0;
            _size = needed;

            #if DBG
            // On retail we start with enough space for two addresses during the
            // first call.  If this debug print gets hit too much we can increase the
            // starting size (IP_BUFFER_SIZE).
            if (_size > sizeof(WSAQUERYSET) + IP_RETAIL_BUFFER_SIZE)
                {
                SensPrintA(SENS_ERR, ("WSALookupServerNext(): sizeof(WSAQUERYSETW)  - %d\n"
                           "WSALookupServerNext(): IP_RETAIL_BUFFER_SIZE - %d\n",
                           sizeof(WSAQUERYSETW), IP_RETAIL_BUFFER_SIZE));
                SensPrintA(SENS_ERR, ("WSALookupServerNext() wants %d bytes.  Make this the "
                           "default?\n", _size));
                }
            #endif

            }
        }

    ASSERT(_pwsqs);
    ASSERT(_index < _pwsqs->dwNumberOfCsAddrs);

    LPCSADDR_INFO pInfo = &_pwsqs->lpcsaBuffer[_index];
    _index++;

    *lpdwIpAddr = ((SOCKADDR_IN *)pInfo->RemoteAddr.lpSockaddr)->sin_addr.s_addr;

    return(RPC_S_OK);
}



IP_ADDRESS_RESOLVER::~IP_ADDRESS_RESOLVER()
{
    if (_hRnr)
        {
        WSALookupServiceEnd(_hRnr);
        }

    if (_fFree)
        {
        delete _pwsqs;
        }
}

#endif // SENS_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\guids.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    guids.c

Abstract:

    Define the GUIDs used.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/10/1997         Start.

--*/



#pragma data_seg(".text")

#define INITGUID

#include <objbase.h>
#include <initguid.h>


// All guid header files
#include <coguid.h>
#include <ndisguid.h>
#include <ntddndis.h>
#include <wmium.h>
#include <sens.h>

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\dest.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    dest.cxx

Abstract:

    Code to keep track of reachability of the list destinations specified
    in Event System's Reachability Event subscriptions.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/31/1997         Start.

--*/


#include <precomp.hxx>


//
// Constants
//

#define SENS_REACHABILITY_POLLING_INTERVAL    5*60*1000   // 5 minutes
#define SENS_REACHABILITY_FIRST_SCAN_TIME     5*60*1000   // 5 minutes




//
// Globals
//

LIST    *gpReachList;
HANDLE  ghReachTimer;





BOOL
StartReachabilityEngine(
    void
    )
/*++

Routine Description:

    Start the Destination reachability engine.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    BOOL bRetVal;

    bRetVal = TRUE; // Note it is TRUE, by default.

    SensPrintA(SENS_INFO, ("StartReachabilityEngine(): Starting...\n"));

    RequestSensLock();

    if (ghReachTimer != NULL)
        {
        SensPrintA(SENS_INFO, ("StartReachabilityEngine(): Engine "
                   "already started!\n"));
        goto Cleanup;
        }

    //
    // Create a timer object to poll for destination reachability
    //
    SensSetTimerQueueTimer(
        bRetVal,                     // Bool return on NT5
        ghReachTimer,                // Handle return on IE5
        NULL,                        // Use default process timer queue
        ReachabilityPollingRoutine,  // Callback
        NULL,                        // Parameter
        SENS_REACHABILITY_FIRST_SCAN_TIME, // Time from now when timer should fire
        SENS_REACHABILITY_POLLING_INTERVAL,// Time inbetween firings of this timer
        0x0                          // No Flags.
        );
    if (SENS_TIMER_CREATE_FAILED(bRetVal, ghReachTimer))
        {
        SensPrintA(SENS_INFO, ("StartReachabilityEngine(): SensCancelTimerQueueTimer("
                   "Reachability) failed!\n"));
        bRetVal = FALSE;
        goto Cleanup;
        }


Cleanup:
    //
    // Cleanup
    //
    ReleaseSensLock();

    SensPrintA(SENS_INFO, ("StartReachabilityEngine(): Returning %s\n",
               bRetVal ? "TRUE" : "FALSE"));

    return bRetVal;
}




BOOL
StopReachabilityEngine(
    void
    )
/*++

Routine Description:

    Start the Destination reachability engine.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    BOOL bStatus;

    bStatus = TRUE; // Note it is TRUE, by default.

    SensPrintA(SENS_INFO, ("StopReachabilityEngine(): Stopping...\n"));

    RequestSensLock();

    //
    // Remove Reachability polling timer
    //
    if (NULL != ghReachTimer)
        {
        bStatus = SensCancelTimerQueueTimer(NULL, ghReachTimer, NULL);
        
        ghReachTimer = NULL;

        SensPrintA(SENS_INFO, ("StopReachabilityEngine(): SensCancelTimerQueueTimer("
                   "Reachability) %s\n", bStatus ? "succeeded" : "failed!"));
        }

    ReleaseSensLock();

    SensPrintA(SENS_INFO, ("StopReachabilityEngine(): Returning %s\n",
               bStatus ? "TRUE" : "FALSE"));

    return bStatus;
}




BOOL
InitReachabilityEngine(
    void
    )
/*++

Routine Description:

    Initialize the Reachability polling mechanism.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    BOOL bRetVal;

    bRetVal = FALSE;

    //
    // Initialize the list of destinations
    //
    gpReachList = new LIST();
    if (NULL == gpReachList)
        {
        goto Cleanup;
        }

    bRetVal = StartReachabilityEngine();

Cleanup:
    //
    // Cleanup
    //
    return bRetVal;
}




SENS_TIMER_CALLBACK_RETURN
ReachabilityPollingRoutine(
    PVOID pvIgnore,
    BOOLEAN bIgnore
    )
/*++

Routine Description:

    This routine is called periodically to walk through the reachability list
    to see if the destinations are reachable.

Arguments:

    pvIgnore - Ignored.

    bIgnore - Ignored.


Return Value:

    None.

--*/
{
    PNODE pTemp;
    DWORD OldState;
    QOCINFO DestQOCInfo;
    DWORD dwLastError;
    char *DestinationA;
    static BOOL bGotDestinations = FALSE;

    //
    // Get the list of destinations, if necessary.
    //
    if (FALSE == bGotDestinations)
        {
        HRESULT hr;

        hr = GetDestinationsFromSubscriptions();
        if (SUCCEEDED(hr))
            {
            bGotDestinations = TRUE;
            }
        else
            {
            SensPrintA(SENS_ERR, ("InitReachabilityPolling(): GetDestinations"
                       "FromSubscriptions() failed with 0x%x.\n", hr));
            }
        }

    SensPrintA(SENS_INFO, ("ReachabilityPollingRoutine(): Checking "
                           "Destinations for reachability.\n"));


    // PERF NOTE: Critsec held too long!
    gpReachList->RequestLock();

    if (gpReachList->IsEmpty() == TRUE)
        {
        StopReachabilityEngine();
        gpReachList->ReleaseLock();
        return;
        }

    //
    // Loop through all destinations checking for reachability.
    //

    pTemp = gpReachList->pHead;
    while (pTemp != NULL)
        {
        error_status_t status;

        // Save old reachability state.
        OldState = pTemp->State;

        //
        // Is it Reachable?
        //
        dwLastError = ERROR_SUCCESS;
        DestQOCInfo.dwSize = sizeof(QOCINFO);

        status = RPC_IsDestinationReachableW(
                           NULL,
                           pTemp->Destination,
                           &DestQOCInfo,
                           (LPBOOL) &pTemp->State,
                           &dwLastError
                           );

        ASSERT(status == RPC_S_OK);

        if (   (pTemp->State != OldState)
            && (dwLastError == ERROR_SUCCESS))
            {
            // Fire the Event!
            SENSEVENT_REACH Data;

            Data.eType = SENS_EVENT_REACH;
            Data.bReachable = pTemp->State;
            Data.Destination = pTemp->Destination;
            memcpy(&Data.QocInfo, &DestQOCInfo, DestQOCInfo.dwSize);
            // NOTE: Set the following field appropriately. This is the best we can do.
            Data.strConnection = DEFAULT_LAN_CONNECTION_NAME;

            SensFireEvent((PVOID)&Data);
            }

        if (dwLastError != ERROR_SUCCESS)
            {
            SensPrintW(SENS_INFO, (L"ReachabilityPollingRoutine(): %s is not reachable - %d\n",
                       pTemp->Destination, dwLastError));

            if (ERROR_INVALID_PARAMETER == dwLastError)
                {
                // Remove the destination from further reachability checks.
                gpReachList->DeleteByDest(pTemp->Destination);
                }
            }

        pTemp = pTemp->Next;
        } // while()

    gpReachList->ReleaseLock();

    //
    // Dump the list
    //
    gpReachList->Print();

}





HRESULT
GetDestinationsFromSubscriptions(
    void
    )
/*++

Routine Description:

    Retrieve the names of destinations from Reachability subscriptions and
    insert into the Reachability List.

Arguments:

    None.

Return Value:

    S_OK, on success.

    HRESULT, on failure.

--*/
{
    HRESULT                 hr;
    int                     errorIndex;
    LONG                    lCount;
    BSTR                    bstrPropertyName;
    BSTR                    bstrEventClassID;
    VARIANT                 variantPropertyValue;
    WCHAR                   wszQuery[MAX_QUERY_SIZE];
    LPOLESTR                strGuid;
    IEventSystem            *pIEventSystem;
    IEventSubscription      *pIEventSubscription;
    IEventObjectCollection  *pSubscriptionCollection;
    IEnumEventObject        *pIEnumEventObject;

    hr = S_OK;
    lCount = 0;
    errorIndex = 0;
    strGuid = NULL;
    bstrPropertyName = NULL;
    bstrEventClassID = NULL;
    pIEventSystem = NULL;
    pIEventSubscription = NULL;
    pSubscriptionCollection = NULL;
    pIEnumEventObject = NULL;


    // Get a new IEventSystem object to play with.
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &pIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): failed to create ")
                  SENS_STRING("IEventSystem - hr = <%x>\n"), hr));
        goto Cleanup;
        }

    //
    // Form the query.
    //
    // (EventClassID = NetEventClassID) AND
    // (   (MethodName = 'DestinationReachable')
    //  OR (MethodName = 'DestinationReachableNoQocInfo'))
    //

    AllocateBstrFromGuid(bstrEventClassID, SENSGUID_EVENTCLASS_NETWORK);
    wcscpy(wszQuery, SENS_BSTR("(EventClassID"));
    wcscat(wszQuery, SENS_BSTR("="));
    wcscat(wszQuery, bstrEventClassID);
    wcscat(wszQuery, SENS_BSTR(") AND (("));
    wcscat(wszQuery, SENS_BSTR("MethodName = \'"));
    wcscat(wszQuery, DESTINATION_REACHABLE_METHOD);
    wcscat(wszQuery, SENS_BSTR("\') OR ("));
    wcscat(wszQuery, SENS_BSTR("MethodName = \'"));
    wcscat(wszQuery, DESTINATION_REACHABLE_NOQOC_METHOD);
    wcscat(wszQuery, SENS_BSTR("\'))"));

    hr = pIEventSystem->Query(
                            PROGID_EventSubscriptionCollection,
                            wszQuery,
                            &errorIndex,
                            (LPUNKNOWN *) &pSubscriptionCollection
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): failed to Query() ")
                  SENS_STRING("- hr = <%x>\n"), hr));
        SensPrint(SENS_ERR, (SENS_STRING("errorIndex = %d\n"), errorIndex));
        goto Cleanup;
        }
    SensPrint(SENS_ERR, (SENS_STRING("Query = %s, hr = 0x%x\n"), wszQuery, hr));

#if DBG
    hr = pSubscriptionCollection->get_Count(&lCount);
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                  SENS_STRING("get_Count() returned hr = <%x>\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
              SENS_STRING("Found %d Reachability subscriptions.\n"), lCount));

    if (0 == lCount)
        {
        goto Cleanup;
        }
#endif // DBG

    // Get a new Enum object to play with.
    hr = pSubscriptionCollection->get_NewEnum(
                                      (IEnumEventObject **) &pIEnumEventObject
                                      );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                  SENS_STRING("get_NewEnum() returned hr = <%x>\n"), hr));
        goto Cleanup;
        }

    hr = S_OK;
    hr = pIEnumEventObject->Reset();

    //
    // Extract each destination name and insert into list.
    //
    while (S_OK == hr)
        {
        ULONG cElements = 1;

        hr = pIEnumEventObject->Next(
                                    cElements,
                                    (LPUNKNOWN *) &pIEventSubscription,
                                    &cElements
                                    );
        if (   (S_OK != hr)
            || (1 != cElements))
            {
            SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                      SENS_STRING("Next() failed hr = <%x>, count = %d\n"), hr, cElements));
            goto Cleanup;
            }

        //
        // Try to get the value for Publisher property - bstrDestination
        //
        VariantInit(&variantPropertyValue);
        AllocateBstrFromString(bstrPropertyName, PROPERTY_DESTINATION);

        hr = pIEventSubscription->GetPublisherProperty(
                                      bstrPropertyName,
                                      &variantPropertyValue
                                      );
        if (hr == S_OK)
            {
            // Found the property!
            gpReachList->InsertByDest(variantPropertyValue.bstrVal);
            SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                      SENS_STRING("Added to Reachability List: %s\n"),
                      variantPropertyValue.bstrVal));
            goto ProcessNextSubscription;
            }

        //
        // Now, try to get the value for Publisher property - bstrDestinationNoQOC
        //
        FreeBstr(bstrPropertyName);
        VariantInit(&variantPropertyValue);
        AllocateBstrFromString(bstrPropertyName, PROPERTY_DESTINATION_NOQOC);

        hr = pIEventSubscription->GetPublisherProperty(
                                      bstrPropertyName,
                                      &variantPropertyValue
                                      );
        if (hr == S_OK)
            {
            // Found the property!
            gpReachList->InsertByDest(variantPropertyValue.bstrVal);
            SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): ")
                      SENS_STRING("Added to Reachability List: %s\n"),
                      variantPropertyValue.bstrVal));
            goto ProcessNextSubscription;
            }

        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationsFromSubscriptions(): failed to get ")
                  SENS_STRING("PublisherProperty - hr = <%x>\n"), hr));


ProcessNextSubscription:

        VariantClear(&variantPropertyValue);
        FreeBstr(bstrPropertyName);

        pIEventSubscription->Release();
        pIEventSubscription = NULL;
        hr = S_OK;
        } // while()


Cleanup:
    //
    // Cleanup
    //
    if (pIEventSystem)
        {
        pIEventSystem->Release();
        }
    if (pIEventSubscription)
        {
        pIEventSubscription->Release();
        }
    if (pSubscriptionCollection)
        {
        pSubscriptionCollection->Release();
        }
    if (pIEnumEventObject)
        {
        pIEnumEventObject->Release();
        }

    FreeBstr(bstrEventClassID);
    FreeStr(strGuid);

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\memory.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    memory.cxx

Abstract:

    This file contains common routines for memory allocation in SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/30/1997         Start.

--*/

#include <precomp.hxx>


extern HANDLE ghSensHeap;



void * __cdecl
operator new(
    IN size_t size
    )
{
    return (HeapAlloc(ghSensHeap, 0, size));
}



void __cdecl
operator delete(
    IN void * lpvObj
    )
{
    HeapFree(ghSensHeap, 0, lpvObj);
}



extern "C" void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t len
    )
{
    return (new char[len]);
}



extern "C" void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR * ptr
    )
{
    delete ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\csubchng.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    csubchng.cxx

Abstract:

    This file contains the implementation of the IEventObjectChange
    interface. We need to subscribe to this interface for publishing
    the DestinationReachable events of SENS's ISensNetwork interface.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/26/1998         Start.

--*/



#include <precomp.hxx>


//
// Globals
//
LONG g_cSubChangeObj;      // Count of active components
LONG g_cSubChangeLock;     // Count of Server locks
extern LIST    *gpReachList;



//
// Constructors and Destructors
//
CImpIEventObjectChange::CImpIEventObjectChange(
    void
    ) : m_cRef(1L) // Add a reference.
{
    InterlockedIncrement(&g_cSubChangeObj);
}

CImpIEventObjectChange::~CImpIEventObjectChange(
    void
    )
{
    InterlockedDecrement(&g_cSubChangeObj);
}




//
// Standard QueryInterface
//
STDMETHODIMP
CImpIEventObjectChange::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    HRESULT hr;

    DebugTraceGuid("CImpIEventObjectChange:QueryInterface()", riid);

    hr = S_OK;
    *ppv = NULL;

    // IUnknown
    if (IsEqualIID(riid, IID_IUnknown))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
    // IEventObjectChange
    if (IsEqualIID(riid, IID_IEventObjectChange))
        {
        *ppv = (ISensNetwork *) this;
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        }

    return hr;
}




//
// Standard AddRef and Release
//
STDMETHODIMP_(ULONG)
CImpIEventObjectChange::AddRef(
    void
    )
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CImpIEventObjectChange::Release(
    void
    )
{
    LONG cRefT;

    SensPrint(SENS_INFO, (SENS_STRING("\t| CImpIEventObjectChange::Release(m_cRef = %d) called.\n"), m_cRef));

    cRefT = InterlockedDecrement((PLONG) &m_cRef);

    if (0 == m_cRef)
        {
        delete this;
        }

    return cRefT;
}




//
// IEventObjectChange Implementation.
//

STDMETHODIMP
CImpIEventObjectChange::ChangedSubscription(
    EOC_ChangeType changeType,
    BSTR bstrSubscriptionID
    )
{
    HRESULT hr;
    NODE *pNode;
    DWORD dwStatus;
    BOOL bSuccess;
    BSTR bstrDestinationName;

    hr = S_OK;
    pNode = NULL;
    dwStatus = ERROR_SUCCESS;
    bSuccess = FALSE;
    bstrDestinationName = NULL;

    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpIEventObjectChange::ChangedSubscription() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("            ChangeType - %d\n"), changeType));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrSubscriptionID - %s\n"), bstrSubscriptionID));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    hr = GetDestinationNameFromSubscription(
              bstrSubscriptionID,
              &bstrDestinationName
              );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription() returned 0x%x\n"), hr));
        if (HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION) == hr)
            {
            hr = S_OK;  // Implies we got a non-DestinationReachability subscription.
            }
        goto Cleanup;
        }
    else
    if (bstrDestinationName == NULL)
        {
        SensPrintW(SENS_WARN, (SENS_BSTR("Destination is <NULL> !\n")));
        goto Cleanup;
        }
    else
        {
        SensPrintW(SENS_INFO, (SENS_BSTR("Destination is %s\n"), bstrDestinationName));
        }

    //
    // Deal with the changed subscription appropriately.
    //
    switch (changeType)
        {
        case EOC_NewObject:
            {
            if (wcslen(bstrDestinationName) > MAX_DESTINATION_LENGTH)
                {
                SensPrintW(SENS_ERR, (SENS_BSTR("Destination %s is too long.\n"), bstrDestinationName));
                break;
                }

            gpReachList->InsertByDest(bstrDestinationName);
            StartReachabilityEngine();
            break;
            }

        case EOC_DeletedObject:
            // Delete the node from the reachability list.
            bSuccess = gpReachList->DeleteByDest(bstrDestinationName);
            break;

        case EOC_ModifiedObject:
        default:
            // Nothing to do.
            break;;
        }

Cleanup:
    //
    // Cleanup
    //
    if (bstrDestinationName)
        {
        ::SysFreeString(bstrDestinationName);
        }

    return hr;
}

STDMETHODIMP
CImpIEventObjectChange::ChangedEventClass(
    EOC_ChangeType changeType,
    BSTR bstrSubscriptionID
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpIEventObjectChange::ChangedEventClass() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("            ChangeType - %d\n"), changeType));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrSubscriptionID - %s\n"), bstrSubscriptionID));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    return S_OK;
}

STDMETHODIMP
CImpIEventObjectChange::ChangedPublisher(
    EOC_ChangeType changeType,
    BSTR bstrSubscriptionID
    )
{
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));
    SensPrint(SENS_INFO, (SENS_STRING("CImpIEventObjectChange::ChangedPublisher() called\n\n")));
    SensPrint(SENS_INFO, (SENS_STRING("            ChangeType - %d\n"), changeType));
    SensPrintW(SENS_INFO, (SENS_BSTR("    bstrSubscriptionID - %s\n"), bstrSubscriptionID));
    SensPrint(SENS_INFO, (SENS_STRING("---------------------------------------------------------\n")));

    return S_OK;
}



HRESULT
GetDestinationNameFromSubscription(
    BSTR bstrSubscriptionID,
    BSTR *pbstrDestinationName
    )
{
    HRESULT             hr;
    int                 errorIndex;
    BSTR                bstrPropertyName;
    BSTR                bstrMethodName;
    VARIANT             variantPropertyValue;
    WCHAR               wszQuery[MAX_QUERY_SIZE];
    LPOLESTR            strDestinationName;
    IEventSystem        *pIEventSystem;
    IEventSubscription  *pIEventSubscription;
    IUnknown            *pIUnkQueryResult;

    hr = S_OK;
    errorIndex = 0;
    strDestinationName = NULL;
    bstrPropertyName = NULL;
    bstrMethodName = NULL;
    *pbstrDestinationName = NULL;
    pIEventSystem = NULL;
    pIEventSubscription = NULL;
    pIUnkQueryResult = NULL;


    // Get a new IEventSystem object to play with.
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &pIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): failed to create ")
                  SENS_STRING("IEventSystem - hr = <%x>\n"), hr));
        goto Cleanup;
        }

    // Form the query
    wcscpy(wszQuery, SENS_BSTR("SubscriptionID"));
    wcscat(wszQuery, SENS_BSTR("="));
    wcscat(wszQuery, bstrSubscriptionID);
    wcscat(wszQuery, SENS_BSTR(""));

    hr = pIEventSystem->Query(
                            PROGID_EventSubscription,
                            wszQuery,
                            &errorIndex,
                            &pIUnkQueryResult
                            );
    if (hr != S_OK)
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): failed to Query() ")
                  SENS_STRING("- hr = <%x>\n"), hr));
        goto Cleanup;
        }

    hr = pIUnkQueryResult->QueryInterface(
                               IID_IEventSubscription,
                               (LPVOID *) &pIEventSubscription
                               );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): QI for IEventSubscription")
                  SENS_STRING(" failed - hr = <%x>\n"), hr));
        goto Cleanup;
        }

    //
    // See if it is a subscription for Destination Reachability event. If not,
    // return success. If yes, try to get the value for Publisher property -
    // bstrDestination.
    //
    hr = pIEventSubscription->get_MethodName(
                                  &bstrMethodName
                                  );
    if (hr != S_OK)
        {
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): get_MethodName()")
                  SENS_STRING(" failed - hr = <%x>\n"), hr));
        goto Cleanup;
        }
    if (   (wcscmp(bstrMethodName, DESTINATION_REACHABLE_METHOD) != 0)
        && (wcscmp(bstrMethodName, DESTINATION_REACHABLE_NOQOC_METHOD) != 0))
        {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): Non-Reachability event")
                  SENS_STRING(" subscription (%s). Returning - hr = <%x>\n"), bstrMethodName, hr));
        goto Cleanup;
        }

    //
    // Try to get the value for Publisher property - bstrDestination
    //
    VariantInit(&variantPropertyValue);
    AllocateBstrFromString(bstrPropertyName, PROPERTY_DESTINATION);

    hr = pIEventSubscription->GetPublisherProperty(
                                  bstrPropertyName,
                                  &variantPropertyValue
                                  );
    if (hr == S_OK)
        {
        *pbstrDestinationName = variantPropertyValue.bstrVal;
        // Found the property!
        goto Cleanup;
        }

    //
    // Now, try to get the value for Publisher property - bstrDestinationNoQOC
    //
    FreeBstr(bstrPropertyName);
    VariantInit(&variantPropertyValue);
    AllocateBstrFromString(bstrPropertyName, PROPERTY_DESTINATION_NOQOC);

    hr = pIEventSubscription->GetPublisherProperty(
                                  bstrPropertyName,
                                  &variantPropertyValue
                                  );
    if (hr == S_OK)
        {
        // Found the property!
        *pbstrDestinationName = variantPropertyValue.bstrVal;
        goto Cleanup;
        }

    SensPrint(SENS_ERR, (SENS_STRING("GetDestinationNameFromSubscription(): failed to get ")
              SENS_STRING("PublisherProperty - hr = <%x>\n"), hr));

Cleanup:
    //
    // Cleanup
    //
    if (pIEventSystem)
        {
        pIEventSystem->Release();
        }
    if (pIEventSubscription)
        {
        pIEventSubscription->Release();
        }
    if (pIUnkQueryResult)
        {
        pIUnkQueryResult->Release();
        }

    FreeBstr(bstrPropertyName);
    FreeBstr(bstrMethodName);

    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\lan.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    lan.cxx

Abstract:

    This is the source file relating to the LAN-specific routines of the
    Connectivity APIs implementation.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include <precomp.hxx>


//
// Constants
//

#define GETIFTABLE          GetIfTable
#define GETIPADDRTABLE      GetIpAddrTable
#define GETIPFORWARDTABLE   GetIpForwardTable
#define GETRTTANDHOPCOUNT   GetRTTAndHopCount
#define GETIPSTATISTICS     GetIpStatistics

#define MAX_IFTABLE_ROWS                4
#define MAX_IPADDRTABLE_ROWS            6
#define MAX_IPNETTABLE_ROWS             8
#define MAX_IPFORWARDTABLE_ROWS         8
#define MAX_HOPS_COUNT                  0xFFFF
#define BROADCAST_ACTIVITY_THRESHOLD    2                   // +2 thru -2
#define MEDIASENSE_INITIALIZATION_DELAY 3*25*1000           // 1:15 minutes
#define MEDIASENSE_EVALUATE_LAN_DELAY   5*1000              // 5 seconds

#define SENS_WINSOCK_VERSION        MAKEWORD( 2, 0 )

//
// Globals
//

BOOL        gbIpInitSuccessful;
long        gdwLastLANTime;
long        gdwLANState;
IF_STATE    gIfState[MAX_IF_ENTRIES];
MIB_IPSTATS gIpStats;
extern CRITICAL_SECTION gSensLock;

HANDLE ghMediaTimer;
DWORD  gdwMediaSenseState;

//
// Macros
//



/*++

Macro Description:

    A macro to help in allocating tables when calling IP Helper APIs.

Arguments:

    TABLE_TYPE - The type of the IP Table being queried.

    ROW_TYPE - The type of the Row corresponding to the TABLE_TYPE.

    FUNC_NAME - The IP API to be called to get the IP table.

    MAX_NUM_ROWS - The default number of rows for the table which is
        being retrieved. These rows are allocated on the stack.

Notes:

    o   lpdwLastError should be defined as an LPDWORD in the code
        fragment that uses this macro.

--*/
#define                                                             \
BEGIN_GETTABLE(                                                     \
    TABLE_TYPE,                                                     \
    ROW_TYPE,                                                       \
    FUNC_NAME,                                                      \
    MAX_NUM_ROWS                                                    \
    )                                                               \
    {                                                               \
    DWORD dwOldSize;                                                \
    DWORD dwSize;                                                   \
    DWORD dwStatus;                                                 \
                                                                    \
    BOOL bOrder;                                                    \
                                                                    \
    TABLE_TYPE *pTable;                                             \
                                                                    \
    bOrder = FALSE;                                                 \
                                                                    \
    dwSize = sizeof(DWORD) + MAX_NUM_ROWS * sizeof(ROW_TYPE);       \
	pTable = (TABLE_TYPE *) new char[dwSize];                       \
    if (pTable == NULL)                                             \
        {                                                           \
        SensPrintA(SENS_MEM, (#FUNC_NAME "(): failed to new %d bytes\n",        \
                  dwSize));                                         \
        *lpdwLastError = ERROR_OUTOFMEMORY;                         \
        return FALSE;                                               \
        }                                                           \
                                                                    \
    dwOldSize = dwSize;                                             \
                                                                    \
    dwStatus = FUNC_NAME(                                           \
                   pTable,                                          \
                   &dwSize,                                         \
                   bOrder                                           \
                   );                                               \
                                                                    \
    if (   (dwStatus == ERROR_INSUFFICIENT_BUFFER)                  \
        || (dwStatus == ERROR_MORE_DATA))                           \
        {                                                           \
		ASSERT(dwSize > dwOldSize);                                 \
        SensPrintA(SENS_WARN, (#FUNC_NAME "(%d): reallocing buffer to be %d bytes\n",   \
                   dwOldSize, dwSize));                             \
        delete (char *)pTable;                                      \
        pTable = (TABLE_TYPE *) new char[dwSize];                   \
        if (pTable != NULL)                                         \
            {                                                       \
            dwStatus = FUNC_NAME(                                   \
                           pTable,                                  \
                           &dwSize,                                 \
                           bOrder                                   \
                           );                                       \
            }                                                       \
        else                                                        \
            {                                                       \
            SensPrintA(SENS_MEM, (#FUNC_NAME "(): failed to new (%d) bytes\n",      \
                      dwSize));                                     \
            *lpdwLastError = ERROR_OUTOFMEMORY;                     \
            return FALSE;                                           \
            }                                                       \
        }                                                           \
                                                                    \
    if (dwStatus != 0)                                              \
        {                                                           \
        ASSERT(   (dwStatus != ERROR_INSUFFICIENT_BUFFER)           \
               && (dwStatus != ERROR_MORE_DATA));                   \
                                                                    \
        SensPrintA(SENS_ERR, (#FUNC_NAME "() returned %d\n", dwStatus));\
        *lpdwLastError = dwStatus;                                  \
        /* P3 BUG: Might need to fire ConnectionLost() here */      \
        gdwLANState = FALSE;                                        \
        UpdateSensCache(LAN);                                       \
		delete pTable;                                              \
        return FALSE;                                               \
        }


/*++

Macro Description:

    This macro ends the BEGIN_GETTABLE() macro.

Arguments:

    None.

Notes:

    a. If we have a return between BEGIN_XXX and END_XXX, we need to make
       sure that we free pTable.

--*/
#define                                                             \
END_GETTABLE()                                                      \
                                                                    \
    delete pTable;                                                  \
                                                                    \
    }




BOOL
DoLanSetup(
    void
    )
/*++

Routine Description:



Arguments:

    None.

Return Value:



--*/
{
    BOOL bRetValue;
    WORD wVersionRequested;
    WSADATA wsaData;
    int err;

    bRetValue = FALSE;

    //
    // NT5-specific stuff
    //
#if defined(SENS_NT5)

    ghMediaTimer = NULL;

    // Register for Media-sense notifications
    if (FALSE == MediaSenseRegister())
        {
        SensPrintA(SENS_ERR, ("%s MediaSenseRegister() failed.\n", SERVICE_NAME));
        }

#endif // SENS_NT5

    //
    // AOL-specific code
    //
#if defined(AOL_PLATFORM)
    gdwAOLState = FALSE;
#endif // AOL_PLATFORM

    //
    // Initialize Winsock.
    //
    wVersionRequested = SENS_WINSOCK_VERSION;
    err = WSAStartup(wVersionRequested, &wsaData);
    if (err != 0)
        {
        SensPrintA(SENS_ERR, ("WSAStartup() returned %d!\n", err));
        bRetValue = FALSE;
        goto Cleanup;
        }

    bRetValue = TRUE;

Cleanup:
    //
    // Cleanup
    //
#if defined(SENS_NT4)
    if (   (FALSE == bRetValue)
        && (NULL != hDLL))
        {
        FreeLibrary(hDLL);
        }
#endif // SENS_NT4

    return bRetValue;
}



#ifdef DBG


inline void
PrintIfState(
    void
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    int i;

    SensPrintA(SENS_INFO, ("|---------------------------------------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("| Valid   Index  UcastIN  UcastOUT  NUcastIN  NUcastOUT  ErrIN  ErrOUT  DiscIN  DiscOUT |\n"));
    SensPrintA(SENS_INFO, ("|---------------------------------------------------------------------------------------|\n"));

    for (i = 0; i < MAX_IF_ENTRIES; i++)
        {
        SensPrintA(SENS_INFO, ("|   %c  %9d %7d %7d %9d %9d   %5d  %6d  %6d  %6d    |\n",
                   gIfState[i].fValid ? 'Y' : 'N',
                   gIfState[i].dwIndex,
                   gIfState[i].dwInUcastPkts,
                   gIfState[i].dwOutUcastPkts,
                   gIfState[i].dwInNUcastPkts,
                   gIfState[i].dwOutNUcastPkts,
                   gIfState[i].dwInErrors,
                   gIfState[i].dwOutErrors,
                   gIfState[i].dwInDiscards,
                   gIfState[i].dwOutDiscards)
                   );
        }

    SensPrintA(SENS_INFO, ("|---------------------------------------------------------------------------------------|\n"));
}

#else  // DBG

#define PrintIfState()      // Nothing

#endif // DBG



#ifdef DETAIL_DEBUG

void
PrintIfTable(
    MIB_IFTABLE *pTable
    )
{
    int i;

    SensPrintA(SENS_INFO, ("|------------------------------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("| Type   Index Spd/1K UcastIN UcastOUT ErrorIN OUT DiscIN OUT Opr Adm          |\n"));
    SensPrintA(SENS_INFO, ("|------------------------------------------------------------------------------|\n"));

    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        SensPrintA(SENS_INFO, ("| %4d %7d %6d %7d %8d %7d %3d %6d %3d %3d %3d           |\n",
                   pTable->table[i].dwType,
                   pTable->table[i].dwIndex,
                   pTable->table[i].dwSpeed/1000,
                   pTable->table[i].dwInUcastPkts,
                   pTable->table[i].dwOutUcastPkts,
                   pTable->table[i].dwInErrors,
                   pTable->table[i].dwOutErrors,
                   pTable->table[i].dwInDiscards,
                   pTable->table[i].dwOutDiscards,
                   pTable->table[i].dwOperStatus,
                   pTable->table[i].dwAdminStatus
                               )
                   );
        }

    SensPrintA(SENS_INFO, ("|------------------------------------------------------------------------------|\n"));

}

void
PrintIpStats(
    void
    )
{

    SensPrintA(SENS_INFO, ("|------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("| IP_STATS   InReceives OutRequests  |\n"));
    SensPrintA(SENS_INFO, ("|------------------------------------|\n"));

    SensPrintA(SENS_INFO, ("|          %10d   %10d   |\n",
               gIpStats.dwInReceives,
               gIpStats.dwOutRequests)
               );

    SensPrintA(SENS_INFO, ("|------------------------------------|\n"));

}

#else

#define PrintIfTable(_X_)   // Nothing

#define PrintIpStats()   // Nothing

#endif // DETAIL_DEBUG

BOOL WINAPI
EvaluateLanConnectivityDelayed(
    LPDWORD
    )
{
    for (int i = 0; i < 4; i++)
        {
        Sleep(MEDIASENSE_EVALUATE_LAN_DELAY*i);  // First time waits 0 ms, no delay

        if (EvaluateLanConnectivity(NULL))
            {
            SensPrintA(SENS_INFO, ("EvaluateLanConnectivity: Delayed eval successful (%d)\n", i));
            return TRUE;
            }
        }
    return FALSE;
}



BOOL WINAPI
EvaluateLanConnectivity(
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Evaluates LAN Connectivity.

Arguments:

    lpdwLastError - if return value is FALSE, GetLastError is returned
        in this OUT parameter.

Notes:

    a. This routine can be entered by multiple threads at the same time.
       Currently only very essential code is under a critical section.

    b. This routine can be executed as a threadpool work item.

Return Value:

    TRUE, if LAN connectivity is present.

    FALSE, otherwise

--*/
{
    DWORD dwNow;
    DWORD dwLocalLastError;
    DWORD dwActiveInterfaceSpeed;
    WCHAR wszActiveInterfaceName[MAX_INTERFACE_NAME_LEN];
    BOOL bLanAlive;
    BOOL bSomeInterfaceActive;
    BOOL bCheckCache;

    dwNow = GetTickCount();
    dwLocalLastError = ERROR_NO_NETWORK;
    dwActiveInterfaceSpeed = 0x0;
    bLanAlive = FALSE;
    bSomeInterfaceActive = FALSE;
    bCheckCache = FALSE;

    if (lpdwLastError)
        {
        *lpdwLastError = dwLocalLastError;
        }
    else
        {
        lpdwLastError = &dwLocalLastError;
        }

    //
    // Get infomation about IP statistics.
    //

    BEGIN_GETTABLE(MIB_IFTABLE, MIB_IFROW, GETIFTABLE, MAX_IFTABLE_ROWS)

    //
    // PurgeStaleInterfaces
    //
    PurgeStaleInterfaces(pTable, lpdwLastError);

    //
    // Algorithm:
    //
    // o Create a record.
    // o See if this record exists.
    // o Save the record, if not and return success.
    // o If it does exist, compare. If greater, then save record.
    // o If not greater, try other entries.
    // o All entries? return failure.
    //
    IF_STATE ifEntry;
    DWORD i;

    SensPrintA(SENS_INFO, ("GetIfTable(): Number of entries - %d.\n", pTable->dwNumEntries));

    PrintIfTable(pTable);

    i = 0;
    while (i < pTable->dwNumEntries)
        {
        //
        // Calculate only if it is a non-WAN and non-Loopback interface.
        //
        if (   (pTable->table[i].dwType != MIB_IF_TYPE_PPP)
            && (pTable->table[i].dwType != MIB_IF_TYPE_SLIP)
            && (pTable->table[i].dwType != MIB_IF_TYPE_LOOPBACK))
            {
            BOOL bForceInvalid = FALSE;

            //
            // BOOT UP WITH NO NETWORK:
            //
            // Check to see if both UnicastIN and UnicastOUT are zero. If so,
            // this interface is considered as not active and we skip it.
            //
            if (   (pTable->table[i].dwInUcastPkts == 0)
                && (pTable->table[i].dwOutUcastPkts == 0))
                {
                bForceInvalid = TRUE;
                }

            //
            // Check if networking says it is connected, if not, skip it.
            //
            if (pTable->table[i].dwOperStatus < MIB_IF_OPER_STATUS_CONNECTING)
                {
                SensPrintA(SENS_INFO, ("GetIfTable: Found interface %d in < connecting state (%d), ignored\n",
                           pTable->table[i].dwIndex, pTable->table[i].dwOperStatus) );
                bForceInvalid = TRUE;
                }

            //
            // At this stage, there is some Unicast activity on this interface.
            // So, we can skip the check for Unicast activity below.
            //

            // Fill the IF_STATE structure
            ifEntry.dwIndex = pTable->table[i].dwIndex;
            ifEntry.dwInUcastPkts = pTable->table[i].dwInUcastPkts;
            ifEntry.dwOutUcastPkts = pTable->table[i].dwOutUcastPkts;
            ifEntry.dwInNUcastPkts = pTable->table[i].dwInNUcastPkts;
            ifEntry.dwOutNUcastPkts = pTable->table[i].dwOutNUcastPkts;
            ifEntry.dwInErrors = pTable->table[i].dwInErrors;
            ifEntry.dwOutErrors = pTable->table[i].dwOutErrors;
            ifEntry.dwInDiscards = pTable->table[i].dwInDiscards;
            ifEntry.dwOutDiscards = pTable->table[i].dwOutDiscards;

            bSomeInterfaceActive = HasIfStateChanged(ifEntry, bForceInvalid);
            if (TRUE == bSomeInterfaceActive)
                {
                bLanAlive = TRUE;

                // Save info about interface for later use.
                    dwActiveInterfaceSpeed = pTable->table[i].dwSpeed;
                    wcscpy(wszActiveInterfaceName, pTable->table[i].wszName);
                }
            else
                {
                if (!bForceInvalid)
                    {
                    bCheckCache = TRUE; // Idle IF found but still valid (enable MAX_LAN_INTERNAL check below)
                    }
                }
            }

        i++;

        } // while ()

    PrintIfState();

    END_GETTABLE()


    //
    // RACE Condition Fix:
    //
    // If there are 2 threads that are in EvaluateLanConnectivity() and one
    // of them updates the interface's packet cache, then there is a distinct
    // possibility that the second thread will compare with the updated cache
    // and wrongly conclude that there is no activity. We ignore any loss of
    // connectivity that was evaluated before MAX_LAN_INTERVAL (ie., we should
    // keep giving cached information for MAX_LAN_INTERVAL seconds).
    //
    if (   (TRUE == bCheckCache)
        && (FALSE == bLanAlive) )
        {

        dwNow = GetTickCount();
        if (   ((dwNow - gdwLastLANTime) <= MAX_LAN_INTERVAL)
            && (gdwLastLANTime != 0) )
            {
            SensPrintA(SENS_DBG, ("EvaluateLanConnectivity(): Returning TRUE "
                       "(Now - %d sec, LastLANTime - %d sec)\n", dwNow/1000, gdwLastLANTime/1000));
            return TRUE;
            }
        }

    //
    // NOTE: If we are doing DWORD InterlockedExchange, then assignment
    // should suffice. Using InterlockedExchange is not a bug, though.
    //
    if (bLanAlive)
        {
        SensPrintA(SENS_DBG, ("**** EvaluateLanConnectivity(): Setting"
                   " gdwLastLANTime to %d secs\n", dwNow/1000));
        InterlockedExchange(&gdwLastLANTime, dwNow);
        }
    else
        {
        SensPrintA(SENS_DBG, ("**** EvaluateLanConnectivity(): Setting"
                   " gdwLastLANTime to 0 secs\n"));
        InterlockedExchange(&gdwLastLANTime, 0x0);
        }

    //
    // Adjust LAN state and fire an event, if necessary.
    //
    if (InterlockedExchange(&gdwLANState, bLanAlive) != bLanAlive)
        {
        //
        // LAN Connectivity state changed.
        //
        SENSEVENT_NETALIVE Data;

        Data.eType = SENS_EVENT_NETALIVE;
        Data.bAlive = bLanAlive;
        memset(&Data.QocInfo, 0x0, sizeof(QOCINFO));
        Data.QocInfo.dwSize = sizeof(QOCINFO);
        Data.QocInfo.dwFlags = NETWORK_ALIVE_LAN;
        Data.QocInfo.dwInSpeed = dwActiveInterfaceSpeed;
        Data.QocInfo.dwOutSpeed = dwActiveInterfaceSpeed;
        //
        // NOTE: When dwActiveInterfaceName gets the right value from
        // IPHLPAPIs we should use that name. Until then, we use a default.
        //
        Data.strConnection = DEFAULT_LAN_CONNECTION_NAME;

        UpdateSensCache(LAN);

        SensFireEvent((PVOID)&Data);
        }

    return bLanAlive;
}




BOOL
HasIfStateChanged(
    IF_STATE ifEntry,
    BOOL bForceInvalid
    )
/*++

Routine Description:

    Compares the current state of a remote network IF with the cached history
        to determine if it is active or not.

Arguments:

    ifEntry - An interface that appears to have changed state and is "valid" as a remote
        LAN if.  (ie, loopback, pptp, etc should be filtered out)
    bForceInvalid - If TRUE, don't bother to look at the stats; this interface is NOT valid.


Return Value:
    
    TRUE - ifEntry appears up and active
    FALSE - ifEntry inactive or down
    
--*/
{
    int i, j;
    static int iLastActiveIndex = -1;
    BOOL bActive;
    BOOL bSeenButInactive;
    DWORD dwInDiff;
    DWORD dwOutDiff;
    int iNUcastDiff;

    i = 0;
    bActive = FALSE;
    bSeenButInactive = FALSE;
    dwInDiff = 0;
    dwOutDiff = 0;
    iNUcastDiff = 0;

    RequestSensLock();

    //
    // Compare the current snapshot with the saved snapshot
    // for this interface.
    //
    while (i < MAX_IF_ENTRIES)
        {
        if (   (gIfState[i].fValid == TRUE)
            && (gIfState[i].dwIndex == ifEntry.dwIndex))
            {

            if (bForceInvalid)
                {
                gIfState[i].fValid = FALSE;
                break;
                }

            if (   (ifEntry.dwInUcastPkts > gIfState[i].dwInUcastPkts)
                || (ifEntry.dwOutUcastPkts > gIfState[i].dwOutUcastPkts)
                || (ifEntry.dwInNUcastPkts > gIfState[i].dwInNUcastPkts)
                || (ifEntry.dwOutNUcastPkts > gIfState[i].dwOutNUcastPkts)
                || (ifEntry.dwInErrors > gIfState[i].dwInErrors)
                || (ifEntry.dwOutErrors > gIfState[i].dwOutErrors)
                || (ifEntry.dwInDiscards > gIfState[i].dwInDiscards)
                || (ifEntry.dwOutDiscards > gIfState[i].dwOutDiscards))
                {
                //
                // HEURISTIC:
                //
                // a. When the net tap is pulled out, it has been observed that
                //    the difference in the incoming non-Unicast packet count
                //    is within +1 thru -1 of the difference in the outgoing
                //    non-Unicast packet count. Most of the times the diff of
                //    these differences is 0. We don't count this as LAN alive
                //
                // b. Also, there should be no change in the unicast IN packet
                //    count. Unicast OUT packet count may change. This could be
                //    problematic.
                //
                dwInDiff = ifEntry.dwInNUcastPkts - gIfState[i].dwInNUcastPkts;
                dwOutDiff = ifEntry.dwOutNUcastPkts - gIfState[i].dwOutNUcastPkts;
                iNUcastDiff = dwOutDiff - dwInDiff;
                SensPrintA(SENS_INFO, ("HasIfStateChanged(): dwInDiff = %d, "
                           "dwOutDiff = %d, dwNUcastDiff = %d, UcastINDiff = "
                           "%d, UcastOUTDiff = %d\n",
                           dwInDiff, dwOutDiff, iNUcastDiff,
                           ifEntry.dwInUcastPkts - gIfState[i].dwInUcastPkts,
                           ifEntry.dwOutUcastPkts - gIfState[i].dwOutUcastPkts));

                if (   (ifEntry.dwInUcastPkts == gIfState[i].dwInUcastPkts)
                    && (iNUcastDiff <= BROADCAST_ACTIVITY_THRESHOLD)
                    && (iNUcastDiff >= -BROADCAST_ACTIVITY_THRESHOLD))
                    {
                    SensPrintA(SENS_INFO, ("HasIfStateChanged(): Interface %d"
                               " has only Broadcast activity (Diff is %d)!\n",
                               gIfState[i].dwIndex, iNUcastDiff));
                    bSeenButInactive = TRUE;
                    }
                else
                    {
                    //
                    // Unicast IN packet counts have changed or Broadcast
                    // activity is greater than the threshold.
                    //
                    iLastActiveIndex = i;
                    bActive = TRUE;
                    SensPrintA(SENS_INFO, ("HasStateChanged(): Interface %d "
                               "has been active.\n", gIfState[i].dwIndex));

                    gdwLastLANTime = GetTickCount();
                    SensPrintA(SENS_DBG, ("**** HasIfStateChanged(): Setting "
                               "gdwLastLANTime to %d secs\n", gdwLastLANTime/1000));
                    }

                //
                // Save the new values.
                //
                memcpy(&gIfState[i], &ifEntry, sizeof(IF_STATE));
                gIfState[i].fValid = TRUE;
                }
            else
                {
                SensPrintA(SENS_INFO, ("HasStateChanged(): Interface %d has NO activity.\n",
                           gIfState[i].dwIndex));
                bSeenButInactive = TRUE;
                }

            // Found the interface, so stop searching
            break;
            }

        i++;

        } // while ()

    ReleaseSensLock();

    if (   (bSeenButInactive == TRUE)
        || (bForceInvalid) )
        {
        return FALSE;
        }

    if (bActive == TRUE)
        {
        return TRUE;
        }

    //
    // We are seeing this interface for the first time. Go ahead and save it
    // in the global interface state array.
    //
    i = MAX_IF_ENTRIES;
    j = iLastActiveIndex;

    RequestSensLock();

    while (i > 0)
        {
        // Try to find a free slot starting from the last active slot.
        j = (j+1) % MAX_IF_ENTRIES;

        if (gIfState[j].fValid == FALSE)
            {
            // Found one!
            break;
            }

        i--;
        }

    //
    // NOTE: If there are more than MAX_IF_ENTRIES, we will start
    // start reusing valid interface elements in gIfState array. This,
    // I guess, is OK since we will have enough interfaces to figure
    // out connectivity.
    //

    memcpy(&gIfState[j], &ifEntry, sizeof(IF_STATE));
    gIfState[j].fValid = TRUE;

    ReleaseSensLock();

    SensPrintA(SENS_ERR, ("******** HasIfStateChanged(): Adding a new "
               "interface with index %d\n", gIfState[j].dwIndex));

    return TRUE;
}



BOOL
MediaSenseRegister(
    void
    )
/*++

Routine Description:

    Schedule a workitem to register for Media-sense notifications from WMI.

Arguments:

    None.

Return Value:

    TRUE, if success.

    FALSE, otherwise.

--*/
{
    BOOL bRetVal;

    bRetVal = TRUE;

    ASSERT(gdwMediaSenseState == SENSSVC_START);

    //
    // Create a timer object to schedule (one-time only) Media-sense
    // registration.
    //
    SensSetTimerQueueTimer(
        bRetVal,                         // Bool return on NT5
        ghMediaTimer,                    // Handle return on IE5
        NULL,                            // Use default process timer queue
        MediaSenseRegisterHelper,        // Callback
        NULL,                            // Parameter
        MEDIASENSE_INITIALIZATION_DELAY, // Time from now when timer should fire
        0x0,                             // Time inbetween firings of this timer
        0x0                              // No Flags.
        );
    if (SENS_TIMER_CREATE_FAILED(bRetVal, ghMediaTimer))
        {
        SensPrintA(SENS_ERR, ("MediaSenseRegister(): SensSetTimerQueueTimer() failed with %d.\n",
                   GetLastError()));
        bRetVal = FALSE;
        }

    return bRetVal;
}




SENS_TIMER_CALLBACK_RETURN
MediaSenseRegisterHelper(
    PVOID pvIgnore,
    BOOLEAN bIgnore
    )
/*++

Routine Description:

    Helper routine that is scheduled to the WMI registration.

Arguments:

    pvIgnore - Ignored.

    bIgnore - Ignored.

Return Value:

    None (void).

--*/
{
    ULONG   Status;
    GUID    guid;

    RequestSensLock();
    
    if (   (SENSSVC_STOP == gdwMediaSenseState)
        || (UNREGISTERED == gdwMediaSenseState))
        {
        goto Cleanup;
        }

    //
    // Enable the media disconnect event.
    //
    guid = GUID_NDIS_STATUS_MEDIA_DISCONNECT;

    Status = WmiNotificationRegistrationW(
                 &guid,                         // Event of interest
                 TRUE,                          // Enable Notification?
                 EventCallbackRoutine,          // Callback function
                 0,                             // Callback context
                 NOTIFICATION_CALLBACK_DIRECT   // Notification flags
        );
    if (ERROR_SUCCESS != Status)
        {
        SensPrintA(SENS_ERR, ("Unable to enable media disconnect event: 0x%x!\n", Status));
        goto Cleanup;
        }

    //
    // Enable the media connect event
    //
    guid = GUID_NDIS_STATUS_MEDIA_CONNECT;

    Status = WmiNotificationRegistrationW(
                 &guid,                         // Event of interest
                 TRUE,                          // Enable Notification?
                 EventCallbackRoutine,          // Callback function
                 0,                             // Callback context
                 NOTIFICATION_CALLBACK_DIRECT   // Notification flags
                 );
    if (ERROR_SUCCESS != Status)
        {
        SensPrintA(SENS_ERR, ("Unable to enable media connect event: 0x%x!\n", Status));
        ASSERT(0);  // If we hit this then we need to unregister the first registration above.
        goto Cleanup;
        }

    SensPrintA(SENS_ERR, ("MediaSenseRegister(): Media-sense registration successful.\n"));

    gdwMediaSenseState = REGISTERED;

Cleanup:
    //
    // Cleanup
    //
    ReleaseSensLock();

    return;
}




BOOL
MediaSenseUnregister(
    void
    )
/*++

Routine Description:

    Unregister from Media-sense notifications from WMI.

Arguments:

    None.

Return Value:

    TRUE, if success.

    FALSE, otherwise.

--*/
{
    ULONG   Status;
    GUID    guid;
    BOOL    bRetVal;
    BOOL    bRegistered;

    bRetVal = TRUE;
    bRegistered = FALSE;

    RequestSensLock();

    ASSERT(gdwMediaSenseState == REGISTERED ||
           gdwMediaSenseState == SENSSVC_START);

    if (gdwMediaSenseState == REGISTERED)
        {
        bRegistered = TRUE;
        }

    gdwMediaSenseState = SENSSVC_STOP;

    if (NULL != ghMediaTimer)
        {
        bRetVal = SensCancelTimerQueueTimer(NULL, ghMediaTimer, NULL);
        ghMediaTimer = NULL;

        SensPrintA(SENS_INFO, ("[%d] MediaSensUnregister(): SensCancelTimer"
                  "QueueTimer(Media) %s\n", GetTickCount(),
                  bRetVal ? "succeeded" : "failed!"));
        }

    if (!bRegistered)
        {
        // Should not do unregistration.
        goto Cleanup;
        }

    //
    // Disable the media disconnect event.
    //
    guid = GUID_NDIS_STATUS_MEDIA_DISCONNECT;

    Status = WmiNotificationRegistrationW(
                 &guid,                         // Event of interest
                 FALSE,                         // Enable Notification?
                 EventCallbackRoutine,          // Callback function
                 0,                             // Callback context
                 NOTIFICATION_CALLBACK_DIRECT   // Notification flags
                 );
    if (ERROR_SUCCESS != Status)
        {
        SensPrintA(SENS_ERR, ("[%d] MediaSensUnregister(): Unable to disable "
                   "media disconnect event: 0x%x!\n", GetTickCount(), Status));
        ASSERT(0);  // If this fails analyze if we should still to the second unregister
        bRetVal = FALSE;
        }

    //
    // Disable the connect event
    //
    guid = GUID_NDIS_STATUS_MEDIA_CONNECT;

    Status = WmiNotificationRegistrationW(
                 &guid,                         // Event of interest
                 FALSE,                         // Enable Notification?
                 EventCallbackRoutine,          // Callback function
                 0,                             // Callback context
                 NOTIFICATION_CALLBACK_DIRECT   // Notification flags
                 );
    if (ERROR_SUCCESS != Status)
        {
        SensPrintA(SENS_ERR, ("[%d] MediaSensUnregister(): Unable to disable "
                   "media disconnect event: 0x%x!\n", GetTickCount(), Status));
        bRetVal = FALSE;
        }

Cleanup:
    //
    //
    //
    gdwMediaSenseState = UNREGISTERED;

    ReleaseSensLock();

    return bRetVal;
}




void
EventCallbackRoutine(
    IN PWNODE_HEADER WnodeHeader,
    IN ULONG Context
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    PULONG Data;
    PWNODE_SINGLE_INSTANCE Wnode = (PWNODE_SINGLE_INSTANCE)WnodeHeader;
    PWCHAR Name;
    DWORD dwIgnore;
    ULONG NameLen;
    int result;

    //
    // Get the information for the media disconnect.
    //
    result = memcmp(&WnodeHeader->Guid, &GUID_NDIS_STATUS_MEDIA_DISCONNECT, sizeof(GUID));
    if (0 == result)
        {
        SensPrintA(SENS_INFO, ("NDIS: received a media disconnect!\n"));
        EvaluateConnectivity(TYPE_LAN);
        }
    else
        {
        //
        // Get the information for the media connect.
        //
        result = memcmp(&WnodeHeader->Guid, &GUID_NDIS_STATUS_MEDIA_CONNECT, sizeof(GUID));
        if (0 == result)
            {
            SensPrintA(SENS_INFO, ("NDIS: received a media connect!\n"));
            EvaluateConnectivity(TYPE_DELAY_LAN);
            }
        else
            {
            SensPrintA(SENS_WARN, ("NDIS: Unknown event received!\n"));
            }
        }

    Name = (PWCHAR)RtlOffsetToPointer(Wnode, Wnode->OffsetInstanceName);

    SensPrintW(SENS_INFO, (L"NDIS: Instance: %ws\n", Name));
}



BOOL
GetIfEntryStats(
    IN DWORD dwIfIndex,
    IN LPQOCINFO lpQOCInfo,
    OUT LPDWORD lpdwLastError,
    OUT LPBOOL lpbIsWanIf
    )
/*++

Routine Description:

    Get the Statistics field of the Interface entry which has the given
    index.

Arguments:

    dwIfIndex - The interface of interest.

    lpQOCInfo - QOC Info structure whose fields are set when the interface
        entry is found in the interface table.

    lpdwLastError - The GLE, if any.

    lpbIsWanIf - Is the interface at this index a WAN interface or not.

Return Value:

    TRUE, if we find the index.

    FALSE, otherwise.

--*/
{
    DWORD i;
    BOOL bFound;

    *lpdwLastError = ERROR_SUCCESS;
    *lpbIsWanIf = FALSE;
    bFound = FALSE;

    BEGIN_GETTABLE(MIB_IFTABLE, MIB_IFROW, GETIFTABLE, MAX_IFTABLE_ROWS)

    // Search the Interface table for the entry with the given index.
    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        if (pTable->table[i].dwIndex == dwIfIndex)
            {
            bFound = TRUE;

            SensPrintA(SENS_INFO, ("GetIfEntryStats(): Interface %d is of "
                       "type %d\n", dwIfIndex, pTable->table[i].dwType));

            if (   (pTable->table[i].dwType == MIB_IF_TYPE_PPP)
                || (pTable->table[i].dwType == MIB_IF_TYPE_SLIP))
                {
                *lpbIsWanIf = TRUE;
                }
            else
                {
                *lpbIsWanIf = FALSE;
                }

            if (lpQOCInfo != NULL)
                {
                lpQOCInfo->dwSize = sizeof(QOCINFO);
                lpQOCInfo->dwInSpeed = pTable->table[i].dwSpeed;
                lpQOCInfo->dwOutSpeed = pTable->table[i].dwSpeed;
                lpQOCInfo->dwFlags = (*lpbIsWanIf) ? CONNECTION_WAN : CONNECTION_LAN;
                }

            break;
            }
        }

    END_GETTABLE()

    return bFound;
}




BOOL
CheckForReachability(
    IN IPAddr DestIpAddr,
    IN OUT LPQOCINFO lpQOCInfo,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    This helper function does all the dirty work in checking for Reachability
    of a particular destination.

Arguments:

    DestIpAddr - The Destination of interest.

    lpQOCInfo - The QOC Info structure.

    lpdwLastError - Returns the GetLastError value when the destination is
        not reachable.

Return Value:

    TRUE, if the destination IP Address is reachable

    FALSE, otherwise. GLE returned in lpdwLastError.

--*/
{
    DWORD i;
    BOOL bSuccess;
    BOOL bSameNetId;
    BOOL bReachable;
    BOOL bIsWanIf;
    DWORD dwNetId;
    DWORD dwSubnetMask;
    DWORD ifNum;
    DWORD dwHopCount;
    DWORD dwRtt;

    ifNum = -1;
    dwRtt = 0;
    bSuccess = FALSE;
    bIsWanIf = FALSE;
    bReachable = FALSE;
    bSameNetId = FALSE;

    //
    // On NT4, check to see if IPHLPAPI was present. If not, gracefully fail with
    // default values.
    //

#if defined(SENS_NT4)
    if (FALSE == gbIpInitSuccessful)
        {
        lpdwLastError = 0x0;
        if (NULL != lpQOCInfo)
            {
            lpQOCInfo->dwSize = sizeof(QOCINFO);
            lpQOCInfo->dwFlags = CONNECTION_LAN;
            lpQOCInfo->dwInSpeed = DEFAULT_LAN_BANDWIDTH;
            lpQOCInfo->dwOutSpeed = DEFAULT_LAN_BANDWIDTH;
            }

        return TRUE;
        }
#endif // SENS_NT4


    //
    // Search the IP Address table for an entry with the same NetId as the
    // Destination. If such an entry exists, the Destination is in the same
    // sub-net and hence reachable.
    //

    BEGIN_GETTABLE(MIB_IPADDRTABLE, MIB_IPADDRROW, GETIPADDRTABLE, MAX_IPADDRTABLE_ROWS)

    // Search for an entry with the same NetId
    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        // Compare NetIds.
        dwSubnetMask = pTable->table[i].dwMask;
        dwNetId = pTable->table[i].dwAddr & dwSubnetMask;

        SensPrintA(SENS_INFO, ("IPADDRESS(%d) - Mask %8x, IP %8x, NETID %8x, COMP %8x\n", i,
                   pTable->table[i].dwMask,
                   pTable->table[i].dwAddr,
                   dwNetId,
                   (DestIpAddr & dwSubnetMask))
                   );

        if (   (pTable->table[i].dwAddr != 0x0)
            && ((DestIpAddr & dwSubnetMask) == dwNetId))
            {
            bSameNetId = TRUE;
            ifNum = pTable->table[i].dwIndex;
            SensPrintA(SENS_INFO, ("CheckForReachability(): Found entry in IPAddr Table with same NetId\n"));
            break;
            }
        }

    END_GETTABLE()

    if (bSameNetId)
        {
        // Destination is in the same Subnet. Get stats from the IfTable.
        bSuccess = GetIfEntryStats(ifNum, lpQOCInfo, lpdwLastError, &bIsWanIf);
        ASSERT(bSuccess == TRUE);
        if (bSuccess)
            {
            return TRUE;
            }
        }


    //
    // Entry is not in the IP AddrTable. We need to Ping. Search the Gateway
    // table for default gateway and get it's interface statistics.
    //
    BEGIN_GETTABLE(MIB_IPFORWARDTABLE, MIB_IPFORWARDROW, GETIPFORWARDTABLE, MAX_IPFORWARDTABLE_ROWS)

    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        dwSubnetMask = pTable->table[i].dwForwardMask;
        dwNetId = pTable->table[i].dwForwardDest & dwSubnetMask;
        ifNum = pTable->table[i].dwForwardIfIndex;

        SensPrintA(SENS_INFO, ("IPFORWARD(%d) - Mask %8x, IP %8x, NETID %8x, COMP %8x\n", i,
                   pTable->table[i].dwForwardMask,
                   pTable->table[i].dwForwardDest,
                   dwNetId,
                   (DestIpAddr & dwSubnetMask))
                   );

        if (pTable->table[i].dwForwardDest == 0x0)
            {
            //
            // Skip the default gateway 0.0.0.0. But, get the statistics
            // anyways. The QOC of the default gateway is used if we have
            // to Ping the destination.
            //
            bSuccess = GetIfEntryStats(ifNum, lpQOCInfo, lpdwLastError, &bIsWanIf);
            SensPrintA(SENS_INFO, ("Default Gateway statistics (if = %d, "
                       "dwSpeed = %d, IsWanIf = %s)\n", ifNum, lpQOCInfo ?
                       lpQOCInfo->dwInSpeed : 0x0, bIsWanIf ? "TRUE" : "FALSE"));
            ASSERT(bSuccess == TRUE);
            break;
            }
        }

    END_GETTABLE()

    //
    // Resort to a Ping
    //

    bReachable = GETRTTANDHOPCOUNT(
                     DestIpAddr,
                     &dwHopCount,
                     MAX_HOPS_COUNT,
                     &dwRtt
                     );

    //
    // If we got around to doing a Ping, QOC information will have been
    // retrieved when we found the Default Gateway entry.
    //

    SensPrintA(SENS_INFO, ("CheckForReachability(): Ping returned %s with GLE of %d\n",
               bReachable ? "TRUE" : "FALSE", GetLastError()));

    if (bReachable == FALSE)
        {
        *lpdwLastError = ERROR_HOST_UNREACHABLE;
        }

    //
    // P3 BUG:
    //
    // a. We determine whether the interface on which the Ping went is a LAN
    //    or WAN by checking the interface type of the default gateway. This
    //    is not TRUE!
    //

    return bReachable;
}




BOOL
GetActiveWanInterfaceStatistics(
    OUT LPDWORD lpdwLastError,
    OUT LPDWORD lpdwWanSpeed
    )
/*++

Routine Description:

    Get the Statistics field of the Interface entry

Arguments:

    lpdwLastError - The GLE, if any.

    lpdwWanSpeed - Speed of the WAN interface

Notes:

    P3 BUG: Currently, this will return the speed of the first WAN interface
    it finds. This won't work properly if there are multiple "active" WAN
    interfaces.

Return Value:

    TRUE, if statistics were successfully retrieved

    FALSE, otherwise.

--*/
{
    DWORD i;
    BOOL bFound;

    *lpdwLastError = ERROR_SUCCESS;
    *lpdwWanSpeed = DEFAULT_WAN_BANDWIDTH;
    bFound = FALSE;

#if defined(SENS_NT4)
    if (FALSE == gbIpInitSuccessful)
        {
        return TRUE;
        }
#endif // SENS_NT4

    BEGIN_GETTABLE(MIB_IFTABLE, MIB_IFROW, GETIFTABLE, MAX_IFTABLE_ROWS)

    // Search the Interface table for the first active WAN interface.
    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        if (   (pTable->table[i].dwType == MIB_IF_TYPE_PPP)
            || (pTable->table[i].dwType == MIB_IF_TYPE_SLIP))
            {
            bFound = TRUE;

            if (   (pTable->table[i].dwInNUcastPkts != 0)
                || (pTable->table[i].dwOutNUcastPkts != 0)
                || (pTable->table[i].dwInErrors != 0)
                || (pTable->table[i].dwOutErrors != 0)
                || (pTable->table[i].dwInDiscards != 0)
                || (pTable->table[i].dwOutDiscards != 0))
                {
                *lpdwWanSpeed = pTable->table[i].dwSpeed;
                break;
                }
            }
        } // for

    END_GETTABLE()

    return bFound;
}




BOOL
PurgeStaleInterfaces(
    IN MIB_IFTABLE *pTable,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Remove statistics from the interfaces that went away.

Arguments:

    pTable - The current If table.

    lpdwLastError - The GLE, if any.

Return Value:

    TRUE, always.

--*/
{
    DWORD i;
    DWORD j;
    BOOL bFound;


    *lpdwLastError = ERROR_SUCCESS;

    RequestSensLock();

    // Check if each valid interface in the cache still exists.
    for (j = 0; j < MAX_IF_ENTRIES; j++)
        {
        if (gIfState[j].fValid == FALSE)
            {
            continue;
            }

        bFound = FALSE;

        // Search if the interface in the cache is present in the IF_TABLE.
        for (i = 0; i < pTable->dwNumEntries; i++)
            {
            if (pTable->table[i].dwIndex == gIfState[j].dwIndex)
                {
                bFound = TRUE;
                }
            } // for (i)

        if (FALSE == bFound)
            {
            SensPrintA(SENS_ERR, ("******** PurgeStaleInterfaces(): Purging"
                       "interface with index %d\n", gIfState[j].dwIndex));

            // Interface went away. So remove from Cache.
            memset(&gIfState[j], 0x0, sizeof(IF_STATE));
            gIfState[j].fValid = FALSE;
            }

        } // for (j)

    ReleaseSensLock();

    return TRUE;
}



#if defined(AOL_PLATFORM)


BOOL
IsAOLInstalled(
    void
    )
/*++

Routine Description:

    Try to determine if AOL is installed on this machine.

Arguments:

    None.

Return Value:

    TRUE, if AOL is installed.

    FALSE, otherwise.

--*/
{
    if (AOL_NOT_INSTALLED == gAOLInstallState)
        {
        SensPrintA(SENS_ERR, ("IsAOLInstalled(): NOT INSTALLED.\n"));
        return FALSE;
        }

    if (AOL_INSTALLED == gAOLInstallState)
        {
        SensPrintA(SENS_ERR, ("IsAOLInstalled(): INSTALLED !\n"));
        return TRUE;
        }

    ASSERT(AOL_DETECT_PENDING == gAOLInstallState);
    gAOLInstallState = AOL_NOT_INSTALLED;

    HKEY hKeyAOL;
    LONG lResult;

    //
    // Open AOL Key under HKCU.
    //
    hKeyAOL = NULL;
    lResult = RegOpenKeyEx(
                  HKEY_CURRENT_USER,        // Handle to the Parent
                  REGSZ_AOLKEY,             // Name of the child key
                  0,                        // Reserved
                  KEY_ENUMERATE_SUB_KEYS,   // Security Access Mask
                  &hKeyAOL                  // Handle to the opened key
                  );
    if (lResult != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, ("IsAOLInstalled(): RegOpenKeyEx(HKCU\\AOL) "
                   "failed with %d\n,", lResult));
        return FALSE;
        }

    //
    // To make sure, open AOL Key under HKLM.
    //
    RegCloseKey(hKeyAOL);
    hKeyAOL = NULL;
    lResult = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,       // Handle to the Parent
                  REGSZ_AOLKEY,             // Name of the child key
                  0,                        // Reserved
                  KEY_ENUMERATE_SUB_KEYS,   // Security Access Mask
                  &hKeyAOL                  // Handle to the opened key
                  );
    if (lResult != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, ("IsAOLInstalled(): RegOpenKeyEx(HKLM\\AOL) "
                   "failed with %d\n,", lResult));
        return FALSE;
        }

    RegCloseKey(hKeyAOL);

    gAOLInstallState = AOL_INSTALLED;

    SensPrintA(SENS_ERR, ("IsAOLInstalled(): Detected that AOL is installed"
               " !\n"));

    return TRUE;
}




BOOL WINAPI
EvaluateAOLConnectivity(
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Evaluates AOL WAN Connectivity.

Arguments:

    lpdwLastError - if return value is FALSE, GetLastError is returned
        in this OUT parameter.

Notes:

    a. This routine can be executed as a threadpool work item.

    b. Currently, AOL can be installed only on Win9x platforms, not NTx.
       This code needs to be updated to handle NTx.

Return Value:

    TRUE, if AOL WAN connectivity is present.

    FALSE, otherwise

--*/
{
    DWORD i;
    DWORD dwNow;
    DWORD dwAolIfIndex;
    DWORD dwLocalLastError;
    BOOL bAolAlive;

    dwNow = GetTickCount();
    dwAolIfIndex = -1;
    dwLocalLastError = ERROR_NO_NETWORK;
    bAolAlive = FALSE;
    if (lpdwLastError)
        {
        *lpdwLastError = dwLocalLastError;
        }
    else
        {
        lpdwLastError = &dwLocalLastError;
        }

    //
    // Check if AOL is installed
    //
    if (FALSE == IsAOLInstalled())
        {
        goto Cleanup;
        }

    //
    // Get IF_TABLE to retrieve the AOL Adapater's interface index.
    //

    BEGIN_GETTABLE(MIB_IFTABLE, MIB_IFROW, GETIFTABLE, MAX_IFTABLE_ROWS)

    SensPrintA(SENS_INFO, ("GetIfTable(): Number of entries - %d.\n",
               pTable->dwNumEntries));

    PrintIfTable(pTable);

    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        //
        // AOL Adapter's description is atleast 3 characters long
        //
        if (pTable->table[i].dwDescrLen > AOL_ADAPTER_PREFIX_LEN)
            {
            if (   (pTable->table[i].bDescr[0] == AOL_ADAPTER_PREFIX[0])
                && (pTable->table[i].bDescr[1] == AOL_ADAPTER_PREFIX[1])
                && (pTable->table[i].bDescr[2] == AOL_ADAPTER_PREFIX[2]))
                {
                dwAolIfIndex = pTable->table[i].dwIndex;
                break;
                }
            }
        } // for ()

    END_GETTABLE()

    if (-1 == dwAolIfIndex)
        {
        SensPrintA(SENS_INFO, ("EvaluateAOLConnectivity(): No AOL adapter"
                   " found!\n"));
        goto Cleanup;
        }

    //
    // Found an AOL Adapter. Now, see if this Adapter has a non-zero IP Address
    //
    BEGIN_GETTABLE(MIB_IPADDRTABLE, MIB_IPADDRROW, GETIPADDRTABLE, MAX_IPADDRTABLE_ROWS)

    // Search for an entry for the AOL adapter
    for (i = 0; i < pTable->dwNumEntries; i++)
        {
        if (   (pTable->table[i].dwIndex == dwAolIfIndex)
            && (pTable->table[i].dwAddr != 0x0))
            {
            bAolAlive = TRUE;
            SensPrintA(SENS_INFO, ("EvaluateAOLConnectivity(): AOL Adapter's "
                       "IP Address is 0x%x\n", pTable->table[i].dwAddr));
            break;
            }
        } // for ()

    END_GETTABLE()

Cleanup:
    //
    // Cleanup
    //
    if (bAolAlive)
        {
        SensPrintA(SENS_INFO, ("EvalutateAOLConnectivity(): Setting AOL to TRUE\n"));
        *lpdwLastError = ERROR_SUCCESS;
        gdwAOLState = TRUE;
        }
    else
        {
        SensPrintA(SENS_INFO, ("EvalutateAOLConnectivity(): Setting AOL to FALSE\n"));
        gdwAOLState = FALSE;
        }

    SensPrintA(SENS_INFO, ("EvaluateAOLConnectivity() returning %s, GLE of %d\n",
               bAolAlive ? "TRUE" : "FALSE", *lpdwLastError));

    return bAolAlive;
}

#endif // AOL_PLATFORM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\event.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    event.cxx

Abstract:

    SENS code related to firing Events using LCE mechanism.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/31/1997         Start.

--*/


#include <precomp.hxx>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


//
// Some useful Macros
//


/*++

Macro Description:

    Helper Macro for firing Winlogon events.

Arguments:

    See signature.

--*/
#define FIRE_WINLOGON_EVENT(_EVENT_NAME_, _EVENT_TYPE_)                         \
{                                                                               \
    PSENSEVENT_WINLOGON pData = (PSENSEVENT_WINLOGON)EventData;                 \
    WCHAR buffer[256*2+1+1];                                                    \
                                                                                \
    wcscpy(buffer, SENS_BSTR(""));                                              \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            WINLOGON Event\n")));                         \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                 Type  -  %s\n"), _EVENT_NAME_));    \
    SensPrint(SENS_INFO, (SENS_STRING("\t|                 Size  -  %d\n"), pData->Info.Size));     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|                Flags  -  0x%x\n"), pData->Info.Flags));  \
    SensPrintW(SENS_INFO, (SENS_BSTR("\t|             UserName  -  %s\n"),                          \
              pData->Info.UserName ? pData->Info.UserName : SENS_BSTR("")));                        \
    SensPrintW(SENS_INFO, (SENS_BSTR("\t|               Domain  -  %s\n"),                          \
              pData->Info.Domain ? pData->Info.Domain : SENS_BSTR("")));                            \
    SensPrintW(SENS_INFO, (SENS_BSTR("\t|           WinStation  -  %s\n"),                          \
              pData->Info.WindowStation ? pData->Info.WindowStation : SENS_BSTR("")));              \
    SensPrint(SENS_INFO, (SENS_STRING("\t|               hToken  -  0x%x\n"), pData->Info.hToken)); \
    SensPrint(SENS_INFO, (SENS_STRING("\t|             hDesktop  -  0x%x\n"), pData->Info.hDesktop));    \
    SensPrint(SENS_INFO, (SENS_STRING("\t|          dwSessionId  -  0x%x\n"), pData->Info.dwSessionId)); \
                                                                                \
    if (pData->Info.Domain != NULL)                                             \
        {                                                                       \
        StringCbCopy(buffer, sizeof(buffer), pData->Info.Domain);               \
        StringCbCat(buffer, sizeof(buffer), SENS_BSTR("\\"));                   \
        }                                                                       \
    if (pData->Info.UserName != NULL)                                           \
        {                                                                       \
        StringCbCat(buffer, sizeof(buffer), pData->Info.UserName);              \
        }                                                                       \
    SensPrintW(SENS_INFO, (SENS_BSTR("\t|    UserName passed is -  %s\n"), buffer));   \
    hr = SensFireWinlogonEventHelper(buffer, pData->Info.dwSessionId, _EVENT_TYPE_);   \
                                                                                \
    break;                                                                      \
}


/*++

Macro Description:

    Helper Macro for firing PnP events.

Arguments:

    See signature.

Notes:

    a. This is not an actual event exposed by SENS.

--*/
#define FIRE_PNP_EVENT(_EVENT_NAME_)                                            \
{                                                                               \
    PSENSEVENT_PNP pData = (PSENSEVENT_PNP)EventData;                           \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            PNP Event\n")));          \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                 Type  -  DEVICE %s\n"), _EVENT_NAME_)); \
    SensPrint(SENS_INFO, (SENS_STRING("\t|                 Size  -  %d\n"), pData->Size));            \
    SensPrint(SENS_INFO, (SENS_STRING("\t|              DevType  -  %d\n"), pData->DevType));         \
    SensPrint(SENS_INFO, (SENS_STRING("\t|             Resource  -  0x%x\n"), pData->Resource));      \
    SensPrint(SENS_INFO, (SENS_STRING("\t|                Flags  -  0x%x\n"), pData->Flags));         \
                                                                                \
    break;                                                                      \
}


/*++

Macro Description:

    Helper Macro for firing Power events.

Arguments:

    See signature.

--*/
#define FIRE_POWER_EVENT(_EVENT_NAME_, _EVENT_TYPE_)                            \
{                                                                               \
    PSENSEVENT_POWER pData = (PSENSEVENT_POWER)EventData;                       \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            POWER MANAGEMENT Event\n"))); \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                  Type  -  %s\n"), _EVENT_NAME_));     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|          ACLineStatus  -  %d\n"),        \
              pData->PowerStatus.ACLineStatus));                                    \
    SensPrint(SENS_INFO, (SENS_STRING("\t|           BatteryFlag  -  %d\n"),        \
              pData->PowerStatus.BatteryFlag));                                     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|    BatteryLifePercent  -  %d\n"),        \
              pData->PowerStatus.BatteryLifePercent));                              \
    SensPrint(SENS_INFO, (SENS_STRING("\t|       BatteryLifeTime  -  0x%x secs\n"), \
              pData->PowerStatus.BatteryLifeTime));                                 \
    SensPrint(SENS_INFO, (SENS_STRING("\t|   BatteryFullLifeTime  -  0x%x secs\n"), \
              pData->PowerStatus.BatteryFullLifeTime));                         \
    hr = SensFirePowerEventHelper(pData->PowerStatus, _EVENT_TYPE_);            \
    break;                                                                      \
}


/*++

Macro Description:

    Helper Macro for firing RAS events.

Arguments:

    See signature.

Notes:

    a. This is not an actual event exposed by SENS. It may, however, generate
       a WAN Connectivity event.

--*/
#define FIRE_RAS_EVENT(_EVENT_NAME_)                                            \
{                                                                               \
                                                                                \
    PSENSEVENT_RAS pData = (PSENSEVENT_RAS)EventData;                           \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            RAS Event\n")));          \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                 Type  -  %s\n"), _EVENT_NAME_));     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|    Connection Handle  -  0x%x\n"), pData->hConnection));  \
    break;                                                                      \
}


/*++

Macro Description:

    Helper Macro for firing LAN events.

Arguments:

    See signature.

Notes:

    a. This is not an actual event exposed by SENS. It may, however, generate
       a LAN Connectivity event.

--*/
#define FIRE_LAN_EVENT(_EVENT_NAME_)                                            \
                                                                                \
{                                                                               \
    PSENSEVENT_LAN pData = (PSENSEVENT_LAN)EventData;                           \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("\t|            LAN Event\n")));          \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                 Type  -  %s\n"), _EVENT_NAME_));    \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|      Connection Name  -  %s\n"), pData->Name));     \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                Status -  0x%x\n"), pData->Status)); \
    SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|                  Type -  0x%x\n"), pData->Type));   \
    break;                                                                      \
}


/*++

Macro Description:

    This macro is called when we allocate the EventData so that it can be
    queued to a worker thread. ALLOCATE_END() should be called to signal the
    end of the allocation.

Arguments:

    See signature.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define ALLOCATE_BEGIN(_EVENT_STRUCT_)                                          \
                                                                                \
    _EVENT_STRUCT_ *pData, *pTempData;                                          \
                                                                                \
    /* Allocate the Data structure */                                           \
    pTempData = (_EVENT_STRUCT_ *) EventData;                                   \
    pData = (_EVENT_STRUCT_ *) new char[sizeof(_EVENT_STRUCT_)];                \
    if (NULL == pData)                                                          \
        {                                                                       \
        goto Cleanup;                                                           \
        }                                                                       \
                                                                                \
    memcpy(pData, EventData, sizeof(_EVENT_STRUCT_));



/*++

Macro Description:

    This macro is called when we allocate the strings in the EventData before
    queueing to a worker thread. FREE_STRING_MEMBER() should be called to free
    the string before the EventData itself is freed.

Arguments:

    See signature.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define ALLOCATE_STRING_MEMBER(_DEST_, _SOURCE_)                                \
                                                                                \
    if (NULL != _SOURCE_)                                                       \
        {                                                                       \
        /* Allocate the string */                                               \
        _DEST_ = new WCHAR[(wcslen(_SOURCE_)+1)];                               \
        if (NULL == _DEST_)                                                     \
            {                                                                   \
            delete pData;                                                       \
            goto Cleanup;                                                       \
            }                                                                   \
        wcscpy(_DEST_, _SOURCE_);                                               \
        }


/*++

Macro Description:

    This macro is called when we finish allocating the EventData so that
    it can be queued to a worker thread. It should be always called after
    ALLOCATE_BEGIN() macro.

Arguments:

    None.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define ALLOCATE_END()                                                          \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("******** Allocated a DS (0x%x)\n"), pData));     \
    pReturnData = pData;                                                        \
    break;



/*++

Macro Description:

    This macro is called to begin the deallocation of the EventData. This
    should always match with a call to ALLOCATE_BEGIN() macro.

Arguments:

    None.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define FREE_BEGIN(_EVENT_STRUCT_)                                              \
                                                                                \
    _EVENT_STRUCT_ *pData;                                                      \
                                                                                \
    pData = (_EVENT_STRUCT_ *) EventData;


/*++

Macro Description:

    This macro is called to free the string member of an EventData. This
    should always match with a call to ALLOCATE_STRING_MEMBER() macro.

Arguments:

    See signature.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define FREE_STRING_MEMBER(_STRING_)                                            \
                                                                                \
    if (NULL != _STRING_)                                                       \
        {                                                                       \
        /* Free the string */                                                   \
        delete _STRING_;                                                        \
        }


/*++

Macro Description:

    This macro is called to end the deallocation of EventData. This
    should always match with a call to FREE_BEGIN() macro.

Arguments:

    See signature.

Notes:

    a. pData, pTempData and pReturnData are fixed names for the variable.
       They should not be changed without updating the code that uses
       this macro.

--*/
#define FREE_END()                                                              \
                                                                                \
    SensPrint(SENS_INFO, (SENS_STRING("********** Freed a DS (0x%x)\n"), pData));       \
    delete pData;                                                               \
    break;





void
EvaluateConnectivity(
    IN CONNECTIVITY_TYPE Type
    )
/*++

Routine Description:

    This code queues up a job (for evaluating Network connectivity) to
    a worker thread.

Arguments:

    Type - Indicates the type of connectivity to be evaluated.

Return Value:

    None.

--*/
{
    BOOL bRetVal;
    LPTHREAD_START_ROUTINE lpfnEvaluate;

    switch (Type)
        {
        case TYPE_WAN:
            lpfnEvaluate = (LPTHREAD_START_ROUTINE) EvaluateWanConnectivity;
            break;

        case TYPE_DELAY_LAN:
            lpfnEvaluate = (LPTHREAD_START_ROUTINE) EvaluateLanConnectivityDelayed;
            break;

        default:
        case TYPE_LAN:
            lpfnEvaluate = (LPTHREAD_START_ROUTINE) EvaluateLanConnectivity;
            break;
        }

    bRetVal = SensQueueUserWorkItem(
                  (LPTHREAD_START_ROUTINE) lpfnEvaluate,
                  NULL,
                  SENS_LONG_ITEM    // Flags
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("EvaluateConnectivity(): SensQueueUserWorkItem() failed with %d.\n",
                   GetLastError()));
        }
}




void
SensFireEvent(
    IN PVOID EventData
    )
/*++

Routine Description:

    This code queues up a job (for firing a SENS event) to a worker thread.

Arguments:

    EventData - Data relating to the event.

Return Value:

    None.

--*/
{
    BOOL bRetVal;
    PVOID pAllocatedData;

    pAllocatedData = AllocateEventData(EventData);
    if (NULL == pAllocatedData)
        {
        SensPrintA(SENS_ERR, ("SensFireEvent(): Failed to allocate Event Data!\n"));
        return;
        }

    bRetVal = SensQueueUserWorkItem(
                  (LPTHREAD_START_ROUTINE) SensFireEventHelper,
                  pAllocatedData,   // Event Data
                  SENS_LONG_ITEM    // Flags
                  );
    if (FALSE == bRetVal)
        {
        SensPrintA(SENS_ERR, ("SensFireEvent(): SensQueueUserWorkItem() failed with %d.\n",
                   GetLastError()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("SensFireEvent(): SensQueueUserWorkItem() succeeded.\n"));
        }
}




DWORD WINAPI
SensFireEventHelper(
    IN PVOID EventData
    )
/*++

Routine Description:

    This code sets up the necessary stuff for firing a SENS event.

Arguments:

    EventData - Data relating to the event.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    SENS_EVENT_TYPE eType;
    HRESULT hr;

    SensPrint(SENS_INFO, (SENS_STRING("\t|-------------------------------------------------------|\n")));
    SensPrint(SENS_INFO, (SENS_STRING("\t|               E V E N T   F I R E D                   |\n")));
    SensPrint(SENS_INFO, (SENS_STRING("\t|-------------------------------------------------------|\n")));

    hr = S_OK;
    eType = *(SENS_EVENT_TYPE *)EventData;

    switch (eType)
        {
        case SENS_EVENT_NETALIVE:
            {
            PSENSEVENT_NETALIVE pData = (PSENSEVENT_NETALIVE)EventData;

            SensPrint(SENS_INFO, (SENS_STRING("\t|   %s%sNetwork Connectivity is %sPRESENT.\n\t|\n"),
                      (pData->QocInfo.dwFlags & CONNECTION_WAN) ? SENS_STRING("WAN ") : SENS_STRING(""),
                      (pData->QocInfo.dwFlags & CONNECTION_LAN) ? SENS_STRING("LAN ") : SENS_STRING(""),
                      pData->bAlive ? SENS_STRING("") : SENS_STRING("NOT "))
                      );

            hr = SensFireNetEventHelper(pData);
            break;
            }

        case SENS_EVENT_REACH:
            {
            PSENSEVENT_REACH pData = (PSENSEVENT_REACH)EventData;

            SensPrint(SENS_INFO, (SENS_STRING("\t|   Destination is %sREACHABLE.\n"), pData->bReachable ? "" : "NOT "));
            SensPrint(SENS_INFO, (SENS_STRING("\t|\n\t|          Name   : %s\n"), pData->Destination));
            if (pData->bReachable == TRUE)
                {
                SensPrint(SENS_INFO, (SENS_STRING("\t|       dwFlags   : 0x%x \n"), pData->QocInfo.dwFlags));
                SensPrint(SENS_INFO, (SENS_STRING("\t|       InSpeed   : %d bits/sec.\n"), pData->QocInfo.dwInSpeed));
                SensPrint(SENS_INFO, (SENS_STRING("\t|      OutSpeed   : %d bits/sec.\n"), pData->QocInfo.dwOutSpeed));
                }

            hr = SensFireReachabilityEventHelper(pData);
            break;
            }

        case SENS_EVENT_PNP_DEVICE_ARRIVED:
            FIRE_PNP_EVENT(SENS_STRING("ARRIVED"));

        case SENS_EVENT_PNP_DEVICE_REMOVED:
            FIRE_PNP_EVENT(SENS_STRING("REMOVED"));

        case SENS_EVENT_POWER_ON_ACPOWER:
            FIRE_POWER_EVENT(SENS_STRING("ON AC POWER"), eType);

        case SENS_EVENT_POWER_ON_BATTERYPOWER:
            FIRE_POWER_EVENT(SENS_STRING("ON BATTERY POWER"), eType);

        case SENS_EVENT_POWER_BATTERY_LOW:
            FIRE_POWER_EVENT(SENS_STRING("BATTERY IS LOW"), eType);

        case SENS_EVENT_POWER_STATUS_CHANGE:
            FIRE_POWER_EVENT(SENS_STRING("POWER STATUS CHANGED"), eType);

        case SENS_EVENT_LOGON:
            FIRE_WINLOGON_EVENT(SENS_STRING("LOGON"), eType);

        case SENS_EVENT_LOGOFF:
            FIRE_WINLOGON_EVENT(SENS_STRING("LOGOFF"), eType);

        case SENS_EVENT_STARTSHELL:
            FIRE_WINLOGON_EVENT(SENS_STRING("STARTSHELL"), eType);

        case SENS_EVENT_POSTSHELL:
            FIRE_WINLOGON_EVENT(SENS_STRING("POSTSHELL"), eType);

        case SENS_EVENT_SESSION_DISCONNECT:
            FIRE_WINLOGON_EVENT(SENS_STRING("SESSION DISCONNECT"), eType);

        case SENS_EVENT_SESSION_RECONNECT:
            FIRE_WINLOGON_EVENT(SENS_STRING("SESSION RECONNECT"), eType);

        case SENS_EVENT_STARTSCREENSAVER:
            FIRE_WINLOGON_EVENT(SENS_STRING("STARTSCREENSAVER"), eType);

        case SENS_EVENT_STOPSCREENSAVER:
            FIRE_WINLOGON_EVENT(SENS_STRING("STOPSCREENSAVER"), eType);

        case SENS_EVENT_LOCK:
            FIRE_WINLOGON_EVENT(SENS_STRING("DISPLAY LOCK"), eType);

        case SENS_EVENT_UNLOCK:
            FIRE_WINLOGON_EVENT(SENS_STRING("DISPLAY UNLOCK"), eType);

        case SENS_EVENT_RAS_STARTED:
            FIRE_RAS_EVENT(SENS_STRING("RAS STARTED"));

        case SENS_EVENT_RAS_STOPPED:
            FIRE_RAS_EVENT(SENS_STRING("RAS STOPPED"));

        case SENS_EVENT_RAS_CONNECT:
            FIRE_RAS_EVENT(SENS_STRING("RAS CONNECT"));

        case SENS_EVENT_RAS_DISCONNECT:
            FIRE_RAS_EVENT(SENS_STRING("RAS DISCONNECT"));

        case SENS_EVENT_RAS_DISCONNECT_PENDING:
            FIRE_RAS_EVENT(SENS_STRING("RAS DISCONNECT PENDING"));

        case SENS_EVENT_LAN_CONNECT:
            FIRE_LAN_EVENT(SENS_STRING("LAN CONNECT"));

        case SENS_EVENT_LAN_DISCONNECT:
            FIRE_LAN_EVENT(SENS_STRING("LAN DISCONNECT"));

        default:
            SensPrint(SENS_ERR, (SENS_STRING("\t|   A bogus event - %d !\n"), eType));
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

    //
    // Free the allocated Event data structure.
    //
    FreeEventData(EventData);

    return ((DWORD) hr);
}




PVOID
AllocateEventData(
    PVOID EventData
    )
/*++

Routine Description:

    Allocated the EventData depending on the type of the event.

Arguments:

    EventData - Data relating to the event.

Return Value:

    None.

--*/
{
    SENS_EVENT_TYPE eType;
    PVOID pReturnData;

    pReturnData = NULL;
    if (NULL == EventData)
        {
        goto Cleanup;
        }

    eType = *(SENS_EVENT_TYPE *)EventData;

    switch (eType)
        {
        case SENS_EVENT_NETALIVE:
            {
            ALLOCATE_BEGIN(SENSEVENT_NETALIVE);

            ALLOCATE_STRING_MEMBER(pData->strConnection, pTempData->strConnection);

            ALLOCATE_END();
            }

        case SENS_EVENT_REACH:
            {
            ALLOCATE_BEGIN(SENSEVENT_REACH);

            ALLOCATE_STRING_MEMBER(pData->Destination, pTempData->Destination);
            ALLOCATE_STRING_MEMBER(pData->strConnection, pTempData->strConnection);

            ALLOCATE_END();
            }

        case SENS_EVENT_PNP_DEVICE_ARRIVED:
        case SENS_EVENT_PNP_DEVICE_REMOVED:
            {
            ALLOCATE_BEGIN(SENSEVENT_PNP);

            ALLOCATE_END();
            }


        case SENS_EVENT_POWER_ON_ACPOWER:
        case SENS_EVENT_POWER_ON_BATTERYPOWER:
        case SENS_EVENT_POWER_BATTERY_LOW:
        case SENS_EVENT_POWER_STATUS_CHANGE:
            {
            ALLOCATE_BEGIN(SENSEVENT_POWER);

            ALLOCATE_END();
            }

        case SENS_EVENT_LOGON:
        case SENS_EVENT_LOGOFF:
        case SENS_EVENT_STARTSHELL:
        case SENS_EVENT_POSTSHELL:
        case SENS_EVENT_SESSION_DISCONNECT:
        case SENS_EVENT_SESSION_RECONNECT:
        case SENS_EVENT_STARTSCREENSAVER:
        case SENS_EVENT_STOPSCREENSAVER:
        case SENS_EVENT_LOCK:
        case SENS_EVENT_UNLOCK:
            {
            ALLOCATE_BEGIN(SENSEVENT_WINLOGON);

            ALLOCATE_STRING_MEMBER(pData->Info.UserName, pTempData->Info.UserName);
            ALLOCATE_STRING_MEMBER(pData->Info.Domain, pTempData->Info.Domain);
            ALLOCATE_STRING_MEMBER(pData->Info.WindowStation, pTempData->Info.WindowStation);

            ALLOCATE_END();
            }

        case SENS_EVENT_RAS_STARTED:
        case SENS_EVENT_RAS_STOPPED:
        case SENS_EVENT_RAS_CONNECT:
        case SENS_EVENT_RAS_DISCONNECT:
        case SENS_EVENT_RAS_DISCONNECT_PENDING:
            {
            ALLOCATE_BEGIN(SENSEVENT_RAS);

            ALLOCATE_END();
            }

        case SENS_EVENT_LAN_CONNECT:
        case SENS_EVENT_LAN_DISCONNECT:
             {
            ALLOCATE_BEGIN(SENSEVENT_LAN);

            ALLOCATE_STRING_MEMBER(pData->Name, pTempData->Name);

            ALLOCATE_END();
            }

        default:
            SensPrint(SENS_ERR, (SENS_STRING("\t|   A bogus event - %d !\n"), eType));
            break;
        }

Cleanup:
    //
    // Cleanup
    //
    return pReturnData;
}




void
FreeEventData(
    PVOID EventData
    )
/*++

Routine Description:

    Frees the EventData depending on the type of the event.

Arguments:

    EventData - Data relating to the event.

Return Value:

    None.

--*/
{
    SENS_EVENT_TYPE eType;

    if (NULL == EventData)
        {
        goto Cleanup;
        }
    eType = *(SENS_EVENT_TYPE *)EventData;

    switch (eType)
        {
        case SENS_EVENT_NETALIVE:
            {
            FREE_BEGIN(SENSEVENT_NETALIVE);

            FREE_STRING_MEMBER(pData->strConnection);

            FREE_END();
            }

        case SENS_EVENT_REACH:
            {
            FREE_BEGIN(SENSEVENT_REACH);

            FREE_STRING_MEMBER(pData->Destination);
            FREE_STRING_MEMBER(pData->strConnection);

            FREE_END();
            }

        case SENS_EVENT_PNP_DEVICE_ARRIVED:
        case SENS_EVENT_PNP_DEVICE_REMOVED:
            {
            FREE_BEGIN(SENSEVENT_PNP);

            FREE_END();
            }


        case SENS_EVENT_POWER_ON_ACPOWER:
        case SENS_EVENT_POWER_ON_BATTERYPOWER:
        case SENS_EVENT_POWER_BATTERY_LOW:
        case SENS_EVENT_POWER_STATUS_CHANGE:
            {
            FREE_BEGIN(SENSEVENT_POWER);

            FREE_END();
            }

        case SENS_EVENT_LOGON:
        case SENS_EVENT_LOGOFF:
        case SENS_EVENT_STARTSHELL:
        case SENS_EVENT_POSTSHELL:
        case SENS_EVENT_SESSION_DISCONNECT:
        case SENS_EVENT_SESSION_RECONNECT:
        case SENS_EVENT_STARTSCREENSAVER:
        case SENS_EVENT_STOPSCREENSAVER:
        case SENS_EVENT_LOCK:
        case SENS_EVENT_UNLOCK:
            {
            FREE_BEGIN(SENSEVENT_WINLOGON);

            FREE_STRING_MEMBER(pData->Info.UserName);
            FREE_STRING_MEMBER(pData->Info.Domain);
            FREE_STRING_MEMBER(pData->Info.WindowStation);

            FREE_END();
            }

        case SENS_EVENT_RAS_STARTED:
        case SENS_EVENT_RAS_STOPPED:
        case SENS_EVENT_RAS_CONNECT:
        case SENS_EVENT_RAS_DISCONNECT:
        case SENS_EVENT_RAS_DISCONNECT_PENDING:
            {
            FREE_BEGIN(SENSEVENT_RAS);

            FREE_END();
            }

        case SENS_EVENT_LAN_CONNECT:
        case SENS_EVENT_LAN_DISCONNECT:
            {
            FREE_BEGIN(SENSEVENT_LAN);

            FREE_STRING_MEMBER(pData->Name);

            FREE_END();
            }

        default:
            SensPrint(SENS_ERR, (SENS_STRING("\t|   A bogus structure to free - %d !\n"), eType));
            break;
        }

Cleanup:
    //
    // Cleanup
    //
    return;
}




HRESULT
SensFireNetEventHelper(
    PSENSEVENT_NETALIVE pData
    )
/*++

Routine Description:

    Helps fire the SENS Network Alive event.

Arguments:

    pData - Net alive event data.

Return Value:

    S_OK, if successful.

    Failure hr, otherwise.

--*/
{
    HRESULT hr;
    BSTR bstrConnectionName;
    BSTR bstrMethodName;
    ISensNetwork    *pISensNetwork;
    IEventControl   *pIEventControl;
    SENS_QOCINFO    SensQocInfo;
    CImpISensNetworkFilter NetEventsFilter; // Already AddRef'ed

    hr = S_OK;
    bstrConnectionName = NULL;
    bstrMethodName = NULL;
    pISensNetwork = NULL;
    pIEventControl = NULL;

    hr = CoCreateInstance(
             SENSGUID_EVENTCLASS_NETWORK,
             NULL,
             CLSCTX_SERVER,
             IID_ISensNetwork,
             (LPVOID *) &pISensNetwork
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensNetwork object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensNetwork Object\n")));

    //
    // Setup Publisher filtering
    //
    hr = pISensNetwork->QueryInterface(
                            IID_IEventControl,
                            (LPVOID *) &pIEventControl
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get IEventControl object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created IEventControl Object\n")));

    //
    // Disallow inproc activation (we're local system, and we
    // don't like foreign components in our security context,
    // potentially crashing us).
    //
    pIEventControl->put_AllowInprocActivation(FALSE);

    AllocateBstrFromString(bstrConnectionName, pData->strConnection);

    if (pData->bAlive)
        {
        // Connect events
        AllocateBstrFromString(bstrMethodName, CONNECTION_MADE_NOQOC_METHOD);
        hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't initialize PublisherFilters for Net Connect Event - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        hr = pIEventControl->SetPublisherFilter(
                                 bstrMethodName,
                                 &NetEventsFilter
                                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for Net Connect Event - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }

        //
        // Fire the necessary ISensNetwork events
        //

        //
        // ConnectionMadeNoQOCInfo event
        //
        hr = pISensNetwork->ConnectionMadeNoQOCInfo(
                                bstrConnectionName,
                                pData->QocInfo.dwFlags
                                );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ConnectionMadeQOCInfo - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        SensPrint(SENS_INFO, (SENS_STRING("\t| ConnectionMadeNoQOCInfo() returned 0x%x\n"), hr));

        //
        // ConnectionMade event
        //
        FreeBstr(bstrMethodName);
        AllocateBstrFromString(bstrMethodName, CONNECTION_MADE_METHOD);
        hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| initialize't set PublisherFilters for NetEvent - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        hr = pIEventControl->SetPublisherFilter(
                                 bstrMethodName,
                                 &NetEventsFilter
                                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for NetEvent - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }

        memcpy(&SensQocInfo, &pData->QocInfo, sizeof(SENS_QOCINFO));
        hr = pISensNetwork->ConnectionMade(
                                bstrConnectionName,
                                pData->QocInfo.dwFlags,
                                &SensQocInfo
                                );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ConnectionMade - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        SensPrint(SENS_INFO, (SENS_STRING("\t| ConnectionMade() returned 0x%x\n"), hr));
        }
    else    // bAlive == FALSE
        {
        // Disconnect event
        AllocateBstrFromString(bstrMethodName, CONNECTION_LOST_METHOD);
        hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't initialize PublisherFilters for Net Disconnect Event - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        hr = pIEventControl->SetPublisherFilter(
                                 bstrMethodName,
                                 &NetEventsFilter
                                 );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for Net Disconnect Event - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }

        //
        // Fire the necessary ISensNetwork events
        //

        //
        // ConnectionMadeNoQOCInfo event
        //
        hr = pISensNetwork->ConnectionLost(
                                bstrConnectionName,
                                pData->QocInfo.dwFlags
                                );
        if (FAILED(hr))
            {
            SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ConnectionLost - ")
                      SENS_STRING("hr = 0x%x\n"), hr));
            goto Cleanup;
            }
        SensPrint(SENS_INFO, (SENS_STRING("\t| ConnectionLost() returned 0x%x\n"), hr));
        }


Cleanup:
    //
    // Cleanup
    //
    if (pIEventControl)
        {
        pIEventControl->Release();
        }
    if (pISensNetwork)
        {
        pISensNetwork->Release();
        }

    FreeBstr(bstrMethodName);
    FreeBstr(bstrConnectionName);

    return hr;
}




HRESULT
SensFireReachabilityEventHelper(
    PSENSEVENT_REACH pData
    )
/*++

Routine Description:

    Helps fire the SENS Reachability event.

Arguments:

    pData - Reachability event Data.

Return Value:

    S_OK, if successful.

    Failure hr, otherwise.

--*/
{
    HRESULT hr;
    BSTR bstrConnectionName;
    BSTR bstrMethodName;
    BSTR bstrDestinationName;
    ISensNetwork    *pISensNetwork;
    IEventControl   *pIEventControl;
    SENS_QOCINFO    SensQocInfo;
    CImpISensNetworkFilter NetEventsFilter; // Already AddRef'ed

    hr = S_OK;
    bstrMethodName = NULL;
    bstrConnectionName = NULL;
    bstrDestinationName = NULL;
    pISensNetwork = NULL;
    pIEventControl = NULL;

    hr = CoCreateInstance(
             SENSGUID_EVENTCLASS_NETWORK,
             NULL,
             CLSCTX_SERVER,
             IID_ISensNetwork,
             (LPVOID *) &pISensNetwork
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensNetwork object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensNetwork Object\n")));

    //
    // Setup Publisher filtering
    //
    hr = pISensNetwork->QueryInterface(
                            IID_IEventControl,
                            (LPVOID *) &pIEventControl
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get IEventControl object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created IEventControl Object\n")));

    //
    // Disallow inproc activation (we're local system, and we
    // don't like foreign components in our security context,
    // potentially crashing us).
    //
    pIEventControl->put_AllowInprocActivation(FALSE);

    AllocateBstrFromString(bstrMethodName, DESTINATION_REACHABLE_NOQOC_METHOD);
    hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| initialize't set PublisherFilters for ReachabilityEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    hr = pIEventControl->SetPublisherFilter(
                             bstrMethodName,
                             &NetEventsFilter
                             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for ReachabilityEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }

    //
    // Fire the Reachability events
    //
    AllocateBstrFromString(bstrConnectionName, pData->strConnection);
    AllocateBstrFromString(bstrDestinationName, pData->Destination);

    //
    // DestinationReachableNoQOCInfo event
    //
    hr = pISensNetwork->DestinationReachableNoQOCInfo(
                            bstrDestinationName,
                            bstrConnectionName,
                            pData->QocInfo.dwFlags
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire DestinationReachableNoQOCInfo - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| DestinationReachableNoQOCInfo() returned 0x%x\n"), hr));

    //
    // DestinationReachable event
    //
    FreeBstr(bstrMethodName);
    AllocateBstrFromString(bstrMethodName, DESTINATION_REACHABLE_METHOD);
    hr = NetEventsFilter.Initialize(bstrMethodName, pIEventControl);
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| initialize't set PublisherFilters for ReachabilityEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    hr = pIEventControl->SetPublisherFilter(
                             bstrMethodName,
                             &NetEventsFilter
                             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't set PublisherFilters for ReachabilityEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }

    memcpy(&SensQocInfo, &pData->QocInfo, sizeof(SENS_QOCINFO));
    hr = pISensNetwork->DestinationReachable(
                            bstrDestinationName,
                            bstrConnectionName,
                            pData->QocInfo.dwFlags,
                            &SensQocInfo
                            );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire DestinationReachable - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| DestinationReachable() returned 0x%x\n"), hr));



Cleanup:
    //
    // Cleanup
    //
    if (pIEventControl)
        {
        pIEventControl->Release();
        }
    if (pISensNetwork)
        {
        pISensNetwork->Release();
        }

    FreeBstr(bstrMethodName);
    FreeBstr(bstrConnectionName);
    FreeBstr(bstrDestinationName);

    return hr;
}




HRESULT
SensFireWinlogonEventHelper(
    LPWSTR strArg,
    DWORD dwSessionId,
    SENS_EVENT_TYPE eType
    )
/*++

Routine Description:

    Helps fire the SENS Winlogon event.

Arguments:

    strArg - DomainName\UserName

    dwSessionId - Session Id of the session on which this event was fired.

    eType - Type of Winlogon event.

Return Value:

    S_OK, if successful.

    Failure hr, otherwise.

--*/
{
    HRESULT hr;
    HRESULT hr2;
    BOOL bLogon2;
    BSTR bstrUserName;
    ISensLogon  *pISensLogon;
    ISensLogon2 *pISensLogon2;

    hr = S_OK;
    hr2 = S_OK;
    bstrUserName = NULL;
    pISensLogon = NULL;
    pISensLogon2 = NULL;

    //
    // Get the ISensLogon Object
    //
    hr = CoCreateInstance(
             SENSGUID_EVENTCLASS_LOGON,
             NULL,
             CLSCTX_SERVER,
             IID_ISensLogon,
             (LPVOID *) &pISensLogon
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensLogon object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensLogon Object\n")));

    //
    // Get the ISensLogon2 Object
    //
    hr2 = CoCreateInstance(
             SENSGUID_EVENTCLASS_LOGON2,
             NULL,
             CLSCTX_SERVER,
             IID_ISensLogon2,
             (LPVOID *) &pISensLogon2
             );
    if (FAILED(hr2))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensLogon2 object - ")
                  SENS_STRING("hr = 0x%x\n"), hr2));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensLogon2 Object\n")));

    AllocateBstrFromString(bstrUserName, strArg);

    switch (eType)
        {
        case SENS_EVENT_LOGON:
            hr = pISensLogon->Logon(bstrUserName);
            hr2 = pISensLogon2->Logon(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_LOGOFF:
            hr = pISensLogon->Logoff(bstrUserName);
            hr2 = pISensLogon2->Logoff(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_STARTSHELL:
            hr = pISensLogon->StartShell(bstrUserName);
            break;

        case SENS_EVENT_POSTSHELL:
            hr2 = pISensLogon2->PostShell(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_SESSION_DISCONNECT:
            hr2 = pISensLogon2->SessionDisconnect(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_SESSION_RECONNECT:
            hr2 = pISensLogon2->SessionReconnect(bstrUserName, dwSessionId);
            break;

        case SENS_EVENT_LOCK:
            hr = pISensLogon->DisplayLock(bstrUserName);
            break;

        case SENS_EVENT_UNLOCK:
            hr = pISensLogon->DisplayUnlock(bstrUserName);
            break;

        case SENS_EVENT_STARTSCREENSAVER:
            hr = pISensLogon->StartScreenSaver(bstrUserName);
            break;

        case SENS_EVENT_STOPSCREENSAVER:
            hr = pISensLogon->StopScreenSaver(bstrUserName);
            break;

        default:
            SensPrint(SENS_WARN, (SENS_STRING("\t| Bad Winlogon Event - %d\n"), eType));
            break;
        }

    //
    // Check for failures
    //

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ISensLogon->WinlogonEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        }
    else
        {
        SensPrint(SENS_INFO, (SENS_STRING("\t| ISensLogon->WinlogonEvent() returned 0x%x\n"), hr));
        }

    if (FAILED(hr2))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ISensLogon2->WinlogonEvent(%d) - ")
                  SENS_STRING("hr = 0x%x\n"), dwSessionId, hr2));
        }
    else
        {
        SensPrint(SENS_INFO, (SENS_STRING("\t| ISensLogon2->WinlogonEvent(%d) returned 0x%x\n"), dwSessionId, hr));
        }


Cleanup:
    //
    // Cleanup
    //
    if (pISensLogon)
        {
        pISensLogon->Release();
        }

    if (pISensLogon2)
        {
        pISensLogon2->Release();
        }

    FreeBstr(bstrUserName);

    return hr;
}




HRESULT
SensFirePowerEventHelper(
    SYSTEM_POWER_STATUS PowerStatus,
    SENS_EVENT_TYPE eType
    )
/*++

Routine Description:

    Helps fire the SENS Power event.

Arguments:

    PowerStatus - Power Status event structure

    eType - Type of the Power event.

Return Value:

    S_OK, if successful.

    Failure hr, otherwise.

--*/
{
    HRESULT hr;
    ISensOnNow  *pISensOnNow;

    hr = S_OK;
    pISensOnNow = NULL;

    //
    // Get the ISensOnNow Object
    //
    hr = CoCreateInstance(
             SENSGUID_EVENTCLASS_ONNOW,
             NULL,
             CLSCTX_SERVER,
             IID_ISensOnNow,
             (LPVOID *) &pISensOnNow
             );
    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't get ISensOnNow object - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| Successfully created ISensOnNow Object\n")));

    switch (eType)
        {
        case SENS_EVENT_POWER_ON_ACPOWER:
            hr = pISensOnNow->OnACPower();
            break;

        case SENS_EVENT_POWER_ON_BATTERYPOWER:
            hr = pISensOnNow->OnBatteryPower(PowerStatus.BatteryLifePercent);
            break;

        case SENS_EVENT_POWER_BATTERY_LOW:
            hr = pISensOnNow->BatteryLow(PowerStatus.BatteryLifePercent);
            break;

        default:
            SensPrint(SENS_WARN, (SENS_STRING("\t| Bad Power Event - %d\n"), eType));
            break;
        }

    if (FAILED(hr))
        {
        SensPrint(SENS_ERR, (SENS_STRING("\t| Couldn't fire ISensOnNow->PowerEvent - ")
                  SENS_STRING("hr = 0x%x\n"), hr));
        //SensPrintToDebugger(SENS_DEB, ("\t| Couldn't fire ISensOnNow->PowerEvent - "
        //                    "hr = 0x%x\n", hr));
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("\t| ISensOnNow->PowerEvent() returned 0x%x\n"), hr));
    //SensPrintToDebugger(SENS_DEB, ("\t| ISensOnNow->PowerEvent() returned 0x%x\n", hr));

Cleanup:
    //
    // Cleanup
    //
    if (pISensOnNow)
        {
        pISensOnNow->Release();
        }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\linklist.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    linklist.cxx

Abstract:

    Implements a linked list for Destination Reachability.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/30/1997         Start.

--*/

#include <precomp.hxx>

#define WCHAR_Y     ((WCHAR) 'Y')
#define WCHAR_N     ((WCHAR) 'N')
#define WCHAR_X     ((WCHAR) '-')


NODE::NODE()
{
    Next = NULL;
    Prev = NULL;
    Destination = NULL;
    SubId = ~0;
    cRef = 1;
    State = UNTRIED;
}

NODE::NODE(DWORD Id, PWCHAR Dest, PDWORD pdwStatus)
{
    int size;

    *pdwStatus = ERROR_SUCCESS;
    Next = NULL;
    Prev = NULL;

    // Make a copy of the Destination name
    Destination = (PWCHAR) new WCHAR[(wcslen(Dest) + 1)];
    if (Destination != NULL)
        {
        wcscpy(Destination, Dest);
        }
    else
        {
        *pdwStatus = ERROR_OUTOFMEMORY;
        }

    SubId = Id;
    cRef = 1;
    State = UNTRIED;
}

NODE::~NODE()
{
    if (Destination != NULL)
        {
        delete Destination;
        }
}

LIST::LIST()
{
    pHead = NULL;

    cElements = 0;

    InitializeCriticalSection(&ListLock);
}


LIST::~LIST()
{
    DeleteAll();

    DeleteCriticalSection(&ListLock);
}

DWORD
LIST::Insert(
    PNODE pNew
    )
{
    ASSERT(pNew != NULL);
    ASSERT(pNew->Destination != NULL);

    RequestLock();

    //
    // See if it is already present. Find() will add a reference to the
    // destination if it is already present in the list.
    //
    if (NULL != Find(pNew->Destination, TRUE))
        {
        ReleaseLock();
        Print();
        return ERROR_ALREADY_EXISTS;
        }

    pNew->Next = pHead;
    if (pHead != NULL)
        {
        pHead->Prev = pNew;
        }
    pHead = pNew;

    cElements++;

    ReleaseLock();

    Print();

    return ERROR_SUCCESS;
}

DWORD
LIST::InsertByDest(
    PWCHAR lpszDest
    )
{
    DWORD dwStatus = ERROR_SUCCESS;
    PNODE pNode = NULL;

    // Insert into the global list
    pNode = new NODE(99, lpszDest, &dwStatus);
    if (   (dwStatus != ERROR_SUCCESS)
        || (pNode == NULL))
        {
        return ERROR_OUTOFMEMORY;
        }

    dwStatus = Insert(pNode);

    if (ERROR_ALREADY_EXISTS == dwStatus)
        {
        delete pNode;
        }

    return dwStatus;
}

inline void
LIST::Delete(
    PNODE pDelete
    )
{
    // Should be always called with the ListLock held.

    if (0 != pDelete->Release())
        {
        Print();
        return;
        }

    if (pDelete->Next != NULL)
        {
        pDelete->Next->Prev = pDelete->Prev;
        }

    if (pDelete->Prev != NULL)
        {
        pDelete->Prev->Next = pDelete->Next;
        }

    if (pDelete == pHead)
        {
        pHead = pDelete->Next;
        }

    delete pDelete;

    cElements--;

    Print();
}

BOOL
LIST::DeleteByDest(
    PWCHAR lpszDest
    )
{
    PNODE pTemp = NULL;

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        if (wcscmp(pTemp->Destination, lpszDest) == 0)
            {
            Delete(pTemp);
            ReleaseLock();
            return TRUE;
            }

        pTemp = pTemp->Next;
        }

    ReleaseLock();

    return FALSE;
}

BOOL
LIST::DeleteById(
    DWORD Id
    )
{
    PNODE pTemp = NULL;

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        if (pTemp->SubId == Id)
            {
            Delete(pTemp);
            ReleaseLock();
            return TRUE;
            }

        pTemp = pTemp->Next;
        }

    ReleaseLock();

    return FALSE;
}

void
LIST::DeleteAll(
    void
    )
{
    PNODE pTemp, pDelete;

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        pDelete = pTemp;
        pTemp = pTemp->Next;
        delete pDelete;
        cElements--;
        }

    ASSERT(cElements == 0);

    ReleaseLock();
}

PNODE
LIST::Find(
    PWCHAR lpszDest,
    BOOL bAddReference
    )
{
    PNODE pTemp = NULL;

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        if (wcscmp(pTemp->Destination, lpszDest) == 0)
            {
            if (TRUE == bAddReference)
                {
                pTemp->AddRef();
                }
            ReleaseLock();
            return pTemp;
            }

        pTemp = pTemp->Next;
        }

    ReleaseLock();

    return NULL;
}

BOOL
LIST::IsEmpty(
    void
    )
{
    RequestLock();

    if (pHead == NULL)
        {
        ASSERT(cElements == 0);

        ReleaseLock();

        return TRUE;
        }

    ReleaseLock();

    return FALSE;
}

void
LIST::Print(
    void
    )
{
#ifdef DBG

    PNODE pTemp;


    SensPrintA(SENS_INFO, ("\n\t|----------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("\t|           R E A C H A B I L I T Y   L I S T              |\n"));
    SensPrintA(SENS_INFO, ("\t|----------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("\t|----------------------------------------------------------|\n"));
    SensPrintA(SENS_INFO, ("\t|  cRef | Reachable |          Destination                 |\n"));
    SensPrintA(SENS_INFO, ("\t|----------------------------------------------------------|\n"));

    RequestLock();

    pTemp = pHead;
    while (pTemp != NULL)
        {
        SensPrintW(SENS_INFO, (L"\t| %3d   |     %c     |     %s\n",
                   pTemp->cRef,
                   (pTemp->State == REACHABLE) ? WCHAR_Y : ((pTemp->State == UNTRIED) ? WCHAR_X : WCHAR_N),
                   pTemp->Destination ? pTemp->Destination : L"<NULL>")
                   );
        pTemp = pTemp->Next;
        }

    ReleaseLock();

    SensPrintA(SENS_INFO, ("\t|----------------------------------------------------------|\n\n"));

#else

    // Nothing

#endif // DBG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\stub_notify_s.c ===
#include <notify_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\stub_api_s.c ===
#include <api_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\msgloop.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    msgloop.cxx

Abstract:

    This file contains the message pump for SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/5/1997         Start.

--*/


#include <precomp.hxx>
#include <dbt.h>


#define SENS_WINDOW_CLASS_NAME      SENS_STRING("SENS Hidden Window class")
#define SENS_HIDDEN_WINDOW_NAME     SENS_STRING("SENS")
#if defined(SENS_NT4)
#define SENS_MODULE_NAME            SENS_STRING("SENS.EXE")
#else // SENS_NT4
#define SENS_MODULE_NAME            SENS_STRING("SENS.DLL")
#endif // SENS_NT4


//
// Globals
//
HWND                ghwndSens;
DWORD               gMessageLoopTid;
HANDLE              ghCleanupEvent;
SYSTEM_POWER_STATUS gSystemPowerState;



LRESULT CALLBACK
SensMainWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:



Arguments:

    None.

Return Value:

    None.

--*/
{
    LRESULT lResult = TRUE;

#ifdef DETAIL_DEBUG
    SensPrintA(SENS_INFO, ("SensMainWndProc(): Received a msg (0x%x) - (0x%x)\n",
               msg, wParam));
#endif // DETAIL_DEBUG

    switch (msg)
        {

        //
        // Power Management Notifications.
        //
        case WM_POWERBROADCAST:
            {
            DWORD dwPowerEvent = (DWORD) wParam;
            SYSTEM_POWER_STATUS CurSPstate;
            SENSEVENT_POWER Data;
            BOOL bRet;

            SensPrintA(SENS_INFO, ("SensMainWndProc(): Received WM_POWERBROADCAST msg - (0x%x)\n",
                       wParam));

            bRet = GetSystemPowerStatus(&CurSPstate);
            ASSERT(bRet);

            switch (dwPowerEvent)
                {
                case PBT_APMBATTERYLOW:
                    {
                    // Save the new state. A critsec is not necessary as this Message to be serialized.
                    memcpy(&gSystemPowerState, &CurSPstate, sizeof(SYSTEM_POWER_STATUS));

                    Data.eType = SENS_EVENT_POWER_BATTERY_LOW;
                    memcpy(&Data.PowerStatus, &CurSPstate, sizeof(SYSTEM_POWER_STATUS));

                    // Fire BatteryLow event
                    SensFireEvent(&Data);

                    break;
                    }

                case PBT_APMPOWERSTATUSCHANGE:
                    {
                    //
                    // OnACPower event is fired when
                    //    o previously the machine was not on AC
                    //    o now, it is on AC
                    //
                    if (   (CurSPstate.ACLineStatus == AC_LINE_ONLINE)
                        && (gSystemPowerState.ACLineStatus != AC_LINE_ONLINE))
                        {
                        Data.eType = SENS_EVENT_POWER_ON_ACPOWER;
                        }
                    else
                    //
                    // OnBatteryPower event is fired when
                    //    o previously the machine was on AC
                    //    o now, it is not on AC
                    //    o the machine has a system battery
                    //
                    if (   (CurSPstate.ACLineStatus == AC_LINE_OFFLINE)
                        && (gSystemPowerState.ACLineStatus == AC_LINE_ONLINE)
                        && ((CurSPstate.BatteryFlag & BATTERY_FLAG_NO_BATTERY) == 0))
                        {
                        Data.eType = SENS_EVENT_POWER_ON_BATTERYPOWER;
                        }
                     //
                     // A Power change we don't care about.
                     //
                     else
                        {
                        break;
                        }

                    // Save the new state. A critsec is not necessary as this Message to be serialized.
                    memcpy(&gSystemPowerState, &CurSPstate, sizeof(SYSTEM_POWER_STATUS));

                    memcpy(&Data.PowerStatus, &CurSPstate, sizeof(SYSTEM_POWER_STATUS));

                    // Fire the event.
                    SensFireEvent(&Data);

                    break;
                    }

                default:
                    // Unrecognized Power event.
                    break;

                } // switch (dwPowerEvent)

            break;
            }


#if defined(SENS_CHICAGO)
        //
        // PnP Device Notifications.
        //
        case WM_DEVICECHANGE:
            {
            SensPrintA(SENS_INFO, ("SensMainWndProc(): Received a WM_DEVICECHANGE msg - (0x%x)\n",
                       wParam));

            PDEV_BROADCAST_NET pdbNet = (PDEV_BROADCAST_NET) lParam;

            switch (wParam)
                {
                case DBT_DEVICEARRIVAL:
                    {
                    if (pdbNet->dbcn_devicetype == DBT_DEVTYP_NET)
                        {
                        SENSEVENT_PNP Data;

                        ASSERT(pdbNet->dbcn_size == sizeof(DEV_BROADCAST_NET));

                        Data.eType = SENS_EVENT_PNP_DEVICE_ARRIVED;
                        Data.Size = pdbNet->dbcn_size;
                        Data.DevType = pdbNet->dbcn_devicetype;
                        Data.Resource = pdbNet->dbcn_resource;
                        Data.Flags = pdbNet->dbcn_flags;

                        SensFireEvent(&Data);

                        // Force a recalculation of LAN Connectivity
                        gdwLastLANTime -= (MAX_LAN_INTERVAL + 1);

                        //EvaluateConnectivity(TYPE_LAN);
                        }
                    break;
                    }

                case DBT_DEVICEREMOVECOMPLETE:
                    {
                    if (pdbNet->dbcn_devicetype == DBT_DEVTYP_NET)
                        {
                        SENSEVENT_PNP Data;

                        ASSERT(pdbNet->dbcn_size == sizeof(DEV_BROADCAST_NET));

                        Data.eType = SENS_EVENT_PNP_DEVICE_REMOVED;
                        Data.Size = pdbNet->dbcn_size;
                        Data.DevType = pdbNet->dbcn_devicetype;
                        Data.Resource = pdbNet->dbcn_resource;
                        Data.Flags = pdbNet->dbcn_flags;

                        SensFireEvent(&Data);

                        // Force a recalculation of LAN Connectivity
                        gdwLastLANTime -= (MAX_LAN_INTERVAL + 1);

                        //EvaluateConnectivity(TYPE_LAN);
                        }
                    break;
                    }
                }

            break;
            }

#endif // SENS_CHICAGO

        case WM_SENS_CLEANUP:
            //
            // Cleanup the Window resources of SENS
            //
            PostQuitMessage(0);

            break;

        default:
            lResult = DefWindowProc(hwnd, msg, wParam, lParam);
            break;

        } // switch (msg)

    return lResult;
}



DWORD WINAPI
SensMessageLoopThreadRoutine(
    LPVOID lpParam
    )
/*++

Routine Description:



Arguments:

    None.

Return Value:

    None.

--*/
{
    WNDCLASS wc;
    BOOL f;
    BOOL bRet;
    HINSTANCE hInstance = NULL;
    MSG msg;

    //
    // Save away the ThreadId
    //
    gMessageLoopTid = GetCurrentThreadId();

    //
    // Save a snapshot of the System Power State.
    //
    bRet = GetSystemPowerStatus(&gSystemPowerState);
    if (bRet == FALSE)
        {
        SensPrintA(SENS_ERR, ("SensMessageLoopThread(): GetSystemPowerStatus() failed with "
               "GLE = %d\n", GetLastError()));
        }

    //
    // Create an event to signal the cleanup of all window resources.
    //
    ghCleanupEvent = CreateEvent(
                         NULL,     // Handle cannot be inherited
                         FALSE,    // It is an auto-reset event
                         FALSE,    // Intial state is non-signalled
                         SENS_STRING("Sens Hidden Window Cleanup Event")   // Name of the event
                         );
    if (ghCleanupEvent == NULL)
        {
        SensPrintA(SENS_ERR, ("ServiceStart(): CreateEvent(ghCleanupEvent)"
                  " failed with %d.", GetLastError()));
        }

    //
    // Register window class
    //
    hInstance = GetModuleHandle(SENS_MODULE_NAME);
    ASSERT(hInstance);

    memset(&wc, 0x0, sizeof(WNDCLASS));

    wc.style = 0;
    wc.lpfnWndProc = (WNDPROC) SensMainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hIcon = NULL;
    wc.hInstance = hInstance;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = SENS_WINDOW_CLASS_NAME;

    f = RegisterClass(&wc);
    ASSERT(f);

    // Create a hidden window
    ghwndSens = CreateWindow(
                    SENS_WINDOW_CLASS_NAME,  // Class Name
                    SENS_HIDDEN_WINDOW_NAME, // Window Name
                    NULL,                    // Window Style
                    0,                       // Horizontal position
                    0,                       // Vertical position
                    0,                       // Window width
                    0,                       // Window height
                    NULL,                    // Handle to parent window
                    NULL,                    // Handle to menu
                    hInstance,               // Handle to application instance
                    NULL                     // window creation data
                    );
    if (ghwndSens)
        {
        ShowWindow(ghwndSens, SW_HIDE);

        //
        // Message pump.
        //
        while ((bRet = GetMessage(&msg, ghwndSens, NULL, NULL)) > 0)
            {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            }

#ifdef DETAIL_DEBUG
        SensPrintA(SENS_DBG, ("SensMessageLoopThread(): Out of message pump !\n"));
#endif // DETAIL_DEBUG

        // Check for bad return value from GetMessage()
        if (bRet == -1)
            {
            SensPrintA(SENS_ERR, ("SensMessageLoopThread(): GetMessage() failed with GLE of %d\n",
                       GetLastError()));
            }

        BOOL bRet;

        // Cleanup the window.
        bRet = DestroyWindow(ghwndSens);
        ASSERT(bRet);
        if (bRet != TRUE)
            {
            SensPrintA(SENS_ERR, ("SensMessageLoopThread(): DestroyWindow() failed with %d\n",
                       GetLastError()));
            }

        // Unregister the window class
        bRet = UnregisterClass(SENS_WINDOW_CLASS_NAME, hInstance);
        ASSERT(bRet);

        // Window cleanup done. Set the event.
        if (ghCleanupEvent)
            {
            SetEvent(ghCleanupEvent);
            }
        }
    else
        {
        SensPrintA(SENS_ERR, ("SensMessageLoopThread(): CreateWindow() failed with GLE of %d\n",
                   GetLastError()));
        }

    return 0;
}



BOOL
InitMessageLoop(
    void
    )
/*++

Routine Description:



Arguments:

    None.

Return Value:

    None.

--*/
{
#if defined(SENS_CHICAGO)

    BOOL bStatus;
    HANDLE hThread;
    DWORD dwThreadId;

    bStatus = FALSE;

    hThread = CreateThread(
                  NULL,
                  0,
                  SensMessageLoopThreadRoutine,
                  NULL,
                  0,
                  &dwThreadId
                  );
    if (NULL != hThread)
        {
        bStatus = TRUE;
        CloseHandle(hThread);
        }
    else
        {
        SensPrintA(SENS_INFO, ("InitMessageLoop() returning %d with GLE of %d\n",
                   bStatus, GetLastError()));
        }

    return bStatus;

#else // SENS_CHICAGO

    return TRUE;

#endif // SENS_CHICAGO
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\sensutil.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensutil.cxx

Abstract:

    This file contains all the utility routines in SENS service.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include <precomp.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\senssvc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senssvc.cxx

Abstract:

    This file implements the Init/Uninit functionality of System Event
    Notification service (SENS).

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          09-20-1997         Start.

--*/


#include <precomp.hxx>


#define MIN_CALL_THREADS            1
#define SENS_CLEANUP_TIMEOUT        15*1000     // Max wait
#define SENS_WAITFORINIT_TIMEOUT    30*1000     // 30 seconds max

//
// Globals
//

IEventSystem        *gpIEventSystem;
HANDLE              ghSensHeap;
HANDLE              ghSensStartedEvent;
CRITICAL_SECTION    gSensLock;
DWORD               gdwRegCO;
DWORD               gdwLocked;
LPCLASSFACTORY      gpChangeCF;

#ifdef DBG
DWORD           gdwDebugOutputLevel;
#endif // DBG

//
// External Globals
//

// Common
extern LONG     g_cFilterObj;
extern LONG     g_cFilterLock;
extern LONG     g_cSubChangeObj;
extern LONG     g_cSubChangeLock;
extern LIST     *gpReachList;
extern BOOL     gbIpInitSuccessful;
extern BOOL     gbIsRasInstalled;
extern long     gdwLastLANTime;
extern long     gdwLANState;
extern HANDLE   ghReachTimer;
extern HANDLE   ghMediaTimer;
extern long     gdwLastWANTime;
extern long     gdwWANState;
extern IF_STATE gIfState[MAX_IF_ENTRIES];
extern MIB_IPSTATS          gIpStats;
extern SYSTEM_POWER_STATUS  gSystemPowerState;


BOOL
SensInitialize(
    void
    )
/*++

Routine Description:

    Main entry into SENS.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    BOOL bRetValue;
	BOOL bComInitialized;

    bRetValue = FALSE;
	bComInitialized = FALSE;

#ifdef DBG
    DWORD dwNow = GetTickCount();
    EnableDebugOutputIfNecessary();
#endif // DBG

    SensPrintA(SENS_INFO, ("[%d] Initializing SENS...\n", dwNow));

    // This will Initialize COM on success.
    if (FALSE == Init())
        {
        SensPrintA(SENS_ERR, ("[%d] Init() failed.\n",
                   GetTickCount()));
        bRetValue = FALSE;
        goto Cleanup;
        }

	bComInitialized = TRUE;

    //
    // This will call CoRegisterClassObject and will help in service
    // startup. So, call this before ConfigureSensIfNecessary()
    //
    if (FALSE == DoEventSystemSetup())
        {
        SensPrintA(SENS_ERR, ("[%d] DoEventSystemSetup() failed.\n", GetTickCount()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("[%d] DoEventSystemSetup() Succeeded.\n", GetTickCount()));
        }

    if (FALSE == ConfigureSensIfNecessary())
        {
        SensPrintA(SENS_ERR, ("[%d] ConfigureSensIfNecessary() failed.\n", GetTickCount()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("[%d] ConfigureSensIfNecessary() Succeeded.\n", GetTickCount()));
        }

    if (FALSE == DoWanSetup())
        {
        SensPrintA(SENS_ERR, ("[%d] DoWanSetup() failed.\n", GetTickCount()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("[%d] DoWanSetup() Succeeded.\n", GetTickCount()));
        }

    if (FALSE == DoLanSetup())
        {
        SensPrintA(SENS_ERR, ("[%d] DoLanSetup() failed.\n", GetTickCount()));
        bRetValue = FALSE;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("[%d] DoLanSetup() Succeeded.\n", GetTickCount()));

    if (FALSE == DoRpcSetup())
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup() failed.\n", GetTickCount()));
        bRetValue = FALSE;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("[%d] DoRpcSetup() Succeeded.\n", GetTickCount()));

    bRetValue = TRUE;

    SensPrintA(SENS_DBG, ("[%d] Service start took %d msec.\n", GetTickCount(), (GetTickCount() - dwNow)));

Cleanup:
    //
    // Cleanup
    //

	if (bComInitialized)
		{
		//
		// This thread (service start) will exit shortly after we return.  Our event system
		// instance and other COM registrations are kept alive by the main svchost thread
		// which is initialized MTA.
		//
		CoUninitialize();
		}

    return bRetValue;
}


inline void
InitializeSensGlobals(
    void
    )
/*++

Routine Description:

    Initialize the global variables. This is needed if we are to run
    within svchost.exe.

Arguments:

    None.

Notes:

    Some of the SENS globals are initialized during SensInitialize()
    processing. Look at ServiceMain(), DoLanSetup(), DoWanSetup() etc.

Return Value:

    None.

--*/
{
    //
    // Common across platforms
    //

    // Pointers
    gpReachList         = NULL;
    gpIEventSystem      = NULL;
    gpSensCache         = NULL;
    gpChangeCF          = NULL;

    // Handles
    ghSensHeap          = NULL;
    ghReachTimer        = NULL;
    ghSensFileMap       = NULL;
    ghSensStartedEvent  = NULL;
    // BOOLs
    gbIpInitSuccessful      = FALSE;
    gbIsRasInstalled        = FALSE;
    gdwLocked               = FALSE;
    // DWORDs
    gdwLastLANTime      = 0x0;
    gdwLANState         = 0x0;
    gdwLastWANTime      = 0x0;
    gdwWANState         = 0x0;
    gdwRegCO            = 0x0;
    g_cFilterObj        = 0x0;
    g_cFilterLock       = 0x0;
    g_cSubChangeObj     = 0x0;
    g_cSubChangeLock    = 0x0;
    gdwMediaSenseState = SENSSVC_START;
    // Structures
    memset(gIfState, 0x0, (sizeof(IF_STATE) * MAX_IF_ENTRIES));
    memset(&gIpStats, 0x0, sizeof(MIB_IPSTATS));
    memset(&gSystemPowerState, 0x0, sizeof(SYSTEM_POWER_STATUS));
    memset(&gSensLock, 0x0, sizeof(CRITICAL_SECTION));
}


inline BOOL
Init(
    void
    )
/*++

Routine Description:

    Perform initialization at startup.

Arguments:

    None.

Notes:

    This should be called early in SensInitialize().

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    HRESULT hr;
    BOOL bRetValue;
    BOOL bComInitialized;
    OSVERSIONINFO VersionInfo;

    hr = S_OK;
    bRetValue = FALSE;
    bComInitialized = FALSE;

    // Reset
    InitializeSensGlobals();

    //
    // Initialize COM
    //
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("[%d] CoInitializeEx() failed, HRESULT=%x\n", GetTickCount(), hr));
        bRetValue = FALSE;
        goto Cleanup;
        }
    bComInitialized = TRUE;

    // Use Default Process heap
    ghSensHeap = GetProcessHeap();
    if (ghSensHeap == NULL)
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] Failed to obtain ProcessHeap() - 0x%x!\n", GetLastError()));
        bRetValue = FALSE;
        goto Cleanup;
        }

    // Initialize Sens Global lock
    InitializeCriticalSection(&gSensLock);

    // Destination Reachability Event setup
    if (FALSE == InitReachabilityEngine())
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] Failed to initialize reachability engine!\n"));
        bRetValue = FALSE;
        goto Cleanup;
        }

    gpIEventSystem = NULL;

    if (FALSE == CreateSensCache())
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] Failed to create SENS Cache!\n"));
        }

    // Get a handle to the SensStartEvent.
    // The event is created in the wlnotify dll (winlogon).
    ghSensStartedEvent = OpenEvent(
                             EVENT_ALL_ACCESS,  // Access Flag
                             FALSE,             // Inheritable
                             SENS_STARTED_EVENT // Name of the event
                             );
    if (ghSensStartedEvent == NULL)
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] Failed to Open SensStartedEvent - 0x%x!\n", GetLastError()));
        }
    else
        {
        SensPrint(SENS_INFO, (SENS_STRING("[%d] Successfully opened SensStartedEvent.\n"), GetTickCount()));
        }

    bRetValue = TRUE;

Cleanup:
    //
    // Cleanup stuff when we fail to Init properly.
    //
    if (FALSE == bRetValue)
        {
        // Release EventSystem
        if (gpIEventSystem != NULL)
            {
            gpIEventSystem->Release();
			gpIEventSystem = 0;
            }

        // Uninit COM because SensUninitialize() is not going to be called.
        if (TRUE == bComInitialized)
            {
            CoUninitialize();
            }
        }

    return bRetValue;
}


BOOL
CreateSids(
    PSID*	ppsidBuiltInAdministrators,
    PSID*	ppsidSystem,
    PSID*	ppsidWorld
)
/*++

Routine Description:

    Creates and return pointers to three SIDs one for each of World,
    Local Administrators, and System.
	
	
Note:

	IDENTICAL TO A FUNCTION IN OLE32\DCOMSS\WRAPPER\EPTS.C.		

Arguments:

    ppsidBuiltInAdministrators - Receives pointer to SID representing local
        administrators; 
    ppsidSystem - Receives pointer to SID representing System;
    ppsidWorld - Receives pointer to SID representing World.

Return Value:

    BOOL indicating success (TRUE) or failure (FALSE).

    Caller must free returned SIDs by calling FreeSid() for each returned
    SID when this function return TRUE; pointers should be assumed garbage
    when the function returns FALSE.

--*/
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Local
    // Administrators is in the "built in" domain.  The other SIDs, for
    // Authenticated users and system, is based directly off of the
    // authority. 
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  ppsidBuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authorities
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         0,0,0,0,0,0,0,
                                         ppsidSystem)) {

        // error

        FreeSid(*ppsidBuiltInAdministrators);
        *ppsidBuiltInAdministrators = NULL;

    } else if (!AllocateAndInitializeSid(&WorldAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_WORLD_RID,
                                         0,0,0,0,0,0,0,
                                         ppsidWorld)) {

        // error

        FreeSid(*ppsidBuiltInAdministrators);
        *ppsidBuiltInAdministrators = NULL;

        FreeSid(*ppsidSystem);
        *ppsidSystem = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


PSECURITY_DESCRIPTOR
CreateSd(
    VOID
)
/*++

Routine Description:

    Creates and return a SECURITY_DESCRIPTOR with a DACL granting
    (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE) to World,
    and GENERIC_ALL to Local Administrators and System.
	
Notes: 

	SIMILAR TO A FUNCTION IN OLE32\DCOMSS\WRAPPER\EPTS.C.	

Arguments:

    None

Return Value:

    Pointer to the created SECURITY_DESCRIPTOR, or NULL if an error occurred.

    Caller must free returned SECURITY_DESCRIPTOR back to process heap by
    a call to HeapFree.

--*/
{
    PSID	psidWorld;
    PSID	psidBuiltInAdministrators;
    PSID	psidSystem;

    if (!CreateSids(&psidBuiltInAdministrators,
                    &psidSystem,
                    &psidWorld)) {

        // error

    } else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        PSECURITY_DESCRIPTOR    Sd = NULL;
        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(psidWorld) +
            GetLengthSid(psidBuiltInAdministrators) +
            GetLengthSid(psidSystem);

        Sd = (PSID)new char[SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize];

        if (!Sd) {

            // error

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                // error

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                            psidWorld)) {

                // Failed to build the ACE granting "WORLD"
                // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            psidBuiltInAdministrators)) {

                // Failed to build the ACE granting "Built-in Administrators"
                // (GENERIC_ALL) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            psidSystem)) {

                // Failed to build the ACE granting "System"
                // GENERIC_ALL access.

            } else if (!InitializeSecurityDescriptor(Sd,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                // error

            } else if (!SetSecurityDescriptorDacl(Sd,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                // error

            } else {
                FreeSid(psidWorld);
                FreeSid(psidBuiltInAdministrators);
                FreeSid(psidSystem);

                return Sd;
            }

			delete (char *)Sd;
        }

        FreeSid(psidWorld);
        FreeSid(psidBuiltInAdministrators);
        FreeSid(psidSystem);
    }

    return NULL;
}


RPC_STATUS
RPC_ENTRY
SENS_CheckLocalCallback(
    RPC_IF_HANDLE ifhandle,
    void *Context
    )
/*++

Routine Description:

    SENS runs in a shared service host which means it is possible for a
    caller on another machine to call SENS.  This is not expected and is
    blocked by this callback routine in order to reduce the potential 
    attack surface of RPC.

Arguments:

    ifhandle - interface this callback is registered with (ignored)
    context - context to discover information about the caller (ignored)

Return Value:

    RPC_S_OK - caller allowed to call methods in the interface
    other - caller is blocked

--*/
{
    unsigned fLocal = FALSE;

    if (   (RPC_S_OK == I_RpcBindingIsClientLocal(0, &fLocal))
        && (fLocal) )
        {
        return RPC_S_OK;
        }

    return RPC_S_ACCESS_DENIED;
}



BOOL
DoRpcSetup(
    void
    )
/*++

Routine Description:

    Perform RPC server initialization.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    RPC_STATUS status;
    BOOL fDontWait;
    BOOL bRetValue;
    PSECURITY_DESCRIPTOR psd;

    status = RPC_S_OK;
    fDontWait = TRUE;
    bRetValue = FALSE;

	// Make sure RPC allocates thread stacks of sufficient size.
	status = RpcMgmtSetServerStackSize(2*4096);
	ASSERT(status == RPC_S_OK);

	psd = CreateSd();
	if (!psd)
		{
		bRetValue = FALSE;
		goto Cleanup; 
		}

    status = RpcServerUseProtseqEp(
                 SENS_PROTSEQ,
                 RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                 SENS_ENDPOINT,
                 psd            // Security descriptor
                 );

	delete (char *)psd;

    if (RPC_S_DUPLICATE_ENDPOINT == status)
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup(): Endpoint already created. Continuing!\n", GetTickCount()));
        status = RPC_S_OK;
        }

    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup(): RpcServerUseProtseqEp() returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }

    //
    // On NT platforms, use auto-listen interfaces. We don't need to call
    // RpcServerListen().
    //

    // SENS API interface
    status = RpcServerRegisterIfEx(
                 SensApi_ServerIfHandle,        // The interface
                 NULL,                          // MgrTypeUuid
                 NULL,                          // MgrEpv
                 RPC_IF_AUTOLISTEN,             // Flags
                 RPC_C_LISTEN_MAX_CALLS_DEFAULT,// Max calls value
                 SENS_CheckLocalCallback        // Security Callback function
                 );
    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup(): RpcServerRegisterIfEx(1) returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }

    // SensNotify interface
    status = RpcServerRegisterIfEx(
                 SENSNotify_ServerIfHandle,     // The interface
                 NULL,                          // MgrTypeUuid
                 NULL,                          // MgrEpv
                 RPC_IF_AUTOLISTEN,             // Flags
                 RPC_C_LISTEN_MAX_CALLS_DEFAULT,// Max calls value
                 SENS_CheckLocalCallback        // Security Callback function
                 );
    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] DoRpcSetup(): RpcServerRegisterIfEx(2) returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }

    // All's well.
    bRetValue = TRUE;

Cleanup:
    //
    // Cleanup
    //
    return bRetValue;
}




BOOL
SensUninitialize(
    void
    )
/*++

Routine Description:

    Perform any cleanup.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    int err;
    RPC_STATUS status;
    BOOL bRetValue;
    HRESULT hr;
    DWORD dwNow;

    bRetValue = TRUE;
    hr = S_OK;
    dwNow = GetTickCount();

    SensPrintA(SENS_ERR, ("[%d] Begin stopping of SENS Service...\n", dwNow));

    // Unregister media sense notifications.
    if (FALSE == MediaSenseUnregister())
        {
        SensPrintA(SENS_ERR, ("[%d] SensUninitialize(): MediaSenseUnregister() failed.\n", GetTickCount()));
        }
    else
        {
        SensPrintA(SENS_INFO, ("[%d] SensUninitialize(): MediaSenseUnregister() succeeded.\n", GetTickCount()));
        }

    // Unregister the RPC interface #1
    status = RpcServerUnregisterIf(
                 SensApi_ServerIfHandle,
                 NULL,   // MgrTypeUuid
                 FALSE   // WaitForCallsToComplete
                 );
	ASSERT(status == RPC_S_OK);
    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] SensUninitialize(): RpcServerUnegisterIf(1) returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("[%d] SensUninitialize(): RpcServerUnregisterIf(1) succeeded.\n", GetTickCount()));

    // Unregister the RPC interface #2
    status = RpcServerUnregisterIf(
                 SENSNotify_ServerIfHandle,
                 NULL,   // MgrTypeUuid
                 FALSE   // WaitForCallsToComplete
                 );
	ASSERT(status == RPC_S_OK);
    if (RPC_S_OK != status)
        {
        SensPrintA(SENS_ERR, ("[%d] SensUninitialize(): RpcServerUnegisterIf(2) returned 0x%x\n", GetTickCount(), status));
        bRetValue = FALSE;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("[%d] SensUninitialize(): RpcServerUnregisterIf(2) succeeded.\n", GetTickCount()));
    
	//
    // Remove our classfactory from COM's cache.
    //
    if (0x0 != gdwRegCO)
        {
        hr = CoRevokeClassObject(gdwRegCO);
        }

    if (NULL != gpChangeCF)
        {
        gpChangeCF->Release();
        }

    //
    // EventSystem specific cleanup.
    //
    if (gpIEventSystem)
        {
        gpIEventSystem->Release();
        }

    //
    // Stop Reachability polling
    //
    StopReachabilityEngine();

    //
    // Empty the destination reachability list
    //
    if (NULL != gpReachList)
        {
        delete gpReachList;

        gpReachList = NULL;
        }

    //
    // Destroy SENS Cache
    //
    DeleteSensCache();

    // Cleanup started event handle
    CloseHandle(ghSensStartedEvent);
    ghSensStartedEvent = 0;

    // Delete Global SENS lock
    DeleteCriticalSection(&gSensLock);

    bRetValue = TRUE;

    SensPrintToDebugger(SENS_DBG, ("\n[SENS] [%d] Service Stopped.\n\n", GetTickCount()));

Cleanup:
    //
    // Cleanup
    //

    // Cleanup Winsock.
    err = WSACleanup();
    if (err != 0)
        {
        SensPrintA(SENS_ERR, ("[%d] SensUninitialize(): WSACleanup() returned GLE of %d\n", GetTickCount(),
                   WSAGetLastError()));
        }

    SensPrintA(SENS_INFO, ("[%d] Stopping SENS took %d msec.\n\n", GetTickCount(), (GetTickCount()-dwNow)));

    return bRetValue;
}



BOOL
DoEventSystemSetup(
    void
    )
/*++

Routine Description:

    Perform the EventSystem specific initialization here.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    HRESULT hr;
    BOOL bRetValue;

    hr = S_OK;
    bRetValue = FALSE;

    //
    // Instantiate the Event System
    //
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &gpIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("[%d] Failed to create CEventSystem, HRESULT=%x\n", GetTickCount(), hr));
        goto Cleanup;
        }

    //
    // Create the IEventObjectChange ClassFactory and register it with COM.
    //
    gpChangeCF = new CIEventObjectChangeCF;
    if (NULL == gpChangeCF)
        {
        SensPrintA(SENS_ERR, ("[%d] Failed to allocate IEventObjectChange ClassFactory object", GetTickCount()));
        goto Cleanup;
        }
    // Add our reference to it.
    gpChangeCF->AddRef();

    SensPrintA(SENS_INFO, ("[%d] ClassFactory created successfully.\n", GetTickCount()));

    // Register the CLSID
    hr = CoRegisterClassObject(
             SENSGUID_SUBSCRIBER_LCE,
             (LPUNKNOWN) gpChangeCF,
             CLSCTX_LOCAL_SERVER,
             REGCLS_MULTIPLEUSE,
             &gdwRegCO
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("[%d] CoRegisterClassObject(IEventObjectChange) returned 0x%x.\n", GetTickCount(), hr));
        goto Cleanup;
        }

    SensPrintA(SENS_ERR, ("[%d] Successfully registered the Class Factories.\n", GetTickCount()));
    bRetValue = TRUE;

Cleanup:
    //
    // Cleanup
    //
    if (FALSE == bRetValue)
        {
        if (0x0 != gdwRegCO)
            {
            hr = CoRevokeClassObject(gdwRegCO);
            gdwRegCO = 0x0;
            }

        if (gpChangeCF)
            {
            delete gpChangeCF;
            gpChangeCF = NULL;
            }
        }

    return bRetValue;
}




BOOL
ConfigureSensIfNecessary(
    void
    )
/*++

Routine Description:

    Perform the configuration necessary for SENS.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise

--*/
{
    HRESULT hr;
    HKEY hKeySens;
    LONG RegStatus;
    BOOL bStatus;
    DWORD dwType;
    DWORD cbData;
    DWORD dwConfigured;
    LPBYTE lpbData;
    HMODULE hSensCfgDll;
    FARPROC pRegisterFunc;

    hr = S_OK;
    hKeySens = NULL;
    RegStatus = ERROR_SUCCESS;
    bStatus = FALSE;
    dwType = 0x0;
    cbData = 0x0;
    dwConfigured = CONFIG_VERSION_NONE;
    lpbData = NULL;
    hSensCfgDll = NULL;
    pRegisterFunc = NULL;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, // Handle of the key
                    SENS_REGISTRY_KEY,  // String which represents the sub-key to open
                    0,                  // Reserved (MBZ)
                    KEY_ALL_ACCESS,     // Security Access mask
                    &hKeySens           // Returned HKEY
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, ("RegOpenKeyEx(Sens) returned %d.\n", RegStatus));
        goto Cleanup;
        }

    //
    // Query the Configured value
    //
    lpbData = (LPBYTE) &dwConfigured;
    cbData = sizeof(DWORD);

    RegStatus = RegQueryValueEx(
                    hKeySens,           // Handle of the sub-key
                    IS_SENS_CONFIGURED, // Name of the Value
                    NULL,               // Reserved (MBZ)
                    &dwType,            // Address of the type of the Value
                    lpbData,            // Address of the data of the Value
                    &cbData             // Address of size of data of the Value
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, ("RegQueryValueEx(IS_SENS_CONFIGURED) failed with 0x%x\n", RegStatus));
        goto Cleanup;
        }
    ASSERT(dwType == REG_DWORD);

    if (dwConfigured >= CONFIG_VERSION_CURRENT)
        {
        SensPrintA(SENS_ERR, ("[%d] SENS is already configured!\n", GetTickCount()));
        bStatus = TRUE;
        goto Cleanup;
        }

    //
    // Sens is not yet configured to the latest version. So, do the necessary
    // work now.
    //

    // Try to Load the Configuration Dll
    hSensCfgDll = LoadLibrary(SENS_CONFIGURATION_DLL);
    if (hSensCfgDll == NULL)
        {
        SensPrintA(SENS_ERR, ("LoadLibrary(SensCfg) returned 0x%x.\n", GetLastError()));
        goto Cleanup;
        }

    // Get the required entry point.
    pRegisterFunc = GetProcAddress(hSensCfgDll, SENS_REGISTER_FUNCTION);
    if (pRegisterFunc == NULL)
        {
        SensPrintA(SENS_ERR, ("GetProcAddress(Register) returned 0x%x.\n", GetLastError()));
        goto Cleanup;
        }

    // Do the registration now.
    hr = (HRESULT)((*pRegisterFunc)());
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("RegisterSens() returned with 0x%x\n", hr));
        goto Cleanup;
        }

    // Update registry to reflect that SENS is now configured.
    dwConfigured = CONFIG_VERSION_CURRENT;
    RegStatus = RegSetValueEx(
                  hKeySens,             // Key to set Value for.
                  IS_SENS_CONFIGURED,   // Value to set
                  0,                    // Reserved
                  REG_DWORD,            // Value Type
                  (BYTE*) &dwConfigured,// Address of Value data
                  sizeof(DWORD)         // Size of Value
                  );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, ("RegSetValueEx(IS_SENS_CONFIGURED) failed with 0x%x\n", RegStatus));
        goto Cleanup;
        }


    SensPrintA(SENS_INFO, ("[%d] SENS is now configured successfully. Registry updated.\n", GetTickCount()));
    bStatus = TRUE;

Cleanup:
    //
    // Cleanup
    //
    if (hKeySens)
        {
        RegCloseKey(hKeySens);
        }
    if (hSensCfgDll)
        {
        FreeLibrary(hSensCfgDll);
        }

    return bStatus;
}

extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpvReserved
    )
/*++

Routine Description:

    This routine will get called either when a process attaches to this dll
    or when a process detaches from this dll.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    BOOL bSuccess;

    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
            // Disable Thread attach/detach calls
            bSuccess = DisableThreadLibraryCalls(hInstance);
            ASSERT(bSuccess == TRUE);

            // Use Default Process heap
            ghSensHeap = GetProcessHeap();
            ASSERT(ghSensHeap != NULL);
            break;

        case DLL_PROCESS_DETACH:
            break;

        }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\service.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    service.cxx

Abstract:

    This contains the Service related functionality of SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    This is cloned from \nt\private\eventsystem\server\eventsystem.cpp

Revision History:

    GopalP          1/11/1998         Start.

--*/


#include <precomp.hxx>
#include <winuser.h>
#include <dbt.h>
#include "service.hxx"


//
// Constants
//
#define SENS_NAME       SENS_STRING("SENS")
#define SENS_DATA       0x19732304
#define SENS_WAIT_HINT  3*1000

enum ACTION
{
    ACTION_NONE,
    ACTION_APPLICATION,
    ACTION_SERVICE
};

//
// Globals
//

DWORD                   gdwError;
HANDLE                  ghStopEvent;
extern HANDLE           ghSensStartedEvent;
SYSTEM_POWER_STATUS     gSystemPowerState;


//
// Service related stuff
//
SERVICE_STATUS          gServiceStatus;       // current status of the service
SERVICE_STATUS_HANDLE   ghStatusHandle;
HDEVNOTIFY              ghDeviceNotify;

SERVICE_TABLE_ENTRY gaServiceEntryTable[] = {
    { SENS_NAME, (LPSERVICE_MAIN_FUNCTION) ServiceMain },
    { NULL, NULL }
    };

//
// Helper functions
//


void __stdcall
LogMessage(
    TCHAR* msg1,
    TCHAR* msg2
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    const TCHAR* strings[2] = {msg1, msg2};
    HANDLE hEventSource;

    hEventSource = RegisterEventSource(NULL, SENS_STRING("SENS"));

    if (hEventSource != NULL)
        {
        ReportEvent(
            hEventSource,           // event source handle
            EVENTLOG_ERROR_TYPE,    // event type
            0,                      // event category
            0,                      // event ID
            NULL,                   // current user's SID
            2,                      // strings in lpszStrings
            0,                      // no bytes of raw data
            strings,                // array of error strings
            NULL                    // no raw data
            );

        DeregisterEventSource(hEventSource);
        }
}



void __stdcall
LogWin32Message(
    TCHAR* msg
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    LPVOID sysmsg;
    TCHAR msgbuf[256];
    DWORD rc = 1234;

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        rc,
        NULL,
        (LPTSTR) &sysmsg,
        0,
        NULL
        );

    wsprintf(msgbuf, SENS_STRING("Event System Win32 Error: %s\n"), sysmsg);

    LogMessage (msgbuf, msg);

    (void) LocalFree (sysmsg);
}


void
ServiceStart(
    void
    )
/*++

Routine Description:

    Start SENS as service.  Stay up until we receive the stop event.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // Initialize SENS.
    if (FALSE == SensInitialize())
        {
        LogWin32Message(SENS_STRING("ServiceStart(): SensInitialize() failed"));
        SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] SensInitialize() failed.\n", GetTickCount()));
        return;
        }

    // Tell the SCM that we're running now.
    if (!ReportStatusToSCM(SERVICE_RUNNING, NO_ERROR, 0))
        {
        LogWin32Message(SENS_STRING("ServiceStart(): ReportStatusToSCM failed"));
        SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] ReportStatusToSCM() failed.\n", GetTickCount()));

        return;
        }

    // Set the SensStartedEvent now.
    if (ghSensStartedEvent != NULL)
        {
        SetEvent(ghSensStartedEvent);
        SensPrintA(SENS_INFO, ("[%d] Successfully signalled starting of SENS.\n", GetTickCount()));
        }
    else
        {
        SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] Couldn't set the SENS Started event!\n", GetTickCount()));
        }

    SensPrintToDebugger(SENS_DBG, ("\n[SENS] [%d] Started successfully.\n\n", GetTickCount()));

}



void
ServiceStop(
    void
    )
/*++

Routine Description:

    Stop SENS as a service.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Cleanup now.
    //
    SensUninitialize();
}




VOID WINAPI
ServiceMain(
    DWORD argc,
    TCHAR* argv[]
    )
/*++

Routine Description:

    Perform the actual service initialization.

Arguments:

    Usual stuff.

Return Value:

    Usual stuff.

--*/
{
    //
    // Initialize Globals.
    //
    gdwError = 0x0;
    ghStopEvent = NULL;
    ghStatusHandle = NULL;
    memset(&gServiceStatus, 0x0, sizeof(SERVICE_STATUS));
    ghDeviceNotify = NULL;

    // Service status parameters that don't change.
    gServiceStatus.dwServiceType                = SERVICE_WIN32_OWN_PROCESS;
    gServiceStatus.dwCurrentState               = SERVICE_START_PENDING;
    gServiceStatus.dwControlsAccepted           = 0;
    gServiceStatus.dwWin32ExitCode              = 0;
    gServiceStatus.dwServiceSpecificExitCode    = 0;
    gServiceStatus.dwCheckPoint                 = 0;
    gServiceStatus.dwWaitHint                   = SENS_WAIT_HINT;

    //
    // Register our service control handler
    //
    DEV_BROADCAST_DEVICEINTERFACE PnPFilter;

    ghStatusHandle = RegisterServiceCtrlHandlerEx(
                          SENS_NAME,
                          ServiceControl,
                          (PVOID) SENS_DATA
                          );
    if (ghStatusHandle == NULL)
        {
        LogWin32Message(SENS_STRING("ServiceMain(): RegisterServiceCtrlHandlerEx() failed"));
        return;
        }

#ifdef PNP_EVENTS
    // Before enabling PnP events be aware that the code to unregister for the PnP
    // is missing.  Since SENS does not use the PnPs the code was all removed.

    //
    // Register for the PnP Device Interface change notifications
    //
    PnPFilter.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    PnPFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    PnPFilter.dbcc_reserved = 0x0;
    memcpy(
        &PnPFilter.dbcc_classguid,
        (LPGUID) &GUID_NDIS_LAN_CLASS,
        sizeof(GUID)
        );

    ghDeviceNotify = RegisterDeviceNotification(
                         (HANDLE) ghStatusHandle,
                         &PnPFilter,
                         DEVICE_NOTIFY_SERVICE_HANDLE
                         );
    if (NULL == ghDeviceNotify)
        {
        LogWin32Message(SENS_STRING("ServiceMain(): RegisterDeviceNotification() failed"));
        SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] ServiceMain(): RegisterDeviceNotification() failed\n", GetTickCount()));
        }

#ifdef DETAIL_DEBUG
    SensPrintToDebugger(SENS_DBG, ("[SENS] [%d] ServiceMain(): RegisterDeviceNotification() succeeded\n", GetTickCount()));
#endif // DETAIL_DEBUG

#endif // PNP_EVENTS

    //
    // Save a snapshot of the System Power State.
    //
    BOOL bRet = GetSystemPowerStatus(&gSystemPowerState);
    if (bRet == FALSE)
        {
        SensPrintA(SENS_ERR, ("SensMessageLoopThread(): GetSystemPowerStatus() failed with "
               "GLE = %d\n", GetLastError()));
        }
    ASSERT(bRet);

    // Report the status, the exit code, and the wait hint to the SCM.
    if (!ReportStatusToSCM(SERVICE_START_PENDING, NO_ERROR, SENS_WAIT_HINT))
        {
        LogWin32Message(SENS_STRING("ServiceMain(): ReportStatusToSCM() failed"));
        return;
        }

    // Start the service executing.
    ServiceStart();

    // Let the thread return.  We will use the stop thread to cleanup.

    return;
}




DWORD WINAPI
ServiceControl(
    DWORD dwCode,
    DWORD dwEventType,
    PVOID EventData,
    PVOID pData
    )
/*++

Routine Description:

    Handle Control Codes from SCM.

Arguments:

    dwCode - The control code.

    dwEventType - The type of the event.

    EventData - Data corresponding to the event.

    pData - Additional Data.

Notes:

    Refer to \\popcorn\razzle1\src\spec\umevent.doc for further details.

Return Value:

    None.

--*/
{

    PDEV_BROADCAST_DEVICEINTERFACE pDevice;
    NTSTATUS NtStatus;
    ANSI_STRING DeviceNameA;
    UNICODE_STRING UnicodeString;
    unsigned char *DeviceUuidA;
    DWORD  dwStatus = NO_ERROR;

    pDevice = (PDEV_BROADCAST_DEVICEINTERFACE) EventData;
    DeviceUuidA = NULL;

#ifdef DETAIL_DEBUG
    SensPrintToDebugger(SENS_DBG, ("[SENS] ServiceControl(): dwCode = 0x%x\n", dwCode));
#endif // DETAIL_DEBUG

    switch (dwCode)
        {
        case SERVICE_CONTROL_STOP:
            //
            // Stop the service.
            //
            // SERVICE_STOP_PENDING should be reported before setting the Stop
            // Event.  This avoids a race condition which may result in a 1053
            // - "The Service did not respond" error.
            //
            if (!ReportStatusToSCM(SERVICE_STOP_PENDING, NO_ERROR, SENS_WAIT_HINT))
                {
                LogWin32Message(SENS_STRING("ServiceControl(): ReportStatusToSCM() failed while stopping service"));
                }
            ServiceStop();

            if (!ReportStatusToSCM(SERVICE_STOPPED, NO_ERROR, 0))
                {
                LogWin32Message(SENS_STRING("ServiceControl(): ReportStatusToSCM() failed while stopping service"));
                }
            return dwStatus;

        case SERVICE_CONTROL_INTERROGATE:
            //
            // Update the service status.
            //

            if (!ReportStatusToSCM(gServiceStatus.dwCurrentState, NO_ERROR, 0))
                {
                LogWin32Message(SENS_STRING("ServiceControl(): ReportStatusToSCM() failed when logging current state"));
                }

            break;

#ifdef PNP_EVENTS
        case SERVICE_CONTROL_DEVICEEVENT:
            //
            // PnP event.
            //
#ifdef DETAIL_DEBUG
            RtlInitUnicodeString(&UnicodeString, (PCWSTR) &pDevice->dbcc_name);
            NtStatus = RtlUnicodeStringToAnsiString(&DeviceNameA, &UnicodeString, TRUE);
            UuidToStringA(&pDevice->dbcc_classguid, &DeviceUuidA);

            SensPrintToDebugger(SENS_DBG, ("\n-------------------------------------------------------------\n"));
            SensPrintToDebugger(SENS_DBG, ("SENS received a PnP Event - "));
            SensPrintToDebugger(SENS_DBG, ((dwEventType == DBT_DEVICEREMOVECOMPLETE) ? "DEVICE REMOVED\n" : ""));
            SensPrintToDebugger(SENS_DBG, ((dwEventType == DBT_DEVICEARRIVAL) ? "DEVICE ARRIVED\n" : "\n"));
            SensPrintToDebugger(SENS_DBG, ("\tdwCode        - 0x%x\n", dwCode));
            SensPrintToDebugger(SENS_DBG, ("\tdwEventType   - 0x%x\n", dwEventType));
            SensPrintToDebugger(SENS_DBG, ("\tpData         - 0x%x\n", pData));
            SensPrintToDebugger(SENS_DBG, ("\tEventData     - 0x%x\n", pDevice));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_size         - 0x%x\n", pDevice->dbcc_size));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_devicetype   - 0x%x\n", pDevice->dbcc_devicetype));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_reserved     - 0x%x\n", pDevice->dbcc_reserved));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_classguid    - %s\n", DeviceUuidA));
            SensPrintToDebugger(SENS_DBG, ("\t  o dbcc_name         - %s\n", DeviceNameA.Buffer));
            SensPrintToDebugger(SENS_DBG, ("-------------------------------------------------------------\n\n"));

            if (NT_SUCCESS(NtStatus))
                {
                RtlFreeAnsiString(&DeviceNameA);
                }
            if (DeviceUuidA != NULL)
                {
                RpcStringFreeA(&DeviceUuidA);
                }
#endif // DETAIL_DEBUG
            break;
#endif // PNP_EVENTS

        case SERVICE_CONTROL_POWEREVENT:
            {
            // 
            // Power event
            //

            //
            // These are generated every 1% of power change, also by playing
            // with the power cpl or plugging in the machine.
            // 

            SYSTEM_POWER_STATUS CurSPstate;
            SENSEVENT_POWER Data;
            BOOL bRet;
            BOOL bFireEvent = FALSE;

            bRet = GetSystemPowerStatus(&CurSPstate);
            ASSERT(bRet);

            switch(dwEventType) 
                {
                case PBT_APMPOWERSTATUSCHANGE:
                    {
                    //
                    // OnACPower event is fired when
                    //    o previously the machine was not on AC
                    //    o now, it is on AC
                    //
                    if (   (CurSPstate.ACLineStatus == AC_LINE_ONLINE)
                        && (gSystemPowerState.ACLineStatus != AC_LINE_ONLINE))
                        {
                        Data.eType = SENS_EVENT_POWER_ON_ACPOWER;
                        bFireEvent = TRUE;
                        }
                    else
                        //
                        // OnBatteryPower event is fired when
                        //    o previously the machine was on AC
                        //    o now, it is not on AC
                        //    o the machine has a system battery
                        //
                    if (   (CurSPstate.ACLineStatus == AC_LINE_OFFLINE)
                        && (gSystemPowerState.ACLineStatus == AC_LINE_ONLINE)
                        && ((CurSPstate.BatteryFlag & BATTERY_FLAG_NO_BATTERY) == 0))
                        {
                        Data.eType = SENS_EVENT_POWER_ON_BATTERYPOWER;
                        bFireEvent = TRUE;

                        // Special case, if the machine goes off battery and has a low
                        // battery we want to generate both events.  Resetting the
                        // low battery flag here guarantees that next time power changes
                        // we will fire the low battery event.
                        CurSPstate.BatteryFlag = CurSPstate.BatteryFlag & ~BATTERY_FLAG_LOW;
                        }
                    else
                        // OnBatteryPowerLow event is fired when
                        // o the battery is not charging and
                        // o previously the battery was not low
                        // o and now the battery is low.
                        //
                    if (     (CurSPstate.BatteryFlag & BATTERY_FLAG_LOW)
                        && ( (CurSPstate.BatteryFlag & BATTERY_FLAG_CHARGING) == 0)
                        && ( (gSystemPowerState.BatteryFlag & BATTERY_FLAG_LOW) == 0) )
                        {
                        Data.eType = SENS_EVENT_POWER_BATTERY_LOW;
                        bFireEvent = TRUE;
                        }
                    else 
                        {
                        // Power event we don't about
                        ASSERT(bFireEvent == FALSE);
                        }

                    break;
                    }

                default:
                    {
                    // Other power event we can ignore
                    break;
                    }
                }

            if (bFireEvent)
                {
                // Save the new state. A critsec is not necessary as service control messages are serialized.
                memcpy(&gSystemPowerState, &CurSPstate, sizeof(SYSTEM_POWER_STATUS));

                // Fire the event.
                memcpy(&Data.PowerStatus, &CurSPstate, sizeof(SYSTEM_POWER_STATUS));
                SensFireEvent(&Data);
                }

            dwStatus = SUCCESS;
            break;
            }

        default:

            dwStatus = ERROR_CALL_NOT_IMPLEMENTED;

            // invalid control code
            break;
        }
    
    return dwStatus;
}




BOOL
ReportStatusToSCM(
    DWORD dwCurrentState,
    DWORD dwExitCode,
    DWORD dwWaitHint
    )
/*++

Routine Description:

    Report status to SCM.

Arguments:

    dwCurrentState - The current state of the service.

    dwExitCode - The Win32 Exit code.

    dwWaitHint - The amount of time in msec to wait for the SCM to acknowledge.

Return Value:

    TRUE, succeeded.

    FALSE, otherwise.

--*/
{
    DWORD dwCheckPoint = 0;
    BOOL bResult = TRUE;

    if (dwCurrentState == SERVICE_START_PENDING)
        {
        gServiceStatus.dwControlsAccepted = 0;
        }
    else
        {
        gServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_POWEREVENT;
        }

    gServiceStatus.dwCurrentState   = dwCurrentState;
    gServiceStatus.dwWin32ExitCode  = dwExitCode;
    gServiceStatus.dwWaitHint       = dwWaitHint;

    if (   (dwCurrentState == SERVICE_RUNNING)
        || (dwCurrentState == SERVICE_STOPPED))
        {
        gServiceStatus.dwCheckPoint = 0;
        }
    else
        {
        gServiceStatus.dwCheckPoint = ++dwCheckPoint;
        }

    //
    // Report the status of the service to the SCM.
    // Caller handles error reporting, so we can have some context....
    //
    return SetServiceStatus(ghStatusHandle, &gServiceStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\sensload\sensload.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensload.cxx

Abstract:

    A BVT to load and test the Init/Uninit entrypoints of SENS.DLL

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          4/4/1998         Start.

--*/


#include <common.hxx>
#include <windows.h>
#include <objbase.h>
#include "useprint.hxx"

//
// Constants
//
#define SENS_INIT       "SensInitialize"
#define SENS_UNINIT     "SensUninitialize"
#define SENS_DLL        SENS_STRING("SENS.DLL")

//
// Forward declarations
//

BOOL APIENTRY
SensInitialize(
    void
    );

BOOL APIENTRY
SensUninitialize(
    void
    );



int
main(
    void
    )
{
    typedef BOOL (__stdcall *LPFN_SENSENTRYPOINT)(void);

    HRESULT hr;
    HMODULE hDLL;
    BOOL bStatus;
    BOOL bComInitialized;
    int RetValue;
    LPFN_SENSENTRYPOINT lpfnInit;
    LPFN_SENSENTRYPOINT lpfnUninit;

    hr = S_OK;
    bStatus = FALSE;
    bComInitialized = FALSE;
    RetValue = -1;
    
    //
    // Initialize COM
    //
    
    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, ("CoInitializeEx() failed, HRESULT=%x\n", hr));
        RetValue = -1;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("CoInitializeEx(APARTMENTTHREADED) succeeded.\n"));
    bComInitialized = TRUE;
    
    //
    // Load the library
    //
    
    hDLL = (HMODULE) LoadLibrary(SENS_DLL);
    if (hDLL == NULL)
        {
        SensPrint(SENS_ERR, (SENS_STRING("LoadLibrary(%s) failed with GLE of %d\n"),
                  SENS_DLL, GetLastError()));
        RetValue = -1;
        goto Cleanup;
        }
    SensPrint(SENS_INFO, (SENS_STRING("LoadLibrary(%s) succeeded.\n"), SENS_DLL));

    //
    // Get the entry points
    //

    lpfnInit = (LPFN_SENSENTRYPOINT) GetProcAddress(hDLL, SENS_INIT);
    if (lpfnInit == NULL)
        {
        SensPrintA(SENS_ERR, ("GetProcAddress(%s) failed with GLE of %d\n",
                   SENS_INIT, GetLastError()));
        RetValue = -1;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("GetProcAddress(%s) succeeded.\n", SENS_INIT));

    lpfnUninit = (LPFN_SENSENTRYPOINT) GetProcAddress(hDLL, SENS_UNINIT);
    if (lpfnUninit == NULL)
        {
        SensPrintA(SENS_ERR, ("GetProcAddress(%s) failed with GLE of %d\n",
                   SENS_UNINIT, GetLastError()));
        RetValue = -1;
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, ("GetProcAddress(%s) succeeded.\n", SENS_UNINIT));

    //
    // Call the entry points
    //

    SensPrintA(SENS_INFO, ("\n\n---------------------------------------------\n"));
    bStatus = (*lpfnInit)();
    SensPrintA(SENS_INFO, ("%s() returned %d.\n", SENS_INIT, bStatus));
    SensPrintA(SENS_INFO, ("\n\n---------------------------------------------\n\n"));
    if (bStatus == FALSE)
        {
        RetValue = -1;
        goto Cleanup;
        }

    SensPrintA(SENS_INFO, ("Sleeping for 10 seconds...\n"));
    Sleep(10 * 1000);

    SensPrintA(SENS_INFO, ("\n\n---------------------------------------------\n"));
    bStatus = (*lpfnUninit)();
    SensPrintA(SENS_INFO, ("%s() returned %d.\n", SENS_UNINIT, bStatus));
    SensPrintA(SENS_INFO, ("\n\n---------------------------------------------\n"));
    if (bStatus == FALSE)
        {
        RetValue = -1;
        goto Cleanup;
        }

    bStatus = FreeLibrary(hDLL);
    if (bStatus != TRUE)
        {
        SensPrint(SENS_INFO, (SENS_STRING("FreeLibrary(%s) failed with GLE of %d\n"),
                  SENS_DLL, GetLastError()));
        }
    SensPrint(SENS_INFO, (SENS_STRING("FreeLibrary(%s) succeeded.\n"), SENS_DLL));

    RetValue = 0;

Cleanup:
    //
    // Cleanup
    //
    if (TRUE == bComInitialized)
        {
        // Uninit COM
        CoUninitialize();
        }
        
    return RetValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\syncmgr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    syncmgr.cxx

Abstract:

    This file contains code for Syncmgr to workaround the security
    restrictions placed on HKLM registry key. Normal users cannot
    write to HKLM now. So, SENS (running as LocalSystem) does the
    dirty work for Syncmgr.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    This code is authored by RogerG.

Revision History:

    GopalP          3/10/1999         Start.
    
    RogerG          9/29/1999         Plug security holes.

--*/


#include <precomp.hxx>




typedef enum SYNCMGRCMDEXECID
{
    SYNCMGRCMDEXECID_UPDATERUNKEY = 1,
    SYNCMGRCMDEXECID_RESETREGSECURITY = 2,
} SYNCMGRCMDEXECID;


// functions local to file implementation is in.
HRESULT SyncMgrExecCmdUpdateRunKey(DWORD nCmdID, DWORD nCmdExecOpt);
HRESULT SyncMgrExecCmdResetRegSecurity(DWORD nCmdID, DWORD nCmdExecOpt);

BOOL SyncMgrGetSecurityDescriptor(SECURITY_ATTRIBUTES *psa,PSECURITY_DESCRIPTOR psd,
                                           PACL *ppOutAcl);
BOOL SyncMgrSetRegKeySecurityEveryone(HKEY hKeyParent,LPCTSTR lpSubKey,SECURITY_DESCRIPTOR *psd); // helper function
HRESULT SyncSetSubKeySecurityEveryone(HKEY hKeyParent,SECURITY_DESCRIPTOR *psd); // helper function
// end of local function delclaration

//--------------------------------------------------------------------------------
//
//  FUNCTION: RPC_SyncMgrExecCmd, public
//
//  PURPOSE: Executes specified SyncMgr cmd.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

error_status_t RPC_SyncMgrExecCmd(handle_t hRpc, DWORD nCmdID, DWORD nCmdExecOpt)
{
HRESULT hr = E_UNEXPECTED;

    switch (nCmdID)
    {
    case SYNCMGRCMDEXECID_UPDATERUNKEY:
        hr =  SyncMgrExecCmdUpdateRunKey(nCmdID,nCmdExecOpt);
        break;
    case SYNCMGRCMDEXECID_RESETREGSECURITY:
        hr =  SyncMgrExecCmdResetRegSecurity(nCmdID,nCmdExecOpt);
        break;
    default:
        hr = S_FALSE;
        break;
    }

    return hr;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncMgrExecCmdUpdateRunKey
//
//  PURPOSE: Updates the RunKey under HKLM to set if mobsync.exe
//            is run on shell startup.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

const TCHAR szRunKey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const TCHAR szRunKeyCommandLine[]  = TEXT("%SystemRoot%\\system32\\mobsync.exe /logon");
const TCHAR szRunKeyValueName[] = TEXT("Synchronization Manager");

HRESULT SyncMgrExecCmdUpdateRunKey(DWORD nCmdID, DWORD nCmdExecOpt)
{
HRESULT hr;
HKEY hKeyRun;
BOOL fLogon = nCmdExecOpt ? TRUE : FALSE; // CmdExecOpt of zero means to remove, else write.

    if (ERROR_SUCCESS == (hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szRunKey,
                              NULL,KEY_READ | KEY_WRITE,&hKeyRun)))
    {
        if (fLogon)
        {
            hr = RegSetValueEx(hKeyRun, szRunKeyValueName, 0, REG_EXPAND_SZ,
                    (BYTE *) szRunKeyCommandLine,(lstrlen(szRunKeyCommandLine) + 1)*sizeof(TCHAR));
        }
        else
        {
            hr = RegDeleteValue(hKeyRun, szRunKeyValueName);
        }

        RegCloseKey(hKeyRun);
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncMgrGetSecurityDescriptor
//
//  PURPOSE: Creates an appropriate secuirty descriptor to set on
//           the subkeys.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

BOOL SyncMgrGetSecurityDescriptor(SECURITY_ATTRIBUTES *psa
                                          ,PSECURITY_DESCRIPTOR psd,
                                           PACL *ppOutAcl)
{
BOOL bRetVal;
int cbAcl;
PACL pAcl = NULL;
PSID pInteractiveUserSid = NULL;
PSID pLocalSystemSid = NULL;
PSID pAdminsSid = NULL;
SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY LocalSystemAuthority = SECURITY_NT_AUTHORITY;

    *ppOutAcl = NULL;

    bRetVal = FALSE;

    // in the structure.

    bRetVal = InitializeSecurityDescriptor(
              psd,                          // Pointer to SD
              SECURITY_DESCRIPTOR_REVISION  // SD revision
              );

    if (!bRetVal)
    {
        goto errRtn;
    }

    // setup acls.

    bRetVal = AllocateAndInitializeSid(
                  &LocalSystemAuthority,      // Pointer to identifier authority
                  1,                    // Count of subauthority
                  SECURITY_INTERACTIVE_RID,   // Subauthority 0
                  0,                    // Subauthority 1
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pInteractiveUserSid            // pointer to pointer to SID
                  );



    if (!bRetVal)
    {
        goto errRtn;
    }

    bRetVal = AllocateAndInitializeSid(
                  &LocalSystemAuthority,// Pointer to identifier authority
                  2,                    // Count of subauthority
                  SECURITY_BUILTIN_DOMAIN_RID,  // Subauthority 1
                  DOMAIN_ALIAS_RID_ADMINS,      // Subauthority 2
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pAdminsSid           // pointer to pointer to SID
                  );

    if (!bRetVal)
    {
        goto errRtn;
    }


    bRetVal = AllocateAndInitializeSid(
              &LocalSystemAuthority,// Pointer to identifier authority
              1,                    // Count of subauthority
              SECURITY_LOCAL_SYSTEM_RID,   // Subauthority 0
              0,                    // Subauthority 1
              0,                    // Subauthority 2
              0,                    // Subauthority 3
              0,                    // Subauthority 4
              0,                    // Subauthority 5
              0,                    // Subauthority 6
              0,                    // Subauthority 7
              &pLocalSystemSid      // pointer to pointer to SID
              );

    if (!bRetVal)
    {
        goto errRtn;
    }

    cbAcl =   sizeof (ACL)
        + 3 * sizeof (ACCESS_ALLOWED_ACE)
        + GetLengthSid(pInteractiveUserSid)
        + GetLengthSid(pLocalSystemSid)
        + GetLengthSid(pAdminsSid);

    pAcl = (PACL) new char[cbAcl];

    if (NULL == pAcl)
    {
        bRetVal = FALSE;
        goto errRtn;
    }

    bRetVal = InitializeAcl(
              pAcl,             // Pointer to the ACL
              cbAcl,            // Size of ACL
              ACL_REVISION      // Revision level of ACL
              );

    if (!bRetVal)
    {
        goto errRtn;
    }


    bRetVal = AddAccessAllowedAce(
              pAcl,             // Pointer to the ACL
              ACL_REVISION,     // ACL revision level
              SPECIFIC_RIGHTS_ALL | GENERIC_READ | DELETE ,    // Access Mask
              pInteractiveUserSid         // Pointer to SID
              );

    if (!bRetVal)
    {
        goto errRtn;
    }


    bRetVal = AddAccessAllowedAce(
              pAcl,             // Pointer to the ACL
              ACL_REVISION,     // ACL revision level
              GENERIC_ALL,      // Access Mask
              pAdminsSid        // Pointer to SID
          );

   if (!bRetVal)
    {
        goto errRtn;
    }

    bRetVal = AddAccessAllowedAce(
              pAcl,             // Pointer to the ACL
              ACL_REVISION,     // ACL revision level
              GENERIC_ALL,      // Access Mask
              pLocalSystemSid   // Pointer to SID
              );

    if (!bRetVal)
    {
        goto errRtn;
    }

    bRetVal =  SetSecurityDescriptorDacl(psd,TRUE,pAcl,FALSE);

    if (!bRetVal)
    {
        goto errRtn;
    }

    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = psd;
    psa->bInheritHandle = FALSE;

errRtn:

    if (pInteractiveUserSid)
    {
        FreeSid(pInteractiveUserSid);
    }

    if (pLocalSystemSid)
    {
        FreeSid(pLocalSystemSid);
    }

    if (pAdminsSid)
    {
        FreeSid(pAdminsSid);
    }

    //
    // On failure, we clean the ACL up. On success, the caller cleans
    // it up after using it.
    //
    if (FALSE == bRetVal)
    {
        if (pAcl)
        {
            delete pAcl;
        }
    }
    else
    {
        *ppOutAcl = pAcl;
    }

    return bRetVal;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncMgrExecCmdResetRegSecurity
//
//  PURPOSE: Makes sure HKLM..\SyncMgr key and all keys below
//              it can be accessed by all users.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

const TCHAR szSyncMgrTopLevelKey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr");

HRESULT SyncMgrExecCmdResetRegSecurity(DWORD nCmdID, DWORD nCmdExecOpt)
{
HRESULT hr = E_UNEXPECTED;
SECURITY_ATTRIBUTES sa;
SECURITY_DESCRIPTOR sd;
PACL pAcl = NULL;

    if (!SyncMgrGetSecurityDescriptor(&sa,&sd,&pAcl))
    {
        SensPrintA(SENS_ERR, ("Unable to GetSecurity Attribs"));

        return E_FAIL;
    }


    // first try to set toplevel key
    if (SyncMgrSetRegKeySecurityEveryone(HKEY_LOCAL_MACHINE,szSyncMgrTopLevelKey,&sd))
    {
    HKEY hKeySyncMgr;

        // open the Key with REG_OPTION_OPEN_LINK so if someone places a symbolic
        // link under syncmgr we don't traverse it.
        if (ERROR_SUCCESS == (hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,szSyncMgrTopLevelKey,
                              REG_OPTION_OPEN_LINK,KEY_READ | KEY_WRITE,&hKeySyncMgr)) )
        {
            SyncSetSubKeySecurityEveryone(hKeySyncMgr,&sd);
            RegCloseKey(hKeySyncMgr);
       }

    }

    if (pAcl)
    {
        delete pAcl;
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncSetSubKeySecurity
//
//  PURPOSE: sets the security on all subkeys on the parent to everyone.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

#define MAX_KEY_LENGTH  255

HRESULT SyncSetSubKeySecurityEveryone(HKEY hKeyParent,SECURITY_DESCRIPTOR *psd)
{
HRESULT hr;
HRESULT hrSubKey;
int iIndexCount;
DWORD  cbSubKey;
TCHAR  szSubKey[MAX_KEY_LENGTH];

    iIndexCount = 0;
    hr = ERROR_SUCCESS;
    hrSubKey = ERROR_SUCCESS;

    do
    {
    HKEY hKeySubKey;
    HRESULT hrCurSubKey;

        cbSubKey = MAX_KEY_LENGTH;
        hr = RegEnumKeyEx(hKeyParent,iIndexCount,szSubKey,&cbSubKey,NULL,NULL,NULL,NULL);

        if(hr != ERROR_SUCCESS)
        {
           hr = (ERROR_NO_MORE_ITEMS == hr) ? ERROR_SUCCESS : hr;
           break;
        }

        SyncMgrSetRegKeySecurityEveryone(hKeyParent,szSubKey,psd);

        // failure to open want to remember error but keep going through
        // remaining subkeys.
        if (ERROR_SUCCESS == (hrCurSubKey = RegOpenKeyEx (hKeyParent,szSubKey,REG_OPTION_OPEN_LINK ,KEY_READ | KEY_WRITE, &hKeySubKey)))
        {
            hrCurSubKey = SyncSetSubKeySecurityEveryone(hKeySubKey,psd);
            RegCloseKey(hKeySubKey);
        }

        if (ERROR_SUCCESS != hrCurSubKey)
        {
            hrSubKey = hrCurSubKey;
        }

        ++iIndexCount;

    } while (ERROR_SUCCESS == hr);


    return (ERROR_SUCCESS != hr) ? hr : hrSubKey;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: SyncMgrSetRegKeySecurityEveryone
//
//  PURPOSE: Gives Everyone all access to the specified RegKey.
//
//
//  COMMENTS:
//
//
//--------------------------------------------------------------------------------

BOOL SyncMgrSetRegKeySecurityEveryone(HKEY hKeyParent,LPCTSTR lpSubKey,SECURITY_DESCRIPTOR *psd)
{
BOOL fResult = FALSE;
HKEY hKey = NULL;

    // key must be openned with WRITE_DAC

    if (ERROR_SUCCESS != RegOpenKeyEx(hKeyParent,
        lpSubKey,
        REG_OPTION_OPEN_LINK, WRITE_DAC,&hKey) )
    {
        hKey = NULL;
    }

    if (hKey)
    {
        if (ERROR_SUCCESS == RegSetKeySecurity(hKey,
            (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
            psd) )
        {
            fResult = TRUE;
        }

        RegCloseKey(hKey);
    }

    ASSERT(TRUE == fResult); // debugging lets find out when this fails.

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senssvc\wan.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    wan.cxx

Abstract:

    This is the source file relating to the WAN-specific routines of the
    Connectivity APIs implementation.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include <precomp.hxx>

//
// Typedefs
//
typedef DWORD (APIENTRY *LPFN_RAS_ENUM)(LPRASCONN, LPDWORD, LPDWORD);
typedef BOOL  (APIENTRY *LPFN_DO_CONNECTOIDS_EXIST)(void);
typedef DWORD (APIENTRY *LPFN_RAS_CONNECTION_NOTIFICATION)(HRASCONN, HANDLE, DWORD);
typedef DWORD (APIENTRY *LPFN_RAS_GET_CONNECT_STATUS)(HRASCONN, LPRASCONNSTATUS);



//
// Constants
//
#define RAS_DLL         SENS_STRING("RasApi32.dll")
#define WININET_DLL     SENS_STRING("Wininet.dll")

#if !defined(SENS_CHICAGO)
#define RAS_ENUM                    "RasEnumConnectionsW"
#define RAS_CONNECTION_NOTIFICATION "RasConnectionNotificationW"
#else     // SENS_CHICAGO
#define RAS_ENUM                    "RasEnumConnectionsA"
#define RAS_CONNECTION_NOTIFICATION "RasConnectionNotificationA"
#define RAS_GET_CONNECT_STATUS      "RasGetConnectStatusA"
#define DO_CONNECTOIDS_EXIST        (LPCSTR) 101    // Ordinal 101
#endif    // SENS_CHICAGO

#if (WINVER < 0x401)
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#endif // WINVER < 0x401



//
// Globals
//

// Common
long            gdwLastWANTime;
long            gdwWANState;
BOOL            gbIsRasInstalled;
LPFN_RAS_ENUM   glpfnRasEnumConnections;
LPFN_RAS_CONNECTION_NOTIFICATION glpfnRasConnectionNotification;

// IE5-specific
#if !defined(SENS_NT5)
HANDLE          ghRasEvents[2];
HANDLE          ghConnectWait;
HANDLE          ghDisconnectWait;
#endif // SENS_NT5

// Win9x-specific
#if defined(SENS_CHICAGO)
LPFN_RAS_GET_CONNECT_STATUS glpfnRasGetConnectStatus;
#endif // SENS_CHICAGO





inline void
LoadRasIfNecessary(
    void
    )
/*++

Routine Description:

    Load RAS DLL, if necessary.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HMODULE hDLL;

    //
    // See if RAS DLL is already loaded.
    //
    if (NULL != glpfnRasEnumConnections)
        {
        return;
        }

    //
    // Do the necessary work.
    //
    hDLL = LoadLibrary(RAS_DLL);
    if (hDLL != NULL)
        {
        glpfnRasEnumConnections = (LPFN_RAS_ENUM) GetProcAddress(hDLL, RAS_ENUM);
        glpfnRasConnectionNotification = (LPFN_RAS_CONNECTION_NOTIFICATION)
                                         GetProcAddress(hDLL, RAS_CONNECTION_NOTIFICATION);
#if defined(SENS_CHICAGO)
        glpfnRasGetConnectStatus = (LPFN_RAS_GET_CONNECT_STATUS)
                                   GetProcAddress(hDLL, RAS_GET_CONNECT_STATUS);
#endif // SENS_CHICAGO

        if (
               (NULL == glpfnRasEnumConnections)
#if defined(SENS_CHICAGO)
            && (NULL == glpfnRasGetConnectStatus)
#endif // SENS_CHICAGO
           )
            {
            // Both entrypoints are NULL. Can't do much with RAS now.
            FreeLibrary(hDLL);
            }
        }

    SensPrintA(SENS_INFO, ("[SENS] LoadRasIfNecessary(): RAS DLL is %spresent.\n",
               (glpfnRasEnumConnections ? "" : "NOT ")));

}




BOOL
DoWanSetup(
    void
    )
/*++

Routine Description:

    Do minimal WAN Setup.

Arguments:

    None.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    DWORD dwLastError;
    DWORD dwCurrentRasState;
    BOOL bStatus;

    dwLastError = 0;
    dwCurrentRasState = 0;
    bStatus = FALSE;
    glpfnRasEnumConnections = NULL;
    glpfnRasConnectionNotification = NULL;
    gbIsRasInstalled = FALSE;
    bStatus = TRUE;

Cleanup:
    //
    // Cleanup
    //
    return bStatus;
}


BOOL
IsRasInstalled(
    OUT LPDWORD lpdwState,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Check to see if RAS is installed. If so, return it's current state.

Arguments:

    lpdwState - If Ras is installed, this parameter contains the current state
        of the RasMan service.

    lpdwLastError - If RAS is not active or installed, it retuns the GLE.

Return Value:

    TRUE, if Ras is installed.

    FALSE, otherwise.

--*/
{
    if (TRUE == gbIsRasInstalled)
        {
        *lpdwState = SERVICE_RUNNING;   // For NT
        *lpdwLastError = ERROR_SUCCESS;

        return TRUE;
        }

    static SC_HANDLE hSCM;      // Cache the handle.
    static SC_HANDLE hRasMan;   // Cache the handle.

    BOOL bRetValue;
    SERVICE_STATUS ServiceStatus;

    bRetValue = FALSE;
    *lpdwState = 0;
    *lpdwLastError = ERROR_SUCCESS;

    if (NULL == hSCM)
        {
        hSCM = OpenSCManager(
                   NULL,                   // Local machine
                   NULL,                   // Default database - SERVICES_ACTIVE_DATABASE
                   SC_MANAGER_ALL_ACCESS   // NOTE: Only for Administrators
                   );
        if (NULL == hSCM)
            {
            SensPrintA(SENS_ERR, ("OpenSCManager() returned %d\n", *lpdwLastError));
            goto Cleanup;
            }
        }

    if (hRasMan == NULL)
        {
        hRasMan = OpenService(
                      hSCM,                 // Handle to SCM database
                      RAS_MANAGER,          // Name of the service to start
                      SERVICE_QUERY_STATUS  // Type of access requested
                      );
        if (NULL == hRasMan)
            {
            SensPrintA(SENS_ERR, ("OpenService() returned %d\n", *lpdwLastError));
            goto Cleanup;
            }
        }

    memset(&ServiceStatus, 0, sizeof(SERVICE_STATUS));

    bRetValue = QueryServiceStatus(
                    hRasMan,
                    &ServiceStatus
                    );
    ASSERT(bRetValue == TRUE);

    if (FALSE == bRetValue)
        {
        goto Cleanup;
        }

    *lpdwState = ServiceStatus.dwCurrentState;

    gbIsRasInstalled = TRUE;

    SensPrintA(SENS_ERR, ("IsRasInstalled(): RASMAN state is %d\n",
               *lpdwState));

    return TRUE;

Cleanup:
    //
    // Cleanup
    //
    *lpdwLastError = GetLastError();

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        hSCM = NULL;
        }
    if (hRasMan)
        {
        CloseServiceHandle(hRasMan);
        hRasMan = NULL;
        }

    return FALSE;
}




BOOL WINAPI
EvaluateWanConnectivity(
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    BOOL bWanAlive;
    BOOL bRasInstalled;
    DWORD dwNow;
    DWORD dwCurrentRasState;
    SERVICE_STATUS ServiceStatus;
    PWCHAR szEntryName;
    DWORD dwLocalLastError;

    dwNow = GetTickCount();
    bWanAlive = FALSE;
    dwCurrentRasState = 0;
    dwLocalLastError = ERROR_NO_NETWORK;

	if (lpdwLastError)
        {
        *lpdwLastError = dwLocalLastError;
        }
    else
        {
        lpdwLastError = &dwLocalLastError;
        }

	szEntryName = new WCHAR[RAS_MaxEntryName + 1];
	if (!szEntryName )
		{
		*lpdwLastError = ERROR_OUTOFMEMORY;
		return FALSE;
		}

    wcscpy(szEntryName, DEFAULT_WAN_CONNECTION_NAME);

    //
    // If RasManager is running, it implies that there "might" be one or more
    // active RAS connections.
    //
    bRasInstalled = IsRasInstalled(&dwCurrentRasState, lpdwLastError);

    if (TRUE == bRasInstalled)
        {
        LoadRasIfNecessary();
        }

    if (   (bRasInstalled) 
        && (dwCurrentRasState == SERVICE_RUNNING)
        && (glpfnRasEnumConnections != NULL))
        {
        DWORD dwRasStatus;
        DWORD cBytes;
        DWORD cBytesOld;
        DWORD cConnections;
        RASCONN *pRasConn;

        dwRasStatus = 0x0;
        cConnections = 0;

        //
        // Start with loop with a single structure.  Will loop and realloc if we need
		// a larger buffer.
        //
		cBytesOld = 0;
		cBytes = sizeof(RASCONN);
		pRasConn = NULL;
		dwRasStatus = ERROR_BUFFER_TOO_SMALL;

        //
        // Loop till RasEnumConnections() succeeds or returns with an error
        // other than ERROR_BUFFER_TOO_SMALL.
        //
        while (ERROR_BUFFER_TOO_SMALL == dwRasStatus)
            {
            ASSERT(cBytes > cBytesOld);
			ASSERT(pRasConn == NULL);

            // Allocate the buffer
            pRasConn = (RASCONN *) new char[cBytes];
            if (pRasConn == NULL)
                {
				delete szEntryName;
				*lpdwLastError = ERROR_OUTOFMEMORY;
                return FALSE;
                }

            pRasConn[0].dwSize = sizeof(RASCONN);
            cBytesOld = cBytes;

            dwRasStatus = (*glpfnRasEnumConnections)(
                              pRasConn,
                              &cBytes,
                              &cConnections
                              );

            // Free the too small buffer.
            if (ERROR_BUFFER_TOO_SMALL == dwRasStatus)
                {
                delete pRasConn;
				pRasConn = NULL;
				SensPrintA(SENS_WARN, ("RasEnumConnections(): reallocing buffer to be %d bytes\n", cBytes));
                }
            }

        if ((0 == dwRasStatus) &&
            (cConnections > 0))
            {
            bWanAlive = TRUE;
            SensPrintA(SENS_INFO, ("RasEnumConnections(%d) successful connections (%d)\n", cBytes, cConnections));

            // P3 BUG: we're only dealing with one RAS connection for now
            SensPrintA(SENS_INFO, ("\tConnection name: %s\n", pRasConn->szEntryName));

            wcscpy(szEntryName, pRasConn->szEntryName);
            }
        else
            {
            if (dwRasStatus != 0)
                {
                *lpdwLastError = dwRasStatus;
                }
            SensPrintA(SENS_ERR, ("RasEnumConnections() returned %d - "
                       "connections (%d)\n", dwRasStatus, cConnections));
            }

    // Delete the RASCONN structure.
        delete pRasConn;

        } // if (bRasInstalled)


    SensPrintA(SENS_INFO, ("EvaluateWanConnectivity() returning %s, GLE of %d\n",
               bWanAlive ? "TRUE" : "FALSE", *lpdwLastError));


    if (InterlockedExchange(&gdwWANState, bWanAlive) != bWanAlive)
        {
        //
        // WAN Connectivity state changed.
        //
        BOOL bSuccess;
        DWORD dwActiveWanInterfaceSpeed;
        DWORD dwLastError;
        SENSEVENT_NETALIVE Data;

        dwLastError = ERROR_SUCCESS;
        dwActiveWanInterfaceSpeed = 0x0;

        if (bWanAlive)
            {
            bSuccess = GetActiveWanInterfaceStatistics(
                           &dwLastError,
                           &dwActiveWanInterfaceSpeed
                           );
#ifdef SENS_NT5
            // Will always fire on NT4/Win9x (due to bugs). Can fire on NT5.
            SensPrintA(SENS_WARN, ("GetActiveWanInterfaceStatistics() returned"
                       " FALSE, using defaults!\n"));
#endif // SENS_NT5
            }

        Data.eType = SENS_EVENT_NETALIVE;
        Data.bAlive = bWanAlive;
        memset(&Data.QocInfo, 0x0, sizeof(QOCINFO));
        Data.QocInfo.dwSize = sizeof(QOCINFO);
        Data.QocInfo.dwFlags = NETWORK_ALIVE_WAN;
        Data.QocInfo.dwInSpeed = dwActiveWanInterfaceSpeed;
        Data.QocInfo.dwOutSpeed = dwActiveWanInterfaceSpeed;
        Data.strConnection = szEntryName;

        UpdateSensCache(WAN);

        SensFireEvent((PVOID)&Data);
        }

    if (bWanAlive)
        {
        InterlockedExchange(&gdwLastWANTime, dwNow);
        }
    else
        {
        InterlockedExchange(&gdwLastWANTime, 0x0);
        }

    SensPrintA(SENS_INFO, ("RasEventNotifyRoutine(%d) - WAN Time is %d msec\n", dwNow, gdwLastWANTime));

	delete szEntryName;

    return bWanAlive;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\sens\conn\senstest\senstest.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senstest.cxx

Abstract:

    BVT for the SENS Connectivity APIs.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/13/1997         Start.

--*/


#include <common.hxx>
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <sensapi.h>
#include <conio.h>


//
// Globals
//
DWORD   gdwThreads;
DWORD   gdwInterval;

//
// Forwards
//

void
MultiThreadedTest(
    void
    );




inline void
Usage(
    void
    )
{
    printf("\nUsage:    senstest [Destination] \n");
    printf("          senstest [-m [Threads] [Interval]] \n\n");
    printf("Options:\n\n");
    printf("    Destination         Name of the destination whose\n"
           "                        reachability is of interest.\n");
    printf("    -m                  Perform Mulithreaded SensAPI test.\n");
    printf("    Threads             Number of threads  [Default = 5]\n");
    printf("    Interval            Wait between calls [Default = 10 sec]\n");
    printf("\n");
}


int __cdecl
main(
    int argc,
    const char * argv[]
    )
{
    DWORD dwFlags = 0;
    BOOL bAlive = FALSE;
    BOOL bReachable = FALSE;


    if (argc > 4)
        {
        Usage();
        return -1;
        }

    if (   (argc == 2)
        && (   (strcmp(argv[1], "-?") == 0)
            || (strcmp(argv[1], "/?") == 0)
            || (strcmp(argv[1], "-help") == 0)
            || (strcmp(argv[1], "/help") == 0)))
        {
        Usage();
        return -1;
        }

    //
    // Start the MultiThreadedTest, if required.
    //

    if (argc > 1)
        {
        if (strcmp(argv[1], "-m") == 0)
            {
            gdwThreads = 5;
            gdwInterval = 10;

            if (argc > 2)
                {
                gdwThreads = atoi(argv[2]);
                }
            if (argc > 3)
                {
                gdwInterval = atoi(argv[3]);
                }

            MultiThreadedTest();
            return 0;
            }
        }


    //
    // Call IsNetworkAlive()
    //

    printf("------------------------------------------------------------------"
            "----\n");

    bAlive = IsNetworkAlive(&dwFlags);

    printf("    IsNetworkAlive() returned %s\n", bAlive ? "TRUE" : "FALSE");
    if (bAlive)
        {
        printf("    Type of connection -%s%s%s\n",
               (dwFlags & NETWORK_ALIVE_WAN) ? " WAN" : "",
               (dwFlags & NETWORK_ALIVE_AOL) ? " AOL" : "",
               (dwFlags & NETWORK_ALIVE_LAN) ? " LAN" : "");
        }
    printf("    The GetLastError() was %d\n", GetLastError());

    printf("------------------------------------------------------------------"
            "----\n");

    if (argc == 1)
        {
        return 0;
        }


    //
    // Test the other API.
    //

    bReachable = IsDestinationReachableA((LPCSTR) argv[1], NULL);

    printf("    IsDestinationReachableA(%s, NULL) returned %s\n",
                argv[1], bReachable ? "TRUE" : "FALSE");

    if (bReachable)
        {
        printf("    QOC is NULL.\n");
        }
    printf("    The GetLastError() was %d\n", GetLastError());

    //
    // Now, call with QOC Info.
    //

    printf("------------------------------------------------------------------"
            "----\n");

    QOCINFO QOCInfo;
    NTSTATUS NtStatus;

    QOCInfo.dwSize = sizeof(QOCINFO);

#if !defined(SENS_CHICAGO)

    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitAnsiString(&AnsiString, (PSZ)argv[1]);
    NtStatus = RtlAnsiStringToUnicodeString(
                   &UnicodeString,
                   &AnsiString,
                   TRUE
                   );
    if (!NT_SUCCESS(NtStatus))
        {
        printf("RtlAnsiStringToUnicodeString() returned 0x%x\n", NtStatus);
        return -1;
        }

    bReachable = IsDestinationReachableW(UnicodeString.Buffer, &QOCInfo);

    wprintf(L"    IsDestinationReachableW(%s, QOC) returned %s\n",
                UnicodeString.Buffer, bReachable ? L"TRUE" : L"FALSE");

    RtlFreeUnicodeString(&UnicodeString);

#else // !SENS_CHICAGO

    bReachable = IsDestinationReachableA(argv[1], &QOCInfo);

    printf("    IsDestinationReachableA(%s, QOC) returned %s\n",
                argv[1], bReachable ? "TRUE" : "FALSE");
#endif // SENS_CHICAGO

    if (bReachable)
        {
        printf("    QOCInfo\n");
        printf("        o dwSize     = 0x%x \n", QOCInfo.dwSize);
        printf("        o dwFlags    = 0x%x \n", QOCInfo.dwFlags);
        printf("        o dwInSpeed  = %d bits/sec.\n", QOCInfo.dwInSpeed);
        printf("        o dwOutSpeed = %d bits/sec.\n", QOCInfo.dwOutSpeed);
        }
    printf("    The GetLastError() was %d\n", GetLastError());

    printf("------------------------------------------------------------------"
            "----\n");

    return 0;
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD WINAPI
ThreadProc(
    LPVOID lpvThreadNum
    )
{
    DWORD dwFlags = 0;
    BOOL bAlive = FALSE;
    int iThreadNum;
    int iWait;

    iThreadNum = PtrToLong(lpvThreadNum);

    for (;;)
        {
        printf("[%2d]-----------------------------------------------------------"
            "----\n", iThreadNum);

        bAlive = IsNetworkAlive(&dwFlags);

        printf("[%2d] IsNetworkAlive() returned %s\n", iThreadNum,
               bAlive ? "TRUE" : "FALSE");
        if (bAlive)
            {
            printf("[%2d] Type of connection -%s%s%s\n",
                   iThreadNum,
                   (dwFlags & NETWORK_ALIVE_WAN) ? " WAN" : "",
                   (dwFlags & NETWORK_ALIVE_AOL) ? " AOL" : "",
                   (dwFlags & NETWORK_ALIVE_LAN) ? " LAN" : "");
            }
        printf("[%2d] The GetLastError() was %d\n", iThreadNum, GetLastError());

        iWait = rand() % gdwInterval;
        printf("[%2d] Sleeping for %d seconds\n", iThreadNum, iWait);
        printf("[%2d]-----------------------------------------------------------"
               "----\n\n", iThreadNum);

        Sleep(iWait * 1000);
        }

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

void
MultiThreadedTest(
    void
    )
{
    DWORD i;
    DWORD dwThreadId;
    DWORD dwResult;
    HANDLE hThread;

    srand(GetTickCount());

    printf("\nSENSTEST: Starting Multithreaded IsNetworkAlive Test\n"
           "\tNumber of threads = %d\n"
           "\tMax Wait interval = %d seconds\n\n",
           gdwThreads, gdwInterval);

    for (i = 0; i < gdwThreads; i++)
        {
        hThread = CreateThread(
                      NULL,
                      0,
                      ThreadProc,
                      ULongToPtr(i),
                      0,
                      &dwThreadId
                      );
        if (NULL != hThread)
            {
            // Don't close the last handle.
            if ((i+1) != gdwThreads)
                {
                CloseHandle(hThread);
                }
            }
        else
            {
            printf("CreateThread(%d) failed with a GLE of %d\n", i,
                   GetLastError());
            }
        }

    dwResult = WaitForSingleObject(hThread, INFINITE);
    printf("WaitForSingleObject() returned %d, GLE = %d\n",
           dwResult, GetLastError());
    CloseHandle(hThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\autosync.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       autosync.cpp
//
//  Contents:   Offline AutoSync class
//
//  Classes:    CAutoSyncPage
//
//  Notes:
//
//  History:    14-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern OSVERSIONINFOA g_OSVersionInfo;
extern LANGID g_LangIdSystem;      // LangId of system we are running on.
extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.

/*
   Both the Logon and Idle pages in the settings dialog share this class
   for performance reasons. i.e. don't have to enum handlers and setup
   ras combo twice. If we ever need to sepcify the difference between settings
   to handlers for logon/logoff and Idle then these would have to be separated
*/

// initializes the specified hwnd.
BOOL CAutoSyncPage::InitializeHwnd(HWND hwnd,SYNCTYPE syncType,DWORD dwDefaultConnection)
{
HRESULT hr;
HWND hwndRasCombo;
HWND hwndList;
HIMAGELIST      himage;
LV_COLUMN       columnInfo;
WORD wHandlerID;
CListView **ppListView = NULL;
BOOL fShowRasEntriesInCombo;
UINT ImageListflags;


    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);

    // make sure main class is initialized.
    if (FALSE == Initialize(hwnd,dwDefaultConnection))
    {
        return FALSE;
    }

    // Setup the Ras combo
    // !!!Must be done before Initializing the Handler queue.
    smBoolChk(hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO));


    // don't show ras entries in combo if this is an AutoSync and
    // on Win9x platform.
    if ( VER_PLATFORM_WIN32_WINDOWS == g_OSVersionInfo.dwPlatformId) 
    {
        fShowRasEntriesInCombo = FALSE;
    }
    else
    {
        fShowRasEntriesInCombo = TRUE;
    }

    m_pRas->FillRasCombo(hwndRasCombo,FALSE,fShowRasEntriesInCombo);

   // now initialize the handler which will create queue
    // if necessary and fill in the values for the specified syncType

    smBoolChk(InitializeHandler(hwnd,syncType));

     Assert(m_HndlrQueue);

    // If initialization was successfull, read in connection info
    // based on th type.
    if ( FAILED(m_HndlrQueue->InitSyncSettings(syncType,hwndRasCombo)))
    {
          return FALSE;
    }

    hr = m_HndlrQueue->FindFirstHandlerInState (HANDLERSTATE_PREPAREFORSYNC,&wHandlerID);

    while (hr == S_OK)
    {
        m_HndlrQueue->ReadSyncSettingsPerConnection(syncType,wHandlerID);
        hr = m_HndlrQueue->FindNextHandlerInState(wHandlerID,HANDLERSTATE_PREPAREFORSYNC,
                                            &wHandlerID);
    }



    //initialize the item list and style
    smBoolChk(hwndList = GetDlgItem(hwnd,IDC_AUTOUPDATELIST));

    ppListView = (syncType == SYNCTYPE_AUTOSYNC) ? &m_pItemListViewAutoSync : &m_pItemListViewIdle;
    if (hwndList)
    {
        *ppListView = new CListView(hwndList,hwnd,IDC_AUTOUPDATELIST,WM_NOTIFYLISTVIEWEX);
    }


    if (NULL == *ppListView)
    {
        return FALSE;
    }

    (*ppListView)->SetExtendedListViewStyle(LVS_EX_CHECKBOXES 
        |   LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP );


    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(hwnd))
    {
         ImageListflags |=  ILC_MIRROR;
    }

    // create an imagelist
    himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                     GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
    if (himage)
    {
       (*ppListView)->SetImageList(himage,LVSIL_SMALL);
    }

    // Insert the Proper columns
    columnInfo.mask = LVCF_FMT  | LVCF_WIDTH;
    columnInfo.fmt = LVCFMT_LEFT;
    columnInfo.cx = CalcListViewWidth(hwndList,260);

    (*ppListView)->InsertColumn(0,&columnInfo);

    smBoolChk(ShowItemsOnThisConnection(hwnd,syncType,dwDefaultConnection));

    ShowWindow(hwnd, SW_SHOWNORMAL );
    UpdateWindow(hwnd);

    return TRUE;

}



//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::Initialize(DWORD dwDefaultConnection)
//
//  PURPOSE: initialization for the autosync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------

BOOL CAutoSyncPage::Initialize(HWND hwnd ,DWORD dwDefaultConnection )
{

    if (m_fInitialized)
        return TRUE;

    //Remove Logoff on all but NT5.
    if ((VER_PLATFORM_WIN32_WINDOWS == g_OSVersionInfo.dwPlatformId) ||
        (g_OSVersionInfo.dwMajorVersion < 5))
    {
        TCHAR pszStaticText[MAX_PATH + 1];
        LoadString(g_hmodThisDll, IDS_LOGON_TEXT,pszStaticText, MAX_PATH);
        
        Static_SetText(GetDlgItem(hwnd, IDC_STATIC2), pszStaticText);
        
        //Hide logoff check box
        HWND hwndLogoffCheck = GetDlgItem(hwnd, IDC_AUTOLOGOFF);
        Button_SetCheck(hwndLogoffCheck,FALSE);
        ShowWindow(hwndLogoffCheck, SW_HIDE);     
    }    
    // Initialize Ras Combo box
    m_pRas= new CRasUI();

    if (NULL == m_pRas || FALSE == m_pRas->Initialize())
    {
        if (m_pRas)
        {
            delete m_pRas;
            m_pRas = NULL;
        }

        return FALSE;
    }


    m_fInitialized = TRUE;
    return TRUE;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::InitializeHandler()
//
//  PURPOSE: initialization for the autosync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------

BOOL CAutoSyncPage::InitializeHandler(HWND hwnd,SYNCTYPE /* SyncType */)
{
SCODE sc = S_OK;
TCHAR lpName[MAX_PATH];
DWORD cbName = MAX_PATH;
HKEY hkSyncMgr;
CLSID clsid;
WORD wHandlerID;
HWND hwndRasCombo;

    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);

    if (NULL == (hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO)) )
    {
        return FALSE;
    }


    if (NULL == m_HndlrQueue) // if queue is already initialized, just return.
    {
        m_HndlrQueue = new CHndlrQueue(QUEUETYPE_SETTINGS);

        if (NULL == m_HndlrQueue)
        {
            return FALSE;
        }

        // loop through the reg getting the handlers and trying to
         // create them.
        if (hkSyncMgr = RegGetHandlerTopLevelKey(KEY_READ))
        {
        DWORD dwIndex = 0;

            while ( ERROR_SUCCESS == RegEnumKey(hkSyncMgr,dwIndex,
                                                lpName,cbName) )
            {
                if (NOERROR == CLSIDFromString(lpName,&clsid) )
                {
                    if (NOERROR == m_HndlrQueue->AddHandler(clsid, &wHandlerID))
                    {
                       m_HndlrQueue->CreateServer(wHandlerID,&clsid);
                    }
                }

                dwIndex++;
            }

            RegCloseKey(hkSyncMgr);
        }

        // Initialize the items.
        sc = m_HndlrQueue->FindFirstHandlerInState(HANDLERSTATE_INITIALIZE,&wHandlerID);

        while (sc == S_OK)
        {
                m_HndlrQueue->Initialize(wHandlerID,0,SYNCMGRFLAG_SETTINGS,0,NULL);

                sc = m_HndlrQueue->FindNextHandlerInState(wHandlerID,
                                                              HANDLERSTATE_INITIALIZE,
                                                              &wHandlerID);             
        }

        // loop through adding items
        sc = m_HndlrQueue->FindFirstHandlerInState (HANDLERSTATE_ADDHANDLERTEMS,&wHandlerID);
        
        while (sc == S_OK)
        {
            m_HndlrQueue->AddHandlerItemsToQueue(wHandlerID);

            sc = m_HndlrQueue->FindNextHandlerInState(wHandlerID,HANDLERSTATE_ADDHANDLERTEMS,
                                                &wHandlerID);
        }



    }


    Assert(m_HndlrQueue);
    return TRUE;

}


void CAutoSyncPage::SetAutoSyncHwnd(HWND hwnd)
{
    m_hwndAutoSync = hwnd;
}

void CAutoSyncPage::SetIdleHwnd(HWND hwnd)
{
    m_hwndIdle = hwnd;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::CommitChanges()
//
//  PURPOSE:  Write all the current AutoSync Settings to the registry
//
//      COMMENTS: Implemented on main thread.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
HRESULT CAutoSyncPage::CommitAutoSyncChanges(void)
{
HRESULT hr = S_FALSE;

    if (m_HndlrQueue)
    {
        hr =  m_HndlrQueue->CommitSyncChanges(SYNCTYPE_AUTOSYNC,m_pRas);
    }

    return hr;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::CommitIdleChanges()
//
//  PURPOSE:  Write all the current Idle Settings to the registry
//
//
//
//  HISTORY:  02-23-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

HRESULT CAutoSyncPage::CommitIdleChanges(void)
{
HRESULT hr = S_FALSE;

    if (m_HndlrQueue)
    {
        hr = m_HndlrQueue->CommitSyncChanges(SYNCTYPE_IDLE,m_pRas);
    }

    return hr;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::~CAutoSyncPage(HWND hwnd)
//
//  PURPOSE:  destructor
//
//      COMMENTS: destructor for AutoSync page
//
//--------------------------------------------------------------------------------
CAutoSyncPage::~CAutoSyncPage()
{
    if (m_pRas)
    {
        delete m_pRas;
        m_pRas = NULL;
    }


    if (m_HndlrQueue)
    {
            m_HndlrQueue->Release();
    }

    Assert(NULL == m_pItemListViewAutoSync);
    Assert(NULL == m_pItemListViewIdle);

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::ShowProperties(int iItem)
//
//  PURPOSE:  Show the app specific properties  Dialog
//
//      COMMENTS: Implemented on main thread.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
SCODE CAutoSyncPage::ShowProperties(HWND hwnd,int iItem)
{
SCODE sc = E_UNEXPECTED;

    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);


    // review, what happens when a cancel comes in when properties are being shown??
    if (m_HndlrQueue)
    {
        sc = m_HndlrQueue->ShowProperties(hwnd,iItem);
    }

    return sc;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::SetItemCheckState(int iItem, BOOL fChecked)
//
//  PURPOSE: set the selected check state
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------
BOOL CAutoSyncPage::SetItemCheckState(HWND hwnd,SYNCTYPE syncType,int iItem, BOOL fChecked,int iCheckCount)
{
HWND hwndRasCombo;
int iConnectionItem;

    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);

    hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO);

    if (NULL == hwndRasCombo || NULL == m_HndlrQueue)
    {
        Assert(hwndRasCombo);
        Assert(m_HndlrQueue);
        return FALSE;
    }


    iConnectionItem = ComboBox_GetCurSel(hwndRasCombo);

    //The check state is message is getting flagged by us programmatically setting it,
    // until after we are done initializing.
    if (m_fItemsOnConnection)
    {
    BOOL fAnyChecked;
    CListView *pItemListView = (syncType == SYNCTYPE_AUTOSYNC) ? m_pItemListViewAutoSync : m_pItemListViewIdle;

        fAnyChecked = iCheckCount ? TRUE : FALSE;

        if (ERROR_SUCCESS == m_HndlrQueue->SetSyncCheckStateFromListViewItem(
                            syncType,iItem,fChecked, iConnectionItem))
        {
            return TRUE;
        }
    
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::SetConnectionCheck(WORD wParam,DWORD dwCheckState)
//
//  PURPOSE: set the selected check state
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------
BOOL CAutoSyncPage::SetConnectionCheck(HWND hwnd,SYNCTYPE syncType,WORD wParam,	DWORD dwCheckState)
{
HWND hwndRasCombo ;
int iConnectionItem;

    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);

    hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO);
    if (NULL == hwndRasCombo || NULL == m_HndlrQueue)
    {
        Assert(hwndRasCombo);
        Assert(m_HndlrQueue);
        return FALSE;
    }

    iConnectionItem = ComboBox_GetCurSel(hwndRasCombo);

        if (m_fItemsOnConnection)
        {
        CListView *pItemListView = (syncType == SYNCTYPE_AUTOSYNC) ? m_pItemListViewAutoSync : m_pItemListViewIdle;

                //Check changing for logon or logoff
                //So enable the prompt me first accordingly

                if (wParam != IDC_AUTOPROMPT_ME_FIRST)
                {
                    HWND hwndLogon = GetDlgItem(hwnd,IDC_AUTOUPDATELIST);
                    int iLogonCheck  = Button_GetCheck(GetDlgItem(hwnd,IDC_AUTOLOGON));
                    int iLogoffCheck = Button_GetCheck(GetDlgItem(hwnd,IDC_AUTOLOGOFF));
                }
                if (ERROR_SUCCESS == m_HndlrQueue->SetConnectionCheck(wParam,dwCheckState,iConnectionItem))
                {
                        return TRUE;
                }
        
                return FALSE;
        }
        return TRUE;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::ShowItemsOnThisConnection(DWORD dwConnectionNum)
//
//  PURPOSE: initialization for the autosync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//+-------------------------------------------------------------------------------

BOOL CAutoSyncPage::ShowItemsOnThisConnection(HWND hwnd,SYNCTYPE syncType,DWORD dwConnectionNum)
{
TCHAR pszConnectionName[RAS_MaxEntryName+1];
HWND hwndRasCombo;
CListView *pItemListView = (syncType == SYNCTYPE_AUTOSYNC) ? m_pItemListViewAutoSync : m_pItemListViewIdle;
BOOL *pListViewInitialize = (syncType == SYNCTYPE_AUTOSYNC) ? &m_pItemListViewAutoSyncInitialized : &m_fListViewIdleInitialized;

    Assert(hwnd == m_hwndAutoSync || hwnd == m_hwndIdle);

    hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO);
    if (NULL == hwndRasCombo || NULL == m_HndlrQueue || NULL == pItemListView)
    {
        Assert(m_HndlrQueue);
        Assert(hwndRasCombo);
        Assert(pItemListView);
        return FALSE;
    }

    *pListViewInitialize = FALSE; // reset initialized in case user switched connections.

    //first clear out the list view
    // Review - why not just recheck items based on new connection??? 
    m_fItemsOnConnection = FALSE;                       
    pItemListView->DeleteAllItems();

    HIMAGELIST himage;
    LVITEMEX lvItemInfo;
    WORD wHandlerID;


    //Note:  Use text to "uniquely" identify connection on RAS
    DWORD dwNumConnections = (DWORD) ComboBox_GetCount(hwndRasCombo);

    // make sure dwConnectionNum is valid,
    if (dwConnectionNum >= dwNumConnections)
    {
        return FALSE;
    }

    COMBOBOXEXITEM comboItem;
    comboItem.mask = CBEIF_TEXT;
    comboItem.cchTextMax = ARRAY_SIZE(pszConnectionName);
    comboItem.pszText = pszConnectionName;
    comboItem.iItem = dwConnectionNum;

    // Review, handle failures.
    ComboEx_GetItem(hwndRasCombo,&comboItem);

    // loop through proxies initializing and adding to the list
    SYNCMGRITEMID ItemID;
    CLSID clsidHandler;
    WORD wItemID;

    // add same images over and over again. Should either just use the same listView
    // resetting the CheckBoxes according or clear the ImageList each time.
    himage = pItemListView->GetImageList(LVSIL_SMALL );


    HRESULT hr = m_HndlrQueue->FindFirstItemOnConnection
                                            (pszConnectionName, &clsidHandler,
                                        &ItemID,&wHandlerID,&wItemID);

    if (NOERROR == hr)
    {
        DWORD dwCheckState;
        do
        {
        INT iListViewItem;
        CLSID clsidDataHandler;
        SYNCMGRITEM offlineItem;
        ITEMCHECKSTATE   ItemCheckState;

                    // grab the offline item info.
            if (NOERROR == m_HndlrQueue->GetSyncItemDataOnConnection(
                                                            dwConnectionNum,
                                                            wHandlerID,wItemID,
                                                            &clsidDataHandler,&offlineItem,
                                                            &ItemCheckState,
                                                            FALSE, FALSE))
            {
            LVHANDLERITEMBLOB lvHandlerItemBlob;
            int iParentItemId;
            BOOL fHandlerParent = TRUE; // always have a parent for now.
            DWORD dwCheckState;

                // Check if item is already in the ListView and if so
                // go on

                lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                lvHandlerItemBlob.clsidServer = clsidDataHandler;
                lvHandlerItemBlob.ItemID = offlineItem.ItemID;
            
                if (-1 != pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob))
                {
                    // already in ListView, go on to the next item.
                    continue;
                }

                if (!fHandlerParent)
                {
                    iParentItemId = LVI_ROOT;
                }
                else
                {
                    // need to add to list so find parent and if one doesn't exist, create it.
                    lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                    lvHandlerItemBlob.clsidServer = clsidDataHandler;
                    lvHandlerItemBlob.ItemID = GUID_NULL;

                    iParentItemId = pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);

                    if (-1 == iParentItemId)
                    {
                    LVITEMEX itemInfoParent;
                    SYNCMGRHANDLERINFO SyncMgrHandlerInfo;

                        // if can't get the ParentInfo then don't add the Item
                        if (NOERROR != m_HndlrQueue->GetHandlerInfo(clsidDataHandler,&SyncMgrHandlerInfo))
                        {
                            continue;
                        }

                        // Insert the Parent.
                        itemInfoParent.mask = LVIF_TEXT;
                        itemInfoParent.iItem = LVI_LAST;;
                        itemInfoParent.iSubItem = 0;
                        itemInfoParent.iImage = -1;
    
                        itemInfoParent.pszText = SyncMgrHandlerInfo.wszHandlerName;
		        if (himage)
		        {
		        HICON hIcon = SyncMgrHandlerInfo.hIcon ? SyncMgrHandlerInfo.hIcon : offlineItem.hIcon;

                            // if have toplevel handler info icon use this else use the
		            // items icon

		            if (hIcon &&  (itemInfoParent.iImage = 
					        ImageList_AddIcon(himage,hIcon)) )
		            {
                                itemInfoParent.mask |= LVIF_IMAGE ; 
		            }
		        }

                        // save the blob
                        itemInfoParent.maskEx = LVIFEX_BLOB;
                        itemInfoParent.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
            
                        iParentItemId = pItemListView->InsertItem(&itemInfoParent);

                        // if parent insert failed go onto the next item
                        if (-1 == iParentItemId)
                        {
                            continue;
                        }
                    }
                }

                // now attemp to insert the item.
	        lvItemInfo.mask = LVIF_TEXT; 
                lvItemInfo.maskEx = LVIFEX_PARENT | LVIFEX_BLOB; 

                lvItemInfo.iItem = LVI_LAST;
	        lvItemInfo.iSubItem = 0; 
                lvItemInfo.iParent = iParentItemId;
        

	        lvItemInfo.pszText = offlineItem.wszItemName; 
                lvItemInfo.iImage = -1; // set to -1 in case can't get image.


                // setup the blob
                lvHandlerItemBlob.ItemID = offlineItem.ItemID;
                lvItemInfo.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
                
                if (himage && offlineItem.hIcon)
                {
                        lvItemInfo.iImage =
                                        ImageList_AddIcon(himage,offlineItem.hIcon);
                }

                iListViewItem = pItemListView->InsertItem(&lvItemInfo);

                if (-1 == iListViewItem)
                {
                    continue;
                }

                //Set the check state of the item
                lvItemInfo.mask = LVIF_STATE;
                lvItemInfo.maskEx = 0; 
                lvItemInfo.iItem = iListViewItem; 
                lvItemInfo.iSubItem = 0;

                dwCheckState =  (syncType == SYNCTYPE_IDLE)
                    ? ItemCheckState.dwIdle : ItemCheckState.dwAutoSync;

                lvItemInfo.stateMask= LVIS_STATEIMAGEMASK;
                lvItemInfo.state = (dwCheckState == SYNCMGRITEMSTATE_UNCHECKED) ?
                        LVIS_STATEIMAGEMASK_UNCHECK : LVIS_STATEIMAGEMASK_CHECK;

                pItemListView->SetItem(&lvItemInfo);

                m_HndlrQueue->SetItemListViewID(clsidDataHandler,offlineItem.ItemID,iListViewItem);

                }


            } while (NOERROR == m_HndlrQueue->FindNextItemOnConnection
                                                    (pszConnectionName,wHandlerID,wItemID,
                                                     &clsidHandler,&ItemID,&wHandlerID,&wItemID, TRUE,
                                                             &dwCheckState) );
    }
        
    if (pItemListView->GetItemCount())
    {
        pItemListView->SetItemState(0,LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );          
    }


    if (syncType == SYNCTYPE_AUTOSYNC)
    {
    int iLogonCheck  = m_HndlrQueue->GetCheck(IDC_AUTOLOGON, dwConnectionNum);
    int iLogoffCheck = m_HndlrQueue->GetCheck(IDC_AUTOLOGOFF, dwConnectionNum);

        Button_SetCheck(GetDlgItem(hwnd,IDC_AUTOLOGON),iLogonCheck);
        Button_SetCheck(GetDlgItem(hwnd,IDC_AUTOLOGOFF),iLogoffCheck);
        
        Button_SetCheck(GetDlgItem(hwnd,IDC_AUTOPROMPT_ME_FIRST),
                                        m_HndlrQueue->GetCheck(IDC_AUTOPROMPT_ME_FIRST, dwConnectionNum));
    }
    else if (syncType == SYNCTYPE_IDLE)
    {
    int iIdleCheck  = m_HndlrQueue->GetCheck(IDC_IDLECHECKBOX, dwConnectionNum);

            Button_SetCheck(GetDlgItem(hwnd,IDC_IDLECHECKBOX),iIdleCheck);
    }

   
    *pListViewInitialize = TRUE;
    m_fItemsOnConnection = TRUE;                        

    return TRUE;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::GetNumConnections(SYNCTYPE syncType))
//
//  PURPOSE: returns the number of connections available to select for the
//          specified sync type
//
//  RETURN number of connections.
//
//  HISTORY:  03-10-98       rogerg        Created.
//
//+-------------------------------------------------------------------------------

DWORD CAutoSyncPage::GetNumConnections(HWND hwnd,SYNCTYPE syncType)
{
HWND hwndRasCombo;

    Assert(syncType == SYNCTYPE_IDLE || syncType == SYNCTYPE_AUTOSYNC);
    Assert(NULL != hwnd);

    hwndRasCombo = GetDlgItem(hwnd,IDC_AUTOUPDATECOMBO);
    Assert(hwndRasCombo);

    if (hwndRasCombo)
    {
        return ComboBox_GetCount(hwndRasCombo);
    }

    return 0;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::GetAdvancedIdleSettings(LPCONNECTIONSETTINGS *ppConnectionSettings)
//
//  PURPOSE: fills in the ConnectionSettings Structure with the Advanced
//              Idle default settings.
//
//  RETURN
//
//  HISTORY:  03-10-98       rogerg        Created.
//
//+-------------------------------------------------------------------------------

HRESULT CAutoSyncPage::GetAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
{
    Assert(pConnectionSettings);
    Assert(m_HndlrQueue);

    if (NULL == pConnectionSettings
            || NULL == m_HndlrQueue)
    {
        return S_FALSE;
    }

    return m_HndlrQueue->ReadAdvancedIdleSettings(pConnectionSettings);
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CAutoSyncPage::SetAdvancedidleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
//
//  PURPOSE: sets the advancedIdle Settings.
//
//  RETURN
//
//  HISTORY:  03-10-98       rogerg        Created.
//
//+-------------------------------------------------------------------------------

HRESULT CAutoSyncPage::SetAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
{
    Assert(pConnectionSettings);
    Assert(m_HndlrQueue);

    if (NULL == pConnectionSettings
            || NULL == m_HndlrQueue)
    {
        return S_FALSE;
    }

    return m_HndlrQueue->WriteAdvancedIdleSettings(pConnectionSettings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\clsobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       clsobj.cpp
//
//  Contents:   export for implimenting MobsyncGetClassObject.
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

class CNetApi;

STDAPI MobsyncGetClassObject(ULONG mobsyncClassObjectId,void **pCObj)
{
    if (NULL == pCObj)
    {
        Assert(pCObj);
        return E_INVALIDARG;
    }

    switch(mobsyncClassObjectId)
    {
    case MOBSYNC_CLASSOBJECTID_NETAPI:
        *pCObj = new CNetApi();
        break;
    default:
        AssertSz(0,"Request made for unknown object");
        break;
    }

    return *pCObj ? NOERROR : CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\cnetapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cnetapi.h
//
//  Contents:   Network/SENS API wrappers
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _MOBSYNC_NETAPIIMPL
#define _MOBSYNC_NETAPIIMPL

// not defined until 401 but need to include header as 40 so rasconn
// structure is valid on 40

#ifndef RASADP_LoginSessionDisable
#define RASADP_LoginSessionDisable   1
#endif // RASADP_LoginSessionDisable



// Sens definitions
typedef BOOL (WINAPI *ISNETWORKALIVE)(LPDWORD);

// Ras definitions

typedef DWORD (APIENTRY *RASENUMCONNECTIONSW)( LPRASCONNW, LPDWORD, LPDWORD );
typedef DWORD (APIENTRY *RASENUMCONNECTIONSA)( LPRASCONNA, LPDWORD, LPDWORD );
typedef DWORD (APIENTRY *RASDIAL)(LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD,
                   LPVOID, LPHRASCONN );
typedef DWORD (APIENTRY *RASHANGUP)( HRASCONN );
typedef DWORD (APIENTRY *RASGETCONNECTSTATUSPROC)( HRASCONN, LPRASCONNSTATUS );
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROCW)( UINT, LPWSTR, DWORD );
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROCA)( UINT, LPSTR, DWORD );
typedef DWORD (APIENTRY *RASGETAUTODIALPARAM)(DWORD, LPVOID, LPDWORD );
typedef DWORD (APIENTRY *RASSETAUTODIALPARAM)(DWORD, LPVOID, DWORD );

typedef DWORD (APIENTRY *RASENUMENTRIESPROCA)( LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD,
                   LPDWORD );

typedef DWORD (APIENTRY *RASENUMENTRIESPROCW)( LPWSTR, LPWSTR, LPRASENTRYNAMEW, LPDWORD,
                   LPDWORD );

typedef DWORD (APIENTRY *RASGETENTRYPROPERTIESPROC)(LPTSTR, LPTSTR, LPBYTE, LPDWORD, 
                LPBYTE, LPDWORD );

#ifndef RASDEFINED
#define RASDEFINED
#endif //RASDEFINED


// wininet definitions
typedef DWORD (WINAPI *INTERNETDIAL)(HWND hwndParent,char* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved);
typedef DWORD (WINAPI *INTERNETDIALW)(HWND hwndParent,WCHAR* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved);
typedef DWORD (WINAPI *INTERNETHANGUP)(DWORD dwConnection,DWORD dwReserved);
typedef BOOL (WINAPI *INTERNETAUTODIAL)(DWORD dwFlags,DWORD dwReserved);
typedef BOOL (WINAPI *INTERNETAUTODIALHANGUP)(DWORD dwReserved);
typedef BOOL (WINAPI *INTERNETGETLASTRESPONSEINFO)(LPDWORD lpdwError,
                                                    LPSTR lpszBuffer,LPDWORD lpdwBufferLength);
typedef BOOL (WINAPI *INTERNETQUERYOPTION)( HINTERNET hInternet,
                                                        DWORD dwOption,
                                                        LPVOID lpBuffer,
                                                        LPDWORD lpdwBufferLength );
typedef BOOL (WINAPI *INTERNETSETOPTION)( HINTERNET hInternet,
                                                      DWORD dwOption,
                                                      LPVOID lpBuffer,
                                                      DWORD dwBufferLength );

BOOL IsRasInstalled(void);

// declaration of our internal class
class  CNetApi : public INetApi, public CLockHandler
{
public:
    CNetApi();

    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP_(BOOL) IsSensInstalled(void);
    STDMETHODIMP_(BOOL) IsNetworkAlive(LPDWORD lpdwFlags);
    STDMETHODIMP GetWanConnections(DWORD *cbNumEntries,RASCONN **pWanConnections);
    STDMETHODIMP FreeWanConnections(RASCONN *pWanConnections);
    STDMETHODIMP GetConnectionStatus(LPCTSTR pszConnectionName,DWORD ConnectionType,BOOL *fConnected,BOOL *fCanEstablishConnection);
    STDMETHODIMP RasGetAutodial( BOOL& fEnabled );
    STDMETHODIMP RasSetAutodial( BOOL fEnabled );
    STDMETHODIMP_(DWORD) RasGetErrorStringProc( UINT uErrorValue, LPTSTR lpszErrorString,DWORD cBufSize);
    
    STDMETHODIMP_(DWORD) RasEnumEntries(LPWSTR reserved,LPWSTR lpszPhoneBook,
                    LPRASENTRYNAME lprasEntryName,LPDWORD lpcb,LPDWORD lpcEntries);

    STDMETHODIMP_(DWORD) RasEnumConnections(LPRASCONNW lprasconn,LPDWORD lpcb,LPDWORD lpcConnections);

    // ConvertGuid is only supported on NT 5.0
    STDMETHODIMP RasConvertGuidToEntry(GUID *pGuid,LPWSTR lpszEntry,RASENTRY *pRasEntry);

    // methods for calling wininet
    STDMETHODIMP_(DWORD) InternetDialA(HWND hwndParent,char* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved);
    STDMETHODIMP_(DWORD)InternetDialW(HWND hwndParent,WCHAR* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved);
    STDMETHODIMP_(DWORD)InternetHangUp(DWORD dwConnection,DWORD dwReserved);
    STDMETHODIMP_(BOOL) InternetAutodial(DWORD dwFlags,DWORD dwReserved);
    STDMETHODIMP_(BOOL) InternetAutodialHangup(DWORD dwReserved);
    STDMETHODIMP  InternetGetAutodial( BOOL& fEnabled );
    STDMETHODIMP  InternetSetAutodial( BOOL fEnabled );

    STDMETHODIMP_(BOOL) IsGlobalOffline(void);
    STDMETHODIMP_(BOOL) SetOffline(BOOL fOffline);

    // methods that aren't unicode wrapped
#if 0
    STDMETHODIMP_(DWORD) RasDial(TCHAR *pszConnectionName,HRASCONN *hRasConn);
    STDMETHODIMP_(DWORD) RasDialDlg(TCHAR *pszConnectionName,HRASCONN *phRasConn);
    STDMETHODIMP RasHangup(HRASCONN hRasConn);
    STDMETHODIMP_(DWORD) RasDialProc(LPRASDIALEXTENSIONS lpRasDialExtensions,
                          LPTSTR lpszPhonebook, LPRASDIALPARAMS lpRasDialParams,
                          DWORD dwNotifierType, LPVOID lpvNotifier,
                          LPHRASCONN phRasConn);
    STDMETHODIMP_(DWORD) RasHangUpProc( HRASCONN hrasconn);
    STDMETHODIMP_(DWORD) RasGetConnectStatusProc(HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus);
    STDMETHODIMP_(DWORD) RasGetEntryDialParamsProc(LPCTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,LPBOOL lpfPassword);
#endif // 0
private:
    ~CNetApi();
    DWORD RasEnumEntriesNT50(LPWSTR reserved,LPWSTR lpszPhoneBook,
                    LPRASENTRYNAME lprasEntryName,LPDWORD lpcb,LPDWORD lpcEntries);


    HRESULT LoadRasApiDll();
    HRESULT LoadWinInetDll();
    STDMETHODIMP LoadSensDll();


    // Sens Dll imports
    BOOL m_fTriedToLoadSens;
    HINSTANCE m_hInstSensApiDll;
    ISNETWORKALIVE m_pIsNetworkAlive;

    // Ras Dll Imports
    BOOL m_fTriedToLoadRas;
    HINSTANCE m_hInstRasApiDll;
    RASENUMCONNECTIONSW m_pRasEnumConnectionsW;
    RASENUMCONNECTIONSA m_pRasEnumConnectionsA;
    RASENUMENTRIESPROCA	        m_pRasEnumEntriesA;
    RASENUMENTRIESPROCW	        m_pRasEnumEntriesW;
    RASGETENTRYPROPERTIESPROC   m_pRasGetEntryPropertiesW;
    RASGETERRORSTRINGPROCW m_pRasGetErrorStringW;
    RASGETERRORSTRINGPROCA m_pRasGetErrorStringA;

    // Ras dll imports of NT 4 or 5
    RASGETAUTODIALPARAM   m_pRasGetAutodialParam;
    RASSETAUTODIALPARAM   m_pRasSetAutodialParam;

#if 0
    RASDIAL m_pRasDial;
    RASHANGUP m_pRasHangup;
    RASGETCONNECTSTATUSPROC m_pRasConnectStatus;
    RASGETENTRYDIALPARAMSPROC m_pRasEntryGetDialParams;
#endif // 0

    // wininet Dll Imports
    BOOL m_fTriedToLoadWinInet;
    HINSTANCE m_hInstWinInetDll;
    INTERNETDIAL m_pInternetDial;
    INTERNETDIALW m_pInternetDialW;
    INTERNETHANGUP m_pInternetHangUp;
    INTERNETAUTODIAL m_pInternetAutodial;
    INTERNETAUTODIALHANGUP m_pInternetAutodialHangup;
    INTERNETQUERYOPTION     m_pInternetQueryOption;
    INTERNETSETOPTION      m_pInternetSetOption;

    BOOL  m_fIsUnicode;     // Is base OS Unicode enabled ?
    ULONG m_cRefs;          // Reference count for this global object
};




#endif // _MOBSYNC_NETAPIIMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\cfact.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Cfact.cpp
//
//  Contents:   Main Dll api and Class Factory interface
//
//  Classes:    CClassFactory
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

STDAPI DllRegisterServer(void);
STDAPI DllPerUserRegister(void);
STDAPI DllPerUserUnregister(void);

EXTERN_C  int APIENTRY mobsyncDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);
STDAPI mobsyncDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
STDAPI mobsyncDllRegisterServer(void);
STDAPI mobsyncDllUnregisterServer(void);
STDAPI mobsyncDllCanUnloadNow(void);

#define PrxDllMain mobsyncDllMain
#define PrxDllRegisterServer mobsyncDllRegisterServer
#define PrxDllUnregisterServer mobsyncDllUnregisterServer
#define PrxDllMain mobsyncDllMain
#define PrxDllGetClassObject mobsyncDllGetClassObject
#define PrxDllCanUnloadNow mobsyncDllCanUnloadNow

//
// Global variables
//
UINT      g_cRefThisDll = 0;            // Reference count of this DLL.
HINSTANCE g_hmodThisDll = NULL;         // Handle to this DLL itself.
DWORD     g_dwPlatformId = 0;           // the OSVersion info
CRITICAL_SECTION g_DllCriticalSection;  // Global Critical Section for this DLL
OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo,
LANGID g_LangIdSystem;      // LangId of system we are running on.

#define _WINLOGON_ 0


#if _WINLOGON_

#include <winwlx.h>
// extern void WINAPI           Sleep(DWORD dwMilliseconds);



HRESULT MakeOneStopInstance(PWLX_NOTIFICATION_INFO pNotify,TCHAR *pCommandLine,BOOL fSync)
{
STARTUPINFO si;
PROCESS_INFORMATION ProcessInformation;



 if ( 1 /* fuser */ )
 {

si.cb = sizeof(STARTUPINFO);
si.lpReserved = NULL;
si.lpTitle = NULL;
si.lpDesktop = NULL;
si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
si.dwFlags = 0;;
si.wShowWindow = SW_SHOW;
si.lpReserved2 = NULL;
si.cbReserved2 = 0;


if (CreateProcessAsUser(pNotify->hToken,NULL, pCommandLine, NULL, NULL, FALSE,
                   0, NULL, NULL, &si, &ProcessInformation))
{

    // wait until the process terminates

    if (fSync)
    {
        WaitForSingleObject(ProcessInformation.hProcess,INFINITE);
    }

    CloseHandle(ProcessInformation.hProcess);
    CloseHandle(ProcessInformation.hThread);


    return NOERROR;
}

}

return NOERROR;
}


#endif // _WINLOGON_

// routines for catching WinLogon
EXTERN_C DWORD WINAPI
WinLogonEvent(
    LPVOID lpParam
    )
{

#if _WINLOGON_
PWLX_NOTIFICATION_INFO pNotify = (PWLX_NOTIFICATION_INFO) lpParam;
HRESULT hr;
LPUNKNOWN lpUnk;

    MakeOneStopInstance(pNotify,"syncmgr.exe /logon",FALSE);    
    return 0;

    // Review - see if have a network connection and Autosync is set up
    // before taking the overhead.

    CoInitialize(NULL); // Roger, test if this has to be called.

    hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_ALL,IID_IUnknown,(void **) &lpUnk);

    if (NOERROR == hr)
    {
    LPPRIVSYNCMGRSYNCHRONIZEINVOKE pSynchInvoke = NULL;

    hr = lpUnk->QueryInterface(IID_IPrivSyncMgrSynchronizeInvoke,
        (void **) &pSynchInvoke);
    
    if (NOERROR == hr)
    {
        hr = pSynchInvoke->Logon();
        pSynchInvoke->Release();
    }


        lpUnk->Release();
    }

#endif // _WINLOGON

    return 0;
}



EXTERN_C DWORD WINAPI
WinLogoffEvent(
    LPVOID lpParam
    )
{

#if _WINLOGON_

PWLX_NOTIFICATION_INFO pInfo = (PWLX_NOTIFICATION_INFO) lpParam;

    if ( !(pInfo->Flags & 0x02))  // 0x02 is the restart bit, don't sync on this.
    {
    
    MakeOneStopInstance(pInfo,"syncmgr.exe /logoff",TRUE);  
    }

   return 0;

#ifdef _OLD

HRESULT hr;
LPUNKNOWN lpUnk;

    CoInitialize(NULL); // Roger, test if this has to be called.

    hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_ALL,IID_IUnknown,(void **) &lpUnk);

    if (NOERROR == hr)
    {
    LPPRIVSYNCMGRSYNCHRONIZEINVOKE pSynchInvoke = NULL;

    hr = lpUnk->QueryInterface(IID_IPrivSyncMgrSynchronizeInvoke,
        (void **) &pSynchInvoke);
    
    if (NOERROR == hr)
    {
        hr = pSynchInvoke->Logoff();
        pSynchInvoke->Release();
    }


        lpUnk->Release();
    }


#endif // _OLD
    
#endif // _WINLOGON_

   return 0;
}

// Setup APIs. Should be moved to another file but wait until after ship.

// declarations for install variables and sections. Any changes
// to these declarations must also have a corresponding changes to .inf

// .inf sections names
#define INSTALLSECTION_MACHINEINSTALL       "Reg"
#define INSTALLSECTION_MACHINEUNINSTALL     "UnReg"

#define INSTALLSECTION_REGISTERSHORTCUT     "RegShortcut"
#define INSTALLSECTION_UNREGISTERSHORTCUT   "UnRegShortcut"

#define INSTALLSETCION_PERUSERINSTALL       "PerUserInstall"

#define INSTALLSECTION_SETUP_PERUSERINSTALL   "SetupPerUserInstall"
#define INSTALLSECTION_REMOVE_PERUSERINSTALL   "RemovePerUserInstall"


// Variable declarations
#define  MODULEPATH_MAXVALUESIZE                MAX_PATH
#define  SZ_MODULEPATH                          "MODULEPATH"

#define  ACCESSORIESGROUP_MAXVALUESIZE          MAX_PATH
#define  SZ_ACCESSORIESGROUP                    "ACESSORIES_GROUP"

// Synchronize LinkName
#define  SYNCHRONIZE_LINKNAME_MAXVALUESIZE      MAX_PATH
#define  SZ_SYNCHRONIZE_LINKNAME                "SYNCHRONIZE_LINKNAME"

// Synchronization PerUserInstall Dislay Name
#define  SYNCHRONIZE_PERUSERDISPLAYNAME_MAXVALUESIZE      MAX_PATH
#define  SZ_SYNCHRONIZE_PERUSERDISPLAYNAME                "SYNCHRONIZE_PERUSERDISPLAYNAME"


//+---------------------------------------------------------------------------
//
//  function:   RunDllRegister, public export
//
//  Synopsis:   processes cmdlines from Rundll32 cmd
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg      Created.
//              27-Oct-98       rogerg      Added perUser Flags.
//
//----------------------------------------------------------------------------

// export for how Rundll32 calls us
EXTERN_C void WINAPI  RunDllRegister(HWND hwnd,
                HINSTANCE hAppInstance,
                LPSTR pszCmdLine,
                int nCmdShow)
{
char *pCmdLine = pszCmdLine;

    // if no cmdLine do a register.
    if (!pCmdLine || '\0' == *pCmdLine)
    {
       DllRegisterServer();
       return;
    }

    // only allow cmdlines inthe form of /
    if ('/' != *pCmdLine)
    {
        AssertSz(0,"Invalid CmdLine");
        return;
    }

    ++pCmdLine;

    // command lines we support for .inf installs are
    // /u - Uninstall
    // /p - perUser Install
    // /pu - perUser UnInstall

    switch(*pCmdLine)
    {
    case 'u':
    case 'U':
        DllUnregisterServer();
        break;
    case 'p':
    case 'P':

        ++pCmdLine;

        switch(*pCmdLine)
        {
           case '\0':
               DllPerUserRegister();
               break;
           case 'u':
           case 'U':
               DllPerUserUnregister();
               break;
           default:
               AssertSz(0,"Unknown PerUser Command");
               break;
        }
        break;
    default:
        AssertSz(0,"Unknown Cmd Line");
        break;
    }

}


//+---------------------------------------------------------------------------
//
//  function:   GetAccessoriesGroupName, private
//
//  Synopsis:   Gets the Name of the Accessories group
//              from the registry.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    ??-???-98       rogerg      Created.
//
//----------------------------------------------------------------------------

// if can get accessories group name register our shortcut.
// accessories name is located at
// key =  HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion Value = SM_AccessoriesName

// !! MUST ALWAYS RETURN ANSI
HRESULT GetAccessoriesGroupName(char *pszAccessories,DWORD cbSize)
{
DWORD dwType = REG_SZ;
HKEY hkeyWindowsCurrentVersion;
BOOL fHaveAccessoriesName = FALSE;
DWORD dwDataSize = cbSize;

    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion",0,KEY_READ,
                        &hkeyWindowsCurrentVersion) )
    {

         if (ERROR_SUCCESS == RegQueryValueExA(hkeyWindowsCurrentVersion,"SM_AccessoriesName",NULL, &dwType,
                                 (LPBYTE) pszAccessories, &dwDataSize) )
         {

             fHaveAccessoriesName = TRUE;
         }


         RegCloseKey(hkeyWindowsCurrentVersion);
    }

    //AssertSz(fHaveAccessoriesName,"Couldn't Get Accessories Group Name");

    return fHaveAccessoriesName ? NOERROR : E_UNEXPECTED;
}

//+---------------------------------------------------------------------------
//
//  function:   GetModulePath, private
//
//  Synopsis:   Gets the Path to us with our name stripped out.
//
//              Note - sets pszModulePath to NULL on error.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

HRESULT GetModulePath(char *pszModulePath,DWORD cbSize)
{
DWORD dwModuleLen;

    Assert(pszModulePath && cbSize >= 1);

    if (!pszModulePath || cbSize < 1)
    {
        AssertSz(0,"Invalid ModulePath Ptr");
        return S_FALSE;
    }

    *pszModulePath = NULL;

    // setup the module path based on our dir.
    if(dwModuleLen = GetModuleFileNameA(
        g_hmodThisDll,
        pszModulePath,
        cbSize) )
    {
    char *pszCurChar = pszModulePath + dwModuleLen - 1;

        // NEED to strip off dll name from path, walk back until hit a \ or beginning of string.
        // call with CharPrev but really shouldn't have to since name is never localized.

        // on no match want an empty string, on a match want path + last backslash.

        while (pszCurChar)
        {
        char *pszPrevChar = CharPrevA(pszModulePath,pszCurChar);

            if(pszPrevChar <= pszModulePath)
            {
                *pszModulePath = '\0'; // if got all the way to the end then make an empty string.
                break;
            }

            if (*pszPrevChar == '\\')
            {
                *pszCurChar = '\0';
                break;
            }

            // check the next character
            pszCurChar = pszPrevChar;
        }

    }

    return *pszModulePath ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  function:   SetupInfVariables, private
//
//  Synopsis:   sets up the variables we pass to the .inf file
//              if fail to setup a variable it is set to NULL
//
//  Arguments:  cbNumEntries - number of entries in the arrays
//              pseReg - Array of STRENTRYs
//              pdwSizes - Array of String sizes for STRENTRY Values.
//
//  Returns:
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

/*

typedef struct _StrEntry {
    LPSTR   pszName;            // String to substitute
    LPSTR   pszValue;           // Replacement string or string resource
} STRENTRY, *LPSTRENTRY;

*/

void SetupInfVariables(DWORD cbNumEntries,STRENTRY *pseReg,DWORD *pdwSizes)
{
STRENTRY *pCurEntry;
DWORD *pCurSize;

    Assert(pseReg);
    Assert(pdwSizes);

    pCurEntry = pseReg;
    pCurSize = pdwSizes;

    // loop through the entries getting the info.
    // Entry names are always in ANSI

    while (cbNumEntries--)
    {

        Assert(*pCurSize);

        if (0 < *pCurSize)
        {
            // null out entry in case of failure
            *(pCurEntry->pszValue) = '\0';

            // see if it matches a known variable.

            if (!lstrcmpA(pCurEntry->pszName,SZ_MODULEPATH))
            {
                // setup the module path based on our dir.
                // GetModulePath sets szModulePath to NULL on error.
                GetModulePath(pCurEntry->pszValue,*pCurSize);
            }
            else if (!lstrcmpA(pCurEntry->pszName,SZ_ACCESSORIESGROUP))
            {
                if (NOERROR != GetAccessoriesGroupName(pCurEntry->pszValue,*pCurSize))
                {
                    *(pCurEntry->pszValue) = '\0';
                }

            }
            else if (!lstrcmpA(pCurEntry->pszName,SZ_SYNCHRONIZE_LINKNAME))
            {
                // if size is too small the string will be truncated.
                LoadStringA(g_hmodThisDll,IDS_SHORTCUTNAME,pCurEntry->pszValue,*pCurSize);
            }
            else if (!lstrcmpA(pCurEntry->pszName,SZ_SYNCHRONIZE_PERUSERDISPLAYNAME))
            {
                // if size is too small the string will be truncated.
                LoadStringA(g_hmodThisDll,IDS_SYNCMGR_PERUSERDISPLAYNAME,pCurEntry->pszValue,*pCurSize);
            }
            else
            {
                AssertSz(0,"Uknown Setup Variable");
            }
        }

        pCurEntry++;
        pCurSize++;

    }
}


HRESULT CallRegInstall(LPSTR szSection,STRTABLE *stReg)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {

            hr = pfnri(g_hmodThisDll, szSection,stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  function:   SystemIsPerUser, private
//
//  Synopsis:   determines if PerUser registration should be
//              done for the current system.
//
//  Returns:    TRUE if should setupPerUserInformation
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

BOOL SystemIsPerUser()
{
     // only return true if NT and < 5.0
    if ((VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId)
                        &&  (g_OSVersionInfo.dwMajorVersion < 5) )
    {
        return TRUE;
    }

    return FALSE;

}

STDAPI DllRegisterServer(void)
{
HRESULT  hr = NOERROR;
char szModulePath[MODULEPATH_MAXVALUESIZE]; // !!! these must always be ANSI
char szAccessoriesGroup[ACCESSORIESGROUP_MAXVALUESIZE];
char szSynchronizeLinkName[SYNCHRONIZE_LINKNAME_MAXVALUESIZE];
char szSynchronizePerUserDisplayName[SYNCHRONIZE_PERUSERDISPLAYNAME_MAXVALUESIZE];

    // register any proxies
    HRESULT hRes = PrxDllRegisterServer();

    // !!! STRENTRY and CallResInstall are always ANSI
    STRENTRY seReg[] = {
    {  SZ_MODULEPATH, szModulePath},
    {  SZ_ACCESSORIESGROUP, szAccessoriesGroup},
    {  SZ_SYNCHRONIZE_LINKNAME, szSynchronizeLinkName},
    {  SZ_SYNCHRONIZE_PERUSERDISPLAYNAME, szSynchronizePerUserDisplayName},
    };

    DWORD cbNumEntries = ARRAYLEN(seReg);

    // fill in sizes for how big the string Values are.
    DWORD dwSizes[] = {
        ARRAYLEN(szModulePath),
        ARRAYLEN(szAccessoriesGroup),
        ARRAYLEN(szSynchronizeLinkName),
        ARRAYLEN(szSynchronizePerUserDisplayName),
    };

    Assert(ARRAYLEN(seReg) == ARRAYLEN(dwSizes));
    Assert(ARRAYLEN(seReg) == cbNumEntries);
    Assert(4 == cbNumEntries); // to make sure ARRAYLEN is working properly

    STRTABLE stReg = { cbNumEntries /* Num entries */, seReg };

    // initialize the variables.
    SetupInfVariables(cbNumEntries,(STRENTRY *) &seReg, (DWORD *) &dwSizes);

    // register the RegKeys pasing in the path to the module
    // call even if couldn't get shortcut.
    CallRegInstall(INSTALLSECTION_MACHINEINSTALL,&stReg); // reg the reg keys

    // if got the accessories and shortcut name, register the shortcut.
    if (*szSynchronizeLinkName && *szAccessoriesGroup)
    {
        CallRegInstall(INSTALLSECTION_REGISTERSHORTCUT,&stReg); // reg the reg keys
    }

    // on NT 4.0 register for PerUser.
    if (SystemIsPerUser())
    {
        CallRegInstall(INSTALLSECTION_SETUP_PERUSERINSTALL,&stReg);
    }
    else
    {
        // make sure PerUserKey isn't there on the registration if currenntly
        // not on a PerUser System.

        // to handle the case that during a previous Register user was running
        // under PerUser System but has now upgraded

        // If you ever to want to do PerUserRegistration on platforms we
        // currently don't do PerUser you will need to increase the PerUserRegistration
        // version number in the .inf so it gets run even in case that there are PerUser
        // turds left over under HKCU.

        RegDeleteKey(HKEY_LOCAL_MACHINE,
        TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{6295DF27-35EE-11d1-8707-00C04FD93327}"));
    }
    //
    // Convert the "mobsync.exe /logon" reg value to use a fully-qualified path string.
    //
    RegFixRunKey();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
char szAccessoriesGroup[ACCESSORIESGROUP_MAXVALUESIZE];
char szSynchronizeLinkName[SYNCHRONIZE_LINKNAME_MAXVALUESIZE];
char szSynchronizePerUserDisplayName[SYNCHRONIZE_PERUSERDISPLAYNAME_MAXVALUESIZE];

    // setup variables to pass to .inf
    STRENTRY seReg[] = {
    {  SZ_ACCESSORIESGROUP, szAccessoriesGroup},
    {  SZ_SYNCHRONIZE_LINKNAME, szSynchronizeLinkName},
    {  SZ_SYNCHRONIZE_PERUSERDISPLAYNAME, szSynchronizePerUserDisplayName},
    };

    DWORD cbNumEntries = ARRAYLEN(seReg);

    // fill in sizes for how big the string Values are.
    DWORD dwSizes[] = {
        ARRAYLEN(szAccessoriesGroup),
        ARRAYLEN(szSynchronizeLinkName),
        ARRAYLEN(szSynchronizePerUserDisplayName),
    };

    Assert(ARRAYLEN(seReg) == ARRAYLEN(dwSizes));
    Assert(ARRAYLEN(seReg) == cbNumEntries);

    STRTABLE stReg = { cbNumEntries /* Num entries */, seReg };

    // initialize the variables.
    SetupInfVariables(cbNumEntries,(STRENTRY *) &seReg, (DWORD *) &dwSizes);

    // remove any schedules the user created
   RegUninstallSchedules();

   // remove or LCE/SENS registrations
   RegRegisterForEvents(TRUE /* fUninstall */);
   RegDeleteKeyNT(HKEY_LOCAL_MACHINE, AUTOSYNC_REGKEY); // remove AutoSync key


    // remove the proxies
    PrxDllUnregisterServer();


    // if System Is PerUser call the PerUserUninstall to setup the proper keys
    // if not per user make sure entire InstalledComponents key is gone for our GUID
    if (SystemIsPerUser() )
    {
        CallRegInstall(INSTALLSECTION_REMOVE_PERUSERINSTALL,&stReg);
    }
    else
    {
        RegDeleteKey(HKEY_LOCAL_MACHINE,
        TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{6295DF27-35EE-11d1-8707-00C04FD93327}"));
    }

    // unreg our regkeys
    CallRegInstall(INSTALLSECTION_MACHINEUNINSTALL,&stReg);

    // if got shortcut and accessories group remove shorcut
    if (*szSynchronizeLinkName && *szAccessoriesGroup)
    {
        CallRegInstall(INSTALLSECTION_UNREGISTERSHORTCUT,&stReg); // reg the reg keys
    }

   // review, should be able to do this from .inf file
   RegDeleteKeyNT(HKEY_LOCAL_MACHINE, IDLESYNC_REGKEY); // remove Idle key
   RegDeleteKeyNT(HKEY_LOCAL_MACHINE, MANUALSYNC_REGKEY); // remove Manual key
   RegDeleteKeyNT(HKEY_LOCAL_MACHINE, PROGRESS_REGKEY); // remove ProgressState key

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  function:   DllPerUserRegister, private
//
//  Synopsis:   Handles PerUser Registration
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

STDAPI DllPerUserRegister(void)
{
char szModulePath[MODULEPATH_MAXVALUESIZE]; // !!! these must always be ANSI
char szAccessoriesGroup[ACCESSORIESGROUP_MAXVALUESIZE];
char szSynchronizeLinkName[SYNCHRONIZE_LINKNAME_MAXVALUESIZE];
char szSynchronizePerUserDisplayName[SYNCHRONIZE_PERUSERDISPLAYNAME_MAXVALUESIZE];

    // setup variables to pass to .inf
    STRENTRY seReg[] = {
    {  SZ_MODULEPATH, szModulePath},
    {  SZ_ACCESSORIESGROUP, szAccessoriesGroup},
    {  SZ_SYNCHRONIZE_LINKNAME, szSynchronizeLinkName},
    {  SZ_SYNCHRONIZE_PERUSERDISPLAYNAME, szSynchronizePerUserDisplayName},
    };

    DWORD cbNumEntries = ARRAYLEN(seReg);

    // fill in sizes for how big the string Values are.
    DWORD dwSizes[] = {
        ARRAYLEN(szModulePath),
        ARRAYLEN(szAccessoriesGroup),
        ARRAYLEN(szSynchronizeLinkName),
        ARRAYLEN(szSynchronizePerUserDisplayName),
    };

    Assert(ARRAYLEN(seReg) == ARRAYLEN(dwSizes));
    Assert(ARRAYLEN(seReg) == cbNumEntries);

    STRTABLE stReg = { cbNumEntries /* Num entries */, seReg };

    // initialize the variables.
    SetupInfVariables(cbNumEntries,(STRENTRY *) &seReg, (DWORD *) &dwSizes);

    // if not on NT 4.0 it must have been an upgrade since only register
    // for per User on NT 4.0. If this happens remove the PerUser Setup
    // else install the shortcut for this user.

    // only case this will happen is where NT 4.0 has been upgraded to NT 5.0

    if (!SystemIsPerUser())
    {
        RegDeleteKey(HKEY_LOCAL_MACHINE,
        TEXT("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{6295DF27-35EE-11d1-8707-00C04FD93327}"));
    }
    else
    {
        // if got the accessories and shortcut name, register the shortcut.
        if (*szSynchronizeLinkName && *szAccessoriesGroup)
        {
            CallRegInstall(INSTALLSECTION_REGISTERSHORTCUT,&stReg); // reg the reg keys
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  function:   DllPerUserUnregister, private
//
//  Synopsis:   Handles PerUser UnRegistration. Currently not
//              used since dll is removed on machine unregister
//              there is no dll to call next time user logs on.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    27-Oct-98       rogerg      Created.
//
//----------------------------------------------------------------------------

STDAPI DllPerUserUnregister(void)
{

    AssertSz(0,"DllPerUserUnregister Called");

    return S_OK;
}


// End of Setup APIs


extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{

  if (!PrxDllMain(hInstance, dwReason, lpReserved))
            return FALSE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {

        InitializeCriticalSection(&g_DllCriticalSection);
        g_hmodThisDll = hInstance;

           #ifdef _DEBUG
              InitDebugFlags();
           #endif // _DEBUG

             // setup widewrap before anything else.
               g_OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

               if (!GetVersionExA(&g_OSVersionInfo))
               {
                   AssertSz(0,"Unabled to GetVersion information");
                   g_OSVersionInfo.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
               }

        g_dwPlatformId = g_OSVersionInfo.dwPlatformId;
                BOOL fOSUnicode =  (VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId) ? TRUE : FALSE;
                InitCommonLib(fOSUnicode);

                g_LangIdSystem = GetSystemDefaultLangID(); // find out what lang we are on


        //initialize the common controls
        INITCOMMONCONTROLSEX controlsEx;
        controlsEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
        controlsEx.dwICC = ICC_USEREX_CLASSES | ICC_WIN95_CLASSES | ICC_NATIVEFNTCTL_CLASS;
        InitCommonControlsEx(&controlsEx);


    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        UnInitCommonLib();

    WALKARENA();
    Assert(0 == g_cRefThisDll);
        DeleteCriticalSection(&g_DllCriticalSection);
        TRACE("In DLLMain, DLL_PROCESS_DETACH\r\n");
    }

    return 1;   // ok
}

//---------------------------------------------------------------------------
// DllCanUnloadNow
//---------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
HRESULT hr;

    TRACE("In DLLCanUnloadNow\r\n");

    if (PrxDllCanUnloadNow() != S_OK)
    {
    return S_FALSE;
    }

    if (g_cRefThisDll)
    {
    hr = S_FALSE;
    }
    else
    {
    hr = S_OK;
    }

    return hr;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut)
{
HRESULT hr = E_OUTOFMEMORY;

    TRACE("In DllGetClassObject\r\n");

    *ppvOut = NULL;

    if (IsEqualIID(rclsid, CLSID_SyncMgr))
    {
    CClassFactory *pcf = new CClassFactory;

    if (NULL != pcf)
    {
            hr =  pcf->QueryInterface(riid, ppvOut);
        pcf->Release();
    }
    }
    else
    {

    hr = PrxDllGetClassObject(rclsid,riid, ppvOut); 
    }

    return hr;
}

CClassFactory::CClassFactory()
{
    TRACE("CClassFactory::CClassFactory()\r\n");

    m_cRef = 1;
    InterlockedIncrement((LONG *)& g_cRefThisDll);
}
                                                                
CClassFactory::~CClassFactory()             
{
    InterlockedDecrement((LONG *)& g_cRefThisDll);
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid,
                                                   LPVOID FAR *ppv)
{
    TRACE("CClassFactory::QueryInterface()\r\n");

    *ppv = NULL;

    // Any interface on this object is the object pointer

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;

        AddRef();

        return NOERROR;
    }

    return E_NOINTERFACE;
}   

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
ULONG cRefs;

    // Increment ref count
    cRefs = InterlockedIncrement((LONG *)& m_cRef);

    return cRefs;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (0 == cRefs)
    {
    delete this;
    }

    return cRefs;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                                      REFIID riid,
                                                      LPVOID *ppvObj)
{
HRESULT hr;

    TRACE("CClassFactory::CreateInstance()\r\n");

    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    
    LPSYNCMGRSYNCHRONIZEINVOKE pSyncMgrDllObject = (LPSYNCMGRSYNCHRONIZEINVOKE)
                                                        new CSyncMgrSynchronize;

    if (NULL == pSyncMgrDllObject)
        return E_OUTOFMEMORY;

    hr =  pSyncMgrDllObject->QueryInterface(riid, ppvObj);
    pSyncMgrDllObject->Release();

    return hr;
}


STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{

    if (fLock)
    {
       InterlockedIncrement( (LONG *) &g_cRefThisDll);
    }
    else
    {
       InterlockedDecrement( (LONG *) &g_cRefThisDll);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\color256.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       256color.cpp
//
//  Contents:   Onestop Schedule wizard 256color bitmap handling
//
//  History:    20-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.


static struct {
    HPALETTE        hPal;
    LPBITMAPINFO    lpbmi;
    HGLOBAL         hDIB;
    int             bitpix;
    int             srcOffset;
    int             srcWidth;
    int             srcHeight;
    RECT            dstRect;
} s_Bmp = { NULL, NULL, NULL, 0, 0, 0, 0, {0,0,0,0}};

//-------------------------------------------------------------------------
// Function: SetupPal(ncolor)
//
// Action: Create palette for 256 color DIB.
//
// Return: TRUE if succeeded, FALSE if not.
//-------------------------------------------------------------------------
BOOL SetupPal(WORD ncolor)
{
    UINT                i;
    struct {
       WORD             palVersion;
       WORD             palNumEntries;
       PALETTEENTRY     palPalEntry[256];
    } lgpl256;

    lgpl256.palVersion = 0x300;
    lgpl256.palNumEntries = ncolor;

    for (i = 0; i < lgpl256.palNumEntries; i++) {
        lgpl256.palPalEntry[i].peBlue  = s_Bmp.lpbmi->bmiColors[i].rgbBlue;
        lgpl256.palPalEntry[i].peGreen = s_Bmp.lpbmi->bmiColors[i].rgbGreen;
        lgpl256.palPalEntry[i].peRed   = s_Bmp.lpbmi->bmiColors[i].rgbRed;
        lgpl256.palPalEntry[i].peFlags = 0;
    }

    s_Bmp.hPal = CreatePalette((LPLOGPALETTE)&lgpl256);
    return(s_Bmp.hPal ? TRUE : FALSE);
}


//-------------------------------------------------------------------------
// Function: GetDIBData()
//
// Action: Get 256 color DIB (device independent bitmap) from resource.
//
// Return: TRUE if succeeded, FALSE if not.
//-------------------------------------------------------------------------
BOOL GetDIBData()
{
    HRSRC           hrsrc;
    WORD            ncolor;

    s_Bmp.hPal = NULL;
    hrsrc = FindResource(g_hmodThisDll, MAKEINTRESOURCE(IDB_SPLASH256), RT_BITMAP);
    if (!hrsrc)
        return FALSE;

    s_Bmp.hDIB = LoadResource(g_hmodThisDll, hrsrc);
    if (!s_Bmp.hDIB)
        return FALSE;

    s_Bmp.lpbmi = (LPBITMAPINFO)LockResource(s_Bmp.hDIB);
    if (s_Bmp.lpbmi == NULL)
        return FALSE;

    if (s_Bmp.lpbmi->bmiHeader.biClrUsed > 0)
        ncolor = (WORD)s_Bmp.lpbmi->bmiHeader.biClrUsed;
    else
        ncolor = 1 << s_Bmp.lpbmi->bmiHeader.biBitCount;

    if (ncolor > 256) {
        UnlockResource(s_Bmp.hDIB);
        return FALSE;   // cannot process here
    }

    if ( s_Bmp.lpbmi->bmiHeader.biSize != sizeof(BITMAPINFOHEADER) ) {
        UnlockResource(s_Bmp.hDIB);
        return FALSE;   // format not supported
    }

    if ( !SetupPal(ncolor) ) {
        UnlockResource(s_Bmp.hDIB);
        return FALSE;   // setup palette failed
    }

    s_Bmp.srcWidth = (int)s_Bmp.lpbmi->bmiHeader.biWidth;
    s_Bmp.srcHeight = (int)s_Bmp.lpbmi->bmiHeader.biHeight;
    s_Bmp.srcOffset = (int)s_Bmp.lpbmi->bmiHeader.biSize + (int)(ncolor * sizeof(RGBQUAD));
    UnlockResource(s_Bmp.hDIB);
    return TRUE;
}

//----------------------------------------------------------------------
// Function: Load256ColorBitmap()
//
// Action: Loads the 256color bitmap
//
//----------------------------------------------------------------------
BOOL Load256ColorBitmap()
{
HDC hDc = GetDC(NULL);
    
    if (hDc)
    {
        s_Bmp.bitpix = GetDeviceCaps(hDc, BITSPIXEL);

        ReleaseDC(NULL, hDc);

        if(s_Bmp.bitpix == 8)
        {
	    if(GetDIBData())
	    {
		s_Bmp.lpbmi = (LPBITMAPINFO)LockResource(s_Bmp.hDIB);
	    }
        }

        return TRUE;
    }

    return FALSE;
}

//----------------------------------------------------------------------
// Function: Unload256ColorBitmap()
//
// Action: Unloads the 256color bitmap
//
//----------------------------------------------------------------------
BOOL Unload256ColorBitmap()
{
	if(s_Bmp.hPal)
	{
		UnlockResource(s_Bmp.hDIB);
		DeleteObject(s_Bmp.hPal);
		s_Bmp.hPal = NULL;
	}
	return TRUE;
}
//----------------------------------------------------------------------
// Function: InitPage(hDlg,lParam)
//
// Action: Generic wizard page initialization.
//
//----------------------------------------------------------------------
BOOL InitPage(HWND   hDlg,   LPARAM lParam)
{
    if(s_Bmp.bitpix == 8)   // 256 color mode -> setup destination bmp rect
    {
        HWND hdst;
        RECT rect;
        POINT pt = {0, 0};

        hdst = GetDlgItem(hDlg, IDC_WIZBMP);
        if(hdst != NULL)
        {
            BOOL bSUNKEN;
            s_Bmp.dstRect.left = 0;
            s_Bmp.dstRect.top = 0;
            s_Bmp.dstRect.right = s_Bmp.srcWidth;
            s_Bmp.dstRect.bottom = s_Bmp.srcHeight;
            bSUNKEN = (BOOL)(GetWindowLongPtr(hdst, GWL_STYLE) & SS_SUNKEN);
            if(bSUNKEN)
            {
                s_Bmp.dstRect.right += 2;
                s_Bmp.dstRect.bottom += 2;
            }

            MapWindowPoints(hdst,NULL,&pt,1);
            OffsetRect(&s_Bmp.dstRect, pt.x, pt.y);

            pt.x = 0;
            pt.y = 0;
            GetClientRect(hDlg, &rect);
            MapWindowPoints(hDlg,NULL,&pt,1);

            OffsetRect(&rect, pt.x, pt.y);

            OffsetRect(&s_Bmp.dstRect, -rect.left, -rect.top);
            MoveWindow(hdst,
                s_Bmp.dstRect.left,
                s_Bmp.dstRect.top,
                s_Bmp.dstRect.right - s_Bmp.dstRect.left,
                s_Bmp.dstRect.bottom - s_Bmp.dstRect.top,
                TRUE);
            if(bSUNKEN)
                InflateRect(&s_Bmp.dstRect, -1, -1);
        }else
            SetRect(&s_Bmp.dstRect, 0, 0, 0, 0);
    }

    return TRUE;
}





//-------------------------------------------------------------------------
// Function: WmPaint(hDlg, uMsg, wParam, lParam)
//
// Action: Handle WM_PAINT message. Draw 256 color bmp on 256 color mode.
//
// Return: none
//-------------------------------------------------------------------------
 void WmPaint(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT     ps;

    if(!s_Bmp.hPal){
        DefWindowProc(hDlg, uMsg, wParam, lParam);
        return;
    }

    BeginPaint(hDlg, &ps);
    SelectPalette(ps.hdc, s_Bmp.hPal, FALSE);
    RealizePalette(ps.hdc);

    SetDIBitsToDevice(ps.hdc,
        s_Bmp.dstRect.left,
        s_Bmp.dstRect.top,
        s_Bmp.dstRect.right - s_Bmp.dstRect.left,
        s_Bmp.dstRect.bottom - s_Bmp.dstRect.top,
        0,
        s_Bmp.srcHeight,
        s_Bmp.srcHeight,
        s_Bmp.srcHeight,
        (LPBYTE)s_Bmp.lpbmi + s_Bmp.srcOffset,
        s_Bmp.lpbmi,
        DIB_RGB_COLORS);

    EndPaint(hDlg, &ps);
}


//-------------------------------------------------------------------------
// Function: WmPaletteChanged(hDlg, wParam)
//
// Action: Handle WM_PALETTECHANGED message.
//
// Return: none
//-------------------------------------------------------------------------
 void WmPaletteChanged(HWND hDlg, WPARAM wParam)
{
    HDC         hdc;
    HPALETTE    hPalOld;
    UINT        rp;

    if(hDlg == (HWND)wParam || !s_Bmp.hPal)
        return;

    hdc = GetDC(hDlg);
    hPalOld = SelectPalette(hdc, s_Bmp.hPal, FALSE);
    rp = RealizePalette(hdc);
    if(rp)
        UpdateColors(hdc);

    if (hPalOld)
        SelectPalette(hdc, hPalOld, FALSE);
    ReleaseDC(hDlg, hdc);
}


//-------------------------------------------------------------------------
// Function: WmQueryNewPalette(hDlg)
//
// Action: Handle WM_QUERYNEWPALETTE message.
//
// Return: TRUE if processed, FALSE if not.
//-------------------------------------------------------------------------
 BOOL WmQueryNewPalette(HWND hDlg)
{
HDC     hdc;
HPALETTE    hPalOld;
UINT        rp = 0;

    if(!s_Bmp.hPal)
    {
        return FALSE;
    }

    hdc = GetDC(hDlg);

    if (hdc)
    {
        hPalOld = SelectPalette(hdc, s_Bmp.hPal, FALSE);
        rp = RealizePalette(hdc);
        if(hPalOld)
            SelectPalette(hdc, hPalOld, FALSE);

        ReleaseDC(hDlg, hdc);
    }

    if(rp)
    {
        InvalidateRect(hDlg, NULL, TRUE);
        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------
// Function: WmActivate(hDlg, wParam, lParam)
//
// Action: Handle WM_ACTIVATE message
//
// Return: zero if processed, non zero if not.
//-------------------------------------------------------------------------
 BOOL WmActivate(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    if(!s_Bmp.hPal)
        return 1;

    if(LOWORD(wParam) == WA_INACTIVE)   // Deactivated
        return 1;

    InvalidateRect(hDlg, NULL, FALSE);
    return 0;                       // processed
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\color256.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       256color.h
//
//  Contents:   Onestop Schedule wizard 256color bitmap handling
//
//  History:    20-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------
#ifndef _COLOR256_
#define _COLOR256_

BOOL Load256ColorBitmap();
BOOL Unload256ColorBitmap();
BOOL InitPage(HWND   hDlg,   LPARAM lParam);
BOOL SetupPal(WORD ncolor);
BOOL GetDIBData();
void WmPaint(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void WmPaletteChanged(HWND hDlg, WPARAM wParam);
BOOL WmQueryNewPalette(HWND hDlg);
BOOL WmActivate(HWND hDlg, WPARAM wParam, LPARAM lParam);

#endif //_COLOR256_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\cnetapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cnetapi.cpp
//
//  Contents:   Network/SENS API wrappers
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// SENS DLL and function strings
STRING_FILENAME(szSensApiDll, "SensApi.dll");
STRING_INTERFACE(szIsNetworkAlive,"IsNetworkAlive");

// RAS Dll and Function Strings
STRING_FILENAME(szRasDll, "RASAPI32.DLL");

// RAS function strings
STRING_INTERFACE(szRasEnumConnectionsW,"RasEnumConnectionsW");
STRING_INTERFACE(szRasEnumConnectionsA,"RasEnumConnectionsA");
STRING_INTERFACE(szRasEnumEntriesA,"RasEnumEntriesA");
STRING_INTERFACE(szRasEnumEntriesW,"RasEnumEntriesW");
STRING_INTERFACE(szRasGetEntryPropertiesW,"RasGetEntryPropertiesW");
STRING_INTERFACE(szRasGetErrorStringW,"RasGetErrorStringW");
STRING_INTERFACE(szRasGetErrorStringA,"RasGetErrorStringA");
STRING_INTERFACE(szRasGetAutodialParam, "RasGetAutodialParamA");
STRING_INTERFACE(szRasSetAutodialParam, "RasSetAutodialParamA");

#if 0
RSTRING_INTERFACE(szRasDial,"RasDialW");
STRING_INTERFACE(szRasHangup,"RasHangUpW");
STRING_INTERFACE(szRasGetConnectStatus,"RasGetConnectStatusW");
STRING_INTERFACE(szRasGetEntryDialParams,"RasGetEntryDialParamsW");
STRING_INTERFACE(szRasGetAutodialParam, "RasGetAutodialParamW");
STRING_INTERFACE(szRasSetAutodialParam, "RasSetAutodialParamW");
STRING_INTERFACE(szRasDial,"RasDialA");
STRING_INTERFACE(szRasHangup,"RasHangUpA");
STRING_INTERFACE(szRasGetConnectStatus,"RasGetConnectStatusA");
STRING_INTERFACE(szRasGetEntryDialParams,"RasGetEntryDialParamsA");
#endif

// wininet declarations
// warning - IE 4.0 only exported InternetDial which was ANSI. IE5 has InternetDailA and
// internetDialW. we always use InternetDial for Ansi. So we prefere InternetDialW but
// must fall back to ANSI for IE 4.0
STRING_FILENAME(szWinInetDll, "WININET.DLL");

STRING_INTERFACE(szInternetDial,"InternetDial");
STRING_INTERFACE(szInternetDialW,"InternetDialW");
STRING_INTERFACE(szInternetHangup,"InternetHangUp");
STRING_INTERFACE(szInternetAutodial,"InternetAutodial");
STRING_INTERFACE(szInternetAutodialHangup,"InternetAutodialHangup");
STRING_INTERFACE(szInternetQueryOption,"InternetQueryOptionA"); // always use the A Version
STRING_INTERFACE(szInternetSetOption,"InternetSetOptionA"); // always use A Version

// SENS install key under HKLM
const WCHAR wszSensInstallKey[]  = TEXT("Software\\Microsoft\\Mobile\\Sens");

extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo.

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::CNetApi, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CNetApi::CNetApi()
{
    m_fTriedToLoadSens = FALSE;
    m_hInstSensApiDll = NULL;
    m_pIsNetworkAlive = NULL;

    m_fTriedToLoadRas = FALSE;
    m_hInstRasApiDll = NULL;
    m_pRasEnumConnectionsW = NULL;
    m_pRasEnumConnectionsA = NULL;
    m_pRasEnumEntriesA = NULL;
    m_pRasEnumEntriesW = NULL;
    m_pRasGetEntryPropertiesW = NULL;

    m_pRasGetErrorStringW = NULL;
    m_pRasGetErrorStringA = NULL;
    m_pRasGetAutodialParam = NULL;
    m_pRasSetAutodialParam = NULL;

    #if 0
    m_pRasDial = NULL;
    m_pRasHangup = NULL;
    m_pRasConnectStatus = NULL;
    m_pRasEntryGetDialParams = NULL;
    #endif // 0

    m_fTriedToLoadWinInet = FALSE;
    m_hInstWinInetDll = NULL;
    m_pInternetDial = NULL;
    m_pInternetDialW = NULL;
    m_pInternetHangUp = NULL;
    m_pInternetAutodial = NULL;
    m_pInternetAutodialHangup = NULL;
    m_pInternetQueryOption = NULL;
    m_pInternetSetOption = NULL;

    m_fIsUnicode = WideWrapIsUnicode();
    m_cRefs = 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::~CNetApi, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CNetApi::~CNetApi()
{
    Assert(0 == m_cRefs); 

    if (NULL != m_hInstSensApiDll)
    {
        FreeLibrary(m_hInstSensApiDll);
    }

    if (NULL != m_hInstWinInetDll)
    {
        FreeLibrary(m_hInstWinInetDll);
    }

    if (NULL != m_hInstRasApiDll)
    {
        FreeLibrary(m_hInstWinInetDll);
    }

}

//+-------------------------------------------------------------------------
//
//  Method:     CNetApi::QueryInterface
//
//  Synopsis:   Increments refcount
//
//  History:    31-Jul-1998      SitaramR       Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CNetApi::QueryInterface( REFIID, LPVOID* )
{
    AssertSz(0,"E_NOTIMPL");
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CNetApiXf
//
//  Synopsis:   Increments refcount
//
//  History:    31-Jul-1998      SitaramR       Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)  CNetApi::AddRef()
{
DWORD dwTmp = InterlockedIncrement( (long *) &m_cRefs );

    return dwTmp;
}

//+-------------------------------------------------------------------------
//
//  Method:     CNetApi::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    31-Jul-1998     SitaramR        Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG)  CNetApi::Release()
{
    Assert( m_cRefs > 0 );

    DWORD dwTmp = InterlockedDecrement( (long *) &m_cRefs );

    if ( 0 == dwTmp )
        delete this;

    return dwTmp;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::LoadSensDll
//
//  Synopsis:   Trys to Load Sens Library.
//
//  Arguments:
//
//  Returns:    NOERROR if successfull.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::LoadSensDll()
{
HRESULT hr = S_FALSE;

    if (m_fTriedToLoadSens)
    {
        return m_hInstSensApiDll ? NOERROR : S_FALSE;
    }

    CLock lock(this);
    lock.Enter();

    if (!m_fTriedToLoadSens)
    {
        Assert(NULL == m_hInstSensApiDll);
        m_hInstSensApiDll = LoadLibrary(szSensApiDll);

        if (m_hInstSensApiDll)
        {
            // for now, don't return an error is GetProc Fails but check in each function.
            m_pIsNetworkAlive = (ISNETWORKALIVE)
                                GetProcAddress(m_hInstSensApiDll, szIsNetworkAlive);
        }

        if (NULL == m_hInstSensApiDll  
            || NULL == m_pIsNetworkAlive)
        {
            hr = S_FALSE;

            if (m_hInstSensApiDll)
            {
                FREE(m_hInstSensApiDll);
                m_hInstSensApiDll = NULL;
            }
        }
        else
        {
            hr = NOERROR;
        }

        m_fTriedToLoadSens = TRUE; // set after all initialization is done.

    }
    else
    {
        hr = m_hInstSensApiDll ? NOERROR : S_FALSE;
    }

    lock.Leave();

    return hr; 
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::IsNetworkAlive, public
//
//  Synopsis:   Calls the Sens IsNetworkAlive API.
//
//  Arguments:
//
//  Returns:    IsNetworkAlive results or FALSE is failed to load
//              sens or import.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CNetApi::IsNetworkAlive(LPDWORD lpdwFlags)
{
    //
    // Sens load fail is not an error
    //
    LoadSensDll();

    BOOL fResult = FALSE;

    if (NULL == m_pIsNetworkAlive)
    {
    DWORD cbNumEntries;
    RASCONN *pWanConnections;

        // if couldn't load export see if there are any WAN Connections.
        if (NOERROR == GetWanConnections(&cbNumEntries,&pWanConnections))
        {
            if (cbNumEntries)
            {
                fResult  = TRUE;
                *lpdwFlags = NETWORK_ALIVE_WAN;
            }

            if (pWanConnections)
            {
                FreeWanConnections(pWanConnections);
            }
        }

        // for testing without sens
        //    fResult  = TRUE;
        //   *lpdwFlags |= NETWORK_ALIVE_LAN;
        // end of testing without sens
    }
    else
    {
        fResult = m_pIsNetworkAlive(lpdwFlags);

    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::IsSensInstalled, public
//
//  Synopsis:   Determines if SENS is installed on the System.
//
//  Arguments:
//
//  Returns:   TRUE if sens is installed
//
//  Modifies:
//
//  History:    12-Aug-98      Kyle        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CNetApi::IsSensInstalled(void)
{
HKEY hkResult;
BOOL fResult = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyExXp(HKEY_LOCAL_MACHINE,wszSensInstallKey,0,
                                   KEY_READ,&hkResult,FALSE /*fSetSecurity*/))
    {
        fResult = TRUE;
        RegCloseKey(hkResult);
    }

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::GetWanConnections, public
//
//  Synopsis:   returns an array of Active Wan connections.
//              up to the caller to free RasEntries structure when done.
//
//  Arguments:  [out] [cbNumEntries] - Number of Connections found
//              [out] [pWanConnections] - Array of Connections found.
//
//  Returns:    IsNetworkAlive results or FALSE is failed to load
//              sens or import.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::GetWanConnections(DWORD *cbNumEntries,RASCONN **pWanConnections)
{
DWORD dwError = -1;
DWORD dwSize;
DWORD cConnections;

    *pWanConnections = NULL;
    *pWanConnections = 0;

    LPRASCONN lpRasConn;
    dwSize = sizeof(RASCONN);

    lpRasConn = (LPRASCONN) ALLOC(dwSize);

    if(lpRasConn)
    {
        lpRasConn->dwSize = sizeof(RASCONN);
        cConnections = 0;

        dwError = RasEnumConnections(lpRasConn, &dwSize, &cConnections);

        if (dwError == ERROR_BUFFER_TOO_SMALL)
        {
            dwSize = lpRasConn->dwSize; // get size needed

            FREE(lpRasConn);

            lpRasConn =  (LPRASCONN) ALLOC(dwSize);
            if(lpRasConn)
            {
                lpRasConn->dwSize = sizeof(RASCONN);
                cConnections = 0;
                dwError = RasEnumConnections(lpRasConn, &dwSize, &cConnections);
            }
        }
    }
    
    if (!dwError && lpRasConn)
    {
        *cbNumEntries = cConnections;
        *pWanConnections = lpRasConn;
        return NOERROR;
    }
    else
    {
        if (lpRasConn)
        {
            FREE(lpRasConn);
        }
    }

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::FreeWanConnections, public
//
//  Synopsis:   Called by caller to free up memory 
//              allocated by GetWanConnections.
//
//  Arguments:  [in] [pWanConnections] - WanConnection Array to free
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Dec-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::FreeWanConnections(RASCONN *pWanConnections)
{
    Assert(pWanConnections);

    if (pWanConnections)
    {
        FREE(pWanConnections);
    }

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasEnumConnections, public
//
//  Synopsis:   Wraps RasEnumConnections.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:
//
//  History:    02-Aug-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::RasEnumConnections(LPRASCONNW lprasconn,LPDWORD lpcb,LPDWORD lpcConnections)
{
DWORD dwReturn = -1;
    

    if (NOERROR != LoadRasApiDll())
        return -1;

    if(m_fIsUnicode && m_pRasEnumConnectionsW)
    {
        dwReturn = (*m_pRasEnumConnectionsW)(lprasconn,lpcb,lpcConnections);
    }
    else if (m_pRasEnumConnectionsA)
    {
    DWORD cbNumRasConn;
    LPRASCONNA pRasConnA = NULL;
    DWORD cbBufSizeA;

        // allocate number of RASCONNA names that can
        // be thunked back to RASCONNW. 

        cbNumRasConn = (*lpcb)/sizeof(RASCONNW);

        Assert(cbNumRasConn > 0);

        cbBufSizeA = cbNumRasConn*sizeof(RASCONNA);
                
        if (cbBufSizeA)
        {
            pRasConnA = (LPRASCONNA) ALLOC(cbBufSizeA);

            if (pRasConnA)
            {
                pRasConnA->dwSize = sizeof(RASCONNA);
            }
        }

        dwReturn = (*m_pRasEnumConnectionsA)(pRasConnA,&cbBufSizeA,lpcConnections);


        // fudge and say the cbBufSize necessary is the returned size *2 so
        // wide enough for WCHAR

        *lpcb = cbBufSizeA*2;

        // if no error thunk then entries back to WCHAR.

        if (0 == dwReturn && pRasConnA)
        {
        DWORD dwEntries = *lpcConnections;
        LPRASCONNA pCurRasEntryNameA = pRasConnA;
        LPRASCONNW pCurRasEntryNameW = lprasconn;
        int iFailCount = 0;

            while (dwEntries--)
            {
                //!!! we only conver the entry name if need other fields
                // will have to convert these as well.
                if (!ConvertString(pCurRasEntryNameW->szEntryName,pCurRasEntryNameA->szEntryName
                    ,sizeof(pCurRasEntryNameW->szEntryName)))
                {
                    ++iFailCount;
                }

                ++pCurRasEntryNameW;
                ++pCurRasEntryNameA;
            }

            if (iFailCount)
            {
                Assert(0 == iFailCount); 
                dwReturn = -1;
            }

        }

        if (pRasConnA)
        {
            FREE(pRasConnA);
        }


    }

    return dwReturn;

}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::GetConnectionStatus, private
//
//  Synopsis:   Given a Connection Name determines if the connection
//              has already been established.
//              Also set ths WanActive flag to indicate if there are any
//              existing RAS connections.
//
//  Arguments:  [pszConnectionName] - Name of the Connection
//              [out] [fConnected] - Indicates if specified connection is currently connected.
//              [out] [fCanEstablishConnection] - Flag indicates if the connection is not found can establish it.
//
//  Returns:    NOERROR if the dll was sucessfully loaded
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::GetConnectionStatus(LPCTSTR pszConnectionName,DWORD dwConnectionType,BOOL *fConnected,BOOL *fCanEstablishConnection)
{
    *fConnected = FALSE;
    *fCanEstablishConnection = FALSE;

    // if this is a lan connection then see if network is alive,
    // else go through the Ras apis.
    if (CNETAPI_CONNECTIONTYPELAN == dwConnectionType)
    {
    DWORD dwFlags;

        if (IsNetworkAlive(&dwFlags)
                && (dwFlags & NETWORK_ALIVE_LAN) )
        {
            *fConnected = TRUE;
        }
    }
    else
    {  // check for Ras Connections.
    RASCONN *pWanConnections;
    DWORD cbNumConnections;


        if (NOERROR == GetWanConnections(&cbNumConnections,&pWanConnections))
        {
            *fCanEstablishConnection = TRUE;
            if (cbNumConnections > 0)
            {
                *fCanEstablishConnection = FALSE;

                // loop through the entries to see if this connection is already
                // connected.
                while (cbNumConnections)
                {
                    cbNumConnections--;

                    if (0 == lstrcmp(pWanConnections[cbNumConnections].szEntryName,pszConnectionName))
                    {
                        *fConnected = TRUE;
                        break;
                    }
                }

            }

            if (pWanConnections)
            {
                FreeWanConnections(pWanConnections);
            }

        }

    }


    return NOERROR;
}

#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasDial, private
//
//  Synopsis:   Given a Connection tries to dial it.
//
//  Arguments:  [pszConnectionName]

//  Returns:    NOERROR if the dial was successfull.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CNetApi::RasDial(TCHAR *pszConnectionName,HRASCONN *phRasConn)
{
DWORD dwErr = -1;
RASDIALPARAMS   rasDialParams;

    *phRasConn = 0;

    if (NOERROR != LoadRasApiDll())
        return -1;


    memset(&rasDialParams,0,sizeof(RASDIALPARAMS));
    rasDialParams.dwSize = sizeof(RASDIALPARAMS);
    lstrcpy(rasDialParams.szEntryName,pszConnectionName);

    dwErr = (*m_pRasDial)( NULL, NULL, &rasDialParams, 0,
                    NULL, phRasConn);


    if(dwErr)
    {
        if(*phRasConn)
        {
            m_pRasHangup(*phRasConn);
            *phRasConn = 0;
        }

    }

    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasDialDlg, public
//
//  Synopsis:   Given a Connection tries to dial it.
//
//  Arguments:  [pszConnectionName]
//              [phRasConn] - return HRASCONN if dial was successful.
//
//  Returns:    NOERROR if the dial was successfull.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CNetApi::RasDialDlg(TCHAR *pszConnectionName,HRASCONN *phRasConn)
{
CRasDialDlg *pRasDialDlg = NULL;
DWORD dwErr = -1;

    *phRasConn = 0;

    if (NOERROR == LoadRasApiDll())
    {

        pRasDialDlg = new CRasDialDlg(this);

        if (NULL != pRasDialDlg)
        {
            dwErr = pRasDialDlg->Dial(pszConnectionName,phRasConn);
            delete pRasDialDlg;
        }
    }

    return dwErr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasDialProc, public
//
//  Synopsis:   Directly calls RasDial()
//
//  Arguments:
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CNetApi::RasDialProc(LPRASDIALEXTENSIONS lpRasDialExtensions,
                          LPTSTR lpszPhonebook, LPRASDIALPARAMS lpRasDialParams,
                          DWORD dwNotifierType, LPVOID lpvNotifier,
                          LPHRASCONN phRasConn)
{
DWORD           dwErr = -1;
CRasDialDlg *pRasDialDlg = NULL;


    *phRasConn = 0;

    if (NOERROR != LoadRasApiDll())
        return -1;

    dwErr = (*m_pRasDial)( lpRasDialExtensions, lpszPhonebook, lpRasDialParams,
                    dwNotifierType,lpvNotifier,phRasConn);

    if(dwErr)
    {
        if(*phRasConn)
        {
            m_pRasHangup(*phRasConn);
            *phRasConn = 0;
        }
    }

    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasHangUpProc, public
//
//  Synopsis:   Directly calls RasDial()
//
//  Arguments:
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CNetApi::RasHangUpProc( HRASCONN hrasconn)
{
DWORD   dwErr = -1;


    if (NOERROR != LoadRasApiDll())
        return -1;

    dwErr = m_pRasHangup(hrasconn);

    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasGetConnectStatusProc, public
//
//  Synopsis:   Directly calls RasGetConnectStatus()
//
//  Arguments:
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CNetApi::RasGetConnectStatusProc(HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus)
{
DWORD   dwErr = -1;


    if (NOERROR != LoadRasApiDll())
        return -1;

    dwErr = m_pRasConnectStatus(hrasconn,lprasconnstatus);

    return dwErr;
}
#endif // if 0


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasGetErrorStringProc, public
//
//  Synopsis:   Directly calls RasGetErrorString()
//
//  Arguments:
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::RasGetErrorStringProc( UINT uErrorValue, LPTSTR lpszErrorString,DWORD cBufSize)
{
DWORD   dwErr = -1;


    if (NOERROR != LoadRasApiDll())
        return -1;

    if ( m_fIsUnicode && m_pRasGetErrorStringW)
    {
        dwErr = m_pRasGetErrorStringW(uErrorValue,lpszErrorString,cBufSize);
    }
    else
    {
        XArray<CHAR> xszErrString;
        BOOL fOk = xszErrString.Init( cBufSize );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return dwErr;
        }

        dwErr = m_pRasGetErrorStringA( uErrorValue, xszErrString.Get(), cBufSize );
        if ( dwErr != ERROR_SUCCESS )
            return dwErr;

        XArray<WCHAR> xwszOutErr;
        fOk = ConvertMultiByteToWideChar( xszErrString.Get(), xwszOutErr );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return -1;
        }

        ULONG ulLen = lstrlenX( xwszOutErr.Get() );
        if ( ulLen > cBufSize-1 )
        {
            //
            // Truncate error message to fit
            //
            lstrcpynX( lpszErrorString, xwszOutErr.Get(), cBufSize-1 );
            lpszErrorString[cBufSize-1] = 0;
        }
        else
            lstrcpyX( lpszErrorString, xwszOutErr.Get() );
    }

    return ERROR_SUCCESS;
}


#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasGetEntryDialParamsProc, public
//
//  Synopsis:   Directly calls RasGetEntryDialParams()
//
//  Arguments:
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::RasGetEntryDialParamsProc(LPCTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,LPBOOL lpfPassword)
{
DWORD dwErr = -1;

    if (NOERROR != LoadRasApiDll())
        return -1;

    dwErr = m_pRasEntryGetDialParams(lpszPhonebook,lprasdialparams,lpfPassword);

    return dwErr;

}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasHangup, public
//
//  Synopsis:   Hangs up a Ras Connection.
//
//  Arguments:  [hRasConn] - Ras Connection to Terminate

//  Returns:    NOERROR if the hangup was successfull.
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::RasHangup(HRASCONN hRasConn)
{
DWORD dwErr = 0;

    if (NOERROR != LoadRasApiDll())
        return S_FALSE;

    dwErr = m_pRasHangup(hRasConn);

    return dwErr;
}
#endif // if 0

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasEnumEntries, public
//
//  Synopsis:   wraps RasEnumEntries
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CNetApi::RasEnumEntries(LPWSTR reserved,LPWSTR lpszPhoneBook,
                    LPRASENTRYNAME lprasEntryName,LPDWORD lpcb,LPDWORD lpcEntries)
{
DWORD dwReturn = -1;
    
    if (NOERROR != LoadRasApiDll())
        return -1;

    if(m_fIsUnicode && m_pRasEnumEntriesW)
    {
    BOOL fIsNT = (g_OSVersionInfo.dwPlatformId ==  VER_PLATFORM_WIN32_NT);

        // if NT 5.0 or greater need to call enum with NT 5 size
        // or entries will be missing.
        if (fIsNT && g_OSVersionInfo.dwMajorVersion >= 5)
        {
            dwReturn = RasEnumEntriesNT50(reserved,lpszPhoneBook,
                    lprasEntryName,lpcb,lpcEntries);
        }
        else
        {
            dwReturn = (*m_pRasEnumEntriesW)(reserved,lpszPhoneBook,
                    lprasEntryName,lpcb,lpcEntries);
        }
    }
    else if (m_pRasEnumEntriesA)
    {
    DWORD cbNumRasEntries;
    LPRASENTRYNAMEA pRasEntryNameA = NULL;
    DWORD cbBufSizeA;

        Assert(NULL == reserved);
        Assert(NULL == lpszPhoneBook);

        // allocate number of RASENTRYA names that can
        // be thunked back to RASENTRYW. 

        cbNumRasEntries = (*lpcb)/sizeof(RASENTRYNAMEW);

        Assert(cbNumRasEntries > 0);

        cbBufSizeA = cbNumRasEntries*sizeof(RASENTRYNAMEA);
                
        if (cbBufSizeA)
        {
            pRasEntryNameA = (LPRASENTRYNAMEA) ALLOC(cbBufSizeA);

            if (pRasEntryNameA)
            {
                pRasEntryNameA->dwSize = sizeof(RASENTRYNAMEA);
            }
        }

        dwReturn = (*m_pRasEnumEntriesA)(NULL,NULL,
                pRasEntryNameA,&cbBufSizeA,lpcEntries);


        // fudge and say the cbBufSize necessary is the returned size *2 so
        // wide enough for WCHAR

        *lpcb = cbBufSizeA*2;

        // if no error thunk then entries back to WCHAR.

        if (0 == dwReturn && pRasEntryNameA)
        {
        DWORD dwEntries = *lpcEntries;
        LPRASENTRYNAMEA pCurRasEntryNameA = pRasEntryNameA;
        LPRASENTRYNAMEW pCurRasEntryNameW = lprasEntryName;
        int iFailCount = 0;

            while (dwEntries--)
            {
                if (!ConvertString(pCurRasEntryNameW->szEntryName,pCurRasEntryNameA->szEntryName
                    ,sizeof(pCurRasEntryNameW->szEntryName)))
                {
                    ++iFailCount;
                }

                ++pCurRasEntryNameW;
                ++pCurRasEntryNameA;
            }

            if (iFailCount)
            {
                Assert(0 == iFailCount); 
                dwReturn = -1;
            }

        }

        if (pRasEntryNameA)
        {
            FREE(pRasEntryNameA);
        }


    }

    return dwReturn;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasGetAutodial
//
//  Synopsis:   Gets the autodial state
//
//  Arguments:  [fEnabled] - Whether Ras autodial is enabled or disabled returned here
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::RasGetAutodial( BOOL& fEnabled )
{
    //
    // In case of failures the default is to assume that Ras autodial is enabled
    //
    fEnabled = TRUE;

    if (NOERROR != LoadRasApiDll())
        return NOERROR;

    if ( m_pRasGetAutodialParam == NULL )
        return NOERROR;

    DWORD dwValue;
    DWORD dwSize = sizeof(dwValue);
    DWORD dwRet = m_pRasGetAutodialParam( RASADP_LoginSessionDisable,
                                          &dwValue,
                                          &dwSize );
    if ( dwRet == ERROR_SUCCESS )
    {
        Assert( dwSize == sizeof(dwValue) );
        fEnabled = (dwValue == 0);
    }

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::RasSetAutodial
//
//  Synopsis:   Sets the autodial state
//
//  Arguments:  [fEnabled] - Whether Ras is to be enabled or disabled
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::RasSetAutodial( BOOL fEnabled )
{
    //
    // Ignore failures
    //
    if (NOERROR != LoadRasApiDll())
        return NOERROR;

    if ( m_pRasGetAutodialParam == NULL )
        return NOERROR;

    DWORD dwValue = !fEnabled;
    DWORD dwRet = m_pRasSetAutodialParam( RASADP_LoginSessionDisable,
                                          &dwValue,
                                          sizeof(dwValue) );
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::LoadRasApiDll, private
//
//  Synopsis:   If not already loaded, loads the RasApi Dll.
//
//  Arguments:
//
//  Returns:    NOERROR if the dll was sucessfully loaded
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CNetApi::LoadRasApiDll()
{
HRESULT hr = S_FALSE;;

    if (m_fTriedToLoadRas)
    {
        return m_hInstRasApiDll ? NOERROR : S_FALSE;
    }

    CLock lock(this);
    lock.Enter();

    if (!m_fTriedToLoadRas)
    {
        Assert(NULL == m_hInstRasApiDll);
        m_hInstRasApiDll = NULL;

        if (IsRasInstalled())
        {

            m_hInstRasApiDll = LoadLibrary(szRasDll);

            if (m_hInstRasApiDll)
            {
                m_pRasEnumConnectionsW = (RASENUMCONNECTIONSW)
                                    GetProcAddress(m_hInstRasApiDll, szRasEnumConnectionsW);
                m_pRasEnumConnectionsA = (RASENUMCONNECTIONSA)
                                    GetProcAddress(m_hInstRasApiDll, szRasEnumConnectionsA);

                m_pRasEnumEntriesA = (RASENUMENTRIESPROCA) 
		        GetProcAddress(m_hInstRasApiDll, szRasEnumEntriesA);

                m_pRasEnumEntriesW = (RASENUMENTRIESPROCW) 
		        GetProcAddress(m_hInstRasApiDll, szRasEnumEntriesW);

                m_pRasGetEntryPropertiesW = (RASGETENTRYPROPERTIESPROC)
		        GetProcAddress(m_hInstRasApiDll, szRasGetEntryPropertiesW);

#if 0
                m_pRasDial = (RASDIAL)
                                    GetProcAddress(m_hInstRasApiDll, szRasDial);

                m_pRasHangup = (RASHANGUP)
                                    GetProcAddress(m_hInstRasApiDll, szRasHangup);

                m_pRasEntryGetDialParams = (RASGETENTRYDIALPARAMSPROC)
                                     GetProcAddress(m_hInstRasApiDll, szRasGetEntryDialParams);


                m_pRasConnectStatus = (RASGETCONNECTSTATUSPROC)
                                     GetProcAddress(m_hInstRasApiDll, szRasGetConnectStatus);

#endif // 0
                m_pRasGetErrorStringW = (RASGETERRORSTRINGPROCW)
                                     GetProcAddress(m_hInstRasApiDll, szRasGetErrorStringW);
                m_pRasGetErrorStringA = (RASGETERRORSTRINGPROCA)
                                     GetProcAddress(m_hInstRasApiDll, szRasGetErrorStringA);

                m_pRasGetAutodialParam = (RASGETAUTODIALPARAM)
                                     GetProcAddress(m_hInstRasApiDll, szRasGetAutodialParam);

                m_pRasSetAutodialParam = (RASSETAUTODIALPARAM)
                                     GetProcAddress(m_hInstRasApiDll, szRasSetAutodialParam);
            }
        }

        //
        // No check for Get/SetAutodialParam because they don't exist on Win 95
        //
        if (NULL == m_hInstRasApiDll
               || NULL == m_hInstRasApiDll
               || NULL == m_pRasEnumConnectionsA
               || NULL == m_pRasGetErrorStringA
               || NULL == m_pRasEnumEntriesA
#if 0
               || NULL == m_pRasDial
               || NULL == m_pRasConnectStatus
               || NULL == m_pRasHangup
               || NULL == m_pRasEntryGetDialParams
#endif // 0
               )
        {
            
            if (m_hInstRasApiDll)
            {
                FreeLibrary(m_hInstRasApiDll);
                m_hInstRasApiDll = NULL;
            }

            hr = S_FALSE;
        }
        else
        {
            hr = NOERROR;
        }

        m_fTriedToLoadRas = TRUE; // set after all init is done.
    }
    else
    {
        hr = m_hInstRasApiDll ? NOERROR : S_FALSE;
    }

    lock.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::LoadWinInetDll, private
//
//  Synopsis:   If not already loaded, loads the WinInet Dll.
//
//  Arguments:
//
//  Returns:    NOERROR if the dll was sucessfully loaded
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CNetApi::LoadWinInetDll()
{

    if (m_fTriedToLoadWinInet)
    {
        return m_hInstWinInetDll ? NOERROR : S_FALSE;
    }

    CLock lock(this);
    lock.Enter();

    HRESULT hr = NOERROR;

    if (!m_fTriedToLoadWinInet)
    {
        Assert(NULL == m_hInstWinInetDll);

         m_hInstWinInetDll = LoadLibrary(szWinInetDll);

        if (m_hInstWinInetDll)
        {
            m_pInternetDial = (INTERNETDIAL) GetProcAddress(m_hInstWinInetDll, szInternetDial);
            m_pInternetDialW = (INTERNETDIALW) GetProcAddress(m_hInstWinInetDll, szInternetDialW);
            m_pInternetHangUp = (INTERNETHANGUP) GetProcAddress(m_hInstWinInetDll, szInternetHangup);
            m_pInternetAutodial = (INTERNETAUTODIAL)  GetProcAddress(m_hInstWinInetDll, szInternetAutodial);
            m_pInternetAutodialHangup = (INTERNETAUTODIALHANGUP) GetProcAddress(m_hInstWinInetDll, szInternetAutodialHangup);
            m_pInternetQueryOption = (INTERNETQUERYOPTION)  GetProcAddress(m_hInstWinInetDll, szInternetQueryOption);
            m_pInternetSetOption = (INTERNETSETOPTION)  GetProcAddress(m_hInstWinInetDll, szInternetSetOption);

            // note: not an error if can't get wide version of InternetDial
            Assert(m_pInternetDial);
            Assert(m_pInternetHangUp);
            Assert(m_pInternetAutodial);
            Assert(m_pInternetAutodialHangup);
            Assert(m_pInternetQueryOption);
            Assert(m_pInternetSetOption);
        }

         // note: don't bail if can't get wide version of InternetDial
        if (NULL == m_hInstWinInetDll
               || NULL == m_pInternetDial
               || NULL == m_pInternetHangUp
               || NULL == m_pInternetAutodial
               || NULL == m_pInternetAutodialHangup
               || NULL == m_pInternetQueryOption
               || NULL == m_pInternetSetOption
            )
        {
            if (m_hInstWinInetDll)
            {
                FreeLibrary(m_hInstWinInetDll);
                m_hInstWinInetDll = NULL;
            }

            hr = S_FALSE;
        }
        else
        {
            hr = NOERROR;
        }

        m_fTriedToLoadWinInet = TRUE; // set after all init is done.
    }
    else
    {
        // someone took the lock before us, return the new resul
        hr = m_hInstWinInetDll ? NOERROR : S_FALSE;
    }



    lock.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetDial, private
//
//  Synopsis:   Calls the WinInet InternetDial API.
//
//  Arguments:
//
//  Returns:    -1 can't load dll
//              whatever API returns.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::InternetDialA(HWND hwndParent,char* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved)
{
DWORD dwRet = -1;

    if (NOERROR == LoadWinInetDll())
    {
       dwRet = m_pInternetDial(hwndParent,lpszConnectoid,dwFlags,lpdwConnection,dwReserved);
    }

    return dwRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetDial, private
//
//  Synopsis:   Calls the WinInet InternetDial API.
//
//  Arguments:
//
//  Returns:    -1 can't load dll
//              whatever API returns.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::InternetDialW(HWND hwndParent,WCHAR* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved)
{
DWORD dwRet = -1;

    if (NOERROR == LoadWinInetDll())
    {
       if (m_pInternetDialW)
       {
            dwRet = m_pInternetDialW(hwndParent,lpszConnectoid,dwFlags,lpdwConnection,dwReserved);
       }
       else
       {
           XArray<CHAR> xszConnectoid;
           BOOL fOk = ConvertWideCharToMultiByte( lpszConnectoid, xszConnectoid );
           if ( !fOk )
               return dwRet;

           dwRet = InternetDialA(hwndParent, xszConnectoid.Get(), dwFlags, lpdwConnection, dwReserved);
        }
    }

    return dwRet;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetHangUp, private
//
//  Synopsis:   Calls the WinInet InternetHangUp API.
//
//  Arguments:
//
//  Returns:    -1 can't load dll
//              whatever API returns.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(DWORD) CNetApi::InternetHangUp(DWORD dwConnection,DWORD dwReserved)
{
DWORD dwRet = -1;

    if (NOERROR == LoadWinInetDll())
    {
       dwRet = m_pInternetHangUp(dwConnection,dwReserved);
    }

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetAutodial, private
//
//  Synopsis:   Calls the WinInet InternetAutodial API.
//
//  Arguments:
//
//  Returns:    TRUE if connection was established.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(BOOL)  WINAPI CNetApi::InternetAutodial(DWORD dwFlags,DWORD dwReserved)
{
BOOL fRet = FALSE;

    if (NOERROR == LoadWinInetDll())
    {
       fRet = m_pInternetAutodial(dwFlags,dwReserved);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetAutodialHangup, private
//
//  Synopsis:   Calls the WinInet InternetAutodialHangup API.
//
//  Arguments:
//
//  Returns:   TRUE if hangup was successful.
//
//  Modifies:
//
//  History:    26-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(BOOL)  WINAPI CNetApi::InternetAutodialHangup(DWORD dwReserved)
{
BOOL fRet = FALSE;

    if (NOERROR == LoadWinInetDll())
    {
       fRet = m_pInternetAutodialHangup(dwReserved);
    }

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetGetAutoDial
//
//  Synopsis:   Gets the wininet autodial state
//
//  Arguments:  [fDisabled] - Whether autodial is enabled or disabled
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::InternetGetAutodial( BOOL& fEnabled )
{

    //
    // In case of failures the default is to assume that Wininet autodial is enabled
    //
    fEnabled = TRUE;

    if ( NOERROR == LoadWinInetDll() )
    {
        DWORD dwEnable = 1;
        DWORD dwSize = sizeof(DWORD);

        BOOL fOk = m_pInternetQueryOption(NULL, INTERNET_OPTION_DISABLE_AUTODIAL, &dwEnable, &dwSize);
        if ( fOk )
        {
            //
            // InternetQueryOption( .. AUTODIAL .. ) is available on IE 5 only
            //
            fEnabled = dwEnable;
            return NOERROR;
        }
    }

    //
    // For IE < version 5, fall back to reading registry
    //
    HKEY hkIE;
    LONG lr = RegOpenKeyExXp( HKEY_CURRENT_USER,
                          L"software\\microsoft\\windows\\currentversion\\Internet Settings",
                          NULL,KEY_READ,
                          &hkIE,FALSE /*fSetSecurity*/);
    if ( lr != ERROR_SUCCESS )
        return NOERROR;

    DWORD dwType;
    DWORD dwValue;
    DWORD dwSize = sizeof(dwValue);
    lr = RegQueryValueEx( hkIE,
                          L"EnableAutoDial",
                          NULL,
                          &dwType,
                          (BYTE *)&dwValue,
                          &dwSize );
    RegCloseKey( hkIE );

    if ( lr == ERROR_SUCCESS )
    {
        Assert( dwSize == sizeof(dwValue) && (dwType == REG_BINARY || dwType == REG_DWORD) );
        fEnabled = (dwValue == 1);
    }

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetApi::InternetSetAutoDial
//
//  Synopsis:   Sets the wininet autodial state
//
//  Arguments:  [fEnabled] - Whether autodial is to be enabled or disabled
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CNetApi::InternetSetAutodial( BOOL fEnabled )
{
    //
    // Ignore failures
    //

    if ( NOERROR == LoadWinInetDll() )
    {
        DWORD dwEnable = fEnabled;

        BOOL fOk = m_pInternetSetOption(NULL, INTERNET_OPTION_DISABLE_AUTODIAL, &dwEnable, sizeof(DWORD));
        if ( fOk )
        {
            //
            // InternetSetOption( .. AUTODIAL .. ) is available on IE 5 only
            //
            return NOERROR;
        }
    }

    //
    // For IE < version 5, fall back to reading registry
    //
    HKEY  hkIE;
    LONG lr = RegOpenKeyExXp( HKEY_CURRENT_USER,
                          L"software\\microsoft\\windows\\currentversion\\Internet Settings",
                          NULL,KEY_READ | KEY_WRITE,
                          &hkIE,FALSE /*fSetSecurity*/ );
   
    if ( lr != ERROR_SUCCESS )
        return NOERROR;

    DWORD dwValue = fEnabled;
    lr = RegSetValueEx( hkIE,
                        L"EnableAutoDial",
                        NULL,
                        REG_BINARY,
                        (BYTE *)&dwValue,
                        sizeof(dwValue) );
    RegCloseKey( hkIE );

    return NOERROR;
}


//+-------------------------------------------------------------------
//
//  Function: IsGlobalOffline
//
//  Synopsis:  Determines if in WorkOffline State
//
//  Arguments: 
//
//  Notes: Code Provided by DarrenMi
//
//
//  History:  
//
//--------------------------------------------------------------------


STDMETHODIMP_(BOOL) CNetApi::IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
    
    LoadWinInetDll();

    if (NULL == m_pInternetQueryOption)
    {
        Assert(m_pInternetQueryOption)
        return FALSE; // USUAL NOT OFFLINE
    }

    if(m_pInternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

//+-------------------------------------------------------------------
//
//  Function:    SetOffline
//
//  Synopsis:  Sets the WorkOffline state to on or off.
//
//  Arguments: 
//
//  Notes: Code Provided by DarrenMi
//
//
//  History:  
//
//--------------------------------------------------------------------


STDMETHODIMP_(BOOL)  CNetApi::SetOffline(BOOL fOffline)
{    
INTERNET_CONNECTED_INFO ci;
BOOL fReturn = FALSE;

    LoadWinInetDll();

    if (NULL == m_pInternetSetOption)
    {
        Assert(m_pInternetSetOption);
        return FALSE;
    }

    memset(&ci, 0, sizeof(ci));

    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    fReturn = m_pInternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));

    return fReturn;
}

//+-------------------------------------------------------------------
//
//  Function:    IsRasInstalled
//
//  Synopsis:  determine whether this machine has ras installed
//
//  Arguments: 
//
//  Notes: Stole code from WinInent. Can call InternetGetConnectionEx
//          to get this information but this is an IE 5.0 only function.
//          If IE 5.0 wininet is available on all shipping platforms
//          call the InternetGetConnectionEx funciton instead of this.
//
//
//  History:  
//
//--------------------------------------------------------------------

// from sdk\inc\inetreg.h
#ifdef _DONTINCLUDEINETREG
#define TSZMICROSOFTPATH                  TEXT("Software\\Microsoft")
#define TSZWINCURVERPATH TSZMICROSOFTPATH TEXT("\\windows\\CurrentVersion")
#define REGSTR_PATH_RNACOMPONENT    TSZWINCURVERPATH    TEXT("\\Setup\\OptionalComponents\\RNA")
#define REGSTR_VAL_RNAINSTALLED     TEXT("Installed")
#endif // #ifdef _DONTINCLUDEINETREG


// from private\inet\wininet\dll\autodial.cxx
static const TCHAR szRegKeyRAS[] = TEXT("SOFTWARE\\Microsoft\\RAS");


STDMETHODIMP_(BOOL) IsRasInstalled(void)
{
BOOL fInstalled = FALSE;
OSVERSIONINFOA OSVersionInfo;

   OSVersionInfo.dwOSVersionInfoSize = sizeof(OSVersionInfo);

   if (!GetVersionExA(&OSVersionInfo))
   {
       AssertSz(0,"Unable to GetOS Version");
       return TRUE; // go ahead and try RAS anyway.
   }

   if(VER_PLATFORM_WIN32_WINDOWS == OSVersionInfo.dwPlatformId) {
        //
        // Check Win9x key
        //
        TCHAR    szSmall[3]; // there should be a "1" or a "0" only
        DWORD   cb = 3 * sizeof(TCHAR);
        HKEY    hkey;
        long    lRes;

        lRes = RegOpenKeyExXp(HKEY_LOCAL_MACHINE, REGSTR_PATH_RNACOMPONENT,
                             NULL, KEY_READ, &hkey,FALSE /*fSetSecurity*/);
        if(ERROR_SUCCESS == lRes) {
            
            
            //  REGSTR_VAL_RNAINSTALLED is defined with TEXT() macro so
            //  if wininet is ever compiled unicode this will be a compile
            //  error.
            lRes = RegQueryValueEx(hkey, REGSTR_VAL_RNAINSTALLED, NULL,
                    NULL, (LPBYTE)szSmall, &cb);
            if(ERROR_SUCCESS == lRes) {
                if((szSmall[0] ==  TEXT('1')) && (szSmall[1] == 0)) {
                    // 1 means ras installed
                    fInstalled = TRUE;
                }
            }
            RegCloseKey(hkey);
        }
    } else {
        if (OSVersionInfo.dwMajorVersion < 5)
        {
            //
            // Check old NT key (5.x (and presumably later versions) always have RAS installed)
            //
            HKEY hKey;
            long lerr;

            lerr = RegOpenKeyExXp(HKEY_LOCAL_MACHINE, szRegKeyRAS, 0,
                    KEY_READ, &hKey,FALSE /*fSetSecurity*/);
            if(ERROR_SUCCESS == lerr) {
                // key exists - ras is installed
                fInstalled = TRUE;
                RegCloseKey(hKey);
            }
        } else {
            // NT5 and later - always installed
            fInstalled = TRUE;
        }
    }

    return fInstalled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\cred.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       wizsel.cxx
//
//  Contents:   Task schedule credentials selection property page implementation.
//
//  Classes:    CCredentialsPage
//
//  History:    05-22-1998   SusiA
//
//---------------------------------------------------------------------------

#include "precomp.h"

// temporariy define new mstask flag in case hasn't
// propogated to sdk\inc
//for CS help

#ifdef _CREDENTIALS

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

extern DWORD g_dwPlatformId;

CCredentialsPage *g_pCredentialsPage = NULL;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardCredentialsDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------
BOOL CALLBACK SchedWizardCredentialsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
        WORD wNotifyCode = HIWORD(wParam); // notification code

        switch (uMessage)
        {
                case WM_INITDIALOG:

                        if (g_pCredentialsPage)
                                g_pCredentialsPage->Initialize(hDlg);

            InitPage(hDlg,lParam);
            break;

                case WM_HELP:
        {
                        LPHELPINFO lphi  = (LPHELPINFO)lParam;

                        if (lphi->iContextType == HELPINFO_WINDOW)
                        {
                                WinHelp ( (HWND) lphi->hItemHandle,
                                        szSyncMgrHelp,
                                        HELP_WM_HELP,
                                        (ULONG_PTR) g_aContextHelpIds);
                        }
                        return TRUE;
                }
                case WM_CONTEXTMENU:
                {
                        WinHelp ((HWND)wParam,
                            szSyncMgrHelp,
                            HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aContextHelpIds);

                        return TRUE;
                }
                case WM_PAINT:
            WmPaint(hDlg, uMessage, wParam, lParam);
            break;

        case WM_PALETTECHANGED:
            WmPaletteChanged(hDlg, wParam);
            break;

        case WM_QUERYNEWPALETTE:
            return( WmQueryNewPalette(hDlg) );
            break;

        case WM_ACTIVATE:
            return( WmActivate(hDlg, wParam, lParam) );
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                                case IDC_USERNAME:
                                case IDC_PASSWORD:
                                case IDC_CONFIRMPASSWORD:
                                {
                                        if (wNotifyCode == EN_CHANGE)
                                        {
                                                PropSheet_Changed(GetParent(hDlg), hDlg);
                                                g_pCredentialsPage->SetDirty();
                                        }
                                }
                                break;

                                case IDC_RUNLOGGEDON:
                                {
                                        if (wNotifyCode == BN_CLICKED)
                                        {
                                                PropSheet_Changed(GetParent(hDlg), hDlg);
                                                g_pCredentialsPage->SetDirty();
                                                g_pCredentialsPage->SetEnabled(FALSE);

                                        }
                                }
                                break;
                                case IDC_RUNALWAYS:
                                {
                                        if (wNotifyCode == BN_CLICKED)
                                        {
                                                PropSheet_Changed(GetParent(hDlg), hDlg);
                                                g_pCredentialsPage->SetDirty();
                                                g_pCredentialsPage->SetEnabled(TRUE);

                                        }
                                }
                                break;

                                default:
                    break;

            }
            break;

                default:
                        return FALSE;
        }
        return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCredentialsPage::CCredentialsPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA
//
//---------------------------------------------------------------------------

CCredentialsPage::CCredentialsPage(
    HINSTANCE hinst,
        BOOL *pfSaved,
        ISyncSchedule *pISyncSched,
    HPROPSHEETPAGE *phPSP)
{
        ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));

        m_psp.dwSize = sizeof (PROPSHEETPAGE);
        m_psp.dwFlags = PSP_DEFAULT;
        m_psp.hInstance = hinst;
        m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDPAGE_CREDENTIALS);
        m_psp.pszIcon = NULL;
        m_psp.pfnDlgProc = (DLGPROC) SchedWizardCredentialsDlgProc;
        m_psp.lParam = 0;

        g_pCredentialsPage = this;
        m_pISyncSched = pISyncSched;
        m_pISyncSched->AddRef();

        m_pfSaved = pfSaved;
        *m_pfSaved = FALSE;

        m_fTaskAccountChange = FALSE;

#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

   *phPSP = CreatePropertySheetPage(&m_psp);


}

//+--------------------------------------------------------------------------
//
//  Member:     CCredentialsPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the credentials page
//
//  History:    05-22-1998   SusiA
//
//---------------------------------------------------------------------------

BOOL CCredentialsPage::Initialize(HWND hwnd)
{
        m_hwnd = hwnd;

        ShowUserName();

        //Set the default IDC_ONLY_WHEN_LOGGED_ON check state.
        ITask *pITask;
        m_pISyncSched->GetITask(&pITask);
        DWORD dwFlags;
        pITask->GetFlags(&dwFlags);

        BOOL fOnlyWhenLoggedOn = dwFlags & TASK_FLAG_RUN_ONLY_IF_LOGGED_ON;

        Button_SetCheck(GetDlgItem(m_hwnd,IDC_RUNLOGGEDON), fOnlyWhenLoggedOn);
        Button_SetCheck(GetDlgItem(m_hwnd,IDC_RUNALWAYS), !fOnlyWhenLoggedOn);
        Edit_LimitText(GetDlgItem(m_hwnd, IDC_PASSWORD), PWLEN);
        Edit_LimitText(GetDlgItem(m_hwnd, IDC_CONFIRMPASSWORD), PWLEN);
        Edit_LimitText(GetDlgItem(m_hwnd, IDC_USERNAME), MAX_DOMANDANDMACHINENAMESIZE -1);

        SetEnabled(!fOnlyWhenLoggedOn);
        pITask->Release();


        ShowWindow(m_hwnd, /* nCmdShow */ SW_SHOWNORMAL );
        UpdateWindow(m_hwnd);


        return TRUE;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CCredentialsPage::SetDirty()
//
//  PURPOSE:  we have changed the account info
//
//      COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
void CCredentialsPage::SetDirty()
{
         m_fTaskAccountChange = TRUE;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSelectItemsPage::ShowUserName()
//
//  PURPOSE:  change the task's user name
//
//      COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
BOOL CCredentialsPage::ShowUserName()
{

        Assert(m_pISyncSched);

        WCHAR wszUserName[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;

        HWND hwndEdit = GetDlgItem(m_hwnd, IDC_USERNAME);

        HRESULT hr = m_pISyncSched->GetAccountInformation(&dwSize, wszUserName);

        if (FAILED(hr))
        {
            *wszUserName = L'\0';
        }

        Edit_SetText(hwndEdit, wszUserName);

        //
        // Need to set m_fTaskAccountChange here since doing a Edit_SetText causes
        // a WM_COMMAND msg with EN_CHANGE to be called for edit boxes.
        //
        m_fTaskAccountChange = FALSE;

        return TRUE;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSelectItemsPage::CommitChanges()
//
//  PURPOSE:  Write all the current Schedule Settings to the registry
//
//      COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
HRESULT CCredentialsPage::CommitChanges()
{
        HRESULT hr = S_OK;
        BOOL fAccountChanged = TRUE;

        if (m_fTaskAccountChange)
        {
                BOOL fRunAlways = Button_GetCheck(GetDlgItem(m_hwnd,IDC_RUNALWAYS));


                if (fRunAlways)
                {
                        Assert(m_pISyncSched);
                        WCHAR wcUserBuffMAX_DOMANDANDMACHINENAMESIZE];
                        WCHAR wcPassword[PWLEN + 1];
                        WCHAR wcConfirmPassword[PWLEN + 1];
                        
                        GetDlgItemText(m_hwnd,IDC_USERNAME,wcUserBuff,MAX_DOMANDANDMACHINENAMESIZE);
                        GetDlgItemText(m_hwnd,IDC_PASSWORD,wcPassword, PWLEN);
                        GetDlgItemText(m_hwnd,IDC_CONFIRMPASSWORD,wcConfirmPassword, PWLEN);


                        if (wcscmp(wcPassword, wcConfirmPassword) != 0)
                        {
                                // we return this to signal the controlling page not to
                                // dismiss the dialog.
                                return(ERROR_INVALID_PASSWORD);
                        }


                        ITask *pITask;
                        if (FAILED(hr = m_pISyncSched->GetITask(&pITask)))
                        {
                                return hr;
                        }

                        if (FAILED (hr = m_pISyncSched->SetAccountInformation(wcUserBuff,
                                                                                                        wcPassword)))
                        {
                                AssertSz(0,"ISyncSched->SetAccountInformation failed");
                                return hr;
                        }

                        DWORD dwFlags;
                        pITask->GetFlags(&dwFlags);

                        if (FAILED(hr = pITask->SetFlags(dwFlags & (~TASK_FLAG_RUN_ONLY_IF_LOGGED_ON))))
                        {
                                AssertSz(0,"ITask->SetFlags failed");
                                return hr;
                        }
                        pITask->Release();

                }
                else
                {
                        ITask *pITask;
                        if (FAILED(hr = m_pISyncSched->GetITask(&pITask)))
                        {
                                return hr;
                        }

                        WCHAR wszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];

                        GetDefaultDomainAndUserName(wszDomainAndUser,TEXT("\\"),MAX_DOMANDANDMACHINENAMESIZE);

                        if (FAILED(hr = m_pISyncSched->SetAccountInformation(wszDomainAndUser, NULL)))
                        {
                                AssertSz(0,"ISyncSched->SetAccountInformation failed");
                                return hr;
                        }

                        DWORD dwFlags;
                        pITask->GetFlags(&dwFlags);

                        if (FAILED(hr = pITask->SetFlags(dwFlags | TASK_FLAG_RUN_ONLY_IF_LOGGED_ON)))
                        {
                                AssertSz(0,"ITask->SetFlags failed");
                                return hr;
                        }
                        pITask->Release();

                }
                //Now save the schedule
                //NoteNote: optimize by moving the save from wizsel and cred to EditSyncSched
                hr = m_pISyncSched->Save();
                if (hr == S_OK)
                {
                        *m_pfSaved = TRUE;
                }
        }
        return hr;
}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::SetEnabled(BOOL fEnabled)
//
//  PURPOSE: set the fields enabled according to the RB choice
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CCredentialsPage::SetEnabled(BOOL fEnabled)
{
        EnableWindow(GetDlgItem(m_hwnd, IDC_USERNAME), fEnabled);
        EnableWindow(GetDlgItem(m_hwnd, IDC_PASSWORD), fEnabled);
        EnableWindow(GetDlgItem(m_hwnd, IDC_CONFIRMPASSWORD), fEnabled);
        EnableWindow(GetDlgItem(m_hwnd, IDC_RUNAS_TEXT), fEnabled);
        EnableWindow(GetDlgItem(m_hwnd, IDC_PASSWORD_TEXT), fEnabled);
        EnableWindow(GetDlgItem(m_hwnd, IDC_CONFIRMPASSWORD_TEXT), fEnabled);

        return TRUE;

}

#endif // #ifdef _CREDENTIALS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\confres.h ===
#ifndef _CONFRES_H_
#define _CONFRES_H_

// If we require any of the elements in the dialog box, we can call the
// caller back via the callback function and specify what we want
// (This has not yet been implemented)
#define RFCD_NAME                0x0001
#define RFCD_KEEPBOTHICON        0x0002
#define RFCD_KEEPLOCALICON       0x0004
#define RFCD_KEEPSERVERICON      0x0008
#define RFCD_NETWORKMODIFIEDBY   0x0010
#define RFCD_NETWORKMODIFIEDON   0x0020
#define RFCD_LOCALMODIFIEDBY     0x0040
#define RFCD_LOCALMODIFIEDON     0x0080
#define RFCD_NEWNAME             0x0100
#define RFCD_LOCATION            0x0200
#define RFCD_ALL                 0x03FF

// User clicks the view button. This is the message sent to the caller
// via the callback
#define RFCCM_VIEWLOCAL          0x0001   
#define RFCCM_VIEWNETWORK        0x0002
#define RFCCM_NEEDELEMENT        0x0003

// Return values
#define RFC_KEEPBOTH             0x01
#define RFC_KEEPLOCAL            0x02
#define RFC_KEEPNETWORK          0x03

typedef BOOL (*PFNRFCDCALLBACK)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

typedef struct tagRFCDLGPARAMW {
    DWORD   dwFlags;                // currently unused.. 
    LPCWSTR  pszFilename;            // File name of the file conflicted
    LPCWSTR  pszLocation;            // Location of the file
    LPCWSTR  pszNewName;             // The  new name to give the file
    LPCWSTR  pszNetworkModifiedBy;   // Name of person who changed the net doc
    LPCWSTR  pszLocalModifiedBy;     // Name of person who changed the local doc
    LPCWSTR  pszNetworkModifiedOn;   // When the net doc was changed
    LPCWSTR  pszLocalModifiedOn;     // Whent the local doc was changed
    HICON    hIKeepBoth;             // Icon
    HICON    hIKeepLocal;            //
    HICON    hIKeepNetwork;          //
    PFNRFCDCALLBACK pfnCallBack;    // Callback
    LPARAM  lCallerData;            // Place where the caller can keep some context data
} RFCDLGPARAMW;

typedef struct tagRFCDLGPARAMA {
    DWORD   dwFlags;                // currently unused.. 
    LPCSTR  pszFilename;            // File name of the file conflicted
    LPCSTR  pszLocation;            // Location of the file
    LPCSTR  pszNewName;             // The  new name to give the file
    LPCSTR  pszNetworkModifiedBy;   // Name of person who changed the net doc
    LPCSTR  pszLocalModifiedBy;     // Name of person who changed the local doc
    LPCSTR  pszNetworkModifiedOn;   // When the net doc was changed
    LPCSTR  pszLocalModifiedOn;     // Whent the local doc was changed
    HICON   hIKeepBoth;             // Icon
    HICON   hIKeepLocal;            //
    HICON   hIKeepNetwork;          //
    PFNRFCDCALLBACK pfnCallBack;    // Callback
    LPARAM  lCallerData;            // Place where the caller can keep some context data
} RFCDLGPARAMA;

int WINAPI SyncMgrResolveConflictW(HWND hWndParent, RFCDLGPARAMW *pdlgParam);
int WINAPI SyncMgrResolveConflictA(HWND hWndParent, RFCDLGPARAMA *pdlgParam);

#ifdef UNICODE
#define SyncMgrResolveConflict SyncMgrResolveConflictW
#define RFCDLGPARAM RFCDLGPARAMW
#else
#define SyncMgrResolveConflict SyncMgrResolveConflictA
#define RFCDLGPARAM RFCDLGPARAMA
#endif  
  
#endif  // _CONFRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\confres.cpp ===
/*----------------------------------------------------------------------------
/ Title;
/  dll.cpp
/  Copyright (C) Microsoft Corporation, 1999.
/
/ Authors;
/   Jude Kavalam (judej)
/
/ Notes;
/   Entry point for File Conflict Resolution Dialog
/----------------------------------------------------------------------------*/

#include "precomp.h"

#define CX_BIGICON                      48
#define CY_BIGICON                      48

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))

// Special flag to fix up the callback data when thunking
#define RFC_THUNK_DATA	0x80000000


/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
        Assert(lpa != NULL);
        Assert(lpw != NULL);
        // verify that no illegal character present
        // since lpw was allocated based on the size of lpa
        // don't worry about the number of chars
        lpw[0] = L'\0';
        MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
        return lpw;
}

LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
        Assert(lpw != NULL);
        Assert(lpa != NULL);
        // verify that no illegal character present
        // since lpa was allocated based on the size of lpw
        // don't worry about the number of chars
        lpa[0] = '\0';
        WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
        return lpa;
}


INT_PTR CALLBACK RFCDlgProc(HWND, UINT, WPARAM, LPARAM);

// The caller needs to send an hwnd and fill in the RFCDLGPARAM. Only the icons
// are optional

int WINAPI SyncMgrResolveConflict(HWND hWndParent, RFCDLGPARAM *pdlgParam)
{
    int nRet = 0;
    HICON hIKeepBoth = NULL, hIKeepLocal = NULL, hIKeepNetwork = NULL;

    if (!hWndParent || !pdlgParam)
        return -1;

    if (IsBadReadPtr(pdlgParam, sizeof(RFCDLGPARAM)))
        return -1;

    // If we don't have any of the params fail..
    if (!pdlgParam->pszFilename || !pdlgParam->pszLocation || !pdlgParam->pszNewName)
        return -1;

    // If we do not have any of the icons, load the defaults
    if (!pdlgParam->hIKeepBoth)
        pdlgParam->hIKeepBoth = hIKeepBoth =
                      (HICON)LoadImage(g_hmodThisDll, MAKEINTRESOURCE(IDI_KEEPBOTH),
                                IMAGE_ICON, CX_BIGICON, CY_BIGICON,
                                LR_LOADMAP3DCOLORS);
    if (!pdlgParam->hIKeepLocal)
        pdlgParam->hIKeepLocal = hIKeepLocal =
                      (HICON)LoadImage(g_hmodThisDll, MAKEINTRESOURCE(IDI_KEEPLOCAL),
                                IMAGE_ICON, CX_BIGICON, CY_BIGICON,
                                LR_LOADMAP3DCOLORS);
    if (!pdlgParam->hIKeepNetwork)
        pdlgParam->hIKeepNetwork = hIKeepNetwork =
                      (HICON)LoadImage(g_hmodThisDll, MAKEINTRESOURCE(IDI_KEEPNETWORK),
                                IMAGE_ICON, CX_BIGICON, CY_BIGICON,
                                LR_LOADMAP3DCOLORS);

    nRet = (int)DialogBoxParam(g_hmodThisDll, MAKEINTRESOURCE(IDD_RESFILECONFLICTS),
                               hWndParent, RFCDlgProc, (LPARAM)pdlgParam);

    // Destroy the icons that were created
    if (hIKeepBoth)
        DestroyIcon(hIKeepBoth);
    if (hIKeepLocal)
        DestroyIcon(hIKeepLocal);
    if (hIKeepNetwork)
        DestroyIcon(hIKeepNetwork);

    return nRet;
}

INT_PTR CALLBACK RFCDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RFCDLGPARAM * pParam = (RFCDLGPARAM*)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            SHFILEINFO sfi = {0};
            TCHAR szStr[INTERNET_MAX_URL_LENGTH + MAX_PATH];
            TCHAR szFmt[MAX_PATH];
            HICON hiExclaim;
            LPTSTR pszNetUser=NULL, pszNetDate=NULL, pszLocalUser=NULL, pszLocalDate=NULL;

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
            pParam = (RFCDLGPARAM*)lParam;

            if (!pParam)
            {
                EndDialog(hDlg, -1);
                return TRUE;
            }

            hiExclaim = LoadIcon(NULL, IDI_EXCLAMATION);
            SendDlgItemMessage(hDlg, IDI_EXCLAIMICON, STM_SETICON, (WPARAM)hiExclaim, 0L);

            // Get the icon from Shell
            wsprintf(szStr, TEXT("%ws%ws"), pParam->pszLocation, pParam->pszFilename);
            if (SHGetFileInfo(szStr, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_LARGEICON))
                SendDlgItemMessage(hDlg, IDI_DOCICON, STM_SETICON, (WPARAM)sfi.hIcon, 0L);

            // Set initial selection
            CheckRadioButton(hDlg, IDC_KEEPBOTH, IDC_KEEPNETWORK, IDC_KEEPBOTH);
            if (pParam->hIKeepBoth)
                SendDlgItemMessage(hDlg, IDB_BIGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)pParam->hIKeepBoth);

            // Format and set the strings
            LoadString(g_hmodThisDll, IDS_NAMEANDLOCATION, szFmt, ARRAYLEN(szFmt));
            wsprintf(szStr, szFmt, pParam->pszFilename, pParam->pszLocation);
            SetDlgItemText(hDlg,IDC_FILEANDLOCATION,szStr);
			
            if (pParam->pszNewName)
            {
                SetDlgItemText(hDlg,IDC_NEWFILENAME,pParam->pszNewName);
            }

            if (pParam->pszNetworkModifiedBy && pParam->pszNetworkModifiedOn &&
                 lstrlen(pParam->pszNetworkModifiedBy) && lstrlen(pParam->pszNetworkModifiedOn))
            {
                // we have by and on then use them both
                LoadString(g_hmodThisDll, IDS_NETWORKMODIFIED, szFmt, ARRAYLEN(szFmt));
                wsprintf(szStr, szFmt, pParam->pszNetworkModifiedBy, pParam->pszNetworkModifiedOn);
            }
            else if ((pParam->pszNetworkModifiedBy && lstrlen(pParam->pszNetworkModifiedBy)) &&
                     (!pParam->pszNetworkModifiedOn || !lstrlen(pParam->pszNetworkModifiedOn)))
            {
                // We have the name but no date
                TCHAR szTemp[MAX_PATH];
                LoadString(g_hmodThisDll, IDS_UNKNOWNDATE, szTemp, ARRAYLEN(szTemp));
                LoadString(g_hmodThisDll, IDS_NETWORKMODIFIED, szFmt, ARRAYLEN(szFmt));
                wsprintf(szStr, szFmt, pParam->pszNetworkModifiedBy, szTemp);
            }
            else if ((!pParam->pszNetworkModifiedBy || !lstrlen(pParam->pszNetworkModifiedBy)) &&
                     (pParam->pszNetworkModifiedOn && lstrlen(pParam->pszNetworkModifiedOn)))
            {
                // We have the date but no name
                LoadString(g_hmodThisDll, IDS_NETWORKMODIFIED_DATEONLY, szFmt, ARRAYLEN(szFmt));
                wsprintf(szStr, szFmt, pParam->pszNetworkModifiedOn);

            }
            else
                // we do not have on or by, use the unknown
                LoadString(g_hmodThisDll, IDS_NONETINFO, szStr, ARRAYLEN(szStr));

            SetDlgItemText(hDlg,IDC_NETWORKMODIFIED,szStr);

            if (pParam->pszLocalModifiedBy && pParam->pszLocalModifiedOn &&
                 lstrlen(pParam->pszLocalModifiedBy) && lstrlen(pParam->pszLocalModifiedOn))
            {
                // we have by and on then use them both
                LoadString(g_hmodThisDll, IDS_LOCALMODIFIED, szFmt, ARRAYLEN(szFmt));
                wsprintf(szStr, szFmt, pParam->pszLocalModifiedBy, pParam->pszLocalModifiedOn);
            }
            else if ((pParam->pszLocalModifiedBy && lstrlen(pParam->pszLocalModifiedBy)) &&
                     (!pParam->pszLocalModifiedOn || !lstrlen(pParam->pszLocalModifiedOn)))
            {
                // We have the name but no date
                TCHAR szTemp[MAX_PATH];
                LoadString(g_hmodThisDll, IDS_UNKNOWNDATE, szTemp, ARRAYLEN(szTemp));
                LoadString(g_hmodThisDll, IDS_LOCALMODIFIED, szFmt, ARRAYLEN(szFmt));
                wsprintf(szStr, szFmt, pParam->pszLocalModifiedBy, szTemp);
            }
            else if ((!pParam->pszLocalModifiedBy || !lstrlen(pParam->pszLocalModifiedBy)) &&
                     (pParam->pszLocalModifiedOn && lstrlen(pParam->pszLocalModifiedOn)))
            {
                // We have the date but no name
                LoadString(g_hmodThisDll, IDS_LOCALMODIFIED_DATEONLY, szFmt, ARRAYLEN(szFmt));
                wsprintf(szStr, szFmt, pParam->pszLocalModifiedOn);

            }
            else
                // we do not have on or by, use the unknown
                LoadString(g_hmodThisDll, IDS_NOLOCALINFO, szStr, ARRAYLEN(szStr));

            SetDlgItemText(hDlg,IDC_LOCALMODIFIED,szStr);

            // If there is no call back function, don't show the view buttons.
            if (!pParam->pfnCallBack)
            {
                HWND hWndButton = GetDlgItem(hDlg, IDC_VIEWLOCAL);
                ShowWindow(hWndButton, SW_HIDE);
                EnableWindow(hWndButton, FALSE);
                hWndButton = GetDlgItem(hDlg, IDC_VIEWNETWORK);
                ShowWindow(hWndButton, SW_HIDE);
                EnableWindow(hWndButton, FALSE);
            }

            // Hide the "Apply to all" checkbox if caller doesn't want it.
            if (!(RFCF_APPLY_ALL & pParam->dwFlags))
            {
                HWND hWndButton = GetDlgItem(hDlg, IDC_APPLY_ALL);
                ShowWindow(hWndButton, SW_HIDE);
                EnableWindow(hWndButton, FALSE);
            }

            break;
        }

        case WM_COMMAND:
        {
            int id = LOWORD(wParam);

            switch (id)
            {
                case IDCANCEL:
                    EndDialog(hDlg, RFC_CANCEL);
                    break;

                case IDOK:
                {
                    int nRet = RFC_KEEPBOTH;

                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_KEEPBOTH))
                        nRet = RFC_KEEPBOTH;
                    else if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_KEEPLOCAL))
                        nRet = RFC_KEEPLOCAL;
                    else if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_KEEPNETWORK))
                        nRet = RFC_KEEPNETWORK;

                    if (pParam && (RFCF_APPLY_ALL & pParam->dwFlags) &&
                        BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_APPLY_ALL))
                    {
                        nRet |= RFC_APPLY_TO_ALL;
                    }

                    EndDialog(hDlg, nRet);
                    break;
                }

                case IDC_KEEPBOTH:
                case IDC_KEEPLOCAL:
                case IDC_KEEPNETWORK:
                {
                    HICON hITemp;

                    if (!pParam)
                        break;

                    if (IDC_KEEPBOTH == id)
                        hITemp = pParam->hIKeepBoth;
                    else if (IDC_KEEPLOCAL == id)
                        hITemp = pParam->hIKeepLocal;
                    else
                        hITemp = pParam->hIKeepNetwork;

                    SendDlgItemMessage(hDlg, IDB_BIGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hITemp);
                    break;
                }

                case IDC_VIEWLOCAL:
                    if (pParam)
                        pParam->pfnCallBack(hDlg, RFCCM_VIEWLOCAL, 0, (pParam->dwFlags & RFC_THUNK_DATA) ? pParam->lCallerData : (LPARAM)pParam);
                    break;

                case IDC_VIEWNETWORK:
                    if (pParam)
                        pParam->pfnCallBack(hDlg, RFCCM_VIEWNETWORK, 0, (pParam->dwFlags & RFC_THUNK_DATA) ? pParam->lCallerData : (LPARAM)pParam);
                    break;

                default:
                    return FALSE;
            }
            break;
        }

        default:
            return FALSE;
    }
    return TRUE;
}

#ifdef _UNICODE
int WINAPI SyncMgrResolveConflictA(HWND hWndParent, RFCDLGPARAMA *pdlgParam)
{
    USES_CONVERSION;
    RFCDLGPARAMW dlgPW={0};

    dlgPW.dwFlags = pdlgParam->dwFlags | RFC_THUNK_DATA;
    dlgPW.hIKeepBoth = pdlgParam->hIKeepBoth;
    dlgPW.hIKeepLocal = pdlgParam->hIKeepLocal;
    dlgPW.hIKeepNetwork = pdlgParam->hIKeepNetwork;
    dlgPW.pfnCallBack = pdlgParam->pfnCallBack;
    dlgPW.lCallerData = (LPARAM)pdlgParam;

    dlgPW.pszFilename = A2CW(pdlgParam->pszFilename);
    dlgPW.pszLocation = A2CW(pdlgParam->pszLocation);
    dlgPW.pszNewName = A2CW(pdlgParam->pszNewName);
    dlgPW.pszNetworkModifiedBy = A2CW(pdlgParam->pszNetworkModifiedBy);
    dlgPW.pszNetworkModifiedOn = A2CW(pdlgParam->pszNetworkModifiedOn);
    dlgPW.pszLocalModifiedBy = A2CW(pdlgParam->pszLocalModifiedBy);
    dlgPW.pszLocalModifiedOn = A2CW(pdlgParam->pszLocalModifiedOn);

    return SyncMgrResolveConflictW(hWndParent, &dlgPW);
}
#else
int WINAPI SyncMgrResolveConflictW(HWND hWndParent, RFCDLGPARAMW *pdlgParam)
{
    USES_CONVERSION;
    RFCDLGPARAMA dlgPA={0};

    dlgPA.dwFlags = pdlgParam->dwFlags | RFC_THUNK_DATA;
    dlgPA.hIKeepBoth = pdlgParam->hIKeepBoth;
    dlgPA.hIKeepLocal = pdlgParam->hIKeepLocal;
    dlgPA.hIKeepNetwork = pdlgParam->hIKeepNetwork;
    dlgPA.pfnCallBack = pdlgParam->pfnCallBack;
    dlgPA.lCallerData = (LPARAM)pdlgParam;

    dlgPA.pszFilename = W2CA(pdlgParam->pszFilename);
    dlgPA.pszLocation = W2CA(pdlgParam->pszLocation);
    dlgPA.pszNewName = W2CA(pdlgParam->pszNewName);
    dlgPA.pszNetworkModifiedBy = W2CA(pdlgParam->pszNetworkModifiedBy);
    dlgPA.pszNetworkModifiedOn = W2CA(pdlgParam->pszNetworkModifiedOn);
    dlgPA.pszLocalModifiedBy = W2CA(pdlgParam->pszLocalModifiedBy);
    dlgPA.pszLocalModifiedOn = W2CA(pdlgParam->pszLocalModifiedOn);

    return SyncMgrResolveConflictA(hWndParent, &dlgPA);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\dllsz.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       dllsz.c
//
//  Contents:   SyncMgr dll string constants
//
//  History:    18-Feb-98   SusiA      Created.
//
//--------------------------------------------------------------------------

#include <windows.h>


const WCHAR SZ_REGSITRYMUTEXNAME[] =  TEXT("{6295DF2D-35EE-11d1-8707-00C04FD93327}RegistryMutex");
const WCHAR SZ_SCHEDULEMUTEXNAME[] =  TEXT("{6295DF2D-35EE-11d1-8707-00C04FD93327}ScheduleMutex");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\dll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Dll.h
//
//  Contents:   Main Dll api and Class Factory interface
//
//  Classes:    CClassFactory
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------
                                  
#ifndef _ONESTOPDLL_H
#define _ONESTOPDLL_H


class CClassFactory : public IClassFactory
{
protected:
	ULONG	m_cRef;

public:
	CClassFactory();
	~CClassFactory();

	//IUnknown members
	STDMETHODIMP		QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	//IClassFactory members
	STDMETHODIMP		CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
	STDMETHODIMP		LockServer(BOOL);

};
typedef CClassFactory *LPCClassFactory;

// todo: need helper functions for creating and releasing
// structure so each function doesn't have to call it.

#ifdef _UNUSED

class COneStopDllObject : public IServiceProvider
{
private:   
	ULONG m_cRef;
public:
	COneStopDllObject();
	~COneStopDllObject();

	//IUnknown members
	STDMETHODIMP		QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// IServiceProvider Methods
	STDMETHODIMP QueryService(REFGUID guidService,REFIID riid,void** ppv);
};
typedef COneStopDllObject *LPCOneStopDllObject;

#endif // _UNUSED

#endif // _ONESTOPDLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\dllsz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       dllsz.h
//
//  Contents:   SyncMgr dll string extern constants
//
//  History:    18-Feb-98   SusiA      Created.
//
//--------------------------------------------------------------------------

#ifndef _Dll_STRINGC_
#define  _Dll_STRINGC_

extern "C" { 

    // place dll specific strings here.

extern const WCHAR SZ_REGSITRYMUTEXNAME[];
extern const WCHAR SZ_SCHEDULEMUTEXNAME[];

};

#endif //  _Dll_STRINGC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\daily.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       daily.cxx
//
//  Contents:   Task wizard Onestop daily selection property page implementation.
//
//  Classes:    CSelectDailyPage
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

#include "precomp.h"

CSelectDailyPage *g_pDailyPage = NULL;
extern CSelectItemsPage *g_pSelectItemsPage;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardDailyDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//  HISTORY:    12-08-1997   SusiA		Created  
//
//--------------------------------------------------------------------------------
BOOL CALLBACK SchedWizardDailyDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
WORD wNotifyCode = HIWORD(wParam); // notification code
 
	switch (uMessage)
	{
		case WM_INITDIALOG:
			if (g_pDailyPage)
				g_pDailyPage->Initialize(hDlg);

            InitPage(hDlg,lParam);
            break;

        case WM_PAINT:
            WmPaint(hDlg, uMessage, wParam, lParam);
            break;

        case WM_PALETTECHANGED:
            WmPaletteChanged(hDlg, wParam);
            break;

        case WM_QUERYNEWPALETTE:
            return( WmQueryNewPalette(hDlg) );
            break;

        case WM_ACTIVATE:
            return( WmActivate(hDlg, wParam, lParam) );
            break;

		case WM_COMMAND:
			return g_pDailyPage->OnCommand(hDlg,
								LOWORD(wParam),  // item, control, or acce
								HIWORD(wParam)); // notification code
			break;

		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{

 				case PSN_KILLACTIVE:
	           		SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					return 1;
					break;

				case PSN_RESET:
					// reset to the original values
	           		SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

				case PSN_SETACTIVE:
	    			PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
					break;

                case PSN_WIZNEXT:
					break;

				default:
					return FALSE;

    	}
		break;

		default:
			return FALSE;
	}
	return TRUE;   
}
//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::OnCommand
//
//  Synopsis:   Handle the WM_COMMAND for the daily page
//
//  History:    12-08-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CSelectDailyPage::OnCommand(HWND hwnd, WORD wID, WORD wNotifyCode)
{
  switch (wNotifyCode)
  {
	case BN_CLICKED:
	
		switch (wID)
		{
		case daily_day_rb:
		case daily_weekday_rb:
		case daily_ndays_rb:
			m_idSelectedRadio = (USHORT) wID;
			EnableNDaysControls(wID == daily_ndays_rb);
			break;

		default:
			break;
		}
	break;

	case EN_UPDATE:
	{
		//
		// If the user just pasted non-numeric text or an illegal numeric
		// value, overwrite it and complain.
		//
		if (IsWindowEnabled(GetDlgItem(hwnd,daily_ndays_edit)))
		{
			INT iNewPos = GetDlgItemInt(hwnd, daily_ndays_edit, NULL, FALSE);

			if (iNewPos < NDAYS_MIN || iNewPos > NDAYS_MAX)
			{
				HWND hUD = GetDlgItem(hwnd,daily_ndays_ud);
				UpDown_SetPos(hUD, UpDown_GetPos(hUD));
				MessageBeep(MB_ICONASTERISK);
			}
		}
	}

	default:
		break;
    break;
  }
  return TRUE;

}
//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::EnableNDaysControls
//
//  Synopsis:   Enable or disable the 'run every n days' controls
//
//  History:    12-05-1997   SusiA   Created
//
//---------------------------------------------------------------------------

VOID CSelectDailyPage::EnableNDaysControls(BOOL fEnable)
{
    EnableWindow(GetDlgItem(m_hwnd,daily_ndays_ud), fEnable);
    EnableWindow(GetDlgItem(m_hwnd,daily_ndays_edit), fEnable);
    EnableWindow(GetDlgItem(m_hwnd,daily_ndays_lable), fEnable);
}
    
    
//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::CSelectDailyPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

CSelectDailyPage::CSelectDailyPage(
    HINSTANCE hinst,
	ISyncSchedule *pISyncSched,
    HPROPSHEETPAGE *phPSP)
{
	ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));

   	m_psp.dwSize = sizeof (PROPSHEETPAGE);
	m_psp.hInstance = hinst;
        m_psp.dwFlags = PSP_DEFAULT;
	m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDWIZ_DAILY);
	m_psp.pszIcon = NULL;
	m_psp.pfnDlgProc = (DLGPROC) SchedWizardDailyDlgProc;
	m_psp.lParam = 0;

	m_pISyncSched = pISyncSched;
	m_pISyncSched->AddRef();

	g_pDailyPage = this;
	
#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97
 
	m_idSelectedRadio = 0;
   *phPSP = CreatePropertySheetPage(&m_psp);

}

//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the welcome page and set the task name to a unique 
//				new onestop name
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CSelectDailyPage::Initialize(HWND hwnd)
{

   m_hwnd = hwnd;

   UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));
   DateTime_SetFormat(GetDlgItem(m_hwnd,starttime_dp), m_tszTimeFormat);

   m_idSelectedRadio = daily_day_rb;
   CheckDlgButton(m_hwnd, m_idSelectedRadio, BST_CHECKED);

   EnableNDaysControls(FALSE);
   UpDown_SetRange(GetDlgItem(m_hwnd,daily_ndays_ud), NDAYS_MIN, NDAYS_MAX);
   UpDown_SetPos(GetDlgItem(m_hwnd,daily_ndays_ud), 7);
   Edit_LimitText(GetDlgItem(m_hwnd,daily_ndays_edit), 3);
   return TRUE; 

}

//+--------------------------------------------------------------------------
//
//  Member:     CSelectDailyPage::FillInTrigger
//
//  Synopsis:   Fill in the fields of the trigger structure according to the
//              settings specified for this type of trigger
//
//  Arguments:  [pTrigger] - trigger struct to fill in
//
//  Modifies:   *[pTrigger]
//
//  History:    12-08-1997   SusiA	Stole from the TaskScheduler
//
//  Notes:      Precondition is that trigger's cbTriggerSize member is
//              initialized.
//
//---------------------------------------------------------------------------

BOOL CSelectDailyPage::SetITrigger()
{
	TASK_TRIGGER Trigger;
	ITaskTrigger *pITrigger;
	
	if (FAILED(m_pISyncSched->GetTrigger(&pITrigger)))
	{
		return FALSE;
	}
	
	ZeroMemory(&Trigger, sizeof(Trigger));
	Trigger.cbTriggerSize = sizeof(TASK_TRIGGER);

    switch (m_idSelectedRadio)
    {
		case daily_day_rb:
			Trigger.TriggerType = TASK_TIME_TRIGGER_DAILY;
			Trigger.Type.Daily.DaysInterval = 1;
			break;

		case daily_weekday_rb:
			Trigger.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
			Trigger.Type.Weekly.WeeksInterval = 1;
			Trigger.Type.Weekly.rgfDaysOfTheWeek = TASK_WEEKDAYS;
			break;

		case daily_ndays_rb:
			Trigger.TriggerType = TASK_TIME_TRIGGER_DAILY;
			Trigger.Type.Daily.DaysInterval =
				UpDown_GetPos(GetDlgItem(m_hwnd, daily_ndays_ud));
			break;

		default:
			break;
    }
    FillInStartDateTime(GetDlgItem(m_hwnd,startdate_dp), 
						GetDlgItem(m_hwnd,starttime_dp), &Trigger);
	
	if (ERROR_SUCCESS == pITrigger->SetTrigger(&Trigger))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\dllreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Reg.h
//
//  Contents:   Registration routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _CONESTOPREGISTER_
#define _CONESTOPREGISTER_

#include "rasui.h" // included so exe can inlude dll.reg.

#define GUID_SIZE 128
#define MAX_STRING_LENGTH 256

typedef
enum _tagSYNCTYPE
{
    SYNCTYPE_MANUAL    = 0x1,
    SYNCTYPE_AUTOSYNC  = 0x2,
    SYNCTYPE_IDLE      = 0x3,
    SYNCTYPE_SCHEDULED = 0x4,
    SYNCTYPE_PROGRESS  = 0x5
}   SYNCTYPE;


EXTERN_C void WINAPI  RunDllRegister(HWND hwnd,
                                HINSTANCE hAppInstance,
                                LPSTR pszCmdLine,
                                int nCmdShow);


#define UL_DEFAULTIDLEWAITMINUTES  15
#define UL_DEFAULTIDLERETRYMINUTES 60
#define UL_DELAYIDLESHUTDOWNTIME   2*1000 // time in milliseconds
#define UL_DEFAULTWAITMINUTES 15
#define UL_DEFAULTREPEATSYNCHRONIZATION 1
#define UL_DEFAULTFRUNONBATTERIES 0

typedef struct _CONNECTIONSETTINGS {
    TCHAR pszConnectionName[RAS_MaxEntryName + 1];  //The connection
    DWORD dwConnType;
        //      DWORD dwSyncFlags;
        // For optimization:  these are currently all BOOL,
        //the first three are used exclusively for autosync,
        //and dwMakeConnection is used exclusively for sched sync.
        //Consider using bitfields and/or a union to consolidate space.

    // AutoSync settings
    DWORD  dwLogon;             //Autosync at logon
    DWORD  dwLogoff;            //Autosync at logoff
    DWORD  dwPromptMeFirst;     //Prompt the user first before autosyncing

    // Schedule settings.
    DWORD  dwMakeConnection;    //Automatically try to establish the connection

    // Idle Settings
    DWORD  dwIdleEnabled; // Idle is enabled on this connection

    // Idle Settings that are really not per connection but read in for
    // convenience. These are currently never written.
    ULONG ulIdleWaitMinutes; // number of minutes to wait after idle to start idle processing.
    ULONG ulIdleRetryMinutes; // number of minutes for Idle before retry.
    ULONG ulDelayIdleShutDownTime; // time to delay shutdown of idle in milliseconds
    DWORD dwRepeatSynchronization; // indicates synchronization should be repeated
    DWORD dwRunOnBatteries; // indicates whether to run on batteries or not.
    DWORD  dwHidden;            //Hide the schedule from the user because this is a publishers sched.
    DWORD  dwReadOnly;          //Schedule info is readonly

} CONNECTIONSETTINGS;

typedef CONNECTIONSETTINGS *LPCONNECTIONSETTINGS;


STDAPI_(BOOL) AddRegNamedValue(HKEY hkey,LPTSTR pszKey,LPTSTR pszSubkey,LPTSTR pszValueName,LPTSTR pszValue);
STDAPI_(BOOL) RegLookupSettings(HKEY hKeyUser,
                       CLSID clsidHandler,
                       SYNCMGRITEMID ItemID,
                       const TCHAR *pszConnectionName,
                       DWORD *pdwCheckState);

STDAPI_(BOOL) RegWriteOutSettings(HKEY hKeyUser,
                         CLSID clsidHandler,
                         SYNCMGRITEMID ItemID,
                         const TCHAR *pszConnectionName,
                         DWORD dwCheckState);

STDAPI_(BOOL) RegGetSyncItemSettings(DWORD dwSyncType,
                                     CLSID clsidHandler,
                                     SYNCMGRITEMID ItemId,
                                     const TCHAR *pszConnectionName,
                                     DWORD *pdwCheckState,
                                     DWORD dwDefaultCheckState,
                                     TCHAR *pszSchedName);

STDAPI_(BOOL) RegSetSyncItemSettings(DWORD dwSyncType,
                                     CLSID clsidHandler,
                                     SYNCMGRITEMID ItemId,
                                     const TCHAR *pszConnectionName,
                                     DWORD dwCheckState,
                                     TCHAR *pszSchedName);

STDAPI_(BOOL) RegSetSyncHandlerSettings(DWORD syncType,
                            const TCHAR *pszConnectionName,
                            CLSID clsidHandler,
                            BOOL  fItemsChecked);

STDAPI_(BOOL) RegQueryLoadHandlerOnEvent(TCHAR *pszClsid,DWORD dwSyncFlags,
                                         TCHAR *pConnectionName);


//Progress dialog preference
STDAPI_(BOOL)  RegGetProgressDetailsState(REFCLSID clsidDlg,BOOL *pfPushPin, BOOL *pfExpanded);
STDAPI_(BOOL)  RegSetProgressDetailsState(REFCLSID clsidDlg,BOOL fPushPin, BOOL fExpanded);

//Autosync reg functions
STDAPI_(BOOL)  RegGetAutoSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings);
STDAPI_(BOOL)  RegSetAutoSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                      int iNumConnections,
                                      CRasUI *pRas,
                                      BOOL fCleanReg,
                                      BOOL fSetMachineState,
                                      BOOL fPerUser);

// Idle reg functions
STDAPI_(BOOL)  RegGetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings);
STDAPI_(BOOL)  RegSetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings, 
                                      int iNumConnections,
                                      CRasUI *pRas,
                                      BOOL fCleanReg,
                                      BOOL fPerUser);
STDAPI_(BOOL)  RegRegisterForIdleTrigger(BOOL fRegister,ULONG ulWaitMinutes,BOOL fRunOnBatteries);


// function for exporting settings for exe
STDAPI_(BOOL) RegGetSyncSettings(DWORD dwSyncType,LPCONNECTIONSETTINGS lpConnectionSettings);

//Scheduled Sync reg functions
STDAPI_(BOOL) RegSchedHandlerItemsChecked(TCHAR *pszHandlerName, 
                                 TCHAR *pszConnectionName,
                                 TCHAR *pszScheduleName);
STDAPI_(BOOL)  RegGetSchedSyncSettings( LPCONNECTIONSETTINGS lpConnectionSettings,TCHAR *pszSchedName);
STDAPI_(BOOL)  RegSetSchedSyncSettings( LPCONNECTIONSETTINGS lpConnectionSettings,TCHAR *pszSchedName);
STDAPI_(BOOL)  RegGetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
                                                                          LPTSTR ptstrFriendlyName);
STDAPI_(BOOL)  RegSetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
                                                                          LPCTSTR ptstrFriendlyName);
STDAPI_(BOOL)  RegGetSchedConnectionName(TCHAR *pszSchedName,
                                                                         TCHAR *pszConnectionName,
                                                                         DWORD cbConnectionName);
STDAPI_(BOOL) RegSetSIDForSchedule(TCHAR *pszSchedName);
STDAPI_(BOOL) RegGetSIDForSchedule(TCHAR *ptszTextualSidSched,
                                   DWORD *dwSizeSid, 
                                   TCHAR *pszSchedName);


STDAPI_(BOOL) RegRemoveScheduledTask(TCHAR *pszTaskName);
STDAPI_(BOOL) RemoveScheduledJobFile(TCHAR *pszTaskName);

STDAPI_(BOOL) RegRegisterForScheduledTasks(BOOL fScheduled);
STDAPI_(BOOL) RegUninstallSchedules();
STDAPI_(BOOL) RegFixRunKey();

STDAPI_(DWORD) RegDeleteKeyNT(HKEY hStartKey , LPCWSTR pKeyName);

// Manual settings
STDAPI_(BOOL) RegRemoveManualSyncSettings(TCHAR *pszConnectionName);


// Handler Registration Functions.
STDAPI_(BOOL) RegRegisterHandler(REFCLSID rclsidHandler,
                        WCHAR const *pwszDescription,
                        DWORD dwSyncMgrRegisterFlags,
                        BOOL *pfFirstRegistration);
STDAPI_(BOOL) RegRegRemoveHandler(REFCLSID rclsidHandler);
STDAPI_(BOOL) RegGetHandlerRegistrationInfo(REFCLSID rclsidHandler,LPDWORD pdwSyncMgrRegisterFlags);
STDAPI_(void) RegSetUserDefaults();
STDAPI_(void) RegSetAutoSyncDefaults(BOOL fLogon,BOOL fLogoff);
STDAPI_(void) RegSetIdleSyncDefaults(BOOL fIdle);

STDAPI RegSetUserAutoSyncDefaults(DWORD dwSyncMgrRegisterMask,
                                         DWORD dwSyncMgrRegisterFlags);
STDAPI RegSetUserIdleSyncDefaults(DWORD dwSyncMgrRegisterMask,
                                         DWORD dwSyncMgrRegisterFlags);
STDAPI RegGetUserRegisterFlags(LPDWORD pdwSyncMgrRegisterFlags);

STDAPI_(BOOL) RegWriteTimeStamp(HKEY hkey);
STDAPI_(BOOL) RegGetTimeStamp(HKEY hKey, FILETIME *pft);
STDAPI_(void) RegUpdateTopLevelKeys();

// common registry functions.


STDAPI_(HKEY) RegOpenUserKey(HKEY hkeyParent,REGSAM samDesired,BOOL fCreate,BOOL fCleanReg);
STDAPI_(HKEY) RegGetSyncTypeKey(DWORD dwSyncType,REGSAM samDesired,BOOL fCreate);
STDAPI_(HKEY) RegGetCurrentUserKey(DWORD dwSyncType,REGSAM samDesired,BOOL fCreate);

STDAPI_(HKEY) RegGetHandlerTopLevelKey(REGSAM samDesired);
STDAPI_(HKEY) RegGetHandlerKey(HKEY hkeyParent,LPCWSTR pszHandlerClsid,REGSAM samDesired,BOOL fCreate);

// EventService/Winlogon Registration

#if 0
// define regkeys for WinLogon Registration
// WinLogon is registered undler HKLM
#define WINLOGON_NOTIFY "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\notify"
#define WINLOGON_SYNCMGRDLLNAME "syncmgrp.dll"

#define WINLOGON_LOGONVALUE     TEXT("StartShell")
#define WINLOGON_LOGOFFVALUE    TEXT("Logoff")
#define WINLOGON_DLLNAMEVALUE   TEXT("DllName")

#define WINLOGON_LOGONEXPORT    TEXT("WinLogonEvent")
#define WINLOGON_LOGOFFEXPORT   TEXT("WinLogoffEvent")

#define WINLOGON_NOTIFYKEYNAME TEXT(WINLOGON_NOTIFY)
#define WINLOGON_SYNCMGRNOTIFYKEYNAME TEXT(WINLOGON_SYNCMGRDLLNAME)
#define WINLOGON_SYNCMGRKEYFULLPATH TEXT(WINLOGON_NOTIFY##"\\"##WINLOGON_SYNCMGRDLLNAME)

#endif 

STDAPI  RegRegisterForEvents(BOOL fUninstall);

#endif // _CONESTOPREGISTER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\errdlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       errdlg.cxx
//
//  Contents:   Error dialog function
//
//
//  History:    14-Jul-1998    SitaramR      Created from util.cxx
//
//---------------------------------------------------------------------------

#include "precomp.h"

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.

//+---------------------------------------------------------------------------
//
//      Security functions
//
//      only on NT
//
//----------------------------------------------------------------------------

void
SchedUIErrorDialog(
    HWND    hwnd,
    int     idsErrMsg)
{
    TCHAR szTitleBuf[MAX_PATH +1 ];
        TCHAR szErrorBuf[MAX_PATH + 1];
    //
    // Load the error message string.
    //
    LoadString(g_hmodThisDll, IDS_SYNCHMGR_NAME, szTitleBuf, ARRAYLEN(szTitleBuf));
    LoadString(g_hmodThisDll, idsErrMsg, szErrorBuf, ARRAYLEN(szErrorBuf));

    MessageBox(hwnd, szErrorBuf, szTitleBuf,
               MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\finish.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       finish.cxx
//
//  Contents:   Task wizard Onestop finish property page implementation.
//
//  Classes:    CFinishPage
//
//  History:    11-21-1998   SusiA   
//
//---------------------------------------------------------------------------

#include "precomp.h"

CFinishPage *g_pFinishPage = NULL;

extern CSelectItemsPage *g_pSelectItemsPage;
extern OSVERSIONINFOA g_OSVersionInfo;
//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardFinishDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------
BOOL CALLBACK SchedWizardFinishDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
WORD wNotifyCode = HIWORD(wParam); // notification code
 
	switch (uMessage)
	{
		case WM_INITDIALOG:
			if (g_pFinishPage)
				g_pFinishPage->Initialize(hDlg);

            InitPage(hDlg,lParam);
            break;

        case WM_PAINT:
            WmPaint(hDlg, uMessage, wParam, lParam);
            break;

        case WM_PALETTECHANGED:
            WmPaletteChanged(hDlg, wParam);
            break;

        case WM_QUERYNEWPALETTE:
            return( WmQueryNewPalette(hDlg) );
            break;

        case WM_ACTIVATE:
            return( WmActivate(hDlg, wParam, lParam) );
            break;

		case WM_COMMAND:
			break;

		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{

  				case PSN_KILLACTIVE:
	           		SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

				case PSN_RESET:
					// reset to the original values
	           		SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

 				case PSN_SETACTIVE:
				    g_pFinishPage->OnPSNSetActive(lParam);
					break;

                case PSN_WIZFINISH:
		{
		    if (g_pSelectItemsPage)
		    {
			if (S_OK != g_pSelectItemsPage->CommitChanges())
			{
			    SchedUIErrorDialog(hDlg, IERR_SCHEDULE_SAVE_FAIL);
			}
		    }				
		}
		break;
		default:
		    return FALSE;

    	}
	break;
	default:
    	    return FALSE;
    }
    return TRUE;   
}
//+--------------------------------------------------------------------------
//
//  Member:     CFinishPage::CFinishPage
//
//  Synopsis:   Initialize the finish page
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1998   SusiA   
//
//---------------------------------------------------------------------------

CFinishPage::CFinishPage(
    HINSTANCE hinst,
	ISyncSchedule *pISyncSched,
    HPROPSHEETPAGE *phPSP)
{
	ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));

   	m_psp.dwSize = sizeof (PROPSHEETPAGE);
	m_psp.hInstance = hinst;
        m_psp.dwFlags = PSP_DEFAULT;
	m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDWIZ_FINISH);
	m_psp.pszIcon = NULL;
	m_psp.pfnDlgProc = (DLGPROC) SchedWizardFinishDlgProc;
	m_psp.lParam = 0;

	m_pISyncSched = pISyncSched;
	m_pISyncSched->AddRef();
	
	g_pFinishPage = this;
	
#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

   *phPSP = CreatePropertySheetPage(&m_psp);

}

//+--------------------------------------------------------------------------
//
//  Member:     CFinishPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the welcome page and set the task name to a unique 
//				new onestop name
//
//  History:    11-21-1998   SusiA   
//
//---------------------------------------------------------------------------
BOOL CFinishPage::Initialize(HWND hwnd)
{
	m_hwnd = hwnd;
   
        HWND hwndName = GetDlgItem(hwnd,IDC_SCHED_NAME);

        if ((VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId
           && g_OSVersionInfo.dwMajorVersion >= 5) )
	{
            LONG_PTR dwStyle = GetWindowLongPtr(hwndName, GWL_STYLE);

	    SetWindowLongPtr(hwndName, GWL_STYLE, dwStyle | SS_ENDELLIPSIS);
	}

        return TRUE;
}

//+--------------------------------------------------------------------------
//
//  Member:     CFinishPage::OnPSNSetActive(LPARAM lParam)
//
//  Synopsis:   handle the set active notification
//
//  History:    12-08-1998   SusiA
//
//---------------------------------------------------------------------------

BOOL CFinishPage::OnPSNSetActive(LPARAM lParam)
{
	HRESULT hr;

	LPWSTR pwszTrigger = NULL;
#ifndef _UNICODE
	TCHAR ptszSchedName[MAX_PATH + 1];
#endif // _UNICODE
	WCHAR pwszSchedName[MAX_PATH + 1];
	DWORD dwSize = MAX_PATH;

	PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK | PSWIZB_FINISH);

	//Schedule Name
	if (FAILED(hr = m_pISyncSched->GetScheduleName(&dwSize, pwszSchedName)))
	{
		return FALSE;
	}

#ifndef _UNICODE
	ConvertString(ptszSchedName,pwszSchedName, MAX_PATH);
	SetStaticString(GetDlgItem(m_hwnd,IDC_SCHED_NAME), ptszSchedName);
#else
	SetStaticString(GetDlgItem(m_hwnd,IDC_SCHED_NAME), pwszSchedName);
#endif // _UNICODE
    
	ITaskTrigger *pTrigger;
	
	if (FAILED(hr = m_pISyncSched->GetTrigger(&pTrigger)))
	{
		return FALSE;
	}

	if (FAILED(hr = pTrigger ->GetTriggerString(&pwszTrigger)))
    {
		return FALSE;
    }

#if defined(UNICODE)
        Static_SetText(GetDlgItem(m_hwnd,IDC_ScheduleTime), pwszTrigger);
#else
        TCHAR tszTrigger[MAX_PATH];
        ConvertString(tszTrigger, pwszTrigger, ARRAYLEN(tszTrigger));
        Static_SetText(GetDlgItem(m_hwnd,IDC_ScheduleTime), tszTrigger);
#endif // defined(UNICODE)

	return TRUE;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\hndlrq.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Hndlrq.cpp
//
//  Contents:   Implements class for keeping track of handlers
//		and the UI associated with them
//
//  Classes:    CHndlrQueue
//
//  History:    05-Nov-97   rogerg      Created.
//				17-Nov-97	susia		Moved to onestop dll for settings.
//
//--------------------------------------------------------------------------

#include "precomp.h"
extern DWORD g_dwPlatformId;

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::CHndlrQueue(QUEUETYPE QueueType)
//
//  PURPOSE:  CHndlrQueue constructor
//
//	COMMENTS: Implemented on main thread.
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------
CHndlrQueue::CHndlrQueue(QUEUETYPE QueueType)
{
    m_cRef = 1;
    m_pFirstHandler = NULL; 
    m_wHandlerCount = 0; 
    m_QueueType = QueueType;
    m_ConnectionList = NULL;
    m_ConnectionCount = 0;
    m_fItemsMissing = FALSE;
    InitializeCriticalSection(&m_CriticalSection);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::AddRef()
//
//  PURPOSE:  AddRef
//
//  History:  30-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHndlrQueue::AddRef()
{
    TRACE("CHndlrQueue::AddRef()\r\n");
    return ++m_cRef;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::Release()
//
//  PURPOSE:  Release
//
//  History:  30-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHndlrQueue::Release()
{
    TRACE("CHndlrQueue::Release()\r\n");
    if (--m_cRef)
        return m_cRef;

	FreeAllHandlers();
    delete this;
    return 0L;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::~CHndlrQueue()
//
//  PURPOSE:  CHndlrQueue destructor
//
//	COMMENTS: Implemented on main thread.
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------
 CHndlrQueue::~CHndlrQueue()
{
    Assert(NULL == m_pFirstHandler); // all items should be freed at this point.
    DeleteCriticalSection(&m_CriticalSection);
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::AddHandler(REFCLSID clsidHandler, WORD *wHandlerId)
//
//  PURPOSE:  Add a handler to the queue  
//
//	COMMENTS: 
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::AddHandler(REFCLSID clsidHandler, WORD *wHandlerId)
{
HRESULT hr = E_OUTOFMEMORY;
LPHANDLERINFO pnewHandlerInfo;
LPHANDLERINFO pCurHandlerInfo = NULL;
    
    // first see if we already have this handler in the queue.
    // find first handler that matches the request CLSID
    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            return S_FALSE;
        }
        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    //didn't find the handler in the queue, add it now.
    pnewHandlerInfo = (LPHANDLERINFO) ALLOC(sizeof(HANDLERINFO));

    if (pnewHandlerInfo)
    {
		// initialize
		memset(pnewHandlerInfo,0,sizeof(HANDLERINFO));
		pnewHandlerInfo->HandlerState = HANDLERSTATE_CREATE;
		pnewHandlerInfo->wHandlerId = 	++m_wHandlerCount;

		// add to end of list and set wHandlerId. End of list since in choice dialog want
		// first writer wins so don't have to continue searches when setting item state.
		if (NULL == m_pFirstHandler)
		{
			m_pFirstHandler = pnewHandlerInfo;
		}
		else
		{
			pCurHandlerInfo = m_pFirstHandler;

			while (pCurHandlerInfo->pNextHandler)
			{
				pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
			}
			pCurHandlerInfo->pNextHandler = pnewHandlerInfo;
		}

		*wHandlerId = pnewHandlerInfo->wHandlerId;

		hr = NOERROR;
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::RemoveHandler(WORD wHandlerId)
//
//  PURPOSE:  Release a handler from the queue  
//
//	COMMENTS: 
//
//  History:  09-23-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::RemoveHandler(WORD wHandlerId)
{
HRESULT hr = NOERROR;
LPHANDLERINFO pPrevHandlerInfo;
LPHANDLERINFO pCurHandlerInfo;
LPITEMLIST pCurItem = NULL;
LPITEMLIST pNextItem = NULL;

    pCurHandlerInfo = pPrevHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && (pCurHandlerInfo->wHandlerId != wHandlerId))
	{
		pPrevHandlerInfo = pCurHandlerInfo;
		pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
	}	

	if (pCurHandlerInfo)
    {
		//Update the first node if necessary
		if (pCurHandlerInfo == m_pFirstHandler)
		{
			m_pFirstHandler = m_pFirstHandler->pNextHandler;
		}
		//Fix up linked list
		pPrevHandlerInfo->pNextHandler = pCurHandlerInfo->pNextHandler;


		//Free the handler items if there are any
		pCurItem = pCurHandlerInfo->pFirstItem;
		while (pCurItem)
		{	
			FREE(pCurItem->pItemCheckState);
			pNextItem = pCurItem->pnextItem;
			FREE(pCurItem);
			pCurItem = pNextItem;
		}

		//Release the handler
		if (pCurHandlerInfo->pSyncMgrHandler)
		{
			pCurHandlerInfo->pSyncMgrHandler->Release();
		}

		FREE(pCurHandlerInfo);
		

	}
	else
	{  
		return E_UNEXPECTED;
	}

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FreeAllHandlers(void)
//
//  PURPOSE:  loops through all the Handlers and frees them
//
//	COMMENTS: 
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::FreeAllHandlers(void)
{
HANDLERINFO HandlerInfoStart;
LPHANDLERINFO pPrevHandlerInfo = &HandlerInfoStart;
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
LPITEMLIST pNextItem = NULL;

    if (m_ConnectionList)
    {
        FREE(m_ConnectionList);
        m_ConnectionList = NULL;
    }
    pPrevHandlerInfo->pNextHandler = m_pFirstHandler;
	
    while (pPrevHandlerInfo->pNextHandler)
    {
		pCurHandlerInfo = pPrevHandlerInfo->pNextHandler;

		pCurItem = pCurHandlerInfo->pFirstItem;
		while (pCurItem)
		{	
			FREE(pCurItem->pItemCheckState);
			pNextItem = pCurItem->pnextItem;
			FREE(pCurItem);
			pCurItem = pNextItem;
		}

		pPrevHandlerInfo->pNextHandler = pCurHandlerInfo->pNextHandler;
		if (pCurHandlerInfo->pSyncMgrHandler)
		{
			pCurHandlerInfo->pSyncMgrHandler->Release();
		}
		FREE(pCurHandlerInfo);
    }

    // update the pointer to the first handler item
    m_pFirstHandler = HandlerInfoStart.pNextHandler;
    Assert(NULL == m_pFirstHandler); // should always have released everything.

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetHandlerInfo, public
//
//  Synopsis:   Gets Data associated with the HandlerID and ItemID
//
//  Arguments:  [wHandlerId] - Id Of Handler the Item belongs too
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetHandlerInfo(REFCLSID clsidHandler,
                                         LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
HRESULT hr = S_FALSE;
LPHANDLERINFO pCurHandlerInfo = NULL;
    // find first handler that matches the request CLSID
    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            *pSyncMgrHandlerInfo = pCurHandlerInfo->SyncMgrHandlerInfo;
            hr = NOERROR;
            break;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:CHndlrQueue::GetSyncItemDataOnConnection(int iConnectionIndex,	
//							WORD wHandlerId,
//							WORD wItemID,
//							CLSID *pclsidHandler,
//							SYNCMGRITEM* offlineItem,
//							ITEMCHECKSTATE *pItemCheckState,	
//							BOOL fSchedSync,
//							BOOL fClear)
//
//  PURPOSE:  Get the item data per connection  
//
//	COMMENTS: Ras implementation is based on names.  Switch to GUIDs for Connection
//				objects
//
//  History:  01-01-98       susia        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetSyncItemDataOnConnection(
						    int iConnectionIndex,	
						    WORD wHandlerId, WORD wItemID,
						    CLSID *pclsidHandler,
						    SYNCMGRITEM* offlineItem,
						    ITEMCHECKSTATE   *pItemCheckState,
						    BOOL fSchedSync,
						    BOOL fClear)
{ 
BOOL fFoundMatch = FALSE;
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
		// only valid if Hanlder is in the PrepareForSync state.
		if (wHandlerId == pCurHandlerInfo->wHandlerId) // see if CLSID matches
		{
			// see if handler info has a matching item
			pCurItem = pCurHandlerInfo->pFirstItem;

			while (pCurItem)
			{
				if (wItemID == pCurItem->wItemId)
				{
					fFoundMatch = TRUE;
					break;
				}
				pCurItem = pCurItem->pnextItem;
			}
		}
		if (!fFoundMatch)
			pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    if (fFoundMatch)
    {
		if (pclsidHandler)
		{
			*pclsidHandler = pCurHandlerInfo->clsidHandler;
		}
		if (offlineItem)
		{
			*offlineItem = pCurItem->offlineItem;
		}

		if (pItemCheckState)
		{
			if (fSchedSync)
			{
                            Assert(0 == iConnectionIndex);

				//if only holding on connection's settings at a time
				if (fClear)
				{
					pCurItem->pItemCheckState[iConnectionIndex].dwSchedule = SYNCMGRITEMSTATE_UNCHECKED;
				}
			}
			else //AutoSync
			{
				 Assert((iConnectionIndex>=0) && (iConnectionIndex < m_ConnectionCount))
			}

                     *pItemCheckState = pCurItem->pItemCheckState[iConnectionIndex];
		}
    }

    return fFoundMatch ? NOERROR : S_FALSE;
}


//--------------------------------------------------------------------------------
//
//  STDMETHODIMP CHndlrQueue::GetItemIcon(WORD wHandlerId, WORD wItemID, HICON *phIcon)
//
//  PURPOSE:  Get the item icon 
//
//  History:  03-13-98       susia        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemIcon(WORD wHandlerId, 
									  WORD wItemID,
									  HICON *phIcon)
{ 
	BOOL fFoundMatch = FALSE;
	LPHANDLERINFO pCurHandlerInfo = NULL;
	LPITEMLIST pCurItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
		if (wHandlerId == pCurHandlerInfo->wHandlerId) // see if CLSID matches
		{
			// see if handler info has a matching item
			pCurItem = pCurHandlerInfo->pFirstItem;

			while (pCurItem)
			{
				if (wItemID == pCurItem->wItemId)
				{
					fFoundMatch = TRUE;
					break;
				}
				pCurItem = pCurItem->pnextItem;
			}
		}
		if (!fFoundMatch)
			pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    if (fFoundMatch)
    {
		if (phIcon)
		{
			*phIcon = pCurItem->offlineItem.hIcon;
		}
    }

    return fFoundMatch ? NOERROR : S_FALSE;
}

//--------------------------------------------------------------------------------
//
//  STDMETHODIMP CHndlrQueue::GetItemName(WORD wHandlerId, WORD wItemID, WCHAR *pwszName)
//
//  PURPOSE:  Get the item Name 
//
//  History:  03-13-98       susia        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemName(WORD wHandlerId, 
									  WORD wItemID,
									  WCHAR *pwszName)
{ 
	BOOL fFoundMatch = FALSE;
	LPHANDLERINFO pCurHandlerInfo = NULL;
	LPITEMLIST pCurItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
		if (wHandlerId == pCurHandlerInfo->wHandlerId) // see if CLSID matches
		{
			// see if handler info has a matching item
			pCurItem = pCurHandlerInfo->pFirstItem;

			while (pCurItem)
			{
				if (wItemID == pCurItem->wItemId)
				{
					fFoundMatch = TRUE;
					break;
				}
				pCurItem = pCurItem->pnextItem;
			}
		}
		if (!fFoundMatch)
			pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    if (fFoundMatch)
    {
		if (pwszName)
		{
			lstrcpy(pwszName, pCurItem->offlineItem.wszItemName);
		}
    }

    return fFoundMatch ? NOERROR : S_FALSE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FindFirstHandlerInState(HANDLERSTATE hndlrState,WORD *wHandlerID)
//
//  PURPOSE: finds first handler it comes across in the state 
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::FindFirstHandlerInState(HANDLERSTATE hndlrState,WORD *wHandlerID)
{
    return FindNextHandlerInState(0,hndlrState,wHandlerID);
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FindNextHandlerInState(WORD wLastHandlerID,
//										HANDLERSTATE hndlrState,WORD *wHandlerID)
//
//  PURPOSE: finds next handler after LasthandlerID in the queue that matches 
//			 the requested state.
//
//	COMMENTS: passing in 0 for the LasthandlerID is the same as calling 
//				FindFirstHandlerInState 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::FindNextHandlerInState(WORD wLastHandlerID,HANDLERSTATE hndlrState,WORD *wHandlerID)
{
HRESULT hr = S_FALSE; 
LPHANDLERINFO pCurHandler;

    *wHandlerID = 0; 

    pCurHandler = m_pFirstHandler;

    if (0 != wLastHandlerID)
    {
		// loop foward until find the last handlerID we checked or hit the end
		while (pCurHandler)
		{
			if (wLastHandlerID == pCurHandler->wHandlerId)
			{
				break;
			}
			pCurHandler = pCurHandler->pNextHandler;
		}
		if (NULL == pCurHandler)
			return S_FALSE;

		pCurHandler = pCurHandler->pNextHandler; // increment to next handler.
    }

    while (pCurHandler)
    {
		if (hndlrState == pCurHandler->HandlerState)
		{
			*wHandlerID = pCurHandler->wHandlerId;
			hr = S_OK;
			break;
		}
		pCurHandler = pCurHandler->pNextHandler;
    }
    return hr;
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FindFirstItemOnConnection
//							(TCHAR *pszConnectionName, 
//							 CLSID *pclsidHandler,
//							 SYNCMGRITEMID* OfflineItemID,
//							 WORD *wHandlerId,
//							 WORD *wItemID)
//
//  PURPOSE: find first ListView Item that can sync over the specified 
//			 connection and return its clsid and ItemID
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::FindFirstItemOnConnection
							(TCHAR *pszConnectionName, 
							 CLSID *pclsidHandler,
							 SYNCMGRITEMID* OfflineItemID,
							 WORD *pwHandlerId,
							 WORD *pwItemID)
{
    DWORD dwCheckState;


    return FindNextItemOnConnection
				(pszConnectionName,0,0,pclsidHandler,
				 OfflineItemID, pwHandlerId, pwItemID, 
				 TRUE, &dwCheckState);
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::FindNextItemOnConnection
//						    (TCHAR *pszConnectionName,
//							 WORD wLastHandlerId,
//							 WORD wLastItemID,
//							 CLSID *pclsidHandler,
//							 SYNCMGRITEMID* OfflineItemID,
//							 WORD *pwHandlerId,
//							 WORD *pwItemID,
//							 BOOL fAllHandlers,
//							 DWORD *pdwCheckState)
//
//
//
//  PURPOSE:  starts on the next item after the specified Handler and ItemID
//			  setting the last HandlerID to 0 is the same as calling 
//			  FindFirstItemOnConnection
//
//	COMMENTS:  For now, no Handler can specifiy that it can or cannot sync over a 
//			   connection, so assume it can, and ignore the connection.
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindNextItemOnConnection
						    (TCHAR *pszConnectionName,
							 WORD wLastHandlerId,
							 WORD wLastItemID,
							 CLSID *pclsidHandler,
							 SYNCMGRITEMID* OfflineItemID,
							 WORD *pwHandlerId,
							 WORD *pwItemID,
							 BOOL fAllHandlers,
							 DWORD *pdwCheckState)


{
	BOOL fFoundMatch = FALSE;
	LPHANDLERINFO pCurHandlerInfo = NULL;
	LPITEMLIST pCurItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;
	
	if (!pCurHandlerInfo)
	{
		return S_FALSE;
	}

    if (0 != wLastHandlerId)
    {
		// loop until find the specified handler or hit end of list.
		while(pCurHandlerInfo && wLastHandlerId != pCurHandlerInfo->wHandlerId)
			pCurHandlerInfo = pCurHandlerInfo->pNextHandler;

		if (NULL == pCurHandlerInfo) // reached end of list without finding the Handler
		{
			Assert(0); // user must have passed an invalid start HandlerID.
			return S_FALSE;
		}
	}
	
	// loop until find item or end of item list
	pCurItem = pCurHandlerInfo->pFirstItem;
	
	if (0 != wLastItemID)
    {
		while (pCurItem && pCurItem->wItemId != wLastItemID)
		{
			pCurItem = pCurItem->pnextItem;
		}
		if (NULL == pCurItem) // reached end of item list without finding the specified item
		{
			Assert(0); // user must have passed an invalid start ItemID.
			return S_FALSE;
		}
	
		// now we found the Handler and item. loop through remaining items for this handler and
		// see if there is a match
		pCurItem = pCurItem->pnextItem;
	}
	//Found the item on this handler
	if (pCurItem)
	{
		fFoundMatch = TRUE;
	}
	
	//If we are to move beyond this handler, do so now, else we are done
	if (!fFoundMatch && fAllHandlers)
	{
		pCurHandlerInfo = pCurHandlerInfo->pNextHandler; // increment to next handler if no match
	}

    if ((FALSE == fFoundMatch) && fAllHandlers)
    {
		while (pCurHandlerInfo && !fFoundMatch)
		{
			// see if handler info has a matching item
			pCurItem = pCurHandlerInfo->pFirstItem;

			if (pCurItem)
				fFoundMatch = TRUE;
			
			if (!fFoundMatch)
				pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
		}
    }

    if (fFoundMatch)
    {
		*pclsidHandler = pCurHandlerInfo->clsidHandler;
		*OfflineItemID = pCurItem->offlineItem.ItemID;
		*pwHandlerId = pCurHandlerInfo->wHandlerId;
		*pwItemID = pCurItem->wItemId;
		*pdwCheckState = pCurItem->pItemCheckState[0].dwSchedule;
    }

    return fFoundMatch ? NOERROR : S_FALSE;
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::GetHandlerIDFromClsid
//							(REFCLSID clsidHandlerIn,
//							 WORD *pwHandlerId)
//
//  PURPOSE: get the HnadlerID from the CLSID
//
//	COMMENTS: if the Handler is GUID_NULL enumerate all
//
//  HISTORY:  03-09-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::GetHandlerIDFromClsid
							(REFCLSID clsidHandlerIn,
							 WORD *pwHandlerId)
{
	LPHANDLERINFO pCurHandlerInfo = m_pFirstHandler;
	
	Assert(pwHandlerId);

	if (clsidHandlerIn == GUID_NULL) 
	{
		*pwHandlerId = 0;
		return S_OK;

	}
	while (pCurHandlerInfo && (clsidHandlerIn != pCurHandlerInfo->clsidHandler))
	{		
			pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
	}
	if (NULL == pCurHandlerInfo) // reached end of list without finding the Handler
	{
		*pwHandlerId = 0;
		Assert(0); // user must have passed an invalid start HandlerID.
		return S_FALSE;
	}

	*pwHandlerId = pCurHandlerInfo->wHandlerId;
	
	return S_OK;

	
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::SetItemListViewID(CLSID clsidHandler,
//		SYNCMGRITEMID OfflineItemID,INT iItem) 												
//
//  PURPOSE:   assigns all items that match the handler clsid and 
//				ItemID this listView Value.
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::SetItemListViewID(CLSID clsidHandler,
					  SYNCMGRITEMID OfflineItemID,INT iItem) 
{ 
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
	if (clsidHandler == pCurHandlerInfo->clsidHandler)
	{

	    pCurItem = pCurHandlerInfo->pFirstItem;

	    while (pCurItem)
	    {
		if (OfflineItemID == pCurItem->offlineItem.ItemID)
		{
		    // This can be called at anytime after prepareforSync if a duplicate
		    // is added later to the choice or progress bar.
		    // found a match
		    pCurItem->iItem = iItem;
		}

		pCurItem = pCurItem->pnextItem;
	    }
	}

	pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    return NOERROR;

} 

//--------------------------------------------------------------------------------
//
//  FUNCTION: DWORD  CHndlrQueue::GetCheck(WORD wParam, INT iItem)
//
//  PURPOSE:   Return the check state for the logon, logoff and 
//			   prompt me first check boxes on the connection number iItem	 
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

DWORD  CHndlrQueue::GetCheck(WORD wParam, INT iItem)
{
    // if no connection list all items are unchecked
    if (!m_ConnectionList)
        return 0;

    switch (wParam)
    {
	    case IDC_AUTOLOGON:	
		    return m_ConnectionList[iItem].dwLogon;
	    break;
	    case IDC_AUTOLOGOFF:
		    return m_ConnectionList[iItem].dwLogoff;
	    break;
	    case IDC_AUTOPROMPT_ME_FIRST:
		    return m_ConnectionList[iItem].dwPromptMeFirst;
	    break;
	    case IDC_AUTOREADONLY:
		    return m_ConnectionList->dwReadOnly;
	    break;
	    case IDC_AUTOHIDDEN:
		    return m_ConnectionList->dwHidden;
	    break;
	    case IDC_AUTOCONNECT:
		    return m_ConnectionList->dwMakeConnection;
	    break;
     case IDC_IDLECHECKBOX:
        return m_ConnectionList[iItem].dwIdleEnabled; 
	    
	     default:
        AssertSz(0,"Unkown SetConnectionCheckBox");
		    return 0;
    }

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: DWORD  CHndlrQueue::SetConnectionCheck(WORD wParam, DWORD dwState, 
//													INT iConnectionItem)
//
//  PURPOSE:   Set the check state for the logon, logoff and 
//			   prompt me first check boxes on the connection number iConnectionItem	 
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::SetConnectionCheck(WORD wParam, DWORD dwState, INT iConnectionItem)
{

    // if no connection list then just return
    if (!m_ConnectionList)
        return E_OUTOFMEMORY;

    switch (wParam)
    {
	case IDC_AUTOLOGON:	
	     m_ConnectionList[iConnectionItem].dwLogon = dwState;
	    break;
	case IDC_AUTOLOGOFF:
	    m_ConnectionList[iConnectionItem].dwLogoff = dwState;
	    break;
	case IDC_AUTOPROMPT_ME_FIRST:
	    m_ConnectionList[iConnectionItem].dwPromptMeFirst = dwState;
	    break;
        case IDC_IDLECHECKBOX:
             m_ConnectionList[iConnectionItem].dwIdleEnabled = dwState;
            break; 
    // these two sare for schedule
	case IDC_AUTOHIDDEN:
	    m_ConnectionList->dwHidden = dwState;
	    break;
	case IDC_AUTOREADONLY:
	    m_ConnectionList->dwReadOnly = dwState;
	    break;
	case IDC_AUTOCONNECT:
	     m_ConnectionList->dwMakeConnection = dwState;
	    break;
	default:
            AssertSz(0,"Unkown SetConnectionCheckBox");
	    return E_UNEXPECTED;
    }

    return ERROR_SUCCESS;
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::SetSyncCheckStateFromListViewItem(
//											DWORD dwSyncType,
//											INT iItem,
//											BOOL fChecked,
//											INT iConnectionItem) 
//
//
//  PURPOSE: finds item with this listview ID and sets it appropriately.  
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::SetSyncCheckStateFromListViewItem(SYNCTYPE SyncType,
                                                INT iItem,
						BOOL fChecked,
						INT iConnectionItem) 
{ 
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
DWORD dwState;

    pCurHandlerInfo = m_pFirstHandler;

    dwState = fChecked ? SYNCMGRITEMSTATE_CHECKED : SYNCMGRITEMSTATE_UNCHECKED;

    while (pCurHandlerInfo )
    {
		pCurItem = pCurHandlerInfo->pFirstItem;

		while (pCurItem)
		{
			if (iItem == pCurItem->iItem)
			{
                            switch(SyncType)
                            {
                            case  SYNCTYPE_AUTOSYNC: 
				pCurItem->pItemCheckState[iConnectionItem].dwAutoSync = dwState;
                                break;
                            case  SYNCTYPE_IDLE:
				pCurItem->pItemCheckState[iConnectionItem].dwIdle = dwState;
                                break;
                            case SYNCTYPE_SCHEDULED:
				pCurItem->pItemCheckState[iConnectionItem].dwSchedule = dwState;
                                break;
                            default:
                                AssertSz(0,"Unknown Setting type");
                                break;
                            }

			    return NOERROR;
			}
			pCurItem = pCurItem->pnextItem;
		}
		pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    Assert(0); // review - better assert but warn us when try to set a listView item that isn't assigned.
    return S_FALSE; // item wasn't found

} 

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::ListViewItemHasProperties(INT iItem)
//
//  PURPOSE: determines if there are properties associated with this item.
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::ListViewItemHasProperties(INT iItem) 
{ 
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
	pCurItem = pCurHandlerInfo->pFirstItem;

	while (pCurItem)
	{
	    if (iItem == pCurItem->iItem)
	    {
    
		Assert(HANDLERSTATE_PREPAREFORSYNC == pCurHandlerInfo->HandlerState); 

		return pCurItem->offlineItem.dwFlags & SYNCMGRITEM_HASPROPERTIES
		    ? NOERROR : S_FALSE;
	    }

	    pCurItem = pCurItem->pnextItem;
	}

	pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

   //  Assert(-1 == iItem); // if don't find item, should be because user clicked in list box where there was none
    return S_FALSE; // item wasn't found

}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::ShowProperties(HWND hwndParent,INT iItem)
//
//  PURPOSE:   find the first item in the queueu with the assigned iItem and 
//			   call there show properties method.
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::ShowProperties(HWND hwndParent,INT iItem) 
{ 
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;

    AssertSz(0,"ShowProperties Called from Setttings");

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
	pCurItem = pCurHandlerInfo->pFirstItem;

	while (pCurItem)
	{
	    if (iItem == pCurItem->iItem)
	    {
		Assert(HANDLERSTATE_PREPAREFORSYNC == pCurHandlerInfo->HandlerState); 

		// UI shouldn't call this unless item actually has a properties flag
		Assert(SYNCMGRITEM_HASPROPERTIES & pCurItem->offlineItem.dwFlags);
	    
		// make sure properties flag isn't set.
		if ( (SYNCMGRITEM_HASPROPERTIES & pCurItem->offlineItem.dwFlags))
		{
		    return pCurHandlerInfo->pSyncMgrHandler->
					ShowProperties(hwndParent,
					  (pCurItem->offlineItem.ItemID));
		}

		return S_FALSE;
	    }

	    pCurItem = pCurItem->pnextItem;
	}

	pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    Assert(0); // review - better assert but wanr us when try to set a listView item that isn't assigned.
    return S_FALSE; // item wasn't found
} 



//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::CreateServer(WORD wHandlerId, const CLSID *pCLSIDServer) 
//
//  PURPOSE:  Create the Handler server
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::CreateServer(WORD wHandlerId, const CLSID *pCLSIDServer) 
{ 
HRESULT hr = NO_ERROR; // review for Lookup failures
LPHANDLERINFO pHandlerInfo = NULL;
LPUNKNOWN pUnk;
    
	hr = LookupHandlerFromId(wHandlerId,&pHandlerInfo);
    if (hr == NOERROR)
	{
		if (HANDLERSTATE_CREATE != pHandlerInfo->HandlerState)
		{
			Assert(HANDLERSTATE_CREATE == pHandlerInfo->HandlerState);
			return E_UNEXPECTED;
		}

		pHandlerInfo->HandlerState = HANDLERSTATE_INCREATE;
	
		pHandlerInfo->clsidHandler = *pCLSIDServer;
		hr = CoCreateInstance(pHandlerInfo->clsidHandler, 
						  NULL, CLSCTX_INPROC_SERVER,
						  IID_IUnknown, (void **) &pUnk);

		if (NOERROR == hr)
		{
			hr = pUnk->QueryInterface(IID_ISyncMgrSynchronize,
							 (void **) &pHandlerInfo->pSyncMgrHandler);

			pUnk->Release();
		}


		if (NOERROR == hr)
		{
			pHandlerInfo->HandlerState = HANDLERSTATE_INITIALIZE;
		}
		else
		{
			pHandlerInfo->pSyncMgrHandler = NULL;
			pHandlerInfo->HandlerState = HANDLERSTATE_DEAD;
		}
    
	}
    return hr;
}
  

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::Initialize(WORD wHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
//								    DWORD cbCookie,const BYTE *lpCookie) 
//
//  PURPOSE: Initialize the handler 
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Initialize(WORD wHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
		    DWORD cbCookie,const BYTE *lpCookie) 
{
HRESULT hr = E_UNEXPECTED; // review for Lookup failures
LPHANDLERINFO pHandlerInfo = NULL;
    
    if (NOERROR == LookupHandlerFromId(wHandlerId,&pHandlerInfo))
    {
		if (HANDLERSTATE_INITIALIZE != pHandlerInfo->HandlerState)
		{
			Assert(HANDLERSTATE_INITIALIZE == pHandlerInfo->HandlerState);
			return E_UNEXPECTED; 
		}

		pHandlerInfo->HandlerState = HANDLERSTATE_ININITIALIZE;

		Assert(pHandlerInfo->pSyncMgrHandler);

		if (NULL != pHandlerInfo->pSyncMgrHandler)
		{
			hr = pHandlerInfo->pSyncMgrHandler->Initialize(dwReserved,dwSyncFlags,cbCookie,lpCookie);
		}
	
		if (NOERROR  == hr)
		{
			pHandlerInfo->HandlerState = HANDLERSTATE_ADDHANDLERTEMS;
			pHandlerInfo->dwSyncFlags = dwSyncFlags; 
		}
		else
		{
			// on an error, go ahead and release the proxy if server doesn't want to handle
			pHandlerInfo->HandlerState = HANDLERSTATE_DEAD;
		}

    }
    
    return hr; 
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:  CHndlrQueue::AddHandlerItemsToQueue(WORD wHandlerId) 
//
//  PURPOSE:  Enumerate the handler items and add them to the queue
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::AddHandlerItemsToQueue(WORD wHandlerId) 
{ 
HRESULT hr = E_UNEXPECTED; // review for Lookup failures
LPHANDLERINFO pHandlerInfo = NULL;
LPSYNCMGRENUMITEMS pEnumOffline = NULL;
    
    if (NOERROR == LookupHandlerFromId(wHandlerId,&pHandlerInfo))
    {
	if (HANDLERSTATE_ADDHANDLERTEMS != pHandlerInfo->HandlerState)
	{
	    Assert(HANDLERSTATE_ADDHANDLERTEMS == pHandlerInfo->HandlerState);
	    return E_UNEXPECTED; 
	}

	pHandlerInfo->HandlerState = HANDLERSTATE_INADDHANDLERITEMS;

	Assert(pHandlerInfo->pSyncMgrHandler);

	if (pHandlerInfo->pSyncMgrHandler)
	{
            hr = pHandlerInfo->pSyncMgrHandler->EnumSyncMgrItems(&pEnumOffline);

            if ( ((NOERROR == hr) || (S_SYNCMGR_MISSINGITEMS  == hr)) && pEnumOffline)
            {
            SYNCMGRITEMNT5B2 offItem; // temporarily use NT5B2 structure since its bigger
            ULONG pceltFetched;

            // add the handler info
            SYNCMGRHANDLERINFO *pSyncMgrHandlerInfo = NULL;

                // update missing items info
                m_fItemsMissing |= (S_SYNCMGR_MISSINGITEMS  == hr);

                hr = pHandlerInfo->pSyncMgrHandler->GetHandlerInfo(&pSyncMgrHandlerInfo);
                if (NOERROR == hr && pSyncMgrHandlerInfo)
                {
                   if (IsValidSyncMgrHandlerInfo(pSyncMgrHandlerInfo))
                   {
                        SetHandlerInfo(wHandlerId,pSyncMgrHandlerInfo);
                    }

                    CoTaskMemFree(pSyncMgrHandlerInfo);
                }

                // Get this handlers registration flags
                BOOL fReg;

                fReg = RegGetHandlerRegistrationInfo(pHandlerInfo->clsidHandler,
                                    &(pHandlerInfo->dwRegistrationFlags));

                // rely on RegGetHandler to set flags to zero on error
                // so assert that it does
                Assert(fReg || (0 == pHandlerInfo->dwRegistrationFlags));
                
                
                hr = NOERROR; // okay to add items even if Gethandler info fails

                Assert(sizeof(SYNCMGRITEMNT5B2) > sizeof(SYNCMGRITEM));

	        // sit in loop getting data of objects to fill list box.
	        // should really set up list in memory for OneStop to fill in or
	        // main thread could pass in a callback interface.

	        while(NOERROR == pEnumOffline->Next(1,(SYNCMGRITEM *) &offItem,&pceltFetched))
	        {
                    // don't add the item if temporary.
                    if (!(offItem.dwFlags & SYNCMGRITEM_TEMPORARY))
                    {
		        AddItemToHandler(wHandlerId,(SYNCMGRITEM *) &offItem);	
                    }
	        }

	        pEnumOffline->Release();
            }
	}

	if (NOERROR  == hr)
	{
	    pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;
	}
	else
	{
	    pHandlerInfo->HandlerState = HANDLERSTATE_DEAD;
	}
    }
    
    return hr; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetHandlerInfo, public
//
//  Synopsis:   Adds item to the specified handler.
//              Called in context of the handlers thread.
//
//  Arguments:  [pHandlerId] - Id of handler.
//              [pSyncMgrHandlerInfo] - Points to SyncMgrHandlerInfo to be filled in.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    28-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetHandlerInfo(WORD wHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;

    if (!pSyncMgrHandlerInfo)
    {
        return E_INVALIDARG;
        Assert(pSyncMgrHandlerInfo);
    }


    if (NOERROR == LookupHandlerFromId(wHandlerId,&pHandlerInfo))
    {
        if (HANDLERSTATE_INADDHANDLERITEMS != pHandlerInfo->HandlerState)
        {
            Assert(HANDLERSTATE_INADDHANDLERITEMS == pHandlerInfo->HandlerState);
            hr =  E_UNEXPECTED;
        }
        else
        {

            // Review - After clients update turn
            // this check back on
            if (0 /* pSyncMgrHandlerInfo->cbSize != sizeof(SYNCMGRHANDLERINFO) */)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                pHandlerInfo->SyncMgrHandlerInfo = *pSyncMgrHandlerInfo;
            }
        }
    }

    return hr;

}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::AddItemToHandler(WORD wHandlerId,SYNCMGRITEM *pOffineItem)
//
//  PURPOSE:  Add the handler's items 
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::AddItemToHandler(WORD wHandlerId,SYNCMGRITEM *pOffineItem)
{
HRESULT hr = E_UNEXPECTED; // review for Lookup failures
LPHANDLERINFO pHandlerInfo = NULL;
LPITEMLIST pNewItem = NULL;
    
    if (!IsValidSyncMgrItem(pOffineItem))
    {
        return E_UNEXPECTED;
    }

    if (NOERROR == LookupHandlerFromId(wHandlerId,&pHandlerInfo))
    {
	if (HANDLERSTATE_INADDHANDLERITEMS != pHandlerInfo->HandlerState)
	{
		Assert(HANDLERSTATE_INADDHANDLERITEMS == pHandlerInfo->HandlerState);
		return E_UNEXPECTED; 
	}

	// Allocate the item.
	pNewItem = (LPITEMLIST) ALLOC(sizeof(ITEMLIST));

	if (NULL == pNewItem)
		return E_OUTOFMEMORY;

	memset(pNewItem,0,sizeof(ITEMLIST));
	pNewItem->wItemId = 	++pHandlerInfo->wItemCount;
	pNewItem->pHandlerInfo = pHandlerInfo;
	pNewItem->iItem = -1;

	pNewItem->offlineItem = *pOffineItem;

	// stick the item on the end of the list
	if (NULL == pHandlerInfo->pFirstItem)
	{
		pHandlerInfo->pFirstItem = pNewItem;
		Assert(1 == pHandlerInfo->wItemCount);
	}
	else
	{
	LPITEMLIST pCurItem;

		pCurItem = pHandlerInfo->pFirstItem;

		while (pCurItem->pnextItem)
		pCurItem = pCurItem->pnextItem;

		pCurItem->pnextItem = pNewItem;

		Assert ((pCurItem->wItemId + 1) == pNewItem->wItemId);
	}

	hr = NOERROR;
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::LookupHandlerFromId(WORD wHandlerId,
//										LPHANDLERINFO *pHandlerInfo)
//
//  PURPOSE:  finds associated hander data from the handler ID
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::LookupHandlerFromId(WORD wHandlerId,LPHANDLERINFO *pHandlerInfo)
{
HRESULT hr = E_UNEXPECTED; // review error code.
LPHANDLERINFO pCurItem;

    *pHandlerInfo = NULL; 
    pCurItem = m_pFirstHandler;

    while (pCurItem)
    {
	if (wHandlerId == pCurItem->wHandlerId )
	{
	    *pHandlerInfo = pCurItem;
	    hr = NOERROR;
	    break;
	}
	
	pCurItem = pCurItem->pNextHandler;
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::InitAutoSyncSettings(HWND hwndRasCombo)
//
//  PURPOSE:  Initialize the autosync settings per the connections 
//				listed in this RasCombo
//
//	COMMENTS: Ras based (connection name as identifier) When connection object
//			  based, we will use the connection GUID to identify the connection 
//			  settings
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::InitSyncSettings(SYNCTYPE syncType,HWND hwndRasCombo)
{
SCODE sc = S_OK;
int i;

        // This function gets possibly gets called twice
        // once for AuotSync and once for Idle if already have
        // a connection list then use existing

        if (NULL == m_ConnectionList)
        {
	    m_ConnectionCount = ComboBox_GetCount(hwndRasCombo);
	    
	    if (m_ConnectionCount > 0)
	    {	
		    smMem(m_ConnectionList = (LPCONNECTIONSETTINGS) 
			               ALLOC(m_ConnectionCount * sizeof(CONNECTIONSETTINGS)));

	    }
        }

        // if now have a connection list set the appropriate settings
        if (m_ConnectionList)
        {
       COMBOBOXEXITEM comboItem;

	    for (i=0; i<m_ConnectionCount; i++)
	    {
		    comboItem.mask = CBEIF_TEXT;
		    comboItem.cchTextMax = RAS_MaxEntryName + 1;
		    comboItem.pszText = m_ConnectionList[i].pszConnectionName;
		    comboItem.iItem = i;

                    // Review what happens on failure
                    ComboEx_GetItem(hwndRasCombo,&comboItem);

                    switch (syncType)
                    {
                        case SYNCTYPE_AUTOSYNC:
			    RegGetAutoSyncSettings(&(m_ConnectionList[i]));
                            break;
                        case SYNCTYPE_IDLE:
                            RegGetIdleSyncSettings(&(m_ConnectionList[i]));
                            break;
                        default:
                            AssertSz(0,"Unknown SyncType");
                            break;
                    }
	    }
        }

EH_Err:
	return sc;  
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::InitSchedSyncSettings(LPCONNECTIONSETTINGS pConnectionSettings)
//
//  PURPOSE:  Initialize the scheduled Sync settings per the connections 
//				listed in this RasCombo
//
//	COMMENTS: Ras based (connection name as identifier) When connection object
//			  based, we will use the connection GUID to identify the connection 
//			  settings
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::InitSchedSyncSettings(LPCONNECTIONSETTINGS pConnectionSettings)
{
	m_ConnectionList = pConnectionSettings;
	
	return S_OK;  
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::ReadSchedSyncSettingsPerConnection(WORD wHandlerID, 
//															 TCHAR * pszSchedName)
//
//  PURPOSE:  Read the scheduled Sync settings from the registry.  
//			  If there is no entry in the registry, the default is the 
//			  check state of the current offline item
//
//	COMMENTS: Ras based (connection name as identifier) When connection object
//			  based, we will use the connection GUID to identify the connection 
//			  settings
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::ReadSchedSyncSettingsOnConnection(WORD wHandlerID,TCHAR * pszSchedName)
{
HRESULT hr = E_UNEXPECTED; // review for Lookup failures
LPHANDLERINFO pHandlerInfo = NULL;

    Assert(m_ConnectionList != NULL);
    
    if (!m_ConnectionList)
        return E_UNEXPECTED;

	//Set the Check set of this item per connection
    if (NOERROR == LookupHandlerFromId(wHandlerID,&pHandlerInfo))
    {
	LPITEMLIST pCurItem = pHandlerInfo->pFirstItem;

	while (pCurItem)
	{
	    //Scheduled sync only works on one connection
            Assert(NULL == pCurItem->pItemCheckState );

	    pCurItem->pItemCheckState = (ITEMCHECKSTATE*) ALLOC(sizeof(ITEMCHECKSTATE));
	
            if (!pCurItem->pItemCheckState)
	    {
		return E_OUTOFMEMORY;
	    }
                        
            // by default no items in the schedule are checked.
            pCurItem->pItemCheckState[0].dwSchedule = FALSE;
	

            // possible for schedule name to be null when schedule first created.
            if (pszSchedName)
            {
                            
	        RegGetSyncItemSettings(SYNCTYPE_SCHEDULED,
				       pHandlerInfo->clsidHandler,
				       pCurItem->offlineItem.ItemID,
				       m_ConnectionList->pszConnectionName,
				       &(pCurItem->pItemCheckState[0].dwSchedule),
				       pCurItem->offlineItem.dwItemState,
				       pszSchedName);
            }

	    pCurItem = pCurItem->pnextItem;
	}
	    
    }
    return hr;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::InsertItem(LPHANDLERINFO pCurHandler, 
//                              LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
//
//  PURPOSE:  App is programatically adding an item to the schedule 
//		with a default check state
//
//  HISTORY:  11-25-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::InsertItem(LPHANDLERINFO pCurHandler, 
                              LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
{
LPITEMLIST pCurItem = pCurHandler->pFirstItem;

    while (pCurItem)
    {
	if (pHandlerItemInfo->itemID == pCurItem->offlineItem.ItemID)
	{
	    pCurItem->pItemCheckState[0].dwSchedule = pHandlerItemInfo->dwCheckState;
	    pCurItem->offlineItem.hIcon = pHandlerItemInfo->hIcon;
	    lstrcpy(pCurItem->offlineItem.wszItemName, pHandlerItemInfo->wszItemName);

	    return S_OK;
        }
        pCurItem = pCurItem->pnextItem;

    }
    if (!pCurItem)
    {
				
        //Item was not found on the handler, add it now
        // Allocate the item.
        LPITEMLIST pNewItem = (LPITEMLIST) ALLOC(sizeof(ITEMLIST));
    
        if (NULL == pNewItem)
        {
            return E_OUTOFMEMORY;
        }
    
        memset(pNewItem,0,sizeof(ITEMLIST));
        pNewItem->wItemId = 	++pCurHandler->wItemCount;
        pNewItem->pHandlerInfo = pCurHandler;
        pNewItem->iItem = -1;

        SYNCMGRITEM *pOfflineItem = (LPSYNCMGRITEM) ALLOC(sizeof(SYNCMGRITEM));
    
        if (NULL == pOfflineItem)
        {
            FREE(pNewItem);
            return E_OUTOFMEMORY;
        }
    
        ZeroMemory(pOfflineItem, sizeof(SYNCMGRITEM));
        pNewItem->offlineItem = *pOfflineItem;
        pNewItem->offlineItem.hIcon = pHandlerItemInfo->hIcon;
        pNewItem->offlineItem.ItemID = pHandlerItemInfo->itemID;
        lstrcpy(pNewItem->offlineItem.wszItemName, pHandlerItemInfo->wszItemName);

        //Scheduled sync only works on one connection
        Assert(NULL == pNewItem->pItemCheckState );

        pNewItem->pItemCheckState = (ITEMCHECKSTATE*) ALLOC(sizeof(ITEMCHECKSTATE));
        if (!pNewItem->pItemCheckState)
        {
            FREE(pNewItem);
            FREE(pOfflineItem);
            return E_OUTOFMEMORY;
        }        
        pNewItem->pItemCheckState[0].dwSchedule = pHandlerItemInfo->dwCheckState;
				    
        // stick the item on the end of the list
        if (NULL == pCurHandler->pFirstItem)
        {
            pCurHandler->pFirstItem = pNewItem;
            Assert(1 == pCurHandler->wItemCount);
        }
        else
        {
	    LPITEMLIST pCurItem;
            pCurItem = pCurHandler->pFirstItem;

            while (pCurItem->pnextItem)
                pCurItem = pCurItem->pnextItem;

            pCurItem->pnextItem = pNewItem;

            Assert ((pCurItem->wItemId + 1) == pNewItem->wItemId);
        }
    }
    return S_OK;			
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::AddHandlerItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
//
//  PURPOSE:  App is programatically adding an item to the schedule 
//		with this default check state
//
//  HISTORY:  03-05-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::AddHandlerItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
{ 
LPHANDLERINFO pCurHandlerInfo = NULL;
SCODE sc = S_OK;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
	if (pHandlerItemInfo->handlerID == pCurHandlerInfo->clsidHandler)
	{

            return InsertItem(pCurHandlerInfo, pHandlerItemInfo);

	}
	pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }
    //if the handler is not loaded, just cache the new item.
    return SYNCMGR_E_HANDLER_NOT_LOADED;
} 

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::SetItemCheck(REFCLSID pclsidHandler,
//						SYNCMGRITEMID *pOfflineItemID, DWORD dwCheckState)
//
//  PURPOSE:  App is programatically setting the check state of an item
//
//  HISTORY:  03-05-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::SetItemCheck(REFCLSID pclsidHandler,
				       SYNCMGRITEMID *pOfflineItemID, DWORD dwCheckState)
{ 
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
	if (pclsidHandler == pCurHandlerInfo->clsidHandler)
	{
	    pCurItem = pCurHandlerInfo->pFirstItem;

	    while (pCurItem)
	    {
		if (*pOfflineItemID == pCurItem->offlineItem.ItemID)
		{
		    pCurItem->pItemCheckState[0].dwSchedule = dwCheckState;
		    return S_OK;
		}
		pCurItem = pCurItem->pnextItem;
	    }
            return SYNCMGR_E_ITEM_UNREGISTERED; 
	}
	pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }
    
    //if the handler is not loaded, just cache the new item
    return SYNCMGR_E_HANDLER_NOT_LOADED;
} 


//--------------------------------------------------------------------------------
//
//  FUNCTION: HndlrQueue::GetItemCheck(REFCLSID pclsidHandler,
//						SYNCMGRITEMID *pOfflineItemID, DWORD *pdwCheckState)
//  PURPOSE:  App is programatically setting the check state of an item
//
//  HISTORY:  03-05-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::GetItemCheck(REFCLSID pclsidHandler,
						SYNCMGRITEMID *pOfflineItemID, DWORD *pdwCheckState)
{ 
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
	if (pclsidHandler == pCurHandlerInfo->clsidHandler)
	{
	    pCurItem = pCurHandlerInfo->pFirstItem;

	    while (pCurItem)
	    {
		if (*pOfflineItemID == pCurItem->offlineItem.ItemID)
		{
		    *pdwCheckState = pCurItem->pItemCheckState[0].dwSchedule;
		    return S_OK;
		}
		pCurItem = pCurItem->pnextItem;
	    }
	    return SYNCMGR_E_ITEM_UNREGISTERED;
        }
	pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }
    
    //if the handler is not loaded, just cache the new item
    return SYNCMGR_E_HANDLER_NOT_LOADED;

} 

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::ReadSyncSettingsPerConnection(SYNCTYPE syncType, 
//															 WORD wHandlerID)
//
//  PURPOSE:  Read the autosync settings from the registry.  
//			  If there is no entry in the registry, the default is the 
//			  check state of the current offline item
//
//	COMMENTS: Ras based (connection name as identifier) When connection object
//			  based, we will use the connection GUID to identify the connection 
//			  settings
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::ReadSyncSettingsPerConnection(SYNCTYPE syncType, 
                                                        WORD wHandlerID)
{
HRESULT hr = E_UNEXPECTED; // review for Lookup failures
LPHANDLERINFO pHandlerInfo = NULL;
	
    int i;

    if (0 == m_ConnectionCount)
        return S_FALSE;

    Assert(m_ConnectionList != NULL);
    Assert(m_ConnectionCount != 0);

	//Set the Check set of this item per connection
    if (NOERROR == LookupHandlerFromId(wHandlerID,&pHandlerInfo))
    {
    LPITEMLIST pCurItem = pHandlerInfo->pFirstItem;

	while (pCurItem)
	 {

             // if don't alreayd have a checkStateAllocate one.
            if (!pCurItem->pItemCheckState)
            {
                pCurItem->pItemCheckState = (ITEMCHECKSTATE*) ALLOC(m_ConnectionCount * sizeof(ITEMCHECKSTATE));
            }

            if (!pCurItem->pItemCheckState)
            {
                return E_OUTOFMEMORY;
            }	

	    for (i=0; i<m_ConnectionCount; i++)
	    {
            DWORD dwDefaultCheck;
                
                // if handler hasn't registered for the
                // event then set its check state fo uncheck
                // we do this in each case. to start off with
                // assume the handler is registered

                // If change this logic need to also change logic in exe hndlrq.


                dwDefaultCheck = pCurItem->offlineItem.dwItemState;

                switch (syncType)
                {
                    case SYNCTYPE_AUTOSYNC:

                        if (0 == (pHandlerInfo->dwRegistrationFlags 
                            & (SYNCMGRREGISTERFLAG_CONNECT | SYNCMGRREGISTERFLAG_PENDINGDISCONNECT)))
                        {
                            dwDefaultCheck = SYNCMGRITEMSTATE_UNCHECKED;
                        }

			RegGetSyncItemSettings(SYNCTYPE_AUTOSYNC,
					    pHandlerInfo->clsidHandler,
					    pCurItem->offlineItem.ItemID,
					    m_ConnectionList[i].pszConnectionName,
					    &(pCurItem->pItemCheckState[i].dwAutoSync),
					    dwDefaultCheck,
					    NULL);

                        break;
                    case SYNCTYPE_IDLE:

                       if (0 == (pHandlerInfo->dwRegistrationFlags & (SYNCMGRREGISTERFLAG_IDLE) ))
                        {
                            dwDefaultCheck = SYNCMGRITEMSTATE_UNCHECKED;
                        }

			RegGetSyncItemSettings(SYNCTYPE_IDLE,
					    pHandlerInfo->clsidHandler,
					    pCurItem->offlineItem.ItemID,
					    m_ConnectionList[i].pszConnectionName,
					    &(pCurItem->pItemCheckState[i].dwIdle),
					    dwDefaultCheck,
					    NULL);
                        break;
                    default:
                        AssertSz(0,"Unknown SyncType");
                        break;
                }

	    }
	    pCurItem = pCurItem->pnextItem;
	}
    
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::ReadAdvancedIdleSettings
//
//  PURPOSE:  Reads in the advanced Idle Settings.
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ReadAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
{

    // connection settings for global idle are really overloaded.
    // advanced idle settings are in each connection so just copy it from 
    // whatever the first connection is.

    if ( (m_ConnectionCount < 1) || (NULL == m_ConnectionList))
        return S_FALSE;


    *pConnectionSettings = m_ConnectionList[0];

    return NOERROR;
}

STDMETHODIMP CHndlrQueue::WriteAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings)
{
int iIndex;

    // connection settings for global idle are really overloaded.
    // advanced idle settings are in each connection so copy the members into each
    // loaded connection in the list
    
    for (iIndex = 0; iIndex < m_ConnectionCount; iIndex++)
    {
        m_ConnectionList[iIndex].ulIdleWaitMinutes = pConnectionSettings->ulIdleWaitMinutes;
        m_ConnectionList[iIndex].ulIdleRetryMinutes = pConnectionSettings->ulIdleRetryMinutes;
        m_ConnectionList[iIndex].dwRepeatSynchronization = pConnectionSettings->dwRepeatSynchronization;
        m_ConnectionList[iIndex].dwRunOnBatteries = pConnectionSettings->dwRunOnBatteries;
        m_ConnectionList[iIndex].ulIdleWaitMinutes = pConnectionSettings->ulIdleWaitMinutes;


    }

    return NOERROR;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::CommitAutoSyncChanges(Ras *pRas)
//
//  PURPOSE:  Write the autosync settings to the registry.  This is done when
//			  the user selects OK or APPLY from the settings dialog.
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::CommitSyncChanges(SYNCTYPE syncType,CRasUI *pRas)
{
LPHANDLERINFO pHandlerInfo;
int i;

    if (!m_ConnectionList) // if no connection list, nothing to do
    {
        Assert(m_ConnectionList);
        return NOERROR;
    }

    switch (syncType)
    {
        case SYNCTYPE_AUTOSYNC:
            RegSetAutoSyncSettings(m_ConnectionList, m_ConnectionCount, pRas,
                !m_fItemsMissing /* fCleanReg */,
                TRUE /* fSetMachineState */,
                TRUE /* fPerUser */);
            
            break;
        case SYNCTYPE_IDLE:
            RegSetIdleSyncSettings(m_ConnectionList, m_ConnectionCount, pRas,
                !m_fItemsMissing /* fCleanReg */,
                TRUE /* fPerUser */);
            
            break;
        default:
            AssertSz(0,"Unknown SyncType");
            break;
    }

    for (i=0; i<m_ConnectionCount; i++)
    {

        pHandlerInfo = m_pFirstHandler;

        while (pHandlerInfo)
        {
        LPITEMLIST pCurItem = pHandlerInfo->pFirstItem;
        BOOL fAnyItemsChecked = FALSE;

	    while (pCurItem)
            {
                switch (syncType)
                {
                case SYNCTYPE_AUTOSYNC:

                    fAnyItemsChecked |= pCurItem->pItemCheckState[i].dwAutoSync;

                    RegSetSyncItemSettings(syncType,
			                    pHandlerInfo->clsidHandler,
			                    pCurItem->offlineItem.ItemID,
			                    m_ConnectionList[i].pszConnectionName,
			                    pCurItem->pItemCheckState[i].dwAutoSync,
			                NULL);
                    break;
                case SYNCTYPE_IDLE:

                    fAnyItemsChecked |= pCurItem->pItemCheckState[i].dwIdle;

                    RegSetSyncItemSettings(syncType,
			                    pHandlerInfo->clsidHandler,
			                    pCurItem->offlineItem.ItemID,
			                    m_ConnectionList[i].pszConnectionName,
			                    pCurItem->pItemCheckState[i].dwIdle,
			                NULL);
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }

           // write out the NoItems checked value on the handler for this connection
           RegSetSyncHandlerSettings(syncType,
                                        m_ConnectionList[i].pszConnectionName,
                                        pHandlerInfo->clsidHandler,
                                        fAnyItemsChecked ? 1 : 0);
                        

	   pHandlerInfo = pHandlerInfo->pNextHandler;
        }
    }

    return ERROR_SUCCESS;

}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CHndlrQueue::CommitSchedSyncChanges(TCHAR * pszSchedName,
//					     TCHAR * pszFriendlyName,
//					     TCHAR * pszConnectionName,
//					     DWORD dwConnType,
//                                           BOOL fCleanReg)
//
//
//  PURPOSE:  Write the scheduled sync settings to the registry.  This is done when
//			  the user selects OK or FINISH from the settings dialog.
//
//	COMMENTS: 
//
//  HISTORY:  01-01-98       SusiA        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CHndlrQueue::CommitSchedSyncChanges(TCHAR * pszSchedName,
						 TCHAR * pszFriendlyName,
						 TCHAR * pszConnectionName,
						 DWORD dwConnType,
                                                 BOOL fCleanReg)
{
LPHANDLERINFO pHandlerInfo;
pHandlerInfo = m_pFirstHandler;

    if (!m_ConnectionList) // Review - What should we do here?
    {
        return E_FAIL;
    }


    if (fCleanReg && !m_fItemsMissing)
    {
        RegRemoveScheduledTask(pszSchedName); // Remove any previous settings
    }

    lstrcpy(m_ConnectionList->pszConnectionName, pszConnectionName);
    m_ConnectionList->dwConnType = dwConnType;
	
    //set the SID on this schedule
    if  (g_dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if (!RegSetSIDForSchedule(pszSchedName))
        {
	    E_FAIL;
        }
    }
    
    //Set the friendly name in the registry
    if (!RegSetSchedFriendlyName(pszSchedName,pszFriendlyName))
    {
	E_FAIL;
    }
    RegSetSchedSyncSettings(m_ConnectionList, pszSchedName);

    while (pHandlerInfo)
    {
    LPITEMLIST pCurItem = pHandlerInfo->pFirstItem;

	while (pCurItem)
	{
	    RegSetSyncItemSettings(SYNCTYPE_SCHEDULED,
						pHandlerInfo->clsidHandler,
						pCurItem->offlineItem.ItemID,
						m_ConnectionList->pszConnectionName,
						pCurItem->pItemCheckState[0].dwSchedule,
						pszSchedName);

	    pCurItem = pCurItem->pnextItem;
	}

	pHandlerInfo = pHandlerInfo->pNextHandler;
    }
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\hndlrq.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Hndlrq.h
//
//  Contents:   Keeps tracks of Handlers and UI assignments
//
//  Classes:    CHndlrQueue
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//				17-Nov-97	susia		Converted to an Autosync Queue
//
//--------------------------------------------------------------------------

#ifndef _HANDLERQUEUE_
#define _HANDLERQUEUE_

typedef enum _tagHANDLERSTATE   
{	
    HANDLERSTATE_CREATE				= 0x01, // state is initialized to this.
    HANDLERSTATE_INCREATE			= 0x02, // state is initialized to this.
    HANDLERSTATE_INITIALIZE			= 0x03, // set after a successfull creation.
    HANDLERSTATE_ININITIALIZE		= 0x04, // set during initialization call
    HANDLERSTATE_ADDHANDLERTEMS		= 0x05, // items need to be enumerated
    HANDLERSTATE_INADDHANDLERITEMS	= 0x06, // in the items enumerator
    HANDLERSTATE_PREPAREFORSYNC		= 0x07, // set during queue tranfers
    HANDLERSTATE_INPREPAREFORSYNC	= 0x08, // handler is currently in a prepfosync call.
    HANDLERSTATE_DEAD    			= 0x0F, // handler has been released. Data Stays around.
}  HANDLERSTATE;
 
typedef enum _tagQUEUETYPE   
{	
    QUEUETYPE_SETTINGS			= 0x3, // set during queue tranfers
    QUEUETYPE_SCHEDULE			= 0x4, // set during queue tranfers
} QUEUETYPE;

// so can share the queue with AutoSync and Idle just define a checkstate struct
// to keep track of items.
typedef struct _tagITEMCHECKSTATE
{
    DWORD dwAutoSync;
    DWORD dwIdle;
    DWORD dwSchedule;
} ITEMCHECKSTATE;



typedef struct _ITEMLIST
{
    struct _ITEMLIST	*pnextItem;
    WORD	        wItemId;		// Id that uniquely identifies Item within a handler.
    void	        *pHandlerInfo;	        // pointer to the handler that owns this item
    INT		        iItem;			// Index of Item in the current ListView.!!!Initialize to -1
    SYNCMGRITEM		offlineItem;            // enumerator structure item returned
    ITEMCHECKSTATE      *pItemCheckState;	// list of check states per connection
} ITEMLIST;

typedef ITEMLIST* LPITEMLIST;



typedef struct _HANDLERINFO {
    struct _HANDLERINFO		*pNextHandler;  // next handler in queue
    WORD		        wHandlerId;	    // Id that uniquely identifies this instance of the Handler
    CLSID			clsidHandler;	// CLSID of the handler Handler 
    SYNCMGRHANDLERINFO          SyncMgrHandlerInfo; // copy of handler info GetHandlerInfo CallHANDLERSTATE		HandlerState;	// Current state of the handler
    HANDLERSTATE                HandlerState;
    DWORD                       dwRegistrationFlags; // flags as item is registered
    DWORD			dwSyncFlags;	// sync flags originally passed in Initialize.
    WORD			wItemCount;		// number of items on this handler    
    LPITEMLIST			pFirstItem;	    // ptr to first Item of the handler in the list.
    LPSYNCMGRSYNCHRONIZE	pSyncMgrHandler;
} HANDLERINFO;

typedef HANDLERINFO* LPHANDLERINFO;


class CHndlrQueue {

private:

	LPHANDLERINFO		m_pFirstHandler;		// first handler in queue
	WORD			m_wHandlerCount;		// number of handlers in this queue
	QUEUETYPE		m_QueueType;			// type of queue this is.
	CRITICAL_SECTION	m_CriticalSection;		// critical section for the queue.
	LPCONNECTIONSETTINGS	m_ConnectionList;		// hold the settings per connection 
	int			m_ConnectionCount;		// number of connections
        BOOL                    m_fItemsMissing;         // set if any handlers have missing items.

public:
	
	CHndlrQueue(QUEUETYPE QueueType);
	~CHndlrQueue();
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	
	// main queue routines
	STDMETHODIMP AddHandler(REFCLSID clsidHandler, WORD *wHandlerId);
	STDMETHODIMP RemoveHandler(WORD wHandlerId);

	STDMETHODIMP FreeAllHandlers(void); 

	// For updating hWnd and ListView Information.
        STDMETHODIMP GetHandlerInfo(REFCLSID clsidHandler,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);

	STDMETHODIMP FindFirstHandlerInState
				(HANDLERSTATE hndlrState,
				 WORD *wHandlerID);
	
	STDMETHODIMP FindNextHandlerInState
				(WORD wLastHandlerID,
				 HANDLERSTATE hndlrState,
				 WORD *wHandlerID);

	STDMETHODIMP GetHandlerIDFromClsid
				(REFCLSID clsidHandlerIn,
				 WORD *pwHandlerId);

	STDMETHODIMP FindFirstItemOnConnection
				(TCHAR *pszConnectionName, 
				 CLSID *pclsidHandler,
				 SYNCMGRITEMID* OfflineItemID,
				 WORD *pwHandlerId,WORD *pwItemID);
	
	STDMETHODIMP FindNextItemOnConnection
				 (TCHAR *pszConnectionName, 
				  WORD wLastHandlerId,
				  WORD wLastItemID,
				  CLSID *pclsidHandler,
				  SYNCMGRITEMID* OfflineItemID,
				  WORD *pwHandlerId,
				  WORD *pwItemID,
				  BOOL fAllHandlers,
				  DWORD *pdwCheckState);
	
	STDMETHODIMP GetSyncItemDataOnConnection
				 (int iConnectionIndex,	
				  WORD wHandlerId,
				  WORD wItemID,
				  CLSID *pclsidHandler,
				  SYNCMGRITEM* offlineItem,
				  ITEMCHECKSTATE   *pItemCheckState,
				  BOOL fSchedSync,
				  BOOL fClear);
    
	STDMETHODIMP SetSyncCheckStateFromListViewItem
				  (SYNCTYPE SyncType,INT iItem,
				   BOOL fChecked,
				   INT iConnectionItem); 

	//AutoSync specific methods
	STDMETHODIMP ReadSyncSettingsPerConnection(SYNCTYPE syncType,WORD wHandlerID);
	STDMETHODIMP InitSyncSettings(SYNCTYPE syncType,HWND hwndRasCombo);
	STDMETHODIMP CommitSyncChanges(SYNCTYPE syncType,CRasUI *pRas);

        // Idle Specific methods.
	STDMETHODIMP ReadAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings);
	STDMETHODIMP WriteAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings);

	
	//SchedSync specific methods
	STDMETHODIMP ReadSchedSyncSettingsOnConnection(WORD wHandlerID, TCHAR *pszSchedName);
	STDMETHODIMP InitSchedSyncSettings(LPCONNECTIONSETTINGS pConnectionSettings);
	STDMETHODIMP CommitSchedSyncChanges(TCHAR * pszSchedName,
						TCHAR * pszFriendlyName,
						TCHAR * pszConnectionName,
						DWORD dwConnType,BOOL fCleanReg);

        STDMETHODIMP InsertItem(LPHANDLERINFO pCurHandler, 
                              LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo);

	STDMETHODIMP AddHandlerItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo);

	STDMETHODIMP SetItemCheck(REFCLSID pclsidHandler,
				  SYNCMGRITEMID *OfflineItemID, DWORD dwCheckState);

	STDMETHODIMP GetItemCheck(REFCLSID pclsidHandler,
				  SYNCMGRITEMID *OfflineItemID, DWORD *pdwCheckState);
									
	STDMETHODIMP SetItemListViewID(CLSID clsidHandler,SYNCMGRITEMID OfflineItemID,INT iItem); // assigns list view ID to an Item.
	DWORD  GetCheck(WORD wParam, INT iItem);
	STDMETHODIMP SetConnectionCheck(WORD wParam, DWORD dwState, INT iConnectionItem);

	
	STDMETHODIMP ListViewItemHasProperties(INT iItem);  // determines if there are properties associated with this item.
	STDMETHODIMP ShowProperties(HWND hwndParent,INT iItem);	    // show properties for this listView Item.
    
	STDMETHODIMP CreateServer(WORD wHandlerId, const CLSID *pCLSIDServer); 
	STDMETHODIMP Initialize(WORD wHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
			        DWORD cbCookie,const BYTE *lpCookie);
        STDMETHODIMP SetHandlerInfo(WORD wHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
	STDMETHODIMP AddHandlerItemsToQueue(WORD wHandlerId);
	STDMETHODIMP AddItemToHandler(WORD wHandlerId,SYNCMGRITEM *pOffineItem);

	STDMETHODIMP GetItemName(WORD wHandlerId, WORD wItemID, WCHAR *pwszName);
	STDMETHODIMP GetItemIcon(WORD wHandlerId, WORD wItemID, HICON *phIcon);


private:
	// private functions for finding proper handlers and items.
	STDMETHODIMP LookupHandlerFromId(WORD wHandlerId,LPHANDLERINFO *pHandlerInfo);
	ULONG  m_cRef;

};



#endif // _HANDLERQUEUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\guid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       guid.c
//
//  Contents:   Defines GUIDS
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#pragma data_seg(".text")
#define INITGUID
#include <objbase.h>
#include <initguid.h>
#include <mstask.h>
#include "debug.h"
#include "mobsync.h"
#include "mobsyncp.h"

#include <sens.h>

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\editschd.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       editschd.cxx
//
//  Contents:   Task schedule page for hidden schedules
//
//  Classes:    CEditSchedPage
//
//  History:    15-Mar-1998   SusiA   
//
//---------------------------------------------------------------------------

#include "precomp.h"

extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo,
extern LANGID g_LangIdSystem;      // LangId of system we are running on.

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

CEditSchedPage *g_pEditSchedPage = NULL;
extern CSelectItemsPage *g_pSelectItemsPage;

#ifdef _CREDENTIALS
extern CCredentialsPage *g_pCredentialsPage;
#endif // _CREDENTIALS

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern OSVERSIONINFOA g_OSVersionInfo;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedEditDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------
BOOL CALLBACK SchedEditDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	WORD wNotifyCode = HIWORD(wParam); // notification code
 
	switch (uMessage)
	{
	case WM_INITDIALOG:
		
	    if (g_pEditSchedPage)
		    g_pEditSchedPage->Initialize(hDlg);

            InitPage(hDlg,lParam);
            return TRUE;
	    break;

        case WM_NOTIFY:
	    switch (((NMHDR FAR *)lParam)->code)
            {
		case PSN_APPLY:

			if (!g_pEditSchedPage->SetSchedName())
			{
				SchedUIErrorDialog(hDlg, IERR_INVALIDSCHEDNAME);
				SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE );
				return TRUE;
			}

                        if (g_pSelectItemsPage)
                        {
			    g_pSelectItemsPage->CommitChanges();
                        }

                    #ifdef _CREDENTIALS

                        SCODE sc;

                        if (g_pCredentialsPage)
                        {
			    sc = g_pCredentialsPage->CommitChanges();
				    
			    if (sc == ERROR_INVALID_PASSWORD)
			    {
				    // Passwords didn't match. Let the user know so he/she
				    // can correct it.
				    
				    SchedUIErrorDialog(hDlg, IERR_PASSWORD);
				    SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE );
				    return TRUE;
				    
			    }
			    else if (sc == SCHED_E_ACCOUNT_NAME_NOT_FOUND)
			    {
				    // Passwords didn't match. Let the user know so he/she
				    // can correct it.
				    
				    SchedUIErrorDialog(hDlg, IERR_ACCOUNT_NOT_FOUND);
				    SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE );
				    return TRUE;
				    
			    }
                        }
                        #endif // _CREDENTIALS

				        

			break;
		
		case PSN_SETACTIVE:
				if (g_pEditSchedPage)
					g_pEditSchedPage->Initialize(hDlg);
			break;
		
		default:
			break;
            
		}
            break;

    	case WM_COMMAND:
	    if ((wNotifyCode == EN_CHANGE) && (LOWORD(wParam) == IDC_SCHED_NAME_EDITBOX))
	    {
			    PropSheet_Changed(GetParent(hDlg), hDlg);
			    g_pEditSchedPage->SetSchedNameDirty();
			    return TRUE;
	    }	
	    break;

        case WM_HELP: 
            {
	    LPHELPINFO lphi  = (LPHELPINFO)lParam;

	        if (lphi->iContextType == HELPINFO_WINDOW)  
	        {
		        WinHelp ( (HWND) lphi->hItemHandle,
			        szSyncMgrHelp, 
    	            	        HELP_WM_HELP, 
			        (ULONG_PTR) g_aContextHelpIds);
	        }           
		return TRUE;
	    }
	case WM_CONTEXTMENU:
	    {
		WinHelp ((HWND)wParam,
                    szSyncMgrHelp, 
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)g_aContextHelpIds);
		
		return TRUE;
	    }

	default:
		break;
	}
	return FALSE;   
}


    
    
//+--------------------------------------------------------------------------
//
//  Member:     CEditSchedPage::CEditSchedPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

CEditSchedPage::CEditSchedPage(
    HINSTANCE hinst,
	ISyncSchedule *pISyncSched,
    HPROPSHEETPAGE *phPSP)
{
	ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));

   	m_psp.dwSize = sizeof (PROPSHEETPAGE);
	m_psp.hInstance = hinst;
        m_psp.dwFlags = PSP_DEFAULT;
	m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDPAGE_SCHEDULE);
	m_psp.pszIcon = NULL;
	m_psp.pfnDlgProc = (DLGPROC) SchedEditDlgProc;
	m_psp.lParam = 0;

	g_pEditSchedPage = this;
	m_pISyncSched = pISyncSched;
	m_pISyncSched->AddRef();

#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

   *phPSP = CreatePropertySheetPage(&m_psp);
}


//+--------------------------------------------------------------------------
//
//  Member:     CEditSchedPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the edit schedule page
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CEditSchedPage::Initialize(HWND hwnd)
{

	SCODE sc;

	TCHAR ptszStr[MAX_PATH + 1];
	TCHAR ptszFmt[MAX_PATH + 1];
	TCHAR ptszString2[MAX_PATH + 1];
	TCHAR ptszString[MAX_PATH + 1];
	WCHAR pwszSchedName[MAX_PATH+1];
	DWORD dwSize = MAX_PATH;

	WCHAR *pwszString = NULL;
        DWORD dwDateReadingFlags = GetDateFormatReadingFlags(hwnd);


        // review - why do we bail on failures but then check for failed immediately after

	//Schedule Name
	if (FAILED(sc = m_pISyncSched->GetScheduleName(&dwSize, pwszSchedName)))
	{
		return FALSE;
	}
	m_hwnd = hwnd;
	
        HWND hwndName = GetDlgItem(hwnd,IDC_SCHED_NAME);

	if ((VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId
            && g_OSVersionInfo.dwMajorVersion >= 5) )
	{
            LONG_PTR dwStyle =  GetWindowLongPtr(hwndName, GWL_STYLE);

	    SetWindowLongPtr(hwndName, GWL_STYLE, dwStyle | SS_ENDELLIPSIS);
	}
   
        SetStaticString(hwndName, pwszSchedName);

	// Trigger string
	ITaskTrigger	*pITrigger;
	TASK_TRIGGER	TaskTrigger;

	if (FAILED(sc = m_pISyncSched->GetTrigger(&pITrigger)))
	{
		return FALSE;
	}
	
	if (FAILED(sc = pITrigger->GetTrigger(&TaskTrigger)))
	{
		return FALSE;
	}
	switch (TaskTrigger.TriggerType)
	{
	case TASK_EVENT_TRIGGER_ON_IDLE:
		LoadString(g_hmodThisDll, IDS_IDLE_TRIGGER_STRING, ptszString, ARRAY_SIZE(ptszString));	
		break;
	case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
		LoadString(g_hmodThisDll, IDS_SYSTEMSTART_TRIGGER_STRING, ptszString, ARRAY_SIZE(ptszString));	
		break;
	case TASK_EVENT_TRIGGER_AT_LOGON:
		LoadString(g_hmodThisDll, IDS_LOGON_TRIGGER_STRING, ptszString, ARRAY_SIZE(ptszString));	
		break;
		
	default:
		if (FAILED(sc = pITrigger->GetTriggerString(&pwszString)))
		{
			return FALSE;
		}
		ConvertString(ptszString,pwszString, ARRAY_SIZE(ptszString));
		
		if (pwszString)
			CoTaskMemFree(pwszString);
		break;
	}

	
	LoadString(g_hmodThisDll, IDS_SCHED_WHEN, ptszFmt, ARRAY_SIZE(ptszFmt));
	wsprintf(ptszStr, ptszFmt, ptszString);

	SetDlgItemText(hwnd,IDC_SCHED_STRING,ptszStr);

	//Last run string
	SYSTEMTIME st;
	if (FAILED(sc = m_pISyncSched->GetMostRecentRunTime(&st)))
	{
		return FALSE;
	}
	if (sc != S_OK)
	{
		LoadString(g_hmodThisDll, IDS_SCHED_NEVERRUN, ptszFmt, ARRAY_SIZE(ptszFmt));
		SetDlgItemText(hwnd,IDC_LASTRUN,ptszFmt);
	}
	else
	{
		sc = GetDateFormat(LOCALE_USER_DEFAULT,dwDateReadingFlags, &st, 
				  NULL,ptszString, MAX_PATH);

		sc = GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, 
				  NULL,ptszString2, MAX_PATH);
	
		LoadString(g_hmodThisDll, IDS_SCHED_LASTRUN, ptszFmt, ARRAY_SIZE(ptszFmt));
		wsprintf(ptszStr, ptszFmt, ptszString, ptszString2);
		SetDlgItemText(hwnd,IDC_LASTRUN,ptszStr);
	}

        //Next run string
	if (FAILED(sc = m_pISyncSched->GetNextRunTime(&st)))
	{
		return FALSE;
	}

	if (sc == SCHED_S_EVENT_TRIGGER)
	{
		switch (TaskTrigger.TriggerType)
		{
		case TASK_EVENT_TRIGGER_ON_IDLE:
			LoadString(g_hmodThisDll, IDS_IDLE_TRIGGER_STRING, ptszString, ARRAY_SIZE(ptszString));	
			break;
		case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
			LoadString(g_hmodThisDll, IDS_SYSTEMSTART_TRIGGER_STRING, ptszString, ARRAY_SIZE(ptszString));	
			break;
		case TASK_EVENT_TRIGGER_AT_LOGON:
			LoadString(g_hmodThisDll, IDS_LOGON_TRIGGER_STRING, ptszString, ARRAY_SIZE(ptszString));	
			break;
		
		default:
			Assert(0);
			break;
		}
		LoadString(g_hmodThisDll, IDS_NEXTRUN_EVENT, ptszFmt, ARRAY_SIZE(ptszFmt));
		wsprintf(ptszStr, ptszFmt, ptszString);
		SetDlgItemText(hwnd,IDC_NEXTRUN,ptszStr);
	
	}
	else if (sc != S_OK)
	{
		LoadString(g_hmodThisDll, IDS_SCHED_NOTAGAIN, ptszFmt, ARRAY_SIZE(ptszFmt));
		SetDlgItemText(hwnd,IDC_NEXTRUN,ptszFmt);
	}
	else
	{
		sc = GetDateFormat(LOCALE_USER_DEFAULT, dwDateReadingFlags, &st, 
				  NULL,ptszString, MAX_PATH);

		sc = GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, 
				  NULL,ptszString2, MAX_PATH);
	
		LoadString(g_hmodThisDll, IDS_SCHED_NEXTRUN, ptszFmt, ARRAY_SIZE(ptszFmt));
		wsprintf(ptszStr, ptszFmt, ptszString, ptszString2);
		SetDlgItemText(hwnd,IDC_NEXTRUN,ptszStr);
	}

    SetCtrlFont(GetDlgItem(hwnd,IDC_SCHED_NAME_EDITBOX),g_OSVersionInfo.dwPlatformId,g_LangIdSystem);

    // set the limit on the edit box for entering the name
    SendDlgItemMessage(hwnd,IDC_SCHED_NAME_EDITBOX,EM_SETLIMITTEXT,MAX_PATH,0);

    ShowSchedName();

    return TRUE;

}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CEditSchedPage::SetSchedNameDirty()
//
//  PURPOSE:  set the sched name dirty
//
//	COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
void CEditSchedPage::SetSchedNameDirty()
{
	m_fSchedNameChanged = TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEditSchedPage::ShowSchedName()
//
//  PURPOSE:  change the task's sched name
//
//	COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
BOOL CEditSchedPage::ShowSchedName()
{

	Assert(m_pISyncSched);
#ifndef _UNICODE
	TCHAR pszSchedName[MAX_PATH + 1];
#endif // _UNICODE
	WCHAR pwszSchedName[MAX_PATH + 1];
	DWORD dwSize = MAX_PATH;
	
	HWND hwndEdit = GetDlgItem(m_hwnd, IDC_SCHED_NAME_EDITBOX);
		
	if (FAILED(m_pISyncSched->GetScheduleName(&dwSize, pwszSchedName)))
	{
		return FALSE;
	}

#ifndef _UNICODE
	ConvertString(pszSchedName, pwszSchedName, MAX_PATH);
 	Edit_SetText(hwndEdit, pszSchedName);
#else
        Edit_SetText(hwndEdit, pwszSchedName);
#endif // _UNICODE

	m_fSchedNameChanged = FALSE;
	return TRUE;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEditSchedPage::SetSchedName()
//
//  PURPOSE:  change the task's sched name
//
//	COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
BOOL CEditSchedPage::SetSchedName()
{

	Assert(m_pISyncSched);

	TCHAR pszSchedName[MAX_PATH + 1];
#ifndef _UNICODE
	WCHAR pwszSchedName[MAX_PATH + 1];
#endif // _UNICODE
	DWORD dwSize = MAX_PATH;

	if (m_fSchedNameChanged)
	{
		HWND hwndEdit = GetDlgItem(m_hwnd, IDC_SCHED_NAME_EDITBOX);
		Edit_GetText(hwndEdit, pszSchedName, MAX_PATH);

#ifndef _UNICODE
		ConvertString(pwszSchedName, pszSchedName, MAX_PATH);
 			
		if (S_OK != m_pISyncSched->SetScheduleName(pwszSchedName))
#else
		if (S_OK != m_pISyncSched->SetScheduleName(pszSchedName))
#endif // _UNICODE
		{
		    return FALSE;
		}

                SetStaticString(GetDlgItem(m_hwnd,IDC_SCHED_NAME), pszSchedName);
		PropSheet_SetTitle(GetParent(m_hwnd),0, pszSchedName);		
	}		

	return TRUE;

}

//+--------------------------------------------------------------------------
//
//  Function:   SetStaticString (HWND hwnd, LPTSTR pszString)
//
//  Synopsis:   print out the schedule name in a static text string, with the ... 
//              if necessary
//
//  History:    12-Mar-1998   SusiA   
//
//---------------------------------------------------------------------------
BOOL SetStaticString (HWND hwnd, LPTSTR pszString)
{
    Assert(hwnd);

    Static_SetText(hwnd, pszString);
    
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\invoke.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Invoke.cpp
//
//  Contents:   IOfflineSynchronizeInvoke interface
//
//  Classes:    CSyncMgrSynchronize
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

int CALLBACK SchedWizardPropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam);
DWORD StartScheduler();
IsFriendlyNameInUse(LPTSTR ptszScheduleGUIDName, LPCTSTR ptstrFriendlyName);
IsScheduleNameInUse(LPTSTR ptszScheduleGUIDName);

extern HINSTANCE g_hmodThisDll;
extern UINT      g_cRefThisDll;
extern DWORD     g_dwPlatformId;
extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo, setup by DLLMain.

//+--------------------------------------------------------------
//
//  Class:     CSyncMgrSynchronize
//
//  FUNCTION: CSyncMgrSynchronize::CSyncMgrSynchronize()
//
//  PURPOSE: Constructor
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
CSyncMgrSynchronize::CSyncMgrSynchronize()
{
    TRACE("CSyncMgrSynchronize::CSyncMgrSynchronize()\r\n");

    m_cRef = 1;
    g_cRefThisDll++;
        m_pITaskScheduler = NULL;

}

//+--------------------------------------------------------------
//
//  Class:     CSyncMgrSynchronize
//
//  FUNCTION: CSyncMgrSynchronize::~CSyncMgrSynchronize()
//
//  PURPOSE: Destructor
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
CSyncMgrSynchronize::~CSyncMgrSynchronize()
{
        if (m_pITaskScheduler)
        {
                m_pITaskScheduler->Release();
    }
        g_cRefThisDll--;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::QueryInterface(REFIID riid, LPVOID FAR *ppv)
//
//  PURPOSE:  QI for the CSyncMgrSynchronize
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_IUknown\r\n");

        *ppv = (LPSYNCMGRSYNCHRONIZEINVOKE) this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrSynchronizeInvoke))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_IOfflineSynchronizeInvoke\r\n");

        *ppv = (LPSYNCMGRSYNCHRONIZEINVOKE) this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrRegister))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_ISyncmgrSynchronizeRegister\r\n");

        *ppv = (LPSYNCMGRREGISTER) this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrRegisterCSC))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_ISyncmgrSynchronizeRegisterCSC\r\n");

        *ppv = (LPSYNCMGRREGISTERCSC) this;
    }
    else if (IsEqualIID(riid, IID_ISyncScheduleMgr))
    {
        TRACE("CSyncMgrDllObject::QueryInterface()==>IID_ISyncScheduleMgr\r\n");
        if (SUCCEEDED(InitializeScheduler()))
        {
                *ppv = (LPSYNCSCHEDULEMGR) this;
        }
    }

    if (*ppv)
    {
        AddRef();

        return NOERROR;
    }

    TRACE("CSyncMgrDllObject::QueryInterface()==>Unknown Interface!\r\n");

    return E_NOINTERFACE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::AddRef()
//
//  PURPOSE: Addref the CSyncMgrSynchronize
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSyncMgrSynchronize::AddRef()
{
    TRACE("CSyncMgrSynchronize::AddRef()\r\n");

    return ++m_cRef;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::Release()
//
//  PURPOSE: Release the CSyncMgrSynchronize
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSyncMgrSynchronize::Release()
{
    TRACE("CSyncMgrSynchronize::Release()\r\n");

    if (--m_cRef)
        return m_cRef;

    delete this;

    return 0L;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::UpdateItems(DWORD dwInvokeFlags,
//                              REFCLSID rclsid,DWORD cbCookie,const BYTE *lpCookie)
//
//  PURPOSE:
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

#define SYNCMGRINVOKEFLAGS_MASK (SYNCMGRINVOKE_STARTSYNC | SYNCMGRINVOKE_MINIMIZED)

STDMETHODIMP CSyncMgrSynchronize::UpdateItems(DWORD dwInvokeFlags,
                                REFCLSID rclsid,DWORD cbCookie,const BYTE *lpCookie)
{
HRESULT hr = E_UNEXPECTED;
LPUNKNOWN lpUnk;

     // verify invoke flags are valid
    if (0 != (dwInvokeFlags & ~(SYNCMGRINVOKEFLAGS_MASK)) )
    {
        AssertSz(0,"Invalid InvokeFlags passed to UpdateItems");
        return E_INVALIDARG;
    }

     hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_ALL,IID_IUnknown,(void **) &lpUnk);

    if (NOERROR == hr)
    {
    LPPRIVSYNCMGRSYNCHRONIZEINVOKE pSynchInvoke = NULL;

        hr = lpUnk->QueryInterface(IID_IPrivSyncMgrSynchronizeInvoke,
                (void **) &pSynchInvoke);

        if (NOERROR == hr)
        {
            AllowSetForegroundWindow(ASFW_ANY); // let mobsync.exe come to front if necessary
            hr = pSynchInvoke->UpdateItems(dwInvokeFlags,rclsid,cbCookie,lpCookie);
            pSynchInvoke->Release();
        }


        lpUnk->Release();
    }

    return hr; // review error code
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::UpdateAll()
//
//  PURPOSE:
//
//  History:  27-Feb-98       rogerg        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::UpdateAll()
{
HRESULT hr;
LPUNKNOWN lpUnk;


    // programmatically pull up the choice dialog.

    hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_ALL,IID_IUnknown,(void **) &lpUnk);

    if (NOERROR == hr)
    {
    LPPRIVSYNCMGRSYNCHRONIZEINVOKE pSynchInvoke = NULL;

        hr = lpUnk->QueryInterface(IID_IPrivSyncMgrSynchronizeInvoke,
                (void **) &pSynchInvoke);

        if (NOERROR == hr)
        {
           
            AllowSetForegroundWindow(ASFW_ANY); // let mobsync.exe come to front if necessary

            pSynchInvoke->UpdateAll();
            pSynchInvoke->Release();
        }


        lpUnk->Release();
    }


    return NOERROR; // review error code
}

// Registration implementation

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::RegisterSyncMgrHandler(REFCLSID rclsidHandler,DWORD dwReserved)
//
//  PURPOSE:  Programmatic way of registering handlers
//
//  History:  17-Mar-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize::RegisterSyncMgrHandler(REFCLSID rclsidHandler,
                                                         WCHAR const * pwszDescription,
                                                         DWORD dwSyncMgrRegisterFlags)
{
    if (0 != (dwSyncMgrRegisterFlags & ~(SYNCMGRREGISTERFLAGS_MASK)) )
    {
        AssertSz(0,"Invalid Registration Flags");
        return E_INVALIDARG;
    }

    if (pwszDescription)
    {
        if (IsBadStringPtr(pwszDescription,-1))
        {
            AssertSz(0,"Invalid Registration Description");
            return E_INVALIDARG;
        }
    }
    
    BOOL fFirstRegistration = FALSE;
    HRESULT hr = E_FAIL;

    // on Win9x and NT 4.0 Logoff is not supported so get rid of this flag
    // so don't have to worry about the upgrade case or if flag manages
    // to get set but doesn't showup in UI

    //!!! warning, if you change platform logic must also change
    //  logic for showing logoff checbox in settings dialog
     if ( (VER_PLATFORM_WIN32_WINDOWS == g_OSVersionInfo.dwPlatformId)
                    || (VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId 
                        && g_OSVersionInfo.dwMajorVersion < 5)  )
     {
         dwSyncMgrRegisterFlags &= ~(SYNCMGRREGISTERFLAG_PENDINGDISCONNECT);
     }


    // Add the Handler to the the list
    if ( RegRegisterHandler(rclsidHandler, pwszDescription,dwSyncMgrRegisterFlags, &fFirstRegistration) )
    {
        hr = S_OK;
    }

    return hr;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::RegisterSyncMgrHandler(REFCLSID rclsidHandler,DWORD dwReserved)
//
//  PURPOSE:  Programmatic way of registering handlers
//
//  History:  17-Mar-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

// methods here to support the old IDL since it is no
// longer called it could be removed.
STDMETHODIMP CSyncMgrSynchronize::RegisterSyncMgrHandler(REFCLSID rclsidHandler,
                                                         DWORD dwReserved)
{
    HRESULT hr = RegisterSyncMgrHandler( rclsidHandler, 0, dwReserved );

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::UnregisterSyncMgrHandler(REFCLSID rclsidHandler)
//
//  PURPOSE:  Programmatic way of unregistering handlers
//
//  History:  17-Mar-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize::UnregisterSyncMgrHandler(REFCLSID rclsidHandler,DWORD dwReserved)
{
    if (dwReserved)
    {
        Assert(0 == dwReserved);
        return E_INVALIDARG;
    }

    HRESULT hr = E_FAIL;

    if (RegRegRemoveHandler(rclsidHandler))
    {
        hr = NOERROR;
    }

    return hr;
}


//--------------------------------------------------------------------------------
//
//  member: CSyncMgrSynchronize::GetHandlerRegistrationInfo(REFCLSID rclsidHandler)
//
//  PURPOSE:  Allows Handler to query its registration Status.
//
//  History:  17-Mar-98       rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize::GetHandlerRegistrationInfo(REFCLSID rclsidHandler,LPDWORD pdwSyncMgrRegisterFlags)
{
HRESULT hr = S_FALSE; // review what should be returned if handler not registered

    if (NULL == pdwSyncMgrRegisterFlags)
    {
        Assert(pdwSyncMgrRegisterFlags);
        return E_INVALIDARG;
    }
    
    *pdwSyncMgrRegisterFlags = 0;

    if (RegGetHandlerRegistrationInfo(rclsidHandler,pdwSyncMgrRegisterFlags))
    {
        hr = S_OK;
    }

   return hr;
}


//--------------------------------------------------------------------------------
//
//  member: CSyncMgrSynchronize::GetUserRegisterFlags
//
//  PURPOSE:  Returns current Registry Flags for the User.
//
//  History:  17-Mar-99      rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize:: GetUserRegisterFlags(LPDWORD pdwSyncMgrRegisterFlags)
{

    if (NULL == pdwSyncMgrRegisterFlags)
    {
        Assert(pdwSyncMgrRegisterFlags);
        return E_INVALIDARG;
    }


    return RegGetUserRegisterFlags(pdwSyncMgrRegisterFlags);
}

//--------------------------------------------------------------------------------
//
//  member: CSyncMgrSynchronize::SetUserRegisterFlags
//
//  PURPOSE:  Sets registry flags for the User.
//
//  History:  17-Mar-99     rogerg        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CSyncMgrSynchronize:: SetUserRegisterFlags(DWORD dwSyncMgrRegisterMask,
                                                    DWORD dwSyncMgrRegisterFlags)
{

    if (0 != (dwSyncMgrRegisterMask & ~(SYNCMGRREGISTERFLAGS_MASK)) )
    {
        AssertSz(0,"Invalid Registration Mask");
        return E_INVALIDARG;
    }

    RegSetUserAutoSyncDefaults(dwSyncMgrRegisterMask,dwSyncMgrRegisterFlags);
    RegSetUserIdleSyncDefaults(dwSyncMgrRegisterMask,dwSyncMgrRegisterFlags);

    return NOERROR;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::CreateSchedule(
//                                              LPCWSTR pwszScheduleName,
//                                              DWORD dwFlags,
//                                              SYNCSCHEDULECOOKIE *pSyncSchedCookie,
//                                              ISyncSchedule **ppSyncSchedule)
//
//  PURPOSE: Create a new Sync Schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::CreateSchedule(
                                                LPCWSTR pwszScheduleName,
                                                DWORD dwFlags,
                                                SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                                ISyncSchedule **ppSyncSchedule)
{
        SCODE sc;
        TCHAR ptszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
        TCHAR ptstrFriendlyName[MAX_PATH + 1];
        WCHAR pwszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];

        ITask *pITask;

        Assert(m_pITaskScheduler);

        if ((!pSyncSchedCookie) || (!ppSyncSchedule) || (!pwszScheduleName))
        {
                return E_INVALIDARG;
        }

        *ppSyncSchedule = NULL;

        if (*pSyncSchedCookie == GUID_NULL)
        {
              sc = CoCreateGuid(pSyncSchedCookie);

              if (FAILED(sc))
              {
                  return sc;
              }
        }

        if (FAILED (sc = MakeScheduleName(ptszScheduleGUIDName, pSyncSchedCookie)))
        {
            return sc;
        }

        ConvertString(pwszScheduleGUIDName,ptszScheduleGUIDName,MAX_SCHEDULENAMESIZE);

        //if the schedule name is empty, generate a new unique one
        if (!lstrcmp(pwszScheduleName,L""))
        {
            //this function is the energizer bunny, going and going until success....
            GenerateUniqueName(ptszScheduleGUIDName, ptstrFriendlyName);
        }
        else
        {
            ConvertString(ptstrFriendlyName,(WCHAR *)pwszScheduleName, MAX_PATH);
        }

        
         HRESULT hrFiendlyNameInUse = NOERROR;
         HRESULT hrActivate = NOERROR;

        //see if this friendly name is already in use by one of this user's schedules
        //if it is, ptszScheduleGUIDName will be filled in with the offending Schedules GUID
        if (IsFriendlyNameInUse(ptszScheduleGUIDName, ptstrFriendlyName))
        {
                // update the scheduleguidName with the one we found.d
                ConvertString(pwszScheduleGUIDName,ptszScheduleGUIDName,MAX_SCHEDULENAMESIZE);
                hrFiendlyNameInUse =  SYNCMGR_E_NAME_IN_USE;
        }

        // if we think it is in use try to activate to make sure.
        if (SUCCEEDED(hrActivate = m_pITaskScheduler->Activate(pwszScheduleGUIDName,
                                                                 IID_ITask,
                                                                 (IUnknown **)&pITask)))
        {
                
            pITask->Release();

            //ok, we have the .job but not the reg entry.
            //delete the turd job file.
            
            if (!IsScheduleNameInUse(ptszScheduleGUIDName))
            {
                if (ERROR_SUCCESS != m_pITaskScheduler->Delete(pwszScheduleGUIDName))
                {
                    //Try to force delete of the .job file
                    wcscat(ptszScheduleGUIDName, L".job");
                    RemoveScheduledJobFile(ptszScheduleGUIDName);
                    //trunctate off the .job we just added
                    pwszScheduleGUIDName[wcslen(ptszScheduleGUIDName) -4] = L'\0';
                }
                hrActivate = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
        }

        // if activate failed but we think there is a friendly name in use
        // then update the regkey and return the appropriate info
        // if already one or our schedules return SYNCMGR_E_NAME_IN_USE, if
        // schedule name is being used by someone else return ERROR_ALREADY_EXISTS

        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrActivate)
        {

            // file not found update regValues and continue to create
            RegRemoveScheduledTask(pwszScheduleGUIDName);
            sc = NOERROR;
        }
        else if (NOERROR  != hrFiendlyNameInUse)
        {
            // fill in the out param with the cookie of schedule
            // that already exists.

            // !!!! warning, alters pwszScheduleGUIDName so
            // if don't just return here would have to make a tempvar.
            pwszScheduleGUIDName[GUIDSTR_MAX] = NULL;
            GUIDFromString(pwszScheduleGUIDName, pSyncSchedCookie);

            return SYNCMGR_E_NAME_IN_USE;
        }
        else if (SUCCEEDED(hrActivate))
        {
            return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }

        // Create an in-memory task object.
        if (FAILED(sc = m_pITaskScheduler->NewWorkItem(
               pwszScheduleGUIDName,
               CLSID_CTask,
               IID_ITask,
               (IUnknown **)&pITask)))
        {
                return sc;
        }

        // Make sure the task scheduler service is started
        if (FAILED(sc = StartScheduler()))
        {
                return sc;
        }

        *ppSyncSchedule =  new CSyncSchedule(pITask,ptszScheduleGUIDName,ptstrFriendlyName);

        if (NULL == *ppSyncSchedule)
        {
            return E_OUTOFMEMORY;
        }

        if (FAILED(sc = ((LPSYNCSCHEDULE)(*ppSyncSchedule))->Initialize()))
        {
                (*ppSyncSchedule)->Release();
                pITask->Release();
                *ppSyncSchedule = NULL;
                return sc;
        }
        //NT Only, on win9x, don't set credentials
        if (g_dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
                if (FAILED(sc = ((LPSYNCSCHEDULE)(*ppSyncSchedule))->SetDefaultCredentials()))
                {
                        (*ppSyncSchedule)->Release();
                        pITask->Release();
                        *ppSyncSchedule = NULL;
                        return sc;
                }
        }
        if (FAILED(sc = (*ppSyncSchedule)->SetFlags(dwFlags & SYNCSCHEDINFO_FLAGS_MASK)))
        {
                (*ppSyncSchedule)->Release();
                pITask->Release();
                *ppSyncSchedule = NULL;
                return sc;
        }

        pITask->Release();

        return sc;


}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: CALLBACK SchedWizardPropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam);
//
//  PURPOSE: Callback dialog init procedure the settings property dialog
//
//  PARAMETERS:
//    hwndDlg   - Dialog box window handle
//    uMsg              - current message
//    lParam    - depends on message
//
//--------------------------------------------------------------------------------

int CALLBACK SchedWizardPropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    switch(uMsg)
    {
        case PSCB_INITIALIZED:
        {
            // Load the bitmap depends on color mode
            Load256ColorBitmap();

        }
        break;
        default:
           return FALSE;

    }
    return TRUE;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::LaunchScheduleWizard(
//                                              HWND hParent,
//                                              DWORD dwFlags,
//                                              SYNCSCHEDULECOOKIE *pSyncSchedCookie,
//                                              ISyncSchedule   ** ppSyncSchedule)
//
//  PURPOSE: Launch the SyncSchedule Creation wizard
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::LaunchScheduleWizard(
                                                HWND hParent,
                                                DWORD dwFlags,
                                                SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                                ISyncSchedule   ** ppSyncSchedule)
{
SCODE sc;
BOOL fSaved;
DWORD dwSize = MAX_PATH;
ISyncSchedule *pNewSyncSchedule;
DWORD cRefs;

    if (!ppSyncSchedule)
    {
        Assert(ppSyncSchedule);
        return E_INVALIDARG;
    }

    *ppSyncSchedule  = NULL;

    if (*pSyncSchedCookie == GUID_NULL)
    {
        if (FAILED(sc = CreateSchedule(L"", dwFlags, pSyncSchedCookie,
                                       &pNewSyncSchedule)))
        {
            return sc;
        }

    }
    else
    {
        //Open the schedule passed in
        if (FAILED(sc = OpenSchedule(pSyncSchedCookie,
                                     0,
                                     &pNewSyncSchedule)))
        {
            return sc;
        }
    }

#ifdef _WIZ97FONTS
     //
    // Create the bold fonts.
    //
    
    SetupFonts( g_hmodThisDll, NULL);

#endif // _WIZ97FONTS

    HPROPSHEETPAGE psp [NUM_TASK_WIZARD_PAGES];
    PROPSHEETHEADERA psh;

    memset(psp,0,sizeof(psp));

#ifdef _WIZ97FONTS

    //Welcome Page needs the bold font from this object
    m_apWizPages[0] = new CWelcomePage(g_hmodThisDll, m_hBoldFont,pNewSyncSchedule, &psp[0]);
#else
    m_apWizPages[0] = new CWelcomePage(g_hmodThisDll,pNewSyncSchedule, &psp[0]);

#endif // _WIZ97FONTS


   m_apWizPages[1] = new CSelectItemsPage(g_hmodThisDll, &fSaved, pNewSyncSchedule, &psp[1],
                                                                               IDD_SCHEDWIZ_CONNECTION);
    m_apWizPages[2] = new CSelectDailyPage(g_hmodThisDll, pNewSyncSchedule, &psp[2]);
    m_apWizPages[3] = new CNameItPage(g_hmodThisDll, pNewSyncSchedule, &psp[3]);
    m_apWizPages[4] = new CFinishPage(g_hmodThisDll, pNewSyncSchedule, &psp[4]);



    // Check that all objects and pages could be created
    int i;
    for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
    {
         if (!m_apWizPages[i] || !psp[i])
         {
                sc = E_OUTOFMEMORY;
         }
    }

    // Manually destroy the pages if one could not be created, then exit
    if (FAILED(sc))
    {
         for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
         {
             if (psp[i])
             {
                 DestroyPropertySheetPage(psp[i]);
             }
             else if (m_apWizPages[i])
             {
                 delete m_apWizPages[i];
             }

         }

        pNewSyncSchedule->Release();
        return sc;
    }

     // All pages created, display the wizard
    ZeroMemory(&psh, sizeof(PROPSHEETHEADERA));

    psh.dwSize = sizeof (PROPSHEETHEADERA);
    psh.dwFlags = PSH_WIZARD;
    psh.hwndParent = hParent;
    psh.hInstance = g_hmodThisDll;
    psh.pszIcon = NULL;
    psh.phpage = psp;
    psh.nPages = NUM_TASK_WIZARD_PAGES;
    psh.pfnCallback = SchedWizardPropSheetProc;
    psh.nStartPage = 0;



    if (-1 == PropertySheetA(&psh))
    {
        sc = E_UNEXPECTED;
    }

    for (i = 0; i < NUM_TASK_WIZARD_PAGES; i++)
    {
        delete m_apWizPages[i];
    }

#ifdef _WIZ97FONTS

        //
    // Destroy the fonts that were created.
    //
    DestroyFonts();

#endif // _WIZ97FONTS


    if (SUCCEEDED(sc))
    {
        if (fSaved)
        {
            *ppSyncSchedule = pNewSyncSchedule;
            (*ppSyncSchedule)->AddRef();
            sc = NOERROR;
        }
        else
        {
            sc = S_FALSE;
        }
    }

  
    cRefs = pNewSyncSchedule->Release();

    Assert( (NOERROR == sc) || (0 == cRefs && NULL == *ppSyncSchedule));

    return sc;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::SetupFonts(HINSTANCE hInstance, HWND hwnd)
//
//  PURPOSE:  Setup the bold fonts
//
//--------------------------------------------------------------------------------

#ifdef _WIZ97FONTS
VOID CSyncMgrSynchronize::SetupFonts(HINSTANCE hInstance, HWND hwnd )
{
    //
        // Create the fonts we need based on the dialog font
    //
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
        LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
        // Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
        BoldLogFont.lfWeight      = FW_BOLD;

    TCHAR FontSizeString[MAX_PATH];
    INT FontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if(!LoadString(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE))
    {
        text to cause a complile error so you read the following comment when this code
        is turned on.
        // on FE Win9x Shell Dialog doesn't map properly, need to
        // use GUI_FONT. Should also review why loading a different font from the 
        // resource and/or wizard97 predefines some fonts in the system
        lstrcpy(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"));
    }

    if(LoadString(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR)))
    {
        FontSize = _tcstoul( FontSizeString, NULL, 10 );
    }
    else
    {
        FontSize = 12;
    }

        HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

        m_hBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
        m_hBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);
    }
}

#endif // _WIZ97FONTS

//+-------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::DestroyFonts()
//
//  PURPOSE:  Destroy the bold fonts
//
//--------------------------------------------------------------------------------

#ifdef _WIZ97FONTS

VOID CSyncMgrSynchronize::DestroyFonts()
{
    if( m_hBigBoldFont )
    {
        DeleteObject( m_hBigBoldFont );
    }

    if( m_hBoldFont )
    {
        DeleteObject( m_hBoldFont );
    }
}

#endif // _WIZ97FONTS


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::OpenSchedule(
//                                              SYNCSCHEDULECOOKIE *pSyncSchedCookie,
//                                              DWORD dwFlags,
//                                              ISyncSchedule **ppSyncSchedule)
//
//  PURPOSE: Open an existing sync schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::OpenSchedule(
                                                SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                                DWORD dwFlags,
                                                ISyncSchedule **ppSyncSchedule)
{
        SCODE sc;

        TCHAR ptszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
#ifndef _UNICODE
        WCHAR pwszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
#else
        WCHAR *pwszScheduleGUIDName;
#endif // _UNICODE
        TCHAR ptstrFriendlyName[MAX_PATH + 1];

        ITask *pITask;

        Assert(m_pITaskScheduler);

        if ((!pSyncSchedCookie) || (!ppSyncSchedule) )
        {
                return E_INVALIDARG;
        }

        *ppSyncSchedule = NULL;

        if (FAILED (sc = MakeScheduleName(ptszScheduleGUIDName, pSyncSchedCookie)))
        {
            return sc;
        }

#ifndef _UNICODE
        ConvertString(pwszScheduleGUIDName,ptszScheduleGUIDName,MAX_SCHEDULENAMESIZE);
#else
        pwszScheduleGUIDName = ptszScheduleGUIDName;
#endif // _UNICODE
        //See if we can find the friendly name in the registry
        if (!RegGetSchedFriendlyName(ptszScheduleGUIDName,ptstrFriendlyName))
        {
            //if we can't find the registry entry, 
            //try to remove any possible turd .job file.
            if (FAILED(sc = m_pITaskScheduler->Delete(pwszScheduleGUIDName)))
            {
                wcscat(pwszScheduleGUIDName, L".job");
                RemoveScheduledJobFile(pwszScheduleGUIDName);
            }
            
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }

        //Try to activate the schedule
        if (FAILED(sc = m_pITaskScheduler->Activate(pwszScheduleGUIDName,
                                                    IID_ITask,
                                                    (IUnknown **)&pITask)))
        {

            // if file not found then update reg info
            if (sc == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                RegRemoveScheduledTask(pwszScheduleGUIDName);
            }

            return sc;
        }

        // Make sure the task scheduler service is started
        if (FAILED(sc = StartScheduler()))
        {
                return sc;
        }

        *ppSyncSchedule =  new CSyncSchedule(pITask,ptszScheduleGUIDName, ptstrFriendlyName);

        if (!(*ppSyncSchedule) || 
            FAILED(sc = ((LPSYNCSCHEDULE)(*ppSyncSchedule))->Initialize()))
        {
                if (*ppSyncSchedule)
                {
                    (*ppSyncSchedule)->Release();
                }
                else
                {
                    sc = E_OUTOFMEMORY;
                }
                pITask->Release();
                *ppSyncSchedule = NULL;
                return sc;
        }

        pITask->Release();

        return sc;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::RemoveSchedule(
//                                              SYNCSCHEDULECOOKIE *pSyncSchedCookie)
//
//  PURPOSE: Remove a sync schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::RemoveSchedule(
                                                SYNCSCHEDULECOOKIE *pSyncSchedCookie)
{
        SCODE sc = S_OK, 
              sc2 = S_OK;
        
        //add 4 to ensure we have room for the .job if necessary
        TCHAR ptszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
#ifndef _UNICODE
        WCHAR pwszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];
#else
        WCHAR *pwszScheduleGUIDName = NULL;
#endif // _UNICODE

        Assert(m_pITaskScheduler);

        if (!pSyncSchedCookie)
        {
                return E_INVALIDARG;
        }

        if (FAILED (sc = MakeScheduleName(ptszScheduleGUIDName, pSyncSchedCookie)))
        {
            return sc;
        }

#ifndef _UNICODE
        ConvertString(pwszScheduleGUIDName,ptszScheduleGUIDName,MAX_SCHEDULENAMESIZE);
#else
        pwszScheduleGUIDName = ptszScheduleGUIDName;
#endif // _UNICODE

        //Try to remove the schedule
        if (ERROR_SUCCESS != (sc2 = m_pITaskScheduler->Delete(pwszScheduleGUIDName)))
        {
            //Try to force delete of the .job file
            wcscat(pwszScheduleGUIDName, L".job");
            RemoveScheduledJobFile(pwszScheduleGUIDName);
            //trunctate off the .job we just added
            pwszScheduleGUIDName[wcslen(pwszScheduleGUIDName) -4] = L'\0';

        }

        //Remove our Registry settings for this schedule
        //Garbage collection, don't propogate error here
        RegRemoveScheduledTask(ptszScheduleGUIDName);

        //If We just transitioned from one schedule to none, unregister now.
        HKEY    hkeySchedSync,
                hKeyUser;
        DWORD   cb = MAX_PATH;
        TCHAR  pszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
        TCHAR   pszSchedName[MAX_PATH + 1];

        hkeySchedSync = RegGetSyncTypeKey(SYNCTYPE_SCHEDULED,KEY_WRITE |  KEY_READ,FALSE);

        if (hkeySchedSync)
        {

            hKeyUser = RegOpenUserKey(hkeySchedSync,KEY_WRITE |  KEY_READ,FALSE,FALSE);

            if (hKeyUser)
            {
            BOOL fRemove = FALSE;

               //if there are no more scedules for this user, remove the user key.
                //Garbage collection, propogate ITaskScheduler->Delete error code in favor of this error.
                if (ERROR_NO_MORE_ITEMS == RegEnumKeyEx(hKeyUser,0,
                    pszSchedName,&cb,NULL,NULL,NULL,NULL))
                {
                    fRemove = TRUE;
                }

                RegCloseKey(hKeyUser);

                if (fRemove)
                {
                    GetDefaultDomainAndUserName(pszDomainAndUser,TEXT("_"),MAX_DOMANDANDMACHINENAMESIZE);

                    RegDeleteKey(hkeySchedSync, pszDomainAndUser);
                }
            }


            cb = MAX_DOMANDANDMACHINENAMESIZE;

            //if there are no more user schedule keys, then no schedules, and unregister
            //Garbage collection, propogate ITaskScheduler->Delete error code in favor of this error.
            if ( ERROR_SUCCESS != (sc = RegEnumKeyEx(hkeySchedSync,0,
                pszDomainAndUser,&cb,NULL,NULL,NULL,NULL)) )
            {
                    RegRegisterForScheduledTasks(FALSE);
            }

            RegCloseKey(hkeySchedSync);

        }
    
        //propogate the error code from the 
        //task scheduler->Delete if no other errors occurred
        return sc2;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncMgrSynchronize::EnumSyncSchedules(
//                                              IEnumSyncSchedules **ppEnumSyncSchedules)
//
//  PURPOSE: Enumerate the sync schedules
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncMgrSynchronize::EnumSyncSchedules(
                                  IEnumSyncSchedules **ppEnumSyncSchedules)
{

        SCODE sc;
        IEnumWorkItems *pEnumWorkItems;

        Assert(m_pITaskScheduler);
        if (!ppEnumSyncSchedules)
        {
            return E_INVALIDARG;
        }

        if (FAILED(sc = m_pITaskScheduler->Enum(&pEnumWorkItems)))
        {
            return sc;
        }

        *ppEnumSyncSchedules =  new CEnumSyncSchedules(pEnumWorkItems, m_pITaskScheduler);

        pEnumWorkItems->Release();

        if (*ppEnumSyncSchedules)
        {
            return sc;
        }
        return E_OUTOFMEMORY;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CCSyncMgrSynchronize::InitializeScheduler()
//
//  PURPOSE:  Initialize the schedule service
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncMgrSynchronize::InitializeScheduler()
{

    SCODE sc;

    if (m_pITaskScheduler)
    {
        return S_OK;
    }

    // Obtain a task scheduler class instance.
    //
    sc = CoCreateInstance(
                CLSID_CTaskScheduler,
                NULL,
                CLSCTX_INPROC_SERVER,
                 IID_ITaskScheduler,
                (VOID **)&m_pITaskScheduler);

    if(FAILED(sc))
    {
        m_pITaskScheduler = NULL;
    }
    return sc;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CCSyncMgrSynchronize::MakeScheduleName(LPTSTR ptstrName, GUID *pCookie)
//
//  PURPOSE: Create the schedule name from the user, domain and GUID
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncMgrSynchronize::MakeScheduleName(LPTSTR ptstrName, GUID *pCookie)
{
SCODE sc = E_UNEXPECTED;
WCHAR wszCookie[GUID_SIZE+1];

    if (*pCookie == GUID_NULL)
    {
        if (FAILED(sc = CoCreateGuid(pCookie)))
        {
            return sc;
        }
    }

    if (StringFromGUID2(*pCookie, wszCookie, GUID_SIZE))
    {
        lstrcpy(ptstrName, wszCookie);
        lstrcat(ptstrName, TEXT("_"));

        GetDefaultDomainAndUserName(ptstrName + GUIDSTR_MAX+1,TEXT("_"),MAX_DOMANDANDMACHINENAMESIZE);
    
        sc = S_OK;
    }

    return sc;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: IsFriendlyNameInUse(LPCTSTR ptszScheduleGUIDName, LPCTSTR ptstrFriendlyName)
//
//  PURPOSE: See if the friendly name is already in use by this user.
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL IsFriendlyNameInUse(LPTSTR ptszScheduleGUIDName,
                                             LPCTSTR ptstrFriendlyName)
{
SCODE sc;
HKEY hKeyUser;
HKEY hkeySchedName;
DWORD dwType = REG_SZ;
DWORD dwDataSize = MAX_PATH * sizeof(TCHAR);
int i = 0;
TCHAR ptstrName[MAX_PATH + 1];
TCHAR ptstrNewName[MAX_PATH + 1];

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        return FALSE;
    }


    while (S_OK == (sc = RegEnumKey( hKeyUser, i++, ptstrName,MAX_PATH)))
    {
        dwDataSize = MAX_PATH * sizeof(TCHAR);

        if (ERROR_SUCCESS != (sc = RegOpenKeyEx (hKeyUser, ptstrName, 0,KEY_READ,
                                  &hkeySchedName)))
        {
            RegCloseKey(hKeyUser);
            return FALSE;
        }

        sc = RegQueryValueEx(hkeySchedName,TEXT("FriendlyName"),NULL, &dwType,
                                         (LPBYTE) ptstrNewName, &dwDataSize);

        if (0 == lstrcmp(ptstrNewName,ptstrFriendlyName))
        {
            lstrcpy(ptszScheduleGUIDName,ptstrName);
            RegCloseKey(hkeySchedName);
            RegCloseKey(hKeyUser);
            return TRUE;
        }

        RegCloseKey(hkeySchedName);
    }

    RegCloseKey(hKeyUser);
    return FALSE;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: IsScheduleNameInUse(LPCTSTR ptszScheduleGUIDName)
//
//  PURPOSE: See if the schedule name is already in use by this user.
//
//  History:  12-Dec-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL IsScheduleNameInUse(LPTSTR ptszScheduleGUIDName)
{
HKEY hKeyUser;
HKEY hkeySchedName;


    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        return FALSE;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(hKeyUser,ptszScheduleGUIDName,0,KEY_READ,
                                            &hkeySchedName))
    {
        RegCloseKey(hKeyUser);
        RegCloseKey(hkeySchedName);
        return TRUE;
    }

    RegCloseKey(hKeyUser);
    return FALSE;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CCSyncMgrSynchronize::GenerateUniqueName(LPCTSTR ptszScheduleGUIDName,
//                                                                                      LPWSTR pwszFriendlyName)
//
//  PURPOSE: Generate a default schedule name.
//
//  History:  14-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
#define MAX_APPEND_STRING_LEN              32

BOOL CSyncMgrSynchronize::GenerateUniqueName(LPTSTR ptszScheduleGUIDName,
                                                                                        LPTSTR ptszFriendlyName)
{
TCHAR *ptszBuf;
TCHAR *ptszBufConvert = NULL;
TCHAR ptszGUIDName[MAX_PATH + 1];
#define MAX_NAMEID 0xffff

        //copy this over because we don't want the check to overwrite the GUID name
        lstrcpy(ptszGUIDName,ptszScheduleGUIDName);

        if (0 == LoadString(g_hmodThisDll,IDS_SYNCMGRSCHED_DEFAULTNAME,ptszFriendlyName,MAX_PATH))
        {
            *ptszFriendlyName = NULL;
            ptszBuf = ptszFriendlyName;
        }
        else
        {
            // set up buf to point to proper strings.
            ptszBuf = ptszFriendlyName + lstrlen(ptszFriendlyName);
        }


        BOOL fMatchFound = FALSE;


        int i=0;
        do
        {
                if (IsFriendlyNameInUse(ptszGUIDName,ptszFriendlyName))
                {
                    // if don't find match adjust buf and setup convert pointer
                    ptszBuf[0] = TEXT(' ');
                    ptszBufConvert = ptszBuf + 1;

                    fMatchFound = TRUE;
                    ++i;
#ifndef _UNICODE
                    _itoa( i, ptszBufConvert, 10 );
#else
                    _itow( i, ptszBufConvert, 10 );
#endif // _UNICODE

		    Assert(i < 100);
                }
                else
                {
                        fMatchFound = FALSE;
                }


        }while (fMatchFound && (i < MAX_NAMEID));

        if (MAX_NAMEID <= i)
        {
            AssertSz(0,"Ran out of NameIds");
            return FALSE;
        }


        return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\invoke.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Invoke.h
//
//  Contents:   IOfflineSynchronizeInvoke interface
//
//  Classes:    CSyncMgrSynchronize
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCMGRINVOKE_
#define _SYNCMGRINVOKE_

#define NUM_TASK_WIZARD_PAGES 5


class CSyncMgrSynchronize : public ISyncMgrSynchronizeInvoke,
                                    public ISyncScheduleMgr,
                                   // public ISyncMgrRegister, // base class of ISyncMgrRegisterCSC
                                    public IOldSyncMgrRegister, // can remove next ship since never went out except in beta
                                    public ISyncMgrRegisterCSC
{
public:
        CSyncMgrSynchronize();
        ~CSyncMgrSynchronize();

        //IUnknown members
        STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
        STDMETHODIMP_(ULONG)    AddRef();
        STDMETHODIMP_(ULONG)    Release();

        // IOfflineSynchronizeInvoke methods
        STDMETHODIMP UpdateItems(DWORD dwInvokeFlags,REFCLSID rclsid,DWORD cbCookie,const BYTE *lpCookie);
        STDMETHODIMP UpdateAll();

        // ISyncMgrRegister methods
        STDMETHODIMP RegisterSyncMgrHandler(REFCLSID rclsidHandler,
                                            WCHAR const *pwszDescription,
                                            DWORD dwSyncMgrRegisterFlags);

        STDMETHODIMP UnregisterSyncMgrHandler(REFCLSID rclsidHandler,DWORD dwReserved);

        STDMETHODIMP GetHandlerRegistrationInfo(REFCLSID rclsidHandler,LPDWORD pdwSyncMgrRegisterFlags);

        // ISyncMgrRegisterCSC private methods

        STDMETHODIMP GetUserRegisterFlags(LPDWORD pdwSyncMgrRegisterFlags);
        STDMETHODIMP SetUserRegisterFlags(DWORD dwSyncMgrRegisterMask,DWORD dwSyncMgrRegisterFlags);

        // old idl, remove when get a chance.
        // IOldSyncMgrRegister method
        STDMETHODIMP RegisterSyncMgrHandler(REFCLSID rclsidHandler,
                                            DWORD dwReserved);

        // ISyncScheduleMgr methods
        STDMETHODIMP CreateSchedule(
                                                LPCWSTR pwszScheduleName,
                                                DWORD dwFlags,
                                                SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                                ISyncSchedule **ppSyncSchedule);

        STDMETHODIMP LaunchScheduleWizard(
                                                HWND hParent,
                                                DWORD dwFlags,
                                                SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                                ISyncSchedule   ** ppSyncSchedule);

        STDMETHODIMP OpenSchedule(
                                                SYNCSCHEDULECOOKIE *pSyncSchedCookie,
                                                DWORD dwFlags,
                                                ISyncSchedule **ppSyncSchedule);

        STDMETHODIMP RemoveSchedule(
                                                SYNCSCHEDULECOOKIE *pSyncSchedCookie);

        STDMETHODIMP EnumSyncSchedules(
                                                IEnumSyncSchedules **ppEnumSyncSchedules);

private:
        SCODE   InitializeScheduler();
        SCODE   MakeScheduleName(LPTSTR ptstrName, GUID *pCookie);

        BOOL    GetFriendlyName(LPCTSTR ptszScheduleGUIDName,
                                                LPTSTR ptstrFriendlyName);
        BOOL    GenerateUniqueName(LPTSTR ptszScheduleGUIDName,
                                                                                        LPTSTR ptszFriendlyName);



#ifdef _WIZ97FONTS

        VOID    SetupFonts(HINSTANCE hInstance, HWND hwnd );
        VOID    DestroyFonts();

        HFONT m_hBigBoldFont;
        HFONT m_hBoldFont;
#endif _WIZ97FONTS

        ULONG m_cRef;
        ITaskScheduler     *m_pITaskScheduler;
        CWizPage           *m_apWizPages[NUM_TASK_WIZARD_PAGES];

};
typedef CSyncMgrSynchronize *LPCSyncMgrSynchronize;


#endif // _SYNCMGRINVOKE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\makefile.inc ===
PRIVLIB= $(O)\mobsyncp.lib
$(O)\mobsync.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\mobsyncp.def $(LIBRARY_OBJS)
   -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\mobsyncp.def
$(LIBRARY_OBJS)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\nameit.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       nameit.cxx
//
//  Contents:   Task wizard naming property page implementation.
//
//  Classes:    CNameItPage
//
//  History:    11-21-1997   SusiA 
//
//---------------------------------------------------------------------------

#include "precomp.h"

extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo,
extern LANGID g_LangIdSystem;      // LangId of system we are running on.


CNameItPage *g_pNameItPage = NULL;

extern CSelectDailyPage *g_pDailyPage;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardNameItDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------

BOOL CALLBACK SchedWizardNameItDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{

	switch (uMessage)
	{
		
		case WM_INITDIALOG:         
			{
				if (g_pNameItPage)
					g_pNameItPage->Initialize(hDlg);

				//This handles the 256 color processing init
				//for the .bmp
				InitPage(hDlg,lParam);
			}
            break;

        case WM_PAINT:
            WmPaint(hDlg, uMessage, wParam, lParam);
            break;

        case WM_PALETTECHANGED:
            WmPaletteChanged(hDlg, wParam);
            break;

        case WM_QUERYNEWPALETTE:
            return( WmQueryNewPalette(hDlg) );
            break;

        case WM_ACTIVATE:
            return( WmActivate(hDlg, wParam, lParam) );
            break;

		case WM_DESTROY:
		{
			Unload256ColorBitmap();
		}
		break;

		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{

  				case PSN_KILLACTIVE:
	           		SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					return 1;
					break;

				case PSN_RESET:
					// reset to the original values
	           		SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

 				case PSN_SETACTIVE:
	    			PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
				break;

                case PSN_WIZNEXT:

					if (g_pNameItPage)
					{
						if (!g_pNameItPage->SetScheduleName())
						{
							SchedUIErrorDialog(hDlg, IERR_INVALIDSCHEDNAME);
							// reset to the original values
	           				SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, -1);
							break;
						}
					}
					if (g_pDailyPage)
					{
						g_pDailyPage->SetITrigger();
					}
     				break;

				default:
					return FALSE;
    	}
		break;
		
		default:
			return FALSE;
	}
	return TRUE;   

}
    
    
//+--------------------------------------------------------------------------
//
//  Member:     CNameItPage::CNameItPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   Stole from Task Scheduler wizard
//
//---------------------------------------------------------------------------

CNameItPage::CNameItPage(
    HINSTANCE hinst,
    ISyncSchedule *pISyncSched,
    HPROPSHEETPAGE *phPSP)
{
	ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));

	g_pNameItPage = this;

   	m_psp.dwSize = sizeof (PROPSHEETPAGE);
	m_psp.hInstance = hinst;
        m_psp.dwFlags = PSP_DEFAULT;
	m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDWIZ_NAMEIT);
	m_psp.pszIcon = NULL;
	m_psp.pfnDlgProc = (DLGPROC) SchedWizardNameItDlgProc;
	m_psp.lParam = 0;

	m_pISyncSched = pISyncSched;
	m_pISyncSched->AddRef();

#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

   *phPSP = CreatePropertySheetPage(&m_psp);


}

//+--------------------------------------------------------------------------
//
//  Member:     CNameItPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the name it page and set the task name to a unique 
//				new onestop name
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CNameItPage::Initialize(HWND hwnd)
{
	WCHAR pwszNewName[MAX_PATH+1];
#ifndef _UNICODE
	TCHAR ptszNewName[MAX_PATH+1];
#else
	TCHAR *ptszNewName;
#endif // _UNICODE
	DWORD dwSize = MAX_PATH;
	m_hwnd = hwnd;

	m_pISyncSched->GetScheduleName(&dwSize, pwszNewName);

#ifndef _UNICODE
	ConvertString(ptszNewName, pwszNewName, MAX_PATH);
#else
        ptszNewName = pwszNewName;
#endif
		
	HWND hwndEdit = GetDlgItem(m_hwnd, IDC_NAMEIT);

        // IE5 doesn't setup edit controls properly, review
        SetCtrlFont(hwndEdit,g_OSVersionInfo.dwPlatformId,g_LangIdSystem);

         // set the limit on the edit box for entering the name
        SendMessage(hwndEdit,EM_SETLIMITTEXT,MAX_PATH,0);

	Edit_SetText(hwndEdit, ptszNewName);

	return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member:     BOOL CNameItPage::SetScheduleName()
//
//  Synopsis:   create a new schedule 
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CNameItPage::SetScheduleName()
{
WCHAR pwszNewName[MAX_PATH+1];
HWND hwndEdit = GetDlgItem(m_hwnd, IDC_NAMEIT);

	Edit_GetText(hwndEdit, pwszNewName, MAX_PATH);

    if (S_OK == m_pISyncSched->SetScheduleName(pwszNewName))
	{
		return TRUE;
	}
	return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\precomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       prcomp.h
//
//  Contents:   precompiled headers
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------


// Ensur Version 400 is defined
//

#ifndef WINVER
#define WINVER 0x400
#elif WINVER < 0x400
#undef WINVER
#define WINVER 0x400
#endif

// standard includes for  MobSync lib
#include <objbase.h>
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <atlbase.h>  // for confres
#include <inetreg.h>
#include <advpub.h>
#include <mstask.h>
#include <msterr.h>

#include <mobsync.h>
#include <mobsyncp.h>

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "widewrap.h"
#include "stringc.h"
#include "smartptr.hxx"
#include "xarray.hxx"
#include "osdefine.h"

#include "validate.h"
#include "netapi.h"
#include "listview.h"
#include "util.hxx"
#include "clsobj.h"

// dll include files
#include "resource.h"
#include "resource.hm"
#include "dllsz.h"

#include "cnetapi.h"
#include "rasui.h"

#include "dllreg.h"

#include "hndlrq.h"

// wizard headers.
#include "color256.h"
#include "wizpage.hxx"
#include "editschd.hxx"
#include "daily.hxx"
#include "finish.hxx"
#include "invoke.h"
#include "nameit.hxx"
#include "cred.hxx"
#include "welcome.hxx"
#include "wizsel.hxx"

#include "dll.h"
#include "invoke.h"
#include "schedif.h"

#include "settings.h"


#ifndef LVS_EX_INFOTIP
#define LVS_EX_INFOTIP          0x00000400 // listview does InfoTips
#endif  // LVS_EX_INFOTIP

#ifndef LVM_GETSELECTIONMARK
#define LVM_GETSELECTIONMARK    (LVM_FIRST + 66)
#define ListView_GetSelectionMark(hwnd) \
    (int)SNDMSG((hwnd), LVM_GETSELECTIONMARK, 0, 0)
#endif //  LVM_GETSELECTIONMARK

#define LVIS_STATEIMAGEMASK_CHECK (0x2000)
#define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)

// temporarily define TasManager Flag until in header.
#ifndef TASK_FLAG_RUN_ONLY_IF_LOGGED_ON
#define TASK_FLAG_RUN_ONLY_IF_LOGGED_ON        (0x2000)
#endif // TASK_FLAG_RUN_ONLY_IF_LOGGED_ON



#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\reg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Reg.cpp
//
//  Contents:   Registration routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//                              11-18-97        susia           Added Autosync and user reg key functions
//
//--------------------------------------------------------------------------

#include "precomp.h"

#ifdef _SENS
#include <eventsys.h> // include event system
#include <sens.h>
#include <sensevts.h>
#endif // _SENS

// temporariy define new mstask flag in case hasn't
// propogated to sdk\inc

#ifndef TASK_FLAG_RUN_ONLY_IF_LOGGED_ON
#define TASK_FLAG_RUN_ONLY_IF_LOGGED_ON        (0x2000)
#endif // TASK_FLAG_RUN_ONLY_IF_LOGGED_ON
extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern OSVERSIONINFOA g_OSVersionInfo; 
extern CRITICAL_SECTION g_DllCriticalSection;	// Global Critical Section for this DLL

// only return success on NT 5.0

BOOL GetUserDefaultSecurityAttribs(SECURITY_ATTRIBUTES *psa
                                          ,PSECURITY_DESCRIPTOR psd,
                                           PACL *ppOutAcl)
{
BOOL bRetVal;
int cbAcl;
PACL pAcl = NULL;
PSID pInteractiveUserSid = NULL;
PSID pLocalSystemSid = NULL;
PSID pAdminsSid = NULL;
SID_IDENTIFIER_AUTHORITY LocalSystemAuthority = SECURITY_NT_AUTHORITY;

    *ppOutAcl = NULL;

    bRetVal = FALSE;
   
    // in the structure.

    bRetVal = InitializeSecurityDescriptor(
              psd,                          // Pointer to SD
              SECURITY_DESCRIPTOR_REVISION  // SD revision
              );

    if (!bRetVal)
    {
        AssertSz(0,"Unable to Init SecurityDescriptor");
        goto errRtn;
    }

    // setup acls.

    bRetVal = AllocateAndInitializeSid(
                  &LocalSystemAuthority,      // Pointer to identifier authority
                  1,                    // Count of subauthority
                  SECURITY_INTERACTIVE_RID,   // Subauthority 0
                  0,                    // Subauthority 1
                  0,                    // Subauthority 2
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pInteractiveUserSid            // pointer to pointer to SID
                  );


    if (!bRetVal)
    {
        AssertSz(0,"Alocate sid failed");
        goto errRtn;
    }

    bRetVal = AllocateAndInitializeSid(
                  &LocalSystemAuthority,      // Pointer to identifier authority
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,  
                 0,
                  0,                    // Subauthority 3
                  0,                    // Subauthority 4
                  0,                    // Subauthority 5
                  0,                    // Subauthority 6
                  0,                    // Subauthority 7
                  &pAdminsSid            // pointer to pointer to SID
                  );

    if (!bRetVal)
    {
        AssertSz(0,"Alocate sid failed");
        goto errRtn;
    }


    bRetVal = AllocateAndInitializeSid(
              &LocalSystemAuthority,// Pointer to identifier authority
              1,                    // Count of subauthority
              SECURITY_LOCAL_SYSTEM_RID,   // Subauthority 0
              0,                    // Subauthority 1
              0,                    // Subauthority 2
              0,                    // Subauthority 3
              0,                    // Subauthority 4
              0,                    // Subauthority 5
              0,                    // Subauthority 6
              0,                    // Subauthority 7
              &pLocalSystemSid      // pointer to pointer to SID
              );

    if (!bRetVal)
    {
        AssertSz(0,"Alocate sid failed");
        goto errRtn;
    }

    cbAcl =   sizeof (ACL)
        + 3 * sizeof (ACCESS_ALLOWED_ACE)
        + GetLengthSid(pInteractiveUserSid)
        + GetLengthSid(pLocalSystemSid)
        + GetLengthSid(pAdminsSid);
 
    pAcl = (PACL) new char[cbAcl];

    if (NULL == pAcl)
    {
        bRetVal = FALSE;

        AssertSz(0,"unable to alloc ACL");
        goto errRtn;
    }

    bRetVal = InitializeAcl(
              pAcl,             // Pointer to the ACL
              cbAcl,            // Size of ACL
              ACL_REVISION      // Revision level of ACL
              );

    if (!bRetVal)
    {
        AssertSz(0,"InitAcl failed");
        goto errRtn;
    }


    bRetVal = AddAccessAllowedAce(
              pAcl,             // Pointer to the ACL
              ACL_REVISION,     // ACL revision level
              SPECIFIC_RIGHTS_ALL | GENERIC_READ | DELETE ,    // Access Mask
              pInteractiveUserSid         // Pointer to SID
              );

    if (!bRetVal)
    {
        AssertSz(0,"AddAccessAllowed Failed");
        goto errRtn;
    }


    bRetVal = AddAccessAllowedAce(
          pAcl,             // Pointer to the ACL
          ACL_REVISION,     // ACL revision level
          GENERIC_ALL,    // Access Mask
          pAdminsSid         // Pointer to SID
          );

   if (!bRetVal)
    {
        AssertSz(0,"AddAccessAllowed Failed");
        goto errRtn;
    }

    bRetVal = AddAccessAllowedAce(
              pAcl,             // Pointer to the ACL
              ACL_REVISION,     // ACL revision level
              GENERIC_ALL,    // Access Mask
              pLocalSystemSid         // Pointer to SID
              );

    if (!bRetVal)
    {
        AssertSz(0,"AddAccessAllowed Failed");
        goto errRtn;
    }

    bRetVal =  SetSecurityDescriptorDacl(psd,TRUE,pAcl,FALSE);

    if (!bRetVal)
    {
        AssertSz(0,"SetSecurityDescirptorDacl Failed");
        goto errRtn;
    }

    psa->nLength = sizeof(SECURITY_ATTRIBUTES);
    psa->lpSecurityDescriptor = psd;
    psa->bInheritHandle = FALSE;

errRtn:

    if (pInteractiveUserSid)
    {
        FreeSid(pInteractiveUserSid); 
    }

    if (pLocalSystemSid)
    {
        FreeSid(pLocalSystemSid);   
    }

    if (pAdminsSid)
    {
        FreeSid(pAdminsSid);
    }
    
    //
    // On failure, we clean the ACL up. On success, the caller cleans
    // it up after using it.
    //
    if (FALSE == bRetVal)
    {
        if (pAcl)
        {
            delete pAcl;
        }
    }
    else
    {
        Assert(pAcl);
        *ppOutAcl = pAcl;
    }

    return bRetVal;
}

const WCHAR SZ_USERSIDKEY[] = TEXT("SID");

// calls regOpen or create based on fCreate param


LONG RegGetKeyHelper(HKEY hkey,LPCWSTR pszKey,REGSAM samDesired,BOOL fCreate,
                        HKEY *phkResult,DWORD *pdwDisposition)
{
LONG lRet = -1;

    Assert(pdwDisposition);

    *pdwDisposition = 0; 
 
    if (fCreate)
    {
        lRet = RegCreateKeyEx(hkey,pszKey,0,NULL,REG_OPTION_NON_VOLATILE,
                        samDesired,NULL,phkResult,pdwDisposition);  
    }
    else
    {
        lRet = RegOpenKeyEx(hkey,pszKey,0,samDesired,phkResult);
        
        if (ERROR_SUCCESS == lRet)
        {
            *pdwDisposition = REG_OPENED_EXISTING_KEY; 
        }

    }

    return lRet;
}



// called to create a new UserKey or subkey
LONG RegCreateUserSubKey(
    HKEY hKey,
    LPCWSTR lpSubKey,
    REGSAM samDesired,
    PHKEY phkResult)
{
LONG lRet;
DWORD dwDisposition;

    lRet = RegCreateKeyEx(hKey,lpSubKey,0,NULL,REG_OPTION_NON_VOLATILE,
                    samDesired,NULL,phkResult,&dwDisposition);    

    if (VER_PLATFORM_WIN32_NT  == g_OSVersionInfo.dwPlatformId)
    {
        // !! if subkey contains \\ don't traverse back through the list

        if ( (ERROR_SUCCESS == lRet) && (REG_CREATED_NEW_KEY == dwDisposition))
        {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;

            if (ERROR_SUCCESS == RegOpenKeyEx(hKey,
	        lpSubKey,
	        REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
            {
                if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
                {

                    RegSetKeySecurity(hKeySecurity,
                            (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                            &sd);
        
                    delete pOutAcl;
                }

                RegCloseKey(hKeySecurity);
            }

        }
    }
    
    
    return lRet;
}


STDAPI_(HKEY) RegOpenUserKey(HKEY hkeyParent,REGSAM samDesired,BOOL fCreate,BOOL fCleanReg)
{
TCHAR  pszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
HKEY hKeyUser;
BOOL fSetUserSid = FALSE;
WCHAR szUserSID[MAX_PATH + 1];
DWORD dwType;
DWORD dwDisposition;
LONG ret;


    GetDefaultDomainAndUserName(pszDomainAndUser,TEXT("_"),MAX_DOMANDANDMACHINENAMESIZE);

    // If suppose to clean the settings for the user/ delete the key
    if (fCleanReg)
    {
        RegDeleteKeyNT(hkeyParent,pszDomainAndUser); 
    }


    if (ERROR_SUCCESS != (ret = RegGetKeyHelper(hkeyParent,pszDomainAndUser,samDesired,fCreate,
                                        &hKeyUser,&dwDisposition)))
    {
        hKeyUser = NULL;
    }
    // On NT 5.0 Verify sid matches and if doesn't blow away any settings.
    // then create again.

    if (hKeyUser && (VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId))
    {
    WCHAR   szRegSID[MAX_PATH + 1];
    DWORD  dwDataSize;

        dwDataSize = ARRAY_SIZE(szRegSID);
        if (ERROR_SUCCESS !=RegQueryValueEx(hKeyUser,
                            SZ_USERSIDKEY,NULL, &dwType, 
                            (LPBYTE) szRegSID, &dwDataSize))
        {
            fSetUserSid = TRUE; 
            
            // if have to set the sid need to make sure openned
            // with set Value and if didn't close key and 
            // let create re-open it with the desired access.
            
            if (!(samDesired & KEY_SET_VALUE))
            {
                RegCloseKey(hKeyUser);
                hKeyUser = NULL;
            }

        }
        else
        {
            dwDataSize = ARRAY_SIZE(szUserSID);
            if (GetUserTextualSid(szUserSID, &dwDataSize))
            {
                if (lstrcmp(szRegSID, szUserSID))
                {
                    // if don't have access privledges
                    // to delete the User this will fail.
                    // may want a call into SENS to delete the
                    // User Key on Failure.
                    RegCloseKey(hKeyUser);
                    hKeyUser = NULL; // set to NULL so check below fails.
                    RegDeleteKeyNT(hkeyParent,pszDomainAndUser); 
                }
            }
        }
    }


    if (NULL == hKeyUser)
    {

        if (ERROR_SUCCESS != (ret = RegGetKeyHelper(hkeyParent,pszDomainAndUser,
                                        samDesired,fCreate,
                                        &hKeyUser,&dwDisposition)))
        {
            hKeyUser = NULL;
        }
        else
        {
            if (REG_CREATED_NEW_KEY == dwDisposition)
            {
                fSetUserSid = TRUE;
            }
        }
    }

    // on creation setup the security
    if (VER_PLATFORM_WIN32_NT  == g_OSVersionInfo.dwPlatformId)
    {

        if ( (ERROR_SUCCESS == ret) && (REG_CREATED_NEW_KEY == dwDisposition))
        {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;

            // !! should have own call for  sync type key security
            if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent,pszDomainAndUser,
	        REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
            {
                if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
                {

                    RegSetKeySecurity(hKeySecurity,
                            (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                            &sd);
        
                    delete pOutAcl;
                }

                RegCloseKey(hKeySecurity);
            }
        }
    }


    // setup the User sid.
    // depends on key being openned with KEY_SET_VALUE
    if (hKeyUser && fSetUserSid && (VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId)
        && (samDesired & KEY_SET_VALUE))
    {
    WCHAR szUserSID[MAX_PATH + 1];
    DWORD dwDataSize;

        dwDataSize = ARRAY_SIZE(szUserSID);

        if (GetUserTextualSid(szUserSID, &dwDataSize))
        {
        DWORD dwType = REG_SZ;

            RegSetValueEx (hKeyUser,SZ_USERSIDKEY,NULL,
                        dwType,
                        (LPBYTE) szUserSID,
                        (lstrlen(szUserSID) + 1)*sizeof(WCHAR));
        }

    }


    return hKeyUser;

}

STDAPI_(HKEY) RegGetSyncTypeKey(DWORD dwSyncType,REGSAM samDesired,BOOL fCreate)
{
HKEY hKeySyncType;
LPCWSTR pszKey;
LONG ret;
DWORD dwDisposition;

    // get appropriate key to open based on sync type
    
    switch(dwSyncType)
    {
    case SYNCTYPE_MANUAL:
        pszKey = MANUALSYNC_REGKEY;
        break;
    case SYNCTYPE_AUTOSYNC:
        pszKey = AUTOSYNC_REGKEY;
        break;
    case SYNCTYPE_IDLE:
        pszKey = IDLESYNC_REGKEY;
        break;
    case SYNCTYPE_SCHEDULED:
        pszKey = SCHEDSYNC_REGKEY;
        break;
    case SYNCTYPE_PROGRESS:
        pszKey = PROGRESS_REGKEY;
        break;
    default:
        AssertSz(0,"Unknown SyncType");
        pszKey = NULL;
        break;
    }

    if (NULL == pszKey)
    {
        return NULL;
    }

    // first try to open the existing key
    if (ERROR_SUCCESS != (ret = RegGetKeyHelper(HKEY_LOCAL_MACHINE,pszKey,samDesired,fCreate,
                            &hKeySyncType,&dwDisposition)))
    {
        // if can't open key try to create 

        if (ERROR_ACCESS_DENIED == ret )
        {
            // if access denied, call sens to reset
            // the security on the topelevel keys.
            SyncMgrExecCmd_ResetRegSecurity();

            ret = RegGetKeyHelper(HKEY_LOCAL_MACHINE,pszKey,samDesired,fCreate,
                                        &hKeySyncType,&dwDisposition);        
        }

        if (ERROR_SUCCESS != ret)
        {
            hKeySyncType = NULL;
        }
    }

    if (VER_PLATFORM_WIN32_NT  == g_OSVersionInfo.dwPlatformId)
    {

        if ( (ERROR_SUCCESS == ret) && (REG_CREATED_NEW_KEY == dwDisposition))
        {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;

            // !! should have own call for  sync type key security
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,pszKey,
	        REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
            {
                if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
                {

                    RegSetKeySecurity(hKeySecurity,
                            (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                            &sd);
        
                    delete pOutAcl;
                }

                RegCloseKey(hKeySecurity);
            }
        }
    }

    return hKeySyncType;
}


STDAPI_(HKEY) RegGetCurrentUserKey(DWORD dwSyncType,REGSAM samDesired,BOOL fCreate)
{
HKEY hKeySyncType;
HKEY hKeyUser = NULL;

    hKeySyncType = RegGetSyncTypeKey(dwSyncType,samDesired ,fCreate);

    if (hKeySyncType)
    {
        hKeyUser =  RegOpenUserKey(hKeySyncType,samDesired,fCreate,FALSE /* fClean */);
        RegCloseKey(hKeySyncType);
    }

    return hKeyUser;
}


// tries to open and set security if necessary on the handler keys.

STDAPI_(HKEY) RegGetHandlerTopLevelKey(REGSAM samDesired)
{
HKEY hKeyTopLevel;
LONG ret;
DWORD dwDisposition;

    // if open failed then try a create.
    if (ERROR_SUCCESS != (ret = RegCreateKeyEx (HKEY_LOCAL_MACHINE,HANDLERS_REGKEY,0, NULL,
                                   REG_OPTION_NON_VOLATILE,samDesired,NULL,
                                   &hKeyTopLevel,
                                   &dwDisposition)))
    {

        // if got an access denige on the handlers key 
        // call sens to reset.
        if (ERROR_ACCESS_DENIED == ret )
        {
            // if access denied, call sens to reset
            // the security on the topelevel keys.
            // and try again
            SyncMgrExecCmd_ResetRegSecurity();

            ret =  RegCreateKeyEx (HKEY_LOCAL_MACHINE,HANDLERS_REGKEY,0, NULL,
                               REG_OPTION_NON_VOLATILE,samDesired,NULL,
                               &hKeyTopLevel,
                               &dwDisposition);
        }

        if (ERROR_SUCCESS != ret)
        {
            hKeyTopLevel = NULL;
        }
    }

    if (VER_PLATFORM_WIN32_NT  == g_OSVersionInfo.dwPlatformId)
    {

        if ( (ERROR_SUCCESS == ret) && (REG_CREATED_NEW_KEY == dwDisposition))
        {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;

            // !! should have own call for toplevel handler key security
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
	        HANDLERS_REGKEY,
	        REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
            {
                if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
                {

                    RegSetKeySecurity(hKeySecurity,
                            (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                            &sd);
        
                    delete pOutAcl;
                }

                RegCloseKey(hKeySecurity);
            }
        }
    }

    return hKeyTopLevel;

}

STDAPI_(HKEY) RegGetHandlerKey(HKEY hkeyParent,LPCWSTR pszHandlerClsid,REGSAM samDesired,
                                        BOOL fCreate)
{
HKEY hKeyHandler = NULL;
LRESULT lRet;
DWORD dwDisposition;


    if (ERROR_SUCCESS != (lRet = RegGetKeyHelper(hkeyParent,pszHandlerClsid,samDesired,
                            fCreate,&hKeyHandler,&dwDisposition)))
    {
        hKeyHandler = NULL;
    }

    if (NULL == hKeyHandler)
    {

        // if got an access denied call sens to unlock
        if (ERROR_ACCESS_DENIED == lRet )
        {
            // if access denied, call sens to reset
            // the security on the topelevel keys.
            // and try again
            SyncMgrExecCmd_ResetRegSecurity();

            lRet = RegGetKeyHelper(hkeyParent,pszHandlerClsid,samDesired,
                            fCreate,&hKeyHandler,&dwDisposition);
        }

        if (ERROR_SUCCESS != lRet)
        {
            hKeyHandler = NULL;
        }

    }


    if (VER_PLATFORM_WIN32_NT  == g_OSVersionInfo.dwPlatformId)
    {

        if ( (ERROR_SUCCESS == lRet) && (REG_CREATED_NEW_KEY == dwDisposition))
        {
        HKEY hKeySecurity;
        SECURITY_ATTRIBUTES sa;
        SECURITY_DESCRIPTOR sd;
        PACL pOutAcl;

            // !! should have own call for  handler key security
            if (ERROR_SUCCESS == RegOpenKeyEx(hkeyParent,
	        pszHandlerClsid,
	        REG_OPTION_OPEN_LINK, WRITE_DAC,&hKeySecurity) )
            {
                if (GetUserDefaultSecurityAttribs(&sa,&sd,&pOutAcl))
                {

                    RegSetKeySecurity(hKeySecurity,
                            (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                            &sd);
        
                    delete pOutAcl;
                }

                RegCloseKey(hKeySecurity);
            }
        }
    }

    return hKeyHandler;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: DWORD RegDeleteKeyNT(HKEY hStartKey , LPTSTR pKeyName )

  Summary:  Recursively delete a key on NT

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/


STDAPI_(DWORD) RegDeleteKeyNT(HKEY hStartKey , LPCWSTR pKeyName )
{
   DWORD   dwRtn, dwSubKeyLength;
   LPTSTR  pSubKey = NULL;
   TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
   HKEY    hkey;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

   // do not allow NULL or empty key name
   if ( pKeyName &&  lstrlen(pKeyName))
   {
      if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
         0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hkey )) == ERROR_SUCCESS)
      {
         while (dwRtn == ERROR_SUCCESS )
         {
            dwSubKeyLength = MAX_KEY_LENGTH;
            dwRtn=RegEnumKeyEx(
                           hkey,
                           0,       // always index zero
                           szSubKey,
                           &dwSubKeyLength,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                         );

            if(dwRtn == ERROR_NO_MORE_ITEMS)
            {
               dwRtn = RegDeleteKey(hStartKey, pKeyName);
               break;
            }
            else if(dwRtn == ERROR_SUCCESS)
               dwRtn=RegDeleteKeyNT(hkey, szSubKey);
         }
         RegCloseKey(hkey);
         // Do not save return code because error
         // has already occurred
      }
   }
   else
      dwRtn = ERROR_BADKEY;

   CMutexRegistry.Leave();
   return dwRtn;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetProgressDetailsState()

  Summary:  Gets the expanded or collapsed user preference for the progress dialog
            and the pushpin preference

  Returns:  Returns TRUE if succeeded, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegGetProgressDetailsState(REFCLSID clsidDlg,BOOL *pfPushPin, BOOL *pfExpanded)
{
SCODE   sc = S_FALSE;
HKEY    hkeyUserProgress,hkeyclsidDlg;
DWORD   dwType = REG_DWORD ;
DWORD   dwDataSize = sizeof(DWORD);
WCHAR  wszCLSID[GUID_SIZE + 1];

    if (0 == StringFromGUID2(clsidDlg, wszCLSID, GUID_SIZE))
    {
        AssertSz(0,"Unable to make Guid a String");
        return FALSE;
    }

    //Prgress dialog defaults to collapsed, pushpin out
    *pfExpanded = FALSE;
    *pfPushPin = FALSE;

    hkeyUserProgress = RegGetCurrentUserKey(SYNCTYPE_PROGRESS,KEY_READ,FALSE);
    
    if (hkeyUserProgress)
    {
       
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyUserProgress,wszCLSID,0,KEY_READ,
                                                                        &hkeyclsidDlg))
        {
            RegQueryValueEx(hkeyclsidDlg,TEXT("Expanded"),NULL, &dwType,
                                                     (LPBYTE) pfExpanded,
                                                     &dwDataSize);
            dwType = REG_DWORD ;
            dwDataSize = sizeof(DWORD);

            RegQueryValueEx(hkeyclsidDlg,TEXT("PushPin"),NULL, &dwType,
                                                     (LPBYTE) pfPushPin,
                                                     &dwDataSize);
            RegCloseKey(hkeyclsidDlg);

            sc = S_OK;
        }


        RegCloseKey(hkeyUserProgress);
    }

    if (sc == S_OK)
        return TRUE;
    else 
        return FALSE;

}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetProgressDetailsState(BOOL fExpanded)

  Summary:  Sets the expanded or collapsed user preference for the progress dialog

  Returns:  Returns TRUE if succeeded, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegSetProgressDetailsState(REFCLSID clsidDlg,BOOL fPushPin, BOOL fExpanded)
{
BOOL fResult = FALSE;
HKEY  hkeyUserProgress,hkeyclsidDlg;
WCHAR  wszCLSID[GUID_SIZE + 1];


    if (0 == StringFromGUID2(clsidDlg, wszCLSID, GUID_SIZE))
    {
        AssertSz(0,"Unable to make Guid a String");
        return FALSE;
    }

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    hkeyUserProgress = RegGetCurrentUserKey(SYNCTYPE_PROGRESS,KEY_WRITE | KEY_READ,TRUE);

    if (hkeyUserProgress)
    {

        if (ERROR_SUCCESS == RegCreateUserSubKey(hkeyUserProgress,wszCLSID,
                                                                  KEY_WRITE | KEY_READ,
                                                                  &hkeyclsidDlg))
        {
    
            fResult = TRUE;

            if (ERROR_SUCCESS != RegSetValueEx(hkeyclsidDlg,TEXT("Expanded"),NULL, REG_DWORD,
                                          (LPBYTE) &(fExpanded),
                                          sizeof(DWORD)))
            {
                fResult = FALSE;
            }


            if (ERROR_SUCCESS == RegSetValueEx(hkeyclsidDlg,TEXT("PushPin"),NULL, REG_DWORD,
                                          (LPBYTE) &(fPushPin),
                                          sizeof(DWORD)))
            {
                fResult = FALSE;
            }

            RegCloseKey(hkeyclsidDlg);
        }

        RegCloseKey(hkeyUserProgress);

    }
    
    CMutexRegistry.Leave();
    return fResult;

}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetSyncItemSettings( DWORD dwSyncType,
                                                     CLSID clsidHandler,
                                                         SYNCMGRITEMID ItemId,
                                                         const TCHAR *pszConnectionName,
                                                         DWORD *pdwCheckState,
                                                         DWORD dwDefaultCheckState,
                                                         TCHAR *pszSchedName)

  Summary:  Gets the settings per handler, itemID, and connection name.
                        If no selections on this connection, the default is ?

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegGetSyncItemSettings( DWORD dwSyncType,
                                      CLSID clsidHandler,
                                      SYNCMGRITEMID ItemId,
                                      const TCHAR *pszConnectionName,
                                      DWORD *pdwCheckState,
                                      DWORD dwDefaultCheckState,
                                      TCHAR *pszSchedName)
{
HKEY hKeyUser;
    
    *pdwCheckState = dwDefaultCheckState;

    // special case schedule
    if (SYNCTYPE_SCHEDULED == dwSyncType)
    {
        // items are always turned off by default and if no schedule name
        // don't bother.
        *pdwCheckState = FALSE;
        if (!pszSchedName)
        {
            return FALSE;
        }
    }

    // open the user key for the type
    hKeyUser = RegGetCurrentUserKey(dwSyncType,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        return FALSE;
    }

    // for a schedule we need to go ahead and open up the schedule name
    // key

    HKEY hKeySchedule = NULL;

    // Review if want GetCurrentUserKey to Handle this.
    if (SYNCTYPE_SCHEDULED == dwSyncType)
    {
        if (ERROR_SUCCESS != RegOpenKeyEx((hKeyUser),
                                     pszSchedName,0,KEY_READ,
                                     &hKeySchedule))
        {
            hKeySchedule = NULL;
            RegCloseKey(hKeyUser);
            return FALSE;
        }
    }


    BOOL fResult;

    fResult =  RegLookupSettings(hKeySchedule ? hKeySchedule : hKeyUser,
                              clsidHandler,
                              ItemId,
                              pszConnectionName,
                              pdwCheckState);

    if (hKeySchedule)
    {
        RegCloseKey(hKeySchedule);
    }

    if (hKeyUser)
    {
        RegCloseKey(hKeyUser);
    }

    return fResult;
}



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetSyncItemSettings( DWORD dwSyncType,
                                    CLSID clsidHandler,
                                    SYNCMGRITEMID ItemId,
                                    const TCHAR *pszConnectionName,
                                    DWORD dwCheckState,
                                    TCHAR *pszSchedName)

  Summary:  Sets the settings per handler, itemID, and connection name.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegSetSyncItemSettings( DWORD dwSyncType,
                                      CLSID clsidHandler,
                                      SYNCMGRITEMID ItemId,
                                      const TCHAR *pszConnectionName,
                                      DWORD dwCheckState,
                                      TCHAR *pszSchedName)
{
HKEY hKeyUser;


    if (SYNCTYPE_SCHEDULED == dwSyncType)
    {
        if (NULL == pszSchedName)
        {
            return FALSE;
        }
    }

    // open the user key for the type
    hKeyUser = RegGetCurrentUserKey(dwSyncType,KEY_WRITE | KEY_READ,TRUE);

    if (NULL == hKeyUser)
    {
        return FALSE;
    }

    // for a schedule we need to go ahead and open up the schedule name
    // key

    HKEY hKeySchedule = NULL;

    if (SYNCTYPE_SCHEDULED == dwSyncType)
    {
        if (ERROR_SUCCESS != RegCreateUserSubKey(hKeyUser,
                                  pszSchedName,KEY_WRITE |  KEY_READ,
                                  &hKeySchedule))
        {
            hKeySchedule = NULL;
            RegCloseKey(hKeyUser);
            return FALSE;
        }
    }

    BOOL fResult;

    fResult =  RegWriteOutSettings(hKeySchedule ? hKeySchedule : hKeyUser,
                                clsidHandler,
                                ItemId,
                                pszConnectionName,
                                dwCheckState);
  
    if (hKeySchedule)
    {
        RegCloseKey(hKeySchedule);
    }

    if (hKeyUser)
    {
        RegCloseKey(hKeyUser);
    }

    return fResult;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegQueryLoadHandlerOnEvent( )

  Summary:  Determines if there is any reason to load this handler
            for the specified event and Connection

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegQueryLoadHandlerOnEvent(TCHAR *pszClsid,DWORD dwSyncFlags,
                                            TCHAR *pConnectionName)
{
BOOL fLoadHandler = FALSE;
DWORD dwSyncType;

    switch(dwSyncFlags & SYNCMGRFLAG_EVENTMASK)
    {
    case SYNCMGRFLAG_CONNECT:
    case SYNCMGRFLAG_PENDINGDISCONNECT:
        {
            dwSyncType = SYNCTYPE_AUTOSYNC;
        }
        break;
    case SYNCMGRFLAG_IDLE:
        {
            dwSyncType = SYNCTYPE_IDLE;
        }
        break;
    default:
        AssertSz(0,"Unknown SyncType");
        return FALSE;
        break;
    }

    // walk done the list openning keys.
    HKEY hkeySyncType;

    if (hkeySyncType = RegGetCurrentUserKey(dwSyncType,KEY_READ,FALSE))
    {
        HKEY hkeyConnectionName;

        if (ERROR_SUCCESS == RegOpenKeyEx(hkeySyncType,pConnectionName,0,KEY_READ,&hkeyConnectionName))
        {
            HKEY hkeyClsid;

            if (ERROR_SUCCESS == RegOpenKeyEx(hkeyConnectionName,pszClsid,0,KEY_READ,&hkeyClsid))
            {
                DWORD dwType = REG_DWORD;
                DWORD dwDataSize = sizeof(DWORD);
                DWORD fQueryResult;


                if (ERROR_SUCCESS == RegQueryValueEx(hkeyClsid,TEXT("ItemsChecked"),NULL, &dwType, (LPBYTE) &fQueryResult, &dwDataSize))
                {
                    fLoadHandler = fQueryResult;
                }

                RegCloseKey(hkeyClsid);
            }

            RegCloseKey(hkeyConnectionName);
        }

        RegCloseKey(hkeySyncType);
    }


    return fLoadHandler;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetSyncHandlerSettings( )

  Summary:  Sets the handler settings for syncType and Connection.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegSetSyncHandlerSettings(DWORD dwSyncType,
                            const TCHAR *pszConnectionName,
                            CLSID clsidHandler,
                            BOOL  fItemsChecked)
{
HKEY hKeyUser;

    hKeyUser = RegGetCurrentUserKey(dwSyncType,KEY_WRITE |  KEY_READ,TRUE);

    if (NULL == hKeyUser)
    {
        return FALSE;
    }

    SCODE sc;
    HKEY hkeyConnection;
    HKEY hkeyCLSID;
    DWORD dwType = REG_DWORD;
    DWORD dwDataSize = sizeof(DWORD);

    TCHAR    szCLSID[(GUID_SIZE+1)];

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    smChkTo(EH_Err2,RegCreateUserSubKey(hKeyUser,
                                          pszConnectionName,
                                          KEY_WRITE |  KEY_READ,
                                          &hkeyConnection));


    StringFromGUID2(clsidHandler, szCLSID, 2*GUID_SIZE);

    // Write entries under CLSID.
    smChkTo(EH_Err3,RegCreateUserSubKey(hkeyConnection,
                                                  szCLSID,KEY_WRITE |  KEY_READ,
                                                  &hkeyCLSID));

    RegSetValueEx(hkeyCLSID,TEXT("ItemsChecked"),NULL, REG_DWORD,
                              (LPBYTE) &fItemsChecked,
                              sizeof(DWORD));

    RegCloseKey(hKeyUser);
    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeyCLSID);
    CMutexRegistry.Leave();
    return TRUE;

EH_Err3:
        RegCloseKey(hkeyConnection);
EH_Err2:
        RegCloseKey(hKeyUser);

        CMutexRegistry.Leave();
        return FALSE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegLookupSettings(const TCHAR *hkeyName,
                              CLSID clsidHandler,
                              SYNCMGRITEMID ItemID,
                              const TCHAR *pszMachineName,
                              const TCHAR *pszConnectionName,
                              DWORD pdwCheckState)

  Summary:  Gets the settings per handler, itemID, and connection name.

  Returns:  Returns TRUE if there are settings for this item and
                        connection, flase otherwise.

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegLookupSettings(HKEY hKeyUser,
                       CLSID clsidHandler,
                       SYNCMGRITEMID ItemID,
                       const TCHAR *pszConnectionName,
                       DWORD *pdwCheckState)
{
SCODE sc;
HKEY hkeyConnection;
HKEY   hkeyItem;
HKEY hKeyHandler;
DWORD dwType = REG_SZ;
DWORD dwDataSize = MAX_PATH + 1;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    TCHAR    szID[GUID_SIZE+1];
    TCHAR    szCLSID[2*(GUID_SIZE+1)];

    
    dwType = REG_DWORD;
    dwDataSize = sizeof(DWORD);

    smChkTo(EH_Err2,RegOpenKeyEx(hKeyUser,
                                 pszConnectionName,0,KEY_READ,
                                 &hkeyConnection));


    StringFromGUID2(clsidHandler, szCLSID, 2*GUID_SIZE);
    StringFromGUID2(ItemID, szID, GUID_SIZE);

    // Read entries under CLSID.
    smChkTo(EH_Err3,RegOpenKeyEx((hkeyConnection),
                                  szCLSID, 0, KEY_READ,
                                  &hKeyHandler));

    smChkTo(EH_Err4,RegOpenKeyEx((hKeyHandler),
                                  szID, 0, KEY_READ,
                                  &hkeyItem));

    RegQueryValueEx(hkeyItem,TEXT("CheckState"),NULL, &dwType, (LPBYTE)pdwCheckState, &dwDataSize);

    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeyItem);
    RegCloseKey(hKeyHandler);

    CMutexRegistry.Leave();
    return TRUE;

EH_Err4:
    RegCloseKey(hKeyHandler);
EH_Err3:
    RegCloseKey(hkeyConnection);
EH_Err2:
    CMutexRegistry.Leave();
    return FALSE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegWriteOutSettings(const TCHAR *hkeyName,
                                      CLSID clsidHandler,
                                      SYNCMGRITEMID ItemID,
                                      const TCHAR *pszConnectionName,
                                      DWORD dwCheckState)

  Summary:  Sets the settings per handler, itemID, and connection name.

  Returns:  Returns TRUE if we can set them, FALSE if there is an error

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegWriteOutSettings(HKEY hKeyUser,
                         CLSID clsidHandler,
                         SYNCMGRITEMID ItemID,
                         const TCHAR *pszConnectionName,
                         DWORD dwCheckState)
{
SCODE sc;
HKEY    hkeyConnection;
HKEY   hKeyHandler;
HKEY     hkeyItem;
DWORD dwType = REG_SZ;
DWORD dwDataSize = MAX_PATH;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    TCHAR    szID[GUID_SIZE+1];
    TCHAR    szCLSID[2*(GUID_SIZE+1)];

    smChkTo(EH_Err2,RegCreateUserSubKey(hKeyUser,
                                   pszConnectionName,KEY_WRITE |  KEY_READ,
                                   &hkeyConnection));


    StringFromGUID2(clsidHandler, szCLSID, 2*GUID_SIZE);
    StringFromGUID2(ItemID, szID, GUID_SIZE);


    smChkTo(EH_Err3,RegCreateUserSubKey(hkeyConnection,
                               szCLSID,KEY_WRITE |  KEY_READ,
                               &hKeyHandler));


    // Write entries under CLSID.
    smChkTo(EH_Err4,RegCreateUserSubKey(hKeyHandler,
                                   szID,KEY_WRITE |  KEY_READ,
                                   &hkeyItem));


    RegSetValueEx(hkeyItem,TEXT("CheckState"),NULL, REG_DWORD,
                                  (LPBYTE) &dwCheckState,
                                  sizeof(DWORD));

    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeyItem);
    RegCloseKey(hKeyHandler);

    CMutexRegistry.Leave();
    return TRUE;

EH_Err4:
    RegCloseKey(hKeyHandler);
EH_Err3:
    RegCloseKey(hkeyConnection);
EH_Err2:
    CMutexRegistry.Leave();
    return FALSE;
}



/****************************************************************************

  AutoSync Registry Functions

***************************************************************************F-F*/

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetAutoSyncSettings(     LPCONNECTIONSETTINGS lpConnectionSettings)

  Summary:  Gets the logon, logoff and prompt me first user selections.
                        If no selections on this connection, the default is ?

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegGetAutoSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings)
{
SCODE sc;
HKEY hkeyConnection;
DWORD dwType = REG_SZ ;
DWORD dwDataSize = MAX_PATH;


    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();


    // Set these first to default values, in case there are no current
    // user preferences in the registry
    lpConnectionSettings->dwLogon = FALSE;
    lpConnectionSettings->dwLogoff = FALSE;
    lpConnectionSettings->dwPromptMeFirst = FALSE;

    HKEY hKeyUser;

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_AUTOSYNC,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        goto EH_Err;
    }

    dwType = REG_DWORD ;
    dwDataSize = sizeof(DWORD);

    smChkTo(EH_Err3,RegOpenKeyEx(hKeyUser, lpConnectionSettings->pszConnectionName,0,KEY_READ,
                                                            &hkeyConnection));

    RegQueryValueEx(hkeyConnection,TEXT("Logon"),NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->dwLogon),
                                             &dwDataSize);

    dwDataSize = sizeof(DWORD);

    RegQueryValueEx(hkeyConnection,TEXT("Logoff"),NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->dwLogoff),
                                             &dwDataSize);

    dwDataSize = sizeof(DWORD);

    RegQueryValueEx(hkeyConnection,TEXT("PromptMeFirst"),NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->dwPromptMeFirst),
                                             &dwDataSize);

    RegCloseKey(hkeyConnection);
    RegCloseKey(hKeyUser);
    
    CMutexRegistry.Leave();

    return TRUE;


EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err:
    CMutexRegistry.Leave();

    return FALSE;

}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegUpdateUserAutosyncKey

  Summary:  given an Autosync User Key makes sure it is in the latest
            format and if not updates it.

  Returns: 

------------------------------------------------------------------------F-F*/

void RegUpdateUserAutosyncKey(HKEY hkeyUser,BOOL fForce)
{
DWORD   dwType = REG_DWORD ;
DWORD   dwDataSize = sizeof(DWORD);
DWORD   dwUserLogonLogoff;
DWORD dwIndex = 0;
TCHAR lpName[MAX_PATH];
DWORD cbName = MAX_PATH;

DWORD dwLogon = 0;
DWORD dwLogoff = 0;

    if (!fForce && (ERROR_SUCCESS == RegQueryValueEx(hkeyUser,TEXT("Logon"),NULL, &dwType,
                             (LPBYTE) &dwUserLogonLogoff,
                             &dwDataSize)) )
    {
        // if can open Logon Key this is up to date.
        return;
    }

    // need to enum connection names and update the toplevel information.
    while ( ERROR_SUCCESS == RegEnumKey(hkeyUser,dwIndex,
            lpName,cbName) )
    {
    LONG lRet;
    HKEY hKeyConnection;

        lRet = RegOpenKeyEx( hkeyUser,
                             lpName,
                             NULL,
                             KEY_READ,
                             &hKeyConnection );

        if (ERROR_SUCCESS == lRet)
        {

            dwDataSize = sizeof(DWORD);

            if (ERROR_SUCCESS == RegQueryValueEx(hKeyConnection,TEXT("Logon"),NULL, &dwType,
                                     (LPBYTE) &dwUserLogonLogoff,
                                     &dwDataSize) )
            {
                dwLogon |= dwUserLogonLogoff;
            }

            dwDataSize = sizeof(DWORD);

            if (ERROR_SUCCESS == RegQueryValueEx(hKeyConnection,TEXT("Logoff"),NULL, &dwType,
                                     (LPBYTE) &dwUserLogonLogoff,
                                     &dwDataSize) )
            {
                dwLogoff |= dwUserLogonLogoff;
            }

            RegCloseKey(hKeyConnection);
        }

        dwIndex++;
    }

    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.
    RegSetValueEx(hkeyUser,TEXT("Logon"),NULL, REG_DWORD,
                                     (LPBYTE) &(dwLogon), sizeof(DWORD));
    RegSetValueEx(hkeyUser,TEXT("Logoff"),NULL, REG_DWORD,
                                     (LPBYTE) &(dwLogoff), sizeof(DWORD));

    RegWriteTimeStamp(hkeyUser);
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegUpdateAutoSyncKeyValueSettings

  Summary:  walks through the UserList Updating the AutoSync

  Returns: 

------------------------------------------------------------------------F-F*/
void RegUpdateAutoSyncKeyValue(HKEY hkeyAutoSync,DWORD dwLogonDefault,DWORD dwLogoffDefault)
{
DWORD dwIndex = 0;
WCHAR lpName[MAX_PATH];
DWORD cbName = MAX_PATH; 
LONG lRet;
DWORD dwLogon = 0;
DWORD dwLogoff = 0;
BOOL fSetLogon,fSetLogoff;

    // need to walk the autosync user key and set the top level information
    // based on whther someone logon/logoff
    
    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    while ( ERROR_SUCCESS == (lRet = RegEnumKey(hkeyAutoSync,dwIndex,
            lpName,cbName) ))
    {
    DWORD   dwType = REG_DWORD ;
    DWORD   dwDataSize = sizeof(DWORD);
    DWORD   dwUserLogonLogoff;
    HKEY hKeyDomainUser;

        lRet = RegOpenKeyEx( hkeyAutoSync,
                             lpName,
                             NULL,
                             KEY_READ, 
                             &hKeyDomainUser );

        if (ERROR_SUCCESS == lRet)
        {
           
            // If Query fails don't want to count this as a failed to enum
            // error so don't set lRet
            if (ERROR_SUCCESS == (RegQueryValueEx(hKeyDomainUser,TEXT("Logon"),NULL, &dwType,
                                     (LPBYTE) &dwUserLogonLogoff,
                                     &dwDataSize) ))
            {
                dwLogon |= dwUserLogonLogoff;
            }

            dwDataSize = sizeof(DWORD);

            if (ERROR_SUCCESS == lRet)
            {
                if (ERROR_SUCCESS == (RegQueryValueEx(hKeyDomainUser,TEXT("Logoff"),NULL, &dwType,
                                         (LPBYTE) &dwUserLogonLogoff,
                                         &dwDataSize) ) )
                {
                    dwLogoff |= dwUserLogonLogoff;
                }
            }

            RegCloseKey(hKeyDomainUser);
        }

        if (ERROR_SUCCESS != lRet)
        {
            break;
        }

        dwIndex++;
    }

   fSetLogon = FALSE;
   fSetLogoff = FALSE;

    // if an error occured, then use the passed in defaults,
    // if set to 1, else don't set.
    if ( (ERROR_SUCCESS != lRet) && (ERROR_NO_MORE_ITEMS != lRet))
    {
        if ( (-1 != dwLogonDefault) && (0 != dwLogonDefault))
        {
            fSetLogon = TRUE;
            dwLogon = dwLogonDefault;
        }

        if ( (-1 != dwLogoffDefault) && (0 != dwLogoffDefault))
        {
            fSetLogoff = TRUE;
            dwLogoff = dwLogoffDefault;
        }

    }
    else
    {
        fSetLogon = TRUE;
        fSetLogoff = TRUE;
    }

    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.

    if (fSetLogon)
    {
        RegSetValueEx(hkeyAutoSync,TEXT("Logon"),NULL, REG_DWORD,
                                         (LPBYTE) &(dwLogon), sizeof(DWORD));
    }

    if (fSetLogoff)
    {
        RegSetValueEx(hkeyAutoSync,TEXT("Logoff"),NULL, REG_DWORD,
                                         (LPBYTE) &(dwLogoff), sizeof(DWORD));
    }

    RegWriteTimeStamp(hkeyAutoSync);

    CMutexRegistry.Leave();
}



/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegUpdateUserIdleKey

  Summary:  given an Idle User Key makes sure it is in the latest
            format and if not updates it.

  Returns: 

------------------------------------------------------------------------F-F*/

void RegUpdateUserIdleKey(HKEY hkeyUser,BOOL fForce)
{
DWORD   dwType = REG_DWORD ;
DWORD   dwDataSize = sizeof(DWORD);
DWORD   dwUserIdleEnabled;
DWORD dwIndex = 0;
TCHAR lpName[MAX_PATH];
DWORD cbName = MAX_PATH;

DWORD dwIdleEnabled = 0;

    if (!fForce && (ERROR_SUCCESS == RegQueryValueEx(hkeyUser,TEXT("IdleEnabled"),NULL, &dwType,
                             (LPBYTE) &dwUserIdleEnabled,
                             &dwDataSize)) )
    {
        // if can open Logon Key this is up to date.
        return;
    }

    // need to enum connection names and update the toplevel information.
    while ( ERROR_SUCCESS == RegEnumKey(hkeyUser,dwIndex,
            lpName,cbName) )
    {
    LONG lRet;
    HKEY hKeyConnection;

        lRet = RegOpenKeyEx( hkeyUser,
                             lpName,
                             NULL,
                             KEY_READ,
                             &hKeyConnection );

        if (ERROR_SUCCESS == lRet)
        {

            dwDataSize = sizeof(DWORD);

            if (ERROR_SUCCESS == RegQueryValueEx(hKeyConnection,TEXT("IdleEnabled"),NULL, &dwType,
                                     (LPBYTE) &dwUserIdleEnabled,
                                     &dwDataSize) )
            {
                dwIdleEnabled |= dwUserIdleEnabled;
            }

            RegCloseKey(hKeyConnection);
        }

        dwIndex++;
    }

    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.
    RegSetValueEx(hkeyUser,TEXT("IdleEnabled"),NULL, REG_DWORD,
                                     (LPBYTE) &(dwIdleEnabled), sizeof(DWORD));
    RegWriteTimeStamp(hkeyUser);
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegUpdateIdleKeyValue

  Summary:  walks through the UserList Updating the Idle RegKey

  Returns: 

------------------------------------------------------------------------F-F*/
void RegUpdateIdleKeyValue(HKEY hkeyIdle,DWORD dwDefault)
{
DWORD dwIndex = 0;
WCHAR lpName[MAX_PATH];
DWORD cbName = MAX_PATH; 
DWORD dwIdleEnabled = 0;
LONG  lRet = -1;
BOOL fSetDefault;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    // need to walk the idle user key and set the top level information
    // based on whther someone logon/logoff

    fSetDefault = FALSE;


    while ( ERROR_SUCCESS == (lRet =  RegEnumKey(hkeyIdle,dwIndex,
            lpName,cbName)) )
    {
    DWORD   dwType = REG_DWORD ;
    DWORD   dwDataSize = sizeof(DWORD);
    DWORD   dwUserIdleEnabled;
    HKEY hKeyDomainUser;

        lRet = RegOpenKeyEx( hkeyIdle,
                             lpName,
                             NULL,
                             KEY_READ, 
                             &hKeyDomainUser );

        if (ERROR_SUCCESS == lRet)
        {
            
            // if query fails don't consider this an error as far as
            // setDefault goes.
            if (ERROR_SUCCESS == (RegQueryValueEx(hKeyDomainUser,TEXT("IdleEnabled"),NULL, &dwType,
                                     (LPBYTE) &dwUserIdleEnabled,
                                     &dwDataSize) ))
            {
                dwIdleEnabled |= dwUserIdleEnabled;
            }

            RegCloseKey(hKeyDomainUser);
        }

        if (ERROR_SUCCESS != lRet)
        {
            break;
        }

        dwIndex++;
    }

     // if an error occured, then use the passed in defaults,
    // if set to 1, else don't set.
    if ( (ERROR_SUCCESS != lRet) && (ERROR_NO_MORE_ITEMS != lRet))
    {
        if ( (-1 != dwDefault) && (0 != dwDefault))
        {
            fSetDefault = TRUE;
            dwIdleEnabled = dwDefault;
        }

    }
    else
    {
        fSetDefault = TRUE;
    }


    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.

    if (fSetDefault)
    {
        RegSetValueEx(hkeyIdle,TEXT("IdleEnabled"),NULL, REG_DWORD,
                                         (LPBYTE) &(dwIdleEnabled), sizeof(DWORD));
    }

    RegWriteTimeStamp(hkeyIdle);
    CMutexRegistry.Leave();
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetAutoSyncSettings(     LPCONNECTIONSETTINGS lpConnectionSettings,
                                                                        int iNumConnections)

  Summary:  Sets the logon, logoff and prompt me first user selections.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegSetAutoSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                                              int iNumConnections,
                                                              CRasUI *pRas,
                                                              BOOL fCleanReg,
                                                              BOOL fSetMachineState,
                                                              BOOL fPerUser)
{
SCODE sc = S_OK;
HKEY hAutoSync;
HKEY hKeyUser;
HKEY hkeyConnection;
DWORD dwUserConfigured = 1;
DWORD dwLogonDefault = -1;
DWORD dwLogoffDefault = -1;
int i;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    // make sure keys are converted to newest format
    RegUpdateTopLevelKeys();
    
    Assert(-1 != TRUE); // we rely on TRUE boolean being something other than -1

    hAutoSync =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_WRITE| KEY_READ,TRUE);

    if (NULL == hAutoSync)
    {
        goto EH_Err;
    }

    hKeyUser =  RegOpenUserKey(hAutoSync,KEY_WRITE| KEY_READ,TRUE,fCleanReg);

    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }

    if (fPerUser)
    {
        
        smChkTo(EH_Err3,RegSetValueEx(hKeyUser,TEXT("UserConfigured"),NULL, REG_DWORD,
                                                     (LPBYTE) &dwUserConfigured,
                                                     sizeof(DWORD)));
    }
    else
    {
        DWORD dwType = REG_DWORD;
        DWORD dwDataSize = sizeof(DWORD);
                
        //If this value isn't added yet, 
        if (ERROR_SUCCESS == RegQueryValueEx(hKeyUser,TEXT("UserConfigured"),NULL, &dwType,
                                        (LPBYTE) &dwUserConfigured,
                                        &dwDataSize))
        {
            //if the user setup their configuration, we won't override on a
            //subsequent handler registration.
            if (dwUserConfigured)
            {
                RegCloseKey(hKeyUser);   
                RegCloseKey(hAutoSync);   
                CMutexRegistry.Leave();
                return TRUE; 
            }
        }
    }

    for (i=0; i<iNumConnections; i++)
    {

        smChkTo(EH_Err3,RegCreateUserSubKey (hKeyUser,
                                         lpConnectionSettings[i].pszConnectionName,
                                         KEY_WRITE |  KEY_READ,
                                         &hkeyConnection));


        if (-1 != lpConnectionSettings[i].dwLogon)
        {

            if (0 != lpConnectionSettings[i].dwLogon)
            {
                dwLogonDefault = lpConnectionSettings[i].dwLogon;
            }

            smChkTo(EH_Err4,RegSetValueEx(hkeyConnection,TEXT("Logon"),NULL, REG_DWORD,
                                                     (LPBYTE) &(lpConnectionSettings[i].dwLogon),
                                                     sizeof(DWORD)));
        }

        if (-1 != lpConnectionSettings[i].dwLogoff)
        {

            if (0 != lpConnectionSettings[i].dwLogoff)
            {
                dwLogoffDefault = lpConnectionSettings[i].dwLogoff;
            }

            smChkTo(EH_Err4,RegSetValueEx(hkeyConnection,TEXT("Logoff"),NULL, REG_DWORD,
                                                     (LPBYTE) &(lpConnectionSettings[i].dwLogoff),
                                                     sizeof(DWORD)));
        }


        if (-1 != lpConnectionSettings[i].dwPromptMeFirst)
        {
            smChkTo(EH_Err4,RegSetValueEx(hkeyConnection,TEXT("PromptMeFirst"),NULL, REG_DWORD,
                                                     (LPBYTE) &(lpConnectionSettings[i].dwPromptMeFirst),
                                                     sizeof(DWORD)));
        }

        RegCloseKey(hkeyConnection);

    }

    // update the toplevel User information
    RegUpdateUserAutosyncKey(hKeyUser,TRUE /* fForce */);

    // update the top-level key
    RegUpdateAutoSyncKeyValue(hAutoSync,dwLogonDefault,dwLogoffDefault);

    RegCloseKey(hKeyUser);
    RegCloseKey(hAutoSync);

    // update our global sens state based on Autosync and Registration

    if (fSetMachineState)
    {
        RegRegisterForEvents(FALSE /* fUninstall */);
    }

    CMutexRegistry.Leave();
    return TRUE;

EH_Err4:
    RegCloseKey(hkeyConnection);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    RegCloseKey(hAutoSync);
EH_Err:
    
    CMutexRegistry.Leave();
    return FALSE;

}

/****************************************************************************

  Scheduled Sync Registry Functions

***************************************************************************F-F*/
//--------------------------------------------------------------------------------
//
//  FUNCTION: RegGetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
//                                    LPTSTR ptstrFriendlyName)
//
//  PURPOSE: Get the friendly name of this Schedule.
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDAPI_(BOOL) RegGetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
                                      LPTSTR ptstrFriendlyName)

{
BOOL fResult = FALSE;
HKEY hkeySchedName;
DWORD   dwType = REG_SZ;
DWORD   dwDataSize = (MAX_PATH + 1) * sizeof(TCHAR);

    HKEY hKeyUser;

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        return FALSE;
    }

    if (NOERROR == RegOpenKeyEx (hKeyUser, ptszScheduleGUIDName, 0,KEY_READ,
                                              &hkeySchedName))
    {

        if (ERROR_SUCCESS == RegQueryValueEx(hkeySchedName,TEXT("FriendlyName"),NULL, &dwType,
                                                 (LPBYTE) ptstrFriendlyName, &dwDataSize))
        {
            fResult = TRUE;
        }

        RegCloseKey(hkeySchedName);
    }

    
    RegCloseKey(hKeyUser);
    return fResult;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: RegSetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
//                                                                        LPCTSTR ptstrFriendlyName)
//
//  PURPOSE: Set the friendly name of this Schedule.
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDAPI_(BOOL) RegSetSchedFriendlyName(LPCTSTR ptszScheduleGUIDName,
                                        LPCTSTR ptstrFriendlyName)

{
SCODE   sc;
HKEY  hkeySchedName;
DWORD dwType = REG_SZ;
HKEY hKeyUser;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_WRITE |  KEY_READ,TRUE);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err;
    }

    smChkTo(EH_Err3,RegCreateUserSubKey (hKeyUser, ptszScheduleGUIDName,
                                            KEY_WRITE |  KEY_READ,
                                                &hkeySchedName));


    smChkTo(EH_Err4,RegSetValueEx (hkeySchedName,TEXT("FriendlyName"),NULL,
                                            dwType,
                                                (LPBYTE) ptstrFriendlyName,
                                                (lstrlen(ptstrFriendlyName) + 1)*sizeof(TCHAR)));

    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    CMutexRegistry.Leave();
    return TRUE;

EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err:
    
    CMutexRegistry.Leave();
    return FALSE;


}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetSchedSyncSettings(    LPCONNECTIONSETTINGS lpConnectionSettings,
                                                                                TCHAR *pszSchedName)

  Summary:  Gets the MakeAutoConnection user selections.
            If no selections on this connection, the default is FALSE

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegGetSchedSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                                          TCHAR *pszSchedName)
{
SCODE   sc;
HKEY  hkeySchedName,
        hkeyConnection;
DWORD   dwType = REG_DWORD;
DWORD   dwDataSize = sizeof(DWORD);
HKEY hKeyUser;

    // Set these first to default values, in case there are no current
    // user preferences in the registry
    lpConnectionSettings->dwConnType = SYNCSCHEDINFO_FLAGS_CONNECTION_LAN;
    lpConnectionSettings->dwMakeConnection = FALSE;
    lpConnectionSettings->dwHidden = FALSE;
    lpConnectionSettings->dwReadOnly = FALSE;

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);
    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }


    smChkTo(EH_Err3,RegOpenKeyEx (hKeyUser,
                                  pszSchedName,0,KEY_READ,
                                  &hkeySchedName));

    smChkTo(EH_Err4,RegQueryValueEx(hkeySchedName,TEXT("ScheduleHidden"),NULL, &dwType,
                                    (LPBYTE) &(lpConnectionSettings->dwHidden),
                                    &dwDataSize));

    dwDataSize = sizeof(DWORD);

    smChkTo(EH_Err4,RegQueryValueEx(hkeySchedName,TEXT("ScheduleReadOnly"),NULL, &dwType,
                                    (LPBYTE) &(lpConnectionSettings->dwReadOnly),
                                    &dwDataSize));

    smChkTo(EH_Err4,RegOpenKeyEx (hkeySchedName,
                                  lpConnectionSettings->pszConnectionName,
                                  0,KEY_READ,
                                  &hkeyConnection));

    dwDataSize = sizeof(DWORD);

    smChkTo(EH_Err5,RegQueryValueEx(hkeyConnection,TEXT("MakeAutoConnection"),NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->dwMakeConnection),
                                             &dwDataSize));

    dwDataSize = sizeof(DWORD);

    smChkTo(EH_Err5,RegQueryValueEx(hkeyConnection,TEXT("Connection Type"),NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->dwConnType),
                                             &dwDataSize));

    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    return TRUE;

EH_Err5:
    RegCloseKey(hkeyConnection);
EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    return FALSE;

}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetSchedSyncSettings(    LPCONNECTIONSETTINGS lpConnectionSettings,
                                                                                TCHAR *pszSchedName)

  Summary:  Sets the hidden and readonly schedule flags.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegSetSchedSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                                          TCHAR *pszSchedName)
{
SCODE   sc;
HKEY    hKeyUser,
        hkeySchedName,
        hkeyConnection;


    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ | KEY_WRITE,TRUE);

    if (NULL == hKeyUser)
    {
        goto EH_Err;
    }

    smChkTo(EH_Err3,RegCreateUserSubKey (hKeyUser,
                                                    pszSchedName,
                                                    KEY_WRITE |  KEY_READ,
                                                    &hkeySchedName));

    smChkTo(EH_Err4,RegSetValueEx(hkeySchedName,TEXT("ScheduleHidden"),NULL, REG_DWORD,
                                             (LPBYTE) &(lpConnectionSettings->dwHidden),
                                             sizeof(DWORD)));

    smChkTo(EH_Err4,RegSetValueEx(hkeySchedName,TEXT("ScheduleReadOnly"),NULL, REG_DWORD,
                                             (LPBYTE) &(lpConnectionSettings->dwReadOnly),
                                             sizeof(DWORD)));

    smChkTo(EH_Err4,RegCreateUserSubKey ( hkeySchedName,
                                                lpConnectionSettings->pszConnectionName,
                                                KEY_WRITE |  KEY_READ,
                                                &hkeyConnection));

    smChkTo(EH_Err5,RegSetValueEx(hkeyConnection,TEXT("MakeAutoConnection"),NULL, REG_DWORD,
                                             (LPBYTE) &(lpConnectionSettings->dwMakeConnection),
                                             sizeof(DWORD)));

    smChkTo(EH_Err5,RegSetValueEx(hkeyConnection,TEXT("Connection Type"),NULL, REG_DWORD,
                                             (LPBYTE) &(lpConnectionSettings->dwConnType),
                                             sizeof(DWORD)));

    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);

    CMutexRegistry.Leave();
    return TRUE;

EH_Err5:
    RegCloseKey(hkeyConnection);
EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err:
    CMutexRegistry.Leave();
    return FALSE;

}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetSchedConnectionName(TCHAR *pszSchedName,
                                                                         TCHAR *pszConnectionName,
                                                                         DWORD cbConnectionName)


  Summary:  returns the Connection Name for the Scheduled Item.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL)  RegGetSchedConnectionName(TCHAR *pszSchedName,TCHAR *pszConnectionName,
                                                   DWORD cbConnectionName)
{
SCODE   sc;
BOOL    fResult = FALSE;
HKEY    hKeyUser,hkeySchedName;
DWORD   dwIndex = 0;
DWORD   cb = cbConnectionName;
DWORD   dwType = REG_DWORD;
DWORD   dwDataSize = sizeof(DWORD);

    //First Set the connectionName to a default.
    // for now we always assume a LAN card is present.
    // if add support for connection manager should 
    // update this.

    LoadString(g_hmodThisDll, IDS_LAN_CONNECTION, pszConnectionName, cbConnectionName);

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        goto EH_Err;
    }

    smChkTo(EH_Err3, RegOpenKeyEx (hKeyUser,pszSchedName,
                                 0,KEY_READ, &hkeySchedName));

    // next enumeration of keys is the names of the Schedules connection
    // currently just have one so only get the first.
    if ( ERROR_SUCCESS == (sc = RegEnumKeyEx(hkeySchedName,dwIndex,
        pszConnectionName,&cb,NULL,NULL,NULL,NULL)) )
    {
        fResult = TRUE;
    }

    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);

    return fResult;


EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err:
    return FALSE;


}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: BOOL RegSetSIDForSchedule( TCHAR *pszSchedName)

  Summary:  sets the SID for this schedule

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegSetSIDForSchedule(TCHAR *pszSchedName)

{
SCODE   sc;
HKEY    hkeySchedName;
TCHAR   pszSID[MAX_PATH + 1];
DWORD   dwSize = MAX_PATH;
DWORD   dwType = REG_SZ;


    if (!GetUserTextualSid(pszSID, &dwSize))
    {
        return FALSE;
    }

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    HKEY hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ | KEY_WRITE,TRUE);

    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }

    smChkTo(EH_Err3,RegCreateUserSubKey (hKeyUser, pszSchedName,
                                    KEY_WRITE |  KEY_READ,
                                    &hkeySchedName));


    smChkTo(EH_Err4,RegSetValueEx  (hkeySchedName,TEXT("SID"),NULL,
                                    dwType,
                                    (LPBYTE) pszSID,
                                    (lstrlen(pszSID) + 1)*sizeof(TCHAR)));

    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    CMutexRegistry.Leave();
    return TRUE;

EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    CMutexRegistry.Leave();
    return FALSE;


}
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: BOOL RegGetSIDForSchedule(  TCHAR *ptszTextualSidSched, 
                                        DWORD *dwSizeSid, TCHAR *pszSchedName)

  Summary:  returns the SID for this schedule

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegGetSIDForSchedule(TCHAR *ptszTextualSidSched, DWORD *pdwSizeSid, TCHAR *pszSchedName)
{
    SCODE   sc;
    HKEY    hkeySchedName;
    DWORD   dwIndex = 0;
    DWORD   dwType = REG_SZ;
    DWORD   dwSizeSidSave = *pdwSizeSid, 
            dwSizeSidSave2 = *pdwSizeSid;
    DWORD   dwTouched = TRUE;

    ptszTextualSidSched[0] = TEXT('\0');
    *pdwSizeSid = 0;

    HKEY hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }

    smChkTo(EH_Err3, RegOpenKeyEx (hKeyUser,pszSchedName,
                                   0,KEY_READ, &hkeySchedName));


    if (ERROR_SUCCESS != (sc = RegQueryValueEx(hkeySchedName,TEXT("SID"),NULL, &dwType,
                    (LPBYTE) ptszTextualSidSched, &dwSizeSidSave)))
    {
        //handle migration from schedules without SIDs 
        // like from Beta to current builds
        RegSetSIDForSchedule(pszSchedName);
        
        RegQueryValueEx(hkeySchedName,TEXT("SID"),NULL, &dwType,
                    (LPBYTE) ptszTextualSidSched, &dwSizeSidSave2);
        
        *pdwSizeSid = dwSizeSidSave2;
    }
    else
    {
        *pdwSizeSid = dwSizeSidSave;
    }

    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    return TRUE;


EH_Err3:
        RegCloseKey(hKeyUser);
EH_Err2:
        return FALSE;

}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL      RemoveScheduledJobFile(TCHAR *pszTaskName)

  Summary:  Remove the TaskScheduler .job file 
            
  Note:     Try to use ITask->Delete first
            Call only when TaskScheduler isn't present or if ITask->Delete failed

  Returns:  Returns TRUE always

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RemoveScheduledJobFile(TCHAR *pszTaskName)
{
    SCODE   sc;
    TCHAR   pszFullFileName[MAX_PATH+1];
    TCHAR   pszTaskFolderPath[MAX_PATH+1];
    HKEY    hkeyTaskSchedulerPath;
    DWORD   dwType = REG_SZ;
    DWORD   dwDataSize = MAX_PATH * sizeof(TCHAR);

    
    if (ERROR_SUCCESS == (sc = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                  TEXT("SOFTWARE\\Microsoft\\SchedulingAgent"),
                                  NULL,KEY_READ,&hkeyTaskSchedulerPath)))
    {
           
        sc = RegQueryValueEx(hkeyTaskSchedulerPath,TEXT("TasksFolder"),
                                     NULL, &dwType,
                                     (LPBYTE) pszTaskFolderPath, &dwDataSize);
        RegCloseKey(hkeyTaskSchedulerPath);
    }
    
    //If this get doesn't exist then bail.
    if (ERROR_SUCCESS != sc)
    {
        return FALSE;
    }
    ExpandEnvironmentStrings(pszTaskFolderPath,pszFullFileName,MAX_PATH);
    wcscat(pszFullFileName, L"\\");
    wcscat(pszFullFileName,pszTaskName);
    
    //if we fail this, ignore the error.  We tried, there isn't much else we can do.
    //So we have a turd file.
    sc = DeleteFile(pszFullFileName);
    return TRUE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegRemoveScheduledTask(TCHAR *pszTaskName)

  Summary:  Remove the Scheduled task info from the registry.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegRemoveScheduledTask(TCHAR *pszTaskName)
{
HKEY hKeyUser;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ | KEY_WRITE,FALSE);
    
    if (hKeyUser)
    {
        RegDeleteKeyNT(hKeyUser, pszTaskName);
        RegCloseKey(hKeyUser);
    }


    CMutexRegistry.Leave();
    return TRUE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegUninstallSchedules()

  Summary:  Uninstall the scheduled tasks.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL) RegUninstallSchedules()
{
SCODE sc;
ITaskScheduler   *pITaskScheduler = NULL;
HKEY    hkeySchedSync;

    // Obtain a task scheduler class instance.
    sc = CoCreateInstance(
           CLSID_CTaskScheduler,
           NULL,
           CLSCTX_INPROC_SERVER,
            IID_ITaskScheduler,
           (VOID **)&pITaskScheduler);

    if (NOERROR != sc)
    {
        pITaskScheduler = NULL;
    }

    //now go through and delete the schedules

    hkeySchedSync =  RegGetSyncTypeKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);

    if (hkeySchedSync)
    {
    int iUserCount = 0;

        while (sc == ERROR_SUCCESS )
        {
        HKEY hkeyDomainUser;
        TCHAR   szDomainUser[MAX_KEY_LENGTH];
        SCODE sc2;
        DWORD  dwDataSize;

        
            dwDataSize = MAX_KEY_LENGTH;
            sc = RegEnumKeyEx(hkeySchedSync,iUserCount,szDomainUser,&dwDataSize,NULL,NULL,NULL,NULL);
            iUserCount++;

            if(sc == ERROR_NO_MORE_ITEMS)
            {
               break;
            }

            sc2 = RegOpenKeyEx (hkeySchedSync,szDomainUser,0,KEY_READ, &hkeyDomainUser);

            if (ERROR_SUCCESS == sc2)
            {
            int iScheduleCount = 0;

                while (sc2 == ERROR_SUCCESS )
                {
                 TCHAR   ptszScheduleGUIDName[MAX_KEY_LENGTH];
                //Add 4 to ensure that we can hold the .job extension if necessary
                WCHAR   pwszScheduleGUIDName[MAX_SCHEDULENAMESIZE + 4];

                    dwDataSize = MAX_KEY_LENGTH;
                    sc2 = RegEnumKeyEx(hkeyDomainUser,iScheduleCount,ptszScheduleGUIDName,&dwDataSize,NULL,NULL,NULL,NULL);

                    iScheduleCount++;

                    if(sc2 == ERROR_NO_MORE_ITEMS)
                    {
                       continue;
                    }
                    else
                    {
                        ConvertString(pwszScheduleGUIDName,ptszScheduleGUIDName,MAX_SCHEDULENAMESIZE);
           
                        if ((!pITaskScheduler) || 
                             FAILED(pITaskScheduler->Delete(pwszScheduleGUIDName)))
                        {
                            wcscat(pwszScheduleGUIDName, L".job");
                            RemoveScheduledJobFile(pwszScheduleGUIDName);
                        }

                    }
                }

                RegCloseKey(hkeyDomainUser);
            }

        }

        RegCloseKey(hkeySchedSync);
    }

    if (pITaskScheduler)
    {
        pITaskScheduler->Release();
    }

    RegDeleteKeyNT(HKEY_LOCAL_MACHINE, SCHEDSYNC_REGKEY);

    return TRUE;
}

/****************************************************************************

  Idle Registry Functions

***************************************************************************F-F*/

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegGetIdleSyncSettings(     LPCONNECTIONSETTINGS lpConnectionSettings)

  Summary:  Gets the Idle Specific settings.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegGetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings)
{
SCODE sc;
HKEY hkeyConnection;
DWORD dwType = REG_SZ ;
DWORD dwDataSize = MAX_PATH;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    // set up defaults

    lpConnectionSettings->dwIdleEnabled = 0;

    // following are really per user not per connection
    lpConnectionSettings->ulIdleWaitMinutes = UL_DEFAULTIDLEWAITMINUTES;
    lpConnectionSettings->ulIdleRetryMinutes = UL_DEFAULTIDLERETRYMINUTES;
    lpConnectionSettings->ulDelayIdleShutDownTime = UL_DELAYIDLESHUTDOWNTIME;
    lpConnectionSettings->dwRepeatSynchronization = UL_DEFAULTREPEATSYNCHRONIZATION;
    lpConnectionSettings->dwRunOnBatteries = UL_DEFAULTFRUNONBATTERIES;

    HKEY hKeyUser = RegGetCurrentUserKey(SYNCTYPE_IDLE,KEY_READ,FALSE);
    
    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }


    dwType = REG_DWORD ;
    dwDataSize = sizeof(DWORD);

    // if got the Idle key open then fill in global settings

    RegQueryValueEx(hKeyUser,SZ_IDLEWAITAFTERIDLEMINUTESKEY,NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->ulIdleWaitMinutes),
                                             &dwDataSize);

    dwDataSize = sizeof(DWORD);
    RegQueryValueEx(hKeyUser,SZ_IDLEREPEATESYNCHRONIZATIONKEY,NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->dwRepeatSynchronization),
                                             &dwDataSize);

    dwDataSize = sizeof(DWORD);
    RegQueryValueEx(hKeyUser,SZ_IDLERETRYMINUTESKEY,NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->ulIdleRetryMinutes),
                                             &dwDataSize);

    dwDataSize = sizeof(DWORD);
    RegQueryValueEx(hKeyUser,SZ_IDLEDELAYSHUTDOWNTIMEKEY,NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->ulDelayIdleShutDownTime),
                                             &dwDataSize);

    dwDataSize = sizeof(DWORD);
    RegQueryValueEx(hKeyUser,SZ_IDLERUNONBATTERIESKEY,NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->dwRunOnBatteries),
                                             &dwDataSize);

    smChkTo(EH_Err3,RegOpenKeyEx(hKeyUser, lpConnectionSettings->pszConnectionName,0,KEY_READ,
                                                            &hkeyConnection));

    dwDataSize = sizeof(DWORD);
    RegQueryValueEx(hkeyConnection,TEXT("IdleEnabled"),NULL, &dwType,
                                             (LPBYTE) &(lpConnectionSettings->dwIdleEnabled),
                                             &dwDataSize);

    RegCloseKey(hkeyConnection);
    RegCloseKey(hKeyUser);

    CMutexRegistry.Leave();
    return TRUE;

EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    CMutexRegistry.Leave();
    return FALSE;

}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegSetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                      int iNumConnections,
                                      CRasUI *pRas,
                                      BOOL fCleanReg,
                                      BOOL fPerUser)

  Summary:  Sets the Idle Information user selections.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/
STDAPI_(BOOL)  RegSetIdleSyncSettings(LPCONNECTIONSETTINGS lpConnectionSettings,
                                      int iNumConnections,
                                      CRasUI *pRas,
                                      BOOL fCleanReg,
                                      BOOL fPerUser)
{
HKEY hkeyIdleSync = NULL;
HKEY hKeyUser;;
HKEY hkeyConnection;
HRESULT hr;
ULONG ulWaitMinutes = UL_DEFAULTWAITMINUTES;
DWORD dwIdleEnabled;
BOOL fRunOnBatteries = UL_DEFAULTFRUNONBATTERIES;
int i;
DWORD dwType;
DWORD dwDataSize;
DWORD dwUserConfigured;
DWORD dwTopLevelDefaultValue = -1;

    RegUpdateTopLevelKeys(); // make sure top-level keys are latest version

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    Assert(-1 != TRUE); // we rely on TRUE boolean being something other than -1

    hkeyIdleSync =  RegGetSyncTypeKey(SYNCTYPE_IDLE,KEY_WRITE| KEY_READ,TRUE);

    if (NULL == hkeyIdleSync)
    {
        goto EH_Err;
    }

    hKeyUser =  RegOpenUserKey(hkeyIdleSync,KEY_WRITE| KEY_READ,TRUE,fCleanReg);

    if (NULL == hKeyUser)
    {
        goto EH_Err2;
    }


    if (fPerUser)
    {

        dwUserConfigured = 1;
  
        if (ERROR_SUCCESS != RegSetValueEx(hKeyUser,TEXT("UserConfigured"),NULL, REG_DWORD,
                                                     (LPBYTE) &dwUserConfigured,
                                                     sizeof(DWORD)))
        {
            goto EH_Err3;
        }
    
    }
    else
    {
        dwType = REG_DWORD;
        dwDataSize = sizeof(DWORD);
        
        //If this value isn't added yet, 
        if (ERROR_SUCCESS == RegQueryValueEx(hKeyUser,TEXT("UserConfigured"),NULL, &dwType,
                                        (LPBYTE) &dwUserConfigured,
                                        &dwDataSize))
        {
            //if the user setup their configuration, we won't override on a
            //subsequent handler registration.
            if (dwUserConfigured)
            {
                RegCloseKey(hkeyIdleSync);
                RegCloseKey(hKeyUser);
                CMutexRegistry.Leave();
                return TRUE;
            }
        }
    }

    for (i=0; i<iNumConnections; i++)
    {

        if (ERROR_SUCCESS != RegCreateUserSubKey (hKeyUser,
                                                 lpConnectionSettings[i].pszConnectionName,
                                                 KEY_WRITE |  KEY_READ,
                                                 &hkeyConnection))
        {
            goto EH_Err3;        
        }


        hr = RegSetValueEx(hkeyConnection,TEXT("IdleEnabled"),NULL, REG_DWORD,
                             (LPBYTE) &(lpConnectionSettings[i].dwIdleEnabled),
                             sizeof(DWORD));
        
        if (lpConnectionSettings[i].dwIdleEnabled)
        {
            dwTopLevelDefaultValue = lpConnectionSettings[i].dwIdleEnabled;
        }

        RegCloseKey(hkeyConnection);

    }
    // write out the global idle information for Retry minutes and DelayIdleShutDown.
    // then call function to reg/unregister with TS.


    Assert(hkeyIdleSync); // should have already returned if this failed.

    if (iNumConnections) // make sure at least one connection
    {

        // ONLY UPDATE SETTINGS IF NOT -1;

        if (-1 != lpConnectionSettings[0].ulIdleRetryMinutes)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLERETRYMINUTESKEY,NULL, REG_DWORD,
                                 (LPBYTE) &(lpConnectionSettings[0].ulIdleRetryMinutes),
                                 sizeof(DWORD));
        }

        if (-1 != lpConnectionSettings[0].ulDelayIdleShutDownTime)
        {
           hr = RegSetValueEx(hKeyUser,SZ_IDLEDELAYSHUTDOWNTIMEKEY,NULL, REG_DWORD,
                                 (LPBYTE) &(lpConnectionSettings[0].ulDelayIdleShutDownTime),
                                 sizeof(DWORD));
        }

        if (-1 != lpConnectionSettings[0].dwRepeatSynchronization)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLEREPEATESYNCHRONIZATIONKEY,NULL, REG_DWORD,
                                 (LPBYTE) &(lpConnectionSettings[0].dwRepeatSynchronization),
                                 sizeof(DWORD));
        }



        if (-1 != lpConnectionSettings[0].ulIdleWaitMinutes)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLEWAITAFTERIDLEMINUTESKEY,NULL, REG_DWORD,
                             (LPBYTE) &(lpConnectionSettings[0].ulIdleWaitMinutes),
                             sizeof(DWORD));
        }


        if (-1 != lpConnectionSettings[0].dwRunOnBatteries)
        {
            hr = RegSetValueEx(hKeyUser,SZ_IDLERUNONBATTERIESKEY,NULL, REG_DWORD,
                             (LPBYTE) &(lpConnectionSettings[0].dwRunOnBatteries),
                             sizeof(DWORD));
        }

        ulWaitMinutes = lpConnectionSettings[0].ulIdleWaitMinutes;
        fRunOnBatteries = lpConnectionSettings[0].dwRunOnBatteries;

        // if -1 is passed in for ulWait or fRun on Batteries we need to 
        // get these and set them up so they can be passed onto Task Schedule
        if (-1 == ulWaitMinutes)
        {
            dwType = REG_DWORD ;
            dwDataSize = sizeof(ulWaitMinutes);

            if (!(ERROR_SUCCESS == RegQueryValueEx(hKeyUser,SZ_IDLEWAITAFTERIDLEMINUTESKEY,NULL, &dwType,
                         (LPBYTE) &ulWaitMinutes,
                         &dwDataSize)) )
            {
                ulWaitMinutes = UL_DEFAULTIDLEWAITMINUTES;
            }
        }

        if (-1 == fRunOnBatteries)
        {
            dwType = REG_DWORD ;
            dwDataSize = sizeof(fRunOnBatteries);

            if (!(ERROR_SUCCESS == RegQueryValueEx(hKeyUser,SZ_IDLERUNONBATTERIESKEY,NULL, &dwType,
                         (LPBYTE) &fRunOnBatteries,
                         &dwDataSize)) )
            {
                fRunOnBatteries = UL_DEFAULTFRUNONBATTERIES;
            }
        }

    }

    RegUpdateUserIdleKey(hKeyUser,TRUE /* fForce */); // set userlevel IdleFlags

    // read in dwIdleEnabled key now that the UserKey is Updated.
    dwType = REG_DWORD ;
    dwDataSize = sizeof(DWORD);

    if (!(ERROR_SUCCESS == RegQueryValueEx(hKeyUser,TEXT("IdleEnabled"),NULL, &dwType,
                             (LPBYTE) &dwIdleEnabled,
                             &dwDataSize)) )
    {
        AssertSz(0,"Unable to query User IdleEnabledKey");
        dwIdleEnabled = FALSE;
    }

    RegCloseKey(hKeyUser);

    // update the toplevel IdleSyncInfo
    RegUpdateIdleKeyValue(hkeyIdleSync,dwTopLevelDefaultValue);

    RegCloseKey(hkeyIdleSync);

    CMutexRegistry.Leave();

    RegRegisterForIdleTrigger(dwIdleEnabled,ulWaitMinutes,fRunOnBatteries);

    return TRUE;

EH_Err3:
    RegCloseKey(hKeyUser);
EH_Err2:
    RegCloseKey(hkeyIdleSync);
EH_Err:
    CMutexRegistry.Leave();

    return FALSE;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: RegRegisterForIdleTrigger()

  Summary:  Sets or removes the Idle trigger.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL)  RegRegisterForIdleTrigger(BOOL fRegister,ULONG ulWaitMinutes,BOOL fRunOnBatteries)
{
HRESULT hr;
CSyncMgrSynchronize *pSyncMgrSynchronize;
LPSYNCSCHEDULEMGR pScheduleMgr;

    // Review - Currently the mobsync dll is registered as apartment
   //    and this function can be called from Logon/Logoff which is FreeThreaded
   //    Correct fix is to change DLL to be registered as BOTH but until then
   //    just create the class directly.

#ifdef _WHENREGUPDATED
    hr = CoCreateInstance(CLSID_SyncMgr,NULL,CLSCTX_ALL,
                        IID_ISyncScheduleMgr,(void **) &pScheduleMgr);
#endif // _WHENREGUPDATED

    pSyncMgrSynchronize = new CSyncMgrSynchronize;
    hr = E_OUTOFMEMORY;

    if (pSyncMgrSynchronize)
    {
        hr = pSyncMgrSynchronize->QueryInterface(IID_ISyncScheduleMgr,(void **) &pScheduleMgr);
        pSyncMgrSynchronize->Release();
    }


    if (NOERROR != hr)
    {
        return FALSE;
    }

    if (fRegister)
    {
    ISyncSchedule *pSyncSchedule = NULL;
    SYNCSCHEDULECOOKIE SyncScheduleCookie;
    BOOL fNewlyCreated = FALSE;


        HRESULT hr = E_FAIL;

        SyncScheduleCookie =  GUID_IDLESCHEDULE;

        // if there isn't an existing schedule create one, else update
        // the existing.

        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == (hr = pScheduleMgr->OpenSchedule(&SyncScheduleCookie,0,&pSyncSchedule)))
        {
             SyncScheduleCookie =  GUID_IDLESCHEDULE;
            // see if it is an exiting schedule.

             hr = pScheduleMgr->CreateSchedule(L"Idle",0,&SyncScheduleCookie,&pSyncSchedule);
             fNewlyCreated = TRUE;
        }

        // If created or found a schedule update the trigger settings.
        if (NOERROR == hr)
        {
        ITaskTrigger *pTrigger;

            pSyncSchedule->SetFlags(SYNCSCHEDINFO_FLAGS_READONLY | SYNCSCHEDINFO_FLAGS_HIDDEN);

            if (NOERROR == pSyncSchedule->GetTrigger(&pTrigger))
            {
            TASK_TRIGGER trigger;
            ITask *pTask;

                trigger.cbTriggerSize = sizeof(TASK_TRIGGER);

                if (SUCCEEDED(pTrigger->GetTrigger(&trigger)))
                {
                DWORD dwFlags;

                    // need to set Idle, ULONG ulWaitMinutes,BOOL fRunOnBatteries
                    trigger.cbTriggerSize = sizeof(TASK_TRIGGER);
                    trigger.TriggerType  = TASK_EVENT_TRIGGER_ON_IDLE;
                    trigger.rgFlags = 0;
                    pTrigger->SetTrigger(&trigger);

                    if (SUCCEEDED(pSyncSchedule->GetITask(&pTask)))
                    {
                        // set up if run on battery.
                        if (SUCCEEDED(pTask->GetFlags(&dwFlags)))
                        {
                            dwFlags &= ~TASK_FLAG_DONT_START_IF_ON_BATTERIES;
                            dwFlags |=  !fRunOnBatteries ? TASK_FLAG_DONT_START_IF_ON_BATTERIES : 0;

                            dwFlags |= TASK_FLAG_RUN_ONLY_IF_LOGGED_ON; // don't require password.

                            pTask->SetFlags(dwFlags);
                        }

                        // if this schedule was just created, get the current user name and reset
                        // account information password to NULL, If existing schedule don't change
                        // since user may have added a password for schedule to run while not logged on.
                        if (fNewlyCreated)
                        {
                        TCHAR szAccountName[MAX_DOMANDANDMACHINENAMESIZE];
                        WCHAR *pszAccountName = NULL;
                        DWORD dwAccountName = sizeof(szAccountName);
                        #ifndef _UNICODE
                        WCHAR pwszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
                        #endif // _UNICODE

                            // Review, this never returns an errorl
                            *szAccountName = TCHAR('\0');
                            GetDefaultDomainAndUserName( (LPTSTR) &szAccountName,TEXT("\\"),dwAccountName);

                            #ifndef _UNICODE

                                // if we are compiled as ansi need to convert to wchar
                                pszAccountName = pwszDomainAndUser;
                                MultiByteToWideChar(CP_ACP, 0, szAccountName, -1, pwszDomainAndUser,sizeof(pwszDomainAndUser));
                            #else
                                pszAccountName = szAccountName;
                            #endif _UNICODE

                            Assert(pszAccountName);

                            if (pszAccountName)
                            {
                                pTask->SetAccountInformation(pszAccountName,NULL);
                            }

                        }


                        // set up the IdleWaitTime.
                        pTask->SetIdleWait((WORD) ulWaitMinutes,1);

                        // turn off the option to kill task after xxx minutes.
                        pTask->SetMaxRunTime(INFINITE);

                        pTask->Release();
                    }

                    pTrigger->Release();

                }

                pSyncSchedule->Save();
            }



            pSyncSchedule->Release();
        }

    }
    else
    {
    SYNCSCHEDULECOOKIE SyncScheduleCookie = GUID_IDLESCHEDULE;

        // see if there is an existing schedule and if so remove it.
        pScheduleMgr->RemoveSchedule(&SyncScheduleCookie);

    }

    pScheduleMgr->Release();

    // set the temporary sens flags according so it can start on an idle trigger.
    // not an error to not be able to get and set key since sens will
    // be running anyways eventually.
        HKEY    hkeyAutoSync;
        DWORD   dwFlags = 0;
    DWORD       dwType = REG_DWORD;
    DWORD       dwDataSize = sizeof(DWORD);

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    hkeyAutoSync = RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_WRITE |  KEY_READ,TRUE);
    if (NULL == hkeyAutoSync)
    {
        CMutexRegistry.Leave(); 
        return FALSE;
    }

    if (ERROR_SUCCESS == RegQueryValueEx(hkeyAutoSync,TEXT("Flags"),NULL, &dwType,
                                                 (LPBYTE) &(dwFlags),&dwDataSize))
    {
        // Here we are setting Idle only so retail the other settings.
        dwFlags &= ~AUTOSYNC_IDLE;
        dwFlags |= (fRegister? AUTOSYNC_IDLE : 0);

        RegSetValueEx(hkeyAutoSync,TEXT("Flags"),NULL, REG_DWORD,
                                             (LPBYTE) &(dwFlags), sizeof(DWORD));
    }
    RegCloseKey(hkeyAutoSync);
    CMutexRegistry.Leave();
    return TRUE;

}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL  RegGetSyncSettings(DWORD dwSyncType,LPCONNECTIONSETTINGS lpConnectionSettings)

  Summary:  Get ConnectionSettings appropriate to the synctype..

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegGetSyncSettings(DWORD dwSyncType,LPCONNECTIONSETTINGS lpConnectionSettings)
{

    switch(dwSyncType)
    {
    case SYNCTYPE_AUTOSYNC:
        return RegGetAutoSyncSettings(lpConnectionSettings);
        break;
    case SYNCTYPE_IDLE:
        return RegGetIdleSyncSettings(lpConnectionSettings);
        break;
    default:
        AssertSz(0,"Unknown SyncType in RegGetSyncSettings");
        break;
    }

    return FALSE;
}


/****************************************************************************

  Manual Sync Registry Functions

***************************************************************************F-F*/

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegRemoveManualSyncSettings(TCHAR *pszTaskName)

  Summary:  Remove the manual settings info from the registry.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegRemoveManualSyncSettings(TCHAR *pszConnectionName)
{
HKEY hkeyUser;
CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
CMutexRegistry.Enter();

    hkeyUser = RegGetCurrentUserKey(SYNCTYPE_MANUAL,KEY_WRITE |  KEY_READ,FALSE);

    if (hkeyUser)
    {
        RegDeleteKeyNT(hkeyUser, pszConnectionName);
        RegCloseKey(hkeyUser);
    }

    CMutexRegistry.Leave();
    return TRUE;
}
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegWriteEvents(BOOL fWanLogon,BOOL fWanLogoff,BOOL fLanLogon,BOOL fLanLogoff)

  Summary:  Write out the Wan/Lan Logon/Logoff preferences fo SENS knows whether to invoke us.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

// Run key under HKLM
const WCHAR wszRunKey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const WCHAR wszRunKeyCommandLine[]  = TEXT("%SystemRoot%\\system32\\mobsync.exe /logon");


STDAPI_(BOOL) RegWriteEvents(BOOL Logon,BOOL Logoff)
{
HRESULT hr;
HKEY    hkeyAutoSync;
DWORD   dwFlags = 0;
DWORD   dwType = REG_DWORD;
DWORD   dwDataSize = sizeof(DWORD);

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    hkeyAutoSync =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_WRITE |  KEY_READ,TRUE);
    if (NULL == hkeyAutoSync)
    {

        CMutexRegistry.Leave();
        return FALSE;
    }

    RegQueryValueEx(hkeyAutoSync,TEXT("Flags"),NULL, &dwType,
                                             (LPBYTE) &(dwFlags),
                                             &dwDataSize);


    // Review, Shouldn't need to worry about schedule/idle once IsNetworkAlive
    // is setup properly. Leave for now first time anyone sets idle or schedule
    // stuck


    // Here we are setting autosync only,
    // so retain the registry settings for scheduled and idle.

    dwFlags &= ~(AUTOSYNC_WAN_LOGON  | AUTOSYNC_LAN_LOGON | AUTOSYNC_LOGONWITHRUNKEY
		  | AUTOSYNC_WAN_LOGOFF | AUTOSYNC_LAN_LOGOFF);

    // don't set logoff flags unless on platform logoff is supported
    // 
    // !!! warning, if you change this also need to update settings
    // and registry which are the other places we block this.
    if ((VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId 
            && g_OSVersionInfo.dwMajorVersion >= 5) )
    {
        dwFlags |= (Logoff ? AUTOSYNC_WAN_LOGOFF : 0);
        dwFlags |= (Logoff ? AUTOSYNC_LAN_LOGOFF : 0);
    }

    // Since now use Run key instead of SENS always set both Logon Flags 
    // that SENS looks for to do a CreateProcess on us to FALSE.
    // Then set the AUTOSYNC_LOGONWITHRUNKEY key to true so sens still gets loaded.

    dwFlags |= (Logon ? AUTOSYNC_LOGONWITHRUNKEY : 0);

    hr = RegSetValueEx(hkeyAutoSync,TEXT("Flags"),NULL, REG_DWORD,
                                     (LPBYTE) &(dwFlags), sizeof(DWORD));

    RegCloseKey(hkeyAutoSync);

    // now add /delete the run key appropriately.


    HKEY hKeyRun;

    // call private RegOpen since don't want to set security on RunKey
    if (ERROR_SUCCESS == RegOpenKeyExXp(HKEY_LOCAL_MACHINE,wszRunKey,
                              NULL,KEY_READ | KEY_WRITE,&hKeyRun,FALSE /*fSetSecurity*/))
    {
        if (Logon)
        {
            RegSetValueEx(hKeyRun, SZ_SYNCMGRNAME, 0, REG_EXPAND_SZ, 
                    (BYTE *) wszRunKeyCommandLine,(lstrlen(wszRunKeyCommandLine) + 1)*sizeof(TCHAR));
        }
        else
        {
            RegDeleteValue(hKeyRun, SZ_SYNCMGRNAME);
        }
        
        RegCloseKey(hKeyRun);
    }
    else
    {
       // if can't open run key try calling SENS if that fails give up.
       SyncMgrExecCmd_UpdateRunKey(Logon);
    }

    CMutexRegistry.Leave();
    return TRUE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegFixRunKey(BOOL fScheduled)

  Summary:  The original version of SyncMgr for WinMe/Win2000 wrote the
            "run" value as "mobsync.exe /logon".  Since this is not a fully-
            qualified path to the mobsync.exe image, the system's search 
            path is utilized to locate the image.  This can create an 
            opportunity for someone to build a 'trojan' mobsync.exe, place
            it in the search path ahead of the real mobsync.exe and have 
            the 'trojan' code run whenever a synchronization is invoked.
            To fix this, the path must be stored in the registry using
            fully-qualified syntax.  

            i.e. "%SystemRoot%\System32\mobsync.exe /logon"

            This function is called from DllRegisterServer to correct this 
            registry entry during setup.

  Returns:  Always returns TRUE.

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegFixRunKey(void)
{
    HKEY hKeyRun;

    // call private RegOpen since don't want to set security on RunKey
    if (ERROR_SUCCESS == RegOpenKeyExXp(HKEY_LOCAL_MACHINE,
                                        wszRunKey,
                                        NULL,
                                        KEY_READ | KEY_WRITE,
                                        &hKeyRun,
                                        FALSE /*fSetSecurity*/))
    {
        TCHAR szRunValue[MAX_PATH];
        DWORD cbValue = sizeof(szRunValue);
        DWORD dwType;
        if (ERROR_SUCCESS == RegQueryValueEx(hKeyRun,
                                             SZ_SYNCMGRNAME,
                                             NULL,
                                             &dwType,
                                             (LPBYTE)szRunValue,
                                             &cbValue))
        {
            if (REG_SZ == dwType && 0 == lstrcmp(szRunValue, TEXT("mobsync.exe /logon")))
            {
                //
                // Upgrade only if it's our original value.
                //
                RegSetValueEx(hKeyRun, 
                              SZ_SYNCMGRNAME, 
                              0, 
                              REG_EXPAND_SZ, 
                              (BYTE *)wszRunKeyCommandLine,
                              (lstrlen(wszRunKeyCommandLine) + 1) * sizeof(TCHAR));
            }           
        }
        RegCloseKey(hKeyRun);
    }
    return TRUE;
}


/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  BOOL RegRegisterForScheduledTasks(BOOL fScheduled)

  Summary:  Register/unregister for scheduled tasks
                        so SENS knows whether to invoke us.

  Returns:  Returns TRUE if successful, FALSE otherwise

------------------------------------------------------------------------F-F*/

STDAPI_(BOOL) RegRegisterForScheduledTasks(BOOL fScheduled)
{
HKEY    hkeyAutoSync;
DWORD   dwFlags = 0;
DWORD   dwType = REG_DWORD;
DWORD   dwDataSize = sizeof(DWORD);

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    hkeyAutoSync =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_WRITE |  KEY_READ,TRUE);

    if (NULL == hkeyAutoSync)
    {
        CMutexRegistry.Leave();
        return FALSE;
    }

    RegQueryValueEx(hkeyAutoSync,TEXT("Flags"),NULL, &dwType,
                    (LPBYTE) &(dwFlags), &dwDataSize);


    // Here we are setting schedsync only,
    // so retain the registry settings for autosync and idle.

    dwFlags &=  AUTOSYNC_WAN_LOGON  |
                AUTOSYNC_WAN_LOGOFF     |
                AUTOSYNC_LAN_LOGON  |
                AUTOSYNC_LAN_LOGOFF |
                AUTOSYNC_IDLE;

     dwFlags |= (fScheduled? AUTOSYNC_SCHEDULED : 0);

     RegSetValueEx(hkeyAutoSync,TEXT("Flags"),NULL, REG_DWORD,
                                         (LPBYTE) &(dwFlags), sizeof(DWORD));

     RegCloseKey(hkeyAutoSync);
     
     CMutexRegistry.Leave();
    
     return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     RegGetCombinedUserRegFlags, private
//
//  Synopsis:   Gets an or'ing together of user settings for setting up globals.
//
//  Arguments:  [dwSyncMgrRegisterFlags] - On Success gets set to flags
//               on failure they are set to zero
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    24-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL RegGetCombinedUserRegFlags(DWORD *pdwSyncMgrRegisterFlags)
{
HKEY hkey;
BOOL fResult = TRUE;
DWORD   dwType = REG_DWORD ;
DWORD   dwDataSize = sizeof(DWORD);


    *pdwSyncMgrRegisterFlags = 0;

    // update the AutoSync Key
    hkey =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_READ,FALSE);

    if (hkey)
    {
    DWORD dwUserLogonLogoff;

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,TEXT("Logon"),NULL, &dwType,
                             (LPBYTE) &dwUserLogonLogoff,
                             &dwDataSize) )
        {
            *pdwSyncMgrRegisterFlags |= dwUserLogonLogoff ? SYNCMGRREGISTERFLAG_CONNECT : 0;
        }

        dwDataSize = sizeof(DWORD);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,TEXT("Logoff"),NULL, &dwType,
                             (LPBYTE) &dwUserLogonLogoff,
                             &dwDataSize) )
        {
            *pdwSyncMgrRegisterFlags |= dwUserLogonLogoff ? SYNCMGRREGISTERFLAG_PENDINGDISCONNECT : 0;
        }

        RegCloseKey(hkey);
    }


    // update the Idle Key
    hkey =  RegGetSyncTypeKey(SYNCTYPE_IDLE,KEY_READ,FALSE);

    if (hkey)
    {
    DWORD   dwIdleEnabled;
    dwDataSize = sizeof(DWORD);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,TEXT("IdleEnabled"),NULL, &dwType,
                         (LPBYTE) &dwIdleEnabled,
                         &dwDataSize) )
        {
           *pdwSyncMgrRegisterFlags |= dwIdleEnabled ? SYNCMGRREGISTERFLAG_IDLE : 0;
        }

        RegCloseKey(hkey);
    }

    return TRUE; // always return true but don't set flags on error.

}


//+---------------------------------------------------------------------------
//
//  Member:     RegGetCombinedHandlerRegFlags, private
//
//  Synopsis:   Gets an or'ing together of handler registration Keys
//
//  Arguments:  [dwSyncMgrRegisterFlags] - On Success gets set to flags
//               on failure they are set to zero
//              [ft] - On Success filed with timestamp
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    24-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL RegGetCombinedHandlerRegFlags(DWORD *pdwSyncMgrRegisterFlags,FILETIME *pft)
{
HKEY hkey;
BOOL fResult = TRUE;
DWORD   dwType = REG_DWORD ;
DWORD   dwDataSize = sizeof(DWORD);


    *pdwSyncMgrRegisterFlags = 0;

    hkey = RegGetHandlerTopLevelKey(KEY_READ);

    if (hkey)
    {
        DWORD dwRegistrationFlags;

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,SZ_REGISTRATIONFLAGSKEY,NULL, &dwType,
                         (LPBYTE) &dwRegistrationFlags,
                         &dwDataSize) )
        {
            *pdwSyncMgrRegisterFlags = dwRegistrationFlags;
        }

       RegGetTimeStamp(hkey,pft);

       RegCloseKey(hkey);
    }

    return TRUE; // always return true but don't set flags on error.

}


//+---------------------------------------------------------------------------
//
//  Member:     RegGetChangedHandlerFlags, private
//
//  Synopsis:   Gets an or'ing together of handler registration Keys
//              that have changed since the given FILETIME
//
//  Arguments:  [pft] - Pointer to FileTime for Compare
//              [pdwChangedFlags] - On Success filed with flags that channged
//
//  Returns:    TRUE if could gather flags.
//
//  Modifies:
//
//  History:    24-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL RegGetChangedHandlerFlags(FILETIME *pft,DWORD *pdwHandlerChandedFlags)
{
HKEY hkeyHandler;

    *pdwHandlerChandedFlags = 0;

    hkeyHandler = RegGetHandlerTopLevelKey(KEY_READ);

    if (hkeyHandler)
    {
    TCHAR lpName[MAX_PATH + 1];
    DWORD cbName = MAX_PATH;
    DWORD dwRegistrationFlags = 0;
    FILETIME ftHandlerReg;
    DWORD dwIndex = 0;
    DWORD   dwType = REG_DWORD ;
    DWORD   dwDataSize = sizeof(DWORD);
    DWORD   dwHandlerRegFlags;
    LONG lRet;
    HKEY hKeyClsid;

        // enumerate the keys 
        while ( ERROR_SUCCESS == RegEnumKey(hkeyHandler,dwIndex,lpName,cbName) )
        {
            lRet = RegOpenKeyEx( hkeyHandler,
                                 lpName,
                                 NULL,
                                 KEY_READ,
                                 &hKeyClsid );

           
            if (ERROR_SUCCESS == lRet)
            {

                RegGetTimeStamp(hKeyClsid,&ftHandlerReg);

                // handler reg is new time than our gvien time add it to the flags.
                if (CompareFileTime(pft,&ftHandlerReg) < 0)
                {
                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyClsid,SZ_REGISTRATIONFLAGSKEY,NULL, &dwType,
                                             (LPBYTE) &dwHandlerRegFlags,
                                             &dwDataSize) )
                    {
                        dwRegistrationFlags |= dwHandlerRegFlags;
                    }
                }

                RegCloseKey(hKeyClsid);
            }

            dwIndex++;
        }


        *pdwHandlerChandedFlags = dwRegistrationFlags;

       RegCloseKey(hkeyHandler);
    }


    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     RegRegisterForEvents, private
//
//  Synopsis:   Registers/UnRegisters for appropriate SENS and WinLogon Events.
//              and any other per machine registration we need to do
//
//  Arguments:  [fUninstall] - set to true by uninstall to force us to unregister
//                  regardless of current machine state.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

// !!!Warning - Assumes toplevel key information is up to date.

STDAPI  RegRegisterForEvents(BOOL fUninstall)
{
HRESULT hr = NOERROR;
BOOL fLogon = FALSE;
BOOL fLogoff = FALSE;
BOOL fIdle = FALSE;
#ifdef _SENS
IEventSystem *pEventSystem;
#endif // _SENS
CCriticalSection cCritSect(&g_DllCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    if (!fUninstall)
    {
    FILETIME ftHandlerReg;
    DWORD dwSyncMgrUsersRegisterFlags; // or'ing of all Users settings
    DWORD dwSyncMgrHandlerRegisterFlags; // or'ing of all handler settings.
    DWORD dwCombinedFlags; // or together user and handler.

        // if not an uninstall determine the true machine state 
        // if Logon set for handler or user set or if handler
        //   wants an idle set.
        // If Logoff set we register for Logoff.
        
        RegGetCombinedUserRegFlags(&dwSyncMgrUsersRegisterFlags);
        RegGetCombinedHandlerRegFlags(&dwSyncMgrHandlerRegisterFlags,&ftHandlerReg);

        dwCombinedFlags = dwSyncMgrUsersRegisterFlags | dwSyncMgrHandlerRegisterFlags;

        if ( (dwCombinedFlags & SYNCMGRREGISTERFLAG_CONNECT)
                ||  (dwSyncMgrHandlerRegisterFlags & SYNCMGRREGISTERFLAG_IDLE) )
        {
            fLogon = TRUE;
        }

        if ( (dwCombinedFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) )
        {
            fLogoff = TRUE;
        }
        
    }

    // update Registry entries for SENS to lookup
    RegWriteEvents(fLogon,fLogoff);

#ifdef _SENS


    // we were able to load ole automation so reg/unreg with the event system.
    hr = CoCreateInstance(CLSID_CEventSystem,NULL,CLSCTX_SERVER,IID_IEventSystem,
                                            (LPVOID *) &pEventSystem);

    if (SUCCEEDED(hr))
    {
    IEventSubscription  *pIEventSubscription;
    WCHAR               szGuid[GUID_SIZE+1];
    BSTR                bstrSubscriberID = NULL;
    BSTR                bstrPROGID_EventSubscription = NULL;


        bstrPROGID_EventSubscription = SysAllocString(PROGID_EventSubscription);

        StringFromGUID2(GUID_SENSSUBSCRIBER_SYNCMGRP,szGuid, GUID_SIZE);
        bstrSubscriberID = SysAllocString(szGuid);

        if (bstrSubscriberID && bstrPROGID_EventSubscription)
        {
            // register for RasConnect
           hr = CoCreateInstance(
                     CLSID_CEventSubscription,
                     NULL,
                     CLSCTX_SERVER,
                     IID_IEventSubscription,
                     (LPVOID *) &pIEventSubscription
                     );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
        BSTR bstrPublisherID = NULL;
        BSTR bstrSubscriptionID = NULL;
        BSTR bstrSubscriptionName = NULL;
        BSTR bstrSubscriberCLSID = NULL;
        BSTR bstrEventID = NULL;
        BSTR bstrEventClassID = NULL;
        BSTR bstrIID = NULL;

            // if there are any events, register with ens for messages.
            if (fLogon)
            {

                StringFromGUID2(GUID_SENSLOGONSUBSCRIPTION_SYNCMGRP,szGuid, GUID_SIZE);
                bstrSubscriptionID = SysAllocString(szGuid);

                if (bstrSubscriptionID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_SubscriptionID(bstrSubscriptionID);
                }

                StringFromGUID2(CLSID_SyncMgrp,szGuid, GUID_SIZE);
                bstrSubscriberCLSID = SysAllocString(szGuid);

                if (bstrSubscriberCLSID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_SubscriberCLSID(bstrSubscriberCLSID);
                }

                StringFromGUID2(SENSGUID_PUBLISHER,szGuid, GUID_SIZE);
                bstrPublisherID = SysAllocString(szGuid);
                if (bstrPublisherID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_PublisherID(bstrPublisherID);
                }


                bstrSubscriptionName = SysAllocString(SZ_SYNCMGRNAME);
                if (bstrSubscriptionName && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_SubscriptionName(bstrSubscriptionName);
                }

                bstrEventID = SysAllocString(L"ConnectionMade");
                if (bstrEventID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_MethodName(bstrEventID);
                }

                StringFromGUID2(SENSGUID_EVENTCLASS_NETWORK,szGuid,GUID_SIZE);
                bstrEventClassID = SysAllocString(szGuid);
                if (bstrEventClassID && SUCCEEDED(hr))
                {
                    hr = pIEventSubscription->put_EventClassID(bstrEventClassID);
                }

                // set this up for roaming
                if (SUCCEEDED(hr))
                {
                   // hr = pIEventSubscription->put_PerUser(TRUE); // don't register PerUser for Nw
                }

               StringFromGUID2(IID_ISensNetwork,szGuid,GUID_SIZE);
               bstrIID = SysAllocString(szGuid);
               if (bstrIID && SUCCEEDED(hr))
               {
                    hr = pIEventSubscription->put_InterfaceID(bstrIID);
               }


                if (SUCCEEDED(hr))
                {
                    hr = pEventSystem->Store(bstrPROGID_EventSubscription,pIEventSubscription);
                }

                if (bstrIID)
                {
                    SysFreeString(bstrIID);
                }

                if (bstrPublisherID)
                    SysFreeString(bstrPublisherID);

                if (bstrSubscriberCLSID)
                    SysFreeString(bstrSubscriberCLSID);

                if (bstrEventClassID)
                    SysFreeString(bstrEventClassID);

                if (bstrEventID)
                    SysFreeString(bstrEventID);

                if (bstrSubscriptionID)
                    SysFreeString(bstrSubscriptionID);

                if (bstrSubscriptionName)
                    SysFreeString(bstrSubscriptionName);
            }
            else // don't need to be registered, remove.
            {

                if (NOERROR == hr)
                {
                int   errorIndex;

                    bstrSubscriptionID = SysAllocString(L"SubscriptionID={6295df30-35ee-11d1-8707-00C04FD93327}");

                    if (bstrSubscriptionID)
                    {
                        hr = pEventSystem->Remove(bstrPROGID_EventSubscription,bstrSubscriptionID /* QUERY */,&errorIndex);
                        SysFreeString(bstrSubscriptionID);
                    }
                }

            }


            pIEventSubscription->Release();

        }

        if (bstrSubscriberID)
        {
            SysFreeString(bstrSubscriberID);
        }

        if (bstrPROGID_EventSubscription)
        {
            SysFreeString(bstrPROGID_EventSubscription);
        }

        pEventSystem->Release();

    }

#endif // _SENS

    cCritSect.Leave();

    return hr;
}

// helper functions for handler registration
STDAPI_(BOOL) RegGetTimeStamp(HKEY hKey, FILETIME *pft)
{
DWORD dwType;
FILETIME ft;
LONG lr;
DWORD dwSize = sizeof(FILETIME);

    Assert(pft);

    lr = RegQueryValueEx( hKey,
                          SZ_REGISTRATIONTIMESTAMPKEY,
                          NULL,
                          &dwType,
                          (BYTE *)&ft,
                          &dwSize );


    if ( lr == ERROR_SUCCESS )
    {
        Assert( dwSize == sizeof(FILETIME) && dwType == REG_BINARY );
        *pft = ft;
    }
    else
    {
        // set the filetime to way back when to
        // any compares will just say older instead
        // of having to check success code
        (*pft).dwLowDateTime = 0;
        (*pft).dwHighDateTime = 0;
    }

    return TRUE;
}


STDAPI_(BOOL) RegWriteTimeStamp(HKEY hkey)
{
SYSTEMTIME sysTime;
FILETIME ft;
LONG lr = -1;

    GetSystemTime(&sysTime); // void can't check for errors

    if (SystemTimeToFileTime(&sysTime,&ft) )
    {
        CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
        CMutexRegistry.Enter();


        // write out the UpdateTime
        lr = RegSetValueEx( hkey,
                SZ_REGISTRATIONTIMESTAMPKEY,
                NULL,
                REG_BINARY,
                (BYTE *)&ft,
                sizeof(ft) );
        
         CMutexRegistry.Leave();
   
    }
    return (ERROR_SUCCESS == lr) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   UpdateHandlerKeyInformation
//
//  Synopsis:  Updates the top-level handler key information
//
//  Arguments:
//
//  Returns:    void
//
//  Modifies:   enumerates the handlers underneath the given key
//              updating the registrationFlags which is an || or
//              all registered handler flags and then updates the 
//              timestamp on this key
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void UpdateHandlerKeyInformation(HKEY hKeyHandler)
{
DWORD dwSyncMgrTopLevelRegisterFlags = 0;
DWORD dwIndex = 0;
TCHAR lpName[MAX_PATH];
DWORD cbName = MAX_PATH; 


    while ( ERROR_SUCCESS == RegEnumKey(hKeyHandler,dwIndex,
            lpName,cbName) )
    {
    DWORD   dwType = REG_DWORD ;
    DWORD   dwDataSize = sizeof(DWORD);
    DWORD   dwHandlerRegFlags;
    LONG lRet;
    HKEY hKeyClsid;

        lRet = RegOpenKeyEx( hKeyHandler,
                             lpName,
                             NULL,
                             KEY_READ,
                             &hKeyClsid );

        if (ERROR_SUCCESS == lRet)
        {

            if (ERROR_SUCCESS == RegQueryValueEx(hKeyClsid,SZ_REGISTRATIONFLAGSKEY,NULL, &dwType,
                                     (LPBYTE) &dwHandlerRegFlags,
                                     &dwDataSize) )
            {
                dwSyncMgrTopLevelRegisterFlags |= dwHandlerRegFlags;
            }

            RegCloseKey(hKeyClsid);
        }

        dwIndex++;
    }


    // not much we can do if RegFlags are messed up other than assert and mask out
    Assert(dwSyncMgrTopLevelRegisterFlags <= SYNCMGRREGISTERFLAGS_MASK);
    dwSyncMgrTopLevelRegisterFlags &= SYNCMGRREGISTERFLAGS_MASK;

    // write out new flags even if errors occured. work thing that happens is
    // we don't set up someones autosync automatically.
    RegSetValueEx(hKeyHandler,SZ_REGISTRATIONFLAGSKEY,NULL, REG_DWORD,
                                     (LPBYTE) &(dwSyncMgrTopLevelRegisterFlags), sizeof(DWORD));

    RegWriteTimeStamp(hKeyHandler);
}


//+---------------------------------------------------------------------------
//
//  Function:   RegUpdateTopLevelKeys
//
//  Synopsis:   Looks at toplevel AutoSync,Idle, etc. keys and determines
//              if they need to be updated and if so goes for it.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:   set pfFirstRegistration out param to true if this is
//              the first handler that has registered so we can setup defaults.
//
//  History:    24-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(void) RegUpdateTopLevelKeys()
{
HKEY hkey;
CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);

   CMutexRegistry.Enter();


    // update the AutoSync Key
    hkey =  RegGetSyncTypeKey(SYNCTYPE_AUTOSYNC,KEY_READ | KEY_WRITE,TRUE);

    if (hkey)
    {
    DWORD   dwType = REG_DWORD ;
    DWORD   dwDataSize = sizeof(DWORD);
    DWORD   dwUserLogonLogoff;

        // see if has a logon value and if it is either newly created or
        // old format. Call Update to setthings up
        if (ERROR_SUCCESS != RegQueryValueEx(hkey,TEXT("Logon"),NULL, &dwType,
                         (LPBYTE) &dwUserLogonLogoff,
                         &dwDataSize) )
        {
            RegUpdateAutoSyncKeyValue(hkey,-1,-1); 
        }

        RegCloseKey(hkey);
    }


    // update the Idle Key
    hkey =  RegGetSyncTypeKey(SYNCTYPE_IDLE,KEY_READ | KEY_WRITE,TRUE);

    if (hkey)
    {
    DWORD   dwType = REG_DWORD ;
    DWORD   dwDataSize = sizeof(DWORD);
    DWORD   dwIdleEnabled;

        // see if has a Idle value and if it is either newly created or
        // old format. Call Update to setthings up
        if (ERROR_SUCCESS != RegQueryValueEx(hkey,TEXT("IdleEnabled"),NULL, &dwType,
                         (LPBYTE) &dwIdleEnabled,
                         &dwDataSize) )
        {
            RegUpdateIdleKeyValue(hkey,-1); 
        }




        RegCloseKey(hkey);
    }

    CMutexRegistry.Leave();

}

//+---------------------------------------------------------------------------
//
//  Function:   RegRegisterHandler
//
//  Synopsis:   Registers Handlers with SyncMgr.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:   set pfFirstRegistration out param to true if this is
//              the first handler that has registered so we can setup defaults.
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) RegRegisterHandler(REFCLSID rclsidHandler,
                        WCHAR const* pwszDescription,
                        DWORD dwSyncMgrRegisterFlags,
                        BOOL *pfFirstRegistration)
{
LONG lRet;

    RegUpdateTopLevelKeys(); // make sure other top-level keys are up to date.

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    *pfFirstRegistration = FALSE;
    HKEY hKeyHandler;

    hKeyHandler = RegGetHandlerTopLevelKey(KEY_READ | KEY_WRITE);

    if (NULL == hKeyHandler)
    {
        CMutexRegistry.Leave();
        return FALSE;
    }

    XRegKey xRegKeyHandler( hKeyHandler );

    //
    // Check if this is the first handler being registerd
    //
    TCHAR szGuid[GUID_SIZE+1];
    DWORD cbGuid = GUID_SIZE+1;

    lRet = RegEnumKeyEx( hKeyHandler,
                         0,
                         szGuid,
                         &cbGuid,
                         NULL,
                         NULL,
                         NULL,
                         NULL );

    if ( lRet != ERROR_SUCCESS )
        *pfFirstRegistration = TRUE;

    //
    // Convert guid and description to TCHAR
    //
    TCHAR *pszDesc;
    BOOL fOk = FALSE;

    StringFromGUID2( rclsidHandler, szGuid, GUID_SIZE+1 );
    pszDesc = (TCHAR *)pwszDescription;


    // write out the registration flags. If fail go ahead
    // and succed registration anyways.
    if (hKeyHandler)
    {
    HKEY hKeyClsid;

        hKeyClsid = RegGetHandlerKey(hKeyHandler,szGuid,KEY_WRITE | KEY_READ,TRUE);

        if (hKeyClsid)
        {

            fOk = TRUE; // if make handle key say registered okay

            if (pszDesc)
            {
                RegSetValueEx(hKeyClsid,NULL,NULL, REG_SZ,
                                                 (LPBYTE) pszDesc,
                                                 (lstrlen(pszDesc) +1)*sizeof(TCHAR));
            }

            RegSetValueEx(hKeyClsid,SZ_REGISTRATIONFLAGSKEY,NULL, REG_DWORD,
                                             (LPBYTE) &(dwSyncMgrRegisterFlags), sizeof(DWORD));
   
            // update the TimeStamp on the handler clsid

            RegWriteTimeStamp(hKeyClsid);
            RegCloseKey( hKeyClsid );

            // update the toplevel key
            UpdateHandlerKeyInformation(hKeyHandler);
        }
    }

    // update the user information.
    RegSetUserDefaults();
    RegRegisterForEvents(FALSE /* fUninstall */);

    CMutexRegistry.Leave();

    return fOk;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegRegRemoveHandler
//
//  Synopsis:   UnRegisters Handlers with SyncMgr.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:   set pfAllHandlerUnRegistered out param to true if this is
//              the last handler that needs to be unregistered before
//              turning off our defaults..
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) RegRegRemoveHandler(REFCLSID rclsidHandler)
{
HKEY hKeyHandler;
CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);

    CMutexRegistry.Enter();


    hKeyHandler = RegGetHandlerTopLevelKey(KEY_WRITE | KEY_READ);

    if (NULL == hKeyHandler)
    {
        //
        // Non-existent key, so nothing to remove
        //
        CMutexRegistry.Leave();
        return TRUE;
    }

    XRegKey xKeyHandler( hKeyHandler );

    TCHAR szGuid[GUID_SIZE+1];

#ifdef _UNICODE
    StringFromGUID2( rclsidHandler, szGuid, GUID_SIZE+1 );
#else
    WCHAR wszGuid[GUID_SIZE+1];
    StringFromGUID2( rclsidHandler, wszGuid, GUID_SIZE+1 );

    BOOL fOk = ConvertString( szGuid, wszGuid, GUID_SIZE+1 );
    Assert( fOk );
#endif

    HKEY hKeyClsid;
    
    hKeyClsid = RegGetHandlerKey(hKeyHandler,szGuid,KEY_WRITE | KEY_READ,FALSE);
    
    if (hKeyClsid)
    {
        RegCloseKey( hKeyClsid );
        RegDeleteKey( hKeyHandler, szGuid );

        // update the toplevel key
        UpdateHandlerKeyInformation(hKeyHandler);

    }
    else
    {
        //
        // Non-existent key, so nothing to remove
        //
    }


    RegRegisterForEvents(FALSE /* fUninstall */); // UPDATE EVENT REGISTRATION.

    CMutexRegistry.Leave();

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegGetHandlerRegistrationInfo
//
//  Synopsis:   Gets Information of the specified handler.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:   pdwSyncMgrRegisterFlags
//
//  History:    20-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(BOOL) RegGetHandlerRegistrationInfo(REFCLSID rclsidHandler,LPDWORD pdwSyncMgrRegisterFlags)
{
HKEY hKeyHandler;

    *pdwSyncMgrRegisterFlags = 0;


    hKeyHandler = RegGetHandlerTopLevelKey(KEY_READ);

    if (NULL == hKeyHandler)
    {
        //
        // Non-existent key
        //
        return FALSE;
    }

    XRegKey xKeyHandler( hKeyHandler );

    TCHAR szGuid[GUID_SIZE+1];

#ifdef _UNICODE
    StringFromGUID2( rclsidHandler, szGuid, GUID_SIZE+1 );
#else
    WCHAR wszGuid[GUID_SIZE+1];
    StringFromGUID2( rclsidHandler, wszGuid, GUID_SIZE+1 );

    BOOL fOk = ConvertString( szGuid, wszGuid, GUID_SIZE+1 );
    Assert( fOk );
#endif

    HKEY hKeyClsid;
    BOOL fResult = FALSE;

    hKeyClsid = RegGetHandlerKey(hKeyHandler,szGuid,KEY_READ,FALSE);
    
    if (hKeyClsid)
    {
    DWORD   dwType = REG_DWORD ;
    DWORD   dwDataSize = sizeof(DWORD);
    LONG lRet;

        lRet = RegQueryValueEx(hKeyClsid,SZ_REGISTRATIONFLAGSKEY,NULL, &dwType,
                                         (LPBYTE) pdwSyncMgrRegisterFlags,
                                         &dwDataSize);
        RegCloseKey( hKeyClsid );

        fResult = (ERROR_SUCCESS == lRet) ? TRUE : FALSE;
    }
    else
    {
        //
        // Non-existent key, so nothing to remove
        //

    }

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSetUserDefaults
//
//  Synopsis:   Registers default values for auto and idle sync
//
//              Setup based on Handler and UserPreferences
//
//  History:    20-May-98       SitaramR       Created
//
//----------------------------------------------------------------------------

STDAPI_(void) RegSetUserDefaults()
{
HKEY hKeyUser = NULL;
BOOL fLogon = FALSE;
BOOL fLogoff = FALSE;
FILETIME ftHandlerReg;
DWORD dwHandlerRegistrationFlags;

    CMutex  CMutexRegistry(NULL, FALSE,SZ_REGSITRYMUTEXNAME);
    CMutexRegistry.Enter();

    // get the combined handler registration toplevel flags and timeStamp
    // to see if should bother enumerating the rest.
    if (!RegGetCombinedHandlerRegFlags(&dwHandlerRegistrationFlags,&ftHandlerReg))
    {
        CMutexRegistry.Leave();
        return;
    }

    if (0 != (dwHandlerRegistrationFlags & 
                (SYNCMGRREGISTERFLAG_CONNECT | SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) ) )
    {

        // See if AutoSync key needs to be updated
        hKeyUser =  RegGetCurrentUserKey(SYNCTYPE_AUTOSYNC,KEY_WRITE |  KEY_READ,TRUE);

        if (hKeyUser)
        {
        FILETIME ftUserAutoSync;

            // if got the User get the timestamp and see if it is older than the handlers
            // If this is a new user filetime will be 0

            RegGetTimeStamp(hKeyUser,&ftUserAutoSync);

            if (CompareFileTime(&ftUserAutoSync,&ftHandlerReg) < 0)
            {
            DWORD dwHandlerChangedFlags;

                // need to walk through handlers and update what we need to set based
                // on each handlers timestamp since we don't want a handler that registered
                // for idle to cause us to turn AutoSync back on and vis-a-versa
                    
                if (RegGetChangedHandlerFlags(&ftUserAutoSync,&dwHandlerChangedFlags))
                {
                BOOL fLogon = (dwHandlerChangedFlags & SYNCMGRREGISTERFLAG_CONNECT) ? TRUE : FALSE;
                BOOL fLogoff = (dwHandlerChangedFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) ? TRUE : FALSE;

                    RegSetAutoSyncDefaults(fLogon,fLogoff);
                }

            }

            RegCloseKey(hKeyUser);
            hKeyUser = NULL;
        }
    }
    
    if (0 != (dwHandlerRegistrationFlags & SYNCMGRREGISTERFLAG_IDLE ) )
    {

        // now check for Idle same logic as above could probably combine
        // into a function
        // See if AutoSync key needs to be updated
        hKeyUser =  RegGetCurrentUserKey(SYNCTYPE_IDLE, KEY_WRITE |  KEY_READ,TRUE);


        if (hKeyUser)
        {
        FILETIME ftUserIdleSync;

            // if got the User get the timestamp and see if it is older than the handlers
            // If this is a new user filetime will be 0

            RegGetTimeStamp(hKeyUser,&ftUserIdleSync);

            if (CompareFileTime(&ftUserIdleSync,&ftHandlerReg) < 0)
            {
            DWORD dwHandlerChangedFlags;

                // need to walk through handlers and update what we need to set based
                // on each handlers timestamp since we don't want a handler that registered
                // for AutoSync to cause us to turn Idle back on and vis-a-versa
                
                if (RegGetChangedHandlerFlags(&ftUserIdleSync,&dwHandlerChangedFlags))
                {
                    if (dwHandlerChangedFlags & SYNCMGRREGISTERFLAG_IDLE)
                    {
                        RegSetIdleSyncDefaults(TRUE);
                    }

                }

            }

            RegCloseKey(hKeyUser);
            hKeyUser = NULL;
        }
    }


    CMutexRegistry.Leave();
}



//+---------------------------------------------------------------------------
//
//  Function:   RegSetAutoSyncDefaults
//
//  Synopsis:   Registers default values for auto sync
//
//  History:    20-May-98       SitaramR       Created
//
//----------------------------------------------------------------------------

STDAPI_(void) RegSetAutoSyncDefaults(BOOL fLogon,BOOL fLogoff)
{
    CONNECTIONSETTINGS *pConnection = (LPCONNECTIONSETTINGS)
                                                ALLOC(sizeof(CONNECTIONSETTINGS));
    if ( pConnection == 0 )
        return;

    XPtr<CONNECTIONSETTINGS> xConnection( pConnection );

    INT iRet = LoadString(g_hmodThisDll,
                          IDS_LAN_CONNECTION,
                          pConnection->pszConnectionName,
                          ARRAYLEN(pConnection->pszConnectionName) );
    Assert( iRet != 0 );

    // -1 values are ignored by RegSetAutoSyncSettings.
    // if not turning on leave the User Preferences alone,
    pConnection->dwConnType = 0;
    pConnection->dwLogon = fLogon ? TRUE : -1;
    pConnection->dwLogoff = fLogoff ? TRUE : -1;
    pConnection->dwPromptMeFirst = -1;
    pConnection->dwMakeConnection = -1;
    pConnection->dwIdleEnabled = -1;

    // since this bases settings on what is already set no need to
    // do a cleanreg or update the machine state
    RegSetAutoSyncSettings(pConnection, 1, 0,
                           FALSE /* fCleanReg */,
                           FALSE /* fSetMachineState */,
                           FALSE /* fPerUser */);
}

//+---------------------------------------------------------------------------
//
//  Function:   RegSetUserAutoSyncDefaults
//
//  Synopsis:   Registers user default values for auto sync
//
//  History:    39-March-99       rogerg       Created
//
//----------------------------------------------------------------------------

STDAPI RegSetUserAutoSyncDefaults(DWORD dwSyncMgrRegisterMask,
                                         DWORD dwSyncMgrRegisterFlags)
{

    // if not changing either logon or logoff just return
    if (!(dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_CONNECT)
        && !(dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) )
    {
        return NOERROR;
    }


    CONNECTIONSETTINGS *pConnection = (LPCONNECTIONSETTINGS)
                                                ALLOC(sizeof(CONNECTIONSETTINGS));
    if ( pConnection == 0 )
        return E_OUTOFMEMORY;

    XPtr<CONNECTIONSETTINGS> xConnection( pConnection );

    INT iRet = LoadString(g_hmodThisDll,
                          IDS_LAN_CONNECTION,
                          pConnection->pszConnectionName,
                          ARRAYLEN(pConnection->pszConnectionName) );
    Assert( iRet != 0 );

    // -1 values are ignored by RegSetAutoSyncSettings.
    // if not turning on leave the User Preferences alone,
    pConnection->dwConnType = 0;
    pConnection->dwLogon = -1;
    pConnection->dwLogoff = -1;
    pConnection->dwPromptMeFirst = -1;
    pConnection->dwMakeConnection = -1;
    pConnection->dwIdleEnabled = -1;

    if (dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_CONNECT)
    {
        pConnection->dwLogon = (dwSyncMgrRegisterFlags & SYNCMGRREGISTERFLAG_CONNECT)
                                                    ? TRUE : FALSE;
    }

    if (dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT)
    {
        pConnection->dwLogoff = (dwSyncMgrRegisterFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT)
                                                    ? TRUE : FALSE;
    }

    // since this bases settings on what is already set no need to
    // do a cleanreg or update the machine state
    RegSetAutoSyncSettings(pConnection, 1, 0,
                           FALSE /* fCleanReg */,
                           TRUE /* fSetMachineState */,
                           TRUE /* fPerUser */);

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Function:   RegSetIdleSyncDefaults
//
//  Synopsis:   Registers default values for idle sync
//
//  History:    20-May-98       SitaramR       Created
//
//----------------------------------------------------------------------------

STDAPI_(void) RegSetIdleSyncDefaults(BOOL fIdle)
{

    Assert(fIdle); // for now this should only be called when true;

    if (!fIdle)
    {
        return;
    }

    CONNECTIONSETTINGS *pConnection = (LPCONNECTIONSETTINGS)
                                                ALLOC(sizeof(CONNECTIONSETTINGS));
    if ( pConnection == 0 )
        return;

    XPtr<CONNECTIONSETTINGS> xConnection( pConnection );

    INT iRet = LoadString(g_hmodThisDll,
                          IDS_LAN_CONNECTION,
                          pConnection->pszConnectionName,
                          ARRAYLEN(pConnection->pszConnectionName) );
    Assert( iRet != 0 );

    pConnection->dwConnType = 0;
    pConnection->dwLogon = -1;
    pConnection->dwLogoff = -1;
    pConnection->dwPromptMeFirst = -1;
    pConnection->dwMakeConnection = -1;
    pConnection->dwIdleEnabled = TRUE;

    // set all userLevel items to -1 so user gets the defaults if new
    // but keep their settings if have already tweaked them.
    pConnection->ulIdleRetryMinutes = -1;
    pConnection->ulDelayIdleShutDownTime = -1;
    pConnection->dwRepeatSynchronization = -1;
    pConnection->ulIdleWaitMinutes = -1;
    pConnection->dwRunOnBatteries = -1;

    RegSetIdleSyncSettings(pConnection, 1, 0,
                           FALSE /* fCleanReg */,
                           FALSE /* fPerUser  */);
}


//+---------------------------------------------------------------------------
//
//  Function:   RegSetIdleSyncDefaults
//
//  Synopsis:   Registers default values for idle sync
//
//  History:    30-March-99       ROGERG       Created
//
//----------------------------------------------------------------------------

STDAPI RegSetUserIdleSyncDefaults(DWORD dwSyncMgrRegisterMask,
                                         DWORD dwSyncMgrRegisterFlags)
{

     // RegSetIdleSyncSettings doesn't handle idle enabled of -1 so only
    // call if Idle actually is set in the flags, if not just return

    if (!(dwSyncMgrRegisterMask & SYNCMGRREGISTERFLAG_IDLE))
    {
        return NOERROR;
    }

    CONNECTIONSETTINGS *pConnection = (LPCONNECTIONSETTINGS)
                                                ALLOC(sizeof(CONNECTIONSETTINGS));
    if ( pConnection == 0 )
        return E_OUTOFMEMORY;

    XPtr<CONNECTIONSETTINGS> xConnection( pConnection );

    INT iRet = LoadString(g_hmodThisDll,
                          IDS_LAN_CONNECTION,
                          pConnection->pszConnectionName,
                          ARRAYLEN(pConnection->pszConnectionName) );
    Assert( iRet != 0 );

    pConnection->dwConnType = 0;
    pConnection->dwLogon = -1;
    pConnection->dwLogoff = -1;
    pConnection->dwPromptMeFirst = -1;
    pConnection->dwMakeConnection = -1;

    pConnection->dwIdleEnabled = (SYNCMGRREGISTERFLAG_IDLE  & dwSyncMgrRegisterFlags) 
                                            ? TRUE : FALSE;

    // set all userLevel items to -1 so user gets the defaults if new
    // but keep their settings if have already tweaked them.
    pConnection->ulIdleRetryMinutes = -1;
    pConnection->ulDelayIdleShutDownTime = -1;
    pConnection->dwRepeatSynchronization = -1;
    pConnection->ulIdleWaitMinutes = -1;
    pConnection->dwRunOnBatteries = -1;

    RegSetIdleSyncSettings(pConnection, 1, 0,
                           FALSE /* fCleanReg */,
                           TRUE /* fPerUser  */);

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegGetUserRegisterFlags
//
//  Synopsis:   returns current registration flags for the User.
//
//  History:    30-March-99       ROGERG       Created
//
//----------------------------------------------------------------------------

STDAPI RegGetUserRegisterFlags(LPDWORD pdwSyncMgrRegisterFlags)
{
CONNECTIONSETTINGS connectSettings;

    *pdwSyncMgrRegisterFlags = 0;

    INT iRet = LoadString(g_hmodThisDll,
                          IDS_LAN_CONNECTION,
                          connectSettings.pszConnectionName,
                          ARRAYLEN(connectSettings.pszConnectionName) );
    if (0 == iRet)
    {
        Assert( iRet != 0 );
        return E_UNEXPECTED;
    }
    
    RegGetSyncSettings(SYNCTYPE_AUTOSYNC,&connectSettings);

    if (connectSettings.dwLogon)
    {
        *pdwSyncMgrRegisterFlags |= (SYNCMGRREGISTERFLAG_CONNECT);
    }

    if (connectSettings.dwLogoff)
    {
        *pdwSyncMgrRegisterFlags |= (SYNCMGRREGISTERFLAG_PENDINGDISCONNECT);
    }


    RegGetSyncSettings(SYNCTYPE_IDLE,&connectSettings);

    if (connectSettings.dwIdleEnabled)
    {
        *pdwSyncMgrRegisterFlags |= (SYNCMGRREGISTERFLAG_IDLE);
    }



    return NOERROR;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  Function: BOOL RegSchedHandlerItemsChecked(TCHAR *pszHandlerName, 
                                 TCHAR *pszConnectionName,
                                 TCHAR *pszScheduleName)
                                                
  Summary:  Determine if any items are checked on this handler for this schedule

  Returns:  Returns TRUE if one or more are checked, FALSE otherwise

------------------------------------------------------------------------F-F*/
BOOL  RegSchedHandlerItemsChecked(TCHAR *pszHandlerName, 
                                 TCHAR *pszConnectionName,
                                 TCHAR *pszScheduleName)
{
SCODE   sc;
HKEY     hKeyUser,
        hkeySchedName,
        hkeyConnection,
        hkeyHandler,
        hkeyItem;
DWORD   cbName = MAX_PATH,
        dwIndex = 0,
        dwCheckState = 0,
        dwType = REG_DWORD,
        dwDataSize = sizeof(DWORD);

BOOL    fItemsChecked = FALSE;
TCHAR   lpName[MAX_PATH + 1];
  
    hKeyUser =  RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        return FALSE;
    }

    smChkTo(EH_Err3,RegOpenKeyEx (hKeyUser,
                                      pszScheduleName,0,KEY_READ,
                                      &hkeySchedName));

    smChkTo(EH_Err4,RegOpenKeyEx (hkeySchedName,
                                      pszConnectionName,
                                      0,KEY_READ,
                                      &hkeyConnection));
        
    smChkTo(EH_Err5,RegOpenKeyEx (hkeyConnection,
                                      pszHandlerName,
                                      0,KEY_READ,
                                      &hkeyHandler));
    // need to enum handler items.
    while ( ERROR_SUCCESS == RegEnumKey(hkeyHandler,dwIndex,
                             lpName,cbName) )
    {
        LONG lRet;
        
        lRet = RegOpenKeyEx( hkeyHandler,
                             lpName,
                             NULL,
                             KEY_READ,
                             &hkeyItem);

        if (ERROR_SUCCESS == lRet)
        {
            RegQueryValueEx(hkeyItem,TEXT("CheckState"),
                            NULL, &dwType, (LPBYTE) &dwCheckState, &dwDataSize);
  
            RegCloseKey(hkeyItem);
    
        }
        else
        {
            goto EH_Err5;
        }
                
        if (dwCheckState)
        {
            fItemsChecked = TRUE;
            break;
        }
        dwIndex++;
    }

    RegCloseKey(hkeyHandler);
    RegCloseKey(hkeyConnection);
    RegCloseKey(hkeySchedName);
    RegCloseKey(hKeyUser);
    return fItemsChecked;

EH_Err5:
    RegCloseKey(hkeyConnection);
EH_Err4:
    RegCloseKey(hkeySchedName);
EH_Err3:
    RegCloseKey(hKeyUser);

    return fItemsChecked;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\rasui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       rasui.h
//
//  Contents:   helper functions for showing Ras UI
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

// Windows Header Files:

#ifndef _RASUIIMPL_
#define _RASUIIMPL_

class CRasUI
{
public:
    CRasUI(void);
    ~CRasUI(void);
    BOOL Initialize(void);
    BOOL IsConnectionLan(int iConnectionNum);
    void FillRasCombo(HWND hwndCtl,BOOL fForceEnum,BOOL fShowRasEntries);


private:
    LPNETAPI m_pNetApi;

    DWORD m_cEntries;
    LPRASENTRYNAME m_lprasentry; // Cached enum

};


#endif // _RASUIIMPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\rasproc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       RasProc.h
//
//  Contents:   implements Exports used by Ras for doing Pending Disconnect
//
//  Classes:    
//
//  Notes:      
//
//  History:    09-Jan-98   rogerg      Created.
//
//--------------------------------------------------------------------------

LRESULT SyncMgrRasQueryShowSyncUI(WPARAM wParam,LPARAM lParam);
LRESULT SyncMgrRasDisconnect(WPARAM wParam,LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\rasui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       rasui.cpp
//
//  Contents:   helper functions for showing Ras UI
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

extern HINSTANCE g_hmodThisDll;


//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::CRasUI, public
//
//  Synopsis:   
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CRasUI::CRasUI()
{
    m_pNetApi = NULL;

    m_cEntries = 0;
    m_lprasentry = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::~CRasUI, public
//
//  Synopsis:   
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CRasUI::~CRasUI()
{

    // clear out any cached enum
     m_cEntries = 0; // make sure on error our enum cash is reset.
    if (m_lprasentry)
    {
        FREE(m_lprasentry);
        m_lprasentry = NULL;
    }

    m_pNetApi->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::Initialize, public
//
//  Synopsis:   
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CRasUI::Initialize()
{

    if (NOERROR != MobsyncGetClassObject(MOBSYNC_CLASSOBJECTID_NETAPI,
            (void **) &m_pNetApi))
    {
        m_pNetApi = NULL;
    }

    return TRUE; // always return true, let other ras calls fail since need 
                 // to handle LAN.
}


//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::IsConnectionLan, public
//
//  Synopsis:   
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CRasUI::IsConnectionLan(int iConnectionNum)
{
    
    // ui always puts the LAN connection as the first item 
    // Need to add logic to get if truly lan if add support
    // for multiple LAN cards and/or not show if no LAN
    // card.

    if (iConnectionNum ==0)
    {
	return TRUE;
    }
    else
    {
	return FALSE;
    }

}


//+---------------------------------------------------------------------------
//
//  Member:     CRasUI::FillRasCombo, public
//
//  Synopsis:   
//
//  Arguments: hwndCtrl - Combo Ctrl to fill items with
//             fForceEnum - reenum rasphonebook instead of using cache
//             fShowRasEntries - true if should include ras entries
//                  in combo, if false, only LAN Connection is shown. 
//
//  Returns:    
//
//  Modifies:
//
//  History:    08-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CRasUI::FillRasCombo(HWND hwndCtl,BOOL fForceEnum,BOOL fShowRasEntries)
{
DWORD dwSize;
DWORD dwError;
COMBOBOXEXITEM comboItem;
DWORD cEntryIndex;
int iItem = 0;
HIMAGELIST himage;
HICON hIcon;
TCHAR szBuf[MAX_PATH + 1];
UINT ImageListflags;

    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(hwndCtl))
    {
         ImageListflags |=  ILC_MIRROR;
    }

    himage = ImageList_Create(16,16,ImageListflags ,5,20);
    if (himage)
    {
	 SendMessage(hwndCtl,CBEM_SETIMAGELIST,0,(LPARAM) himage);
    }


    if (LoadString(g_hmodThisDll, IDS_LAN_CONNECTION, szBuf, MAX_PATH))
    {
		
        hIcon = LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_LANCONNECTION));
        comboItem.iImage = ImageList_AddIcon(himage,hIcon);

        comboItem.mask = CBEIF_TEXT  | CBEIF_IMAGE  | CBEIF_LPARAM | CBEIF_INDENT
		         | CBEIF_SELECTEDIMAGE;
  
        comboItem.iItem = iItem;
        comboItem.pszText = szBuf;
        comboItem.cchTextMax = lstrlen(szBuf) + 1;
        comboItem.iIndent = 0;
        comboItem.iSelectedImage = comboItem.iImage;
        comboItem.lParam  = SYNCSCHEDINFO_FLAGS_CONNECTION_LAN;

        iItem = ComboEx_InsertItem(hwndCtl,&comboItem);
        ++iItem;
    }

    dwError = 0; // if dont' show ras there are now errors

    if (fShowRasEntries)
    {
        // if we are forced to reenum the Rasconnections then free any existing cache

        if (fForceEnum)
        {
            m_cEntries = 0;
            if (m_lprasentry)
            {
                FREE(m_lprasentry);
                m_lprasentry = NULL;
            }

        }

        // if RAS couldn't be loaded, just have LAN connection.
        if (NULL == m_lprasentry) // if don't already have an enum cached then enum now.
        {

            dwSize = sizeof(RASENTRYNAME);
	            
            m_lprasentry = (LPRASENTRYNAME) ALLOC(dwSize);
            if(!m_lprasentry)
	            goto error;
	            
            m_lprasentry->dwSize = sizeof(RASENTRYNAME);
            m_cEntries = 0;
            dwError = m_pNetApi->RasEnumEntries(NULL, NULL, 
	            m_lprasentry, &dwSize, &m_cEntries);

            if (dwError == ERROR_BUFFER_TOO_SMALL)
	    {
	        FREE(m_lprasentry);
	        m_lprasentry =  (LPRASENTRYNAME) ALLOC(dwSize);
	        if(!m_lprasentry)
		        goto error;
		        
	        m_lprasentry->dwSize = sizeof(RASENTRYNAME);
	        m_cEntries = 0;
	        dwError = m_pNetApi->RasEnumEntries(NULL, NULL, 
		        m_lprasentry, &dwSize, &m_cEntries);
            
                Assert(0 == dwError);
	    }

            if (dwError)
	            goto error;
        }

        cEntryIndex = m_cEntries;

        comboItem.mask = CBEIF_DI_SETITEM | CBEIF_TEXT  | CBEIF_IMAGE  | CBEIF_LPARAM | CBEIF_INDENT
		        | CBEIF_SELECTEDIMAGE ;

        hIcon = LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_RASCONNECTION)); 
        comboItem.iImage = ImageList_AddIcon(himage,hIcon);
        comboItem.iItem = iItem;
        comboItem.iIndent = 0;
        comboItem.iSelectedImage = comboItem.iImage;
        comboItem.lParam  = SYNCSCHEDINFO_FLAGS_CONNECTION_WAN;

        while(cEntryIndex)
        {
            comboItem.pszText = m_lprasentry[cEntryIndex-1].szEntryName;

            iItem = ComboEx_InsertItem(hwndCtl,&comboItem);

	    cEntryIndex--;
        }
    }

error:	
    SendMessage(hwndCtl, CB_SETCURSEL,0, 0);
    
    if (dwError)
    {
        m_cEntries = 0; // make sure on error our enum cash is reset.
        if (m_lprasentry)
        {
            FREE(m_lprasentry);
            m_lprasentry = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\rasproc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       RasProc.cpp
//
//  Contents:   Exports used by Ras for doing Pending Disconnect
//
//  Classes:    
//
//  Notes:      
//
//  History:    09-Jan-98   rogerg      Created.
//
//--------------------------------------------------------------------------

// Windows Header Files:

// !!! define this file winver to be at least 5.0 so we can get
// NT 5.0 specific ras structures and still be a single binary
// Ras calls made on < 50 will fail because structure is wrong size.

// Do not use preocompiled headers since they would have already defined
// the Winver to be 40

#ifdef WINVER
#undef WINVER
#endif

#define WINVER 0x500


#include <windows.h>
#include <commctrl.h>
#include <objbase.h>

#include "mobsync.h"
#include "mobsyncp.h"

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "netapi.h"
#include "syncmgrr.h"
#include "rasui.h"
#include "dllreg.h"
#include "cnetapi.h"
#include "rasproc.h"

extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo.

//+-------------------------------------------------------------------
//
//  Function:   SyncMgrRasProc
//
//  Synopsis:   Main entry point for RAS to call to perform
//		a pending disconnect.
//
//  Arguments:  
//
//
//  Notes:
//
//--------------------------------------------------------------------

LRESULT CALLBACK  SyncMgrRasProc(UINT uMsg,WPARAM wParam, LPARAM lParam)
{
   
    switch(uMsg)
    {
    case SYNCMGRRASPROC_QUERYSHOWSYNCUI:
	return SyncMgrRasQueryShowSyncUI(wParam,lParam);
	break;
    case SYNCMGRRASPROC_SYNCDISCONNECT:
	return SyncMgrRasDisconnect(wParam,lParam);
	break;
    default:
	AssertSz(0,"Unknown RasProc Message");
	break;
    };

    return -1; 
}

//+-------------------------------------------------------------------
//
//  Function:   SyncMgrRasQueryShowSyncUI
//
//  Synopsis:   Called by RAS to determine if Ras Should show
//		the Disconnect checkbox and what state it should be.
//
//  Arguments:  
//	    wParam = 0
//	    lParam = Pointer to SYNCMGRQUERYSHOWSYNCUI structure
//
//  Notes:
//
//--------------------------------------------------------------------

LRESULT SyncMgrRasQueryShowSyncUI(WPARAM wParam,LPARAM lParam)
{
CNetApi *pNetApi;
SYNCMGRQUERYSHOWSYNCUI *pQueryStruct = (SYNCMGRQUERYSHOWSYNCUI *) lParam;
// RASENTRY rasEntry;
// TCHAR lpszEntry[RAS_MaxEntryName + 1]; 
LRESULT lResult = -1;

    if (pQueryStruct->cbSize != sizeof(SYNCMGRQUERYSHOWSYNCUI))
    {
	Assert(pQueryStruct->cbSize == sizeof(SYNCMGRQUERYSHOWSYNCUI));
	return -1;
    }

   pQueryStruct->fShowCheckBox = FALSE;
   pQueryStruct->nCheckState = BST_UNCHECKED;

    pNetApi = new CNetApi();

    if (!pNetApi)
    {
	AssertSz(0,"Failed to Load Ras");
	return -1;
    }

    RegSetUserDefaults(); // Make Sure the UserDefaults are up to date

    // don't use guid lookup, instead just use the passed in name.

    if (1 /* NOERROR == pNetApi->RasConvertGuidToEntry(&(pQueryStruct->GuidConnection),
								(LPTSTR) &lpszEntry,
								&rasEntry) */)
    {
    CONNECTIONSETTINGS  connectSettings;

	lstrcpy(connectSettings.pszConnectionName,pQueryStruct->pszConnectionName); // Review, should just pass this to Function
 
	// look up preferences for this entry and see if disconnect has been chosen.
	lResult = 0; // return NOERROR even if no entry is found

	if (RegGetAutoSyncSettings(&connectSettings))
	{
	    if (connectSettings.dwLogoff)
	    {
	       pQueryStruct->fShowCheckBox = TRUE;
	       pQueryStruct->nCheckState = BST_CHECKED;
	    }
	}

    }

    pNetApi->Release();
    return lResult;
}


//+-------------------------------------------------------------------
//
//  Function:   SyncMgrRasDisconnect
//
//  Synopsis:   Main entry point for RAS to call to perform
//		a pending disconnect.
//
//  Arguments:  
//	wParam = 0
//	lParam = Pointer to SYNCMGRSYNCDISCONNECT structure
//
//  Notes:
//
//--------------------------------------------------------------------

LRESULT SyncMgrRasDisconnect(WPARAM wParam,LPARAM lParam)
{
CNetApi *pNetApi;
SYNCMGRSYNCDISCONNECT *pDisconnectStruct = (SYNCMGRSYNCDISCONNECT *) lParam;
TCHAR szEntry[RAS_MaxEntryName + 1]; 
// RASENTRY rasEntry;

    if (pDisconnectStruct->cbSize != sizeof(SYNCMGRSYNCDISCONNECT))
    {
	Assert(pDisconnectStruct->cbSize == sizeof(SYNCMGRSYNCDISCONNECT));
	return -1;
    }

    pNetApi = new CNetApi();

    if (!pNetApi)
    {
	AssertSz(0,"Failed to Load Ras");
	return -1;
    }


     
    if (1 /* NOERROR == pNetApi->RasConvertGuidToEntry(&(pDisconnectStruct->GuidConnection),
								(LPTSTR) &szEntry,
								&rasEntry) */)
    {
    HRESULT hr;
    LPUNKNOWN lpUnk;

	// invoke SyncMgr.exe informing it is a Logoff and then wait in
	// a message loop until the event we pass in gets signalled.

        lstrcpy(szEntry,pDisconnectStruct->pszConnectionName);

        hr = CoInitialize(NULL);

	if (SUCCEEDED(hr))
        {

	    hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_ALL,IID_IUnknown,(void **) &lpUnk);

	    if (NOERROR == hr)
	    {
	    LPPRIVSYNCMGRSYNCHRONIZEINVOKE pSynchInvoke = NULL;

	        hr = lpUnk->QueryInterface(IID_IPrivSyncMgrSynchronizeInvoke,
		        (void **) &pSynchInvoke);
	        
	        if (NOERROR == hr)
	        {

		    // should have everything we need 
		    hr = pSynchInvoke->RasPendingDisconnect(
				        (RAS_MaxEntryName + 1)*sizeof(TCHAR),
				        (BYTE *) szEntry);

		    pSynchInvoke->Release();

	        }

    	        lpUnk->Release();  
	    }

	    CoUninitialize();
        }
    }

  

    pNetApi->Release();
    return 0;
}


// !!!!These method are in this file so we can locally define WINVER to be 5.0 so we
// get the proper rasentry size.


#define RASENTRYNAMEW struct tagRASENTRYNAMEW
typedef struct _tagRASENTRYNAME40W
{
    DWORD dwSize;
    WCHAR szEntryName[ RAS_MaxEntryName + 1 ];
} RASENTRYNAME40W;

//+-------------------------------------------------------------------
//
//  Member:   CNetApi::RasEnumEntriesNT50
//
//  Synopsis: enums the RasEntries thunking to the NT50 structure.
//
//
//  Notes: Only Available on NT 5.0
//
//--------------------------------------------------------------------

DWORD CNetApi::RasEnumEntriesNT50(LPWSTR reserved,LPWSTR lpszPhoneBook,
                    LPRASENTRYNAME lprasEntryName,LPDWORD lpcb,LPDWORD lpcEntries)
{
BOOL fIsNT = (g_OSVersionInfo.dwPlatformId ==  VER_PLATFORM_WIN32_NT);
LPRASENTRYNAME lpRasEntryNT50 = NULL;
DWORD cbSizeNT50 = 0;
DWORD dwReturn;

    // if ras isn't loaded just return false
    // call ras exports directly fro here to ensure
    // we stick with 5.0 sizes.

    if (!fIsNT || g_OSVersionInfo.dwMajorVersion < 5)
    {
        Assert(fIsNT);
        Assert(g_OSVersionInfo.dwMajorVersion >= 5);
        return -1;
    }

    if (NOERROR != LoadRasApiDll())
    {
        return -1;
    }

    // if there is an entry name set up the NT 5.0 size.
    if (lprasEntryName)
    {
    DWORD cbNumRasEntries;

        Assert(lprasEntryName->dwSize == sizeof(RASENTRYNAME40W));

        cbNumRasEntries = (*lpcb)/sizeof(RASENTRYNAME40W);
        Assert(cbNumRasEntries > 0);
        
        if (cbNumRasEntries)
        {
            cbSizeNT50 = sizeof(RASENTRYNAME)*cbNumRasEntries;
            lpRasEntryNT50 = (RASENTRYNAME *) ALLOC(cbSizeNT50);

            if (NULL == lpRasEntryNT50)
            {
                // if out of memory, return an error. 
                return -1;
            }
            else
            {
                lpRasEntryNT50->dwSize =  sizeof(RASENTRYNAME);
            }
        }
    }

    dwReturn = (*m_pRasEnumEntriesW)(reserved,lpszPhoneBook,
        lpRasEntryNT50,&cbSizeNT50,lpcEntries);

    // set out buffer to size return dbSizeNT50. Bigger than
    // we need but then don't have to worry.

    *lpcb = cbSizeNT50;


    // on success thunk back to original structure.
    if (0 == dwReturn && lpRasEntryNT50)
    {
    DWORD dwItems = *lpcEntries;
    RASENTRYNAME40W *pCurRasEntry = (RASENTRYNAME40W *) lprasEntryName;
    LPRASENTRYNAME pCurRasEntryNT50 = lpRasEntryNT50;

        while(dwItems--)
        {
            pCurRasEntry->dwSize = sizeof(RASENTRYNAME40W);
            lstrcpy(pCurRasEntry->szEntryName,pCurRasEntryNT50->szEntryName);

            ++pCurRasEntry;
            ++pCurRasEntryNT50;
        }

    }

    if (lpRasEntryNT50)
    {
        FREE(lpRasEntryNT50);
    }

    return dwReturn;
}


//+-------------------------------------------------------------------
//
//  Member:   CNetApi::RasConvertGuidToEntry
//
//  Synopsis: Given a Guid, convert, finds the corresponding
//	      Ras Entry.
//
//  Arguments:  
//	pGuid - Guid of Connection to Convert.
//	lpszEntry - PhoneBook Entry if a match is found.
//	pRasEntry - Points to valid RasEntry structure if a match is found.
//
//  Notes: Only Available on NT 5.0
//
//--------------------------------------------------------------------


STDMETHODIMP CNetApi::RasConvertGuidToEntry(GUID *pGuid,LPTSTR lpszEntry,RASENTRY *pRasEntry)
{
DWORD dwSize;
DWORD cEntries;
DWORD dwError = -1;
LPRASENTRYNAME lprasentry;
BOOL fFoundMatch = FALSE;

    // if ras isn't loaded just return false
    // call ras exports directly fro here to ensure
    // we stick with 5.0 sizes.

    Assert(m_fIsUnicode);

    if (NOERROR != LoadRasApiDll())
    {
        return S_FALSE;
    }


    if (!m_hInstRasApiDll || (NULL == m_pRasEnumEntriesW)
        || (NULL == m_pRasGetEntryPropertiesW) )
    {
        return S_FALSE;
    }

    dwSize = sizeof(RASENTRYNAME);
	    
    lprasentry = (LPRASENTRYNAME) ALLOC(dwSize);
    if(!lprasentry)
    {
        goto error;
    }
	    
    lprasentry->dwSize = sizeof(RASENTRYNAME);
    cEntries = 0;
    dwError = (*m_pRasEnumEntriesW)(NULL, NULL,lprasentry, &dwSize, &cEntries);

    if (dwError == ERROR_BUFFER_TOO_SMALL)
    {
	FREE(lprasentry);
	lprasentry =  (LPRASENTRYNAME) ALLOC(dwSize);
	if(!lprasentry)
		goto error;
		
	lprasentry->dwSize = sizeof(RASENTRYNAME);
	cEntries = 0;
	dwError = (*m_pRasEnumEntriesW)(NULL, NULL,lprasentry, &dwSize, &cEntries);		
    }

    if (0 != dwError)
    {
        goto error;
    }

    while(cEntries && !fFoundMatch)
    {
    TCHAR *pszEntryName = lprasentry[cEntries-1].szEntryName;
    TCHAR *pszPhoneBookName = lprasentry[cEntries-1].szPhonebookPath;
    DWORD dwSizeRasEntry;
    LPRASENTRY pRasEntry;
    DWORD dwErr;

        dwSizeRasEntry = 0;

        // get the required size
        if (ERROR_BUFFER_TOO_SMALL ==
                (*m_pRasGetEntryPropertiesW)(pszPhoneBookName,pszEntryName,NULL, &dwSizeRasEntry,NULL,NULL))
        {
            
            // allocate the required size.
            pRasEntry = (LPRASENTRY) ALLOC(dwSizeRasEntry);

            if (pRasEntry)
            {

                pRasEntry->dwSize = sizeof(RASENTRY);

	        if (0 == (dwErr = (*m_pRasGetEntryPropertiesW)(pszPhoneBookName,pszEntryName, (LPBYTE) pRasEntry, &dwSizeRasEntry,NULL,NULL)))
	        {
	            if (IsEqualGUID(pRasEntry->guidId,*pGuid))
	            {
		        lstrcpy(lpszEntry,pszEntryName);
		        fFoundMatch = TRUE;
                    }

	        }

                FREE(pRasEntry);
            }
        }

	cEntries--;
    }

    if (FALSE == fFoundMatch)
	dwError = -1;

error:

    return (dwError == 0) ? NOERROR : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Copyright (C) Microsoft Corporation, 1999.
// Microsoft Developer Studio generated include file.
// Used by settings.rc
//
#define IDC_RUNAS_TEXT                  1070
#define IDC_SCHED_NAME_EDIT             1071
#define IDC_SCHED_NAME_EDITBOX          1072
#define IDC_PASSWORD_TEXT               1073
#define IDC_CONFIRMPASSWORD_TEXT        1074
#define IDC_EDIT2                       1075
#define IDC_STATIC1                     1076
#define IDC_RUNLOGGEDON                 1078
#define IDC_RUNALWAYS                   1079
#define IDC_STATIC2                     1081
#define DLL_STARTRESOURCEID             3000
#define IDD_RASCONNECTION               3001
#define IDS_DESCRIPTION                 3002
#define IDS_LARGEFONTNAME               3003
#define IDS_DESCRIPTION4                3004
#define IDS_DESCRIPTION2                3005
#define IDS_LARGEFONTSIZE               3006
#define IDS_DESCRIPTION3                3007
#define IDC_PHONEICON                   3009
#define IDS_SYNCHMGR_NAME               3011
#define IDC_DESCRIPTION                 3012
#define IDS_CONNECTDESCRIPTION          3013
#define IERR_PASSWORD                   3014
#define IDC_SETDEFAULT                  3015
#define IERR_INTERNAL_ERROR             3016
#define IDC_CONNECTIONCOMBO             3017
#define IERR_OUT_OF_MEMORY              3018
#define IERR_NOITEMS                    3019
#define IDS_SCHEDULE_COLUMN_TITLE       3020
#define IDS_LOGONLOGOFF_TAB             3021
#define IDS_ONIDLE_TAB                  3022
#define IDS_SCHEDULED_TAB               3023
#define IDS_SCHEDULED_TITLE             3024
#define IDS_LAN_CONNECTION              3025
#define IDS_NAMEANDLOCATION             3026
#define IDS_NETWORKMODIFIED             3027
#define IDS_LOCALMODIFIED               3028
#define IERR_GETSVCSTATE                3029
#define IERR_STOPSVC                    3030
#define IERR_PAUSESVC                   3031
#define IERR_CONTINUESVC                3032
#define IDS_SCHEDULER_NAME              3033
#define IERR_SCHEDSVC                   3034
#define IDS_START_SERVICE               3035
#define IDS_CONTINUE_SERVICE            3036
#define IDS_START_PENDING               3037
#define IERR_SERVICE_NOT_STARTED        3038
#define IERR_SERVICE_NOT_STARTED_EDIT   3039
#define IERR_INVALIDSCHEDNAME           3040
#define IDS_SCHED_WHEN                  3041
#define IDS_SCHED_LASTRUN               3042
#define IDS_SCHED_NEXTRUN               3043
#define IDS_SCHED_NEVERRUN              3044
#define IDS_SCHED_NOTSCHED              3045
#define IDS_UPDATESELECTEDITEM          3046
#define IDS_SYNCMGR_EXE_NAME            3046
#define IDI_RASCONNECTION               3047
#define IERR_NAMEINUSE                  3047
#define IDI_LANCONNECTION               3048
#define IERR_SCHEDULE_SAVE_FAIL         3049
#define IDS_SCHED_NOTAGAIN              3050
#define IDS_IDLE_TRIGGER_STRING		3051
#define IDS_SYSTEMSTART_TRIGGER_STRING	3052
#define IDS_LOGON_TRIGGER_STRING	3053
#define IDS_NEXTRUN_EVENT		3054

#define IDI_PHONE                       3101
#define IDD_PROPPAGE_LARGE              3102
#define IDD_SCHEDWIZ_WHAT               3103
#define IDD_SCHEDWIZ_CONNECTION         3104
#define IDD_AUTOSYNC                    3105
#define IDD_SCHEDSYNC                   3106
#define IDD_SCHEDWIZ_WHENWHO            3107
#define IDD_SCHEDWIZ_NAMEIT             3108
#define IDD_SCHEDPAGE_ITEMS             3109
#define IDD_PROPPAGE_MEDIUM             3110
#define IDD_SCHEDPAGE_CREDENTIALS       3110
#define IDD_SCHEDWIZ_FINISH             3111
#define IDB_SPLASH256                   3112
#define IDD_SCHEDWIZ_DAILY              3113
#define IDB_BITMAP1                     3114
#define IDD_SCHEDWIZ_ITEMS              3115
#define IDD_SCHEDWIZ_INTRO              3116
#define IDI_TASKSCHED                   3118
#define IDI_SYNCMGR                     3129
#define set_passwd_dlg                  3131
#define IDD_RESFILECONFLICTS            3132
#define IDI_KEEPBOTH                    3135
#define IDI_KEEPLOCAL                   3136
#define IDI_KEEPNETWORK                 3137
#define IDD_IDLESETTINGS                3143
#define IDD_ADVANCEDIDLESETTINGS        3144
#define IDI_SETTINGS                    3147
#define IDC_ADVANCEDIDLEOVERVIEWTEXT    3148
#define IDC_ADVANCEDIDLEWAITTEXT        3149
#define IDC_ADVANCEDIDLEMINUTESTEXT1    3150
#define IDC_ADVANCEDIDLEMINUTESTEXT2    3151
#define IDS_LOGON_TAB                   3152
#define IDS_LOGON_TEXT                  3153
#define IDC_AUTOUPDATECOMBO             4001
#define IDC_AUTOUPDATELIST              4002
#define IDC_AUTOLOGON                   4003
#define IDC_AUTOLOGOFF                  4004
#define IDC_SP_SEPARATOR                4005
#define IDC_AUTOPROMPT_ME_FIRST         4006
#define IDC_SCHEDLIST                   4007
#define IDC_SCHEDADD                    4008
#define IDC_SCHEDEDIT                   4009
#define IDC_SCHEDREMOVE                 4010
#define IDC_WIZBMP                      4013
#define IDC_NAMEIT                      4014
#define IDC_SCHEDUPDATECOMBO            4015
#define IDC_SCHEDUPDATELIST             4016
#define IDC_USERNAME                    4027
#define IDC_USERPASSWORD                4028
#define IDC_USERPASSWORDCONFIRM         4029
#define IDC_CONFIRMPASSWORD             4030
#define IDC_STARTDATE                   4033
#define startdate_dp                    4034
#define IDC_EVERYDAY                    4035
#define daily_day_rb                    4036
#define IDC_WEEKDAYS                    4037
#define daily_weekday_rb                4038
#define IDC_EVERY                       4039
#define daily_ndays_rb                  4040
#define IDC_LIST2                       4041
#define IDC_DAILYTIME                   4042
#define starttime_dp                    4043
#define daily_ndays_ud                  4044
#define daily_ndays_edit                4045
#define daily_ndays_lable               4046
#define IDC_ScheduleName                4047
#define IDC_ScheduleTime                4048
#define IDC_ConnectionName              4049
#define IDC_AUTOCONNECT                 4050
#define IDC_AUTOHIDDEN                  4051
#define IDC_AUTOCONNECT2                4051
#define IDC_ONLY_WHEN_LOGGED_ON         4051
#define IDC_AUTOREADONLY                4052
#define IDC_ConnectionText              4053
#define IDC_INTROTITLE                  4054
#define IDC_PASSWORD                    4055
#define IDC_PASSWORDBUTTON              4055
#define edt_sp_cfrmpasswd               4056
#define edt_sp_passwd                   4057
#define lbl_sp_passwd                   4058
#define lbl_sp_cfrmpasswd               4059
#define btn_sp_ok                       4060
#define btn_sp_cancel                   4061
#define IDC_IDLECHECKBOX                4062
#define IDC_ADVANCEDIDLE                4063
#define IDC_SPINIDLEWAITMINUTES         4065
#define IDC_CHECK1                      4066
#define IDC_CHECKREPEATESYNC            4067
#define IDC_SPIN3                       4068
#define IDC_SPINIDLEREPEATMINUTES       4070
#define IDC_CHECK2                      4071
#define IDC_CHECKRUNONBATTERIES         4072
#define IDC_EDITIWAITMINUTES            4073
#define IDC_EDITIDLEREPEATMINUTES       4075
#define IDD_SCHEDPAGE_SCHEDULE          4076
#define IDC_SCHED_STRING                4080
#define IDC_LASTRUN                     4081
#define IDC_NEXTRUN                     4082
#define IDC_SCHED_NAME                  4083
#define IDC_FILEANDLOCATION             4501
#define IDC_KEEPBOTH                    4502
#define IDC_KEEPLOCAL                   4503
#define IDC_KEEPNETWORK                 4504
#define IDC_NEWFILENAME                 4505
#define IDC_NETWORKMODIFIED             4506
#define IDC_LOCALMODIFIED               4507
#define IDC_VIEWNETWORK                 4508
#define IDC_VIEWLOCAL                   4509
#define IDI_DOCICON                     4510
#define IDI_EXCLAIMICON                 4511
#define IDB_BIGICON                     4512
#define IDC_STATIC3                     4513
#define IDC_STATIC4                     4514
#define IERR_ACCOUNT_NOT_FOUND          4515
#define IDS_NOLOCALINFO                 4516
#define IDS_NONETINFO                   4517
#define IDS_UNKNOWNDATE                 4519
#define IDC_APPLY_ALL                   4520
#define IDS_NETWORKMODIFIED_DATEONLY    4521
#define IDS_LOCALMODIFIED_DATEONLY      4522
#define IDS_CONFIRMSCHEDDELETE_TITLE    4600
#define IDS_CONFIRMSCHEDDELETE_TEXT     4601
#define IDS_SYNCMGRSCHED_DEFAULTNAME    4602
#define IDS_SHORTCUTNAME                4700
#define IDS_SYNCMGR_PERUSERDISPLAYNAME  4701
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        150
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1082
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\schdsync.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       schdsync.cpp
//
//  Contents:   SyncMgr AutoSync class
//
//  Classes:    CSchedSyncPage
//
//  Notes:      
//
//  History:    14-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

DWORD StartScheduler();

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo,
extern LANGID g_LangIdSystem;      // LangId of system we are running on.


#define UNLIMITED_SCHEDULE_COUNT	50 //Review:  What is a reasonable amount of shcedules to grab at a time
#define MAX_APPEND_STRING_LEN		32


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::Initialize()
//
//  PURPOSE: initialization for the autosync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSchedSyncPage::Initialize()
{
//initialize the item list
HWND hwndList = GetDlgItem(m_hwnd,IDC_SCHEDLIST);
TCHAR pszColumnTitle[MAX_PATH + 1];
LV_COLUMN columnInfo;
HIMAGELIST himage;
INT iItem = -1;
UINT ImageListflags;


	LoadString(m_hinst, IDS_SCHEDULE_COLUMN_TITLE,pszColumnTitle, MAX_PATH );

	ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP );


        ImageListflags = ILC_COLOR | ILC_MASK;
        if (IsHwndRightToLeft(m_hwnd))
        {
            ImageListflags |=  ILC_MIRROR;
        }

	// create an imagelist
        himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                         GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
	if (himage)
	{
 	   ListView_SetImageList(hwndList,himage,LVSIL_SMALL);
	}
      
	HICON hIcon = LoadIcon(m_hinst,MAKEINTRESOURCE(IDI_TASKSCHED));
        if (hIcon)
        {
            m_iDefaultIconImageIndex = ImageList_AddIcon(himage,hIcon);
        }
        else
        {
            m_iDefaultIconImageIndex = -1;
        }

	// Insert the Proper columns
	columnInfo.mask = LVCF_FMT  | LVCF_TEXT  | LVCF_WIDTH  | LVCF_SUBITEM;
	columnInfo.fmt = LVCFMT_LEFT;
	columnInfo.cx = 328;
	columnInfo .pszText =pszColumnTitle;
	columnInfo.cchTextMax = lstrlen(pszColumnTitle) + 1;
	columnInfo.iSubItem = 0;
	ListView_InsertColumn(hwndList,0,&columnInfo);
	
	if (FAILED(InitializeScheduleAgent()))
	{
		return FALSE;
	}
	ShowAllSchedules();

	ShowWindow(m_hwnd, /* nCmdShow */ SW_SHOWNORMAL ); 
	UpdateWindow(m_hwnd);


   return TRUE;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::InitializeScheduleAgent()
//
//  PURPOSE: initialization for the ISyncSCheduleMgr
//
//  RETURN VALUE: return the appropriate HRESULT.
//
//+-------------------------------------------------------------------------------
HRESULT CSchedSyncPage::InitializeScheduleAgent()
{
HRESULT hr;
LPUNKNOWN lpUnk;
m_pISyncSchedMgr = NULL;

    hr = CoCreateInstance(CLSID_SyncMgr,NULL,CLSCTX_ALL,
			IID_ISyncScheduleMgr,(void **) &lpUnk);

    if (NOERROR == hr)
    {
	hr = lpUnk->QueryInterface(IID_ISyncScheduleMgr,
		(void **) &m_pISyncSchedMgr);

        lpUnk->Release();
    }

    return hr;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::ShowAllSchedules()
//
//  PURPOSE: initialization for the schedsync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSchedSyncPage::ShowAllSchedules()
{
HRESULT hr;
BOOL fResult = FALSE;
IEnumSyncSchedules *pEnum = NULL;
int iItem = -1;
DWORD dwFetched;
HWND hwndListView = GetDlgItem(m_hwnd,IDC_SCHEDLIST);
SYNCSCHEDULECOOKIE SyncScheduleCookie;
	

    if (!m_pISyncSchedMgr || !hwndListView)
    {
        goto errRtn;
    }

    //First clear out the list
    FreeAllSchedules();
    ListView_DeleteAllItems(hwndListView);
    
    if (FAILED(hr = m_pISyncSchedMgr->EnumSyncSchedules(&pEnum)))
    {
        goto errRtn;
    }
    
    while(S_OK == pEnum->Next(1,&SyncScheduleCookie, &dwFetched))
    {
    ISyncSchedule *pISyncSched; 
    WCHAR pwszName[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH;
    LV_ITEM lvItem;

	//get the ISyncSched for this schedule
	if (FAILED(hr = m_pISyncSchedMgr->OpenSchedule(&SyncScheduleCookie, 
				        0,&pISyncSched)))
	{
	    //can't find this one in the registry - move on.
	    continue;
	}
	//Get and convert the schedules friendly name
	if (FAILED(hr = pISyncSched->GetScheduleName(&dwSize,pwszName)))
	{
            goto errRtn;
	}
		
	++iItem;
	ZeroMemory(&lvItem, sizeof(lvItem));

	lvItem.mask = LVIF_TEXT | LVIF_PARAM;
	lvItem.pszText = pwszName;
	
        if (m_iDefaultIconImageIndex >= 0)
        {
            lvItem.mask |= LVIF_IMAGE;
            lvItem.iImage = m_iDefaultIconImageIndex;
        }
				
	//Save the ISyncSched pointer in the list view data
	lvItem.lParam = (LPARAM)pISyncSched;

	//add the item to the list
	ListView_InsertItem(hwndListView, &lvItem);
    }

    if (iItem != -1)
    {
	ListView_SetItemState(hwndListView, 0, 
		 LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );		
    }

    fResult = TRUE;

errRtn:
    
    if (pEnum)
    {
        pEnum->Release();
    }

    return fResult;

}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::FreeAllSchedules()
//
//  PURPOSE: free the schedules for the schedsync page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSchedSyncPage::FreeAllSchedules()
{
	int iItem;
	int iItemCount;

	HWND hwndListView = GetDlgItem(m_hwnd,IDC_SCHEDLIST);
	
	iItemCount = ListView_GetItemCount(hwndListView);		
	
	for(iItem = 0; iItem < iItemCount; iItem++)
	{
		ISyncSchedule *pISyncSched; 
		LV_ITEM lvItem;
	
		ZeroMemory(&lvItem, sizeof(lvItem));
		lvItem.mask = LVIF_PARAM;
		lvItem.iItem = iItem;

		ListView_GetItem(hwndListView, &lvItem);				
					
		pISyncSched = (ISyncSchedule *) lvItem.lParam;
		
		if (pISyncSched)
		{
                DWORD cRefs;

			cRefs = pISyncSched->Release();
                        Assert(0 == cRefs);
		}
	}
	return TRUE;
}


//-----------------------------------------------------------------------------
//
//  FUNCTION:   CSchedSyncPage::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
//
//  PURPOSE:    Handle the various notification messages dispatched from schedule
//				page
//
//-----------------------------------------------------------------------------
BOOL CSchedSyncPage::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    if (IDC_SCHEDLIST == idFrom)
    {
        switch (pnmhdr->code)
        {
            case LVN_ITEMCHANGED:
		{
                NM_LISTVIEW *pnmv = (NM_LISTVIEW FAR *) pnmhdr; 

		    if (  (pnmv->uChanged == LVIF_STATE)  &&
			      ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED))
		    {
                    BOOL fEnable = FALSE;
                
                        if (pnmv->uNewState & LVIS_SELECTED)
                        {
                            fEnable = TRUE;
                        }

                        SetButtonState(IDC_SCHEDREMOVE,fEnable);
                        SetButtonState(IDC_SCHEDEDIT,fEnable);
		        return TRUE;
		    }						
		}
		break;
            case NM_DBLCLK:
                {
		    LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW) pnmhdr;
		    EditTask(lpnmlv->iItem);
		}
                break;
	    case NM_RETURN:
                {
		    LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW) pnmhdr;
		    EditTask(lpnmlv->iItem);
		}
	
                break;
	    default:
                break;
        }
    }
    return FALSE;
}

BOOL CSchedSyncPage::SetButtonState(int nIDDlgItem,BOOL fEnabled)
{
BOOL fResult = FALSE;
HWND hwndCtrl = GetDlgItem(m_hwnd,nIDDlgItem);
HWND hwndFocus = NULL;

    if (hwndCtrl)
    {
        if (!fEnabled) // don't bother getting focus if not disabling.
        {
            hwndFocus = GetFocus();
        }

        fResult = EnableWindow(GetDlgItem(m_hwnd,nIDDlgItem),fEnabled);

        // if control had the focus. and now it doesn't then tab to the 
        // next control
        if (hwndFocus == hwndCtrl
                && !fEnabled)
        {
            SetFocus(GetDlgItem(m_hwnd,IDC_SCHEDADD));  // if need to change focus set to add.
        }

    }

    return fResult;
}


BOOL  CSchedSyncPage::OnCommand(HWND hDlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
BOOL bResult = FALSE;

    if (BN_CLICKED == wNotifyCode) // allrespond to clicked 
    {

        switch (wID)
        {
	    case  IDC_SCHEDADD:
                {
                    StartScheduleWizard();
    
                    HWND hwndList = GetDlgItem(hDlg, IDC_SCHEDLIST);

                    BOOL fEnable = ListView_GetSelectedCount(hwndList)? TRUE: FALSE;

                    SetButtonState(IDC_SCHEDEDIT,fEnable);
                    SetButtonState(IDC_SCHEDREMOVE,fEnable);
    
                }
                break;
	    case  IDC_SCHEDREMOVE:
                {
                    HWND hwndList = GetDlgItem(hDlg, IDC_SCHEDLIST);
                    int iItem = ListView_GetSelectionMark(hwndList);
                    RemoveTask(iItem);

                    BOOL fEnable = ListView_GetSelectedCount(hwndList)? TRUE: FALSE;

                    SetButtonState(IDC_SCHEDEDIT,fEnable);
                    SetButtonState(IDC_SCHEDREMOVE,fEnable);

                }
                break;
	    case  IDC_SCHEDEDIT:
                {
                    HWND hwndList = GetDlgItem(hDlg, IDC_SCHEDLIST);
                    int iItem = ListView_GetSelectionMark(hwndList);
                    EditTask(iItem);	

                    BOOL fEnable = ListView_GetSelectedCount(hwndList)? TRUE: FALSE;

                    SetButtonState(IDC_SCHEDEDIT,fEnable);
                    SetButtonState(IDC_SCHEDREMOVE,fEnable);

                }
                break;
            default:
                break;
        }
    }

    return bResult;

}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::EditTask(int iItem)
//
//  PURPOSE: edits the selected task
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSchedSyncPage::EditTask(int iItem)
{
LV_ITEM lvItem;
WCHAR pwszScheduleName[MAX_PATH + 1];
DWORD dwSize = MAX_PATH;

    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = iItem;

    ListView_GetItem(GetDlgItem(m_hwnd, IDC_SCHEDLIST), &lvItem);

    if (lvItem.iItem != -1)
    {	
        ISyncSchedule *pISyncSched = (ISyncSchedule *) lvItem.lParam;
	//Start on the scheduled items page
	pISyncSched->EditSyncSchedule(m_hwnd, 0);
        
        pISyncSched->GetScheduleName(&dwSize, pwszScheduleName);

        ListView_SetItemText( GetDlgItem(m_hwnd,IDC_SCHEDLIST), iItem, 0,pwszScheduleName);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSchedSyncPage::RemoveTask(int iItem)
//
//  PURPOSE: removes the selected task
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

// Review - Why can't we just alloc what we need instead of eating up the stack.
BOOL CSchedSyncPage::RemoveTask(int iItem)
{
TCHAR ptszScheduleName[MAX_PATH + 1];
WCHAR pwszScheduleName[MAX_PATH + 1];
TCHAR szFmt[MAX_PATH];
TCHAR szTitle[MAX_PATH];
TCHAR szStr[MAX_PATH];
SYNCSCHEDULECOOKIE SyncSchedCookie;
DWORD dwSize = MAX_PATH;
			
	if  (!m_pISyncSchedMgr)
	{
		return FALSE;
	}

	LV_ITEM lvItem;
	ZeroMemory(&lvItem, sizeof(lvItem));

	lvItem.mask = LVIF_PARAM;
	lvItem.iItem = iItem;

	ListView_GetItem(GetDlgItem(m_hwnd, IDC_SCHEDLIST), &lvItem);

	if (lvItem.iItem == -1)
	{
		return FALSE;
	}


	ISyncSchedule *pISyncSched = (ISyncSchedule *) lvItem.lParam;

        if (NULL == pISyncSched)
        {
            return FALSE;
        }

        
        if (NOERROR != pISyncSched->GetScheduleName(&dwSize,pwszScheduleName))
        {
            *ptszScheduleName = TEXT('\0');
            dwSize = 0;
        }
        else
        {
            ConvertString(ptszScheduleName,pwszScheduleName,MAX_PATH);
        }

        // make sure user really wants to delete this schedule
        LoadString(g_hmodThisDll, IDS_CONFIRMSCHEDDELETE_TITLE, szTitle, ARRAYLEN(szTitle));
        LoadString(g_hmodThisDll, IDS_CONFIRMSCHEDDELETE_TEXT, szFmt, ARRAYLEN(szFmt));
        
        wsprintf(szStr, szFmt,ptszScheduleName);

        if (IDNO == MessageBox(m_hwnd,szStr,szTitle,MB_YESNO | MB_ICONQUESTION))
        {
            return FALSE;
        }


        dwSize = MAX_PATH;

	//Get the Cookie from the schedule
	if (FAILED(((LPSYNCSCHEDULE)pISyncSched)->GetScheduleGUIDName
					(&dwSize,ptszScheduleName)))
	{
		return FALSE;
	}
	
	ptszScheduleName[GUIDSTR_MAX] = NULL;
	ConvertString(pwszScheduleName,ptszScheduleName,MAX_PATH);
	GUIDFromString(pwszScheduleName, &SyncSchedCookie);

        
	//release this pISyncSched
	pISyncSched->Release();
	
	m_pISyncSchedMgr->RemoveSchedule(&SyncSchedCookie);

	HWND hwndList = GetDlgItem(m_hwnd, IDC_SCHEDLIST);

	ListView_DeleteItem(hwndList, iItem);
	UpdateWindow(hwndList);
	
	
	return TRUE;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: StartScheduleWizard(HINSTANCE hinst)
//
//  PURPOSE:  Display the Onestop schedsync wizard
//
//
//--------------------------------------------------------------------------------
BOOL CSchedSyncPage::StartScheduleWizard()
{

SCODE sc;
ISyncSchedule *pISyncSched;
SYNCSCHEDULECOOKIE SyncSchedCookie = GUID_NULL;

    if (!m_pISyncSchedMgr)
    {
        return FALSE;
    }

    if (S_OK == (sc = m_pISyncSchedMgr->LaunchScheduleWizard(
				        m_hwnd, 
				        0,
				        &SyncSchedCookie,		
				        &pISyncSched)))
    {
        TCHAR ptszBuf[MAX_PATH + 1];
	WCHAR pwszName[MAX_PATH + 1];
	DWORD dwSize = MAX_PATH;
	LV_ITEM lvItem;
        
        pISyncSched->GetScheduleName(&dwSize, pwszName);

        ConvertString(ptszBuf,pwszName,MAX_PATH);

	ZeroMemory(&lvItem, sizeof(lvItem));

	lvItem.mask = LVIF_TEXT | LVIF_PARAM;
	lvItem.pszText = ptszBuf;
			
        if (m_iDefaultIconImageIndex >= 0)
        {
            lvItem.mask |= LVIF_IMAGE;
            lvItem.iImage = m_iDefaultIconImageIndex;
        }
						
	//Save the ISyncSched pointer in the list view data
	lvItem.lParam = (LPARAM)pISyncSched;

	//add the item to the list
	ListView_InsertItem(GetDlgItem(m_hwnd,IDC_SCHEDLIST), &lvItem);

        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\schdsrvc.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       schdsrvc.cxx
//
//  Contents:
//
//  Notes:  Hack around the service not being started when creating tasks
//
//  Functions:	StartScheduler
//
//  History:    2/19/1997   SusiA   Cut from MSDN
//
//  Notes:      This function works for either Win9x or Windows NT.
//              If the service is running but paused, does nothing.//
//____________________________________________________________________________

#include "precomp.h"

extern OSVERSIONINFOA g_OSVersionInfo; 

#undef TRACE
#define TRACE(x)                //OutputDebugString(x)

#define MAX_SERVICE_WAIT_TIME   90000   //  a minute and a half

#define SCHED_CLASS             TEXT("SAGEWINDOWCLASS")
#define SCHED_TITLE             TEXT("SYSTEM AGENT COM WINDOW")
#define SCHED_SERVICE_APP_NAME  TEXT("mstask.exe")
#define SCHED_SERVICE_NAME      TEXT("Schedule")

DWORD StartScheduler()
{
    DWORD dwTimeOut;
    DWORD dwError;

    if (g_OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)    
	{
        // Start the Win9X version of TaskScheduler.
        HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);
        
		if (hwnd != NULL)        
		{   // It is already running.
            return ERROR_SUCCESS;
        }        
		//
        //  Execute the task scheduler process.        
		//
        STARTUPINFO         sui;
        PROCESS_INFORMATION pi;
        ZeroMemory(&sui, sizeof(sui));
        sui.cb = sizeof (STARTUPINFO);
        
		TCHAR szApp[MAX_PATH];
        LPTSTR pszPath;
        
		DWORD dwRet = SearchPath(NULL,
                                 SCHED_SERVICE_APP_NAME,
                                 NULL,
                                 MAX_PATH,
                                 szApp,
                                 &pszPath);        
		if (dwRet == 0)        
		{
            return GetLastError();        
		}
        BOOL fRet = CreateProcess(szApp, NULL, NULL, NULL, FALSE,
                                  CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP,
                                  NULL,  NULL, &sui, &pi);

        if (fRet == 0)        
		{            
			return GetLastError();
        }

        //  Now that the process is started, let's wait until the window
        //  exists before we decide to return success.
        dwTimeOut = GetTickCount() + MAX_SERVICE_WAIT_TIME;
        dwError = ERROR_SERVICE_NEVER_STARTED;

        while (GetTickCount() < dwTimeOut)
        {
            if (FindWindow(SCHED_CLASS, SCHED_TITLE))
            {
                dwError = ERROR_SUCCESS;
                break;
            }
            Sleep(1000);
        }

        
		CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        
		return dwError;    
	}    
	else
    {
        // If not Win95 then start the NT version as a TaskScheduler service.
        SC_HANDLE   hSC = NULL;        
		SC_HANDLE   hSchSvc = NULL;
        hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (hSC == NULL)        
		{            
			return GetLastError();
        }
        hSchSvc = OpenService(hSC,
                              SCHED_SERVICE_NAME,
                              SERVICE_START | SERVICE_QUERY_STATUS);

        CloseServiceHandle(hSC);
        if (hSchSvc == NULL)        
		{
            return GetLastError();        
		}        
		SERVICE_STATUS SvcStatus;
        
		if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)        
		{
            CloseServiceHandle(hSchSvc);            
			return GetLastError();
        }        
		if (SvcStatus.dwCurrentState == SERVICE_RUNNING)        
		{
            // The service is already running.
            CloseServiceHandle(hSchSvc);
            return ERROR_SUCCESS;
        }
        if (StartService(hSchSvc, 0, NULL) == FALSE)
        {
            CloseServiceHandle(hSchSvc);
            return GetLastError();
        }

        dwTimeOut = GetTickCount() + MAX_SERVICE_WAIT_TIME;

        BOOL bContinue = TRUE;

        dwError = ERROR_SERVICE_NEVER_STARTED;

        while (bContinue)
        {
            if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
            {
                dwError = GetLastError();
                break;
            }

            switch (SvcStatus.dwCurrentState)
            {
                //  This is good!
                case SERVICE_RUNNING:
                    dwError = ERROR_SUCCESS;

                    //  Fall through

                //  These are bad
                case SERVICE_STOPPED:
                case SERVICE_STOP_PENDING:
                case SERVICE_PAUSE_PENDING:
                case SERVICE_PAUSED:
                    bContinue = FALSE;
                    break;

                default:
                    if (GetTickCount() < dwTimeOut)
                    {                        
                        //  How long to sleep?  According to the SDK use a tenth of the wait hint
                        //  and floor/ceil it between 1 and 10 seconds.

                        DWORD dwSleep = SvcStatus.dwWaitHint / 10;

                        if (dwSleep < 1000)
                        {
                            dwSleep = 1000;
                        }
                        else if (dwSleep > 10000)
                        {
                            dwSleep = 10000;
                        }
                        
                        TRACE("########## Waiting for Task Scheduler service to be started...\n");

                        Sleep(dwSleep);
                    }
                    else
                    {
                        TRACE("########## Starting Task Scheduler service timed out...\n");
                        bContinue = FALSE;
                    }
                    break;
            }
        }

        CloseServiceHandle(hSchSvc);

        TRACE("########## Stop waiting for Task Scheduler service to start...\n");

		return dwError;    
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\settings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Settings.cpp
//
//  Contents:   Onestop settings routines
//
//  Classes:
//
//  Notes:
//
//  History:    10-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern UINT      g_cRefThisDll;
extern CRITICAL_SECTION g_DllCriticalSection; // Global Critical Section for this DLL
extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo, setup by WinMain.

// items for context sensitive help
// Review -Should be string in resource.
TCHAR szSyncMgrHelp[]  = TEXT("mobsync.hlp");

ULONG g_aContextHelpIds[] =
{
	IDC_STATIC1,				((DWORD)  -1),
	IDC_STATIC2,				((DWORD)  -1),
	IDC_STATIC3,				((DWORD)  -1),
	IDC_STATIC4,				((DWORD)  -1),
	IDC_ADVANCEDIDLEOVERVIEWTEXT,	        ((DWORD)  -1),
	IDC_ADVANCEDIDLEWAITTEXT,		((DWORD)  -1),
	IDC_ADVANCEDIDLEMINUTESTEXT1,	        ((DWORD)  -1),
	IDC_ADVANCEDIDLEMINUTESTEXT2,	        ((DWORD)  -1),
	IDC_SP_SEPARATOR,			((DWORD)  -1),
	IDS_CONNECTDESCRIPTION,			((DWORD)  -1),
	IDC_SCHED_NAME,				((DWORD)  -1),
	IDC_SCHED_STRING,			((DWORD)  -1),
	IDC_LASTRUN,				((DWORD)  -1),
	IDC_NEXTRUN,				((DWORD)  -1),
        IDC_ConnectionText,                     ((DWORD)  -1),
	IDC_RUNLOGGEDON,			HIDC_RUNLOGGEDON,
	IDC_RUNALWAYS,				HIDC_RUNALWAYS,
	IDC_RUNAS_TEXT,				HIDC_RUNAS_TEXT,
	IDC_USERNAME,				HIDC_USERNAME,
	IDC_PASSWORD_TEXT,			HIDC_PASSWORD_TEXT,
	IDC_PASSWORD,				HIDC_PASSWORD,
	IDC_CONFIRMPASSWORD_TEXT,		HIDC_CONFIRMPASSWORD_TEXT,
	IDC_CONFIRMPASSWORD,			HIDC_CONFIRMPASSWORD,
	IDC_ADVANCEDIDLE,			HIDC_ADVANCEDIDLE,
	IDC_AUTOCONNECT,			HIDC_AUTOCONNECT,
	IDC_AUTOLOGOFF,				HIDC_AUTOLOGOFF,
	IDC_AUTOLOGON,				HIDC_AUTOLOGON,
	IDC_AUTOPROMPT_ME_FIRST,		HIDC_AUTOPROMPT_ME_FIRST,
	IDC_AUTOUPDATECOMBO,			HIDC_AUTOUPDATECOMBO,
	IDC_AUTOUPDATELIST,			HIDC_AUTOUPDATELIST,
	IDC_CHECKREPEATESYNC,			HIDC_CHECKREPEATESYNC,
	IDC_CHECKRUNONBATTERIES,		HIDC_CHECKRUNONBATTERIES,	
	IDC_EDITIDLEREPEATMINUTES,		HIDC_EDITIDLEREPEATMINUTES,
	IDC_EDITIWAITMINUTES,                   HIDC_EDITIWAITMINUTES,
        IDC_SPINIDLEREPEATMINUTES,              HIDC_EDITIDLEREPEATMINUTES,
	IDC_SPINIDLEWAITMINUTES,                HIDC_EDITIWAITMINUTES,
        IDC_IDLECHECKBOX,			HIDC_IDLECHECKBOX,
	IDC_SCHEDADD,				HIDC_SCHEDADD,
	IDC_SCHEDEDIT,				HIDC_SCHEDEDIT,
	IDC_SCHEDLIST,				HIDC_SCHEDLIST,
	IDC_SCHEDREMOVE,			HIDC_SCHEDREMOVE,
	IDC_SCHEDUPDATECOMBO,			HIDC_SCHEDUPDATECOMBO,	
	IDC_SCHEDUPDATELIST,			HIDC_SCHEDUPDATELIST,	
	IDC_SCHED_NAME_EDITBOX,			HIDC_SCHED_NAME_EDITBOX,
	0,0
};


INT_PTR CALLBACK AutoSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SchedSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK IdleSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK IdleAdvancedSettingsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

int CALLBACK PropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam);

DWORD WINAPI  SettingsThread( LPVOID lpArg );

DWORD g_SettingsThreadID = NULL;
HWND g_hwndPropSheet = NULL;
CAutoSyncPage *g_pAutoSyncPage = NULL; // shared by AutoSync and IdleSyncDlg Procs
CSchedSyncPage *g_pSchedSyncPage = NULL;
BOOL g_fInSettingsDialog = FALSE;

//+-------------------------------------------------------------------------------
//
//  FUNCTION: IsSchedulingInstalled()
//
//  PURPOSE:  Determines is there is a task scheduler on the current workstation
//
//
//--------------------------------------------------------------------------------
BOOL IsSchedulingInstalled()
{
BOOL fInstalled = FALSE;
ISchedulingAgent *pSchedAgent = NULL;

    // Review if there is a better way to test this.
    if (NOERROR == CoCreateInstance(CLSID_CSchedulingAgent,
					NULL,
					CLSCTX_INPROC_SERVER,
					IID_ISchedulingAgent,
					(LPVOID*)&pSchedAgent) )
    {
	fInstalled = TRUE;
	pSchedAgent->Release();
    }

    return fInstalled;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: IsIdleAvailable()
//
//  PURPOSE:  Determines is this machine supports can Idle
//
//
//--------------------------------------------------------------------------------

BOOL IsIdleAvailable()
{
BOOL fInstalled = FALSE;
ISchedulingAgent *pSchedAgent = NULL;

    // Review if there is a better way to test this.
    if (NOERROR == CoCreateInstance(CLSID_CSchedulingAgent,
					NULL,
					CLSCTX_INPROC_SERVER,
					IID_ISchedulingAgent,
					(LPVOID*)&pSchedAgent) )
    {
	fInstalled = TRUE;
	pSchedAgent->Release();
    }

    return fInstalled;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: IsAutoSyncAvailable()
//
//  PURPOSE:  Determines is this machine supports AutoSync
//
//
//--------------------------------------------------------------------------------

BOOL IsAutoSyncAvailable()
{
    return TRUE;
}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: DisplayOptions()
//
//  PURPOSE:  Display the Onestop autosync options
//
//
//--------------------------------------------------------------------------------
STDAPI DisplayOptions(HWND hwndOwner)
{
#define MAXNUMPROPSHEETS 3

int hr = E_FAIL;
DWORD dwError;
// always use ANSI versions since doesn't matter
PROPSHEETPAGE psp [MAXNUMPROPSHEETS];
HPROPSHEETPAGE hpsp [MAXNUMPROPSHEETS];
PROPSHEETHEADER psh;
int nPages = 0;
BOOL fIdleAvailable;
CCriticalSection cCritSect(&g_DllCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    if (g_fInSettingsDialog) // IF ALREADY DISPLAYING A DIALOG BOX, THEN JUST RETURN
    {
    HWND hwndSettings = g_hwndPropSheet;

        cCritSect.Leave();

        if (hwndSettings)
        {
	    SetForegroundWindow(hwndSettings);
        }

	return NOERROR;
    }


    g_fInSettingsDialog = TRUE;
    cCritSect.Leave();

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {

        RegSetUserDefaults(); // Make Sure the UserDefaults are up to date

        ZeroMemory(psp,sizeof(psp));
        ZeroMemory(&psh, sizeof(psh));

   
       if (IsAutoSyncAvailable())
        {
	    psp[nPages].dwSize = sizeof (psp[0]);
	    psp[nPages].dwFlags = PSP_DEFAULT | PSP_USETITLE;
	    psp[nPages].hInstance = g_hmodThisDll;
	    psp[nPages].pszTemplate = MAKEINTRESOURCE(IDD_AUTOSYNC);
	    psp[nPages].pszIcon = NULL;
	    psp[nPages].pfnDlgProc = AutoSyncDlgProc;
            //Logon only on everything but NT5
            if ((VER_PLATFORM_WIN32_WINDOWS == g_OSVersionInfo.dwPlatformId) ||
                (g_OSVersionInfo.dwMajorVersion < 5))
            {
               psp[nPages].pszTitle = MAKEINTRESOURCE(IDS_LOGON_TAB);
            }
            else
            {
	        psp[nPages].pszTitle = MAKEINTRESOURCE(IDS_LOGONLOGOFF_TAB);
            }
	    psp[nPages].lParam = 0;

            hpsp[nPages] = CreatePropertySheetPage(&(psp[nPages]));
	    ++nPages;
        }

        if (fIdleAvailable = IsIdleAvailable())
        {
    
            psp[nPages].dwSize = sizeof (psp[0]);
	        psp[nPages].dwFlags = PSP_DEFAULT | PSP_USETITLE;

	        psp[nPages].hInstance = g_hmodThisDll;
	        psp[nPages].pszTemplate = MAKEINTRESOURCE(IDD_IDLESETTINGS);
	        psp[nPages].pszIcon = NULL;
	        psp[nPages].pfnDlgProc = IdleSyncDlgProc;
	        psp[nPages].pszTitle = MAKEINTRESOURCE(IDS_ONIDLE_TAB);
	        psp[nPages].lParam = 0;

            hpsp[nPages] = CreatePropertySheetPage(&(psp[nPages]));

	    ++nPages;
        }

    
        // Review - if have idle have schedule, why not collapse
        // all these IsxxxAvailable into one call.
        if (fIdleAvailable /* IsSchedulingInstalled() */)
        {
	    psp[nPages].dwSize = sizeof (psp[0]);
	    psp[nPages].dwFlags = PSP_DEFAULT | PSP_USETITLE;
	    psp[nPages].hInstance = g_hmodThisDll;
	    psp[nPages].pszTemplate = MAKEINTRESOURCE(IDD_SCHEDSYNC);
	    psp[nPages].pszIcon = NULL;
	    psp[nPages].pfnDlgProc = SchedSyncDlgProc;
	    psp[nPages].pszTitle = MAKEINTRESOURCE(IDS_SCHEDULED_TAB);
	    psp[nPages].lParam = 0;

            hpsp[nPages] = CreatePropertySheetPage(&(psp[nPages]));

	    ++nPages;
        }

   
        Assert(nPages <= MAXNUMPROPSHEETS);

        psh.dwSize = sizeof (psh);
        psh.dwFlags = PSH_DEFAULT | PSH_USECALLBACK | PSH_USEHICON;
        psh.hwndParent = hwndOwner;
        psh.hInstance = g_hmodThisDll;
        psh.pszIcon = NULL;
        psh.hIcon =  LoadIcon(g_hmodThisDll, MAKEINTRESOURCE(IDI_SYNCMGR));
        psh.pszCaption = MAKEINTRESOURCE(IDS_SCHEDULED_TITLE);
        psh.nPages = nPages;
        psh.phpage = hpsp;
        psh.pfnCallback = PropSheetProc;
        psh.nStartPage = 0;

        hr = (int)PropertySheet(&psh);

        // remove global classes

        if (g_pAutoSyncPage)
        {
	    delete g_pAutoSyncPage;
	    g_pAutoSyncPage = NULL;
        }

        g_SettingsThreadID = NULL;

        if (g_pSchedSyncPage)
        {
            delete g_pSchedSyncPage;
            g_pSchedSyncPage = NULL;
        }

        g_hwndPropSheet = NULL;

        CoFreeUnusedLibraries();
        CoUninitialize();
    }

    if (hr == -1)
    {
        dwError = GetLastError();
    }

    cCritSect.Enter();
    g_fInSettingsDialog = FALSE; // allow another settings to be created.
    cCritSect.Leave();

    return hr;
}


//+-------------------------------------------------------------------------------
//  FUNCTION: AutoSyncDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------

INT_PTR CALLBACK AutoSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
WORD wNotifyCode = HIWORD(wParam); // notification code

    switch (uMessage)
    {
        case WM_INITDIALOG:
 	    {
                // if on NT 4.0 or Win9x hide the logoff
                // button

                //!!! warning, if you change platform logic must also change
                //  logic for && out logoff flag in Register Interfaces.

                if ((VER_PLATFORM_WIN32_WINDOWS == g_OSVersionInfo.dwPlatformId)
                    || (VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId
                        && g_OSVersionInfo.dwMajorVersion < 5) )
                {
                HWND hwndLogoff = GetDlgItem(hDlg,IDC_AUTOLOGOFF);

                    if (hwndLogoff)
                    {
                        ShowWindow(hwndLogoff,SW_HIDE);
                        EnableWindow(hwndLogoff,FALSE);
                    }

                }

                if (NULL == g_pAutoSyncPage)
                {
                    g_pAutoSyncPage = new CAutoSyncPage(g_hmodThisDll);
                }

		    if (g_pAutoSyncPage)
		    {
			    g_pAutoSyncPage->SetAutoSyncHwnd(hDlg);
			    g_pAutoSyncPage->InitializeHwnd(hDlg,SYNCTYPE_AUTOSYNC,0);
                return TRUE;
		    }	
            else
            {
                return FALSE;
            }
	    }
	    break;
  
        case WM_DESTROY:
		{

                    if (g_pAutoSyncPage && g_pAutoSyncPage->m_pItemListViewAutoSync)
                    {
                        delete  g_pAutoSyncPage->m_pItemListViewAutoSync;
                        g_pAutoSyncPage->m_pItemListViewAutoSync = NULL;
                    }

		}
		break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
				case IDC_AUTOUPDATECOMBO:
				{
					if (wNotifyCode == CBN_SELCHANGE)
					{
						HWND hwndCombo = (HWND) lParam;
						if (g_pAutoSyncPage)
						{
						g_pAutoSyncPage->ShowItemsOnThisConnection
										(hDlg,SYNCTYPE_AUTOSYNC,ComboBox_GetCurSel(hwndCombo));
						}
					}
				}
				break;
				
				case IDC_AUTOLOGON:	
				case IDC_AUTOLOGOFF:
				case IDC_AUTOPROMPT_ME_FIRST:
					{
					    if (wNotifyCode == BN_CLICKED)
					    {
						    PropSheet_Changed(g_hwndPropSheet, hDlg);
			
						    HWND hwndCtrl = (HWND) lParam;
						    g_pAutoSyncPage->SetConnectionCheck(hDlg,SYNCTYPE_AUTOSYNC,LOWORD(wParam),
											    Button_GetCheck(hwndCtrl));
				
					    }
					}
				break;
        	
				default:
                    break;

            }
            break;
		case WM_HELP:
        {
			LPHELPINFO lphi  = (LPHELPINFO)lParam;

			if (lphi->iContextType == HELPINFO_WINDOW)
			{
				WinHelp ( (HWND) lphi->hItemHandle,
					szSyncMgrHelp,
    	            HELP_WM_HELP,
					(ULONG_PTR) g_aContextHelpIds);
			}
			return TRUE;
		}
		case WM_CONTEXTMENU:
		{

			WinHelp ((HWND)wParam,
                            szSyncMgrHelp,
                            HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aContextHelpIds);
			
			return TRUE;
		}

      case WM_NOTIFYLISTVIEWEX:

            if (g_pAutoSyncPage)
            {
            int idCtrl = (int) wParam;
            LPNMHDR pnmhdr = (LPNMHDR) lParam;

                if ( (IDC_AUTOUPDATELIST != idCtrl) || (NULL == g_pAutoSyncPage->m_pItemListViewAutoSync))
                {
                    Assert(IDC_AUTOUPDATELIST == idCtrl);
                    Assert(g_pAutoSyncPage->m_pItemListViewAutoSync);
                    break;
                }

                switch (pnmhdr->code)
                {
                    case LVNEX_ITEMCHECKCOUNT:
                    {
		    LPNMLISTVIEWEXITEMCHECKCOUNT pnmvCheckCount = (LPNMLISTVIEWEXITEMCHECKCOUNT) lParam;

                        // pass along notification only if listView is done being initialized
                        // since no need to set the CheckState or mark PSheet as Dirty
                        if (g_pAutoSyncPage->m_pItemListViewAutoSyncInitialized)
                        {

                            g_pAutoSyncPage->SetItemCheckState(hDlg,SYNCTYPE_AUTOSYNC,
				        pnmvCheckCount->iItemId,pnmvCheckCount->dwItemState
                                        ,pnmvCheckCount->iCheckCount);

                            PropSheet_Changed(g_hwndPropSheet, hDlg);
                        }

                        break;
                    }
                    default:
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            if (g_pAutoSyncPage)
            {
            int idCtrl = (int) wParam;
            LPNMHDR pnmhdr = (LPNMHDR) lParam;


                // if notification for UpdateListPass it on.
                if ((IDC_AUTOUPDATELIST == idCtrl) && g_pAutoSyncPage->m_pItemListViewAutoSync)
                {
                    g_pAutoSyncPage->m_pItemListViewAutoSync->OnNotify(pnmhdr);
                    break;
                }

            }

            switch (((NMHDR FAR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                    break;

                case PSN_APPLY:
                    //User has clicked the OK or Apply button so we'll
                    //Save the current selections

                    g_pAutoSyncPage->CommitAutoSyncChanges();
                    break;
                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }

    return FALSE;
}


//+-------------------------------------------------------------------------------
//  FUNCTION: IdleSyncDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the iDLE property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------

INT_PTR CALLBACK IdleSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
WORD wNotifyCode = HIWORD(wParam); // notification code

    switch (uMessage)
    {
        case WM_INITDIALOG:
 	    {
                        /*
			RECT rc;
			HRESULT hr;


			hr = GetWindowRect(hDlg, &rc);

			hr = SetWindowPos(hDlg,
                NULL,
                ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                0,
                0,
                SWP_NOSIZE | SWP_NOACTIVATE); */


                        if (NULL == g_pAutoSyncPage)
                        {
                            g_pAutoSyncPage = new CAutoSyncPage(g_hmodThisDll);
                        }


			if (g_pAutoSyncPage)
			{
                      BOOL fConnectionsAvailable;

                                g_pAutoSyncPage->SetIdleHwnd(hDlg);
                                g_pAutoSyncPage->InitializeHwnd(hDlg,SYNCTYPE_IDLE,0);

                                // there must be at least one connection or we disable
                                // the advanced button.

                                fConnectionsAvailable  =
                                    g_pAutoSyncPage->GetNumConnections(hDlg,SYNCTYPE_IDLE)
                                    ? TRUE : FALSE;

                                EnableWindow(GetDlgItem(hDlg,IDC_ADVANCEDIDLE),fConnectionsAvailable);

                                return TRUE;
			}	
			else
			{
				return FALSE;
			}
			
		}
		break;
        case WM_DESTROY:
		{

                    if (g_pAutoSyncPage && g_pAutoSyncPage->m_pItemListViewIdle)
                    {
                        delete g_pAutoSyncPage->m_pItemListViewIdle;
                        g_pAutoSyncPage->m_pItemListViewIdle = NULL;
                    }

		//	PostQuitMessage(0);	

	            // PostQuitMessage(0);	
		}
		break;
		case WM_HELP:
        {
			LPHELPINFO lphi  = (LPHELPINFO)lParam;

			if (lphi->iContextType == HELPINFO_WINDOW)
			{
				WinHelp ( (HWND) lphi->hItemHandle,
					szSyncMgrHelp,
    	                                HELP_WM_HELP,
					(ULONG_PTR) g_aContextHelpIds);
			}
			return TRUE;
		}
		case WM_CONTEXTMENU:
		{

			WinHelp ((HWND)wParam,
                            szSyncMgrHelp,
                            HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aContextHelpIds);
			
			return TRUE;
		}
		case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_AUTOUPDATECOMBO:
		{
			if (wNotifyCode == CBN_SELCHANGE)
			{
				HWND hwndCombo = (HWND) lParam;
				if (g_pAutoSyncPage)
				{
				g_pAutoSyncPage->ShowItemsOnThisConnection
								(hDlg,SYNCTYPE_IDLE,ComboBox_GetCurSel(hwndCombo));
				}
			}
		}
		break;
	        case IDC_IDLECHECKBOX:
		    {
			if (wNotifyCode == BN_CLICKED)
			{
				PropSheet_Changed(g_hwndPropSheet, hDlg);
	
				HWND hwndCtrl = (HWND) lParam;
				g_pAutoSyncPage->SetConnectionCheck(hDlg,SYNCTYPE_IDLE,LOWORD(wParam),
									Button_GetCheck(hwndCtrl));
		
			}
		    }
	            break;
	        case IDC_ADVANCEDIDLE:
		    {
			if (wNotifyCode == BN_CLICKED)
			{
                        // bring up the advanced idle dialog passing in the autoSyncPage class
                        // as the owning class.
	                    DialogBoxParam(g_hmodThisDll,
                                MAKEINTRESOURCE(IDD_ADVANCEDIDLESETTINGS),hDlg, IdleAdvancedSettingsDlgProc,
			                    (LPARAM) g_pAutoSyncPage);

			}
		    }
	            break;
                default:
                    break;

                }
            break;
        case WM_NOTIFYLISTVIEWEX:
            if (g_pAutoSyncPage)
            {
            int idCtrl = (int) wParam;
            LPNMHDR pnmhdr = (LPNMHDR) lParam;

                if ( (IDC_AUTOUPDATELIST != idCtrl) || (NULL == g_pAutoSyncPage->m_pItemListViewIdle))
                {
                    Assert(IDC_AUTOUPDATELIST == idCtrl);
                    Assert(g_pAutoSyncPage->m_pItemListViewIdle);
                    break;
                }

                switch (pnmhdr->code)
                {
                    case LVNEX_ITEMCHECKCOUNT:
                    {
		    LPNMLISTVIEWEXITEMCHECKCOUNT pnmvCheckCount = (LPNMLISTVIEWEXITEMCHECKCOUNT) lParam;

                        // pass along notification only if listView is done being initialized
                        // since no need to set the CheckState or mark PSheet as Dirty
                        if (g_pAutoSyncPage->m_fListViewIdleInitialized)
                        {
                            g_pAutoSyncPage->SetItemCheckState(hDlg,SYNCTYPE_IDLE,
				        pnmvCheckCount->iItemId,pnmvCheckCount->dwItemState
                                        ,pnmvCheckCount->iCheckCount);

                            PropSheet_Changed(g_hwndPropSheet, hDlg);
                        }

                        break;
                    }
                    default:
                        break;
                }
            }
            break;
        case WM_NOTIFY:

            if (g_pAutoSyncPage)
            {
            int idCtrl = (int) wParam;
            LPNMHDR pnmhdr = (LPNMHDR) lParam;

                // if notification for UpdateListPass it on.
                if ((IDC_AUTOUPDATELIST == idCtrl) && g_pAutoSyncPage->m_pItemListViewIdle)
                {
                    g_pAutoSyncPage->m_pItemListViewIdle->OnNotify(pnmhdr);
                    break;
                }

                switch (((NMHDR FAR *)lParam)->code)
                {
                    case PSN_SETACTIVE:
                        break;
                    case PSN_APPLY:
                        //User has clicked the OK or Apply button so we'll
			//Save the current selections
	                g_pAutoSyncPage->CommitIdleChanges();
                        break;
                    default:
                        break;
                }
            }
            break;

        default:
            return FALSE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------------
//  FUNCTION: IdleAdvancedSettingsDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the Advanced Idle Settings.
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------


INT_PTR CALLBACK IdleAdvancedSettingsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{

    switch(uMessage)
    {
        case WM_INITDIALOG:
        {
        CONNECTIONSETTINGS ConnectionSettings;

            Assert(g_pAutoSyncPage);

            if (NULL == g_pAutoSyncPage)
                return FALSE;

            UpDown_SetRange(GetDlgItem(hDlg,IDC_SPINIDLEWAITMINUTES), SPINDIALWAITMINUTES_MIN, SPINDIALWAITMINUTES_MAX);
            Edit_LimitText(GetDlgItem(hDlg,IDC_EDITIWAITMINUTES), 3);

            UpDown_SetRange(GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES), SPINDIALREPEATMINUTES_MIN, SPINDIALREPEATMINUTES_MAX);
            Edit_LimitText(GetDlgItem(hDlg,IDC_EDITIDLEREPEATMINUTES), 3);

            // initialize user specific preferences
            // if can't get shouldn't show dialog

            // EditText cannot accept DBCS characters on Win9x so disalbe IME for 
            // Edit Boxes.

            ImmAssociateContext(GetDlgItem(hDlg,IDC_EDITIWAITMINUTES), NULL);
            ImmAssociateContext(GetDlgItem(hDlg,IDC_EDITIDLEREPEATMINUTES), NULL);

            if (NOERROR == g_pAutoSyncPage->GetAdvancedIdleSettings(&ConnectionSettings))
            {
                UpDown_SetPos(GetDlgItem(hDlg,IDC_SPINIDLEWAITMINUTES), ConnectionSettings.ulIdleWaitMinutes);
                UpDown_SetPos(GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES),ConnectionSettings.ulIdleRetryMinutes);

                Button_SetCheck(GetDlgItem(hDlg,IDC_CHECKREPEATESYNC),ConnectionSettings.dwRepeatSynchronization);
                Button_SetCheck(GetDlgItem(hDlg,IDC_CHECKRUNONBATTERIES),!(ConnectionSettings.dwRunOnBatteries));

                // if the repeat check state is selected then enable the edit box associated with it
                EnableWindow(GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES),ConnectionSettings.dwRepeatSynchronization);
                EnableWindow(GetDlgItem(hDlg,IDC_EDITIDLEREPEATMINUTES),ConnectionSettings.dwRepeatSynchronization);
                EnableWindow(GetDlgItem(hDlg,IDC_ADVANCEDIDLEMINUTESTEXT2),ConnectionSettings.dwRepeatSynchronization);

            }

            ShowWindow(hDlg,SW_SHOW);
            return TRUE;
            break;
        }
	case WM_HELP:
        {
			LPHELPINFO lphi  = (LPHELPINFO)lParam;

			if (lphi->iContextType == HELPINFO_WINDOW)
			{
				WinHelp ( (HWND) lphi->hItemHandle,
						szSyncMgrHelp,
    	                HELP_WM_HELP,
						(ULONG_PTR) g_aContextHelpIds);
			}
			return TRUE;
		}
		case WM_CONTEXTMENU:
		{

			WinHelp ((HWND)wParam,
                            szSyncMgrHelp,
                            HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aContextHelpIds);
			
			return TRUE;
		}
		case WM_COMMAND:
            switch (LOWORD(wParam))
            {
	    case IDCANCEL:
	         EndDialog(hDlg,FALSE);
	        break;
	    case IDOK:
                 if (g_pAutoSyncPage)
                 {
                CONNECTIONSETTINGS ConnectionSettings;

                    if (g_pAutoSyncPage)
                    {

                        ConnectionSettings.ulIdleWaitMinutes = GetDlgItemInt(hDlg, IDC_EDITIWAITMINUTES, NULL, FALSE);
                        ConnectionSettings.ulIdleRetryMinutes = GetDlgItemInt(hDlg, IDC_EDITIDLEREPEATMINUTES, NULL, FALSE);

                        ConnectionSettings.dwRepeatSynchronization = Button_GetCheck(GetDlgItem(hDlg,IDC_CHECKREPEATESYNC));
                        ConnectionSettings.dwRunOnBatteries = (!Button_GetCheck(GetDlgItem(hDlg,IDC_CHECKRUNONBATTERIES)));

                        g_pAutoSyncPage->SetAdvancedIdleSettings(&ConnectionSettings);
                    }
                 }
	         EndDialog(hDlg,FALSE);
	        break;
	    case IDC_EDITIWAITMINUTES:
	    {
            WORD wNotifyCode = HIWORD(wParam);
            INT iNewPos;

	        //
	        // If the user just pasted non-numeric text or an illegal numeric
	        // value, overwrite it and complain.
	        //
                if (EN_KILLFOCUS == wNotifyCode)
                {
                    iNewPos = GetDlgItemInt(hDlg, IDC_EDITIWAITMINUTES, NULL, FALSE);
		    if (iNewPos < SPINDIALWAITMINUTES_MIN || iNewPos > SPINDIALWAITMINUTES_MAX)
		    {
		    HWND hUD = GetDlgItem(hDlg,IDC_SPINIDLEWAITMINUTES);

                        if (iNewPos < SPINDIALWAITMINUTES_MIN)
                        {
		            UpDown_SetPos(hUD, SPINDIALWAITMINUTES_MIN);
                        }
                        else
                        {
                            UpDown_SetPos(hUD,SPINDIALWAITMINUTES_MAX);
                        }

		    }

                }
                break;
            }
	    case IDC_EDITIDLEREPEATMINUTES:
	    {
            WORD wNotifyCode = HIWORD(wParam);
            INT iNewPos;

	        //
	        // If the user just pasted non-numeric text or an illegal numeric
	        // value, overwrite it and complain.
	        //

                // Review, redundant code with other spin control.
                if (EN_KILLFOCUS  == wNotifyCode)
                {
                    iNewPos = GetDlgItemInt(hDlg, IDC_EDITIDLEREPEATMINUTES, NULL, FALSE);
		    if (iNewPos < SPINDIALREPEATMINUTES_MIN || iNewPos > SPINDIALREPEATMINUTES_MAX)
		    {
		    HWND hUD = GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES);

                        if (iNewPos < SPINDIALREPEATMINUTES_MIN)
                        {
		            UpDown_SetPos(hUD, SPINDIALREPEATMINUTES_MIN);
                        }
                        else
                        {
                            UpDown_SetPos(hUD,SPINDIALREPEATMINUTES_MAX);
                        }

		    }

                }

                break;
            }
	    case IDC_CHECKREPEATESYNC:
	    {
            WORD wNotifyCode = HIWORD(wParam);

                // if use clicked the repeat check box set set state of the other
                // items associated with it.

                if (BN_CLICKED == wNotifyCode)
                {
                BOOL fEnableState = Button_GetCheck(GetDlgItem(hDlg,IDC_CHECKREPEATESYNC));

                // if the repeat check state is selected then enable the edit box associated with it
                  EnableWindow(GetDlgItem(hDlg,IDC_SPINIDLEREPEATMINUTES),fEnableState);
                  EnableWindow(GetDlgItem(hDlg,IDC_EDITIDLEREPEATMINUTES),fEnableState);
                  EnableWindow(GetDlgItem(hDlg,IDC_ADVANCEDIDLEMINUTESTEXT2),fEnableState);
                }


                break;
	    }
            default:
                break;
        }
	default:
	    break;
    }

    return FALSE;
}


//+-------------------------------------------------------------------------------
//  FUNCTION: SchedSyncDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------


INT_PTR CALLBACK SchedSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
WORD wNotifyCode = HIWORD(wParam); // notification code
BOOL bResult = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
 	    {

		g_pSchedSyncPage = new CSchedSyncPage(g_hmodThisDll, hDlg);

		if (g_pSchedSyncPage)
		{
	            bResult =  g_pSchedSyncPage->Initialize();
		}	
			
	    }
	    break;
        case WM_DESTROY:
	    {
                g_pSchedSyncPage->FreeAllSchedules();
	    }
	    break;
	case WM_HELP:
            {
	    LPHELPINFO lphi  = (LPHELPINFO)lParam;

		    if (lphi->iContextType == HELPINFO_WINDOW)
		    {
			    WinHelp ( (HWND) lphi->hItemHandle,
				    szSyncMgrHelp,
    	                            HELP_WM_HELP,
				    (ULONG_PTR) g_aContextHelpIds);
		    }
		
                    bResult = TRUE;
	    }
            break;
	case WM_CONTEXTMENU:
	    {
		    WinHelp ((HWND)wParam,
                        szSyncMgrHelp,
                        HELP_CONTEXTMENU,
                       (ULONG_PTR)g_aContextHelpIds);
		
		    bResult =  TRUE;
	    }
            break;
        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {
	        case PSN_SETACTIVE:
                    break;

                case PSN_APPLY:
                    //User has clicked the OK or Apply button so we'll
                    //update the icon information in the .GAK file
                    break;

                 default:
		       bResult =  g_pSchedSyncPage->OnNotify(hDlg,(int)wParam,(LPNMHDR)lParam);
                 break;
            }
            break;
	case WM_COMMAND:
                bResult = g_pSchedSyncPage->OnCommand(hDlg, HIWORD(wParam), LOWORD(wParam),
                                                                                (HWND)lParam);
		break;	
	default:
            break;
    }

    return bResult;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: CALLBACK PropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam);
//
//  PURPOSE: Callback dialog init procedure the settings property dialog
//
//  PARAMETERS:
//    hwndDlg   - Dialog box window handle
//    uMsg		- current message
//    lParam    - depends on message
//
//--------------------------------------------------------------------------------

int CALLBACK PropSheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    switch(uMsg)
    {
        case PSCB_INITIALIZED:
            g_hwndPropSheet = hwndDlg;
	    return TRUE;
	    break;
	default:
	    return TRUE;
	}
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\schedif.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       schedif.h
//
//  Contents:   interfaces for synchronization scheduling
//
//  Interfaces:	IEnumSyncSchedules
//				ISyncSchedule
//				IEnumSyncItems
//	
//  Classes:    CEnumSyncSchedules
//				CSyncSchedule
//				CEnumSyncItems
//
//  Notes:      
//
//  History:    27-Feb-98   Susia      Created.
//
//--------------------------------------------------------------------------
#ifndef _SYNCSCHED_IF_
#define _SYNCSCHED_IF_

#define MAX_SCHEDULENAMESIZE (GUID_SIZE + 1 + MAX_DOMANDANDMACHINENAMESIZE + 1)

//+--------------------------------------------------------------
//
//  Class:     CEnumSyncSchedules
//
//  History:    27-Feb-98       SusiA   Created
//
//---------------------------------------------------------------
class CEnumSyncSchedules : public IEnumSyncSchedules
{
public:
	CEnumSyncSchedules(IEnumWorkItems *pIEnumWorkItems, 
					   ITaskScheduler *pITaskScheduler);
	~CEnumSyncSchedules();

	//	IUnknown members
	STDMETHODIMP			QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// IEnumSyncSchedules methods
	STDMETHODIMP Next(ULONG celt, 
					SYNCSCHEDULECOOKIE *pSyncSchedCookie,
					ULONG *pceltFetched);

	STDMETHODIMP Skip(ULONG celt);

	STDMETHODIMP Reset(void);

	STDMETHODIMP Clone(IEnumSyncSchedules **ppEnumSyncSchedules);

private:   
	ULONG m_cRef;
	IEnumWorkItems *m_pIEnumWorkItems;
	ITaskScheduler *m_pITaskScheduler;
	BOOL IsSyncMgrSched(LPCWSTR pwstrTaskName);
	BOOL IsSyncMgrSchedHidden(LPCWSTR pwstrTaskName);
        BOOL VerifyScheduleSID(LPCWSTR pwstrTaskName);
        BOOL CheckForTaskNameKey(LPCWSTR pwstrTaskName);
};
typedef CEnumSyncSchedules *LPENUMSYNCSCHEDULES;


typedef struct tagCACHELIST {
    struct tagCACHELIST *pNext;
    CLSID phandlerID;
    SYNCMGRITEMID itemID;
    DWORD dwCheckState;
} CACHELIST;


//+--------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//  History:    27-Feb-98       SusiA   Created
//
//---------------------------------------------------------------
class CSyncSchedule : public ISyncSchedulep
{

public:
	CSyncSchedule(ITask *pITask, 
				  LPTSTR ptstrGUIDName, 
				  LPTSTR ptstrFriendlyName);
	~CSyncSchedule();


	//	IUnknown members
	STDMETHODIMP			QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// ISyncSchedule methods
	STDMETHODIMP GetFlags(DWORD *pdwFlags);

	STDMETHODIMP SetFlags(DWORD dwFlags);

	STDMETHODIMP GetConnection(DWORD *pcbSize,
						LPWSTR pwszConnectionName,
						DWORD *pdwConnType);

	STDMETHODIMP SetConnection(LPCWSTR pwszConnectionName,
								DWORD dwConnType);

	STDMETHODIMP GetScheduleName(DWORD *pcbSize,
						LPWSTR pwszScheduleName);

	STDMETHODIMP SetScheduleName(LPCWSTR pwszScheduleName);

	STDMETHODIMP GetScheduleCookie(SYNCSCHEDULECOOKIE *pSyncSchedCookie);

	STDMETHODIMP SetAccountInformation(LPCWSTR pwszAccountName,
						LPCWSTR pwszPassword);

	STDMETHODIMP GetAccountInformation(DWORD *pcbSize,
						LPWSTR pwszAccountName);

	STDMETHODIMP GetTrigger(ITaskTrigger ** ppTrigger);

	STDMETHODIMP GetNextRunTime(SYSTEMTIME * pstNextRun);

	STDMETHODIMP GetMostRecentRunTime(SYSTEMTIME * pstRecentRun);

	STDMETHODIMP EditSyncSchedule(HWND  hParent,
						DWORD dwReserved);

	STDMETHODIMP AddItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo);
	
	STDMETHODIMP RegisterItems( REFCLSID pHandlerID,
                                    SYNCMGRITEMID *pItemID);

        STDMETHODIMP UnregisterItems( REFCLSID pHandlerID,
                                      SYNCMGRITEMID *pItemID);
    
        STDMETHODIMP SetItemCheck(REFCLSID pHandlerID,
						SYNCMGRITEMID *pItemID, DWORD dwCheckState);

	STDMETHODIMP GetItemCheck(REFCLSID pHandlerID,
						SYNCMGRITEMID *pItemID, DWORD *pdwCheckState);

	STDMETHODIMP EnumItems(REFCLSID pHandlerID,
						IEnumSyncItems  **ppEnumItems);

	STDMETHODIMP Save();

	STDMETHODIMP GetITask(ITask **ppITask);

        // ISyncSchedulp methods
        STDMETHODIMP GetHandlerInfo(REFCLSID pHandlerID,LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);


private:   
	SCODE Initialize();
        SCODE LoadAllHandlers();
        SCODE LoadOneHandler(REFCLSID pHandlerID);
        SCODE SetDefaultCredentials();
	SCODE GetScheduleGUIDName(DWORD *pcbSize,
			          LPTSTR ptszScheduleName);
        SCODE CacheItemCheckState(REFCLSID phandlerID,
                                  SYNCMGRITEMID itemID,
                                  DWORD dwCheckState);
        
        SCODE RetreiveCachedItemCheckState(REFCLSID phandlerID,
                                           SYNCMGRITEMID itemID,
                                           DWORD *pdwCheckState);

        SCODE ApplyCachedItemsCheckState(REFCLSID phandlerID);
        SCODE PurgeCachedItemsCheckState(REFCLSID phandlerID);
        SCODE WriteOutAndPurgeCache(void);

        CACHELIST *m_pFirstCacheEntry;

	ULONG  m_cRef;
	ITask *m_pITask;
	// 
	// Since we don't expose functions to get and set 
	// the GUID name, this one is a TCHAR for ease of writing the registry									
	TCHAR  m_ptstrGUIDName[MAX_PATH + 1];  
	
	WCHAR  m_pwszFriendlyName[MAX_PATH + 1];
	WCHAR  m_pwszConnectionName[RAS_MaxEntryName + 1];
	DWORD  m_dwConnType;
        BOOL   m_fCleanReg;

        LPCONNECTIONSETTINGS m_pConnectionSettings;
        CHndlrQueue *m_HndlrQueue;
	WORD   m_iTrigger;
	ITaskTrigger *m_pITrigger;
	BOOL m_fNewSchedule;

friend class CSyncMgrSynchronize; 
friend class CSchedSyncPage;

};
typedef CSyncSchedule *LPSYNCSCHEDULE;

//+--------------------------------------------------------------
//
//  Class:     CEnumSyncItems
//
//  History:    27-Feb-98       SusiA   Created
//
//---------------------------------------------------------------
class CEnumSyncItems : public IEnumSyncItems
{
friend class CEnumSyncItems;

public:
	CEnumSyncItems(REFGUID pHandlerId, CHndlrQueue *pHndlrQueue);
	~CEnumSyncItems();

	//	IUnknown members
	STDMETHODIMP			QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// IEnumSyncItems methods
	STDMETHODIMP Next(ULONG celt,
        			LPSYNC_HANDLER_ITEM_INFO rgelt,
					ULONG * pceltFetched);

	STDMETHODIMP Skip(ULONG celt);

	STDMETHODIMP Reset(void);

	STDMETHODIMP Clone(IEnumSyncItems ** ppEnumSyncItems);

private:   
	SCODE SetHandlerAndItem(WORD wHandlerID, WORD wItemID);
	
	ULONG m_cRef;
	GUID m_HandlerId;
	WORD m_wItemId;
	WORD m_wHandlerId;
        CHndlrQueue *m_HndlrQueue;
	BOOL m_fAllHandlers;
};
typedef CEnumSyncItems *LPENUMSYNCITEMS;

#endif // _SYNCSCHED_IF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\schedif.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       schedif.cpp
//
//  Contents:   interfaces for synchronization scheduling
//
//  Interfaces:	IEnumSyncSchedules
//				ISyncSchedule
//				IEnumSyncItems
//	
//  Classes:    CEnumSyncSchedules
//				CSyncSchedule
//				CEnumSyncItems
//
//  Notes:      
//
//  History:    27-Feb-98   Susia      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern DWORD g_dwPlatformId;
extern UINT      g_cRefThisDll; 


extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
DWORD StartScheduler();
IsFriendlyNameInUse(LPTSTR ptszScheduleGUIDName, LPCTSTR ptstrFriendlyName);

//+--------------------------------------------------------------
//
//  Class:     CEnumSyncSchedules
//
//  FUNCTION: CEnumSyncSchedules::CEnumSyncSchedules()
//
//  PURPOSE: Constructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CEnumSyncSchedules::CEnumSyncSchedules(IEnumWorkItems *pIEnumWorkItems, 
									   ITaskScheduler *pITaskScheduler)
{
    TRACE("CEnumSyncSchedules::CEnumSyncSchedules()\r\n");
    m_cRef = 1;
    ++g_cRefThisDll;

    m_pIEnumWorkItems = pIEnumWorkItems;
    m_pITaskScheduler = pITaskScheduler;
    
    m_pITaskScheduler->AddRef();
    m_pIEnumWorkItems->AddRef();

}

//+--------------------------------------------------------------
//
//  Class:     CEnumSyncSchedules
//
//  FUNCTION: CEnumSyncSchedules::~CEnumSyncSchedules()
//
//  PURPOSE: Destructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CEnumSyncSchedules::~CEnumSyncSchedules()
{
    TRACE("CEnumSyncSchedules::~CEnumSyncSchedules()\r\n");
 
    m_pITaskScheduler->Release();
    m_pIEnumWorkItems->Release();

    --g_cRefThisDll;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::QueryInterface(REFIID riid, LPVOID FAR *ppv)
//
//  PURPOSE: QI for the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        TRACE("CEnumSyncSchedules::QueryInterface()==>IID_IUknown\r\n");
    	*ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_IEnumSyncSchedules))
    {
        TRACE("CSyncScheduleMgr::QueryInterface()==>IID_IEnumSyncSchedules\r\n");
        *ppv = (LPENUMSYNCSCHEDULES) this;
    }
    if (*ppv)
    {
        AddRef();
        return NOERROR;
    }

    TRACE("CEnumSyncSchedules::QueryInterface()==>Unknown Interface!\r\n");
    return E_NOINTERFACE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::AddRef()
//
//  PURPOSE: Addref for the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumSyncSchedules::AddRef()
{
    TRACE("CEnumSyncSchedules::AddRef()\r\n");
    return ++m_cRef;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::Release()
//
//  PURPOSE: Release for the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumSyncSchedules::Release()
{
    TRACE("CEnumSyncSchedules::Release()\r\n");
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:  CEnumSyncSchedules::Next(ULONG celt, 
//					SYNCSCHEDULECOOKIE *pSyncSchedCookie,
//					ULONG *pceltFetched)
//
//  PURPOSE:  Next sync Schedule 
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::Next(ULONG celt, 
					SYNCSCHEDULECOOKIE *pSyncSchedCookie,
					ULONG *pceltFetched)
{
	SCODE sc;
	LPWSTR *pwszSchedNames;

	ULONG ulSyncCount = 0, ulTaskCount = 0;
	ULONG ulFetched;

	Assert(m_pIEnumWorkItems);

    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == pSyncSchedCookie))
    {
        return E_INVALIDARG;
    }

    //We may have to call Next multiple times, as we must filter out non-sync schedules.
    do 
    {
        ulTaskCount = 0;
		
        if (FAILED (sc = m_pIEnumWorkItems->Next(celt - ulSyncCount, 
					  &pwszSchedNames, &ulFetched)))
	{
	    return sc;
	}
	if (ulFetched == 0)
	{
	    break;
	}
	while (ulTaskCount < ulFetched)
	{
	    //IsSyncMgrSched will blow away turds
            if (  IsSyncMgrSched(pwszSchedNames[ulTaskCount]) )
            {   
                if  (!IsSyncMgrSchedHidden(pwszSchedNames[ulTaskCount]) )
	        {	
		    pwszSchedNames[ulTaskCount][GUIDSTR_MAX] = NULL;
		    GUIDFromString(pwszSchedNames[ulTaskCount], &(pSyncSchedCookie[ulSyncCount]));
		    ulSyncCount++;
	        }
            }
            //Free this TaskName, we are done with it.
	    CoTaskMemFree(pwszSchedNames[ulTaskCount]);
	    ulTaskCount++;
	}
		
	CoTaskMemFree(pwszSchedNames);
	
	} while (ulFetched && (ulSyncCount < celt));
	
	if (pceltFetched)
	{
		*pceltFetched = ulSyncCount;
	}
	if (ulSyncCount == celt)
	{
		return S_OK;
	}
	return S_FALSE;	
}	


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::Skip(ULONG celt)
//
//  PURPOSE:  skip celt sync schedules
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::Skip(ULONG celt)
{
    SCODE sc;
    LPWSTR *pwszSchedNames;

    ULONG ulSyncCount = 0, ulTaskCount = 0;
    ULONG ulFetched;

    Assert(m_pIEnumWorkItems);
	
    //We have to call Next, rather than wrap Skip, because we need the schedule name to 
    //determine if it is ours or not.
    //We may have to call Next multiple times, as we must filter out non-sync schedules.
    do 
    {
	ulTaskCount = 0;
	if (S_OK != (sc = m_pIEnumWorkItems->Next(celt - ulSyncCount, 
			                          &pwszSchedNames, &ulFetched)))
	{
	    return sc;
	}
	while (ulTaskCount < ulFetched)
	{
            //IsSyncMgrSched will blow away turds
            if (  IsSyncMgrSched(pwszSchedNames[ulTaskCount]) )
            {
                if (!IsSyncMgrSchedHidden(pwszSchedNames[ulTaskCount]) )
	        {	
		    ulSyncCount++;
	        }
            }
            //Free this TaskName, we are done with it.
	    FREE(pwszSchedNames[ulTaskCount]);
	    ulTaskCount++;
	}
		
	FREE(pwszSchedNames);
	
    } while (ulFetched && (ulSyncCount < celt));	
	
    return S_OK;	
}	

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::Reset(void)
//
//  PURPOSE: reset the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::Reset(void)
{
	Assert(m_pIEnumWorkItems);
	
	return m_pIEnumWorkItems->Reset();
	
}	

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncSchedules::Clone(IEnumSyncSchedules **ppEnumSyncSchedules)
//
//  PURPOSE: Clone the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncSchedules::Clone(IEnumSyncSchedules **ppEnumSyncSchedules)
{
	SCODE sc;
	IEnumWorkItems *pIEnumWorkItems;
	
	if (!ppEnumSyncSchedules)
	{
		return E_INVALIDARG;
	}
	Assert(m_pIEnumWorkItems);


	if (FAILED(sc = m_pIEnumWorkItems->Clone(&pIEnumWorkItems)))
	{
		return sc;
	}

	*ppEnumSyncSchedules =  new CEnumSyncSchedules(pIEnumWorkItems, m_pITaskScheduler);

	if (!ppEnumSyncSchedules)
	{
		return E_OUTOFMEMORY;	
	}

	//Constructor AddRefed it, we release it here.
	pIEnumWorkItems->Release();
	return S_OK;
}	

//--------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CEnumSyncSchedules::VerifyScheduleSID(LPCWSTR pwstrTaskName)
//
//  PURPOSE: determine if this schedule SID matches the current user SID
//          !!!Warning - This functions deletes the .job file so make sure
//                  if you call this function you validated the Task .job file
//                  was created by SyncMgr. Should change this so caller needs to
//                  delete
//
//  History:  15-Oct-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL CEnumSyncSchedules::VerifyScheduleSID(LPCWSTR pwstrTaskName)
{
    TCHAR ptszTaskName[MAX_PATH + 1],
          ptszTextualSidUser[MAX_PATH + 1],
          ptszTextualSidSched[MAX_PATH + 1];
    
    DWORD dwSizeSid=MAX_PATH * sizeof(TCHAR);

    
    if (!GetUserTextualSid(  ptszTextualSidUser, &dwSizeSid ))
    {
        return FALSE;
    }
        
    ConvertString(ptszTaskName,(WCHAR *) pwstrTaskName, MAX_PATH);

    //Truncate off the .job extension of the schedule name
    int iTaskNameLen = lstrlen(ptszTaskName);

    if (iTaskNameLen < 4)
    {
	return FALSE;
    }
    ptszTaskName[iTaskNameLen -4] = TEXT('\0');
    
    //Get the SID for this schedule from the registry
    dwSizeSid=MAX_PATH * sizeof(TCHAR);

    //If this fails the key didn't exist 
    if (!RegGetSIDForSchedule(ptszTextualSidSched, &dwSizeSid, ptszTaskName) ||
        //If this fails the key exists but has the wrong SID    
        lstrcmp(ptszTextualSidSched, ptszTextualSidUser))
    {
    
        //Try to remove the schedule
        if (FAILED(m_pITaskScheduler->Delete(pwstrTaskName)))
        {
            //pwstrTaskName should have the .job extension for this function
            RemoveScheduledJobFile((TCHAR *)pwstrTaskName);
        }
        
        //Remove our Registry settings for this schedule
        //Note this should not have the .job extension
        RegRemoveScheduledTask(ptszTaskName);

        return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CEnumSyncSchedules::CheckForTaskNameKey(LPCWSTR pwstrTaskName)
//
//  PURPOSE: check for a corresponging key for the .job
//          !!!Warning - This functions deletes the .job file so make sure
//                  if you call this function you validated the Task .job file
//                  was created by SyncMgr. Should change this so caller needs to
//                  delete

//
//  History:  21-Dec-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL CEnumSyncSchedules::CheckForTaskNameKey(LPCWSTR pwstrTaskName)
{
    HKEY hkeySchedSync,hkeyDomainUser,hkeySchedName;
    LONG lRegResult;
    TCHAR ptszTaskName[MAX_SCHEDULENAMESIZE + 5];

    hkeySchedSync = hkeyDomainUser = hkeySchedName = NULL;

    if (!pwstrTaskName)
    {
        Assert(pwstrTaskName);
        return FALSE;
    }
    
    ConvertString(ptszTaskName, (WCHAR *) pwstrTaskName, MAX_SCHEDULENAMESIZE + 4);

    int iTaskNameLen = lstrlen(ptszTaskName);

    if (iTaskNameLen < 4)
    {
	AssertSz (0, "Schedule name is too short");
        return FALSE;
    }

    ptszTaskName[iTaskNameLen -4] = TEXT('\0');


    // validate this is a valid schedule and if no registry data for 
    // it then delete the .job file. 
    // Get the UserName key from the TaskName itself since on NT schedules
    // can fire if User provided as Password as a different user thant the 
    // current user.

    //Idle GUID is the same UNICODE lenght as all GUID strings.
    int OffsetToUserName = wcslen(WSZGUID_IDLESCHEDULE)
                    + 1; // +1 for _ char between guid and user name.

    TCHAR *pszDomainAndUser = (TCHAR *) ptszTaskName + OffsetToUserName;
    
    // can't call standard function for getting since DomainName is from
    // the task, if fails its okay
    lRegResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,SCHEDSYNC_REGKEY,0,KEY_READ, &hkeySchedSync);

    if (ERROR_SUCCESS == lRegResult)
    {
        lRegResult = RegOpenKeyEx (hkeySchedSync,pszDomainAndUser,0,KEY_READ, &hkeyDomainUser);
    }

    if (ERROR_SUCCESS == lRegResult)
    {
        lRegResult = RegOpenKeyEx (hkeyDomainUser,ptszTaskName,0,KEY_READ, &hkeySchedName);
    }

    // close up the keys
    if (hkeySchedName) RegCloseKey(hkeySchedName);
    if (hkeyDomainUser) RegCloseKey(hkeyDomainUser);
    if (hkeySchedSync) RegCloseKey(hkeySchedSync);

    // if any of the keys are bad then nix the TS file and return;
    if ( ERROR_FILE_NOT_FOUND  == lRegResult)
    {
       //Try to remove the schedule
        if (FAILED(m_pITaskScheduler->Delete(pwstrTaskName)))
        {
            //pwstrTaskName should have the .job extension for this function
            RemoveScheduledJobFile((TCHAR *)pwstrTaskName);
        }
        
        return FALSE;
    }
    else 
    {    
        return TRUE;
    }

}
//--------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CEnumSyncSchedules::IsSyncMgrSched(LPCWSTR pwstrTaskName)
//
//  PURPOSE: determine if this schedule is a SyncSched
//
//  History:  03-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL CEnumSyncSchedules::IsSyncMgrSched(LPCWSTR pwstrTaskName)
{
	TCHAR pszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
	WCHAR pwszDomainAndUser[MAX_DOMANDANDMACHINENAMESIZE];
	
	Assert(m_pITaskScheduler);

	// First let's make sure our address arithmetic 
	// doesn't push us off the string
	if (lstrlen(pwstrTaskName) <= GUIDSTR_MAX)
	{
		return FALSE;
	}

        //Now make sure this was created by CREATOR_SYNCMGR_TASK.
	ITask *pITask;
	LPWSTR pwszCreator;

	if (FAILED(m_pITaskScheduler->Activate(pwstrTaskName,
				               IID_ITask,
					       (IUnknown **)&pITask)))
	{
		return FALSE;
	}
	if (FAILED(pITask->GetCreator(&pwszCreator)))
	{
		pITask->Release();
		return FALSE;
	}
	
	if (0 != lstrcmp(pwszCreator, CREATOR_SYNCMGR_TASK))
	{
		CoTaskMemFree(pwszCreator);
		pITask->Release();
		return FALSE;
	}

	CoTaskMemFree(pwszCreator);
	pITask->Release();	

        //Blow away the .job if there is no reg entry for it.
        // so remember to make sure this schedule was created by us before
        // calling
        if (!CheckForTaskNameKey(pwstrTaskName))
        {
            return FALSE;
        }
	GetDefaultDomainAndUserName(pszDomainAndUser,TEXT("_"), MAX_DOMANDANDMACHINENAMESIZE);
	ConvertString(pwszDomainAndUser, pszDomainAndUser,MAX_DOMANDANDMACHINENAMESIZE);

	//Get the Domain and User name
	if (0 != wcsncmp(&(pwstrTaskName[GUIDSTR_MAX +1]),pwszDomainAndUser,lstrlen(pwszDomainAndUser)))
	{
		return FALSE;
	}
	
	//Ok the name looks right for this user.
        //Let's make sure the SID matches as well.
        //on Win9X the SID should be the empty string
        // !! this removes the .job file and regKeys if the sid doesn't match
        if (!VerifyScheduleSID(pwstrTaskName))
        {
            return FALSE;
        }
                
   
	
	return TRUE;

}	


//--------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CEnumSyncSchedules::IsSyncMgrSchedHidden(LPCWSTR pwstrTaskName)
//
//  PURPOSE: determine if this schedule is a hidden
//
//  History:  16-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
BOOL CEnumSyncSchedules::IsSyncMgrSchedHidden(LPCWSTR pwstrTaskName)
{
SCODE	sc;
HKEY	hKeyUser,hkeySchedName;
DWORD	dwType = REG_DWORD;
DWORD	dwDataSize = sizeof(DWORD);
DWORD	dwHidden = FALSE;
int		iTaskNameLen;
int		i = 0;
TCHAR	ptstrRegName[MAX_PATH + 1];
TCHAR	ptstrNewName[MAX_PATH + 1];


    ConvertString(ptstrNewName, (WCHAR *) pwstrTaskName, MAX_PATH);

    //Truncate off the .job extension of the schedule name
    iTaskNameLen = lstrlen(ptstrNewName);

    if (iTaskNameLen < 4)
    {
	    return FALSE;
    }
    ptstrNewName[iTaskNameLen -4] = TEXT('\0');

    hKeyUser = RegGetCurrentUserKey(SYNCTYPE_SCHEDULED,KEY_READ,FALSE);

    if (NULL == hKeyUser)
    {
        return FALSE;
    }

    do 
    {	
	sc = RegEnumKey( hKeyUser, i++, ptstrRegName, MAX_PATH);
	
	//This is the schedule
	if (0 == lstrcmp(ptstrRegName,ptstrNewName))
	{
            break;
	}	
    
    } while (sc == S_OK);

    //we couldn't find the schedule
    if (sc != S_OK)
    {
	
	RegCloseKey(hKeyUser);
	return FALSE; 
    }

    //schedule found, get the hidden flag
    if (ERROR_SUCCESS != (sc = RegOpenKeyEx (hKeyUser, ptstrRegName, 0,KEY_READ, 
					      &hkeySchedName)))
    {
	RegCloseKey(hKeyUser);
	return FALSE;
    }
		    
    sc = RegQueryValueEx(hkeySchedName,TEXT("ScheduleHidden"),NULL, &dwType, 
					     (LPBYTE) &dwHidden, &dwDataSize);
	    
    RegCloseKey(hkeySchedName);	
    RegCloseKey(hKeyUser);

    if (dwHidden)
    {
        return TRUE;
    }

    return FALSE;

}

//+------------------------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//
//  FUNCTION: CSyncSchedule::CSyncSchedule()
//
//  PURPOSE:  CSyncSchedule constructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CSyncSchedule::CSyncSchedule(ITask *pITask, LPTSTR ptstrGUIDName, LPTSTR ptstrFriendlyName)
{
    TRACE("CSyncSchedule::CSyncSchedule()\r\n");
    ++g_cRefThisDll;

    m_cRef = 1;
    m_HndlrQueue = NULL;
    m_fCleanReg = FALSE;

    m_pITask = pITask;
    m_pITask->AddRef();

    m_iTrigger = 0;
    m_pITrigger = NULL;
    m_fNewSchedule = FALSE;
    m_pFirstCacheEntry = NULL;
    
    lstrcpy(m_ptstrGUIDName,ptstrGUIDName);

    ConvertString(m_pwszFriendlyName,ptstrFriendlyName, MAX_PATH);

}

//+------------------------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//
//  FUNCTION: CSyncSchedule::~CSyncSchedule()
//
//  PURPOSE:  CSyncSchedule destructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CSyncSchedule::~CSyncSchedule()
{
    TRACE("CSyncSchedule::~CSyncSchedule()\r\n");

    if (m_pITask)
    {
	m_pITask->Release();
    }
    if (m_pITrigger)
    {
    	m_pITrigger->Release();
    }

     --g_cRefThisDll;
}

//+------------------------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//
//  FUNCTION: CSyncSchedule::SetDefaultCredentials()
//
//  PURPOSE:  CSyncSchedule credential intialization
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::SetDefaultCredentials()
{

	SCODE sc = S_OK;
	
	//Set the default credentials	
	WCHAR pwszDomainAndUserName[MAX_DOMANDANDMACHINENAMESIZE];
	DWORD dwSize = MAX_DOMANDANDMACHINENAMESIZE;

	GetDefaultDomainAndUserName(pwszDomainAndUserName, TEXT("\\"), dwSize);
    	
	
	if (FAILED(sc = m_pITask->SetFlags(TASK_FLAG_RUN_ONLY_IF_LOGGED_ON)))
	{
		return sc;
	}
	if (FAILED(sc = m_pITask->SetAccountInformation(pwszDomainAndUserName,NULL)))
	{
		return sc;
	}
	return sc;
}

//+------------------------------------------------------------------------------
//
//  Class:     CSyncSchedule
//
//
//  FUNCTION: CSyncSchedule::Initialize()
//
//  PURPOSE:  CSyncSchedule intialization
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::Initialize()
{
    SCODE sc = S_OK;

    TRACE("CSyncSchedule::Initialize()\r\n");
	
    Assert(m_pITask);

    // Form the application name/path and command line params.
    //initialize the syncmgr application name
    TCHAR ptszFileName[MAX_PATH + 1];
    WCHAR pwszAppName[MAX_PATH + 1];
    WCHAR pwszSchedName[MAX_PATH + 1];

    if (!LoadString(g_hmodThisDll, IDS_SYNCMGR_EXE_NAME, ptszFileName, MAX_PATH))
    {
        return E_OUTOFMEMORY;
    }

    ConvertString(pwszAppName, ptszFileName, MAX_PATH);
    ConvertString(pwszSchedName, m_ptstrGUIDName, MAX_PATH);
	
    m_pITask->SetApplicationName(pwszAppName);

    lstrcpy(pwszAppName,SCHED_COMMAND_LINE_ARG);
    lstrcat(pwszAppName, L"\""); // put quotes to handle friendly names
    lstrcat(pwszAppName, pwszSchedName);
    lstrcat(pwszAppName, L"\"");

    if (FAILED(sc = m_pITask->SetParameters(pwszAppName)))
    {
        AssertSz(0,"m_pITask->SetParameters() failed");
        return sc;
    }

    // Specify the creator name.  SyncMGr uses this to identify syncmgr tasks
    if (FAILED(sc = m_pITask->SetCreator(CREATOR_SYNCMGR_TASK)))
    {
        AssertSz(0,"m_pITask->SetCreator() failed");
        return sc;
    }

    //Set up the Trigger
    WORD wTriggerCount;
    if (FAILED(sc = m_pITask->GetTriggerCount(&wTriggerCount)))
    {
        AssertSz(0,"m_pITask->GetTriggerCount() failed");
        return sc;
    }
    if (wTriggerCount == 0)
    {
	if (FAILED(sc = m_pITask->CreateTrigger(&m_iTrigger, &m_pITrigger)))
	{
            AssertSz(0,"m_pITask->CreateTrigger() failed");
            return sc;
    	}
    }
    else if (FAILED(sc = m_pITask->GetTrigger(m_iTrigger, &m_pITrigger)))
    {
	AssertSz(0,"m_pITask->GetTrigger() failed");
        return sc;
    }
	
    //Create a new connectionSettings for this schedule and hand off to the handler queue
    // who will free it
    m_pConnectionSettings = (LPCONNECTIONSETTINGS) 
			        ALLOC(sizeof(CONNECTIONSETTINGS));

    if (!m_pConnectionSettings)
    { 
        return E_OUTOFMEMORY;
    }
	
    // If the connection name isn't in the registry, we know this is a new schedule.
    // We set the name to the default connection name and return FALSE if it wasn't there,
    // True if it was located in the registry
    if (!RegGetSchedConnectionName(m_ptstrGUIDName, 
				  m_pConnectionSettings->pszConnectionName, 
				  MAX_PATH))
    {
        m_fNewSchedule = TRUE;
    }

    //this set defaults before quering registry, so if it can't read the reg,
    //we will just get defaults.
    RegGetSchedSyncSettings(m_pConnectionSettings, m_ptstrGUIDName);

    //Save the Connection name and type on this obj
    ConvertString(m_pwszConnectionName, m_pConnectionSettings->pszConnectionName, MAX_PATH);
    m_dwConnType = m_pConnectionSettings->dwConnType;

    if (!m_HndlrQueue)
    {
        m_HndlrQueue = new CHndlrQueue(QUEUETYPE_SETTINGS); 
        if (!m_HndlrQueue) 
        {
	    return E_OUTOFMEMORY;
        }

        if (FAILED(sc = m_HndlrQueue->InitSchedSyncSettings(m_pConnectionSettings)))
        {
	    return sc;
        }
    }

    return sc;	
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::LoadOneHandler(REFCLSID pHandlerID)
//
//  PURPOSE:  Initialize and load this handler
//
//  History:  9-Oct-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::LoadOneHandler(REFCLSID pHandlerID)
{
    SCODE sc = NOERROR;
    WORD wHandlerID;

    Assert(m_HndlrQueue);
         
    if (NOERROR == (sc = m_HndlrQueue->AddHandler(pHandlerID, &wHandlerID)))
    {
        if (FAILED(sc = m_HndlrQueue->CreateServer(wHandlerID,&pHandlerID)))
        {
            return sc;
        }
		// Initialize the handlers. 
	// If the Handler doesn't want to play on this schedule, remove him.
	if (S_FALSE == m_HndlrQueue->Initialize(wHandlerID,0,SYNCMGRFLAG_SETTINGS,0,NULL))
	{
	    m_HndlrQueue->RemoveHandler(wHandlerID);
	    return SYNCMGR_E_HANDLER_NOT_LOADED;

        }
        
        if (FAILED(sc = m_HndlrQueue->AddHandlerItemsToQueue(wHandlerID)))
        {
            return sc;
        }
        //this set defaults before quering registry, so if it can't read the reg,
        //we will just get defaults.
        m_HndlrQueue->ReadSchedSyncSettingsOnConnection(wHandlerID, m_ptstrGUIDName);

        //Apply all the cached changed to the newly loaded handler
        ApplyCachedItemsCheckState(pHandlerID);

        //Clear out the list of changes to this handler's items
        PurgeCachedItemsCheckState(pHandlerID);

    }
    if (sc == S_FALSE)
    {
	return S_OK;	
    }	
    return sc;	

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::LoadAllHandlers()
//
//  PURPOSE:  Initialize and load all the handlers
//
//  History:  6-Oct-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::LoadAllHandlers()
{
    SCODE sc = NOERROR;
    TCHAR lpName[MAX_PATH];
    DWORD cbName = MAX_PATH;
    HKEY hkSyncMgr;
    CLSID clsid;
    WORD wHandlerID;

    Assert(m_HndlrQueue);
    
    // loop through the reg getting the handlers and trying to 
    // create them.

    hkSyncMgr = RegGetHandlerTopLevelKey(KEY_READ);

    if (hkSyncMgr)
    {
	DWORD dwIndex = 0;

        // if loading all handlers and got handler key open then can clean
        // up old reg entries for this schedule
        m_fCleanReg = TRUE; 

        while ( ERROR_SUCCESS == RegEnumKey(hkSyncMgr,dwIndex,
				lpName,cbName) )
	{
	    WCHAR wcName[MAX_PATH + 1];
			
	    ConvertString(wcName, lpName, MAX_PATH);
		
	    if (NOERROR == CLSIDFromString(wcName,&clsid) )
	    {
		if (NOERROR == m_HndlrQueue->AddHandler(clsid, &wHandlerID))
		{
                HRESULT hrInit;

                    // Initialize the handlers. 
		    // If the Handler fails to create or 
                    // doesn't want to play on this schedule, remove him.
                   hrInit =  m_HndlrQueue->CreateServer(wHandlerID,&clsid);

                   if (NOERROR == hrInit)
                   {
                       hrInit = m_HndlrQueue->Initialize(wHandlerID,0
                                                ,SYNCMGRFLAG_SETTINGS,0,NULL);
                   }

		   if (NOERROR != hrInit)
                   {
			m_HndlrQueue->RemoveHandler(wHandlerID);
		   }
		}
	    }
	    dwIndex++;
	}
	RegCloseKey(hkSyncMgr);
    }

    // loop through adding items
    sc = m_HndlrQueue->FindFirstHandlerInState (HANDLERSTATE_ADDHANDLERTEMS,&wHandlerID);
	
    while (sc == S_OK)
    {
        //ignore failures here and move on.  Could be the handler just fails to addItems,
        //and we don't want to fail the whole load over that
        m_HndlrQueue->AddHandlerItemsToQueue(wHandlerID);
        
    	//this set defaults before quering registry, so if it can't read the reg,
        //we will just get defaults.
        m_HndlrQueue->ReadSchedSyncSettingsOnConnection(wHandlerID, m_ptstrGUIDName);
	sc = m_HndlrQueue->FindNextHandlerInState(wHandlerID, 
					  HANDLERSTATE_ADDHANDLERTEMS,
					  &wHandlerID);
    }
    //Apply all the chached changed to all the newly loaded handlers
    ApplyCachedItemsCheckState(GUID_NULL);
    //Clear out the list of changes to all handler items that occurred before loading
    PurgeCachedItemsCheckState(GUID_NULL);
	

    if (sc == S_FALSE)
    {
	return S_OK;	
    }
    
    return sc;	

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::CacheItemCheckState(REFCLSID phandlerID,
//                                               SYNCMGRITEMID itemID,
//                                               DWORD dwCheckState)
//
//  PURPOSE:  Cache the check state of an item for a handler that is not yet loaded
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::CacheItemCheckState(REFCLSID phandlerID,
                                         SYNCMGRITEMID itemID,
                                         DWORD dwCheckState)
{
    CACHELIST *pCurCacheEntry = m_pFirstCacheEntry;

    while (pCurCacheEntry)
    {
        if ( (phandlerID == pCurCacheEntry->phandlerID) &&
             (itemID == pCurCacheEntry->itemID)            )
        {
            pCurCacheEntry->dwCheckState = dwCheckState;
            return S_OK;
        }
        pCurCacheEntry = pCurCacheEntry->pNext;
    }
    //Not found in the list, insert it now
    pCurCacheEntry = (CACHELIST *) ALLOC(sizeof(CACHELIST));
    
    if (NULL == pCurCacheEntry)
    {
        return E_OUTOFMEMORY;
    }
    
    memset(pCurCacheEntry,0,sizeof(CACHELIST));
    
    pCurCacheEntry->phandlerID = phandlerID;
    pCurCacheEntry->itemID = itemID;
    pCurCacheEntry->dwCheckState = dwCheckState;

    pCurCacheEntry->pNext = m_pFirstCacheEntry;

    m_pFirstCacheEntry = pCurCacheEntry;

    return S_OK;

}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::RetreiveCachedItemCheckState(REFCLSID phandlerID,
//                                               SYNCMGRITEMID itemID,
//                                               DWORD *pdwCheckState)
//
//  PURPOSE:  Retreive the cached the check state (if any) of an item for 
//            a handler that is not yet loaded
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::RetreiveCachedItemCheckState(REFCLSID phandlerID,
                                         SYNCMGRITEMID itemID,
                                         DWORD *pdwCheckState)
{
    CACHELIST *pCurCacheEntry = m_pFirstCacheEntry;

    while (pCurCacheEntry)
    {
        if ( (phandlerID == pCurCacheEntry->phandlerID) &&
             (itemID == pCurCacheEntry->itemID)            )
        {
            *pdwCheckState = pCurCacheEntry->dwCheckState;
            return S_OK;
        }
        pCurCacheEntry = pCurCacheEntry->pNext;
    }
    // no problem if we didn't find it, it has already been 
    // set to either what was in the registry, or if it wasn't in the registry,
    // to the default check state
    return S_OK;

}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::ApplyCachedItemsCheckState(REFCLSID pHandlerID)
//
//  PURPOSE:  Apply any check state changes that occurred before the handler was loaded
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::ApplyCachedItemsCheckState(REFCLSID phandlerID)
{

    CACHELIST *pCurCacheEntry = m_pFirstCacheEntry;

    while (pCurCacheEntry)
    {
        if ( (phandlerID == pCurCacheEntry->phandlerID) ||
             (phandlerID == GUID_NULL)                     )
        {
            SetItemCheck( pCurCacheEntry->phandlerID,
			  &pCurCacheEntry->itemID, 
                          pCurCacheEntry->dwCheckState);

        }
        pCurCacheEntry = pCurCacheEntry->pNext;
    }
    // no problem if we didn't find it, it has already been 
    // set to either what was in the registry, or if it wasn't in the registry,
    // to the default check state
    return S_OK;
    

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::WriteOutAndPurgeCache()
//
//  PURPOSE:  If we never loaded the handlers before save, write the settings to the registry
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::WriteOutAndPurgeCache(void)
{

    CACHELIST *pCurCacheEntry = m_pFirstCacheEntry;
    CACHELIST *pTemp;    

    while (pCurCacheEntry)
    {        
       RegSetSyncItemSettings(SYNCTYPE_SCHEDULED,
                               pCurCacheEntry->phandlerID,
                               pCurCacheEntry->itemID,
                               m_pwszConnectionName,
                               pCurCacheEntry->dwCheckState,
                               m_ptstrGUIDName);

        pTemp = pCurCacheEntry;
        pCurCacheEntry= pCurCacheEntry->pNext;
        FREE(pTemp);
        pTemp = NULL;
    }
    m_pFirstCacheEntry = NULL;

    return S_OK;
    

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::PurgeCachedItemsCheckState(REFCLSID pHandlerID)
//
//  PURPOSE:  Free from the list any check state changes that occurred before the handler was loaded
//
//  History:  12-02-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CSyncSchedule::PurgeCachedItemsCheckState(REFCLSID phandlerID)
{
    CACHELIST StartNode;
    CACHELIST *pCur = NULL,
              *pPrev = &StartNode;

    pPrev->pNext = m_pFirstCacheEntry;

    while (pPrev->pNext)
    {
        pCur = pPrev->pNext;
    
        if ( (phandlerID == pCur->phandlerID) ||
             (phandlerID == GUID_NULL)                     )
        {
            pPrev->pNext = pCur->pNext;   
            FREE(pCur);
        }
        else
        {
            pPrev = pCur;
        }
    }
    m_pFirstCacheEntry = StartNode.pNext;

    return S_OK;

    

}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::QueryInterface(REFIID riid, LPVOID FAR *ppv)
//
//  PURPOSE:  QI
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        TRACE("CSyncSchedule::QueryInterface()==>IID_IUknown\r\n");
    	*ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_ISyncSchedule))
    {
        TRACE("CSyncSchedule::QueryInterface()==>IID_ISyncSchedule\r\n");
        *ppv = (LPSYNCSCHEDULE) this;
    }
    else if (IsEqualIID(riid, IID_ISyncSchedulep))
    {
        TRACE("CSyncSchedule::QueryInterface()==>IID_ISyncSchedulep\r\n");
        *ppv = (LPSYNCSCHEDULEP) this;
    }
    if (*ppv)
    {
        AddRef();
        return NOERROR;
    }

    TRACE("CSyncSchedule::QueryInterface()==>Unknown Interface!\r\n");
    return E_NOINTERFACE;
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::AddRef()
//
//  PURPOSE:  AddRef
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSyncSchedule::AddRef()
{
    TRACE("CSyncSchedule::AddRef()\r\n");
    if (m_HndlrQueue)
	m_HndlrQueue->AddRef();

    return ++m_cRef;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::Release()
//
//  PURPOSE:  Release
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSyncSchedule::Release()
{
    TRACE("CSyncSchedule::Release()\r\n");

    if (m_HndlrQueue)
	m_HndlrQueue->Release();

    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetFlags(DWORD *pdwFlags)
//
//  PURPOSE:  Get the flags for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetFlags(DWORD *pdwFlags)
{
    if (!pdwFlags)
    {
    	return E_INVALIDARG;
    }
    *pdwFlags = 0;

    Assert(m_HndlrQueue);
    
    if (m_HndlrQueue->GetCheck(IDC_AUTOHIDDEN, 0))
    {
	*pdwFlags |= SYNCSCHEDINFO_FLAGS_HIDDEN;
    }
    if (m_HndlrQueue->GetCheck(IDC_AUTOREADONLY, 0))
    {
    	*pdwFlags |= SYNCSCHEDINFO_FLAGS_READONLY;
    }
    if (m_HndlrQueue->GetCheck(IDC_AUTOCONNECT, 0))
    {
	*pdwFlags |= SYNCSCHEDINFO_FLAGS_AUTOCONNECT;
    }

    return S_OK;	
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::SetFlags(DWORD dwFlags)
//
//  PURPOSE: Set the flags for this schedule  
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetFlags(DWORD dwFlags)
{
    SCODE sc;

    Assert(m_HndlrQueue);
    
    if (FAILED(sc = m_HndlrQueue->SetConnectionCheck(IDC_AUTOREADONLY,
    	            (dwFlags & SYNCSCHEDINFO_FLAGS_READONLY) ? TRUE : FALSE, 0)))
    {		
	return sc;
    }

    if (FAILED (sc = m_HndlrQueue->SetConnectionCheck(IDC_AUTOHIDDEN,
            		(dwFlags & SYNCSCHEDINFO_FLAGS_HIDDEN) ? TRUE : FALSE, 0)))
    {		
	return sc;
    }

    sc = m_HndlrQueue->SetConnectionCheck(IDC_AUTOCONNECT,
    	                (dwFlags & SYNCSCHEDINFO_FLAGS_AUTOCONNECT) ? TRUE : FALSE,0);
	
    return sc;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetConnection(DWORD *pcbSize,
//											  LPWSTR pwszConnectionName,
//											  DWORD *pdwConnType)
//
//  PURPOSE:  Get the connection name for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetConnection(DWORD *pcbSize,
					  LPWSTR pwszConnectionName,
					  DWORD *pdwConnType)
{
	
    if (!pcbSize ||	!pwszConnectionName || !pdwConnType)
    {
	return E_INVALIDARG;
    }

    if ( ((int) *pcbSize) <= lstrlen(m_pwszConnectionName))
    {
	*pcbSize = lstrlen(m_pwszConnectionName) + 1;
	return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    lstrcpy(pwszConnectionName, m_pwszConnectionName);
    *pdwConnType = m_dwConnType;

    return S_OK;	
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:  CSyncSchedule::SetConnection(LPCWSTR pwszConnectionName, DWORD dwConnType)
//
//  PURPOSE:  Set the connection for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetConnection(LPCWSTR pwszConnectionName, DWORD dwConnType)
{
    SCODE sc = S_OK;

    if (((dwConnType == SYNCSCHEDINFO_FLAGS_CONNECTION_WAN) && (!pwszConnectionName)) ||
         ((dwConnType != SYNCSCHEDINFO_FLAGS_CONNECTION_WAN) &&
	  (dwConnType != SYNCSCHEDINFO_FLAGS_CONNECTION_LAN)   )  )
    {
	return E_INVALIDARG;
    }
    if (!m_fNewSchedule)
    {
        if (FAILED(sc = LoadAllHandlers()))
            return sc;
    }

    if (pwszConnectionName && (lstrlen(pwszConnectionName) > MAX_PATH))
    {
	return E_INVALIDARG;
    }

    m_dwConnType = dwConnType;
	
    if (!pwszConnectionName)
    {
       if (!LoadString(g_hmodThisDll, IDS_LAN_CONNECTION, 
                m_pwszConnectionName,ARRAY_SIZE(m_pwszConnectionName)))
       {
            m_pwszConnectionName[0] = NULL;
            return E_UNEXPECTED;
       }
    }
    else
    {	
	lstrcpy(m_pwszConnectionName, pwszConnectionName);
    }
    
    return sc;	
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetScheduleName(DWORD *pcbSize,
//						LPWSTR pwszScheduleName)
//
//  PURPOSE:  Get the friendly name for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetScheduleName(DWORD *pcbSize,
						LPWSTR pwszScheduleName)
{
    if (!pcbSize || !pwszScheduleName)
    {
	return E_INVALIDARG;
    }

    if ( ((int) *pcbSize) <= lstrlen(m_pwszFriendlyName))
    {
	*pcbSize = lstrlen(m_pwszFriendlyName) + 1;
	return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    lstrcpy(pwszScheduleName, m_pwszFriendlyName);

    return S_OK;	
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::SetScheduleName(LPCWSTR pwszScheduleName)
//
//  PURPOSE:  Set the friendly name for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetScheduleName(LPCWSTR pwszScheduleName)
{
TCHAR ptszFriendlyName[MAX_PATH+1];
TCHAR ptszScheduleName[MAX_PATH+1];
TCHAR *ptszWorker = NULL;
WCHAR *pwszWorker = NULL;
int iName;
DWORD dwSize = MAX_PATH;


    if (!pwszScheduleName)
    {
	return E_INVALIDARG;
    }
    if (lstrlen(pwszScheduleName) > MAX_PATH)
    {
	return E_INVALIDARG;
    }


    ConvertString(ptszFriendlyName, (WCHAR *) pwszScheduleName, MAX_PATH);
    
    //strip trailing white space off name
    iName = lstrlen(ptszFriendlyName);

    if (iName)
    {
        ptszWorker = iName + ptszFriendlyName -1;
    }

    while (iName && (*ptszWorker == TEXT(' ')))
    {
	    *ptszWorker = TEXT('\0');
            --ptszWorker;
	    iName--;
    }
    //don't allow empty string schedule names
    if (iName == 0)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }
    
    lstrcpy(ptszScheduleName, m_ptstrGUIDName);
    
    if (IsFriendlyNameInUse(ptszScheduleName, ptszFriendlyName))
    {
	//make sure it is in use by this schedule
	if (0 != lstrcmp(ptszScheduleName, m_ptstrGUIDName))
	{
	    return SYNCMGR_E_NAME_IN_USE;

	}
    }
    
    // only copy up to first leading space
    lstrcpyn(m_pwszFriendlyName, pwszScheduleName,iName);
    pwszWorker = m_pwszFriendlyName + iName;
    *pwszWorker = TEXT('\0');

    return S_OK;	
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetScheduleCookie(SYNCSCHEDULECOOKIE *pSyncSchedCookie)
//
//  PURPOSE:  Set the schedule cookie
//
//  History:  14-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetScheduleCookie(SYNCSCHEDULECOOKIE *pSyncSchedCookie)
{
    WCHAR pwszSchedName[MAX_PATH +1];

    if (!pSyncSchedCookie)
    {
	return E_INVALIDARG;
    }

    ConvertString(pwszSchedName, m_ptstrGUIDName, MAX_PATH);

    pwszSchedName[GUIDSTR_MAX] = NULL;
	
    GUIDFromString(pwszSchedName, pSyncSchedCookie);
    return S_OK;	
	
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::SetAccountInformation(LPCWSTR pwszAccountName,
//						LPCWSTR pwszPassword)
//
//  PURPOSE: Set the credentials for this schedule 
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetAccountInformation(LPCWSTR pwszAccountName,
						LPCWSTR pwszPassword)
{
    Assert(m_pITask);
    return m_pITask->SetAccountInformation(pwszAccountName, pwszPassword);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetAccountInformation(DWORD *pcbSize,
//						LPWSTR pwszAccountName)
//
//  PURPOSE:  Get the credentials for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetAccountInformation(DWORD *pcbSize,
						LPWSTR pwszAccountName)
{
    Assert(m_pITask);
    SCODE sc;

    WCHAR *pwszAccount;

    if (!pcbSize || !pwszAccountName)
    {
	return E_INVALIDARG;
    }
	
    if (FAILED(sc = m_pITask->GetAccountInformation(&pwszAccount)))
    {
	return sc;
    }
    	
    if (lstrlen(pwszAccount) > (*pcbSize) )
    {
	CoTaskMemFree(pwszAccount);
	*pcbSize = lstrlen(pwszAccount) + 1;
	return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    lstrcpy(pwszAccountName, pwszAccount);
    CoTaskMemFree(pwszAccount);
	
    return S_OK;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetTrigger(ITaskTrigger ** ppTrigger)
//
//  PURPOSE: Return the ITaskTrigger interface for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetTrigger(ITaskTrigger ** ppTrigger)
{
    SCODE sc = S_OK;

    Assert(m_pITask);
    Assert (m_pITrigger);

    if (!ppTrigger)
    {
	return E_INVALIDARG;
    }

    *ppTrigger = m_pITrigger;
    m_pITrigger->AddRef();

    return sc;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:  CSyncSchedule::GetNextRunTime(SYSTEMTIME * pstNextRun)
//
//  PURPOSE:  return the next time this schedule will run
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetNextRunTime(SYSTEMTIME * pstNextRun)
{
    Assert(m_pITask);
    return m_pITask->GetNextRunTime(pstNextRun);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:  CSyncSchedule::GetMostRecentRunTime(SYSTEMTIME * pstRecentRun)
//
//  PURPOSE:  return the last time this schedule ran 
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetMostRecentRunTime(SYSTEMTIME * pstRecentRun)
{
    Assert(m_pITask);
    return m_pITask->GetMostRecentRunTime(pstRecentRun);

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::EditSyncSchedule(HWND  hParent,
//						DWORD dwReserved)
//
//  PURPOSE:  Launch the propery sheets for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::EditSyncSchedule(HWND  hParent,
					     DWORD dwReserved)
{
    SCODE sc;
    IProvideTaskPage * pIProvideTaskPage;
    PROPSHEETHEADER    PropSheetHdr;
    HPROPSHEETPAGE    *psp;
    int iCurPage = 0;
    int iNumPages = 2;
    INT_PTR iRet;
    BOOL fReadOnlySchedule;
    BOOL fSavedItems = FALSE;
    BOOL fSavedCredentials = FALSE;
	
    WCHAR pwszScheduleName[MAX_PATH + 1];
    TCHAR ptszScheduleName[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH;

    CSelectItemsPage *pItemsPage = NULL;
#ifdef _CREDENTIALS
    CCredentialsPage *pCredentialsPage = NULL;
#endif // _CREDENTIALS

    CWizPage *pSchedPage = NULL;

    Assert (m_HndlrQueue);

    if (FAILED(sc = StartScheduler()))
    {
	return sc;
    }

    fReadOnlySchedule = m_HndlrQueue->GetCheck(IDC_AUTOREADONLY, 0);
	
    if (!fReadOnlySchedule)
    {	
	//AutoAdd new items if the schedule is not ReadOnly
	iNumPages = 4;
    }

#ifdef _CREDENTIALS
    if  (g_dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
	iNumPages++;
    }
#endif // #ifdef _CREDENTIALS

    psp = (HPROPSHEETPAGE *) ALLOC(iNumPages*sizeof(HPROPSHEETPAGE));

    if (!psp)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(psp,iNumPages*sizeof(HPROPSHEETPAGE));
    ZeroMemory(&PropSheetHdr,sizeof(PropSheetHdr));

    smMemTo(EH_Err1, pSchedPage = new CEditSchedPage(g_hmodThisDll, 
        						this, 
							&psp[iCurPage]));
		
    smMemTo(EH_Err2, pItemsPage = new CSelectItemsPage(g_hmodThisDll, 
							&fSavedItems,
							this, 
							&psp[++iCurPage], 
							IDD_SCHEDPAGE_ITEMS));
			
    if (!fReadOnlySchedule)
    {	
	// Obtain the IProvideTaskPage interface from the task object.
	smChkTo(EH_Err3, m_pITask->QueryInterface( IID_IProvideTaskPage,
						(VOID **)&pIProvideTaskPage));
		
	smChkTo(EH_Err4, pIProvideTaskPage->GetPage(TASKPAGE_SCHEDULE, TRUE, 
                                                    &psp[++iCurPage]));
	
	smChkTo(EH_Err4, pIProvideTaskPage->GetPage(TASKPAGE_SETTINGS, TRUE, 
                                                    &psp[++iCurPage]));
    }
	
#ifdef _CREDENTIALS
    if  (g_dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        smMemTo(EH_Err4, pCredentialsPage = new CCredentialsPage(g_hmodThisDll,
								&fSavedCredentials, 
                  						this, 
								&psp[++iCurPage]));
    }
    else
    {
        pCredentialsPage = NULL;
    }

#endif // #ifdef _CREDENTIALS
                
	
    GetScheduleName(&dwSize, pwszScheduleName);
    ConvertString(ptszScheduleName,pwszScheduleName, MAX_PATH);

	
    PropSheetHdr.dwSize     = sizeof(PROPSHEETHEADER);
    PropSheetHdr.dwFlags    = PSH_DEFAULT;
    PropSheetHdr.hwndParent = hParent;
    PropSheetHdr.hInstance  = NULL;
    PropSheetHdr.pszCaption = ptszScheduleName;
    PropSheetHdr.phpage     = psp;
    PropSheetHdr.nPages     = iNumPages;
    PropSheetHdr.nStartPage = 0;

    iRet = PropertySheet(&PropSheetHdr);
    
    if ((iRet > 0) && (fSavedItems || fSavedCredentials))
    {
        //  Changes were made
        sc = S_OK;
    }
    else if (iRet >= 0)
    {
        //  The user hit OK or Cancel but
        //  nothing was changed
	sc = S_FALSE;
    }
    else
    {
        //  play taps...
        sc = E_FAIL;
    }

#ifdef _CREDENTIALS
    if  ( (g_dwPlatformId == VER_PLATFORM_WIN32_NT) && pCredentialsPage)
    {
	delete pCredentialsPage;
    }
#endif // #ifdef _CREDENTIALS

EH_Err4:
    if (!fReadOnlySchedule)
    {	
	pIProvideTaskPage->Release();	
    }
EH_Err3:
    delete pItemsPage;
EH_Err2:
    delete pSchedPage;	
EH_Err1:
    FREE(psp);
    return sc;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::AddItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo);
//
//  PURPOSE:  Add a handler item to the schedule  
//
//  History:  27-Feb-98        susia        Created.
//             9-Oct-98        susia        Added delay loading of handler
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::AddItem(LPSYNC_HANDLER_ITEM_INFO pHandlerItemInfo)
{
    SCODE sc = NOERROR;

    if (!pHandlerItemInfo)
    {
	return E_INVALIDARG;
    }
    sc = m_HndlrQueue->AddHandlerItem(pHandlerItemInfo);
    
    //if the handler is not yet loaded, just write through to the registry
    if (sc == SYNCMGR_E_HANDLER_NOT_LOADED)
    {
       sc = CacheItemCheckState(pHandlerItemInfo->handlerID,
                           pHandlerItemInfo->itemID,
                           pHandlerItemInfo->dwCheckState);
    }
    
    return sc;

}

STDMETHODIMP CSyncSchedule::RegisterItems( REFCLSID pHandlerID,
                                    SYNCMGRITEMID *pItemID)
{
    //eliminated because unused and overly complicated
    return E_NOTIMPL;
}

STDMETHODIMP CSyncSchedule::UnregisterItems( REFCLSID pHandlerID,
                                      SYNCMGRITEMID *pItemID)
{
    //eliminated because unused and overly complicated
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::SetItemCheck(REFGUID pHandlerID,
//						SYNCMGRITEMID *pItemID, DWORD dwCheckState)
//
//  PURPOSE:  Set the Item CheckState
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::SetItemCheck(REFCLSID pHandlerID,
					 SYNCMGRITEMID *pItemID, DWORD dwCheckState)
{
    SCODE sc = NOERROR;

    if ((!pItemID) || (pHandlerID == GUID_NULL))
    {
	return E_INVALIDARG;
    }	
    sc = m_HndlrQueue->SetItemCheck(pHandlerID,pItemID, dwCheckState);

    if (sc == SYNCMGR_E_HANDLER_NOT_LOADED)
    {
       sc = CacheItemCheckState(pHandlerID,
                           *pItemID,
                           dwCheckState);

    }
    
    return sc;

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetItemCheck(REFCLSID pHandlerID,
//					SYNCMGRITEMID *pItemID, DWORD *pdwCheckState);
//
//  PURPOSE:  Set the Item CheckState
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetItemCheck(REFCLSID pHandlerID,
					SYNCMGRITEMID *pItemID, DWORD *pdwCheckState)
{
    SCODE sc = NOERROR;

    if ((!pItemID) || (pHandlerID == GUID_NULL) || (!pdwCheckState))
    {
    	return E_INVALIDARG;
    }
    sc = m_HndlrQueue->GetItemCheck(pHandlerID, pItemID, pdwCheckState);
    
    if (sc == SYNCMGR_E_HANDLER_NOT_LOADED)
    {
       TCHAR pszConnectionName[RAS_MaxEntryName + 1];
       ConvertString(pszConnectionName, m_pwszConnectionName,ARRAY_SIZE(pszConnectionName));

       
       //if we fail setting this in the registry, ignore it and move on.
       // we will lose this item settings.
       RegGetSyncItemSettings(SYNCTYPE_SCHEDULED,
                               pHandlerID,
                               *pItemID,
                               pszConnectionName,
                               pdwCheckState,
                               FALSE,
                               m_ptstrGUIDName);
       
       //Now check if there have been any changes to the check state
       sc = RetreiveCachedItemCheckState(pHandlerID,
                                    *pItemID,
                                    pdwCheckState);


    }

    return sc;

}

//+------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::Save()
//
//  PURPOSE:  CSyncSchedule save, commits the sync schedule.
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::Save()
{
    SCODE sc = NOERROR; 
    TRACE("CSyncSchedule::Save()\r\n");

    TCHAR ptszConnectionName[RAS_MaxEntryName + 1];
    TCHAR ptszScheduleName[MAX_PATH + 1];
    TCHAR ptszFriendlyName[MAX_PATH + 1];
    WCHAR *pwszScheduleName;

    Assert(m_pITask);

    //protect the Save path in a mutex
    CMutex  CMutexSchedule(NULL, FALSE,SZ_SCHEDULEMUTEXNAME);
    CMutexSchedule.Enter();

    //See if this schedule name has been used
    ConvertString(ptszFriendlyName, m_pwszFriendlyName, MAX_PATH);
	
    lstrcpy(ptszScheduleName, m_ptstrGUIDName);
    if (IsFriendlyNameInUse(ptszScheduleName, ptszFriendlyName))
    {
	//make sure it is in use by this schedule
	if (0 != lstrcmp(ptszScheduleName, m_ptstrGUIDName))
	{
    	    CMutexSchedule.Leave();
            return SYNCMGR_E_NAME_IN_USE;
	}
    }
    //Save the schedule to a file
    IPersistFile *pIPersistFile;
		
    if (FAILED(sc = m_pITask->QueryInterface(IID_IPersistFile, (VOID **)&pIPersistFile)))
    {
	CMutexSchedule.Leave();
        return sc;
    }

     //Save the settings for this schedule in the registry
    // todo: ADD code to back out the reg writing if for
    // some reason TS fails.

    ConvertString(ptszConnectionName, m_pwszConnectionName,ARRAY_SIZE(ptszConnectionName));

    if (m_HndlrQueue)
    {
        sc = m_HndlrQueue->CommitSchedSyncChanges(m_ptstrGUIDName,
						ptszFriendlyName,
						ptszConnectionName,
						m_dwConnType,
                                                m_fCleanReg);
    }

    //if we never loaded the handler, then save the cached info to the reg.
    WriteOutAndPurgeCache();

    RegRegisterForScheduledTasks(TRUE);

    if ((FAILED(sc) || FAILED(sc = pIPersistFile->Save(NULL, FALSE))))
    {
        pIPersistFile->Release();
	
	// if failed save clear out the registry. 
	RegRemoveScheduledTask(m_ptstrGUIDName);
	CMutexSchedule.Leave();
        return sc;	
    }
	
    //Now set the file attributes to hidden so we won't show up in the normal TS UI.
    if (FAILED(sc = pIPersistFile->GetCurFile(&pwszScheduleName)))
    {
        pIPersistFile->Release();
	CMutexSchedule.Leave();
        return sc;	
    }
    pIPersistFile->Release();
	

    if (!SetFileAttributes(pwszScheduleName, FILE_ATTRIBUTE_HIDDEN))
    {
	CMutexSchedule.Leave();
        return GetLastError();
    }
    
    CoTaskMemFree(pwszScheduleName);


	CMutexSchedule.Leave();
     return sc;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::EnumItems(REFGUID pHandlerID,
//						IEnumSyncItems  **ppEnumItems)
//
//  PURPOSE: Enumerate the handler items on this sync schedule   
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::EnumItems(REFGUID pHandlerID,
				      IEnumSyncItems  **ppEnumItems)
{
    SCODE sc = S_OK;

    if (!ppEnumItems)
    {
	return E_INVALIDARG;
    }
    
    if (pHandlerID != GUID_NULL)
    {
        if (FAILED(sc = LoadOneHandler(pHandlerID)))
        {
            return sc;
        }
    }
    else if (FAILED(sc = LoadAllHandlers()))
    {
        return sc;
    }
        
    *ppEnumItems =  new CEnumSyncItems(pHandlerID, m_HndlrQueue);
	
    if (*ppEnumItems)
    {
	return S_OK;
    }
    return E_OUTOFMEMORY;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetITask(ITask ** ppITask)
//
//  PURPOSE: Return the ITask interface for this schedule
//
//	Notes: We really should have this private.
//
//  History:  15-Mar-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CSyncSchedule::GetITask(ITask ** ppITask)
{
    Assert(m_pITask);

    *ppITask = m_pITask;
    m_pITask->AddRef();

    return S_OK;
}

//--------------------------------------------------------------------------------
//
//  member: CSyncSchedule::GetHandlerInfo, private
//
//  PURPOSE: returns handler infor for the item. Used so can display UI,
//
//
//  History:  11-Aug-98       rogerg        Created.
//
//-------------------------------------------------------------------------------

STDMETHODIMP CSyncSchedule::GetHandlerInfo(REFCLSID pHandlerID,LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
HRESULT hr = E_UNEXPECTED;
LPSYNCMGRHANDLERINFO pHandlerInfo = NULL;

    if (!ppSyncMgrHandlerInfo)
    {
        Assert(ppSyncMgrHandlerInfo);
        return E_INVALIDARG;
    }

    if (FAILED(hr = LoadOneHandler(pHandlerID)))
    {
        return hr;
    }

    if (pHandlerInfo = (LPSYNCMGRHANDLERINFO) CoTaskMemAlloc(sizeof(SYNCMGRHANDLERINFO)))
    {
        hr = m_HndlrQueue->GetHandlerInfo(pHandlerID,pHandlerInfo);
    }
   
    *ppSyncMgrHandlerInfo = (NOERROR == hr) ? pHandlerInfo : NULL;

    return hr;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CSyncSchedule::GetScheduleGUIDName(DWORD *pcbSize,
//						LPTSTR pwszScheduleName)
//
//  PURPOSE:  Get the GUID name for this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE  CSyncSchedule::GetScheduleGUIDName(DWORD *pcbSize,
						LPTSTR ptszScheduleName)
{
    if (!pcbSize ||	!ptszScheduleName)
    {
	return E_INVALIDARG;
    }

    if (*pcbSize <= (ULONG) lstrlen(m_ptstrGUIDName))
    {
	*pcbSize = lstrlen(m_ptstrGUIDName) + 1;
	return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    lstrcpy(ptszScheduleName, m_ptstrGUIDName);

    return S_OK;	
}

//+------------------------------------------------------------------------------
//
//  Class:     CEnumSyncItems
//
//  FUNCTION: CEnumSyncItems::CEnumSyncItems()
//
//  PURPOSE: Constructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CEnumSyncItems::CEnumSyncItems(REFCLSID pHandlerId, CHndlrQueue *pHndlrQueue)
{
    TRACE("CEnumSyncItems::CEnumSyncItems()\r\n");
    
    ++g_cRefThisDll;

    Assert(pHndlrQueue);

    m_HndlrQueue = pHndlrQueue;
    m_HndlrQueue->AddRef();
	
    if (pHandlerId == GUID_NULL)
    {
        m_fAllHandlers = TRUE;
    }
    else
    {
        m_fAllHandlers = FALSE;
    }

    m_HndlrQueue->GetHandlerIDFromClsid(pHandlerId, &m_wHandlerId);

    m_HandlerId = pHandlerId;
    m_wItemId = 0;
    m_cRef = 1;
	
}

//+------------------------------------------------------------------------------
//
//  Class:     CEnumSyncItems
//
//  FUNCTION: CEnumSyncItems::~CEnumSyncItems()
//
//  PURPOSE: Destructor
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
CEnumSyncItems::~CEnumSyncItems()
{
    --g_cRefThisDll;

    Assert(0 == m_cRef);

    TRACE("CEnumSyncItems::CEnumSyncItems()\r\n");
}
//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::QueryInterface(REFIID riid, LPVOID FAR *ppv)
//
//  PURPOSE: QI for the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CEnumSyncItems::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        TRACE("CEnumSyncItems::QueryInterface()==>IID_IUknown\r\n");
    	*ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_IEnumSyncItems))
    {
        TRACE("CSyncScheduleMgr::QueryInterface()==>IID_IEnumSyncItems\r\n");
        *ppv = (LPENUMSYNCITEMS) this;
    }
    if (*ppv)
    {
        AddRef();
        return NOERROR;
    }

    TRACE("CEnumSyncItems::QueryInterface()==>Unknown Interface!\r\n");
    return E_NOINTERFACE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::AddRef()
//
//  PURPOSE: Addref the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumSyncItems::AddRef()
{
    TRACE("CEnumSyncItems::AddRef()\r\n");
    m_HndlrQueue->AddRef();
	return ++m_cRef;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::Release()
//
//  PURPOSE: Release the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumSyncItems::Release()
{
    TRACE("CEnumSyncItems::Release()\r\n");
    m_HndlrQueue->Release();
	if (--m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::Next(ULONG celt,
//        			LPSYNC_HANDLER_ITEM_INFO rgelt,
//					ULONG * pceltFetched)
//
//  PURPOSE: Next handler item on this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncItems::Next(ULONG celt,
        			LPSYNC_HANDLER_ITEM_INFO rgelt,
					ULONG * pceltFetched)
{
	
    SCODE sc;
    UINT i;
    GUID handlerID;
    SYNCMGRITEMID itemID;
    DWORD dwCheckState;
    Assert(m_HndlrQueue);

    if ((0 == celt) ||  
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }
    if (pceltFetched)
    {
    	*pceltFetched = 0;
    }
	
    i = 0;

    while (i < celt)	
    {
        sc = m_HndlrQueue->FindNextItemOnConnection
			        (NULL,m_wHandlerId,m_wItemId,
			         &handlerID,&itemID,&m_wHandlerId,&m_wItemId, m_fAllHandlers, 
				 &dwCheckState);

	if (sc != S_OK)
	{
	    break;
	}
		
	rgelt[i].handlerID = handlerID;
	rgelt[i].itemID = itemID;
	rgelt[i].dwCheckState = dwCheckState;
	m_HndlrQueue->GetItemIcon(m_wHandlerId, m_wItemId, &(rgelt[i].hIcon));
	m_HndlrQueue->GetItemName(m_wHandlerId, m_wItemId, rgelt[i].wszItemName);
			
	i++;
		
    }
	
    if (SUCCEEDED(sc))
    {
    	if (pceltFetched)
	{
    	    *pceltFetched = i;
	}
	if (i == celt)
	{
	    return S_OK;
	}
	return S_FALSE;
    }
    else
    {
	return sc;
    }
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::Skip(ULONG celt)
//
//  PURPOSE: Skip celt items on this schedule
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncItems::Skip(ULONG celt)
{
    SCODE sc;
    UINT i;
    GUID handlerID;
    SYNCMGRITEMID itemID;
    DWORD dwCheckState;

    Assert(m_HndlrQueue);

    i = 0;
    while (i< celt)	
    {
	sc = m_HndlrQueue->FindNextItemOnConnection
			            (NULL,m_wHandlerId,m_wItemId,
				     &handlerID,&itemID,&m_wHandlerId,&m_wItemId, m_fAllHandlers, 
				     &dwCheckState);
        if (sc != S_OK)
	{
	    break;
	}
	i++;
	
    }
    if (SUCCEEDED(sc))
    {
	return S_OK;
    }
    else
    {
	return sc;
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CEnumSyncItems::Reset(void)
//
//  PURPOSE: Reset the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncItems::Reset(void)
{
    TRACE("CEnumSyncItems::Reset()\r\n");
    
    m_wItemId = 0;
    return m_HndlrQueue->GetHandlerIDFromClsid(m_HandlerId, &m_wHandlerId);
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:  CEnumSyncItems::Clone(IEnumSyncItems ** ppEnumSyncItems)
//
//  PURPOSE: Clone the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
STDMETHODIMP CEnumSyncItems::Clone(IEnumSyncItems ** ppEnumSyncItems)
{
    if (!ppEnumSyncItems)
    {
	return E_INVALIDARG;
    }
	
    *ppEnumSyncItems =  new CEnumSyncItems(m_HandlerId, m_HndlrQueue);
	
    if (!(*ppEnumSyncItems))
    {
	return E_OUTOFMEMORY;
    }
	
    return ((LPENUMSYNCITEMS) (*ppEnumSyncItems))->SetHandlerAndItem
                                                    (m_wHandlerId, m_wItemId);
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:  CEnumSyncItems::SetHandlerAndItem(WORD wHandlerID, WORD wItemID)
//
//  PURPOSE: Used when Cloning the enumerator
//
//  History:  27-Feb-98       susia        Created.
//
//--------------------------------------------------------------------------------
SCODE CEnumSyncItems::SetHandlerAndItem(WORD wHandlerID, WORD wItemID)
{
    m_wHandlerId = wHandlerID;
    m_wItemId = wItemID;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\welcome.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       welcome.cxx
//
//  Contents:   Task wizard welcome (initial) property page implementation.
//
//  Classes:    CWelcomePage
//
//  History:    11-21-1997   SusiA 
//
//---------------------------------------------------------------------------

#include "precomp.h"

CWelcomePage *g_pWelcomePage = NULL;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardWelcomeDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//+-------------------------------------------------------------------------------

BOOL CALLBACK SchedWizardWelcomeDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{

	switch (uMessage)
	{
		
	case WM_INITDIALOG:         
	    {
               #ifdef _WIZ97FONTS
                WND hwndTitle = GetDlgItem(hDlg, IDC_INTROTITLE);

    	        if( hwndTitle)
	        {
                SetWindowFont(hwndTitle, g_pWelcomePage->m_hBoldFont, TRUE);
	        }
               #endif // _WIZ97FONTS

		//This handles the 256 color processing init
		//for the .bmp
		InitPage(hDlg,lParam);
	    }
            break;
        case WM_PAINT:
            WmPaint(hDlg, uMessage, wParam, lParam);
            break;

        case WM_PALETTECHANGED:
            WmPaletteChanged(hDlg, wParam);
            break;

        case WM_QUERYNEWPALETTE:
            return( WmQueryNewPalette(hDlg) );
            break;

        case WM_ACTIVATE:
            return( WmActivate(hDlg, wParam, lParam) );
            break;

		case WM_DESTROY:
		{
			Unload256ColorBitmap();
		}
		break;

		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{

  				case PSN_KILLACTIVE:
	           		SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					return 1;
					break;

				case PSN_RESET:
					// reset to the original values
	           		SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

 				case PSN_SETACTIVE:
	    			PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
				break;

                case PSN_WIZNEXT:
     				break;

				default:
					return FALSE;
    	}
		break;
		
		default:
			return FALSE;
	}
	return TRUE;   

}

    
    
//+--------------------------------------------------------------------------
//
//  Member:     CWelcomePage::CWelcomePage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   Stole from Task Scheduler wizard
//
//---------------------------------------------------------------------------

#ifdef _WIZ97FONTS

CWelcomePage::CWelcomePage(
    HINSTANCE hinst,
    HFONT hBoldFont,
    ISyncSchedule *pISyncSched,
    HPROPSHEETPAGE *phPSP)

#else

CWelcomePage::CWelcomePage(
    HINSTANCE hinst,
    ISyncSchedule *pISyncSched,
    HPROPSHEETPAGE *phPSP)

#endif //  _WIZ97FONTS

{
	ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));

	g_pWelcomePage = this;

   	m_psp.dwSize = sizeof (PROPSHEETPAGE);
        m_psp.dwFlags = PSH_DEFAULT;
	m_psp.hInstance = hinst;
	m_psp.pszTemplate = MAKEINTRESOURCE(IDD_SCHEDWIZ_INTRO);
	m_psp.pszIcon = NULL;
	m_psp.pfnDlgProc = (DLGPROC) SchedWizardWelcomeDlgProc;
	m_psp.lParam = 0;

	m_pISyncSched = pISyncSched;
	m_pISyncSched->AddRef();

#ifdef _WIZ97FONTS
	m_hBoldFont = hBoldFont;
#endif //   _WIZ97FONTS


#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

   *phPSP = CreatePropertySheetPage(&m_psp);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\syncmgrr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       syncmgrr.h
//
//  Contents:   Exports used by Ras for doing Pending Disconnect
//
//  Classes:    
//
//  Notes:      
//
//  History:    09-Jan-98   rogerg      Created.
//
//--------------------------------------------------------------------------

LRESULT CALLBACK  SyncMgrRasProc(UINT uMsg,WPARAM wParam, LPARAM lParam);  

// structures used in messages

typedef struct _tagSYNCMGRQUERYSHOWSYNCUI
{
    /* [in]  */ DWORD cbSize;
    /* [in]  */ GUID GuidConnection;
    /* [in]  */ LPCWSTR pszConnectionName;
    /* [out] */ BOOL fShowCheckBox;
    /* [out] */ UINT nCheckState;  // values taken from the BST_ #defines
} SYNCMGRQUERYSHOWSYNCUI;

typedef struct _tagSYNCMGRSYNCDISCONNECT
{
    /* [in] */ DWORD cbSize;
    /* [in] */ GUID  GuidConnection;
    /* [in] */ LPCWSTR pszConnectionName;
 } SYNCMGRSYNCDISCONNECT;

// Messages to SyncMgrRasProc
#define SYNCMGRRASPROC_QUERYSHOWSYNCUI 	WM_USER + 1

// wParam = 0
// lParam = Pointer to SYNCMGRQUERYSHOWSYNCUI

#define SYNCMGRRASPROC_SYNCDISCONNECT        	WM_USER + 2

// wParam = 0
// lParam = Pointer to SYNCMGRSYNCDISCONNECT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\settings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       Settings.h
//
//  Contents:   Onestop Settings PropertyPage Dialog box classes
//
//  Classes:    CAutoSyncPage
//				CSchedSyncPage
//
//  Notes:
//
//  History:    14-Nov-97   SusiA      Created.
//
//--------------------------------------------------------------------------


#ifndef _SETTINGSDLG_
#define _SETTINGSDLG_

// definitions for Advnanced Idle Setting Spin Control
#define SPINDIALWAITMINUTES_MIN 1
#define SPINDIALWAITMINUTES_MAX 999

#define SPINDIALREPEATMINUTES_MIN 1
#define SPINDIALREPEATMINUTES_MAX 999

#define WM_NOTIFYLISTVIEWEX (WM_USER + 1)

//+-------------------------------------------------------------------------------
//
//  CLASS: CAutoSyncPage
//
//  PURPOSE:  Handle the AutoSync Psge
//
//--------------------------------------------------------------------------------


class CAutoSyncPage
{
public:
    inline CAutoSyncPage(HINSTANCE hinst);
    ~CAutoSyncPage();

    void SetAutoSyncHwnd(HWND hwnd);
    void SetIdleHwnd(HWND hwnd);
    BOOL InitializeHwnd(HWND hwnd,SYNCTYPE syncType,DWORD dwDefaultConnection);
    DWORD GetNumConnections(HWND hwnd,SYNCTYPE syncType);
    BOOL ShowItemsOnThisConnection(HWND hwnd,SYNCTYPE syncType,DWORD dwConnectionNum);
    BOOL SetItemCheckState(HWND hwnd,SYNCTYPE syncType,int iItem, BOOL fChecked,int iCheckCount);
    BOOL SetConnectionCheck(HWND hwnd,SYNCTYPE syncType,WORD wParam,DWORD dwCheckState);

    HRESULT GetAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings);
    HRESULT SetAdvancedIdleSettings(LPCONNECTIONSETTINGS pConnectionSettings);

    HRESULT ShowProperties(HWND hwnd,int iItem);


    SCODE CommitAutoSyncChanges();
    SCODE CommitIdleChanges();

private:
    BOOL InitializeHandler(HWND hwnd,SYNCTYPE SyncType);
    BOOL Initialize(HWND hwnd,DWORD dwDefaultConnection); // called to initialize the AutoSync page

    CHndlrQueue *m_HndlrQueue;
    HWND m_hwndAutoSync;
    HWND m_hwndIdle;
    CListView  *m_pItemListViewAutoSync;
    CListView  *m_pItemListViewIdle;
    BOOL m_pItemListViewAutoSyncInitialized;
    BOOL m_fListViewIdleInitialized;
    HINSTANCE m_hinst;
    CRasUI *m_pRas;
    BOOL m_fInitialized;
    BOOL m_fItemsOnConnection;

    friend INT_PTR CALLBACK AutoSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK IdleSyncDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};

//+-------------------------------------------------------------------------------
//
//  CLASS: CSchedSyncPage
//
//  PURPOSE:  Handle the SchedSync Psge
//
//--------------------------------------------------------------------------------

class CSchedSyncPage
{
public:

	CSchedSyncPage(HINSTANCE hinst, HWND hwnd);
	~CSchedSyncPage();

        BOOL	Initialize();
	BOOL	ShowAllSchedules();
	BOOL	FreeAllSchedules();
	HRESULT InitializeScheduleAgent();
	BOOL	StartScheduleWizard();
	BOOL	EditTask(int iItem);
	BOOL	RemoveTask(int iItem);

        BOOL    OnCommand(HWND hDlg, WORD wNotifyCode, WORD wID, HWND hwndCtl);
	BOOL	OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
        BOOL SetButtonState(int nIDDlgItem,BOOL fEnabled);


private:
	HWND m_hwnd;
	HINSTANCE m_hinst;

	LPSYNCSCHEDULEMGR   m_pISyncSchedMgr;
        int m_iDefaultIconImageIndex;

	
};

//+-------------------------------------------------------------------------------
//
//  FUNCTION: CAutoSyncPage::CAutoSyncPage(HWND hwnd)
//
//  PURPOSE:  Constructor
//
//	COMMENTS: Constructor for AutoSync page
//
//--------------------------------------------------------------------------------
inline CAutoSyncPage::CAutoSyncPage(HINSTANCE hinst)
{
    m_hinst = hinst;
    m_HndlrQueue = NULL;
    m_fInitialized = FALSE;
    m_fItemsOnConnection = FALSE;

    m_hwndIdle = NULL;
    m_hwndAutoSync = NULL;

    m_pItemListViewAutoSync = NULL;
    m_pItemListViewIdle = NULL;
    m_pItemListViewAutoSyncInitialized = FALSE;
    m_fListViewIdleInitialized = FALSE;

}


//+-------------------------------------------------------------------------------
//
//  FUNCTION: CSchedSyncPage::CSchedSyncPage(HWND hwnd)
//
//  PURPOSE:  Constructor
//
//	COMMENTS: Constructor for SchedSync page
//
//--------------------------------------------------------------------------------
inline CSchedSyncPage::CSchedSyncPage(HINSTANCE hinst, HWND hwnd)
{
    m_hwnd = hwnd;
	m_hinst = hinst;
	m_pISyncSchedMgr = NULL;

}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: CSchedSyncPage::~CSchedSyncPage(HWND hwnd)
//
//  PURPOSE:  Constructor
//
//	COMMENTS: Constructor for SchedSync page
//
//--------------------------------------------------------------------------------
inline CSchedSyncPage::~CSchedSyncPage()
{
	if (m_pISyncSchedMgr)
	{
		m_pISyncSchedMgr->Release();
	}
}


#endif // _SETTINGSDLG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\wizpage.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       wizpage.cxx
//
//  Contents:   Implementation of wizard page class
//
//  History:    4-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "precomp.h"

//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::~CWizPage
//
//  History:    31-Mar-1998   SusiA   
//
//---------------------------------------------------------------------------

CWizPage::~CWizPage()
{
	if (m_pISyncSched)
		m_pISyncSched->Release();
}


//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnNotify
//
//  Synopsis:   Aggregate the CPropPage WM_NOTIFY handler to provide
//              wizard-specific dispatching.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnNotify(
    UINT    uMessage,
    UINT    uParam,
    LPARAM  lParam)
{
    // TRACE_METHOD(CWizPage, _OnNotify);

    LPNMHDR pnmhdr = (LPNMHDR) lParam;

    switch (pnmhdr->code)
    {
    //
    // Delegate to base class for notification processing it provides
    // which we don't need to override.
    //

    //
    // Support notifications unique to wizard pages
    //

    case PSN_WIZBACK:
        return _OnWizBack();

    case PSN_WIZNEXT:
        return _OnWizNext();

    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizBack
//
//  Synopsis:   Default handling of PSN_WIZBACK
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizBack()
{

    SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, 0);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizPage::_OnWizNext
//
//  Synopsis:   Default handling of PSN_WIZNEXT
//
//  History:    5-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT
CWizPage::_OnWizNext()
{

    SetWindowLongPtr(m_hwnd, DWLP_MSGRESULT, 0);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\callback.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Callback.cpp
//
//  Contents:   Calback implementation
//
//  Classes:    COfflineSynchronizeCallback
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::COfflineSynchronizeCallback, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pHndlrMsg] - pointer to CHndlrMsg class this callback belongs too.
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

COfflineSynchronizeCallback::COfflineSynchronizeCallback(CHndlrMsg *pHndlrMsg
                                                         ,CLSID CLSIDServer
                                                         ,DWORD dwSyncFlags
                                                         ,BOOL fAllowModeless)
{
    Assert(NULL != pHndlrMsg);

    m_pHndlrMsg = pHndlrMsg;
    m_CLSIDServer = CLSIDServer;
    m_dwSyncFlags = dwSyncFlags;
    m_cRef = 1;
    m_fSynchronizeCompleted = FALSE;
    m_fAllowModeless = fAllowModeless;
    m_fForceKilled = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::~COfflineSynchronizeCallback, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

COfflineSynchronizeCallback::~COfflineSynchronizeCallback()
{
    Assert(FALSE == m_fForceKilled); // should never get cleaned up of force killed.
    Assert(NULL == m_pHndlrMsg);
    Assert(0 == m_cRef);
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  COfflineSynchronizeCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    *ppvObj = NULL;

    if( IsEqualIID( riid, IID_IUnknown ) )
        *ppvObj = (LPVOID) this;
    else if ( IsEqualIID( riid, IID_ISyncMgrSynchronizeCallback ) )
        *ppvObj = (LPVOID)(LPSYNCMGRSYNCHRONIZECALLBACK) this;
    else if ( IsEqualIID( riid, IID_IOldSyncMgrSynchronizeCallback ) )
    {
        // This is for the Old IDL This is the old IE 5.0 Beta1 interface
        // no one shipped using it so it can safely be removed.
        *ppvObj = (LPVOID)(LPOLDSYNCMGRSYNCHRONIZECALLBACK) this;
    }
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD COfflineSynchronizeCallback::AddRef()
{
ULONG cRefs;

    cRefs = InterlockedIncrement((LONG *)& m_cRef);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD COfflineSynchronizeCallback::Release()
{
ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (0 == cRefs)
    {
        delete this;
    }

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::EnableModeless, public
//
//  Synopsis:   EnableModeless method - Currently always returns NOERROR
//
//  Arguments:  [fEnable] - Boolean (TRUE == request to bring up dialog,
//                              FALSE == the dialog has been dismissed.
//
//  Returns:    S_OK if handler can perform the request
//              S_FALSE if dialog shouldn't be displayed.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::EnableModeless(BOOL fEnable)
{
HRESULT hr = S_OK;

    if (m_fForceKilled)
    {
        return S_FALSE;
    }

    if (!m_fAllowModeless && fEnable)
    {
        hr = S_FALSE;
    }

    if (m_pHndlrMsg)
    {
    BOOL fAttach = FALSE;

        if (fEnable && (S_OK == hr)) // Attach Thread input if want dialog and it was granted.
        {
            fAttach = TRUE;
        }

        m_pHndlrMsg->AttachThreadInput(fAttach);
    }


    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::Progress, public
//
//  Synopsis:   Called by Handlers to update progress information.
//
//  Arguments:  [ItemID] - Identifies Item Progress information pertains to
//              [lpSyncProgressItem] - Pointer to ProgressItem Structure.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::Progress(REFSYNCMGRITEMID ItemID,
                                        LPSYNCMGRPROGRESSITEM lpSyncProgressItem)
{
HRESULT hr = E_UNEXPECTED;
CHndlrQueue *pHndlrQueue = NULL;
HANDLERINFO *pHandlerID = 0;
DWORD dwProxyThreadId;
CLock clockCallback(this);

    if (m_fForceKilled)
    {
        return S_SYNCMGR_CANCELALL;
    }

    clockCallback.Enter();

    Assert(NULL != m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        hr = pHndlrQueue->Progress(pHandlerID,
                                            ItemID,lpSyncProgressItem);

        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue
    }

    return hr;
}


STDMETHODIMP COfflineSynchronizeCallback::PrepareForSyncCompleted(HRESULT hCallResult)
{
    CallCompletionRoutine(ThreadMsg_PrepareForSync,hCallResult,0,NULL);
    return NOERROR;
}


STDMETHODIMP COfflineSynchronizeCallback::SynchronizeCompleted(HRESULT hCallResult)
{
    CallCompletionRoutine(ThreadMsg_Synchronize,hCallResult,0,NULL);
    return NOERROR;
}

STDMETHODIMP  COfflineSynchronizeCallback::ShowPropertiesCompleted(HRESULT hCallResult)
{
   CallCompletionRoutine(ThreadMsg_ShowProperties,hCallResult,0,NULL);
   return NOERROR;
}

STDMETHODIMP  COfflineSynchronizeCallback::ShowErrorCompleted(HRESULT hCallResult,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{

    CallCompletionRoutine(ThreadMsg_ShowError,hCallResult,cbNumItems,pItemIDs);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::LogError, public
//
//  Synopsis:   Called by Handlers to log and Error.
//
//  Arguments:  [dwErrorLevel] - ErrorLevel of the Log
//              [lpcErrorText] - Text Associated with the error.
//              [lpSyncLogError] - Additional Error information.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::LogError(DWORD dwErrorLevel,
                        const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError)
{
HRESULT hr = E_UNEXPECTED;
CHndlrQueue *pHndlrQueue = NULL;
HANDLERINFO *pHandlerID = 0;
DWORD dwProxyThreadId;
CLock clockCallback(this);

    if (m_fForceKilled)
    {
        return NOERROR;
    }

    clockCallback.Enter();

    Assert(NULL != m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        hr = pHndlrQueue->LogError(pHandlerID,
                dwErrorLevel, lpcErrorText,lpSyncLogError);

        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue

    }

    return hr;

}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::LogError, public
//
//  Synopsis:   Called by Handlers to delete an error that
//              was previously logged.
//
//  Arguments:
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    13-Mar-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::DeleteLogError(REFSYNCMGRERRORID ErrorID,DWORD dwReserved)
{
HRESULT hr = E_UNEXPECTED;
CHndlrQueue *pHndlrQueue = NULL;
HANDLERINFO *pHandlerID = 0;
DWORD dwProxyThreadId;
CLock clockCallback(this);

    if (m_fForceKilled)
    {
        return NOERROR;
    }

    if (dwReserved)
    { 
        AssertSz(0,"DeleteLogError Reserved must be zero");
        return E_INVALIDARG;
    }

    clockCallback.Enter();

    Assert(NULL != m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        hr = pHndlrQueue->DeleteLogError(pHandlerID,ErrorID,dwReserved);
        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue

    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::EstablishConnection
//
//  Synopsis:   Called by Handlers to establish a net connection
//
//  Arguments:  [lpwszConnection] -- Connection string
//              [dwReserved]      -- Must be zero for now
//
//  History:    28-Jul-98      SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP COfflineSynchronizeCallback::EstablishConnection( WCHAR const * lpwszConnection,
                                                               DWORD dwReserved)
{

    if (m_fForceKilled)
    {
        return S_FALSE;
    }

    if ( dwReserved != 0 )
    {
        Assert( dwReserved == 0 );
        return E_INVALIDARG;
    }

    HRESULT hr = E_UNEXPECTED;

    CHndlrQueue *pHndlrQueue = NULL;
    HANDLERINFO *pHandlerID = 0;
    DWORD dwProxyThreadId;

    CLock clockCallback(this);

    clockCallback.Enter();

    Assert(NULL != m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        hr = pHndlrQueue->EstablishConnection( pHandlerID,
                                               lpwszConnection,
                                               dwReserved);
        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::SetHndlrMsg, public
//
//  Synopsis:   Called by CHndlrMsg to update the CHndlrMsg that owns the
//              callback. This currently should only be called with a paramater
//              of NULL for when the HndlrMsg is being destroyed.
//
//  Arguments:  [pHndlrMsg] - New CHndlrMsg the Callback belongs too.
//		[fForceKilled] - Set to True if HndlrMsg is removed because of a forcekill
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void COfflineSynchronizeCallback::SetHndlrMsg(CHndlrMsg *pHndlrMsg,BOOL fForceKilled)
{
CLock clockCallback(this);

    Assert(NULL == pHndlrMsg); 
    Assert(FALSE == m_fForceKilled); // shouldn't get force killed twice

    clockCallback.Enter();
    m_pHndlrMsg = pHndlrMsg;
    m_fForceKilled = fForceKilled;
    clockCallback.Leave();
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::SetEnableModeless, private
//
//  Synopsis:   Called by CHndlrMsg to update inform the callback if
//              it is allowed to enablemodelsss.
//
//  Arguments:  
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void COfflineSynchronizeCallback::SetEnableModeless(BOOL fAllowModeless)
{
CLock clockCallback(this);

    clockCallback.Enter();
    m_fAllowModeless = fAllowModeless;
    clockCallback.Leave();
}


//+---------------------------------------------------------------------------
//
//  Member:     COfflineSynchronizeCallback::CallCompletionRoutine, private
//
//  Synopsis:   Private helper method for calling completion routine.
//
//  Arguments:
//              DWORD dwThreadMsg - Identifies message belongs too.
//              HRESULT hCallResult - result of call
//              ULONG *pcbNumItems - only applies to ShowError
//              SYNCMGRITEMID **pItemIDs - only applies to ShowError
//
//  Returns:
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void COfflineSynchronizeCallback::CallCompletionRoutine(DWORD dwThreadMsg,HRESULT hCallResult,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{
CHndlrQueue *pHndlrQueue = NULL;
HANDLERINFO *pHandlerID = 0;
DWORD dwProxyThreadId;
SYNCMGRITEMID itemIDShowProperties;
CLock clockCallback(this);

    if (m_fForceKilled)
    {
        return;
    }

    clockCallback.Enter();

    Assert(NULL != m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
        // if this is a ShowProperties, fix up the item
        if (ThreadMsg_ShowProperties == dwThreadMsg)
        {
            cbNumItems = 1;
            itemIDShowProperties = m_pHndlrMsg->m_itemIDShowProperties;
            pItemIDs = &itemIDShowProperties;

            m_pHndlrMsg->m_itemIDShowProperties = GUID_NULL;
        }

        m_pHndlrMsg->GetHndlrQueue(&pHndlrQueue,&pHandlerID,&dwProxyThreadId);
        m_pHndlrMsg->AttachThreadInput(FALSE); // release any thread input that was set.
    }

    clockCallback.Leave();

    if (pHndlrQueue)
    {
        pHndlrQueue->CallCompletionRoutine(pHandlerID,dwThreadMsg,hCallResult,cbNumItems,pItemIDs);
        pHndlrQueue->Release(); // release our reference put on by GetHndlrQueue

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\choice.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Choice.cpp
//
//  Contents:   Implements the choice dialog
//
//  Classes:    CChoiceDlg
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

const DlgResizeList g_ChoiceResizeList[] = {
    IDC_CHOICERESIZESCROLLBAR,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM,
    IDC_START,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_NOCOPYBITS,
    IDC_OPTIONS,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_NOCOPYBITS,
    IDC_CLOSE,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_NOCOPYBITS,
    IDC_CHOICELISTVIEW,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINTOP | DLGRESIZEFLAG_PINLEFT,
    IDC_PROPERTY,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_NOCOPYBITS,
};

TCHAR g_szSyncMgrHelp[]  = TEXT("mobsync.hlp");
ULONG g_aContextHelpIds[] =
{
    IDC_STATIC1,		        ((DWORD)  -1),
    IDC_STATIC2,		        ((DWORD)  -1),
    IDC_STATIC3,		        ((DWORD)  -1),
    IDC_STATIC4,		        ((DWORD)  -1),
    IDC_STATIC5,			((DWORD)  -1),
    IDC_UPDATEAVI,                      ((DWORD)  -1),
    IDC_RESULTTEXT,		        ((DWORD)  -1),	
    IDC_STATIC_SKIP_TEXT,	        ((DWORD)  -1),
    IDC_CHOICELISTVIEW,		        HIDC_CHOICELISTVIEW,
    IDC_CLOSE,			        HIDC_CLOSE,
    IDC_DETAILS,		        HIDC_DETAILS,
    IDC_LISTBOXERROR,		        HIDC_LISTBOXERROR,
    IDC_OPTIONS,		        HIDC_OPTIONS,
    IDC_PROGRESSBAR,	                HIDC_PROGRESSBAR,
    IDC_PROGRESS_OPTIONS_BUTTON_MAIN,	HIDC_PROGRESS_OPTIONS_BUTTON_MAIN,
    IDC_PROPERTY,		        HIDC_PROPERTY,	
    IDC_SKIP_BUTTON_MAIN,	        HIDC_SKIP_BUTTON_MAIN,
    IDC_START,			        HIDC_START,
    IDC_UPDATE_LIST,		        HIDC_UPDATE_LIST,
    IDC_PROGRESS_TABS,		        HIDC_PROGRESS_TABS,
    IDC_TOOLBAR,		        HIDC_PUSHPIN,
    IDSTOP,			        HIDSTOP,
    0, 0
};

extern HINSTANCE g_hInst;      // current instance
extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo, setup by WinMain.
extern LANGID g_LangIdSystem; // langID of system we are running on.

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::CChoiceDlg()
//
//  PURPOSE:  Constructor
//
//	COMMENTS: Constructor for choice dialog
//
//
//--------------------------------------------------------------------------------

CChoiceDlg::CChoiceDlg(REFCLSID rclsid)
{
    m_fDead = FALSE;
    m_hwnd = NULL;
    m_nCmdShow = SW_SHOWNORMAL;
    m_pHndlrQueue = NULL;
    m_clsid = rclsid;
    m_dwThreadID = 0;
    m_fInternalAddref = FALSE;
    m_dwShowPropertiesCount = 0;
    m_fForceClose = FALSE;
    m_pItemListView = NULL;
    m_ulNumDlgResizeItem = 0;
    m_ptMinimizeDlgSize.x = 0;
    m_ptMinimizeDlgSize.y = 0;

    m_fHwndRightToLeft = FALSE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::Initialize
//
//  PURPOSE:  Must be called before any other methods.
//
//
//--------------------------------------------------------------------------------

BOOL CChoiceDlg::Initialize(DWORD dwThreadID,int nCmdShow)
{

    m_nCmdShow = nCmdShow;

    Assert(NULL == m_hwnd);

    if (NULL == m_hwnd)
    {
	m_dwThreadID = dwThreadID;

        m_hwnd =  CreateDialogParam(g_hInst,(LPWSTR) MAKEINTRESOURCE(IDD_CHOICE),NULL, (DLGPROC) CChoiceDlgProc,
			(LPARAM) this);
    }

    Assert(m_hwnd);
    return m_hwnd ? TRUE : FALSE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::SetQueueData()
//
//  PURPOSE:  Sets the Choice dialog queue
//
//  COMMENTS: Does a SendMessage to get on the same thread as the dialog
//
//
//--------------------------------------------------------------------------------

BOOL CChoiceDlg::SetQueueData(REFCLSID rclsid,CHndlrQueue * pHndlrQueue)
{
SetQueueDataInfo dataInfo;
BOOL fSet = FALSE;

    dataInfo.rclsid = &rclsid;
    dataInfo.pHndlrQueue = pHndlrQueue;

    SendMessage(m_hwnd,WM_CHOICE_SETQUEUEDATA,
	   (WPARAM) &fSet,(LPARAM) &dataInfo);

    return fSet;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::PrivSetQueueData()
//
//  PURPOSE:  Sets the QueueData
//
//  COMMENTS: Can be called multiple times if the dialg is invoked twice.
//
//
//--------------------------------------------------------------------------------

BOOL CChoiceDlg::PrivSetQueueData(REFCLSID rclsid,CHndlrQueue * pHndlrQueue)
{
    if (NULL == pHndlrQueue)
	    return FALSE;

    // if already have a queue then transfer the given queue items, else just
    // set the items.

    // reivew, special case UpdateAll dialog to just bring it to front
    //	    instead of adding all the items again.

    // if a request comes in to add after we have removed our addref or
    // haven't set it yet then stick an addref on the dialog

    if (FALSE == m_fInternalAddref)
    {
        m_fInternalAddref = TRUE;
	SetChoiceReleaseDlgCmdId(rclsid,this,RELEASEDLGCMDID_CANCEL);
	AddRefChoiceDialog(rclsid,this); // first time addref to keep alive.
    }

    if (NULL == m_pHndlrQueue)
    {
        m_pHndlrQueue = pHndlrQueue;
	m_pHndlrQueue->SetQueueHwnd(this);
	m_clsid = rclsid;

    }
    else
    {
	Assert(m_clsid == rclsid); // better have found the same choice dialog.
	Assert(NULL != m_pHndlrQueue);


	// !! warninng if you return an error it is up to the caller to free the queue.
	if (m_pHndlrQueue)
	{
	
	    m_pHndlrQueue->TransferQueueData(pHndlrQueue); // review, what should do on error.

	    // ALL QUEUE DATA SHOULD BE TRANSFERED.
	    pHndlrQueue->FreeAllHandlers();
	    pHndlrQueue->Release();
	}

    }


    AddNewItemsToListView(); // add the items to the ListView.

    // go ahead and show the choice dialog now that there are
    // items to display
    ShowChoiceDialog();

   return TRUE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::SetButtonState
//
//  PURPOSE:
//
//
//
//
//--------------------------------------------------------------------------------

BOOL CChoiceDlg::SetButtonState(int nIDDlgItem,BOOL fEnabled)
{
BOOL fResult = FALSE;
HWND hwndCtrl = GetDlgItem(m_hwnd,nIDDlgItem);
HWND hwndFocus = NULL;

    if (hwndCtrl)
    {
        // if state is current state then don't do anything
        // !! in case IsWindowEnable bool doesn't == our bool
        if ( (!!IsWindowEnabled(hwndCtrl)) == (!!fEnabled) )
        {
            return fEnabled;
        }

        if (!fEnabled) // don't bother getting focus if not disabling.
        {
            hwndFocus = GetFocus();
        }

        fResult = EnableWindow(GetDlgItem(m_hwnd,nIDDlgItem),fEnabled);

        // if control had the focus. and now it doesn't then tab to the
        // next control
        if (hwndFocus == hwndCtrl
                && !fEnabled)
        {
            SetFocus(GetDlgItem(m_hwnd,IDC_CLOSE));  // close is always enabled.
        }

    }

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::AddQueueItemsToListView, private
//
//  Synopsis:   Adds the items in the Queue to the ListView.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CChoiceDlg::AddNewItemsToListView()
{
DWORD dwExtStyle = LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP;
LVHANDLERITEMBLOB lvEmptyItemBlob;

    // set up the list view
    if (!m_pItemListView)
    {
        Assert(m_pItemListView);
        return FALSE;
    }


    // if emptyItem is in list View delete it.
    lvEmptyItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
    lvEmptyItemBlob.clsidServer = GUID_NULL;
    lvEmptyItemBlob.ItemID = GUID_NULL;

    if (-1 != m_pItemListView->FindItemFromBlob((LPLVBLOB) &lvEmptyItemBlob))
    {
    int ListViewWidth = CalcListViewWidth(GetDlgItem(m_hwnd,IDC_CHOICELISTVIEW));

        m_pItemListView->DeleteAllItems();

        // adjust the column widths back
        m_pItemListView->SetColumnWidth(0,(ListViewWidth * 2)/3);
        m_pItemListView->SetColumnWidth(1,ListViewWidth/3);
    }

    AddItemsFromQueueToListView(m_pItemListView,m_pHndlrQueue,dwExtStyle,0,
                      CHOICELIST_LASTUPDATECOLUMN,/* iDateColumn */ -1 /*status column */,TRUE /* fUseHandlerAsParent */
                    ,FALSE /* fAddOnlyCheckedItems */);


    // Set StartButton State in case don't have any checks would
    // m_iCheckCount set by listview notification.
    SetButtonState(IDC_START,m_pItemListView->GetCheckedItemsCount());


    // if no items are in the ListView then done, put in the NoItems to Sync Info.
    if (0 == m_pItemListView->GetItemCount())
    {
    TCHAR szBuf[MAX_STRING_RES];
    RECT rcClientRect;
    HIMAGELIST himageSmallIcon = m_pItemListView->GetImageList(LVSIL_SMALL );

        //disable the check box list view style
        m_pItemListView->SetExtendedListViewStyle(LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP );

        // adjust the column widths
        if (GetClientRect(GetDlgItem(m_hwnd,IDC_CHOICELISTVIEW),&rcClientRect))
        {
             m_pItemListView->SetColumnWidth(1,0);
             m_pItemListView->SetColumnWidth(0,rcClientRect.right -2);
        }


        LoadString(g_hInst,IDS_NOITEMS, szBuf, ARRAY_SIZE(szBuf));
	
        LVITEMEX lvitem;
	
        lvitem.mask = LVIF_TEXT | LVIF_IMAGE ;
        lvitem.iItem = 0;
        lvitem.iSubItem = 0;
        lvitem.pszText = szBuf;
        lvitem.iImage = -1;

        if (himageSmallIcon)
        {
            lvitem.iImage = ImageList_AddIcon(himageSmallIcon,LoadIcon(NULL, IDI_INFORMATION));
        }

        lvitem.maskEx = LVIFEX_BLOB;
        lvitem.pBlob = (LPLVBLOB) &lvEmptyItemBlob;

        m_pItemListView->InsertItem(&lvitem);

        m_pItemListView->SetItemState(0,
               LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );

        // Reset the current default push button to a regular button.
        SendDlgItemMessage(m_hwnd, IDC_START, BM_SETSTYLE, BS_PUSHBUTTON, (LPARAM)TRUE);

        // Update the default push button's control ID.
        SendMessage(m_hwnd, DM_SETDEFID, IDC_CLOSE, 0L);

        // Set the new style.
        SendDlgItemMessage(m_hwnd, IDC_CLOSE,BM_SETSTYLE, BS_DEFPUSHBUTTON, (LPARAM)TRUE);
    }

    m_pItemListView->SetItemState(0,
             LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );

    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::ShowChoiceDialog()
//
//  PURPOSE:  Initialize and display the Choice Dialog
//
//  COMMENTS: Implemented on main thread.
//
//
//--------------------------------------------------------------------------------
BOOL CChoiceDlg::ShowChoiceDialog()
{

    // Review, this needs to get cleanedup
    if (!m_hwnd)
    {
        Assert(m_hwnd);
        return FALSE;
    }

    return TRUE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::ShowProperties(int iItem)
//
//  PURPOSE:  Show the app specific properties  Dialog
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
HRESULT CChoiceDlg::ShowProperties(int iItem)
{
HRESULT hr = E_UNEXPECTED;

    Assert(iItem >= 0);

    // only call showProperties if still have our own addref.
    // and not already in a ShowProperties out call.
    if ( (iItem >= 0) &&
        m_pItemListView &&
        m_pHndlrQueue &&
        m_fInternalAddref && (0 == m_dwShowPropertiesCount) )
    {
    LVHANDLERITEMBLOB lvHandlerItemBlob;

        lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);

        if (m_pItemListView->GetItemBlob(iItem,(LPLVBLOB) &lvHandlerItemBlob,lvHandlerItemBlob.cbSize))
        {

            if (NOERROR == m_pHndlrQueue->ItemHasProperties(lvHandlerItemBlob.clsidServer,
                                                        lvHandlerItemBlob.ItemID))
	    {

                // Put two refs on the Properties one
                // for completion routine to reset and one for this
                // call so cancel can't happen until both return from
                // call and completion is called.

                m_dwShowPropertiesCount += 2;

                ObjMgr_AddRefHandlerPropertiesLockCount(2);

                hr = m_pHndlrQueue->ShowProperties(lvHandlerItemBlob.clsidServer,lvHandlerItemBlob.ItemID,m_hwnd);

                 --m_dwShowPropertiesCount;  // out of call
                ObjMgr_ReleaseHandlerPropertiesLockCount(1);

                Assert( ((LONG) m_dwShowPropertiesCount) >= 0);

                if ( ((LONG) m_dwShowPropertiesCount) <0)
                    m_dwShowPropertiesCount = 0;

                // if hr wasn't a success code then up to us to call the callback
                if (FAILED(hr))
                {
                    PostMessage(m_hwnd,WM_BASEDLG_COMPLETIONROUTINE,
                                            ThreadMsg_ShowProperties,0);
                }

            }
        }

    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::ReleaseDlg
//
//  PURPOSE:  Called by objmgr when we need to release
//              post message to the dialog thread.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------

void CChoiceDlg::ReleaseDlg(WORD wCommandID)
{
    PostMessage(m_hwnd,WM_CHOICE_RELEASEDLGCMD,wCommandID,0);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::PrivReleaseDlg
//
//  PURPOSE:  frees the dialog
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------

void CChoiceDlg::PrivReleaseDlg(WORD wCommandID)
{
BOOL fCloseConnections = TRUE;

    Assert(m_dwThreadID == GetCurrentThreadId());
    Assert(m_fInternalAddref == FALSE);

    if (m_hwnd)
    {
	// ShowWindow(m_hwnd,SW_HIDE);
    }

    // if don't have a listView then change command to a cancel
    if (NULL == m_pItemListView)
    {
        wCommandID = RELEASEDLGCMDID_CANCEL;
    }

    switch(wCommandID)
    {
    case RELEASEDLGCMDID_CANCEL:
       // done with our queue

	Assert(m_pHndlrQueue);
    case RELEASEDLGCMDID_DESTROY:
	// this CommandID is sent if dialog was created but it couldn't be added
	// to the object mgr list.

	if (m_pHndlrQueue)
	{
	    m_pHndlrQueue->FreeAllHandlers(); // done with our queue.
	    m_pHndlrQueue->Release();
	    m_pHndlrQueue = NULL;
	}

	break;
    case RELEASEDLGCMDID_OK:
	{
	     Assert(m_pHndlrQueue);
             Assert(m_pItemListView);

	     if (m_pHndlrQueue && m_pItemListView)
	     {
	    CProgressDlg *pProgressDlg;
	    short i = 0;
	    int sCheckState;
            LVHANDLERITEMBLOB lvHandlerItemBlob;

                    lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);

		 // loop through getting and setting the selected items.

		 // 1 checked, 0 unchecked, -1 last item
		 while (-1 != (sCheckState = m_pItemListView->GetCheckState(i)))
		 {

		    if (m_pItemListView->GetItemBlob(i,(LPLVBLOB) &lvHandlerItemBlob,lvHandlerItemBlob.cbSize))
                    {

                        if (GUID_NULL != lvHandlerItemBlob.ItemID)
                        {
                            m_pHndlrQueue->SetItemState(lvHandlerItemBlob.clsidServer,
                                        lvHandlerItemBlob.ItemID,
                                        sCheckState == LVITEMEXSTATE_CHECKED ?
                                                SYNCMGRITEMSTATE_CHECKED : SYNCMGRITEMSTATE_UNCHECKED);
                        }

                    }

		     i++;

		 } while (-1 != sCheckState);

		 m_pHndlrQueue->PersistChoices();

		 // on a manual create the progress dialog as displayed.
		 if (NOERROR == FindProgressDialog(GUID_NULL,TRUE,SW_SHOWNORMAL,&pProgressDlg))
		 {
		     if (NOERROR == pProgressDlg->TransferQueueData(m_pHndlrQueue))
                     {
                        fCloseConnections = FALSE;
                     }
		     ReleaseProgressDialog(GUID_NULL,pProgressDlg,FALSE);
		 }

		   m_pHndlrQueue->FreeAllHandlers(); // done with our queue.
		   m_pHndlrQueue->Release();
		   m_pHndlrQueue = NULL;
	     }
	}
	break;
    case RELEASEDLGCMDID_DEFAULT:
	
	if (m_pHndlrQueue)
	{
	    m_pHndlrQueue->FreeAllHandlers(); // done with our queue.
	    m_pHndlrQueue->Release();
	    m_pHndlrQueue = NULL;
	}

	break;
    default:
	Assert(0); // unknown command or we never set one.
	break;
    }


    // see if there is a progress queue when we get done and we havne't
    // created one ourselves. If there isn't then
    // call CloseConnection to make sure any Events or open Connections
    // get hungUp.

    CProgressDlg *pProgressDlg = NULL;


    if (fCloseConnections)
    {
        if  (NOERROR == FindProgressDialog(GUID_NULL,FALSE,SW_MINIMIZE,&pProgressDlg))
        {
            ReleaseProgressDialog(GUID_NULL,pProgressDlg,FALSE);
        }
        else
        {
            ConnectObj_CloseConnections();
        }
    }

    m_fDead = TRUE;

    if (m_pItemListView)
    {
        delete m_pItemListView;
        m_pItemListView = NULL;
    }


    if (m_hwnd)
    {
	DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }


    delete this;

    return;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::UpdateWndPosition
//
//  PURPOSE:   updates window Z-Order and min/max state.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------

void CChoiceDlg::UpdateWndPosition(int nCmdShow,BOOL fForce)
{
    // always just pull choice to the front since can't minimize;
   ShowWindow(m_hwnd,nCmdShow);
   SetForegroundWindow(m_hwnd);
   UpdateWindow(m_hwnd);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlg::HandleLogError(int iItem)
//
//  PURPOSE:  handles virtual function for base class.
//
//
//--------------------------------------------------------------------------------

void CChoiceDlg::HandleLogError(HWND hwnd, HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors)
{
    AssertSz(0,"Choice dialogs HandleLogError Called");

}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::CallCompletionRoutine, private
//
//  Synopsis:   method called when a call has been completed.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam)
{

    // only completion routine choice
    // dialog should get is for show properties
    switch(dwThreadMsg)
    {
    case ThreadMsg_ShowProperties:

        ObjMgr_ReleaseHandlerPropertiesLockCount(1);

        // If have a success code we need to handle do it
        // before releasing our lock.
        if (lpCallCompletelParam)
        {
            switch(lpCallCompletelParam->hCallResult)
            {
            case S_SYNCMGR_ITEMDELETED:

                // if item is deleted just set the itemState to unchecked and remove from the
                // ui

                if (m_pHndlrQueue && m_pItemListView)
                {
                LVHANDLERITEMBLOB lvItemBlob;
                int lvItemID;

                    m_pHndlrQueue->SetItemState(lpCallCompletelParam->clsidHandler,
                                    lpCallCompletelParam->itemID,SYNCMGRITEMSTATE_UNCHECKED);

                    lvItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                    lvItemBlob.clsidServer = lpCallCompletelParam->clsidHandler;
                    lvItemBlob.ItemID = lpCallCompletelParam->itemID;

                    if (-1 != (lvItemID = m_pItemListView->FindItemFromBlob((LPLVBLOB) &lvItemBlob)))
                    {
                        // if toplevel item, first delete the children
                        if (GUID_NULL == lpCallCompletelParam->itemID)
                        {
                            m_pItemListView->DeleteChildren(lvItemID);
                        }

                        m_pItemListView->DeleteItem(lvItemID);
                    }

                    Assert(-1 != lvItemID);
                }

                break;
            case S_SYNCMGR_ENUMITEMS:

                if (m_pHndlrQueue && m_pItemListView)
                {
                LVHANDLERITEMBLOB lvItemBlob;
                int lvItemID;

                    // delete all items from the ListView.
                    lvItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                    lvItemBlob.clsidServer = lpCallCompletelParam->clsidHandler;
                    lvItemBlob.ItemID = GUID_NULL;

                    if (-1 != (lvItemID = m_pItemListView->FindItemFromBlob((LPLVBLOB) &lvItemBlob)))
                    {
                        if (m_pItemListView->DeleteChildren(lvItemID))
                        {

                            m_pHndlrQueue->ReEnumHandlerItems(lpCallCompletelParam->clsidHandler,
                                                    lpCallCompletelParam->itemID);

                            AddNewItemsToListView();
                        }
                    }

                    Assert(-1 != lvItemID);
                }
                break;
            default:
                break;
            }
        }

        --m_dwShowPropertiesCount;
        Assert( ((LONG) m_dwShowPropertiesCount) >= 0);

        // fix up the count if gone negative.
        if ( ((LONG) m_dwShowPropertiesCount) < 0)
            m_dwShowPropertiesCount = 0;

        break;
    default:
        AssertSz(0,"Uknown Completion Routine");
        break;
    }


    // if have an lparam free it now
    if (lpCallCompletelParam)
    {
        FREE(lpCallCompletelParam);
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::QueryCanSystemShutdown, private
//
//  Synopsis:   called by object manager to determine if can shutdown.
//
//          !!!Warning - can be called on any thread. make sure this is
//              readonly.
//
//          !!!Warning - Do not yield in the function;
//
//
//  Arguments:
//
//  Returns:   S_OK - if can shutdown
//             S_FALSE - system should not shutdown, must fill in out params.
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CChoiceDlg::QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide)
{
HRESULT hr = S_OK;

    // dialog locked open if in ShowProperties
    if (m_dwShowPropertiesCount > 0)
    {
        *puMessageId = IDS_HANDLERPROPERTIESQUERYENDSESSION;
        *phwnd = NULL; // since properties can overvlay us don't give parent
        *pfLetUserDecide = FALSE; // user doesn't get a choice.
        hr = S_FALSE;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::CalcListViewWidth, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    12-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CChoiceDlg::CalcListViewWidth(HWND hwndList)
{
NONCLIENTMETRICSA metrics;
RECT rcClientRect;


    metrics.cbSize = sizeof(metrics);

    // explicitly ask for ANSI version of SystemParametersInfo since we just
    // care about the ScrollWidth and don't want to conver the LOGFONT info.
    if (GetClientRect(hwndList,&rcClientRect)
        && SystemParametersInfoA(SPI_GETNONCLIENTMETRICS,sizeof(metrics),(PVOID) &metrics,0))
    {
        // subtract off scroll bar distance + 1/2 another to give a little space to
        // read right justified text.
        rcClientRect.right -= (metrics.iScrollWidth * 3)/2;
    }
    else
    {
        rcClientRect.right = 320;  // if fail, just makeup a number
    }


    return rcClientRect.right;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnInitialize, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CChoiceDlg::OnInitialize(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
HIMAGELIST himage;
WCHAR wszColumnName[MAX_PATH];
INT iItem = -1;
HWND hwndList = GetDlgItem(hwnd,IDC_CHOICELISTVIEW);
LPNETAPI pNetApi;


    // if sens is not installed hide the settings button.
    // and move the synchronize over.
    if (pNetApi = gSingleNetApiObj.GetNetApiObj())
    {
        if (!(pNetApi->IsSensInstalled()))
        {
        RECT rect;
        HWND hwndSettings = GetDlgItem(hwnd,IDC_OPTIONS);

            if (hwndSettings)
            {
            BOOL fGetWindowRect;
            HWND hwndStart;
            RECT rectStart;

                ShowWindow(hwndSettings,SW_HIDE);
                EnableWindow(hwndSettings,FALSE); // disable for alt

                fGetWindowRect = GetWindowRect(hwndSettings,&rect);
                hwndStart = GetDlgItem(hwnd,IDC_START);

                if (fGetWindowRect && hwndStart
                    && GetClientRect(hwndStart,&rectStart)
                    && MapWindowPoints(NULL,hwnd,(LPPOINT) &rect,2)
                    )
                {

                    SetWindowPos(hwndStart, 0,
                        rect.right - WIDTH(rectStart),rect.top,0,0,SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE );

                }

            }

        }

        pNetApi->Release();
    }


    m_hwnd = hwnd; // setup the hwnd.

    m_fHwndRightToLeft = IsHwndRightToLeft(m_hwnd);

    // IF THE HWND IS RIGHT TO LEFT HIDE
    // SIZE CONTROL UNTIL RESIZE WORKS.

    if (m_fHwndRightToLeft)
    {
        ShowWindow(GetDlgItem(m_hwnd,IDC_CHOICERESIZESCROLLBAR),SW_HIDE);
    }
    

    if (hwndList)
    {

       // setup the list view
       m_pItemListView = new CListView(hwndList,hwnd,IDC_CHOICELISTVIEW,WM_BASEDLG_NOTIFYLISTVIEWEX);

       if (m_pItemListView)
       {
       int iClientRect = CalcListViewWidth(hwndList);
       UINT ImageListflags;

           m_pItemListView->SetExtendedListViewStyle(LVS_EX_CHECKBOXES
                                    | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP );


            // create an imagelist, if fail continue, list view just won't have an
            // imaglist

            ImageListflags = ILC_COLOR | ILC_MASK;
            if (IsHwndRightToLeft(m_hwnd))
            {
                 ImageListflags |=  ILC_MIRROR;
            }

            himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                             GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
            if (himage)
            {
                m_pItemListView->SetImageList(himage,LVSIL_SMALL);
            }



            // Calc cx 2/3 for name 1/3 for

            if (!LoadString(g_hInst,IDS_CHOICEHANDLERCOLUMN, wszColumnName, ARRAY_SIZE(wszColumnName)))
            {
                *wszColumnName = NULL;
            }

            InsertListViewColumn(m_pItemListView,CHOICELIST_NAMECOLUMN,wszColumnName,LVCFMT_LEFT,(iClientRect*2)/3);


            if (!LoadString(g_hInst,IDS_CHOICELASTUPDATECOLUMN, wszColumnName, ARRAY_SIZE(wszColumnName)))
            {
                *wszColumnName = NULL;
            }

            InsertListViewColumn(m_pItemListView,CHOICELIST_LASTUPDATECOLUMN,wszColumnName,LVCFMT_RIGHT,(iClientRect)/3);
       }
    }

    RECT rectParent;

    m_ulNumDlgResizeItem = 0; // if fail then we don't resize anything.

 
    if (GetClientRect(hwnd,&rectParent))
    {
    ULONG itemCount;
    DlgResizeList *pResizeList;

        // loop through resize list
        Assert(NUM_DLGRESIZEINFOCHOICE == (sizeof(g_ChoiceResizeList)/sizeof(DlgResizeList)) );

        pResizeList = (DlgResizeList *) &g_ChoiceResizeList;

        for (itemCount = 0; itemCount < NUM_DLGRESIZEINFOCHOICE; ++itemCount)
        {
            if(InitResizeItem(pResizeList->iCtrlId,
                pResizeList->dwDlgResizeFlags,hwnd,&rectParent,&(m_dlgResizeInfo[m_ulNumDlgResizeItem])))
            {
                ++m_ulNumDlgResizeItem;
            }

            ++pResizeList;
        }
    }


    // store the current width and height as the
    // the min
    if (GetWindowRect(hwnd,&rectParent))
    {
        m_ptMinimizeDlgSize.x = rectParent.right - rectParent.left;
        m_ptMinimizeDlgSize.y = rectParent.bottom - rectParent.top;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnClose, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnClose(UINT uMsg,WPARAM wParam,LPARAM lParam)
{

    if ( (0 == m_dwShowPropertiesCount) && (m_fInternalAddref) )
    {
        m_fInternalAddref = FALSE; // set released member so know we have removed addref on ourself.
        SetChoiceReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_CANCEL);
        ReleaseChoiceDialog(m_clsid,this);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnSetQueueData, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnSetQueueData(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
SetQueueDataInfo *pdataInfo;
BOOL fSet;
BOOL *pfSet = (BOOL *) wParam;

    pdataInfo = (SetQueueDataInfo *) lParam;
    fSet = PrivSetQueueData(*pdataInfo->rclsid, pdataInfo->pHndlrQueue );

    if (pfSet)
    {
        *pfSet = fSet;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnContextMenu, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnContextMenu(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    WinHelp ((HWND)wParam,g_szSyncMgrHelp,HELP_CONTEXTMENU,
               (ULONG_PTR) g_aContextHelpIds);
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnHelp, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnHelp(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
LPHELPINFO lphi  = (LPHELPINFO)lParam;

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
	WinHelp ( (HWND) lphi->hItemHandle,
		g_szSyncMgrHelp,HELP_WM_HELP,
		(ULONG_PTR)  g_aContextHelpIds);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnStartCommand, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnStartCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    if ((0 == m_dwShowPropertiesCount) && (m_fInternalAddref))
    {
       m_fInternalAddref = FALSE;
       SetChoiceReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_OK);
       ReleaseChoiceDialog(m_clsid,this);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnPropertyCommand, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnPropertyCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    // only bring up properties if still have addref on self.
    if (m_fInternalAddref && m_pItemListView)
    {
    int i =  m_pItemListView->GetSelectionMark();

        if (i >= 0)
        {
            ShowProperties(i);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnCommand, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
WORD wID = LOWORD(wParam);
WORD wNotifyCode = HIWORD(wParam);

    switch (wID)
    {
    case  IDC_START:
        if (BN_CLICKED == wNotifyCode)
        {
            OnStartCommand(uMsg,wParam,lParam);
        }
        break;
    case IDCANCEL:
    case IDC_CLOSE:
        OnClose(uMsg,wParam,lParam);
        break;
    case IDC_PROPERTY:
        OnPropertyCommand(uMsg,wParam,lParam);
	break;
    case IDC_OPTIONS:
        ShowOptionsDialog(m_hwnd);
        break;
    default:
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnGetMinMaxInfo, private
//
//  Synopsis:  Called by WM_GETMINMAXINFO
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CChoiceDlg::OnGetMinMaxInfo(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
MINMAXINFO   *pMinMax = (MINMAXINFO *) lParam ;

     pMinMax->ptMinTrackSize.x = m_ptMinimizeDlgSize.x;
     pMinMax->ptMinTrackSize.y = m_ptMinimizeDlgSize.y ;

}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnSize, private
//
//  Synopsis:  Called by WM_SIZE
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------


void CChoiceDlg::OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    ResizeItems(m_ulNumDlgResizeItem,m_dlgResizeInfo);
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnNotify, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CChoiceDlg::OnNotify(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
int idCtrl = (int) wParam;
LPNMHDR pnmh = (LPNMHDR) lParam;

    if ((IDC_CHOICELISTVIEW == idCtrl) && m_pItemListView)
    {
        return m_pItemListView->OnNotify(pnmh);
    }


    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChoiceDlg::OnNotifyListViewEx, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CChoiceDlg::OnNotifyListViewEx(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
int idCtrl = (int) wParam;
LPNMHDR pnmh = (LPNMHDR) lParam;
LVHANDLERITEMBLOB lvHandlerItemBlob;

    if ( (IDC_CHOICELISTVIEW != idCtrl) || (NULL == m_pItemListView))
    {
        Assert(IDC_CHOICELISTVIEW == idCtrl);
        Assert(m_pItemListView);
        return 0;
    }

    lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);

    switch (pnmh->code)
    {
    case LVNEX_ITEMCHECKCOUNT:
    {
    LPNMLISTVIEWEXITEMCHECKCOUNT  plviCheckCount = (LPNMLISTVIEWEXITEMCHECKCOUNT) lParam;

        // update start button based on how many items are selected.
        SetButtonState(IDC_START,plviCheckCount->iCheckCount);
        break;
    }
    case LVNEX_ITEMCHANGED:
    {
    LPNMLISTVIEWEX pnmvEx = (LPNMLISTVIEWEX) lParam;
    LPNMLISTVIEW pnmv= &(pnmvEx->nmListView);

        if (pnmv->uChanged == LVIF_STATE)
        {	
        int iItem = pnmv->iItem;
        BOOL fItemHasProperties = FALSE;;
	
            if (pnmv->uNewState & LVIS_SELECTED)
            {
                Assert(iItem >= 0);

		if ((iItem >= 0) &&
                       m_pItemListView->GetItemBlob(iItem,(LPLVBLOB) &lvHandlerItemBlob,lvHandlerItemBlob.cbSize))
                {

                    if (NOERROR == m_pHndlrQueue->ItemHasProperties(lvHandlerItemBlob.clsidServer,
                                                                lvHandlerItemBlob.ItemID))
		    {
                        fItemHasProperties = TRUE;
		    }
                }
            }

            SetButtonState(IDC_PROPERTY,fItemHasProperties);
	}
        break;
    }
    case LVNEX_DBLCLK:
    {
    LPNMLISTVIEW lpnmlv = (LPNMLISTVIEW) lParam;

        ShowProperties(lpnmlv->iItem);
        break;
    }
    default:
        break;
    }

    return 0;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CChoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
//
//  PURPOSE:  Callback for Choice Dialog
//
//	COMMENTS: Implemented on main thread.
//
//
//------------------------------------------------------------------------------
BOOL CALLBACK CChoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam)
{
CChoiceDlg *pThis = (CChoiceDlg *) GetWindowLongPtr(hwnd, DWLP_USER);

    // spcial case destroy and init.
    switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0); // done with this thread.
	break;
    case WM_INITDIALOG:
        {
	// Stash the this pointer so we can use it later
	SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
	pThis = (CChoiceDlg *) lParam;

        if (pThis)
        {
            return pThis->OnInitialize(hwnd,uMsg,wParam,lParam);
        }

        return FALSE;
	break;
        }
    default:
        {
            if (pThis)
            {
                switch (uMsg)
                {
                case WM_CLOSE:
                    pThis->OnClose(uMsg,wParam,lParam);
                    break;
                case WM_BASEDLG_HANDLESYSSHUTDOWN:
                    PostMessage(hwnd,WM_CLOSE,0,0); // post a close message to get on our thread.
                    break;
                case WM_GETMINMAXINFO:
                    pThis->OnGetMinMaxInfo(uMsg,wParam,lParam);
                    break;
                case WM_SIZE:
                    pThis->OnSize(uMsg,wParam,lParam);
                    break;
                case WM_COMMAND:
                    pThis->OnCommand(uMsg,wParam,lParam);
                    break;
                case WM_NOTIFY:
                    {
                    LRESULT lretOnNotify;

                        lretOnNotify =  pThis->OnNotify(uMsg,wParam,lParam);

                        SetWindowLongPtr(hwnd,DWLP_MSGRESULT,lretOnNotify);
                        return TRUE;
                    }
	            break;
                case WM_HELP:
                    pThis->OnHelp(uMsg,wParam,lParam);
                    return TRUE;
	            break;
	        case WM_CONTEXTMENU:
                    pThis->OnContextMenu(uMsg,wParam,lParam);
	            break;
                case WM_BASEDLG_SHOWWINDOW:
                    pThis->UpdateWndPosition((int)wParam /*nCmd */,FALSE /* force */);
                    break;
                case WM_BASEDLG_COMPLETIONROUTINE:
                    pThis->CallCompletionRoutine((DWORD)wParam /* dwThreadMsg*/,(LPCALLCOMPLETIONMSGLPARAM) lParam);
                    break;
                case WM_BASEDLG_NOTIFYLISTVIEWEX:
                    pThis->OnNotifyListViewEx(uMsg,wParam,lParam);
                    break;
	        case WM_CHOICE_SETQUEUEDATA:
                    pThis->OnSetQueueData(uMsg,wParam,lParam);
                    return TRUE;
	            break;
                case WM_CHOICE_RELEASEDLGCMD:
                    pThis->PrivReleaseDlg((WORD)wParam /* wCommandID */);
                    break;
	        default:
	            break;
                }
            }
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\dll\wizsel.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//  
//  File:       wizsel.cxx
//
//  Contents:   Task wizard Onestop selection property page implementation.
//
//  Classes:    CSelectItemsPage
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------


#include "precomp.h"

// temporariy define new mstask flag in case hasn't
// propogated to sdk\inc
//for CS help

extern TCHAR szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];


extern DWORD g_dwPlatformId;
extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo,
extern LANGID g_LangIdSystem;      // LangId of system we are running on.

CSelectItemsPage *g_pSelectItemsPage = NULL;

//+-------------------------------------------------------------------------------
//  FUNCTION: SchedWizardConnectionDlgProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Callback dialog procedure for the property page
//
//  PARAMETERS:
//    hDlg      - Dialog box window handle
//    uMessage  - current message
//    wParam    - depends on message
//    lParam    - depends on message
//
//  RETURN VALUE:
//
//    Depends on message.  In general, return TRUE if we process it.
//
//  COMMENTS:
//
//--------------------------------------------------------------------------------
BOOL CALLBACK SchedWizardConnectionDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
	WORD wNotifyCode = HIWORD(wParam); // notification code
 
	switch (uMessage)
	{
		case WM_INITDIALOG:
			
			if (g_pSelectItemsPage)
				g_pSelectItemsPage->Initialize(hDlg);

            InitPage(hDlg,lParam);
            break;

        case WM_DESTROY:
			if (g_pSelectItemsPage)
			{
				g_pSelectItemsPage->FreeItemsFromListView();
				g_pSelectItemsPage->FreeRas();
                                
                                if (g_pSelectItemsPage->m_pListView)
                                {
                                    delete g_pSelectItemsPage->m_pListView;
                                }

			}
			break;

		case WM_HELP: 
        {
			LPHELPINFO lphi  = (LPHELPINFO)lParam;

			if (lphi->iContextType == HELPINFO_WINDOW)  
			{
				WinHelp ( (HWND) lphi->hItemHandle,
					szSyncMgrHelp, 
    	            HELP_WM_HELP, 
					(ULONG_PTR) g_aContextHelpIds);
			}           
			return TRUE;
		}
		case WM_CONTEXTMENU:
		{
			WinHelp ((HWND)wParam,
                            szSyncMgrHelp, 
                            HELP_CONTEXTMENU,
                           (ULONG_PTR)g_aContextHelpIds);
			
			return TRUE;
		}
		case WM_PAINT:
            WmPaint(hDlg, uMessage, wParam, lParam);
            break;

        case WM_PALETTECHANGED:
            WmPaletteChanged(hDlg, wParam);
            break;

        case WM_QUERYNEWPALETTE:
            return( WmQueryNewPalette(hDlg) );
            break;

        case WM_ACTIVATE:
            return( WmActivate(hDlg, wParam, lParam) );
            break;

        case WM_NOTIFYLISTVIEWEX:

            if (g_pSelectItemsPage)
            {
            int idCtrl = (int) wParam; 
            LPNMHDR pnmhdr = (LPNMHDR) lParam;

                if ( (IDC_SCHEDUPDATELIST != idCtrl) || (NULL == g_pSelectItemsPage->m_pListView))
                {
                    Assert(IDC_SCHEDUPDATELIST == idCtrl);
                    Assert(g_pSelectItemsPage->m_pListView);
                    break;
                }

                switch (pnmhdr->code)
                {
                    case LVNEX_ITEMCHECKCOUNT:
                    {
		    LPNMLISTVIEWEXITEMCHECKCOUNT pnmvCheckCount = (LPNMLISTVIEWEXITEMCHECKCOUNT) lParam; 
                    
                        g_pSelectItemsPage->SetItemCheckState(pnmvCheckCount->iCheckCount);

                        break;
                    }
                    default:
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            if (g_pSelectItemsPage)
            {
            int idCtrl = (int) wParam; 
            LPNMHDR pnmhdr = (LPNMHDR) lParam;


                // if notification for UpdateListPass it on.
                if ((IDC_SCHEDUPDATELIST == idCtrl) && g_pSelectItemsPage->m_pListView)
                {
                    g_pSelectItemsPage->m_pListView->OnNotify(pnmhdr);
                    break;
                }
                
            }

	    switch (((NMHDR FAR *)lParam)->code)
            {
  		case PSN_KILLACTIVE:
			break;
		case PSN_RESET:
			break;
 		case PSN_SETACTIVE:
			if (g_pSelectItemsPage->m_pListView
                                && (0 == g_pSelectItemsPage->m_pListView->GetCheckedItemsCount()) )
			{
				PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK ) ; 
			}
			else
			{ 
				PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
			}
			
	            SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, 0);
		    break;
		case PSN_WIZNEXT:
			//shouldn't save this until finish
	        //this guy is only called if the dialog is a wizard
                   break;					 	
                default:
                    break;
            }
            break;
    	case WM_COMMAND:
            switch (LOWORD(wParam))
            {
		    case IDC_SCHEDUPDATECOMBO:
		    {				
			    if (wNotifyCode == CBN_SELCHANGE)
			    {
				HWND hwndCombo = (HWND) lParam;
				if (g_pSelectItemsPage)
				{
					g_pSelectItemsPage->SetConnectionDirty();
                                        
                                        
					g_pSelectItemsPage->ShowItemsOnThisConnection
								(ComboBox_GetCurSel(hwndCombo), FALSE);
                                        
				}
			    }
		    }
		    break;

		    case IDC_AUTOCONNECT:
			    {
				if (wNotifyCode == BN_CLICKED) 
				{
					PropSheet_Changed(GetParent(hDlg), hDlg);
		
					HWND hwndCtrl = (HWND) lParam;
					g_pSelectItemsPage->SetCheck(LOWORD(wParam),
										Button_GetCheck(hwndCtrl));
			
				}
			    }
		    break;
		    
		    default:
                        break;

            }
            break;

		default:
			return FALSE;
	}
	return TRUE;   
}


    
    
//+--------------------------------------------------------------------------
//
//  Member:     CSelectItemsPage::CSelectItemsPage
//
//  Synopsis:   ctor
//
//              [phPSP]                - filled with prop page handle
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

CSelectItemsPage::CSelectItemsPage(
    HINSTANCE hinst,
	BOOL *pfSaved,
	ISyncSchedule *pISyncSched,
        HPROPSHEETPAGE *phPSP,
	int iDialogResource)
{
	ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));

        Assert(pISyncSched);

   	m_psp.dwSize = sizeof (PROPSHEETPAGE);
        m_psp.dwFlags = PSH_DEFAULT;
	m_psp.hInstance = hinst;
	m_psp.pszTemplate = MAKEINTRESOURCE(iDialogResource);
	m_psp.pszIcon = NULL;
	m_psp.pfnDlgProc = (DLGPROC) SchedWizardConnectionDlgProc;
	m_psp.lParam = 0;

	m_iCreationKind = iDialogResource;
	g_pSelectItemsPage = this;
	m_pISyncSched = pISyncSched;
	m_pISyncSched->AddRef();
	m_pfSaved = pfSaved;
	*m_pfSaved = FALSE;


        m_pListView = NULL;

	m_fItemsChanged = FALSE;
	m_fConnectionFlagChanged = FALSE;
	m_fConnectionChanged = FALSE;

        // attempt to get our private interface
        if (NOERROR != pISyncSched->QueryInterface(IID_ISyncSchedulep,(void **) &m_pISyncSchedp))
        {
            m_pISyncSchedp = NULL;
        }

	
#ifdef WIZARD97
    m_psp.dwFlags |= PSP_HIDEHEADER;
#endif // WIZARD97

   *phPSP = CreatePropertySheetPage(&m_psp);


}


CSelectItemsPage::~CSelectItemsPage()
{

    if (m_pISyncSchedp)
    {
        m_pISyncSchedp->Release();
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CSelectItemsPage::FreeRas()
//
//  History:    12-Mar-1998   SusiA   
//
//---------------------------------------------------------------------------
void CSelectItemsPage::FreeRas()
{
	if (m_pRas)
		delete m_pRas;

}

//+--------------------------------------------------------------------------
//
//  Member:     CSelectItemsPage::Initialize(HWND hwnd)
//
//  Synopsis:   initialize the item selection page and set the task name to a unique 
//				new onestop name
//
//  History:    11-21-1997   SusiA   
//
//---------------------------------------------------------------------------

BOOL CSelectItemsPage::Initialize(HWND hwnd)
{
	m_hwnd = hwnd;
	// Initialize Ras Combo box
    m_pRas= new CRasUI();
    
    if (NULL == m_pRas || FALSE == m_pRas->Initialize())
    {
		if (m_pRas)
			delete m_pRas;
		return FALSE;
    }
    m_hwndRasCombo = GetDlgItem(m_hwnd,IDC_SCHEDUPDATECOMBO);
	
    m_pRas->FillRasCombo(m_hwndRasCombo,FALSE,TRUE);

    InitializeItems();
    
    //initialize the item list
    HWND hwndList = GetDlgItem(m_hwnd,IDC_SCHEDUPDATELIST);
    LV_COLUMN columnInfo;
    HIMAGELIST himage;
    INT iItem = -1;
    UINT ImageListflags;

    
    m_pListView = new CListView(hwndList,m_hwnd,IDC_SCHEDUPDATELIST,WM_NOTIFYLISTVIEWEX);
    if (NULL == m_pListView)
    {
        return FALSE;
    }

    m_pListView->SetExtendedListViewStyle(LVS_EX_CHECKBOXES |  LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP );

    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(hwnd))
    {
        ImageListflags |=  ILC_MIRROR;
    }

    // create an imagelist
    himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                     GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
    if (himage)
    {
       m_pListView->SetImageList(himage,LVSIL_SMALL);
    }
  
    // Insert the Proper columns

    columnInfo.mask = LVCF_FMT  | LVCF_TEXT  | LVCF_WIDTH  | LVCF_SUBITEM;
    columnInfo.fmt = LVCFMT_LEFT;
    columnInfo.cx = CalcListViewWidth(hwndList,295);
    columnInfo .pszText = TEXT("");
    columnInfo.cchTextMax = 1;
    columnInfo.iSubItem = 0;
    m_pListView->InsertColumn(0,&columnInfo);
    
    ShowItemsOnThisConnection(ComboBox_GetCurSel(m_hwndRasCombo), FALSE);

    //Wizard creation
    if (m_iCreationKind != IDD_SCHEDPAGE_ITEMS)
    {
	    SetConnectionDirty();
    }
    ShowWindow(m_hwnd, /* nCmdShow */ SW_SHOWNORMAL ); 
    UpdateWindow(m_hwnd);

    return TRUE;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::InitializeItems()
//
//  PURPOSE: initialize the handler for the schedule wizard page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSelectItemsPage::InitializeItems()
{
	int i,
		iConnectionCount;
	TCHAR ptszComboConnName[RAS_MaxEntryName + 1];

	TCHAR ptszConnectionName[RAS_MaxEntryName + 1];
	WCHAR pwszConnectionName[RAS_MaxEntryName + 1];
	
	DWORD dwSize = RAS_MaxEntryName + 1;
	DWORD dwConnType;

	m_fItemsChanged = FALSE;
	m_fConnectionFlagChanged = FALSE;
	m_fConnectionChanged = FALSE;

	if (FAILED(m_pISyncSched->GetConnection(&dwSize,pwszConnectionName, &dwConnType)))
	{
		return FALSE;
	}
	ConvertString(ptszConnectionName,pwszConnectionName,ARRAY_SIZE(ptszConnectionName));

	iConnectionCount= ComboBox_GetCount(m_hwndRasCombo);		
	
	//Initialize the Schedule connection settings
	COMBOBOXEXITEM comboItem;
	  
	for (i=0; i< iConnectionCount; i++)
	{
		comboItem.mask = CBEIF_TEXT;
		comboItem.cchTextMax = ARRAY_SIZE(ptszComboConnName);
		comboItem.pszText = ptszComboConnName;
		comboItem.iItem = i;
                // Review, handle failures.
                ComboEx_GetItem(m_hwndRasCombo,&comboItem);

		m_SchedConnectionNum = 0;
		
		if (lstrcmp(ptszComboConnName, ptszConnectionName) == 0)
		{
			//Current connection to sync over for the schedule.
			m_SchedConnectionNum = i;
			ComboBox_SetCurSel(m_hwndRasCombo, i);
			break;
		}
	}
	//Set the default autoconnect check state  
	m_pISyncSched->GetFlags(&m_dwFlags);
			
	Button_SetCheck(GetDlgItem(m_hwnd,IDC_AUTOCONNECT),
					m_dwFlags & SYNCSCHEDINFO_FLAGS_AUTOCONNECT);

	return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CSelectItemsPage::SetConnectionDirty()
//
//  PURPOSE:  we have changed the connection info
//
//	COMMENTS: Only called frm prop sheet; not wizard
//
//--------------------------------------------------------------------------------
void CSelectItemsPage::SetConnectionDirty()
{
	m_fConnectionChanged = TRUE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CSelectItemsPage::CommitChanges()
//
//  PURPOSE:  Write all the current Schedule Settings to the registry
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
HRESULT CSelectItemsPage::CommitChanges()
{
	HRESULT hr = S_OK;
	
	if (m_fConnectionFlagChanged)
	{
		m_pISyncSched->SetFlags(m_dwFlags);
	}

	if (m_fConnectionChanged)
	{
		m_pISyncSched->SetConnection(m_pwszConnectionName, m_dwConnType);
	}
	if (m_fItemsChanged) 
	{
        int iTotalItems = m_pListView->GetItemCount();

		//Now set the check state with ISyncSched
		BOOL fChecked;
		int iItem;

                for (iItem=0;iItem < iTotalItems;iItem++)
		{

                        fChecked = (LVITEMEXSTATE_CHECKED == m_pListView->GetCheckState(iItem)) ? TRUE : FALSE;
			
			LVITEMEX lvItem;
			ZeroMemory(&lvItem, sizeof(lvItem));

			lvItem.mask = LVIF_PARAM;
                        lvItem.maskEx = 0;
			lvItem.iItem = iItem;
			lvItem.lParam = 0;

			if (m_pListView->GetItem(&lvItem) && lvItem.lParam) // lparam is zero for toplevel items
			{	
				LPSYNC_HANDLER_ITEM_INFO pHandlerItem = (LPSYNC_HANDLER_ITEM_INFO) lvItem.lParam;
				if (fChecked)
				{
					m_pISyncSched->SetItemCheck(pHandlerItem->handlerID,
												&(pHandlerItem->itemID),
												SYNCMGRITEMSTATE_CHECKED);
				}
				else
				{
					m_pISyncSched->SetItemCheck(pHandlerItem->handlerID,
												&(pHandlerItem->itemID),
												SYNCMGRITEMSTATE_UNCHECKED);
				}
			}
		}
	}

	hr = m_pISyncSched->Save();

	if (hr == S_OK)
	{
		*m_pfSaved = TRUE; 
	}

	return hr;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::SetItemCheckState()
//
//  PURPOSE: set the selected check state
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSelectItemsPage::SetItemCheckState(int iCheckCount)
{
int iConnectionItem = ComboBox_GetCurSel(m_hwndRasCombo);
	
    //The check state is message is getting flagged by us programmatically setting it,
    // until after we are done initializing.
    if (m_Initialized)
    {
    BOOL fAnyChecked = iCheckCount ? TRUE : FALSE;
	    
	//Enable the prompt me first according to what items selected
	//EnableWindow(GetDlgItem(m_hwnd,IDC_AUTOPROMPT_ME_FIRST), m_fAnyChecked);
	
	PropSheet_Changed(GetParent(m_hwnd), m_hwnd);

	//Enable the next button according to what items are selected
	// should only be disabled iff ALL connection items are
	// unselected, not just the current connections selection's
	if (fAnyChecked) 
		PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK | PSWIZB_NEXT);
	else
		PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK);

	m_fItemsChanged = TRUE;
    }
    return TRUE;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::SetCheck(WORD wParam,DWORD dwCheckState)
//
//  PURPOSE: set the selected check state
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSelectItemsPage::SetCheck(WORD wParam,DWORD dwCheckState)
{
	if (wParam == IDC_AUTOCONNECT)
	{
		int iConnectionItem = ComboBox_GetCurSel(m_hwndRasCombo);

		//preserve Readonly state
		m_dwFlags &= SYNCSCHEDINFO_FLAGS_READONLY;

		//set new autoconnect state
		if (dwCheckState)
		{
			m_dwFlags |= SYNCSCHEDINFO_FLAGS_AUTOCONNECT;
		}
		
		if (m_Initialized)
		{
			m_fConnectionFlagChanged = TRUE;
		}

	}
	return TRUE;

}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::FreeItemsFromListView()
//
//  PURPOSE:  free the items on this Schedule 
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL CSelectItemsPage::FreeItemsFromListView()
{
	int iItem;
	int iItemCount;

	HWND hwndListView = GetDlgItem(m_hwnd,IDC_SCHEDUPDATELIST);
	
	iItemCount = m_pListView->GetItemCount();		
	
	for(iItem = 0; iItem < iItemCount; iItem++)
	{
	LPSYNC_HANDLER_ITEM_INFO pHandlerItem; 
	LVITEMEX lvItem;

	    ZeroMemory(&lvItem, sizeof(lvItem));
	    lvItem.mask = LVIF_PARAM;
            lvItem.maskEx = 0;
	    lvItem.iItem = iItem;

            if (m_pListView->GetItem(&lvItem) && lvItem.lParam)
            {
	        pHandlerItem = (LPSYNC_HANDLER_ITEM_INFO) lvItem.lParam;
	        FREE(pHandlerItem);
            }

	}
	return TRUE;
}
//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL CSelectItemsPage::ShowItemsOnThisConnection()
//
//  PURPOSE: List the items on this connection for the Schedule page
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL CSelectItemsPage::ShowItemsOnThisConnection(int iItem, BOOL fClear)
{
TCHAR ptszConnectionName[RAS_MaxEntryName + 1];

    // set up the list view
    if (!m_pListView || !m_pISyncSchedp)
    {
        return FALSE;
    }

    HIMAGELIST himage;
    LVITEMEX itemInfo;

    m_Initialized = FALSE;			

    //Note:  Use text to "uniquely" identify connection on RAS
    //change to using GUID on connection objects
    int iNumConnections = ComboBox_GetCount(m_hwndRasCombo);

    m_SchedConnectionNum = iItem;

    COMBOBOXEXITEM comboItem;
    comboItem.mask = CBEIF_TEXT | CBEIF_LPARAM;
    comboItem.cchTextMax = ARRAY_SIZE(ptszConnectionName);
    comboItem.pszText = ptszConnectionName;
    comboItem.iItem = iItem;

    // Review, handle failures.
    ComboEx_GetItem(m_hwndRasCombo,&comboItem);
    
    //SetConnectionName
    ConvertString(m_pwszConnectionName, ptszConnectionName,ARRAY_SIZE(ptszConnectionName));
    m_dwConnType = (DWORD) comboItem.lParam;

    // if don't need to clear and listview contains items then we are done
    if (!fClear && m_pListView->GetItemCount())
    {
        m_Initialized = TRUE;
        return TRUE;
    }

    //first clear out the list view
    FreeItemsFromListView();
    m_pListView->DeleteAllItems();


    // Review, dont' clear ImageList so just keeps getting bigger as change connections.
    himage = m_pListView->GetImageList(LVSIL_SMALL );
			
    //Enumerate the Items
    IEnumSyncItems *pIEnum;
    LPSYNC_HANDLER_ITEM_INFO pHandlerItem = (LPSYNC_HANDLER_ITEM_INFO) 
								    ALLOC(sizeof(SYNC_HANDLER_ITEM_INFO));

    ULONG ulFetched;

    if (FAILED(m_pISyncSchedp->EnumItems(GUID_NULL, &pIEnum)))
    {
	return FALSE;
    }


    while (pHandlerItem && S_OK == pIEnum->Next(1,pHandlerItem, &ulFetched))
    {
    LVHANDLERITEMBLOB lvHandlerItemBlob;
    int iParentItemId;
    BOOL fHandlerParent = TRUE; // always have a parent for now.

        // Check if item is already in the ListView and if so
        // go on

        lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
        lvHandlerItemBlob.clsidServer = pHandlerItem->handlerID;
        lvHandlerItemBlob.ItemID = pHandlerItem->itemID;
    
        if (-1 != m_pListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob))
        {
            // already in ListView, go on to the next item.
            continue;
        }

        if (!fHandlerParent)
        {
            iParentItemId = LVI_ROOT;
        }
        else
        {
            // need to add to list so find parent and if one doesn't exist, create it.
            lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
            lvHandlerItemBlob.clsidServer = pHandlerItem->handlerID;
            lvHandlerItemBlob.ItemID = GUID_NULL;

            iParentItemId = m_pListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);

            if (-1 == iParentItemId)
            {
            LVITEMEX itemInfoParent;
            SYNCMGRHANDLERINFO *pSyncMgrHandlerInfo;

                // if can't get the ParentInfo then don't add the Item
                if (NOERROR != m_pISyncSchedp->GetHandlerInfo(pHandlerItem->handlerID,&pSyncMgrHandlerInfo) )
                {
                    continue;
                }

                // Insert the Parent.
                itemInfoParent.mask = LVIF_TEXT | LVIF_PARAM;
                itemInfoParent.iItem = LVI_LAST;
                itemInfoParent.iSubItem = 0;
                itemInfoParent.lParam = 0;
                itemInfoParent.iImage = -1;

                itemInfoParent.pszText = pSyncMgrHandlerInfo->wszHandlerName;
		if (himage)
		{
		HICON hIcon = pSyncMgrHandlerInfo->hIcon ? pSyncMgrHandlerInfo->hIcon : pHandlerItem->hIcon;

                    // if have toplevel handler info icon use this else use the
		    // items icon

		    if (hIcon &&  (itemInfoParent.iImage = 
					ImageList_AddIcon(himage,hIcon)) )
		    {
                        itemInfoParent.mask |= LVIF_IMAGE ; 
		    }
		}

                // save the blob
                itemInfoParent.maskEx = LVIFEX_BLOB;
                itemInfoParent.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
    
                iParentItemId = m_pListView->InsertItem(&itemInfoParent);

                CoTaskMemFree(pSyncMgrHandlerInfo);

                // if parent insert failed go onto the next item
                if (-1 == iParentItemId)
                {
                    continue;
                }
            }
        }


	itemInfo.mask = LVIF_TEXT | LVIF_PARAM; 
        itemInfo.maskEx = LVIFEX_PARENT | LVIFEX_BLOB;
	itemInfo.iItem = LVI_LAST; 
	itemInfo.iSubItem = 0; 

        itemInfo.lParam = (LPARAM)pHandlerItem;
	itemInfo.pszText = pHandlerItem->wszItemName; 
	itemInfo.iImage = -1;       // index of the list view item?s icon 
	if (himage && pHandlerItem->hIcon)
	{
	    itemInfo.iImage = 
			    ImageList_AddIcon(himage,pHandlerItem->hIcon);

            itemInfo.mask |= LVIF_IMAGE; 

	}

        itemInfo.iParent = iParentItemId;

        // setup the blob
        lvHandlerItemBlob.ItemID = pHandlerItem->itemID;
        itemInfo.pBlob = (LPLVBLOB) &lvHandlerItemBlob;

	itemInfo.iItem = m_pListView->InsertItem(&itemInfo);

        if (-1 == itemInfo.iItem)
        {
            continue;
        }

	//Set the check state of the item
        itemInfo.mask = LVIF_STATE; 
        itemInfo.stateMask= LVIS_STATEIMAGEMASK; 

        if (fClear)
	{
	    itemInfo.state = LVIS_STATEIMAGEMASK_UNCHECK;
	    m_fItemsChanged = TRUE;
	}
        else
	{
	    itemInfo.state = pHandlerItem->dwCheckState == SYNCMGRITEMSTATE_UNCHECKED ?
					    LVIS_STATEIMAGEMASK_UNCHECK : LVIS_STATEIMAGEMASK_CHECK ;
        }


	m_pListView->SetItem(&itemInfo);

	pHandlerItem = (LPSYNC_HANDLER_ITEM_INFO) ALLOC(sizeof(SYNC_HANDLER_ITEM_INFO));

    }


    if (m_pListView->GetItemCount())
    {
        m_pListView->SetItemState(0,
                 LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }

    //free the last one we created, we didn't use it.
    if (pHandlerItem)
    {
        FREE(pHandlerItem);
    }
    
    pIEnum->Release();

    m_Initialized = TRUE;			

    if (m_pListView->GetCheckedItemsCount()) 
    {
	PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK | PSWIZB_NEXT);
    }
    else  
    {
	PropSheet_SetWizButtons(GetParent(m_hwnd), PSWIZB_BACK); 
    }
 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\callback.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Callback.h
//
//  Contents:   Callback implementation
//
//  Classes:    COfflineSychronizeCallback
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCCALLBACK_
#define _SYNCCALLBACK_

class CHndlrMsg;
class CThreadMsgProxy;


class COfflineSynchronizeCallback: public ISyncMgrSynchronizeCallback ,
                                   public IOldSyncMgrSynchronizeCallback, // OLD IDL
                                   CLockHandler
{
public:
    COfflineSynchronizeCallback(CHndlrMsg *pHndlrMsg,
                            CLSID CLSIDServer,DWORD dwSyncFlags,BOOL fAllowModeless);
    ~COfflineSynchronizeCallback();

    //IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // Callback methods.
    STDMETHODIMP Progress(REFSYNCMGRITEMID ItemID,LPSYNCMGRPROGRESSITEM lpSyncProgressItem);
    STDMETHODIMP PrepareForSyncCompleted(HRESULT hr);
    STDMETHODIMP SynchronizeCompleted(HRESULT hr);

    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP LogError(DWORD dwErrorLevel,const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError);
    STDMETHODIMP DeleteLogError(REFSYNCMGRERRORID ErrorID,DWORD dwReserved);
    STDMETHODIMP EstablishConnection( WCHAR const * lpwszConnection, DWORD dwReserved);

    // new callback methods
    STDMETHODIMP ShowPropertiesCompleted(HRESULT hr);
    STDMETHODIMP ShowErrorCompleted(HRESULT hr,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);


    // called by hndlrMsg
    void SetHndlrMsg(CHndlrMsg *pHndlrMsg,BOOL fForceKilled);
    void SetEnableModeless(BOOL fAllowModeless);

private:
    void CallCompletionRoutine(DWORD dwThreadMsg,HRESULT hCallResult,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);

    CHndlrMsg *m_pHndlrMsg;
    ULONG m_cRef;
    BOOL m_fSynchronizeCompleted;
    DWORD m_dwSyncFlags;
    BOOL m_fAllowModeless;
    BOOL m_fForceKilled;
    CLSID m_CLSIDServer;

};



#endif // _SYNCCALLBACK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\clsfact.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ClsFact.h
//
//  Contents:   OneStop ClassFactory
//
//  Classes:    CClassFactory
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _CLSFACT_
#define _CLSFACT_


//This class factory for OneStop EXE

class CClassFactory : public IClassFactory
{
protected:
	ULONG	m_cRef;

public:
	CClassFactory();
	~CClassFactory();

	//IUnknown members
	STDMETHODIMP		 QueryInterface( REFIID, LPVOID* );
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	//IClassFactory members
	STDMETHODIMP		CreateInstance( LPUNKNOWN, REFIID, LPVOID* );
	STDMETHODIMP		LockServer( BOOL );
};







#endif // _CLSFACT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\cmdline.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cmdline.cpp
//
//  Contents:   commandline helper routines.
//
//  Classes:    
//
//  Notes:      
//
//  History:    17-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::CCmdLine, public
//
//  Synopsis:  Constructor.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CCmdLine::CCmdLine()
{
    m_cmdLineFlags = 0;
    m_pszJobFile = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::~CCmdLine, public
//
//  Synopsis:  destructor.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    07-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CCmdLine::~CCmdLine()
{
    if (m_pszJobFile)
    {
        FREE(m_pszJobFile);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::ParseCommandLine, public
//
//  Synopsis:   Parses the command line passed to the Application
//		and Sets the member variables accordingly.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------


void CCmdLine::ParseCommandLine()
{
m_cmdLineFlags = 0;
char *lpszRemaining;

    // start at 1 -- the first is the exe
    for (int i=1; i< __argc; i++)
    {

 	if (MatchOption(__argv[i], "Embedding"))
	{
 	    m_cmdLineFlags |= CMDLINE_COMMAND_EMBEDDING;
	}
 	else if (MatchOption(__argv[i],"Register"))
	{
 	    m_cmdLineFlags |= CMDLINE_COMMAND_REGISTER;
	}
 	else if (MatchOption(__argv[i], "logon") )
	{
 	    m_cmdLineFlags |= CMDLINE_COMMAND_LOGON;
	}
 	else if (MatchOption(__argv[i],"logoff") )
	{
 	    m_cmdLineFlags |= CMDLINE_COMMAND_LOGOFF;
	}
 	else if (MatchOption(__argv[i],"DllRegisterServer") )
	{
 	    m_cmdLineFlags |= CMDLINE_COMMAND_REGISTER;
	}
 	else if (MatchOption(__argv[i],"Idle") )
	{

            // pretend idle is the idle schedule firing for this 
            // user so same code path is exceriside if command
            // line invoked or TS launched us.
            
             m_cmdLineFlags |= CMDLINE_COMMAND_SCHEDULE;

             // m_pszJobFile will be scheduleguid_UserName

              TCHAR szDomainUserName[MAX_DOMANDANDMACHINENAMESIZE];
              GetDefaultDomainAndUserName(szDomainUserName,TEXT("_"), MAX_DOMANDANDMACHINENAMESIZE);

              m_pszJobFile = (WCHAR *) ALLOC(
                                        ( lstrlen(WSZGUID_IDLESCHEDULE)  /* guid of schedule */
                                        + 1 /* space for separator */
                                        + lstrlen(szDomainUserName) /* space for domainUserNmae */
                                        + 1 /* space for NULL */
                                        ) * sizeof(WCHAR) );

              lstrcpy(m_pszJobFile,WSZGUID_IDLESCHEDULE);
              lstrcat(m_pszJobFile,TEXT("_"));
              lstrcat(m_pszJobFile,szDomainUserName);
            
	}
 	else if (MatchOption(__argv[i],"Schedule=",FALSE,&lpszRemaining))
	{
        ULONG ul_JobFileSize = 0;

            m_cmdLineFlags |= CMDLINE_COMMAND_SCHEDULE;
           
            // command lines are always in ANSI so convert jobname to WCHAR
            
            ul_JobFileSize = lstrlenA(lpszRemaining) + 1;
            m_pszJobFile = (WCHAR *) ALLOC(ul_JobFileSize*sizeof(WCHAR));

            // UP to Schedule method on invoke to handle if jobfile is null.
            if (m_pszJobFile)
            {
	        MultiByteToWideChar(CP_ACP ,0,
			        lpszRemaining,-1,m_pszJobFile,ul_JobFileSize);

            }

	}
	else
	{
	    AssertSz( i== 0,"Unknown Command Line"); // unkown command line
	}
    }
}





//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::MatchOption, private
//
//  Synopsis:   given a command line and an option determines if the command
//		line matches the option up until the end of the option text
//		if there is additional text after the option text a pointer
//		to it will be returned in lpRemaining, else lpRemaining wil
//		be set to NULL.
//
//		!!!CmdLine options always come in in ANSI
//
//  Arguments:  [lpsz] - command line value to match
//		[lpszOption] - Option string to match command line too.
//		[fExactMatch] - when true, the command line must contain the same
//				number of characters as the Option (i.e.) There shouldn't
//				be any remaining characters
//		[lpszRemaining] - Points to any remaining part of the command after the match
//
//  Returns:    
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CCmdLine::MatchOption(LPSTR lpsz, LPSTR lpszOption,BOOL fExactMatch,LPSTR *lpszRemaining)
{

    if (lpszRemaining)
	*lpszRemaining = '\0';

    if (lpsz[0] == TEXT('-') || lpsz[0] == TEXT('/'))
    {
    int nRet = 0;

	lpsz++;

       while (! (nRet = toupper(*lpsz)
			- toupper(*lpszOption)) &&
	      *lpsz)
       {
	  lpsz++;
	  lpszOption++;
       }

       if (*lpszOption || (*lpsz && fExactMatch) )
	   return FALSE;

       if (lpszRemaining)
	 *lpszRemaining = lpsz;

       return(TRUE);
    }

    return FALSE;
}




//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::MatchOption, private
//
//  Synopsis:   given a command line and an option determines if the command
//		line matches exactly matches the option 
//
//  Arguments:  [lpsz] - command line value to match
//		[lpszOption] - Option string to match command line too.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CCmdLine::MatchOption(LPSTR lpsz, LPSTR lpszOption)
{
    return MatchOption(lpsz,lpszOption,TRUE /* fExactmatch */ ,NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCmdLine::strnicmp, private
//
//  Synopsis:   internal implimentation of strnicmp so don't need
//              the runtime.
//
//  Arguments:  [lpsz] - command line value to match
//		[lpszOption] - Option string to match command line too.
//              [count] - number of characters to compare.
//
//  Returns:    standard strnicmp values.
//
//  Modifies:   
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

int  CCmdLine::strnicmp(LPWSTR lpsz, LPWSTR lpszOption,size_t count)
{
int nRet = 0;

   while (count-- && 
           !(nRet = toupper(*lpsz)
		    - toupper(*lpszOption)) &&
	  *lpsz)
   {
      lpsz++;
      lpszOption++;
   }

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\clsfact.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Clsfact.cpp
//
//  Contents:   Class Factory
//
//  Classes:    CClassFactory
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::CClassFactory, public
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CClassFactory::CClassFactory()
{
	m_cRef = 1;
	return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::~CClassFactory, public
//
//  Synopsis:   Destructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CClassFactory::~CClassFactory( void )
{
    
    Assert(0 == m_cRef);
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface( REFIID riid, LPVOID* ppv )
{
    *ppv = NULL;

    if( IsEqualIID( riid, IID_IUnknown ) || IsEqualIID( riid, IID_IClassFactory ) )
    {
	*ppv = (LPVOID)this;
	AddRef();
	return NOERROR;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:	CClassFactory::AddRef, public
//
//  Synopsis:	Add reference
//
//  History:	05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
ULONG cRefs;

    cRefs = InterlockedIncrement((LONG *)& m_cRef);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:	CClasFactory::Release, public
//
//  Synopsis:	Release reference
//
//  History:	05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (0 == cRefs)
    {
	delete this;
    }

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::CreateInstance, public
//
//  Synopsis:   Creates and instance of the requested object 
//
//  Arguments:  [pUnkOuter] - Controlling unknown
//		[riid] - Requested interface
//		[ppvObj] - object pointer
//
//  Returns:    Appropriate status code
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CClassFactory::CreateInstance( LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR *ppvObj )
{
HRESULT		hr = E_OUTOFMEMORY;
CSynchronizeInvoke *pNewSynchronizeInstance;

    *ppvObj = NULL;

    // We don't support aggregation at all.
    if( pUnkOuter )
    {
	return CLASS_E_NOAGGREGATION;
    }

    //Create the object, passing function to notify on destruction
    pNewSynchronizeInstance = new CSynchronizeInvoke(); // initialized RefCount to 1.

    if( NULL == pNewSynchronizeInstance )
    {
	return hr;
    }

    hr = pNewSynchronizeInstance->QueryInterface( riid, ppvObj );
    pNewSynchronizeInstance->Release(); // release our copy of the object

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::LockServer, public
//
//  Synopsis:   Locks the Server
//
//  Arguments:  [fLock] - To Lock or Unlock
//
//  Returns:    Appropriate status code
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer( BOOL fLock )
{
    if( fLock )
    {
	AddRefOneStopLifetime(TRUE /*External*/);
    }
    else
    {
	ReleaseOneStopLifetime(TRUE /*External*/);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\cmdline.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cmdline.h
//
//  Contents:   Helper class for parsing the Command Line.
//
//  Classes:    
//
//  Notes:      
//
//  History:    17-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _CMDLINEHELPER_
#define _CMDLINEHELPER_

typedef enum _tagCMDLINE_COMMAND   
{	
    CMDLINE_COMMAND_EMBEDDING			= 0x01, // embedding flag was passed in
    CMDLINE_COMMAND_REGISTER			= 0x02, // register flag was passed in
    CMDLINE_COMMAND_LOGON			= 0x04, // logon flag was passed in
    CMDLINE_COMMAND_LOGOFF			= 0x08, // logon flag was passed in
    CMDLINE_COMMAND_SCHEDULE			= 0x10, // schedule flag was passed in
    CMDLINE_COMMAND_IDLE			= 0x20, // Idle flag was passed in
} CMDLINE_COMMAND;


class CCmdLine {

public:
    CCmdLine();
    ~CCmdLine();
    void ParseCommandLine();
    inline DWORD GetCmdLineFlags() { return m_cmdLineFlags; };
    WCHAR* GetJobFile() { return m_pszJobFile; };

private:
    BOOL MatchOption(LPSTR lpsz, LPSTR lpszOption);
    BOOL MatchOption(LPSTR lpsz, LPSTR lpszOption,BOOL fExactMatch,LPSTR *lpszRemaining);
    int  strnicmp(LPWSTR lpsz, LPWSTR lpszOption,size_t count);

    DWORD m_cmdLineFlags;
    WCHAR *m_pszJobFile;
	
};





#endif // _CMDLINEHELPER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\connobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ConnObj.h
//
//  Contents:   ConnectionObject Implementation
//
//  Classes:    CCConnectObj
//
//  Notes:
//
//  History:    10-Feb-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCMGRCONNECTIONOBJ_
#define SYNCMGRCONNECTIONOBJ_

class CBaseDlg;

typedef struct _CONNECTIONOBJ {
    struct _CONNECTIONOBJ *pNextConnectionObj;
    DWORD cRefs;
    LPWSTR  pwszConnectionName; // pointer to the connection name.
    DWORD dwConnectionType; // connection type as defined by CNetApi class
    BOOL fConnectionOpen; // flag set when connection has been established.
    DWORD dwConnectionId; // Connection Id returned from InternetDial.
    HANDLE   hCompletionEvent;  // set by clients who want to be informed when connection
                                // has been closed.
} CONNECTIONOBJ;


class CConnectionObj : CLockHandler
{
public:
    CConnectionObj();

    HRESULT OpenConnection(CONNECTIONOBJ *pConnectionObj,BOOL fMakeConnection,CBaseDlg *pDlg);
    HRESULT AutoDial(DWORD dwFlags,CBaseDlg *pDlg); // same flags as InternetAutoDial takes
    HRESULT SetWorkOffline(BOOL fWorkOffline); 
    HRESULT CloseConnections();
    HRESULT CloseConnection(CONNECTIONOBJ *pConnectionObj);
    HRESULT FindConnectionObj(LPCWSTR pszConnectionName,BOOL fCreate,CONNECTIONOBJ **pConnectionObj);
    DWORD ReleaseConnectionObj(CONNECTIONOBJ *pConnectionObj);
    DWORD AddRefConnectionObj(CONNECTIONOBJ *pConnectionObj);
    HRESULT GetConnectionObjCompletionEvent(CONNECTIONOBJ *pConnectionObj,HANDLE *phRasPendingEvent);
    HRESULT IsConnectionAvailable(LPCWSTR pszConnectionName);

private:
    void LogError(LPNETAPI pNetApi,DWORD dwErr,CBaseDlg *pDlg);
    void RemoveConnectionObj(CONNECTIONOBJ *pConnectionObj);
    void FreeConnectionObj(CONNECTIONOBJ *pConnectionObj);
    void TurnOffWorkOffline(LPNETAPI pNetApi);
    void RestoreWorkOffline(LPNETAPI pNetApi);


    CONNECTIONOBJ *m_pFirstConnectionObj; // pointer to first connection object in list.
    BOOL           m_fAutoDialConn;       // Was an auto dial connection set up ?
    DWORD          m_dwAutoConnID;    
    BOOL           m_fForcedOnline; // set to true if had to transition from WorkOffline to dial
};


HRESULT InitConnectionObjects();
HRESULT ReleaseConnectionObjects();

// wrapper functions for class
HRESULT ConnectObj_OpenConnection(CONNECTIONOBJ *pConnectionObj,BOOL fMakeConnection,CBaseDlg *pDlg);
HRESULT ConnectObj_CloseConnection(CONNECTIONOBJ *pConnectionObj);
HRESULT ConnectObj_CloseConnections();
HRESULT ConnectObj_FindConnectionObj(LPCWSTR pszConnectionName,BOOL fCreate,CONNECTIONOBJ **pConnectionObj);
DWORD ConnectObj_ReleaseConnectionObj(CONNECTIONOBJ *pConnectionObj);
DWORD ConnectObj_AddRefConnectionObj(CONNECTIONOBJ *pConnectionObj);
HRESULT ConnectObj_GetConnectionObjCompletionEvent(CONNECTIONOBJ *pConnectionObj,HANDLE *phRasPendingEvent);
HRESULT ConnectObj_AutoDial(DWORD dwFlags,CBaseDlg *pDlg);
HRESULT ConnectObj_IsConnectionAvailable(LPCWSTR pszConnectionName);
HRESULT ConnectObj_SetWorkOffline(BOOL fWorkOffline);

#endif // SYNCMGRCONNECTIONOBJ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\guid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       guid.c
//
//  Contents:   Defines GUIDS
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#pragma data_seg(".text")
#define INITGUID
#include <objbase.h>
#include <initguid.h>


#include "mobsync.h"
#include "mobsyncp.h"
#include "osdefine.h"
#include "debug.h"

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\dlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Dlg.cpp
//
//  Contents:   common dialog routines.
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE g_hInst;      // current instance

//+---------------------------------------------------------------------------
//
//  function:     AddItemsFromQueueToListView, private
//
//  Synopsis:   Adds the items in the Queue to the ListView.
//
//  Arguments:  
//              int iDateColumn,int iStatusColumn - if these are >= zero
//              means the Column is Valid and the proper data is initialized.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------


BOOL AddItemsFromQueueToListView(CListView  *pItemListView,CHndlrQueue *pHndlrQueue
                            ,DWORD dwExtStyle,LPARAM lparam,int iDateColumn,int iStatusColumn,BOOL fHandlerParent
                            ,BOOL fAddOnlyCheckedItems)
{
WORD wItemID;
HIMAGELIST himageSmallIcon;
HANDLERINFO *pHandlerId;
WCHAR wszStatusText[MAX_STRING_RES];
DWORD dwDateReadingFlags;

    dwDateReadingFlags = GetDateFormatReadingFlags(pItemListView->GetHwnd());

    *wszStatusText = NULL;

    if (!pItemListView)
    {
        Assert(pItemListView);
        return FALSE;
    }

    if (!pHndlrQueue)
    {
        Assert(pHndlrQueue);
        return FALSE;
    }

    pItemListView->SetExtendedListViewStyle(dwExtStyle);

    // not an error to not get the small Icon, just won't have icons.
    himageSmallIcon = pItemListView->GetImageList(LVSIL_SMALL );

    pHandlerId = 0;;
    wItemID = 0;

    // loop through queue finding any 
    while (NOERROR ==  pHndlrQueue->FindNextItemInState(HANDLERSTATE_PREPAREFORSYNC,
                            pHandlerId,wItemID,&pHandlerId,&wItemID))
    {
    INT iListViewItem;
    CLSID clsidDataHandler;
    SYNCMGRITEM offlineItem;
    BOOL fHiddenItem;
    LVITEMEX lvItemInfo; // structure to pass into ListView Calls


	// grab the offline item info. 
	if (NOERROR == pHndlrQueue->GetItemDataAtIndex(pHandlerId,wItemID,
				    &clsidDataHandler,&offlineItem,&fHiddenItem))
	{
        LVHANDLERITEMBLOB lvHandlerItemBlob;
        int iParentItemId;

            // if the item is hidden don't show it in the UI
            if (fHiddenItem)
            {
                continue;
            }

            // if only add checked items and this one isn't continue on
            if (fAddOnlyCheckedItems && (SYNCMGRITEMSTATE_CHECKED != offlineItem.dwItemState))
            {
                continue;
            }



            // Check if item is already in the ListView and if so
            // go on

            lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
            lvHandlerItemBlob.clsidServer = clsidDataHandler;
            lvHandlerItemBlob.ItemID = offlineItem.ItemID;
            
            if (-1 != pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob))
            {
                // already in ListView, go on to the next item.
                continue;
            }


            if (!fHandlerParent)
            {
                iParentItemId = LVI_ROOT;
            }
            else
            {
                // need to add to list so find parent and if one doesn't exist, create it.
                lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
                lvHandlerItemBlob.clsidServer = clsidDataHandler;
                lvHandlerItemBlob.ItemID = GUID_NULL;

                iParentItemId = pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);

                if (-1 == iParentItemId)
                {
                LVITEMEX itemInfoParent;
                SYNCMGRHANDLERINFO SyncMgrHandlerInfo;

                    // if can't get the ParentInfo then don't add the Item
                    if (NOERROR != pHndlrQueue->GetHandlerInfo(clsidDataHandler,&SyncMgrHandlerInfo))
                    {
                        continue;
                    }

                    // Insert the Parent.
                    itemInfoParent.mask = LVIF_TEXT;
                    itemInfoParent.iItem = LVI_LAST;;
                    itemInfoParent.iSubItem = 0;
                    itemInfoParent.iImage = -1;
    
                    itemInfoParent.pszText = SyncMgrHandlerInfo.wszHandlerName;
		    if (himageSmallIcon)
		    {
		    HICON hIcon = SyncMgrHandlerInfo.hIcon ? SyncMgrHandlerInfo.hIcon : offlineItem.hIcon;

                        // if have toplevel handler info icon use this else use the
		        // items icon

		        if (hIcon &&  (itemInfoParent.iImage = 
					    ImageList_AddIcon(himageSmallIcon,hIcon)) )
		        {
                            itemInfoParent.mask |= LVIF_IMAGE ; 
		        }
		    }

                    // save the blob
                    itemInfoParent.maskEx = LVIFEX_BLOB;
                    itemInfoParent.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
            
                    iParentItemId = pItemListView->InsertItem(&itemInfoParent);

                    // if parent insert failed go onto the next item
                    if (-1 == iParentItemId)
                    {
                        continue;
                    }
                }
            }

            
            // now attemp to insert the item.
	    lvItemInfo.mask = LVIF_TEXT | LVIF_PARAM; 
            lvItemInfo.maskEx = LVIFEX_PARENT | LVIFEX_BLOB; 

            lvItemInfo.iItem = LVI_LAST;
	    lvItemInfo.iSubItem = 0; 
            lvItemInfo.iParent = iParentItemId;
            

	    lvItemInfo.pszText = offlineItem.wszItemName; 
            lvItemInfo.iImage = -1; // set to -1 in case can't get image.
            lvItemInfo.lParam = lparam;

	    if (himageSmallIcon && offlineItem.hIcon)
	    {
		    lvItemInfo.iImage = 
				    ImageList_AddIcon(himageSmallIcon,offlineItem.hIcon);

                    lvItemInfo.mask |= LVIF_IMAGE ; 
	    }

            // setup the blob
            lvHandlerItemBlob.ItemID = offlineItem.ItemID;
            lvItemInfo.pBlob = (LPLVBLOB) &lvHandlerItemBlob;


	    iListViewItem = lvItemInfo.iItem = pItemListView->InsertItem(&lvItemInfo);

            if (-1 == iListViewItem)
            {
                continue;
            }

            // if the item has a date column insert it and the item
            // has a last update time.
            if (iDateColumn  >= 0 && (offlineItem.dwFlags & SYNCMGRITEM_LASTUPDATETIME))
            {
            SYSTEMTIME sysTime;
            FILETIME filetime;
            WCHAR DateTime[256];  
            LPWSTR pDateTime = DateTime;
            int cchWritten;


                lvItemInfo.mask = LVIF_TEXT;
                lvItemInfo.iSubItem = iDateColumn;
                lvItemInfo.maskEx = 0; 

                FileTimeToLocalFileTime(&(offlineItem.ftLastUpdate),&filetime);
                FileTimeToSystemTime(&filetime,&sysTime);

                // insert date in form of date<space>hour
                *DateTime = NULL; 

                // want to insert the date
                if (cchWritten = GetDateFormat(NULL,DATE_SHORTDATE | dwDateReadingFlags,&sysTime,NULL,pDateTime,ARRAY_SIZE(DateTime)))
                {
                    pDateTime += (cchWritten -1); // move number of characters written. (cchWritten includes the NULL)
                    *pDateTime = TEXT(' '); // pDateTime is now ponting at the NULL character.
                    ++pDateTime;
                
                   // if left to right add the LRM
                    if (DATE_LTRREADING & dwDateReadingFlags)
                    {
                        *pDateTime = LRM;
                        ++pDateTime;
                    }

                    // no try to get the hours if fails we make sure that the last char is NULL;
                    if (!GetTimeFormat(NULL,TIME_NOSECONDS,&sysTime,NULL,pDateTime,ARRAY_SIZE(DateTime) - cchWritten))
                    {
                        *pDateTime = NULL;
                    }
                }

                lvItemInfo.pszText = DateTime;

		pItemListView->SetItem(&lvItemInfo); // if fail, then just don't have any date.
            }

            if (iStatusColumn >= 0)
            {

                lvItemInfo.iSubItem = iStatusColumn;
                lvItemInfo.maskEx = 0; 

                lvItemInfo.mask = LVIF_TEXT;

                if (NULL == *wszStatusText)
                {
                    LoadString(g_hInst, IDS_PENDING,wszStatusText, MAX_STRING_RES);
                }

                lvItemInfo.pszText = wszStatusText;

                pItemListView->SetItem(&lvItemInfo); // if fail, then just don't have any date.

            }


            // if the listbox has checkBoxes then set the CheckState accordingly
            if (LVS_EX_CHECKBOXES & dwExtStyle)
            {

                if (SYNCMGRITEMSTATE_CHECKED == offlineItem.dwItemState)
		{
			lvItemInfo.state = LVIS_STATEIMAGEMASK_CHECK;
		}
		else
		{
			lvItemInfo.state = LVIS_STATEIMAGEMASK_UNCHECK;
		}

                // if LVS_EX_CHECKBOXES set then setup the CheckBox State

                // setitem State, must do after insert
                pItemListView->SetItemState(iListViewItem,lvItemInfo.state,LVIS_STATEIMAGEMASK);
            }

        }
	    
    }

    // now loop through to see if any handlers that want to always show but don't
    // yet have any items have been added

    if (fHandlerParent)
    {
    LVHANDLERITEMBLOB lvHandlerItemBlob;
    int iParentItemId;
    HANDLERINFO *pHandlerID = 0;
    CLSID clsidDataHandler;

        while (NOERROR == pHndlrQueue->FindNextHandlerInState(pHandlerID,
                            GUID_NULL,HANDLERSTATE_PREPAREFORSYNC,&pHandlerID
                            ,&clsidDataHandler))
        {
        SYNCMGRHANDLERINFO SyncMgrHandlerInfo;

            // if can't get the ParentInfo then don't add.
            if (NOERROR != pHndlrQueue->GetHandlerInfo(clsidDataHandler,&SyncMgrHandlerInfo))
            {
                continue;
            }

            // only add if handler says too
            if (!(SYNCMGRHANDLER_ALWAYSLISTHANDLER & 
                            SyncMgrHandlerInfo.SyncMgrHandlerFlags))
            {
                continue;
            }

            // need to add to list so find parent and if one doesn't exist, create it.
            lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
            lvHandlerItemBlob.clsidServer = clsidDataHandler;
            lvHandlerItemBlob.ItemID = GUID_NULL;

            iParentItemId = pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);

            if (-1 == iParentItemId)
            {
            LVITEMEX itemInfoParent;


                // Insert the Parent.
                itemInfoParent.mask = LVIF_TEXT;
                itemInfoParent.iItem = LVI_LAST;;
                itemInfoParent.iSubItem = 0;
                itemInfoParent.iImage = -1;

                itemInfoParent.pszText = SyncMgrHandlerInfo.wszHandlerName;
	        if (himageSmallIcon)
	        {
	        HICON hIcon = SyncMgrHandlerInfo.hIcon ? SyncMgrHandlerInfo.hIcon : NULL;

                    // if have toplevel handler info icon use this else use the
		    // items icon

		    if (hIcon &&  (itemInfoParent.iImage = 
				        ImageList_AddIcon(himageSmallIcon,hIcon)) )
		    {
                        itemInfoParent.mask |= LVIF_IMAGE ; 
		    }
	        }

                // save the blob
                itemInfoParent.maskEx = LVIFEX_BLOB;
                itemInfoParent.pBlob = (LPLVBLOB) &lvHandlerItemBlob;
    
                iParentItemId = pItemListView->InsertItem(&itemInfoParent);
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\connobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      connobj.cpp
//
//  Contents:   ConnectionObject Implementation
//
//  Classes:    CCConnectObj
//
//  Notes:      Purpose is to globally keep track of Connections
//              for a SyncMgr instance. and Open and Close Connections
//              abstracted from LAN or RAS.
//
//  History:    10-Feb-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"


extern HINSTANCE g_hInst;      // current instance

CConnectionObj *g_pConnectionObj = NULL; // global pointer to ConnectionObject.

//+---------------------------------------------------------------------------
//
//  Member:     InitConnectionObjects, public
//
//  Synopsis:   Must be called to initialize the ConnectionObjects
//              before any other functions are called.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT InitConnectionObjects()
{
    g_pConnectionObj = new CConnectionObj;

    return g_pConnectionObj ? NOERROR : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     ReleaseConnectionObjects, public
//
//  Synopsis:   Called to Release the Connection Objects
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ReleaseConnectionObjects()
{
    if (g_pConnectionObj)
    {
        delete g_pConnectionObj;
        g_pConnectionObj = NULL;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::CConnectionObj, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CConnectionObj::CConnectionObj()
   :  m_pFirstConnectionObj(NULL),
      m_fAutoDialConn(FALSE),
      m_fForcedOnline(FALSE)
{
}



//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::FindConnectionObj, public
//
//  Synopsis:   Sees if there is an existing Connection object for this
//              Item and if there is incremements the refcount. If one
//              isn't found and fCreate is true a new one is allocated
//              and added to the list.
//
//  Arguments:  [pszConnectionName] - Name of the Connection.
//              [fCreate] - Create a New Connection if one doesn't already exist
///             [pConnectionOb] - OutParam pointer to newly created connectionObj
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::FindConnectionObj(LPCWSTR pszConnectionName,
                           BOOL fCreate,CONNECTIONOBJ **pConnectionObj)
{
HRESULT hr = S_FALSE;
CONNECTIONOBJ *pCurConnectionObj;
BOOL fFoundMatch = FALSE;
CLock clockqueue(this);
TCHAR szBuf[MAX_PATH + 1];

    *pConnectionObj = NULL;

    Assert(pszConnectionName);

    clockqueue.Enter();

    // look for an existing match
    pCurConnectionObj = m_pFirstConnectionObj;

    while (pCurConnectionObj)
    {
        if (0 == lstrcmp(pszConnectionName,pCurConnectionObj->pwszConnectionName))
        {
            fFoundMatch = TRUE;
            break;
        }

        pCurConnectionObj = pCurConnectionObj->pNextConnectionObj;
    }


    if (fFoundMatch)
    {
        ++(pCurConnectionObj->cRefs);
        *pConnectionObj = pCurConnectionObj;
        hr = NOERROR;

    }
    else if (fCreate)
    {
    CONNECTIONOBJ *pNewConnectionObj;

        // if we need to create a new connectionObj then
        pNewConnectionObj = (CONNECTIONOBJ *) ALLOC(sizeof(CONNECTIONOBJ));
        if (pNewConnectionObj)
        {
            memset(pNewConnectionObj,0,sizeof(CONNECTIONOBJ));
            pNewConnectionObj->cRefs = 1;

            Assert(pszConnectionName);

            // setup the Connectoin Name
            if (pszConnectionName)
            {
            DWORD cch = lstrlen(pszConnectionName);
            DWORD cbAlloc = (cch + 1)*ARRAY_ELEMENT_SIZE(pNewConnectionObj->pwszConnectionName);

                pNewConnectionObj->pwszConnectionName = (LPWSTR) ALLOC(cbAlloc);

                if (pNewConnectionObj->pwszConnectionName)
                {
                    lstrcpy(pNewConnectionObj->pwszConnectionName,pszConnectionName);
                }
            }

            // for now if the name of the connection is our
            // LAN connection name then set the ConnectionType to LAN,
            // else set it to WAN. if convert to using hte connection
            // manager should get from that.

            LoadString(g_hInst, IDS_LAN_CONNECTION, szBuf, MAX_PATH);

            if (NULL == pszConnectionName || 0 == lstrcmp(szBuf,pszConnectionName))
            {
                pNewConnectionObj->dwConnectionType = CNETAPI_CONNECTIONTYPELAN;
            }
            else
            {
                pNewConnectionObj->dwConnectionType = CNETAPI_CONNECTIONTYPEWAN;
            }
        }

        // if everything went okay, add it to the list.
        // must have a new connection obj and either not connection name
        // was passed in or we successfully added a connection name.
        if (pNewConnectionObj && (NULL == pszConnectionName
                || pNewConnectionObj->pwszConnectionName) )
        {
            // put at beginning of list
            pNewConnectionObj->pNextConnectionObj = m_pFirstConnectionObj;
            m_pFirstConnectionObj = pNewConnectionObj;

            *pConnectionObj = pNewConnectionObj;
            hr = NOERROR;
        }
        else
        {
            if (pNewConnectionObj)
            {
                FreeConnectionObj(pNewConnectionObj);
            }
        }

    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::RemoveConnectionObj, public
//
//  Synopsis:   Removes the specified connections from the list.
//
//  Arguments:  [pszConnectionName] - Name of the Connection.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::RemoveConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
CONNECTIONOBJ *pCurConnection = m_pFirstConnectionObj;

    ASSERT_LOCKHELD(this);

    // remove from the list
    if (m_pFirstConnectionObj == pConnectionObj)
    {
        m_pFirstConnectionObj = pConnectionObj->pNextConnectionObj;
    }
    else
    {
        while (pCurConnection)
        {

            if (pCurConnection->pNextConnectionObj == pConnectionObj)
            {
                pCurConnection->pNextConnectionObj = pConnectionObj->pNextConnectionObj;
                break;
            }

            pCurConnection = pCurConnection->pNextConnectionObj;
        }
    }


    FreeConnectionObj(pConnectionObj);

}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::FreeConnectionObj, privte
//
//  Synopsis:   frees the memory associate with a conneciton Object.
//
//  Arguments:  
//
//  Returns:    nada
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::FreeConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    Assert(pConnectionObj);

    if (pConnectionObj)
    {
        if (pConnectionObj->pwszConnectionName)
        {
            FREE(pConnectionObj->pwszConnectionName);
        }

        FREE(pConnectionObj);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::IsConnectionAvailable, public
//
//  Synopsis:   Given a connection name sees if the connection is open
//
//  Arguments:
//
//  Returns:    S_OK - Connection Open
//              S_FALSE - Connection not Open
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::IsConnectionAvailable(LPCWSTR pszConnectionName)
{
TCHAR szBuf[MAX_PATH + 1];
DWORD dwConnectionType;
LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();
HRESULT hr = S_FALSE;

    if (NULL != pNetApi )
    {
    BOOL fConnected,fCanEstablishConnection;

        // for now if the name of the connection is our
        // LAN connection name then set the ConnectionType to LAN,
        // else set it to WAN. if convert to Connection Manager
        // should get type from those interfaces.
        LoadString(g_hInst, IDS_LAN_CONNECTION, szBuf, MAX_PATH);

        if (NULL == pszConnectionName || 0 == lstrcmp(szBuf,pszConnectionName))
        {
            dwConnectionType = CNETAPI_CONNECTIONTYPELAN;
        }
        else
        {
            dwConnectionType = CNETAPI_CONNECTIONTYPEWAN;
        }


        pNetApi->GetConnectionStatus(pszConnectionName,dwConnectionType,
                                       &fConnected,&fCanEstablishConnection);
        pNetApi->Release();

        hr = (fConnected) ? S_OK: S_FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::RestoreWorkOffline, private
//
//  Synopsis:   If have force an online because of a dial then
//              set system state back to Work Offline.
//
//  Arguments:
//
//  Returns:   
//
//  Modifies:
//
//  History:    05-Apr-99      rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::RestoreWorkOffline(LPNETAPI pNetApi)
{
    if (!pNetApi)
    {
        Assert(pNetApi);
        return;
    }

    if (m_fForcedOnline)
    {
       pNetApi->SetOffline(TRUE);
       m_fForcedOnline = FALSE;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::TurnOffWorkOffline, private
//
//  Synopsis:   If System is in WorkOffline state will force
//              back to online.
//
//  Arguments:
//
//  Returns:   
//
//  Modifies:
//
//  History:    05-Apr-99      rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::TurnOffWorkOffline(LPNETAPI pNetApi)
{
    if (!pNetApi)
    {
        Assert(pNetApi);
        return;
    }

    if (pNetApi->IsGlobalOffline())
    {
        // if in offline state go ahead and switch to online
        if (pNetApi->SetOffline(FALSE))
        {
            m_fForcedOnline = TRUE;
        }

    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::OpenConnection, public
//
//  Synopsis:   Given a connection sees if the connection is open
//              and if it not and the fMakeConnection is true
//              will then attempt to open the connection.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------
HRESULT CConnectionObj::OpenConnection(CONNECTIONOBJ *pConnectionObj,BOOL fMakeConnection,CBaseDlg *pDlg)
{

#ifndef _RASDIAL
DWORD dwConnectionId;
#else
HRASCONN hRasConn;
#endif // _RASDIAL

LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();
BOOL fConnected = FALSE;
BOOL fCanEstablishConnection = FALSE;

    if (NULL != pNetApi )
    {

        // See if the specified connection is active and if there is any
        // Wan Activity.

        Assert(pConnectionObj->dwConnectionType); // should have a connection type setup by now.
        if (NOERROR == pNetApi->GetConnectionStatus(pConnectionObj->pwszConnectionName,
                                                    pConnectionObj->dwConnectionType,
                                                        &fConnected,
                                                        &fCanEstablishConnection))
        {
            // if there is no Wan Activity and there is not a connection
            // then we can go ahead try to dial
            if (!fConnected && fCanEstablishConnection
                    && fMakeConnection && (pConnectionObj->pwszConnectionName))
            {
            DWORD dwErr;
            
                TurnOffWorkOffline(pNetApi);

                dwErr = pNetApi->InternetDialW(pDlg ? pDlg->GetHwnd() : NULL,
                                pConnectionObj->pwszConnectionName,
                                INTERNET_AUTODIAL_FORCE_ONLINE |INTERNET_AUTODIAL_FORCE_UNATTENDED,
                                &dwConnectionId,0);

                if (0  == dwErr)
                {
                    fConnected = TRUE;
                    pConnectionObj->dwConnectionId = dwConnectionId;
                }
                else 
                {

                    dwConnectionId = 0;

                    if (pDlg)
                    {
                        LogError(pNetApi,dwErr,pDlg);
                    }
                }

            }
        }

    }

    if (pNetApi)
        pNetApi->Release();

    // review, don't handle all failure cases for Scheduling such as LAN connection
    // not available or not allowed to make connection on RAS.
    pConnectionObj->fConnectionOpen = fConnected;

    return pConnectionObj->fConnectionOpen ? NOERROR : S_FALSE;
}




//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::AutoDial
//
//  Synopsis:   Dials the default auto dial connection
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------
HRESULT CConnectionObj::AutoDial(DWORD dwFlags,CBaseDlg *pDlg)
{
HRESULT hr = NOERROR;
DWORD dwErr = -1;
LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    // only allow one autodial at a time.
    if (m_fAutoDialConn)
    {
        return NOERROR;
    }

    if ( NULL == pNetApi )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {

        TurnOffWorkOffline(pNetApi);

        // if flags are force unattended then call InternetAutoDial
        // if should prompt user call InternetDial without
        // a connectoid to bringup choice
        if (dwFlags & INTERNET_AUTODIAL_FORCE_UNATTENDED)
        {

            BOOL fOk = pNetApi->InternetAutodial(dwFlags,0);
            if ( fOk )
            {
                m_fAutoDialConn = TRUE;
                m_dwAutoConnID = 0;
                dwErr = 0;
            }
            else
            {
                dwErr = GetLastError();
            }
        }
        else
        {
        DWORD dwConnectionId;

            dwErr = pNetApi->InternetDialW(pDlg ? pDlg->GetHwnd() : NULL,
                    NULL,
                    INTERNET_AUTODIAL_FORCE_ONLINE,
                    &dwConnectionId,0);

            if (0  == dwErr)
            {
                m_fAutoDialConn = TRUE;
                m_dwAutoConnID = dwConnectionId;
            }
        }

        // if an error occured then log it.
        if (0 != dwErr)
        {
            if (pDlg)
            {
                 LogError(pNetApi,dwErr,pDlg);
            }
        }

        hr = m_fAutoDialConn ? NOERROR : E_UNEXPECTED;
    }

    if ( pNetApi != NULL )
    {
        pNetApi->Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::AutoDial
//
//  Synopsis:   turns on or off work offline
//
//  History:    14-April-99       rogerg        Created
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::SetWorkOffline(BOOL fWorkOffline)
{
LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    if (NULL == pNetApi)
    {
        return E_OUTOFMEMORY;
    }

    if (fWorkOffline)
    {
        RestoreWorkOffline(pNetApi); // Note: only sets back to workOffline if we turned it off.
    }
    else
    {
        TurnOffWorkOffline(pNetApi);
    }

    pNetApi->Release(); 

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::LogError, private
//
//  Synopsis: Logs the dwErr to the dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-Mar-99 rogerg        Created.
//
//----------------------------------------------------------------------------

void CConnectionObj::LogError(LPNETAPI pNetApi,DWORD dwErr,CBaseDlg *pDlg)
{
BOOL fErrorString= FALSE;
WCHAR wszErrorString[RASERROR_MAXSTRING];
DWORD dwErrorStringLen = sizeof(wszErrorString)/sizeof(WCHAR);
MSGLogErrors msgLogError;

    // don't log if success or no dialog
    if (NULL == pDlg || 0 == dwErr)
    {
        Assert(0 != dwErr);
        Assert(NULL != pDlg);
        return;
    }


    // print out an error message if it falls within the range of RAS then
    // get the raserror, else if a Win32 message get that, if -1 means the dll
    // failed to load so use the unknown error.

    if (dwErr >= RASBASE && dwErr <=  RASBASEEND)
    {
        if (NOERROR ==
            pNetApi->RasGetErrorStringProc(dwErr,wszErrorString,dwErrorStringLen) )
        {
            fErrorString = TRUE;
        }
    }
    else if (-1 != dwErr) // try formatMessage
    {
         if (FormatMessage(
                      FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL,
                      dwErr,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
                      wszErrorString,
                      dwErrorStringLen,
                      NULL))
         {
             fErrorString = TRUE;
         }
    }


    if (FALSE == fErrorString)
    {
        // just use the generic error.
        if (LoadString(g_hInst, IDS_UNDEFINED_ERROR,wszErrorString,dwErrorStringLen))
        {
            fErrorString = TRUE;
        }
    }


    if (fErrorString)
    {

        msgLogError.mask = 0;
        msgLogError.dwErrorLevel = SYNCMGRLOGLEVEL_ERROR;
        msgLogError.lpcErrorText = wszErrorString;
        msgLogError.ErrorID = GUID_NULL;
        msgLogError.fHasErrorJumps = FALSE;

        pDlg->HandleLogError(NULL,0,&msgLogError);
    }

}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::CloseConnection, public
//
//  Synopsis:   closes the specified connection.
//          Not an error if can't find Connection obj since under error
//          conditions we still want to call this to clean up, object
//          may or may not exist.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::CloseConnection(CONNECTIONOBJ *pConnectionObj)
{
CLock clockqueue(this);
CONNECTIONOBJ FirstConnectObj;
CONNECTIONOBJ *pCurConnection = &FirstConnectObj;

    clockqueue.Enter();

    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    pCurConnection->pNextConnectionObj = m_pFirstConnectionObj;

    while (pCurConnection->pNextConnectionObj)
    {
    CONNECTIONOBJ *pConnection = pCurConnection->pNextConnectionObj;

        // if the connection is equal to what was passed in, then
        // close it out.

        if (pConnection
                == pConnectionObj)
        {
            // If have a Completion Event to Set then
            if (pConnection->hCompletionEvent)
            {
                SetEvent(pConnection->hCompletionEvent);
                CloseHandle(pConnection->hCompletionEvent);
                pConnection->hCompletionEvent = NULL;
            }


            // if have an open ras connection, hang it up.
            // only time this should get connected is in the progress
            // TODO: make this a class that keeps the netapi loaded
            // until all connectoins have been closed.
#ifndef _RASDIAL
            if (pConnection->dwConnectionId)
            {
                if ( NULL != pNetApi )
                {
                    pNetApi->InternetHangUp(pConnection->dwConnectionId,0);
                    pConnection->dwConnectionId = 0; // even if hangup fails set to null.
                }
            }
#else
            if (pConnection->hRasConn)
            {
                if ( NULL != pNetApi )
                {
                    pNetApi->RasHangup(pConnection->hRasConn);
                    pConnection->hRasConn = NULL; // even if hangup fails set to null.
                }
            }
#endif // _RASDIAL


            // if noone is holding onto this connection anymore get rid of it.
            if (0 == pConnection->cRefs)
            {

                pCurConnection->pNextConnectionObj
                    = pConnection->pNextConnectionObj;

               FreeConnectionObj(pConnection);

            }
            else
            {
                pCurConnection = pCurConnection->pNextConnectionObj;
            }

            break;
        }
        else
        {
            pCurConnection = pCurConnection->pNextConnectionObj;
        }
    }

    m_pFirstConnectionObj = FirstConnectObj.pNextConnectionObj;

    if ( pNetApi != NULL )
        pNetApi->Release();

    clockqueue.Leave();

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::CloseConnections, public
//
//  Synopsis:   Closes any open connections that have a refcount of zero.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::CloseConnections()
{
CLock clockqueue(this);
CONNECTIONOBJ FirstConnectObj;
CONNECTIONOBJ *pCurConnection = &FirstConnectObj;

    clockqueue.Enter();

    pCurConnection->pNextConnectionObj = m_pFirstConnectionObj;

    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    while (pCurConnection->pNextConnectionObj)
    {
    CONNECTIONOBJ *pConnection = pCurConnection->pNextConnectionObj;

        // If have a Completion Event to Set then
        if (pConnection->hCompletionEvent)
        {
            SetEvent(pConnection->hCompletionEvent);
            CloseHandle(pConnection->hCompletionEvent);
            pConnection->hCompletionEvent = NULL;
        }


        // if have an open ras connection, hang it up.
        // only time this should get connected is in the progress
        // TODO: make this a class that keeps the netapi loaded
        // until all connectoins have been closed.
        if (pConnection->dwConnectionId)
        {
            if ( NULL != pNetApi )
            {
                pNetApi->InternetHangUp(pConnection->dwConnectionId,0);
                pConnection->dwConnectionId = 0; // even if hangup fails set to null.
            }
        }

        // if noone is holding onto this connection anymore get rid of it.
        if (0 == pConnection->cRefs)
        {

            pCurConnection->pNextConnectionObj
                = pConnection->pNextConnectionObj;

            FreeConnectionObj(pConnection);
        }
        else
        {
            pCurConnection = pCurConnection->pNextConnectionObj;
        }
    }

    m_pFirstConnectionObj = FirstConnectObj.pNextConnectionObj;

    //
    // Check if auto dial connection needs to be turned off, ignore failure
    //
    if ( m_fAutoDialConn )
    {
        if ( NULL != pNetApi )
        {
            if (m_dwAutoConnID)
            {
                pNetApi->InternetHangUp(m_dwAutoConnID,0);
            }
            else
            {
                pNetApi->InternetAutodialHangup( 0 );
            }
        }

        m_dwAutoConnID = FALSE;
        m_fAutoDialConn = FALSE;
    }

    // if we turned off offline then turn it back on
    RestoreWorkOffline(pNetApi);

    if ( pNetApi != NULL )
        pNetApi->Release();

    clockqueue.Leave();

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::ReleaseConnectionObj, public
//
//  Synopsis:   Decrements the specified connectionObj
//              If ther reference count goes to zero and there
//              is not an open connection we go ahead and
//              cleanup immediately.
//
//              If there is a dialed connection we wait until
//              CloseConnection is explicitly called.
//
//  Arguments:  [pConnectionObj] - Pointer to the Connection Obj to Release.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CConnectionObj::ReleaseConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
DWORD cRefs;
BOOL fConnectionOpen = FALSE;
CLock clockqueue(this);

    clockqueue.Enter();
    --pConnectionObj->cRefs;
    cRefs = pConnectionObj->cRefs;
    Assert( ((LONG) cRefs) >= 0);

#ifndef _RASDIAL
    fConnectionOpen = pConnectionObj->dwConnectionId;
#else
    fConnectionOpen = pConnectionObj->hRasConn;
#endif // _RASDIAL

    if (0 == cRefs && !fConnectionOpen
        && NULL == pConnectionObj->hCompletionEvent)
    {
        RemoveConnectionObj(pConnectionObj);
    }

    clockqueue.Leave();
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:   CConnectionObj::AddRefConnectionObj, public
//
//  Synopsis:   Puts an AddRef on the specified connection obj
//
//  Arguments:  [pConnectionObj] - Pointer to the Connection Obj to Release.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CConnectionObj::AddRefConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
DWORD cRefs;

    cRefs = InterlockedIncrement( (LONG *) &(pConnectionObj->cRefs));

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConnectionObj::GetConnectionObjCompletionEvent, public
//
//  Synopsis:  caller has made a request for a completion event to be set up.
// !!! warning, on success the event won't be signalled until CloseConnections is Called.
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CConnectionObj::GetConnectionObjCompletionEvent(CONNECTIONOBJ *pConnectionObj,HANDLE *phRasPendingEvent)
{
HRESULT hr = E_UNEXPECTED;
BOOL fFirstCreate = FALSE;
CLock clockqueue(this);

    clockqueue.Enter();

    if (NULL == pConnectionObj->hCompletionEvent)
    {
        pConnectionObj->hCompletionEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
        fFirstCreate = TRUE;
    }

    if (pConnectionObj->hCompletionEvent)
    {
    HANDLE hCurThread;
    HANDLE hProcess;

        // if have a handle, duplicate it hand it out.
        hCurThread = GetCurrentThread();
        hProcess = GetCurrentProcess();

        if (DuplicateHandle(hProcess,pConnectionObj->hCompletionEvent,hProcess,
                    phRasPendingEvent,
                    0,FALSE,DUPLICATE_SAME_ACCESS) )
        {

            hr = NOERROR;
        }
        else
        {
            *phRasPendingEvent = NULL;

            // if event was just created, then also close this one
            if (fFirstCreate)
            {
                CloseHandle(pConnectionObj->hCompletionEvent);
                pConnectionObj->hCompletionEvent = NULL;
            }
        }

    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_OpenConnection, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_OpenConnection(CONNECTIONOBJ *pConnectionObj,BOOL fMakeConnection,CBaseDlg *pDlg)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->OpenConnection(pConnectionObj,fMakeConnection,pDlg);

}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_CloseConnections, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_CloseConnections()
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->CloseConnections();

}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_CloseConnection, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_CloseConnection(CONNECTIONOBJ *pConnectionObj)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->CloseConnection(pConnectionObj);
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_FindConnectionObj, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_FindConnectionObj(LPCWSTR pszConnectionName,BOOL fCreate,CONNECTIONOBJ **pConnectionObj)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->FindConnectionObj(pszConnectionName,
                fCreate,pConnectionObj);

}


//+---------------------------------------------------------------------------
//
//  Function:   ConnectObj_AutoDial
//
//  Synopsis:   Wrapper function for auto dial
//
//  History:    28-Jul-98      SitaramR        Created
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_AutoDial(DWORD dwFlags,CBaseDlg *pDlg)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;

    return g_pConnectionObj->AutoDial(dwFlags,pDlg);
}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_ReleaseConnectionObj, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD ConnectObj_ReleaseConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return 0;

    return g_pConnectionObj->ReleaseConnectionObj(pConnectionObj);

}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_AddRefConnectionObj, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------


DWORD ConnectObj_AddRefConnectionObj(CONNECTIONOBJ *pConnectionObj)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return 0;

    return g_pConnectionObj->AddRefConnectionObj(pConnectionObj);

}

//+---------------------------------------------------------------------------
//
//  Function:     ConnectObj_GetConnectionObjCompletionEvent, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_GetConnectionObjCompletionEvent(CONNECTIONOBJ *pConnectionObj,HANDLE *phRasPendingEvent)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;


    return g_pConnectionObj->GetConnectionObjCompletionEvent(
            pConnectionObj,phRasPendingEvent);

}

//+---------------------------------------------------------------------------
//
//  Function:   ConnectObj_IsConnectionAvailable, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    30-Mar-99       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_IsConnectionAvailable(LPCWSTR pszConnectionName)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;


    return g_pConnectionObj->IsConnectionAvailable(pszConnectionName);

}

//+---------------------------------------------------------------------------
//
//  Function:   ConnectObj_SetWorkOffline, public
//
//  Synopsis:   wrapper function
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    14-Apr-99       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT ConnectObj_SetWorkOffline(BOOL fWorkOffline)
{
    Assert(g_pConnectionObj);

    if (NULL == g_pConnectionObj)
        return E_UNEXPECTED;


    return g_pConnectionObj->SetWorkOffline(fWorkOffline);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\hndlrmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Hndlrmsg.h
//
//  Contents:   Handles messages on the Handlers thread
//
//  Classes:    CHndlrMsg
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _HNDLRMSG_
#define _HNDLRMSG_

class CThreadMsgProxy;
class COfflineSynchronizeCallback;
class CHndlrQueue;

typedef struct _tagShowPropertiesThreadArgs {
LPSYNCMGRSYNCHRONIZE lpOneStopHandler;
CLSID ItemId;
HWND hwnd;
} ShowPropertiesThreadArgs;


class CHndlrMsg  : public CLockHandler
{

public:
    CHndlrMsg(void);
    ~CHndlrMsg(void);

    //IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // ISYNCMGRSynchronize Methods
    STDMETHODIMP Initialize(DWORD dwReserved,DWORD dwSyncFlags,
                        DWORD cbCookie,const BYTE *lpCooke);

    STDMETHODIMP GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
    STDMETHODIMP EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOffineItems);
    STDMETHODIMP GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv);
    STDMETHODIMP ShowProperties(HWND hwnd,REFSYNCMGRITEMID ItemID);
    STDMETHODIMP SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack);
    STDMETHODIMP PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
                        HWND hwnd,DWORD dwReserved);
    STDMETHODIMP Synchronize(HWND hwnd);
    STDMETHODIMP SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus);
    STDMETHODIMP ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID);

    // Private proxy messages
    STDMETHODIMP  CreateServer(const CLSID *pCLSIDServer,
                            CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId,DWORD dwProxyThreadId);
    STDMETHODIMP  SetHndlrQueue(CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId,DWORD m_dwProxyThreadId);
    STDMETHODIMP  AddHandlerItems(HWND hwndList,DWORD *pcbNumItems);
    STDMETHODIMP  SetupCallback(BOOL fSet);

    // Private methods
 //   STDMETHODIMP  privSetCallBack(void);
    STDMETHODIMP AddToItemList(LPSYNCMGRITEM poffItem);
    STDMETHODIMP SetHandlerInfo();

    // private messages called on different thread.
    STDMETHODIMP ForceKillHandler();

private:
    void  GetHndlrQueue(CHndlrQueue **ppHndlrQueue,HANDLERINFO **ppHandlerId,DWORD *pdwProxyThreadId);
    void  AttachThreadInput(BOOL fAttach); // attach input queue with proxy.
    BOOL m_fThreadInputAttached;
    DWORD m_cRef;
    LPSYNCMGRSYNCHRONIZE m_pOneStopHandler;
    LPOLDSYNCMGRSYNCHRONIZE m_pOldOneStopHandler; // old idl, remove if time.
    DWORD m_dwSyncFlags;
    COfflineSynchronizeCallback *m_pCallBack;
    SYNCMGRITEMID m_itemIDShowProperties; // ItemId that was passed to ShowProperties.
    CLSID m_CLSIDServer;
    CHndlrQueue *m_pHndlrQueue;
    HANDLERINFO *m_pHandlerId;
    DWORD m_dwProxyThreadId; // threadId of caller.
    DWORD m_dwThreadId;
    DWORD m_dwNestCount; // keep track of re-entry.
    BOOL m_fDead; // object has been released;
    BOOL m_fForceKilled; // object was force killed.

    friend COfflineSynchronizeCallback;
};




#endif // _HNDLRMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\dlg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Dlg.h
//
//  Contents:   Dialog box classes
//
//  Classes:    CBaseDlg
//              CChoiceDlg
//              CProgressDlg
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _ONESTOPDLG_
#define _ONESTOPDLG_


//Used for item data on Progress Results UI
// !!!!Warning - Automated test look at this structure directly
//   If you change it you need to notify Testing so they can also
//   Update their tests

typedef struct tagLBDATA
{
BOOL    fTextRectValid; // flag to indicate if rcText has been calculated.
RECT    rcTextHitTestRect; // rectangle for hitTesting.
RECT    rcText;     // total bounding box of text to use for draw
INT     IconIndex;
BOOL    fIsJump;
BOOL    fHasBeenClicked;
BOOL    fAddLineSpacingAtEnd; // set if should leave space after item
HANDLERINFO *   pHandlerID;
SYNCMGRERRORID ErrorID;
DWORD   dwErrorLevel;    // Error level of this item
TCHAR   pszText[1];      // errorText, dynamic array.
} LBDATA;



// cmdIds passed ot the ReleaseDlg method
#define RELEASEDLGCMDID_DESTROY    0 // cmdid send when dialog was destroyed before added to list
#define RELEASEDLGCMDID_DEFAULT    1 // cmdid sent if cmd hasn't been explicitly set.
#define RELEASEDLGCMDID_OK                 2 // treated as if user Pressed Okay
#define RELEASEDLGCMDID_CANCEL     3 // treated as if user pressed Cancel


// helper utilities
BOOL AddItemsFromQueueToListView(CListView  *pItemListView,CHndlrQueue *pHndlrQueue
                            ,DWORD dwExtStyle,LPARAM lparam,int iDateColumn,int iStatusColumn,BOOL fHandlerParent
                            ,BOOL fAddOnlyCheckedItems);



typedef struct _tagDlgResizeList
{
    int iCtrlId;
    DWORD dwDlgResizeFlags;
} DlgResizeList;

// structure passed as lParam to call completion routine.
// must free after processin the message
// CallCompletion message declarations.
// DWORD dwThreadMsg; // passed as wParam.

typedef struct _tagCALLCOMPLETIONMSGLPARAM 
{
    HRESULT hCallResult;
    CLSID  clsidHandler;
    SYNCMGRITEMID itemID;
} CALLCOMPLETIONMSGLPARAM , *LPCALLCOMPLETIONMSGLPARAM;

// base class both dialogs derive from
#define CHOICELIST_NAMECOLUMN 0
#define CHOICELIST_LASTUPDATECOLUMN 1
#define PROGRESSLIST_NAMECOLUMN 0
#define PROGRESSLIST_STATUSCOLUMN 1
#define PROGRESSLIST_INFOCOLUMN 2

#define PROGRESS_TAB_UPDATE	0
#define PROGRESS_TAB_ERRORS 1

class CBaseDlg
{
public:
    HWND m_hwnd;
    DWORD m_dwThreadID;
    BOOL m_fForceClose; // passed in generic release.
    BOOL m_fHwndRightToLeft;


    inline HWND GetHwnd() { return m_hwnd; };

    virtual BOOL Initialize(DWORD dwThreadID,int nCmdShow) = 0;
    virtual void ReleaseDlg(WORD wCommandID) = 0;
    virtual void UpdateWndPosition(int nCmdShow,BOOL fForce)= 0;

    // make HandleLogError as a base dialog class so can call it from queue and
    // other locations without worrying about the dialog type.
    virtual void HandleLogError(HWND hwnd,HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors) = 0;
    virtual void PrivReleaseDlg(WORD wCommandID) = 0;
    virtual void CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam) = 0;
    virtual HRESULT QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide) = 0;
};

// Messages Shared between both dialogs

#define WM_BASEDLG_SHOWWINDOW           (WM_USER + 3)
#define WM_BASEDLG_COMPLETIONROUTINE    (WM_USER + 4)
#define WM_BASEDLG_HANDLESYSSHUTDOWN    (WM_USER + 5)
#define WM_BASEDLG_NOTIFYLISTVIEWEX     (WM_USER + 6)
#define WM_BASEDLG_LAST                 WM_BASEDLG_NOTIFYLISTVIEWEX

// choice dialog messages
#define WM_CHOICE_FIRST  (WM_BASEDLG_LAST + 1)
#define WM_CHOICE_SETQUEUEDATA          (WM_CHOICE_FIRST + 1)
#define WM_CHOICE_RELEASEDLGCMD         (WM_CHOICE_FIRST + 2)
#define WM_CHOICE_LAST                  WM_CHOICE_RELEASEDLGCMD               


// progress dialog messages
#define WM_PROGRESS_FIRST   (WM_CHOICE_LAST + 1)
#define WM_PROGRESS_UPDATE                  (WM_PROGRESS_FIRST + 1)
#define WM_PROGRESS_LOGERROR                (WM_PROGRESS_FIRST + 2)
#define WM_PROGRESS_DELETELOGERROR          (WM_PROGRESS_FIRST + 3)
#define WM_PROGRESS_STARTPROGRESS           (WM_PROGRESS_FIRST + 4)
#define WM_PROGRESS_RELEASEDLGCMD           (WM_PROGRESS_FIRST + 5)
#define WM_PROGRESS_TRANSFERQUEUEDATA       (WM_PROGRESS_FIRST + 6)
#define WM_PROGRESS_SHELLTRAYNOTIFICATION   (WM_PROGRESS_FIRST + 7)
#define WM_PROGRESS_SHUTDOWN                (WM_PROGRESS_FIRST + 8)
#define WM_PROGRESS_RESETKILLHANDLERSTIMER  (WM_PROGRESS_FIRST + 9)

// helper macros for sending window messages
#define BASEDLG_SHOWWINDOW(hwnd,nCmdShow) SendMessage(hwnd,WM_BASEDLG_SHOWWINDOW,nCmdShow,0);

BOOL CALLBACK CChoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                              LPARAM lParam);

typedef struct _tagSetQueueDataInfo
{
const CLSID *rclsid;
CHndlrQueue * pHndlrQueue;
} SetQueueDataInfo;

#define NUM_DLGRESIZEINFOCHOICE 6 // make sure update if change numitems

class CChoiceDlg : public CBaseDlg
{
public:
    CChoiceDlg(REFCLSID rclsid);
    BOOL Initialize(DWORD dwThreadID,int nCmdShow); // called to initialize the choice dialog
    BOOL SetQueueData(REFCLSID rclsid,CHndlrQueue * pHndlrQueue);
    void ReleaseDlg(WORD wCommandID);
    void UpdateWndPosition(int nCmdShow,BOOL fForce);
    HRESULT QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide);

    void HandleLogError(HWND hwnd,HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors);
    void PrivReleaseDlg(WORD wCommandID);
    void CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam);


private:
    BOOL PrivSetQueueData(REFCLSID rclsid,CHndlrQueue * pHndlrQueue);
    BOOL SetButtonState(int nIDDlgItem,BOOL fEnabled);
    int CalcListViewWidth(HWND hwndList);

    BOOL OnInitialize(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnClose(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnGetMinMaxInfo(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam);
    LRESULT OnNotifyListViewEx(UINT uMsg,WPARAM wParam,LPARAM lParam);
    LRESULT OnNotify(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnHelp(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnContextMenu(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnSetQueueData(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnStartCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnPropertyCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);

    // Set QueueData has to be in sync with
    BOOL ShowChoiceDialog();
    BOOL AddNewItemsToListView();
    HRESULT ShowProperties(int iItem);

    CHndlrQueue *m_pHndlrQueue;
    BOOL m_fDead;
    int m_nCmdShow; // How to show dialog, same flags pased to ShowWindow.
    BOOL m_fInternalAddref; // bool to indicate if dialog has placed an addref on self.
    DWORD m_dwShowPropertiesCount; // keeps track of number of show properties open.
    CLSID m_clsid;              // clsid associated with this dialog.
    ULONG m_ulNumDlgResizeItem;
    DLGRESIZEINFO m_dlgResizeInfo[NUM_DLGRESIZEINFOCHOICE];
    POINT m_ptMinimizeDlgSize;
    CListView  *m_pItemListView;


friend BOOL CALLBACK CChoiceDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam);

};




// structures for dialog messages

// wparam of the progress update message,
// lparam of the Update is teh SYNCPROGRESSITEM.
typedef struct _tagPROGRESSUPDATEDATA
{
HANDLERINFO *pHandlerID;
WORD  wItemId;
CLSID clsidHandler;
SYNCMGRITEMID ItemID;
} PROGRESSUPDATEDATA;


// flags for keeping track of progress dlg state.
// make sure all flags are unique bits.
typedef enum _tagPROGRESSFLAG
{
    // general state of the dialog
    PROGRESSFLAG_NEWDIALOG                  = 0x01,  // dialog is new and no items have been added yet.
    PROGRESSFLAG_TRANSFERADDREF             = 0x02, // an addref has been placed on dialog by queue items getting trasferred.
    PROGRESSFLAG_SYNCINGITEMS               = 0x04, // process of synchronizing items in queue has started but not finished.
    PROGRESSFLAG_INCANCELCALL               = 0x08, // cancel call is in progress.
    PROGRESSFLAG_CANCELWHILESHUTTINGDOWN    = 0x10, // cancel was pressed while in shutdownloop
    PROGRESSFLAG_DEAD                       = 0x20, // done with dialog no methods should be called.
    PROGRESSFLAG_CALLBACKPOSTED             = 0x40, // at leasted on callback message is in the queue.
    PROGRESSFLAG_STARTPROGRESSPOSTED        = 0x80, // anyone who posts a start process check this before posting

    // flags used by main sync loop to figure out what to do next.
    PROGRESSFLAG_NEWITEMSINQUEUE        = 0x0100, // new items have been placed in the queue.
    PROGRESSFLAG_IDLENETWORKTIMER       = 0x0200,  // idle timer has been setup for network idles.
    PROGRESSFLAG_PROGRESSANIMATION      = 0x0400, // progress animatiion has been turned on.
    PROGRESSFLAG_SHUTTINGDOWNLOOP       = 0x0800,  // set when no more items in queue and starting shutdown process
    PROGRESSFLAG_INHANDLEROUTCALL       = 0x1000,  // set when in main loop and making an out call.
    PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL       = 0x2000,  // set in callback when handler is already in an out calll.
    PROGRESSFLAG_INSHOWERRORSCALL          = 0x4000, // set when in showerrors call
    PROGRESSFLAG_SHOWERRORSCALLBACKCALLED = 0x8000, // set when showerrors callback comes in while still in original cal.

    // flags used to keep track of Idle state (if any)
    PROGRESSFLAG_REGISTEREDFOROFFIDLE   = 0x010000, // off idle callback has been registered.
    PROGRESSFLAG_RECEIVEDOFFIDLE        = 0x020000, // queue has receive the offIdle event
    PROGRESSFLAG_IDLERETRYENABLED       = 0x040000, // retry on idle has been set.
    PROGRESSFLAG_INOFFIDLE              = 0x080000, // set when handling an offidle
    PROGRESSFLAG_CANCELPRESSED          = 0x100000, // set when cancel has been pressed and never reset.
    
    //flag used to terminate unresponsive hanlders
    PROGRESSFLAG_INTERMINATE            = 0x200000 //We are terminating unresponsive handlers.

} PROGRESSFLAG;


BOOL CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);

#define NUM_DLGRESIZEINFO_PROGRESS 15
#define NUM_DLGRESIZEINFO_PROGRESS_COLLAPSED 7

#define NUM_PROGRESS_ERRORIMAGES 3

/////////////////////////////////////////////////////////////////////////////
// Images
//
typedef enum _tagErrorImageIndex
{
    ErrorImage_Information = 0,
    ErrorImage_Warning      = 1,
    ErrorImage_Error        = 2,
} ErrorImageIndex;

enum {
    IMAGE_TACK_IN = 0,
    IMAGE_TACK_OUT
};

class CProgressDlg : public CBaseDlg
{
public:

    CProgressDlg(REFCLSID rclsid);
    BOOL Initialize(DWORD dwThreadID,int nCmdShow);

    // transfer queue has to be synced with person doing the transfer.
    STDMETHODIMP TransferQueueData(CHndlrQueue *HndlrQueue);
    void ReleaseDlg(WORD wCommandID);
    void UpdateWndPosition(int nCmdShow,BOOL fForce);
    void HandleLogError(HWND hwnd,HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors);
    void HandleDeleteLogError(HWND hwnd,MSGDeleteLogErrors *pDeleteLogError);
    void CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam);
    HRESULT QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide);

    void PrivReleaseDlg(WORD wCommandID);
    void OffIdle();
    void OnIdle();
    void SetIdleParams( ULONG m_ulIdleRetryMinutes,ULONG m_ulDelayIdleShutDownTime,BOOL fRetryEnabled);


private:
    STDMETHODIMP_(ULONG) AddRefProgressDialog();
    STDMETHODIMP_(ULONG) ReleaseProgressDialog(BOOL fForce);

    // methods called from the wndProc
    BOOL InitializeHwnd(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    BOOL OnCommand(HWND hwnd, WORD wID, WORD wNotifyCode);
    BOOL OnSysCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnTimer(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnTaskBarCreated(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnPaint(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnShellTrayNotification(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnClose(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnGetMinMaxInfo(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnMoving(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnCommand(UINT uMsg,WPARAM wParam,LPARAM lParam);
    LRESULT OnNotify(UINT uMsg,WPARAM wParam,LPARAM lParam);
    BOOL OnContextMenu(UINT uMsg,WPARAM wParam,LPARAM lParam);
    BOOL OnPowerBroadcast(UINT uMsg,WPARAM wParam,LPARAM lParam);
    LRESULT OnNotifyListViewEx(UINT uMsg,WPARAM wParam,LPARAM lParam);
    void OnResetKillHandlersTimers(void);


    STDMETHODIMP PrivTransferQueueData(CHndlrQueue *HndlrQueue);
    BOOL KeepProgressAlive();
    void OnCancel(BOOL fOffIdle);
    STDMETHODIMP CreateListViewItem(HWND hwnd,HANDLERINFO *pHandlerID,REFCLSID clsidHandler,SYNCMGRITEM *pofflineItem, INT *piListViewItem, INT iItem);
    STDMETHODIMP OnShowError(HANDLERINFO *pHandlerId,HWND hWndParent,REFSYNCMGRERRORID ErrorID);
    BOOL RedrawIcon();
    void ShowProgressTab(int iTab);
    void UpdateProgressValues();
    STDMETHODIMP PrepareNewItemsForSync(void);
    void DoSyncTask(HWND hwnd);
    void HandleProgressUpdate(HWND hwnd, WPARAM wParam,LPARAM lParam);
    void ExpandCollapse(BOOL fExpand, BOOL fForce);
    BOOL InitializeTabs(HWND hwnd);
    BOOL InitializeToolbar(HWND hwnd);
    BOOL InitializeUpdateList(HWND hwnd);
    BOOL InitializeResultsList(HWND hwnd);
    BOOL ShowCompletedProgress(BOOL fComplete,BOOL fDialogIsLocked);
    BOOL AnimateTray(BOOL fTayAdded);
    BOOL RegisterShellTrayIcon(BOOL fRegister);
    BOOL UpdateTrayIcon();
    BOOL SetButtonState(int nIDDlgItem,BOOL fEnabled);
    BOOL IsItemWorking(int iListViewItem);

    void UpdateDetailsInfo(DWORD dwStatusType,int iItem, TCHAR *pszItemInfo);
    void AddListData(LBDATA *pData, int iNumChars, HWND hwndList);


private:
    LONG m_cInternalcRefs;
    LONG m_lTimerSet;

    HWND m_hwndTabs;
    WNDPROC m_fnResultsListBox;  // function for ListBoxSubClass.
    BOOL m_fSensInstalled;

    // variables for resizing.
    DLGRESIZEINFO m_dlgResizeInfo[NUM_DLGRESIZEINFO_PROGRESS];
    ULONG m_cbNumDlgResizeItemsCollapsed;
    ULONG m_cbNumDlgResizeItemsExpanded;
    POINT m_ptMinimumDlgExpandedSize; // minimum size dialog can be in expanded mode.
    DWORD   m_cyCollapsed;      // min Height of the collapsed dialog
    BOOL    m_fExpanded;    // TRUE if the details part of the dialog is visible
    BOOL    m_fPushpin;     //Pushpin state
    BOOL    m_fMaximized;   // set to true when the window has been maximized.
    RECT    m_rcDlg;        // Size of the fully expanded dialog

    HIMAGELIST m_errorimage;
    int m_iIconMetricX;
    int m_iIconMetricY;
    INT  m_ErrorImages[NUM_PROGRESS_ERRORIMAGES];
    INT  m_iProgressSelectedItem;
    INT  m_iResultCount;
    INT  m_iInfoCount;
    INT  m_iWarningCount;
    INT  m_iErrorCount;
    LBDATA *m_CurrentListEntry;

    int m_iLastItem; 
    DWORD m_dwLastStatusType;
    INT    m_iTab;                 // The index of the current tab

    CHndlrQueue *m_HndlrQueue;

    // Idle specific members
    CSyncMgrIdle *m_pSyncMgrIdle;
    ULONG m_ulIdleRetryMinutes;
    ULONG m_ulDelayIdleShutDownTime;

    DWORD m_dwProgressFlags;
    DWORD m_dwShowErrorRefCount; // number of RefCounts showError calls have on the dialog.
    DWORD m_dwSetItemStateRefCount; // number of RefCounts SetItemState OutCall has on the dialog.
    DWORD m_dwHandleThreadNestcount; // make sure main handler thread isn't re-entrant
    DWORD m_dwPrepareForSyncOutCallCount; // number of prepareForSyncs in progress.
    DWORD m_dwSynchronizeOutCallCount; // number of prepareForSyncs in progress.
    DWORD m_dwHandlerOutCallCount; // total number of outcalls in progress.
    CLSID m_clsidHandlerInSync;         // clsid associated with handler that is currently synchronizing.
    
    DWORD m_dwQueueTransferCount; // number of queue transfers in progress.
    BOOL m_fHasShellTrayIcon;
    BOOL m_fAddedIconToTray;
    int  m_iTrayAniFrame;
    CLSID m_clsid;              // clsid associated with this dialog.
    INT m_iItem;                // index to any new item to the list box.
    int m_nCmdShow;             // How to show dialog, same flags pased to ShowWindow.
    CListView  *m_pItemListView;
    UINT m_nKillHandlerTimeoutValue; // TimeoutValue for ForceKill
    

    TCHAR m_pszStatusText[8][MAX_STRING_RES + 1];

    friend BOOL CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
    friend BOOL OnProgressUpdateNotify(HWND hwnd,CProgressDlg *pProgress, int idFrom, LPNMHDR pnmhdr);
    friend BOOL OnProgressResultsDrawItem(HWND hwnd,CProgressDlg *pProgress,UINT idCtl, const DRAWITEMSTRUCT* lpDrawItem);
    friend BOOL OnProgressResultsNotify(HWND hwnd,CProgressDlg *pProgress, int idFrom, LPNMHDR pnmhdr);
    friend BOOL CALLBACK ResultsListBoxWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
    friend BOOL CALLBACK ResultsProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
    friend BOOL OnProgressResultsMeasureItem(HWND hwnd,CProgressDlg *pProgress, UINT *horizExtent, UINT idCtl, MEASUREITEMSTRUCT *pMeasureItem);


};


#endif // _ONESTOPDLG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\hndlrmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Hndlrmsg.cpp
//
//  Contents:   Takes care of handler specific messages
//
//  Classes:    CHndlrMsg
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::CHndlrMsg, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CHndlrMsg::CHndlrMsg()
{
    m_pOneStopHandler = NULL;
    m_pOldOneStopHandler = NULL;
    m_dwSyncFlags = 0;
    m_pCallBack = NULL;
    m_cRef = 1;
    m_fDead = FALSE;
    m_fForceKilled = FALSE;
    m_dwNestCount = 0;
    m_fThreadInputAttached = FALSE;
    m_itemIDShowProperties = GUID_NULL;

    m_dwProxyThreadId = -1;
    m_dwThreadId = GetCurrentThreadId();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::~CHndlrMsg, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CHndlrMsg::~CHndlrMsg()
{
    Assert(m_dwThreadId == GetCurrentThreadId() || m_fForceKilled);
    Assert(0 == m_dwNestCount || m_fForceKilled);
    Assert(0 == m_cRef || m_fForceKilled);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
   Assert(m_dwThreadId == GetCurrentThreadId());

    Assert(0 == m_dwNestCount);

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CHndlrMsg::AddRef()
{
ULONG cRefs;

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    cRefs = InterlockedIncrement((LONG *)& m_cRef);

    m_dwNestCount--;
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CHndlrMsg::Release()
{
ULONG cRefs;

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (0 == cRefs)
    {

        if (m_pCallBack)
        {
            SetupCallback(FALSE);
        }

        Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );
        if (m_pOneStopHandler)
        {
        LPSYNCMGRSYNCHRONIZE OneStopHandler = m_pOneStopHandler;

            m_pOneStopHandler = NULL;
            // if have a callback then revoke it
            __try
            {
                OneStopHandler->Release();
            }
            __except(QueryHandleException())
            {
                AssertSz(0,"Exception in Handler's release method.");
            }
        }

        if (m_pOldOneStopHandler)
        {
            LPOLDSYNCMGRSYNCHRONIZE pOldOneStopHandler = m_pOldOneStopHandler;

            m_pOldOneStopHandler = NULL;
            // if have a callback then revoke it
            __try
            {
                pOldOneStopHandler->Release();
            }
            __except(QueryHandleException())
            {
                AssertSz(0,"Exception in Handler's release method.");
            }
        }

        if (m_pHndlrQueue)
        {
            m_pHndlrQueue->Release();
            m_pHndlrQueue = NULL;
        }

        m_fDead = TRUE;
        m_dwNestCount--;
        delete this;
    }
    else
    {
        m_dwNestCount--;
    }

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::Initialize, public
//
//  Synopsis:   Calls Initialize method of the Handler
//
//  Arguments:  [dwReserved] - Reserved for now is NULL
//              [dwSyncFlags] - SyncFlags
//              [cbCookie] - Size of Cookie data if any
//              [lpCookie] - Pointer to Cookie data
//
//  Returns:    Whatever the handler tells us too.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::Initialize(DWORD dwReserved,
                                    DWORD dwSyncFlags,
                                    DWORD cbCookie,
                                    BYTE const*lpCookie)
{
HRESULT hr = E_UNEXPECTED;

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    m_dwSyncFlags = dwSyncFlags;
    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (NULL != m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->Initialize(dwReserved,dwSyncFlags,cbCookie,lpCookie);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's Initialize method.");
        }
    }


    if (NULL != m_pOldOneStopHandler)
    {
         // old handlers can't handle cookie data unless it is their own
        if (SYNCMGRFLAG_INVOKE != (dwSyncFlags & SYNCMGRFLAG_EVENTMASK))
        {
            cbCookie = 0;
            lpCookie = NULL;
        }

        __try
        {
            hr = m_pOldOneStopHandler->Initialize(dwReserved,dwSyncFlags,cbCookie,lpCookie);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's Initialize method.");
        }
    }

   m_dwNestCount--;
   return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::GetHandlerInfo, public
//
//  Synopsis:   Calls GetHandlerInfo method of the Handler
//
//  Arguments:  [ppSyncMgrHandlerInfo] -
//
//  Returns:    Whatever the handler tells us too.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (NULL != m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->GetHandlerInfo(ppSyncMgrHandlerInfo);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's GetHandlerInfo method.");
        }
    }

    if (NULL != m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->GetHandlerInfo(ppSyncMgrHandlerInfo);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's GetHandlerInfo method.");
        }
    }

   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::EnumOfflineItems, public
//
//  Synopsis:   PlaceHolder for IOfflineSynchronize Enum method.
//              This shouldn't be called. AddHandlerItems should be
//              called instead
//
//  Arguments:  [ppenumOfflineItems] - returned enumerator
//
//  Returns:    Whatever the handler tells us too.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::EnumSyncMgrItems(ISyncMgrEnumItems** ppenumOffineItems)
{

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    AssertSz(0,"Shouldn't call this Method");
    *ppenumOffineItems = NULL;

    m_dwNestCount--;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::GetItemObject, public
//
//  Synopsis:   Calls Handler's GetItemObject method
//
//  Arguments:  [ItemID] - Id of the item
//              [riid] - requested interface
//              [ppv] - out pointer for object
//
//  Returns:    Whatever the handler tells us too.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv)
{
HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (NULL != m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->GetItemObject(ItemID,riid,ppv);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's GetItemObject method.");
        }
        Assert(E_NOTIMPL == hr); // currently noone should be implementing this.
    }

    if (NULL != m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->GetItemObject(ItemID,riid,ppv);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's GetItemObject method.");
        }
        Assert(E_NOTIMPL == hr); // currently noone should be implementing this.
    }

    m_dwNestCount--;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::ShowProperties, public
//
//  Synopsis:   Calls Handler's ShowProperties method
//
//  Arguments:  [hwnd] - hwnd to use as parent to dialog
//              [itemID] - Identifies the Item
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::ShowProperties(HWND hwnd,REFSYNCMGRITEMID ItemID)
{
HRESULT hr = E_UNEXPECTED;

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    // need to setup calback if showProperties is called
    // if can't setup callback then fail the ShowProperties call.

    // Review, ShowPropertiesCompleted doesn't give us the ItemID back so we
    // have to store it. This is fine but limits us to one ShowPropertiesCall
    // at a time on the handler. if update main interfaces change
    // ShowPropertiesCompleted to return the ItemID 

    Assert(GUID_NULL == m_itemIDShowProperties);
    m_itemIDShowProperties = ItemID;


    hr = SetupCallback(TRUE); // set up the callback.
    if (NOERROR != hr)
        return hr;

    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    AttachThreadInput(TRUE);

    if (NULL != m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->ShowProperties(hwnd,ItemID);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's ShowProperties method.");
        }
    }

    if (NULL != m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->ShowProperties(hwnd,ItemID);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's ShowProperties method.");
        }
    }

    m_dwNestCount--;

    // if old interface need to make the callback ourselves
    if ( m_pOldOneStopHandler )
    {
        Assert(m_pCallBack);
        if (m_pCallBack && (NOERROR == hr))
        {
            m_pCallBack->ShowPropertiesCompleted(NOERROR);
        }
    }

    // if an error is returned set the showProperties guid back
    if (NOERROR != hr)
    {
        m_itemIDShowProperties = GUID_NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetProgressCallback, public
//
//  Synopsis:   PlaceHolder for SetProgressCallback. This member is currently
//              not used. Instead the SetupCallback method is called
//
//  Arguments:  [lpCallBack] - Pointer to Callback object
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(0 == m_dwNestCount);
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    m_dwNestCount++;

    AssertSz(0,"Shouldn't call this method");

    m_dwNestCount--;
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::PrepareForSync, public
//
//  Synopsis:   Calls Handler's ShowProperties method
//
//  Arguments:  [cbNumItems] - number of items so sync
//              [pItemIDs] - Array of Items
//              [hwnd] - Hwnd to use as the Parent of any dialogs
//              [dwReserved] - Just a reserved parameter
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
                                HWND hwnd,DWORD dwReserved)
{
HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    // Assert(0 == m_dwNestCount);// may not be zero if handler has yielded

    hr = SetupCallback(TRUE); // set up the callback.
    if (NOERROR != hr)
        return hr;

    m_dwNestCount++;

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->PrepareForSync(cbNumItems,pItemIDs,hwnd,dwReserved);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's PrepareForSync method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->PrepareForSync(cbNumItems,pItemIDs,hwnd,dwReserved);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's PrepareForSync method.");
        }
    }

   m_dwNestCount--;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::Sychronize, public
//
//  Synopsis:   Calls Handler's Synchronize method
//
//  Arguments:  [hwnd] - hwnd to use as parent to dialog
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::Synchronize(HWND hwnd)
{
HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );
    // Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->Synchronize(hwnd);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's Synchronize method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->Synchronize(hwnd);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's Synchronize method.");
        }
    }

    m_dwNestCount--;

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetItemStatus, public
//
//  Synopsis:   Calls Handler's SetItemStatus method
//
//  Arguments:
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus)
{
HRESULT hr = NOERROR;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    m_dwNestCount++; // valid for this to come in when in sync call.

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->SetItemStatus(ItemID,dwSyncMgrStatus);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's SetItemStatus method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->SetItemStatus(ItemID,dwSyncMgrStatus);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's SetItemStatus method.");
        }
    }

    m_dwNestCount--;
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::ShowError, public
//
//  Synopsis:   Calls Handler's ShowError method
//
//  Arguments:  [hwnd] - hwnd to use as parent to dialog
//              [dwErrorID] - ErrorID passed in LogError
//
//  Returns:    Whatever the handler tells us.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
HRESULT hr = E_UNEXPECTED;
ULONG cbNumItems;
SYNCMGRITEMID *pItemIDs;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    m_dwNestCount++;

    // on a ShowError enablemodeless in the callback can 
    // return true since user has shown an interest

    if (m_pCallBack)
    {
        m_pCallBack->SetEnableModeless(TRUE);
    }

    AttachThreadInput(TRUE);

    if (m_pOneStopHandler)
    {
        __try
        {
            hr = m_pOneStopHandler->ShowError(hWndParent,ErrorID);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's ShowError method.");
        }
    }

    if (m_pOldOneStopHandler)
    {
        __try
        {
            hr = m_pOldOneStopHandler->ShowError(hWndParent,ErrorID,&cbNumItems,&pItemIDs);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's ShowError method.");
        }    
    }

    m_dwNestCount--;

    // if old interface need to make the callback ourselves
    if ( m_pOldOneStopHandler )
    {
        Assert(m_pCallBack);
        if (m_pCallBack && SUCCEEDED(hr))
        {
            m_pCallBack->ShowErrorCompleted(hr,cbNumItems,pItemIDs);
            if ( (S_SYNCMGR_RETRYSYNC == hr) && pItemIDs) // after completion routine free the pItems since [in] param.
            {
                CoTaskMemFree(pItemIDs);
            }
        }

        return SUCCEEDED(hr) ? NOERROR : hr;
    }

    // New interface won't have the numItems and Items Enum
    //  on new interface ShowError should only return NOERROR so if retry or
    //  other success is returned then return NOERROR;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetupCallback, private
//
//  Synopsis:   Sets up the callback for the handler
//
//  Arguments:  [fSet] - TRUE sets the Callbac, FALSE removes it
//
//  Returns:    NOERROR on Success
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CHndlrMsg::SetupCallback(BOOL fSet)
{
HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(m_dwNestCount <= 1); // 1 since valid to be called from Release method.
    m_dwNestCount++;

    // possible to get called with fSet twice of true in the case
    // a retrysync occurs. If we already have a callback set
    // when a new request to set one comes in the just return.

    if (NULL != m_pCallBack && TRUE == fSet)
    {
        hr =  NOERROR;
    }
    else
    {

        Assert( ( (NULL != m_pCallBack) && (FALSE == fSet) )
            || (TRUE == fSet)); // catch case OneStop calls this twice when already set

        if (NULL != m_pCallBack)
        {
            // set the callbacks CHndlrMsg pointer to NULL in case
            // object tries to call through after the release.
            m_pCallBack->SetHndlrMsg(NULL,FALSE);
            m_pCallBack->Release();
            m_pCallBack = NULL;
        }


        if (TRUE == fSet)
        {
             // if allocation fails, progress just gets set to NULL
            m_pCallBack = new COfflineSynchronizeCallback(this,m_CLSIDServer,m_dwSyncFlags,
                           (SYNCMGRFLAG_MAYBOTHERUSER & m_dwSyncFlags) /* fAllowModeless */ );
        }

        Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );
        if (m_pOneStopHandler)
        {
            __try
            {
                hr = m_pOneStopHandler->SetProgressCallback( (LPSYNCMGRSYNCHRONIZECALLBACK) m_pCallBack );
            }
            __except(QueryHandleException())
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
                AssertSz(0,"Exception in Handler's SetProgressCallback method.");
            }
        }

        if (m_pOldOneStopHandler)
        {
            __try
            {
                hr = m_pOldOneStopHandler->SetProgressCallback( (LPOLDSYNCMGRSYNCHRONIZECALLBACK) m_pCallBack );
            }
            __except(QueryHandleException())
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
                AssertSz(0,"Exception in Handler's SetProgressCallback method.");
            }
        }

        if ( (NOERROR != hr) && (NULL != m_pCallBack)  )
        {
            m_pCallBack->SetHndlrMsg(NULL,FALSE);
            m_pCallBack->Release(); // on an error go ahead and release our copy too.
            m_pCallBack = NULL;
        }
    }

    m_dwNestCount--;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetHandlerInfo, private
//
//  Synopsis:   sets up the Handler info
//
//  Arguments:  
//
//  Returns:    NOERROR on Success
//
//  Modifies:
//
//  History:    28-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrMsg::SetHandlerInfo()
{
LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo = NULL;
HRESULT hr = E_UNEXPECTED; 

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    hr = GetHandlerInfo(&pSyncMgrHandlerInfo);
    if (NOERROR != hr || (NULL == pSyncMgrHandlerInfo))
    {
        return hr;
    }
    
    if (!IsValidSyncMgrHandlerInfo(pSyncMgrHandlerInfo))
    {
        CoTaskMemFree(pSyncMgrHandlerInfo);
        return E_INVALIDARG;
    }

    Assert(m_pHndlrQueue);

    if (m_pHndlrQueue)
    {
        hr  = m_pHndlrQueue->SetHandlerInfo(m_pHandlerId,pSyncMgrHandlerInfo);
    }

    if (pSyncMgrHandlerInfo)
    {
        CoTaskMemFree(pSyncMgrHandlerInfo);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::AddtoItemList, private
//
//  Synopsis:   Adds a single Items to the queue
//
//  Arguments:  [poffItem] - Pointer to Item to add
//
//  Returns:    NOERROR on Success
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CHndlrMsg::AddToItemList(LPSYNCMGRITEM poffItem)
{
HRESULT hr = E_UNEXPECTED;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    Assert(m_pHndlrQueue);

    if (!IsValidSyncMgrItem(poffItem))
    {
        return E_INVALIDARG;
    }

    if (m_pHndlrQueue)
    {

        hr  = m_pHndlrQueue->AddItemToHandler(m_pHandlerId,poffItem);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::AddHandlerItems, private
//
//  Synopsis:   Calls the handlers enumerator and adds each returned item
//              to the queue
//
//  Arguments:  [hwndList] - hwnd of ListView to add items too. (Not Used)
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CHndlrMsg::AddHandlerItems(HWND hwndList,DWORD *pcbNumItems)
{
HRESULT hr = E_UNEXPECTED;
LPSYNCMGRENUMITEMS pEnumOffline = NULL;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(pcbNumItems);

    *pcbNumItems = 0;

    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    SetHandlerInfo(); // setup the toplevel handler info

    Assert(m_pOneStopHandler || m_pOldOneStopHandler);
    Assert( !(m_pOneStopHandler && m_pOldOneStopHandler) );

    if (m_pOneStopHandler || m_pOldOneStopHandler)
    {
        if ( m_pOneStopHandler )
        {
            __try
            {
                hr = m_pOneStopHandler->EnumSyncMgrItems(&pEnumOffline);
            }
            __except(QueryHandleException())
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
                AssertSz(0,"Exception in Handler's EnumSyncMgrItems method.");
            }
        }
        if ( m_pOldOneStopHandler )
        {
            __try
            {
                hr = m_pOldOneStopHandler->EnumSyncMgrItems(&pEnumOffline);
            }
            __except(QueryHandleException())
            {
                hr = HRESULT_FROM_WIN32(GetExceptionCode());
                AssertSz(0,"Exception in Handler's EnumSyncMgrItems method.");
            }
        }

        // Review - Make sure preferences aren't deleted
        //  in missing items case.
        if ( (NOERROR == hr || S_SYNCMGR_MISSINGITEMS  == hr) && pEnumOffline)
        {
        SYNCMGRITEMNT5B2 offItem; // temporarily use NT5B2 structure since its bigger
        ULONG pceltFetched;

            Assert(sizeof(SYNCMGRITEMNT5B2) > sizeof(SYNCMGRITEM));

            // sit in loop getting data of objects to fill list box.
            // should really set up list in memory for OneStop to fill in or
            // main thread could pass in a callback interface.
            
            if (pEnumOffline)
            {
                __try
                {
                    while(NOERROR == pEnumOffline->Next(1,(LPSYNCMGRITEM) &offItem,&pceltFetched))
                    {
                        if (NOERROR == AddToItemList((LPSYNCMGRITEM) &offItem))
                        {
                            ++(*pcbNumItems);
                        }
                    }

                    pEnumOffline->Release();
                }
                __except(QueryHandleException())
                {
                    hr = HRESULT_FROM_WIN32(GetExceptionCode());
                    AssertSz(0,"Exception in Handler's EnumOffline::Next method.");
                }
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
    }

    m_dwNestCount--;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::CreateServer, private
//
//  Synopsis:   Creates and Instance of the handle
//
//  Arguments:  [pCLSIDServer] - CLSID of Handler
//              [pHndlrQueue] - pointer to queue handler should be added too
//              [wHandlerID] - ID of Handler in the queue
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CHndlrMsg::CreateServer(const CLSID *pCLSIDServer,CHndlrQueue *pHndlrQueue,
                                  HANDLERINFO *pHandlerId,DWORD dwProxyThreadId)
{
HRESULT hr = NOERROR;
LPUNKNOWN pUnk;
LPSYNCMGRENUMITEMS pEnumOffline = NULL;

    Assert(m_dwThreadId == GetCurrentThreadId());
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);
    Assert(0 == m_dwNestCount);
    m_dwNestCount++;

    m_CLSIDServer = *pCLSIDServer;
    m_pHndlrQueue = pHndlrQueue;
    m_dwProxyThreadId = dwProxyThreadId;

    if (m_pHndlrQueue)
    {
        m_pHndlrQueue->AddRef();
    }

    m_pHandlerId = pHandlerId;

    hr = CoCreateInstance(m_CLSIDServer, NULL, CLSCTX_INPROC_SERVER,
                    IID_IUnknown, (void **) &pUnk);

    if (NOERROR == hr)
    {
        __try
        {
            hr = pUnk->QueryInterface(IID_ISyncMgrSynchronize,(void **) &m_pOneStopHandler);
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's IUnknown::QI method.");
        }
        __try
        {
            pUnk->Release();
        }
        __except(QueryHandleException())
        {
            hr = HRESULT_FROM_WIN32(GetExceptionCode());
            AssertSz(0,"Exception in Handler's IUnknown::Release method.");
        }
    }

    if (NOERROR != hr)
    {
        m_pOneStopHandler = NULL;
        m_pOldOneStopHandler = NULL;
    }

    m_dwNestCount--;
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::SetHndlrQueue, private
//
//  Synopsis:   Assigns a new HndlrQueue.
//
//  Arguments:  [pHndlrQueue] - Pointer to the Queue
//              [wHandlerId] - Id assigned to handler in the new queue
//
//              !!!Warning - this is on the callers thread
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CHndlrMsg::SetHndlrQueue(CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId,DWORD dwProxyThreadId)
{
CLock clockCallback(this);

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    clockCallback.Enter();

    Assert(0 == m_dwNestCount);
    m_dwNestCount++;


    if (pHndlrQueue != m_pHndlrQueue)
    {
        if (m_pHndlrQueue)
        {
            m_pHndlrQueue->Release();
        }

        m_pHndlrQueue = pHndlrQueue;

        if (m_pHndlrQueue)
        {
            m_pHndlrQueue->AddRef();
        }
    }


    AttachThreadInput(FALSE); // make sure thread input isn't set

    // update handlr id and proxy which can change even if queue is same
    // which can happen first queue that gets set in choice.
    m_pHandlerId = pHandlerId;
    m_dwProxyThreadId = dwProxyThreadId;


    m_dwNestCount--;

    clockCallback.Leave();


    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::GetHndlrQueue, private
//
//  Synopsis:   Gets current Queue,
//              Can be called on any thread so progress callback
//              gets this information.
//
//  Arguments:  [ppHndlrQueue] - Out param filled with Pointer to the Queue
//                              [pwHandlerId] - out param filled with Id assigned to handler
//                              in the new queue
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CHndlrMsg::GetHndlrQueue(CHndlrQueue **ppHndlrQueue,HANDLERINFO **ppHandlerId,DWORD *pdwProxyThreadId)
{
CLock clockCallback(this);

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    clockCallback.Enter();

    *ppHndlrQueue = m_pHndlrQueue;
    *ppHandlerId = m_pHandlerId;
    *pdwProxyThreadId = m_dwProxyThreadId;

    if (m_pHndlrQueue)
    {
        m_pHndlrQueue->AddRef();
    }

    clockCallback.Leave();

}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::AttachThreadInput, private
//
//  Synopsis:   Attaches the thread input of this thread
//              with the calling proxy so UI works correctly.
//
//  Arguments:  [fAttach] - Bool to indicate if should attach or not.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void  CHndlrMsg::AttachThreadInput(BOOL fAttach)
{
    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    // if request is same as current state don't do anything.
    if (m_fThreadInputAttached != fAttach )
    {
        m_fThreadInputAttached = fAttach;
        ::AttachThreadInput(m_dwProxyThreadId,m_dwThreadId,fAttach);
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrMsg::ForceKillHandler, private
//
//  Synopsis:   called directly by proxy when a thread is not
//              responding. Does any necessary cleanup of classes in the handler
//              thread before the proxy kills the thred
//
//  Arguments: 
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    17-Nov-98      rogerg        Created.
//
//----------------------------------------------------------------------------


STDMETHODIMP CHndlrMsg::ForceKillHandler()
{

    Assert(FALSE == m_fForceKilled && FALSE == m_fDead);

    m_fForceKilled = TRUE;

    // if have a callback tell it we terminated but don't
    // release it in case the handler calls the callback later.

    if (m_pCallBack)
    {
    COfflineSynchronizeCallback* pCallback = m_pCallBack;
    
        m_pCallBack = NULL;
        pCallback->SetHndlrMsg(NULL,TRUE);
    }


    // delete our instance since should never be called again.
    delete this;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\invoke.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Invoke.cpp
//
//  Contents:   Handles invocation cases, ENS, Schedule, etc.
//
//  Classes:    CSynchronizeInvoke
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// Review - Need to figure out logon logic. This just prevents ConnectionMade
// events from being handled while we are in logon. If IsNetworkAlive becomse async
// or someone calls IsNetworkAlive before us we will sync the same items twice.
BOOL g_InAutoSync = FALSE;
extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo, setup by WinMain.
extern HINSTANCE g_hInst;      // current instance

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::CSynchronizeInvoke, public
//
//  Synopsis:   Constructor
//              Increments the applications lifetime
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CSynchronizeInvoke::CSynchronizeInvoke()
{
    m_cRef = 1;
    m_pUnkOuter = &m_Unknown; // only support our unknown for know.
    m_pITypeInfoLogon = NULL;
    m_pITypeInfoNetwork = NULL;

    m_Unknown.SetParent(this);

#ifdef _SENS
    m_PrivSensNetwork.SetParent(this);
    m_PrivSensLogon.SetParent(this);
#endif // _SENS

    AddRefOneStopLifetime(TRUE /*External*/);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::~CSynchronizeInvoke, public
//
//  Synopsis:   Destructor
//              Decrements the applications lifetime
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CSynchronizeInvoke::~CSynchronizeInvoke()
{

    if (m_pITypeInfoLogon)
    {
        m_pITypeInfoLogon->Release();
        m_pITypeInfoLogon = NULL;
    }

    if (m_pITypeInfoNetwork)
    {
        m_pITypeInfoNetwork->Release();
        m_pITypeInfoNetwork = NULL;
    }

    ReleaseOneStopLifetime(TRUE /*External*/);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    return m_pUnkOuter->QueryInterface(riid,ppv);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::AddRef()
{
    return m_pUnkOuter->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSychrononizeInvoke::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::Release()
{
    return m_pUnkOuter->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::UpdateItems, public
//
//  Synopsis:   Handles a programmatic UpdateItems call.
//
//              !!Warning - Liveness relies on a dialog being created
//                      before return or we could go away when the
//                      caler releases our interface.
//
//  Arguments:  [dwInvokeFlags] - InvokeFlags
//              [rclsid] - clsid of handler to load
//              [cbCookie] - Size of cookie data
//              [lpCookie] - Ptr to cookie data.
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::UpdateItems(DWORD dwInvokeFlags,REFCLSID rclsid,
                                                        DWORD cbCookie,const BYTE*lpCookie)
{
HRESULT hr = E_OUTOFMEMORY;
CHndlrQueue * pHndlrQueue = NULL;
HANDLERINFO *pHandlerID;
JOBINFO *pJobInfo = NULL;
BOOL fReg;
DWORD dwRegistrationFlags;
int nCmdShow = (dwInvokeFlags & SYNCMGRINVOKE_MINIMIZED) ? SW_SHOWMINIMIZED : SW_SHOWNORMAL;

    // when a new UpdateItems come through do the following
    //  1 - If should display choices see if existing choice dialog or create a new one
    //          and then add the new items to the choice queue

    // 2 - If shouldn't display choices see if existing progress or create a new one
    //          and then add the items to the progress queue.

    // behavior - If already an Update All choice dialog just pull it to the Front
    //            If Already an UpdateAll progress bar bring it to the front
    //            If Progress Bar but doesn't already contain an updateAll create the choice dialog.

#if _ZAWTRACK
    LogZawTrack(dwInvokeFlags); // Track any invokes.
#endif _ZAWTRACK

    pHndlrQueue = new CHndlrQueue(QUEUETYPE_CHOICE,NULL);  // we don't use stored preferences on invoke so doesn't matter what pass in as the connection

    if (NULL == pHndlrQueue)
    {
        hr =  E_OUTOFMEMORY;
        return hr;
    }

    // attempt to initialize the queue
    hr = pHndlrQueue->AddQueueJobInfo(
                SYNCMGRFLAG_INVOKE | SYNCMGRFLAG_MAYBOTHERUSER,
                0,NULL,NULL,FALSE,&pJobInfo);

    fReg = RegGetHandlerRegistrationInfo(rclsid,&dwRegistrationFlags);
    Assert(fReg || (0 == dwRegistrationFlags));

    if ((NOERROR == hr) && NOERROR == pHndlrQueue->AddHandler(&pHandlerID,pJobInfo,dwRegistrationFlags))
    {
        hr = pHndlrQueue->CreateServer(pHandlerID,&rclsid);

        if (NOERROR == hr)
        {
            hr = pHndlrQueue->Initialize(pHandlerID,0,SYNCMGRFLAG_INVOKE | SYNCMGRFLAG_MAYBOTHERUSER,
                                    cbCookie,lpCookie);
        }

    }

    // can release our reference on the job info
    if (pJobInfo)
    {
        pHndlrQueue->ReleaseJobInfoExt(pJobInfo);
        pJobInfo = NULL;
    }

    if (NOERROR == hr)
    {
    DWORD cbNumItemsAdded;

        hr = pHndlrQueue->AddHandlerItemsToQueue(pHandlerID,&cbNumItemsAdded);

        if (SYNCMGRINVOKE_STARTSYNC & dwInvokeFlags)
        {
            // if start invoke need to add the handlers items to the queue before
            // transferring


            if (NOERROR == hr && pHndlrQueue->AreAnyItemsSelectedInQueue())
            {
            CProgressDlg *pProgressDlg;


                hr = FindProgressDialog(GUID_NULL,TRUE,nCmdShow,&pProgressDlg);

                if (NOERROR == hr)
                {
                    hr = pProgressDlg->TransferQueueData(pHndlrQueue);
                    ReleaseProgressDialog(GUID_NULL,pProgressDlg,FALSE);
                }

            }

            pHndlrQueue->FreeAllHandlers(); // done with our queue.

            pHndlrQueue->Release();
            pHndlrQueue = NULL;

        }
        else
        {
        CChoiceDlg *pChoiceDlg;

           // Bring up the Choice dialog, Let choice dialog actually addes the hanlder items
           // if there are any so in the future we can async fill in the choices

           hr = FindChoiceDialog(rclsid,TRUE,nCmdShow,&pChoiceDlg);

           if (S_OK == hr)
           {

                if (FALSE == pChoiceDlg->SetQueueData(rclsid,pHndlrQueue) ) {
                    pHndlrQueue->FreeAllHandlers();

                    pHndlrQueue->Release();

                    pHndlrQueue = NULL;
                    hr =  E_UNEXPECTED;
                }

                ReleaseChoiceDialog(rclsid,pChoiceDlg);
           }

        }
    }
    else
    {
        // if initialize failed and have a queue release it now.

        if (pHndlrQueue)
        {
            pHndlrQueue->FreeAllHandlers();
            pHndlrQueue->Release();
            pHndlrQueue = NULL;
        }

    }

   // if we successfully added a jobinfo to the queue release our reference.


   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::UpdateAll, public
//
//  Synopsis:   Handles a programmatic UpdateAll call.
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::UpdateAll(void)
{
SCODE sc = S_OK;
TCHAR pConnectName[RAS_MaxEntryName + 1];
TCHAR *pConnectionNameArray;

    if (!LoadString(g_hInst, IDS_LAN_CONNECTION, pConnectName, ARRAY_SIZE(pConnectName)))
        {
                sc = GetLastError();
                return sc;
        }
        pConnectionNameArray = pConnectName;

        // Review - Do we Need proper connection or do we always just
    //  use the last items selected in a manual sync regardless
    //  of the current connection

    return PrivUpdateAll(0,SYNCMGRFLAG_MANUAL | SYNCMGRFLAG_MAYBOTHERUSER,0,NULL,
        1,&pConnectionNameArray,NULL,FALSE,NULL,0,0,FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::Logon, public
//
//  Synopsis:   Handles a Logon notification
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::Logon()
{
HRESULT hr = E_UNEXPECTED;

     RegSetUserDefaults(); // Make Sure the UserDefaults are up to date

    // if on Win9x just call IsNetworkAlive and rely on ConnectionMade
    // events coming through. Can't just do this yet on NT 5.0 because 
    // not garanteed to get connectionMades on each logon.

    if (VER_PLATFORM_WIN32_NT != g_OSVersionInfo.dwPlatformId)
    {
    LPNETAPI pNetApi;
    DWORD dwFlags;

        pNetApi = gSingleNetApiObj.GetNetApiObj();

        if (pNetApi)
        {
            pNetApi->IsNetworkAlive(&dwFlags);
            pNetApi->Release();
        }
    }
    else
    {
        hr = PrivHandleAutoSync(SYNCMGRFLAG_CONNECT | SYNCMGRFLAG_MAYBOTHERUSER);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::Logoff, public
//
//  Synopsis:   Handles a Logoff notification
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::Logoff()
{
HRESULT hr = E_UNEXPECTED;

    RegSetUserDefaults(); // Make Sure the UserDefaults are up to date

    hr = PrivHandleAutoSync(SYNCMGRFLAG_PENDINGDISCONNECT | SYNCMGRFLAG_MAYBOTHERUSER);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::Schedule, public
//
//  Synopsis:   Handles a shceduled notification
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

const TCHAR c_szTrayWindow[]            = TEXT("Shell_TrayWnd");

STDMETHODIMP CSynchronizeInvoke::Schedule(WCHAR *pszTaskName)
{
HRESULT hr = E_UNEXPECTED;
TCHAR szConnectionName[RAS_MaxEntryName + 1];
TCHAR *pszConnectionName = szConnectionName;
CONNECTIONSETTINGS ConnectionSettings;

    if (!pszTaskName)
    {
        Assert(pszTaskName);
        return E_INVALIDARG;
    }


    // on Win9x Task Scheduler is on a per Machine basis and can fire before
    // a user has logged on or Cancels the logon dialog. Check for if
    // really logged on by seeing if the Shell Tray Window is present.

    if (VER_PLATFORM_WIN32_WINDOWS == g_OSVersionInfo.dwPlatformId)
    {
        if (NULL == FindWindow(c_szTrayWindow, NULL))
        {
            return E_UNEXPECTED;
        }
    }

    // validate this is a valid schedule and if no registry data for 
    // it then delete the .job file. 
    // Get the UserName key from the TaskName itself since on NT schedules
    // can fire if User provided as Password as a different user thant the 
    // current user.

    int OffsetToUserName = lstrlen(WSZGUID_IDLESCHEDULE)
                    + 1; // +1 for _ char between guid and user name.
    WCHAR *pszDomainAndUser = pszTaskName + OffsetToUserName;
    HKEY hkeySchedSync,hkeyDomainUser,hkeySchedName;
    LONG lRegResult;

    hkeySchedSync = hkeyDomainUser = hkeySchedName = NULL;

     // open up keys ourselves so 
    lRegResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,SCHEDSYNC_REGKEY,0,KEY_READ, &hkeySchedSync);

    if (ERROR_SUCCESS == lRegResult)
    {
        lRegResult = RegOpenKeyEx (hkeySchedSync,pszDomainAndUser,0,KEY_READ, &hkeyDomainUser);
    }

    if (ERROR_SUCCESS == lRegResult)
    {
        lRegResult = RegOpenKeyEx (hkeyDomainUser,pszTaskName,0,KEY_READ, &hkeySchedName);
    }

    // close up the keys
    if (hkeySchedName) RegCloseKey(hkeySchedName);
    if (hkeyDomainUser) RegCloseKey(hkeyDomainUser);
    if (hkeySchedSync) RegCloseKey(hkeySchedSync);

    // if any of the keys are bad then nix the TS file and return;
    if ( ERROR_FILE_NOT_FOUND  == lRegResult)
    {
        // TODO: Call function to delete this .job file when
        // it is implemented for now just let it fire each time.

        return E_UNEXPECTED;
    }

    // assert is just so it fires if a new Error code occurs
    // so we make sure we handle it properly

    Assert(ERROR_SUCCESS == lRegResult);


    // Now see if on Win9x schedule applies to the current User and if not just 
    // bail.

   if (VER_PLATFORM_WIN32_NT != g_OSVersionInfo.dwPlatformId)
   {
    TCHAR szDomainUserName[MAX_DOMANDANDMACHINENAMESIZE];
 
        GetDefaultDomainAndUserName(szDomainUserName,TEXT("_"), MAX_DOMANDANDMACHINENAMESIZE);
    
        // !!!using strnicmp just since it is not case sensitive. Can switch
        // to add verify that the lstrcmpi funciton works but I don't want
        // to risk this for IE ship (rogerg)

        if (0 != strnicmp(szDomainUserName,pszDomainAndUser,lstrlen(szDomainUserName)) )
        {
            return NOERROR;
        }
   }


    // check to see if this is really and idle and if so foward on to Idle
    // method

   WCHAR *pszSchedCookieIdle = WSZGUID_IDLESCHEDULE;
   int comparelength = (sizeof(WSZGUID_IDLESCHEDULE)/sizeof(WCHAR)) -1; // don't compare null

                   
     // set the Idle flag instead
    // Note: the strnicmp function is a method on this class not the runtime call.
    if (0 == strnicmp(pszSchedCookieIdle,pszTaskName,comparelength))
    {
        return Idle();
    }


    // finally made it past verification if you can get a Connection
    // you can run the schedule.

    if (RegGetSchedConnectionName(pszTaskName,pszConnectionName,ARRAY_SIZE(szConnectionName)))
    {
    BOOL fCanMakeConnection = FALSE;
    DWORD cbCookie = (lstrlen(pszTaskName) + 1)*(sizeof(WCHAR)/sizeof(BYTE));



        // if this is a valid schedule then go ahead and read in the settings
        // by default don't let the connection be made.

        lstrcpy(ConnectionSettings.pszConnectionName,pszConnectionName);
        if (RegGetSchedSyncSettings(&ConnectionSettings,pszTaskName))
        {
            fCanMakeConnection = ConnectionSettings.dwMakeConnection;
        }



        // if this schedule can't make the connectione then
        // check to see if the conneciton is available and if
        // it isn't bail here.

        BOOL fConnectionAvailable = FALSE;

        if (!fCanMakeConnection)
        {
            if (S_OK == ConnectObj_IsConnectionAvailable(pszConnectionName))
            {
                fConnectionAvailable = TRUE;
            }
        }

        // add to the queue and let the main progress determine if
        // can handle the schedule.
    
        if (fCanMakeConnection || fConnectionAvailable)
        {
            // on a schedule we pass in the schedule name for the cookie data.
             hr = PrivUpdateAll(SYNCMGRINVOKE_STARTSYNC | SYNCMGRINVOKE_MINIMIZED,SYNCMGRFLAG_SCHEDULED,
                  cbCookie,(BYTE *) pszTaskName,1,&pszConnectionName,pszTaskName,fCanMakeConnection,NULL,0,0,FALSE);
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {

       AssertSz(0,"Schedule has no Connection");
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::Idle, public
//
//  Synopsis:   Handles an Idle Notifications
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    20-Feb-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::Idle()
{
HRESULT hr = E_UNEXPECTED;

    // request the idle Lock, If someone already has it then just return.
    if (NOERROR == (hr = RequestIdleLock()))
    {

        hr = RunIdle();

        // if an error occured setting things up or nothing to do
        // then release our idle lock.
         if (NOERROR != hr)
         {
            ReleaseIdleLock();
         }

    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::RunIdle, public
//
//  Synopsis:   Runs an Idle.
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    20-Feb-98      rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::RunIdle()
{
    // for not just run the Idle as a Connect
    return PrivHandleAutoSync(SYNCMGRFLAG_IDLE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::RasPendingDisconnect, private
//
//  Synopsis:   Handles a programmatic Ras Pending Disconnect calls.
//
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::RasPendingDisconnect(DWORD cbConnectionName,
                    const BYTE *lpConnectionName)
{
HRESULT hr = E_OUTOFMEMORY;
CONNECTIONOBJ *pConnectionObj;

    // Thread with class factory is FreeThreaded so can block the return
    // until update is complete.

    // find connection object for this item so know its liveness.
    hr = ConnectObj_FindConnectionObj( (TCHAR*) lpConnectionName,TRUE,&pConnectionObj);

    if (NOERROR == hr)
    {
    HANDLE hRasPendingEvent;


        if (NOERROR == (hr = ConnectObj_GetConnectionObjCompletionEvent(pConnectionObj,&hRasPendingEvent)))
        {

            hr = PrivAutoSyncOnConnection(SYNCMGRFLAG_PENDINGDISCONNECT | SYNCMGRFLAG_MAYBOTHERUSER,
                1,(TCHAR **) &lpConnectionName,hRasPendingEvent);


            // if successfully invoked the connection then wait for the event
            // object to get set,

            if (NOERROR == hr && hRasPendingEvent)
            {
                WaitForSingleObject(hRasPendingEvent,INFINITE);  // review if can determine a timeout
            }
            else
            {
                // !!!!on failure call close the Connection to make sure
                // the object gets cleaned up in case the progress queue didn't get kicked off.
                // If someone is currently using a connection they will be closed which is
                // the same as if autosync wasn't selected and the User chose to
                // close while a sync was in progress.

                ConnectObj_CloseConnection(pConnectionObj);
            }

            // Release our hold on the Connection.
            ConnectObj_ReleaseConnectionObj(pConnectionObj);

            if (hRasPendingEvent)
            {
                CloseHandle(hRasPendingEvent);
            }
        }

    }

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Member:     QueryLoadHandlerOnEvent, private
//
//  Synopsis:   Determines if Handle needs to be loaded for the specified
//              Event and Connection.
//
//
//  Arguments:  [pszClsid] - clsid of handler
//              [dwSyncFlags] - SyncFlags to pass onto initialize
//              [cbNumConnectionNames] - Number of ConnectionNames in array
//              [ppConnectionNames] - array of connection names.
//
//  Returns:    TRUE - handler needs to be loaded
//              FALSE - handler doesn't need to be loaded.
//
//  Modifies:
//
//  History:    24-Aug-98      rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL QueryLoadHandlerOnEvent(TCHAR *pszClsid,DWORD dwSyncFlags,DWORD dwRegistrationFlags,
                                             DWORD cbNumConnectionNames,TCHAR **ppConnectionNames)
{
BOOL fLoadHandler = TRUE;
DWORD dwSyncEvent = dwSyncFlags & SYNCMGRFLAG_EVENTMASK;

    // see if handler is registered for the event
    // if it is then we always load it. If its not the User had to have checked an item
    if (
           ( (dwSyncEvent == SYNCMGRFLAG_IDLE) && !(dwRegistrationFlags & SYNCMGRREGISTERFLAG_IDLE) )
        || ( (dwSyncEvent == SYNCMGRFLAG_CONNECT) && !(dwRegistrationFlags & SYNCMGRREGISTERFLAG_CONNECT) )
        || ( (dwSyncEvent == SYNCMGRFLAG_PENDINGDISCONNECT) && !(dwRegistrationFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) )
       )
    {
    DWORD cbCurConnectionName;

        fLoadHandler = FALSE;

        for (cbCurConnectionName = 0 ; cbCurConnectionName < cbNumConnectionNames;cbCurConnectionName++)
        {
            fLoadHandler |= RegQueryLoadHandlerOnEvent(pszClsid,dwSyncFlags,ppConnectionNames[cbCurConnectionName]);
        }
    }

    return fLoadHandler;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::PrivUpdateAll, private
//
//  Synopsis:   Handles a programmatic UpdateAll call.
//
//              !!Warning - Liveness relies on a dialog being created
//                      before return or we could go away when the
//                      caler releases our interface.
//
//  Arguments:  [dwInvokeFlags] - InvokeFlags
//              [dwSyncFlags] - SyncFlags to pass onto initialize
//              [pszConnectionName] - array of connection names.
//              [pszScheduleName] - Name of schedule that was fired if a scheduled event.
//
//  Returns:    S_OK/NOERROR - If handled result
//              S_FALSE - if nothing to do (such as no items selected on Idle).
//              error codes - if errors occured
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::PrivUpdateAll(DWORD dwInvokeFlags,DWORD dwSyncFlags,
                                DWORD cbCookie,const BYTE *lpCooke,
                                DWORD cbNumConnectionNames,TCHAR **ppConnectionNames,
                                TCHAR *pszScheduleName,BOOL fCanMakeConnection,HANDLE hRasPendingDisconnect,
                                ULONG ulIdleRetryMinutes,ULONG ulDelayIdleShutDownTime,BOOL fRetryEnabled)
{
HRESULT hr = E_OUTOFMEMORY;
CHndlrQueue * pHndlrQueue = NULL;
CLSID clsidChoice = GUID_NULL;
CChoiceDlg *pChoiceDlg = NULL;
JOBINFO *pJobInfo = NULL;
int nCmdShow = (dwInvokeFlags & SYNCMGRINVOKE_MINIMIZED) ? SW_SHOWMINIMIZED : SW_SHOWNORMAL;
DWORD dwSyncEvent = (dwSyncFlags & SYNCMGRFLAG_EVENTMASK);

    // On an UpdateAll
    //   1 - see if there is an existing UpdateAll choice, If so bring to foreground
    //   2 - Bring up update All choice dialog.

    // behavior - If already an Update All choice dialog just pull it to the Front
    //            If Already an UpdateAll progress bar bring it to the front
    //            If Progress Bar but doesn't already contain an updateAll create the choice dialog.

#if _ZAWTRACK
    LogZawTrack(dwSyncFlags); // Track any invokes.
#endif _ZAWTRACK

    Assert(NULL != ppConnectionNames && cbNumConnectionNames >= 1);
    Assert(NULL == pszScheduleName || (SYNCMGRFLAG_SCHEDULED == dwSyncEvent)
            || (SYNCMGRFLAG_IDLE == dwSyncEvent)  ); // review, temporary for idle.

    pHndlrQueue = new CHndlrQueue(QUEUETYPE_CHOICE,NULL);

    if (NULL == pHndlrQueue)
        return E_OUTOFMEMORY;

    hr = pHndlrQueue->AddQueueJobInfo(dwSyncFlags,cbNumConnectionNames,
                                        ppConnectionNames,pszScheduleName,fCanMakeConnection
                                        ,&pJobInfo);

    // loop through the reg getting the handlers and trying to
    // create them.

    if (NOERROR == hr)
    {
    TCHAR lpName[256];
    DWORD cbName = 256;
    HKEY hkOneStop;
    CLSID clsid;
    HANDLERINFO *pHandlerID;
    BOOL fItemsInQueue = FALSE;

        hkOneStop = RegGetHandlerTopLevelKey(KEY_READ);

        if (hkOneStop)
        {
        DWORD dwIndex = 0;


            while ( ERROR_SUCCESS == RegEnumKey(hkOneStop,dwIndex,
                    lpName,cbName) )
            {
                if (NOERROR == CLSIDFromString(lpName,&clsid) )
                {
                BOOL fReg;
                DWORD dwRegistrationFlags;
                BOOL fLoadHandler = TRUE;

                    fReg = RegGetHandlerRegistrationInfo(clsid,&dwRegistrationFlags);
                    Assert(fReg || (0 == dwRegistrationFlags));
                    
                    //For scheduled, see if there are any items on this handler,

                    if ((SYNCMGRINVOKE_STARTSYNC & dwInvokeFlags) &&
                        (SYNCMGRFLAG_SCHEDULED == dwSyncEvent))
                    {
                        fLoadHandler = RegSchedHandlerItemsChecked(lpName, ppConnectionNames[0],pszScheduleName);
                    }
                    else if (SYNCMGRINVOKE_STARTSYNC & dwInvokeFlags)
                    {
                        fLoadHandler =  QueryLoadHandlerOnEvent(lpName,dwSyncFlags,dwRegistrationFlags,
                                                 cbNumConnectionNames,ppConnectionNames);
                    }

                    if (fLoadHandler)
                    {
                        if (NOERROR == pHndlrQueue->AddHandler(&pHandlerID,pJobInfo,dwRegistrationFlags))
                        {
                            pHndlrQueue->CreateServer(pHandlerID,&clsid);
                        }
                    }

                }

                dwIndex++;
            }

            RegCloseKey(hkOneStop);
        }

        // Initialize the items.

        CLSID pHandlerClsid;

        while (NOERROR == pHndlrQueue->FindFirstHandlerInState(HANDLERSTATE_INITIALIZE,GUID_NULL,&pHandlerID,&pHandlerClsid))
        {
            pHndlrQueue->Initialize(pHandlerID,0,dwSyncFlags,
                cbCookie,lpCooke);
        }

        // can release jobinfo since handlers need to hold their own addref.
         if (pJobInfo)
        {
            pHndlrQueue->ReleaseJobInfoExt(pJobInfo);
            pJobInfo = NULL;
        }

        // if start invoke need to add the handlers items to the queue before
        // transferring

        while (NOERROR == pHndlrQueue->FindFirstHandlerInState(HANDLERSTATE_ADDHANDLERTEMS,GUID_NULL,&pHandlerID,&pHandlerClsid))
        {
        DWORD cbNumItemsAdded;

            hr = pHndlrQueue->AddHandlerItemsToQueue(pHandlerID,&cbNumItemsAdded);

            // if an item was added, then there are items in the queue
            if (cbNumItemsAdded)
            {
                fItemsInQueue = TRUE;
            }
        }

        //
        // Move handlers that won't establish connections to end
        // of handler list.
        //
        pHndlrQueue->SortHandlersByConnection();

        if (SYNCMGRINVOKE_STARTSYNC & dwInvokeFlags)
        {
        CProgressDlg *pProgressDlg;
        CLSID clsid_Progress = GUID_NULL;

            // For Idle we want to use the idle progress dialog
            // currently progress dialog relies on some globals so
            // need to change that first before checking this in
            if (SYNCMGRFLAG_IDLE == dwSyncEvent)
            {
                clsid_Progress = GUID_PROGRESSDLGIDLE;
            }

            // if not items are selected, just free the queue.
            // Review - it would be better to always call Progress and progress
            // itself not show until there are items to synchronize
            if (pHndlrQueue->AreAnyItemsSelectedInQueue())
            {

                hr = FindProgressDialog(clsid_Progress,TRUE,nCmdShow,&pProgressDlg);

                if (NOERROR == hr)
                {
                     // for an Idle we now request the defaults for retryIdle
                     // and delay shutdown, and change the queue order
                    // based on the last item
                    if (SYNCMGRFLAG_IDLE == dwSyncEvent)
                    {
                    CLSID clsidLastHandler;

                        pProgressDlg->SetIdleParams(ulIdleRetryMinutes,
                                                        ulDelayIdleShutDownTime,fRetryEnabled);

                        if (NOERROR == GetLastIdleHandler(&clsidLastHandler))
                        {
                            pHndlrQueue->ScrambleIdleHandlers(clsidLastHandler);
                        }
                    }

                     hr = pProgressDlg->TransferQueueData(pHndlrQueue);
                     ReleaseProgressDialog(clsid_Progress,pProgressDlg,FALSE);
                }
            }
            else
            {
                hr = S_FALSE; // return S_FALSE IF NOTHING TO DO.
            }


            pHndlrQueue->FreeAllHandlers(); // done with our queue.

            pHndlrQueue->Release();
            pHndlrQueue = NULL;

        }
        else
        {
        CChoiceDlg *pChoiceDlg;
        BOOL fDontShowIfNoItems = (
                (SYNCMGRFLAG_CONNECT == dwSyncEvent)
                || (SYNCMGRFLAG_PENDINGDISCONNECT == dwSyncEvent ) );
                                
            // if the choice has been requested by a logon/logoff event and 
            // there aren't any items in the queue for the User to choose then
            // if you want to turn on the code to now display anything
            // turn on this If statement. For now we always show the choice.

            if (1 /* !fDontShowIfNoItems || fItemsInQueue */)
            {

               // Bring up the Choice dialog, Let choice dialog actually addes the hanlder items
               // if there are any so in the future we can async fill in the choices

               hr = FindChoiceDialog(clsidChoice,TRUE,nCmdShow,&pChoiceDlg);

               if (S_OK == hr)
               {
                    if (FALSE == pChoiceDlg->SetQueueData(clsidChoice,pHndlrQueue) ) 
                    {
                        hr =  E_UNEXPECTED;
                    }
                    else
                    {
                        pHndlrQueue = NULL; // set queue to NULL since Choice dialog owns it now.
                    }

                    ReleaseChoiceDialog(clsidChoice,pChoiceDlg);
               }
            }

            // release our queue if still have it otherwise choice owns it.
            if (pHndlrQueue)
            {
                pHndlrQueue->FreeAllHandlers();
                pHndlrQueue->Release();
            }
        }
    }

   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::PrivHandleAutoSync, private
//
//  Synopsis:   Handles an AutoSync Update. Figures out what connections
//              if any are active and invoke an AutoSync on each one.
//
//  Arguments:  [dwSyncFlags] - SyncFlags to pass onto initialize
//
//  Returns:    S_OK - sync was started
//              S_FALSE - nothing to do
//              appropriate error codes.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::PrivHandleAutoSync(DWORD dwSyncFlags)
{
HRESULT hr = E_UNEXPECTED;
DWORD dwFlags = 0;
BOOL fAlive = FALSE;
LPNETAPI pNetApi = NULL;
DWORD cbNumWanConnections = 0;
LPRASCONN pRasConn = NULL;

    pNetApi = gSingleNetApiObj.GetNetApiObj();

    if (NULL == pNetApi)
        return S_FALSE;

    g_InAutoSync = TRUE;

    if (fAlive = pNetApi->IsNetworkAlive(&dwFlags))
    {
    TCHAR **pConnections; // array of connection names. End with NULL;
    ULONG ulConnectionCount = 0;

        if (NETWORK_ALIVE_LAN & dwFlags)
        {
            // We curently don't care about these error results.
            // PrivAutoSyncOnConnection(dwSyncFlags,LANCONNECTIONNAME,NULL);
            // Review what we want this to do.
            ulConnectionCount += 1;
        }

           // loop through Ras Connections.
        if ( NETWORK_ALIVE_WAN & dwFlags)
        {
            if (NOERROR == pNetApi->GetWanConnections(&cbNumWanConnections,&pRasConn)
                    && (NULL != pRasConn) )
            {
                ulConnectionCount += cbNumWanConnections;
            }
            else
            {
                cbNumWanConnections = 0;
                pRasConn = NULL;
            }
        }
         // allocate array buffer for connections + 1 more for NULL
        if (ulConnectionCount
                && (pConnections = (TCHAR **) ALLOC(sizeof(TCHAR *)*(ulConnectionCount + 1))))
        {
        TCHAR **pCurConnection = pConnections;
        TCHAR *pLanConnection = NULL;
            // initialize the array.

            if (NETWORK_ALIVE_LAN & dwFlags)
            {
                pLanConnection = (TCHAR *) ALLOC(sizeof(TCHAR )*(MAX_PATH + 1));
                
                if (pLanConnection)
                {
                    if (LoadString(g_hInst, IDS_LAN_CONNECTION, pLanConnection, MAX_PATH))
                    {
                        *pCurConnection = pLanConnection;
                        ++pCurConnection;
                    }
                }
            }

            while (cbNumWanConnections)
            {
                cbNumWanConnections--;
                *pCurConnection = pRasConn[cbNumWanConnections].szEntryName;
                ++pCurConnection;
            }

            *pCurConnection = NULL; // set the last connection to NULL;

            // now autosync these puppies
            hr = PrivAutoSyncOnConnection(dwSyncFlags,ulConnectionCount,pConnections,NULL);

            if (pLanConnection)
            {
                FREE(pLanConnection);
            }

            if (pRasConn)
            {
                pNetApi->FreeWanConnections(pRasConn);
            }

            if (pConnections)
            {
                FREE(pConnections);
            }

        }
    }

    g_InAutoSync = FALSE;

    if ( pNetApi != NULL )
        pNetApi->Release();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::PrivAutoSyncOnConnection, private
//
//  Synopsis:   Handles an AutoSync Update. Given the SyncFlags and Connection
//              determines if anything should be done on this connection
//              and if so invokes it.
//
//  Arguments:  [dwSyncFlags] - SyncFlags to pass onto initialize
//              [ppConnectionNames] - array of connectnames that apply to this request
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    08-Dec-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::PrivAutoSyncOnConnection(DWORD dwSyncFlags,DWORD cbNumConnectionNames,
                                 TCHAR **ppConnectionNames,HANDLE hRasPendingEvent)
{
CONNECTIONSETTINGS ConnectSettings;
DWORD dwSyncEvent;
TCHAR **ppWorkerConnectionNames = NULL;
DWORD cbNumWorkerConnections = 0;
DWORD cbIndexCheck;
DWORD dwPromptMeFirst = 0;
ULONG ulIdleRetryMinutes;
ULONG ulDelayIdleShutDownTime;
BOOL fRetryEnabled = FALSE;
HRESULT hr = S_FALSE;

    // assert there is at least one connection in the request
    Assert(NULL != ppConnectionNames && cbNumConnectionNames >= 1);

    if (NULL == ppConnectionNames || 0 == cbNumConnectionNames )
        return S_FALSE;

    if (NULL ==
            (ppWorkerConnectionNames = (TCHAR **) ALLOC(sizeof(TCHAR**) * cbNumConnectionNames)))
    {
        return E_OUTOFMEMORY;
    }

    dwSyncEvent = (dwSyncFlags & SYNCMGRFLAG_EVENTMASK);

    // loop through all the connections and move any of the ones that
    // are valid into our ppWorkerConnections name array.

    TCHAR **ppCurWorkerConnectionNamesIndex = ppWorkerConnectionNames;
    TCHAR **ppConnectionsNameIndex = ppConnectionNames;

    for (cbIndexCheck = 0; cbIndexCheck < cbNumConnectionNames; cbIndexCheck++)
    {

        lstrcpy(ConnectSettings.pszConnectionName,*ppConnectionsNameIndex);

        // See if should do anything on this connection.
        if (RegGetSyncSettings(SYNCMGRFLAG_IDLE == dwSyncEvent
                    ? SYNCTYPE_IDLE : SYNCTYPE_AUTOSYNC,&ConnectSettings))
        {
            if ( (((SYNCMGRFLAG_CONNECT == dwSyncEvent) && ConnectSettings.dwLogon))
               ||(((SYNCMGRFLAG_PENDINGDISCONNECT == dwSyncEvent) && ConnectSettings.dwLogoff))
               ||(((SYNCMGRFLAG_IDLE == dwSyncEvent) && ConnectSettings.dwIdleEnabled))
                )
            {
                *ppCurWorkerConnectionNamesIndex = *ppConnectionsNameIndex;
                ++ppCurWorkerConnectionNamesIndex;
                ++cbNumWorkerConnections;

                // update the variables for connection, for autosync if dwPromptMeFirst
                // is set on any match connection
                switch (dwSyncEvent)
                {
                case SYNCMGRFLAG_IDLE:

                    // minimum retry idle values win.
                    if (1 == cbNumWorkerConnections ||
                                ConnectSettings.ulIdleRetryMinutes < ulIdleRetryMinutes)
                    {
                        ulIdleRetryMinutes = ConnectSettings.ulIdleRetryMinutes;
                    }


                    // maximum wait for shutdown wins.
                     if (1 == cbNumWorkerConnections ||
                                ConnectSettings.ulDelayIdleShutDownTime > ulDelayIdleShutDownTime)
                    {
                        ulDelayIdleShutDownTime = ConnectSettings.ulDelayIdleShutDownTime;
                    }

                    // if any connection has retry after xxx minutes set to bool then retry
                     if (ConnectSettings.dwRepeatSynchronization)
                    {
                        fRetryEnabled = TRUE;
                    }

                    break;
                case SYNCMGRFLAG_PENDINGDISCONNECT:
                case SYNCMGRFLAG_CONNECT:
                    // if any connection is set to prompt then prompt.
                    if (ConnectSettings.dwPromptMeFirst)
                    {
                        dwPromptMeFirst = ConnectSettings.dwPromptMeFirst;
                    }
                    break;
                }
            }
        }

        ++ppConnectionsNameIndex;
    }


    // if we found any connections to actually do work on start the sync off.
    if (cbNumWorkerConnections > 0)
    {
    DWORD dwInvokeFlag = 0;

        switch (dwSyncEvent)
        {
        case SYNCMGRFLAG_IDLE:
            dwInvokeFlag |=  SYNCMGRINVOKE_MINIMIZED | SYNCMGRINVOKE_STARTSYNC;
            break;
        case SYNCMGRFLAG_PENDINGDISCONNECT:
        case SYNCMGRFLAG_CONNECT:
            if (!dwPromptMeFirst)
            {
                dwInvokeFlag |= SYNCMGRINVOKE_STARTSYNC;
            }
            break;
        default:
            AssertSz(0,"Unknown SyncEvent");
            break;
        }

        // perform the Update
        hr = PrivUpdateAll(dwInvokeFlag,dwSyncFlags,0,NULL,
                        cbNumWorkerConnections,
                        ppWorkerConnectionNames,NULL,FALSE,hRasPendingEvent,
                        ulIdleRetryMinutes,
                        ulDelayIdleShutDownTime,fRetryEnabled);
    }

    if (ppWorkerConnectionNames)
    {
        FREE(ppWorkerConnectionNames);
    }

    return hr;
}

// default Unknown implementation


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::CPrivUnknown::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::CPrivUnknown::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(riid, IID_IPrivSyncMgrSynchronizeInvoke))
    {
        *ppv = (IPrivSyncMgrSynchronizeInvoke *) m_pSynchInvoke;
    }
#ifdef _SENS


    else if (IsEqualIID(riid, IID_ISensNetwork))
    {
        *ppv = (ISensNetwork *) &(m_pSynchInvoke->m_PrivSensNetwork);
    }

    else if (IsEqualIID(riid, IID_ISensLogon))
    {
        *ppv = (ISensLogon *) &(m_pSynchInvoke->m_PrivSensLogon);
    }

    // in final this shouldn't return anything until LCE change, change
    // depending on which interface we want to test.

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppv = &(m_pSynchInvoke->m_PrivSensLogon);
    }
#endif // _SENS

    if (*ppv)
    {
        m_pSynchInvoke->m_pUnkOuter->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::CPrivUnknown::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivUnknown::AddRef()
{
ULONG cRefs;

    cRefs = InterlockedIncrement((LONG *)& m_pSynchInvoke->m_cRef);
    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSychrononizeInvoke::CPrivUnknown::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivUnknown::Release()
{
ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_pSynchInvoke->m_cRef);

    if (0 == cRefs)
    {
        delete m_pSynchInvoke;
    }

    return cRefs;
}



#ifdef _SENS

// SENS Network connect Interfaces

STDMETHODIMP CSynchronizeInvoke::CPrivSensNetwork::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    return m_pSynchInvoke->m_pUnkOuter->QueryInterface(riid,ppv);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivSensNetwork::AddRef()
{
    return m_pSynchInvoke->m_pUnkOuter->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSychrononizeInvoke::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivSensNetwork::Release()
{
    return m_pSynchInvoke->m_pUnkOuter->Release();

}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    *pCountITypeInfo = 1;
    return NOERROR;
}


STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
HRESULT hr;

    if (iTypeInfo != 0)
    {
        return DISP_E_BADINDEX;
    }

    if (NOERROR == (hr = m_pSynchInvoke->GetNetworkTypeInfo()))
    {
        // if got a typelib addref it and hand it out.
        m_pSynchInvoke->m_pITypeInfoNetwork->AddRef();
        *ppITypeInfo = m_pSynchInvoke->m_pITypeInfoNetwork;
    }

    return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
HRESULT hr;

    if (NOERROR == (hr = m_pSynchInvoke->GetNetworkTypeInfo()))
    {
         hr = m_pSynchInvoke->m_pITypeInfoNetwork->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );
    }

    return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
HRESULT hr;

    if (NOERROR == (hr = m_pSynchInvoke->GetNetworkTypeInfo()))
    {
         hr = m_pSynchInvoke->m_pITypeInfoNetwork->Invoke(
                                            (IDispatch*) this,
                                           dispID,
                                           wFlags,
                                           pDispParams,
                                           pvarResult,
                                           pExecpInfo,
                                           puArgErr);
    }


  return hr;
}


STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::ConnectionMade(
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO pQOCInfo
    )
{
HRESULT hr = E_UNEXPECTED;
TCHAR pszConnectionName[RAS_MaxEntryName + 1];
TCHAR *pConnectionNameArray;
#ifndef _UNICODE
BOOL fUsedDefaultChar;
#endif // _UNICODE

    if (g_InAutoSync) // Review logic, for now if in logon just return.
    {
        return NOERROR;
    }

    RegSetUserDefaults(); // Make Sure the UserDefaults are up to date

    // if Lan connection use our hardcoded value, else use the
     // connection name given to use.

    if (ulType & NETWORK_ALIVE_LAN)
    {
        LoadString(g_hInst, IDS_LAN_CONNECTION, pszConnectionName,ARRAY_SIZE(pszConnectionName));
    }
    else
    {

    #ifdef _UNICODE
        lstrcpy(pszConnectionName , bstrConnection);
    #else
        WideCharToMultiByte(CP_ACP ,0,bstrConnection,-1,
                pszConnectionName,ARRAY_SIZE(pszConnectionName),NULL,&fUsedDefaultChar);

    #endif // _UNICODE

    }
        pConnectionNameArray = pszConnectionName;

    if (pszConnectionName)
    {
        hr = m_pSynchInvoke->PrivAutoSyncOnConnection(SYNCMGRFLAG_CONNECT | SYNCMGRFLAG_MAYBOTHERUSER,1,
                &pConnectionNameArray,
                NULL);
    }

   return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::ConnectionMadeNoQOCInfo(
    BSTR bstrConnection,
    ULONG ulType
    )
{
TCHAR *pszConnectionName;
#ifndef _UNICODE
TCHAR szwConnection[RAS_MaxEntryName + 1]; 
BOOL fUsedDefaultChar;
#endif // _UNICODE

    AssertSz(0,"ConnectionMadeNoQOCInfo called");

#ifdef _UNICODE
    pszConnectionName = bstrConnection;
#else
    WideCharToMultiByte(CP_ACP ,0,bstrConnection,-1,
            szwConnection,ARRAY_SIZE(szwConnection),NULL,&fUsedDefaultChar);

     pszConnectionName = szwConnection;
#endif // _UNICODE



    //  m_pSynchInvoke->PrivAutoSyncOnConnection(SYNCMGRFLAG_CONNECT,pszConnectionName,
        //              NULL);

   return NOERROR;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::ConnectionLost(
    BSTR bstrConnection,
    ULONG ulType
    )
{

    return NOERROR;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::BeforeDisconnect(
    BSTR bstrConnection,
    ULONG ulType
    )
{

    return NOERROR;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::DestinationReachable(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType,
    LPSENS_QOCINFO pQOCInfo
    )
{
    return NOERROR;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensNetwork::DestinationReachableNoQOCInfo(
    BSTR bstrDestination,
    BSTR bstrConnection,
    ULONG ulType
    )
{
   return NOERROR;
}


// ISensLogon/Logoff Events


STDMETHODIMP CSynchronizeInvoke::CPrivSensLogon::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    return m_pSynchInvoke->m_pUnkOuter->QueryInterface(riid,ppv);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::AddRef, public
//
//  Synopsis:   Add reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivSensLogon::AddRef()
{
    return m_pSynchInvoke->m_pUnkOuter->AddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSychrononizeInvoke::Release, public
//
//  Synopsis:   Release reference
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSynchronizeInvoke::CPrivSensLogon::Release()
{
    return m_pSynchInvoke->m_pUnkOuter->Release();

}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensLogon::GetTypeInfoCount(
    UINT *pCountITypeInfo
    )
{
    *pCountITypeInfo = 1;
    return NOERROR;
}


STDMETHODIMP
CSynchronizeInvoke::CPrivSensLogon::GetTypeInfo(
    UINT iTypeInfo,
    LCID lcid,
    ITypeInfo **ppITypeInfo
    )
{
HRESULT hr;

    if (iTypeInfo != 0)
    {
        return DISP_E_BADINDEX;
    }

    if (NOERROR == (hr = m_pSynchInvoke->GetLogonTypeInfo()))
    {
        // if got a typelib addref it and hand it out.
        m_pSynchInvoke->m_pITypeInfoLogon->AddRef();
        *ppITypeInfo = m_pSynchInvoke->m_pITypeInfoLogon;
    }

    return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensLogon::GetIDsOfNames(
    REFIID riid,
    LPOLESTR *arrNames,
    UINT cNames,
    LCID lcid,
    DISPID *arrDispIDs)
{
HRESULT hr;

    if (NOERROR == (hr = m_pSynchInvoke->GetLogonTypeInfo()))
    {
         hr = m_pSynchInvoke->m_pITypeInfoLogon->GetIDsOfNames(
                               arrNames,
                               cNames,
                               arrDispIDs
                               );
    }

    return hr;
}

STDMETHODIMP
CSynchronizeInvoke::CPrivSensLogon::Invoke(
    DISPID dispID,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS *pDispParams,
    VARIANT *pvarResult,
    EXCEPINFO *pExecpInfo,
    UINT *puArgErr
    )
{
HRESULT hr;

    if (NOERROR == (hr = m_pSynchInvoke->GetLogonTypeInfo()))
    {
         hr = m_pSynchInvoke->m_pITypeInfoLogon->Invoke(
                                            (IDispatch*) this,
                                           dispID,
                                           wFlags,
                                           pDispParams,
                                           pvarResult,
                                           pExecpInfo,
                                           puArgErr);
    }


  return hr;
}

STDMETHODIMP CSynchronizeInvoke::CPrivSensLogon::Logon(BSTR bstrUserName)
{

  m_pSynchInvoke->Logon();

  return NOERROR;

}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::Logoff(BSTR bstrUserName)
{

    m_pSynchInvoke->Logoff();

    return NOERROR;

}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::Startup(BSTR bstrUserName)
{
    return NOERROR;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::StartShell(BSTR bstrUserName)
{
    return NOERROR;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::Shutdown(BSTR bstrUserName)
{
    return NOERROR;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::DisplayLock(BSTR bstrUserName)
{
    return NOERROR;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::DisplayUnlock(BSTR bstrUserName)
{
    return NOERROR;
}

STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::StartScreenSaver(BSTR bstrUserName)
{
    return NOERROR;
}


STDMETHODIMP  CSynchronizeInvoke::CPrivSensLogon::StopScreenSaver(BSTR bstrUserName)
{
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::GetLogonTypeInfo, private
//
//  Synopsis:   Loads the TypeInfo object for the Sens
//              Logon Information.
//
//  Arguments:
//
//  Returns:   NOERROR if successfully loaded the TypeInfo.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//+---------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::GetLogonTypeInfo()
{
HRESULT hr;
ITypeLib *pITypeLib;

    if (m_pITypeInfoLogon)
        return NOERROR;

    hr = LoadRegTypeLib(
                 LIBID_SensEvents,
                 1 /* MAJOR_VER */ ,
                 0 /* MINOR_VER */ ,
                 0 /* DEFAULT_LCID */,
                 &pITypeLib
                 );

    if (NOERROR == hr)
    {

         hr = pITypeLib->GetTypeInfoOfGuid(
                     IID_ISensLogon,
                     &m_pITypeInfoLogon
                     );

        pITypeLib->Release();
    }


    if (NOERROR != hr)
    {
        m_pITypeInfoLogon = NULL; // don't rely on call not to leave this alone.
    }

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Member:     CSynchronizeInvoke::GetNetworkTypeInfo, private
//
//  Synopsis:   Loads the TypeInfo object for the Sens
//              Network Information.
//
//  Arguments:
//
//  Returns:   NOERROR if successfully loaded the TypeInfo.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//+---------------------------------------------------------------------------

STDMETHODIMP CSynchronizeInvoke::GetNetworkTypeInfo()
{
HRESULT hr;
ITypeLib *pITypeLib;

    if (m_pITypeInfoNetwork)
        return NOERROR;


    hr = LoadRegTypeLib(
                 LIBID_SensEvents,
                 1 /* MAJOR_VER */ ,
                 0 /* MINOR_VER */ ,
                 0 /* DEFAULT_LCID */,
                 &pITypeLib
                 );

    if (NOERROR == hr)
    {

         hr = pITypeLib->GetTypeInfoOfGuid(
                     IID_ISensNetwork,
                     &m_pITypeInfoNetwork
                     );

        pITypeLib->Release();
    }

    if (NOERROR != hr)
    {
        m_pITypeInfoNetwork = NULL; // don't rely on call not to leave this alone.
    }

    return hr;
}




#endif // _SENS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\idle.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       idle.h
//
//  Contents:   Idle notification routines.
//
//  Classes:
//
//  Notes:
//
//  History:    23-Feb-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCMGRIDLE_
#define _SYNCMGRIDLE_

// this is a copy of msidle.h routines we need since msidle.h is not defined in public

typedef void (WINAPI* _IDLECALLBACK) (DWORD dwState);

#define STATE_USER_IDLE_BEGIN       1
#define STATE_USER_IDLE_END         2

//
// BeginIdleDetection - start monitoring idleness
//
// pfnCallback - function to call back when idle state changes
// dwIdleMin - minutes of inactivity before idle callback
// dwReserved - must be 0
//
// Returns: 0 on success, error code on failure
//
// Note: Exported as ordinal 3
//
DWORD BeginIdleDetection(_IDLECALLBACK pfnCallback, DWORD dwIdleMin, DWORD dwReserved);

typedef DWORD (WINAPI* _BEGINIDLEDETECTION) (_IDLECALLBACK, DWORD, DWORD);

//
// EndIdleDetection - stop monitoring idleness
//
// Returns: TRUE on success, FALSE on failure
//
// Note: Exported as ordinal 4
//
BOOL EndIdleDetection(DWORD dwReserved);

typedef BOOL (WINAPI* _ENDIDLEDETECTION) (DWORD);

//
// SetIdleTimeout - Set minutes for idle timeout and reset idle state
//
// dwMinutes - new minutes threshold for idleness
// fResetState - flag to return to non-idle state to retrigger idle callback
// dwReserved - must be 0
//
// Note: Exported as ordinal 5
//
BOOL SetIdleTimeout(DWORD dwMinutes, DWORD dwReserved);

typedef BOOL (WINAPI* _SETIDLETIMEOUT) (DWORD, DWORD);

//
// SetIdleNotify - Turns on or off notification when idle
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 6
//
void SetIdleNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETIDLENOTIFY) (BOOL, DWORD);

//
// SetBusyNotify - Turns on or off notification when busy
//
// fNotify - flag whether to notify or not
// dwReserved - must be 0
//
// Note: Exported as ordinal 7
//
void SetBusyNotify(BOOL fNotify, DWORD dwReserved);

typedef void (WINAPI* _SETBUSYNOTIFY) (BOOL, DWORD);

//
// GetIdleMinutes
//
// dwReserved - must be 0
//
// Returns number of minutes since user's last activity
//
// Note: Exported as ordinal 8
//
DWORD GetIdleMinutes(DWORD dwReserved);

typedef DWORD (WINAPI* _GETIDLEMINUTES) (DWORD);


// end of msidle.h copy

class CProgressDlg;

void WINAPI IdleCallback(DWORD dwState); // callback for registering with Idle.

class CSyncMgrIdle
{
public:
    CSyncMgrIdle();
    ~CSyncMgrIdle();

    BOOL Initialize();

    DWORD BeginIdleDetection(CProgressDlg *pProgressDlg,DWORD dwIdleMin, DWORD dwReserved);
    DWORD ReRegisterIdleDetection(CProgressDlg *pProgressDlg);
    DWORD ResetIdle(ULONG ulIdleRetryMinutes);
    void OffIdle();
    void OnIdle();
    void CheckForIdle();

private:
    BOOL LoadMsIdle();

    HINSTANCE m_hInstMsIdleDll;
    _BEGINIDLEDETECTION m_pBeginIdleDetection;
    _ENDIDLEDETECTION m_pEndIdleDetection;
    _GETIDLEMINUTES m_pGetIdleMinutes;
    _SETBUSYNOTIFY m_pSetBusyNotify;
    _SETIDLENOTIFY m_pSetIdleNotify;
    _SETIDLETIMEOUT m_pSetIdleTimeout;

    BOOL m_fInBeginIdleDetection;
    DWORD_PTR m_dwRegisteredTimer;
    BOOL m_fReceivedOffIdle;
    CProgressDlg *m_pProgressDlg;

    friend void WINAPI IdleCallback(DWORD dwState);
    friend VOID CALLBACK IdleOnTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime);
};




#endif // _SYNCMGRIDLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\idle.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       idle.cpp
//
//  Contents:   Idle notification routines.
//
//  Classes:
//
//  Notes:
//
//  History:    23-Feb-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// msidle  DLL and function strings
STRING_FILENAME(szMsIdleDll, "MsIdle.dll");

#define BEGINIDLEDETECTIONORD 3
#define ENDIDLEDETECTIONORD   4
#define SETIDLETIMEOUTORD     5
#define SETIDLENOTIFYORD      6
#define SETBUSYNOTIFYORD      7
#define GETIDLEMINUTESORD     8


CSyncMgrIdle *g_SyncMgrIdle = NULL; // idle that has a current callback.

//+---------------------------------------------------------------------------
//
//  Member:     IdleCallback, private
//
//  Synopsis:   callback function for Idle, Only one idle registration
//		is allowed per SyncMgrInstance.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void WINAPI IdleCallback(DWORD dwState)
{

    if (STATE_USER_IDLE_END == dwState)
    {

	if (g_SyncMgrIdle)
	{

	    g_SyncMgrIdle->m_fReceivedOffIdle = TRUE;

	    // if we have a registered timer for reset Idle remove it.
	    if (g_SyncMgrIdle->m_dwRegisteredTimer)
	    {
		KillTimer(0,g_SyncMgrIdle->m_dwRegisteredTimer);
	    }


	    g_SyncMgrIdle->m_pSetBusyNotify(FALSE,0); // only allow one busy to come through
	    g_SyncMgrIdle->m_pSetIdleNotify(FALSE,0); // don't allow an Idle through after get a busy.
	    g_SyncMgrIdle->OffIdle();
	}

    }
/*

    User the TimerProc instead.
    else if (STATE_USER_IDLE_BEGIN == dwState)
    {

	// On an Idle Begin just send another Idle.
	if (g_SyncMgrIdle)
	{
	    g_SyncMgrIdle->m_pSetIdleNotify(FALSE,0);
	    g_SyncMgrIdle->OnIdle();
	}
    }
*/

}

//+---------------------------------------------------------------------------
//
//  Member:     TimerCallback, private
//
//  Synopsis:   callback function for Timer when minutes have passed
//		for when to restart the Idle.
//		
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

VOID CALLBACK IdleOnTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime)
{

    if (g_SyncMgrIdle && !g_SyncMgrIdle->m_fReceivedOffIdle)
    {
    DWORD_PTR dwRegTimer = g_SyncMgrIdle->m_dwRegisteredTimer;

	g_SyncMgrIdle->m_dwRegisteredTimer = 0;
	KillTimer(0,dwRegTimer);
	g_SyncMgrIdle->OnIdle();
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::CSyncMgrIdle, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CSyncMgrIdle::CSyncMgrIdle()
{
    m_hInstMsIdleDll = NULL;
    m_pBeginIdleDetection = NULL;
    m_pEndIdleDetection = NULL;
    m_pGetIdleMinutes = NULL;
    m_pSetBusyNotify = NULL;
    m_pSetIdleNotify = NULL;
    m_pSetIdleTimeout = NULL;
    m_pProgressDlg = NULL;
    m_dwRegisteredTimer = NULL;
    m_fInBeginIdleDetection = FALSE;
    m_fReceivedOffIdle = FALSE;

    Assert(NULL == g_SyncMgrIdle); // make sure another idle doesn't exist
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::~CSyncMgrIdle, public
//
//  Synopsis:   destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CSyncMgrIdle::~CSyncMgrIdle()
{

    if (m_dwRegisteredTimer) // remove our timer.
    {
	KillTimer(0,m_dwRegisteredTimer);
    }

    // if we are in an idle detection then first remove it.
    if (m_fInBeginIdleDetection)
    {
        m_pEndIdleDetection(0);
	m_pProgressDlg = NULL;
	g_SyncMgrIdle = NULL;
    }
    else
    {
	Assert(NULL == m_pProgressDlg);
	Assert(NULL == g_SyncMgrIdle);
    }


    // if have the dll then free it.

    if (m_hInstMsIdleDll)
    {
	FreeLibrary(m_hInstMsIdleDll);
    }

}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::Initialize, public
//
//  Synopsis:   Initializes class, must be called before any other member.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CSyncMgrIdle::Initialize()
{
    return LoadMsIdle();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::BeginIdleDetection, public
//
//  Synopsis:   Registers the callback with msidle.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CSyncMgrIdle::BeginIdleDetection(CProgressDlg *pProgressDlg,DWORD dwIdleMin, DWORD dwReserved)
{
DWORD dwResult = 0;

    Assert(m_hInstMsIdleDll);

    if (!m_hInstMsIdleDll)
    {
	return -1;
    }

    // if there is already an idle registered
    // assert it is the same as what is trying to get registered
    // now and return

    Assert(FALSE == m_fInBeginIdleDetection);

    if (m_fInBeginIdleDetection)
    {
	Assert(g_SyncMgrIdle == this);
	Assert(m_pProgressDlg == pProgressDlg);
	return 0;
    }

    Assert(NULL == g_SyncMgrIdle); // should not still be another Idle.

    g_SyncMgrIdle = this;
    m_pProgressDlg = pProgressDlg;

    dwResult =  m_pBeginIdleDetection(IdleCallback,30,0);

    if (0 != dwResult)
    {
	g_SyncMgrIdle = NULL;
	m_pProgressDlg = NULL;

    }
    else
    {
	m_pSetBusyNotify(TRUE,0);
	m_pSetIdleNotify(FALSE,0);

	m_fInBeginIdleDetection = TRUE;
    }

    return dwResult;
}



//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::ReRegisterIdleDetection, public
//
//  Synopsis:   ReRegisters an existing callback with MSIdle. Currently MSIdle
//              only allows one idle registration per process. If a handler comes
//              along and also wants Idle they will remove our calback. Therefore
//              until MSIdle allows multiple registrations per process we
//              reregister for Idle after each handler is called.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-April-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CSyncMgrIdle::ReRegisterIdleDetection(CProgressDlg *pProgressDlg)
{
DWORD dwResult = 0;

    Assert(m_hInstMsIdleDll);

    // this funciton should only be called after we have already begun an existing Idle detection.
    // If IdleDetection if already off for any reason don't reregister.
    if (!m_hInstMsIdleDll || !m_fInBeginIdleDetection)
    {
	return -1;
    }

    Assert(g_SyncMgrIdle == this);
    Assert(m_pProgressDlg == pProgressDlg);

    g_SyncMgrIdle = this;
    m_pProgressDlg = pProgressDlg;

    m_pEndIdleDetection(0); // Review - Need to call EndIdleDetection or MSIdle.dll will leak WindowsHooks on NT 4.0.
    dwResult =  m_pBeginIdleDetection(IdleCallback,30,0);

    if (0 != dwResult)
    {
	g_SyncMgrIdle = NULL;
	m_pProgressDlg = NULL;

    }
    else
    {
	m_pSetBusyNotify(TRUE,0);
	m_pSetIdleNotify(FALSE,0);
    }

    return dwResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::ResetIdle, public
//
//  Synopsis:   Resets the idle Counter.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CSyncMgrIdle::ResetIdle(ULONG ulIdleRetryMinutes)
{

    Assert(ulIdleRetryMinutes);

    // assert we have a callback.
    Assert(g_SyncMgrIdle);
    Assert(m_pProgressDlg );

    Assert(0 == m_dwRegisteredTimer); // don't allow nested

    // if zero is passed in then set to an hour
    if (!ulIdleRetryMinutes)
        ulIdleRetryMinutes = 60;

    m_dwRegisteredTimer = SetTimer(NULL,0,1000*60*ulIdleRetryMinutes,(TIMERPROC) IdleOnTimerProc);

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::OffIdle, public
//
//  Synopsis:   Gets Called when an OnIdle Occurs,.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void  CSyncMgrIdle::OffIdle()
{
    // when get an offIdle first thing revoke our Idle handlers

    if (g_SyncMgrIdle->m_dwRegisteredTimer)
    {
	KillTimer(0,g_SyncMgrIdle->m_dwRegisteredTimer);
        g_SyncMgrIdle->m_dwRegisteredTimer = 0;
    }

    Assert(m_fInBeginIdleDetection);

    if (m_fInBeginIdleDetection)
    {
        m_pEndIdleDetection(0);
        m_fInBeginIdleDetection = FALSE;
	g_SyncMgrIdle = NULL;
    }

    if (m_pProgressDlg)
	m_pProgressDlg->OffIdle();

    m_pProgressDlg = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::OnIdle, public
//
//  Synopsis:   Gets Called when an OffIdle Occurs,.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void  CSyncMgrIdle::OnIdle()
{
    if (m_pProgressDlg)
	m_pProgressDlg->OnIdle();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::CheckForIdle, public
//
//  Synopsis:   Gets Called by progress once in a while to make sure
//		an offIdle happened but our notification missed it.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CSyncMgrIdle::CheckForIdle()
{

    // currently don't do anything for this case. If we miss the off-Idle we
    // just continue. This function is a placeholder in case
    // we need to add this support.

}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrIdle::LoadMsIdle, private
//
//  Synopsis:   attempts to load the necessary msIdle exports.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CSyncMgrIdle::LoadMsIdle()
{
    m_hInstMsIdleDll = LoadLibrary(szMsIdleDll);

    if (m_hInstMsIdleDll)
    {
	// for now, don't return an error is GetProc Fails but check in each function.
	m_pBeginIdleDetection = (_BEGINIDLEDETECTION)
			GetProcAddress(m_hInstMsIdleDll, (LPCSTR) BEGINIDLEDETECTIONORD);

	m_pEndIdleDetection = (_ENDIDLEDETECTION)
			GetProcAddress(m_hInstMsIdleDll, (LPCSTR) ENDIDLEDETECTIONORD);

	m_pGetIdleMinutes = (_GETIDLEMINUTES)
			GetProcAddress(m_hInstMsIdleDll, (LPCSTR) GETIDLEMINUTESORD);

	m_pSetBusyNotify = (_SETBUSYNOTIFY)
			GetProcAddress(m_hInstMsIdleDll, (LPCSTR) SETBUSYNOTIFYORD);

	m_pSetIdleNotify = (_SETIDLENOTIFY)
			GetProcAddress(m_hInstMsIdleDll, (LPCSTR) SETIDLENOTIFYORD);

	m_pSetIdleTimeout = (_SETIDLETIMEOUT)
			GetProcAddress(m_hInstMsIdleDll, (LPCSTR) SETIDLETIMEOUTORD);
    }


    if (m_hInstMsIdleDll &&
	    m_pBeginIdleDetection &&
	    m_pEndIdleDetection   &&
	    m_pGetIdleMinutes &&
	    m_pSetBusyNotify  &&
	    m_pSetIdleNotify &&
	    m_pSetIdleTimeout
	 )
    {

	return TRUE;
    }


    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\invoke.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Invoke.h
//
//  Contents:   Private Invoke interface for kicking off Synchronizations
//
//  Classes:    CSynchronizeInvoke
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------


#ifndef _SYNCINVOKE_
#define _SYNCINVOKE_

#ifdef _SENS
#include <sensevts.h> // Review - must be real path 
#endif // _SENS

class CSynchronizeInvoke : public IPrivSyncMgrSynchronizeInvoke 
{

public:
    CSynchronizeInvoke(void);
    ~CSynchronizeInvoke();

    // default controlling unknown.
    class CPrivUnknown : public IUnknown
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

	inline void SetParent(CSynchronizeInvoke *pSynchInvoke) { m_pSynchInvoke = pSynchInvoke; };

    private:
	CSynchronizeInvoke *m_pSynchInvoke;
    };

    friend class CPrivUnknown;
    CPrivUnknown m_Unknown;

    //IUnknown members
    STDMETHODIMP	    QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IOfflineSynchronizeInvoke Methods
    STDMETHODIMP UpdateItems(DWORD dwInvokeFlags,REFCLSID rclsid,DWORD cbCookie,const BYTE*lpCookie);
    STDMETHODIMP UpdateAll(void);

    // private methods
    STDMETHODIMP Logon();
    STDMETHODIMP Logoff();
    STDMETHODIMP Schedule(WCHAR *pszTaskName);
    STDMETHODIMP Idle();
    STDMETHODIMP RasPendingDisconnect(DWORD cbConnectionName,const BYTE *lpConnectionName);

#ifdef _SENS

    class CPrivSensNetwork : public ISensNetwork
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

	// Dispatch Methods
	STDMETHOD (GetTypeInfoCount)    (UINT *);
	STDMETHOD (GetTypeInfo)         (UINT, LCID, ITypeInfo **);
	STDMETHOD (GetIDsOfNames)       (REFIID, LPOLESTR *, UINT, LCID, DISPID *);
	STDMETHOD (Invoke)              (DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

	// ISensNetwork
	STDMETHOD (ConnectionMade)                (BSTR, ULONG, LPSENS_QOCINFO);
	STDMETHOD (ConnectionMadeNoQOCInfo)       (BSTR, ULONG);
	STDMETHOD (ConnectionLost)                (BSTR, ULONG);
	STDMETHOD (BeforeDisconnect)              (BSTR, ULONG);
	STDMETHOD (DestinationReachable)          (BSTR, BSTR, ULONG, LPSENS_QOCINFO);
	STDMETHOD (DestinationReachableNoQOCInfo) (BSTR, BSTR, ULONG);

	inline void SetParent(CSynchronizeInvoke *pSynchInvoke) { m_pSynchInvoke = pSynchInvoke; };

	private:
	    CSynchronizeInvoke *m_pSynchInvoke;
     };

    friend class CPrivSensNetwork;
    CPrivSensNetwork m_PrivSensNetwork;

    class CPrivSensLogon : public ISensLogon
    {
    public:
        STDMETHOD(QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

	// Dispatch Methods
	STDMETHOD (GetTypeInfoCount)    (UINT *);
	STDMETHOD (GetTypeInfo)         (UINT, LCID, ITypeInfo **);
	STDMETHOD (GetIDsOfNames)       (REFIID, LPOLESTR *, UINT, LCID, DISPID *);
	STDMETHOD (Invoke)              (DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

	// ISensLogon
	STDMETHOD (Logon)(BSTR bstrUserName);
	STDMETHOD (Logoff)(BSTR bstrUserName);
	STDMETHOD (Startup)(BSTR bstrUserName);
	STDMETHOD (StartShell)(BSTR bstrUserName);
	STDMETHOD (Shutdown)(BSTR bstrUserName);
	STDMETHOD (DisplayLock)(BSTR bstrUserName);
	STDMETHOD (DisplayUnlock)(BSTR bstrUserName);
	STDMETHOD (StartScreenSaver)(BSTR bstrUserName);
	STDMETHOD (StopScreenSaver)(BSTR bstrUserName);

        inline void SetParent(CSynchronizeInvoke *pSynchInvoke) { m_pSynchInvoke = pSynchInvoke; };

	private:
	    CSynchronizeInvoke *m_pSynchInvoke;

    };

    friend class CPrivSensLogon;
    CPrivSensLogon m_PrivSensLogon;

#endif // _SENS

public:
    STDMETHODIMP RunIdle();

private:
   STDMETHODIMP PrivUpdateAll(DWORD dwInvokeFlags,DWORD dwSyncFlags,DWORD cbCookie,const BYTE *lpCooke,
	  	DWORD cbNumConnectionNames,TCHAR **ppConnectionNames,
                TCHAR *pszScheduleName,BOOL fCanMakeConnection,HANDLE hRasPendingDisconnect,
                ULONG ulIdleRetryMinutes,ULONG ulDelayIdleShutDownTime,BOOL fRetryEnabled);
   
   STDMETHODIMP PrivHandleAutoSync(DWORD dwSyncFlags);
   STDMETHODIMP PrivAutoSyncOnConnection(DWORD dwSyncFlags,DWORD cbNumConnectionNames,
                        TCHAR **ppConnectionName,
			HANDLE hRasPendingEvent);

   STDMETHODIMP GetLogonTypeInfo();
   STDMETHODIMP GetNetworkTypeInfo();


   DWORD m_cRef;
   IUnknown *m_pUnkOuter; // pointer to outer unknown.
    
   ITypeInfo *m_pITypeInfoLogon; // TypeInfo for Sens Logon Event.
   ITypeInfo *m_pITypeInfoNetwork; // TypeInfo for Sens Network Event.
};


#endif // _SYNCINVOKE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\hndlrq.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Hndlrq.h
//
//  Contents:   Keeps tracks of Handlers and UI assignments
//
//  Classes:    CHndlrQueue
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _HANDLERQUEUE_
#define _HANDLERQUEUE_

//  For Choice dialog If same item is added again first one their wins.
//  This handles the case if user previously chose properties. duplicate items
//  will be set to not synchronize even if the preference is set. this is
//  the defined behavior for AddHandlerItemsToQueue.
//
//  Progress dialog all items get synchronized as they were added. To move
//  items to the Progress queue always use the TransferQueueData method. If Item
//  was previously skipped what should we do?


// Also need routines for registering Choice and Progress dialogs.
class CBaseDlg;
class CChoiceDlg;
class CLock;
class CThreadMsgProxy;
class CHndlrMsg;

// state the handler should go to next
// note: any items with a HandlerState other than choice in a TransferQueueData
//          will be released asserting the HANDLERSTATE_RELEASE or HANDLERSTATE_DEAD
//          state is set.

typedef enum _tagHANDLERSTATE
{
    HANDLERSTATE_NEW                    = 0x00, // state is initialized to this.
    HANDLERSTATE_CREATE                 = 0x01, // state is initialized to this.
    HANDLERSTATE_INCREATE               = 0x02, // state is initialized to this.
    HANDLERSTATE_INITIALIZE             = 0x03, // set after a successfull creation.
    HANDLERSTATE_ININITIALIZE           = 0x04, // set during initialization call
    HANDLERSTATE_ADDHANDLERTEMS         = 0x05,  // items need to be enumerated
    HANDLERSTATE_INADDHANDLERITEMS      = 0x06, // in the items enumerator
    HANDLERSTATE_PREPAREFORSYNC         = 0x07, // set during queue tranfers
    HANDLERSTATE_INPREPAREFORSYNC       = 0x08, // handler is currently in a prepfosync call.
    HANDLERSTATE_INSETCALLBACK          = 0x09, // within a setcallback call.
    HANDLERSTATE_SYNCHRONIZE            = 0x0A, // Prepare for Sync set this if successfull
    HANDLERSTATE_INSYNCHRONIZE          = 0x0B, // item is currently in a synchronize call
    HANDLERSTATE_HASERRORJUMPS          = 0x0C, // if synchronize returned but error has jumps
    HANDLERSTATE_INHASERRORJUMPS        = 0x0D, // this handleris in a has jumps call
    HANDLERSTATE_RELEASE                = 0x0E, // Handler can be released, set on error or after success
    HANDLERSTATE_TRANSFERRELEASE        = 0x0F, // Handler can be released, was transferred into the queue but nothing to do.
    HANDLERSTATE_DEAD                   = 0x10, // handler has been released. Data Stays around.
}  HANDLERSTATE;

typedef enum _tagQUEUETYPE
{
    QUEUETYPE_CHOICE                    = 0x1, //
    QUEUETYPE_PROGRESS                  = 0x2, //
    QUEUETYPE_SETTINGS                  = 0x3, //
} QUEUETYPE;

// Job info list is assigned to each new item added to the hndlrqueu
// keeps track of number of handlers attached to JobInfo, Initialize
// flags, schedule name
// Progress queue keeps a linked list.

typedef struct _JOBINFO  {
    struct _JOBINFO *pNextJobInfo;
    struct _JOBINFO *pTransferJobInfo; // used in queue transfer.
    DWORD cRefs;
    DWORD dwSyncFlags; // standard sync flags
    TCHAR szScheduleName[MAX_PATH + 1]; 
    BOOL fCanMakeConnection; // Job is allowed to dial the connection.
    BOOL fTriedConnection; // Job already tried to dial the connection.
    DWORD cbNumConnectionObjs;
    CONNECTIONOBJ *pConnectionObj[1]; // array of cbNumConnecObjs associated with this job.
} JOBINFO;



typedef struct _ITEMLIST
{
    struct _ITEMLIST* pnextItem;
    WORD  wItemId;              // Id that uniquely identifies Item within a handler.
    void *pHandlerInfo;         // pointer to the handler that owns this item
    SYNCMGRITEM offlineItem;    // enumerator structure item returned
    BOOL fItemCancelled;        // when set poper code should be returned to progress.
    BOOL fDuplicateItem;        // when set to true indicates there was already an existing item of this handler and item.
    BOOL fIncludeInProgressBar; // if set to true items ProgValues are added to the progress bar.
    BOOL fProgressBarHandled;   // Used internally by GetProgressInfo for calculating num items of num items completed
    INT iProgValue;             // current progress value.
    INT iProgMaxValue;          // current progress max value.
    BOOL fProgValueDirty;       // set to true if Normalized Progress Value needs to be recalced.
    INT iProgValueNormalized;      // current progress  value normalized
    DWORD dwStatusType;         // status type from last callback.
    BOOL fHiddenItem;       // flag set it Item was added by ShowErrors returning nonItem.
    BOOL fSynchronizingItem;      // flag set while item has been selected for prepareForSync/synchronize.
} ITEMLIST;
typedef ITEMLIST* LPITEMLIST;

typedef struct _HANDLERINFO {
    struct _HANDLERINFO *pNextHandler;
    DWORD dwCallNestCount;
    struct _HANDLERINFO *pHandlerId;        // Id that uniquely identifies this instance of the Handler
    CLSID clsidHandler;             // CLSID of the handler Handler
    DWORD    dwRegistrationFlags; // flags as item is registered
    SYNCMGRHANDLERINFO SyncMgrHandlerInfo; // copy of handler info GetHandlerInfo Call
    HANDLERSTATE HandlerState;
    HWND hWndCallback; //  hWnd to send callback information to.
    BOOL fHasErrorJumps; // BOOL if can call ShowErrors then don't release on completion of sync.
    BOOL fInShowErrorCall; // bool to indicate if handler is currently handling a ShowError Call.
    BOOL fInTerminateCall; // bool to indicate if handler is currently handling a ShowError Call.
    CThreadMsgProxy *pThreadProxy;
    DWORD dwOutCallMessages; // out call messages we are currenlty handling.
    WORD wItemCount;
    BOOL fCancelled; // This Handler was Cancelled by the User.
    BOOL fRetrySync; // retrySync was requested while before this items synchronization was done.
    LPITEMLIST pFirstItem;          // ptr to first Item of the handler in the list.
    JOBINFO *pJobInfo;
} HANDLERINFO;
typedef HANDLERINFO* LPHANDLERINFO;


#define MAXPROGRESSVALUE 3000 // maximum absolute progress bar value

class CHndlrQueue : CLockHandler {

    private:
        // review when eat up all the available IDs
        LPHANDLERINFO m_pFirstHandler;
        JOBINFO     *m_pFirstJobInfo; // pointer to first job.
        HWND m_hwndDlg; // hwnd to dialog that owns the queue.
        CBaseDlg *m_pDlg; // pointer to dialog that owns the queue.
        WORD m_wHandlerCount; // number of handlers in this queue
        QUEUETYPE m_QueueType; // type of queue this is.
        DWORD m_dwQueueThreadId; // Thread that queue was created on.
        DWORD m_dwShowErrororOutCallCount; // number of handlers currently stuck in a ShowError Call.
        BOOL m_fInCancelCall; // Don't allow Cancel to be re-entrant
        DWORD m_cRefs;
        BOOL  m_fItemsMissing;         // set if any handlers have missing items.
        INT   m_iNormalizedMax; // last calculated Max Value in GetProgressInfo
        BOOL  m_fNumItemsCompleteNeedsARecalc; // Need to recalulate the number of items complete.
        BOOL  m_iItemCount; // Total Number of  Items as shown in progress.
        BOOL  m_iCompletedItems; // Number of Completed Items..
        ULONG m_ulProgressItemCount; //  total count of Items in cache included with progress.

    public:
        CHndlrQueue(QUEUETYPE QueueType,CBaseDlg *pDlg);
        ~CHndlrQueue();

        STDMETHODIMP_(ULONG)    AddRef();
        STDMETHODIMP_(ULONG)    Release();

        // main queue routines
        STDMETHODIMP AddHandler(HANDLERINFO **ppHandlerId,JOBINFO *pJobInfo,DWORD dwRegistrationFlags);
        STDMETHODIMP Cancel(void);
        STDMETHODIMP ForceKillHandlers(BOOL *pfItemToKill);
        STDMETHODIMP TransferQueueData(CHndlrQueue *pQueueMoveFrom);
        STDMETHODIMP SetQueueHwnd(CBaseDlg *pDlg);
        STDMETHODIMP ReleaseCompletedHandlers(void);
        BOOL AreAnyItemsSelectedInQueue(); // walks through seeing if any items are selected for sync.
        STDMETHODIMP FreeAllHandlers(void); // frees all handlers associated with the queue.

        STDMETHODIMP GetHandlerInfo(REFCLSID clsidHandler,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
        STDMETHODIMP GetHandlerInfo(HANDLERINFO *pHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
        STDMETHODIMP GetItemDataAtIndex(HANDLERINFO *pHandlerId,WORD wItemID,CLSID *pclsidHandler,
                                            SYNCMGRITEM* offlineItem,BOOL *pfHiddenItem);
        STDMETHODIMP GetItemDataAtIndex(HANDLERINFO *pHandlerId,REFSYNCMGRITEMID ItemID,CLSID *pclsidHandler,
                                            SYNCMGRITEM* offlineItem,BOOL *pfHiddenItem);

        // new methods for walking through ListView relying on clsid and itemID
	STDMETHODIMP FindFirstItemInState(HANDLERSTATE hndlrState,HANDLERINFO **ppHandlerId,WORD *wItemID);
	STDMETHODIMP FindNextItemInState(HANDLERSTATE hndlrState,HANDLERINFO *pLastHandlerId,WORD wLastItemID,
						     HANDLERINFO **ppHandlerId,WORD *wItemID);

        STDMETHODIMP SetItemState(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID,DWORD dwState); 
	STDMETHODIMP ItemHasProperties(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID);  // determines if there are properties associated with this item.
	STDMETHODIMP ShowProperties(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID,HWND hwndParent);	    // show properties for this listView Item.
        STDMETHODIMP ReEnumHandlerItems(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID);
	STDMETHODIMP SkipItem(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID); // skip this item

        // methods for handling the progress and Items complete
        STDMETHODIMP GetProgressInfo(INT *iProgValue,INT *iMaxValue,INT *iNumItemsComplete,
                                            INT *iNumItemsTotal);
        STDMETHODIMP SetItemProgressInfo(HANDLERINFO *pHandlerId,WORD wItemID,
                                                LPSYNCMGRPROGRESSITEM pSyncProgressItem,
                                                BOOL *pfProgressChanged);
        STDMETHODIMP RemoveFinishedProgressItems(); // walks through list marking any
                                                     // finished items as fIncludeInProgressBar==FALSE;

        STDMETHODIMP PersistChoices(void); // persists choices for next time.

        // For finding Handlers that meet specific state requirements
        STDMETHODIMP FindFirstHandlerInState(HANDLERSTATE hndlrState,
                        REFCLSID clsidHandler,HANDLERINFO **ppHandlerId,CLSID *pMatchHandlerClsid);
        STDMETHODIMP FindNextHandlerInState(HANDLERINFO *pLastHandlerID,
                            REFCLSID clsidHandler,HANDLERSTATE hndlrState,HANDLERINFO **ppHandlerId
                            ,CLSID *pMatchHandlerClsid);

        // functions for calling through the items proxy.
        STDMETHODIMP CreateServer(HANDLERINFO *pHandlerId, const CLSID *pCLSIDServer);
        STDMETHODIMP Initialize(HANDLERINFO *pHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
                            DWORD cbCookie,const BYTE *lpCooke);
        STDMETHODIMP AddHandlerItemsToQueue(HANDLERINFO *pHandlerId,DWORD *pcbNumItems);
        STDMETHODIMP GetItemObject(HANDLERINFO *pHandlerId,WORD wItemID,REFIID riid,void** ppv);
        STDMETHODIMP SetUpProgressCallback(HANDLERINFO *pHandlerId,BOOL fSet,HWND hwnd); // TRUE == create, FALSE == destroy. Callback info should be sent to specified hwnd.
        STDMETHODIMP PrepareForSync(HANDLERINFO *pHandlerId,HWND hWndParent);
        STDMETHODIMP Synchronize(HANDLERINFO *pHandlerId,HWND hWndParent);
        STDMETHODIMP ShowError(HANDLERINFO *pHandlerId,HWND hWndParent,REFSYNCMGRERRORID ErrorID);

        // callback proxy functions
        STDMETHODIMP IsAllHandlerInstancesCancelCompleted(REFCLSID clsidHandler);

        // functions called from Handler Thread
        STDMETHODIMP SetHandlerInfo(HANDLERINFO *pHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
        STDMETHODIMP AddItemToHandler(HANDLERINFO *pHandlerId,LPSYNCMGRITEM pOffineItem);
        STDMETHODIMP Progress(HANDLERINFO *pHandlerId,REFSYNCMGRITEMID ItemID,LPSYNCMGRPROGRESSITEM lpSyncProgressItem);
        STDMETHODIMP LogError(HANDLERINFO *pHandlerId,DWORD dwErrorLevel,const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError);
        STDMETHODIMP DeleteLogError(HANDLERINFO *pHandlerId,REFSYNCMGRERRORID ErrorID,DWORD dwReserved);
        void CallCompletionRoutine(HANDLERINFO *pHandlerId,DWORD dwThreadMsg,HRESULT hr,
                                ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);

        // internal queue handler of method calls with completion
        // routines. can be called on either handler or dlg owner thread
        // on error from calls completion routine is still invoked for
        // the convenience of the caller to never have to worry about it.
        STDMETHODIMP PrepareForSyncCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult);
        STDMETHODIMP SynchronizeCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult);
        STDMETHODIMP ShowErrorCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);

        STDMETHODIMP AddQueueJobInfo(DWORD dwSyncFlags, DWORD cbNumConnectionNames,
                                    TCHAR **ppConnectionNames,TCHAR *pszScheduleName,BOOL fCanMakeConnection
                                     ,JOBINFO **ppJobInfo);

        DWORD ReleaseJobInfoExt(JOBINFO *pJobInfo);


        // state transition functions
        STDMETHODIMP CancelQueue(void); // put queue into cancel mode.
        STDMETHODIMP ScrambleIdleHandlers(REFCLSID clsidLastHandler);

        // Handler dial support functinos
        STDMETHODIMP BeginSyncSession();
        STDMETHODIMP EndSyncSession();
        STDMETHODIMP SortHandlersByConnection();
        STDMETHODIMP EstablishConnection( LPHANDLERINFO pHandlerID,
                                          WCHAR const * lpwszConnection,
                                          DWORD dwReserved );

    private:
        // private functions for finding proper handlers and items.
        LPITEMLIST AllocNewHandlerItem(LPHANDLERINFO pHandlerInfo,SYNCMGRITEM *pOfflineItem);
	STDMETHODIMP LookupHandlerFromId(HANDLERINFO *pHandlerId,LPHANDLERINFO *pHandlerInfo);
        STDMETHODIMP FindItemData(CLSID clsidHandler,REFSYNCMGRITEMID OfflineItemID,
                                         HANDLERSTATE hndlrStateFirst,HANDLERSTATE hndlrStateLast,
                                         LPHANDLERINFO *ppHandlerInfo,LPITEMLIST *ppItem);

	BOOL IsItemAlreadyInList(CLSID clsidHandler,REFSYNCMGRITEMID ItemID,
                                                    HANDLERINFO *pHandlerId,
                                                    LPHANDLERINFO *ppHandlerMatched,
                                                    LPITEMLIST *ppItemListMatch);
        STDMETHODIMP MoveHandler(CHndlrQueue *pQueueMoveFrom,
                        LPHANDLERINFO pHandlerInfoMoveFrom,HANDLERINFO **pHandlerId,
                        CLock *pclockQueue);
        DWORD GetSelectedItemsInHandler(LPHANDLERINFO pHandlerInfo,ULONG *cbCount,
                                        SYNCMGRITEMID* pItems);
        BOOL IsItemCompleted(LPHANDLERINFO pHandler,LPITEMLIST pItem);
        STDMETHODIMP ReleaseHandlers(HANDLERSTATE HandlerState); // Releases handlers that are no longer neededfs

        // items to handle maintain JobInfo items.
        STDMETHODIMP CreateJobInfo(JOBINFO **ppJobInfo,DWORD cbNumConnectionNames);
        DWORD AddRefJobInfo(JOBINFO *pJobInfo);
        DWORD ReleaseJobInfo(JOBINFO *pJobInfo);

        STDMETHODIMP ForceCompleteOutCalls(LPHANDLERINFO pCurHandler);

        // connection help routines
        STDMETHODIMP OpenConnection(JOBINFO *pJobInfo);

        // helper function for setting item ProgressInfo
        STDMETHODIMP SetItemProgressInfo(LPITEMLIST pItem,
                                        LPSYNCMGRPROGRESSITEM pSyncProgressItem,
                                        BOOL *pfProgressChanged);
        STDMETHODIMP SetItemProgressValues(LPITEMLIST pItem,INT iProgValue,INT iProgMaxValue);


    friend CHndlrMsg;
};

// helper functions
BOOL IsValidSyncProgressItem(LPSYNCMGRPROGRESSITEM lpProgItem);
BOOL IsValidSyncLogErrorInfo(DWORD dwErrorLevel,const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError);


#endif // _HANDLERQUEUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\hndlrq.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Hndlrq.cpp
//
//  Contents:   Implements class for keeping track of handlers
//              and the UI associated with them
//
//  Classes:    CHndlrQueue
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE 10

// called to set up the JobInfo on a choice queue.

STDMETHODIMP CHndlrQueue::AddQueueJobInfo(DWORD dwSyncFlags,DWORD cbNumConnectionNames,
                                TCHAR **ppConnectionNames,
                                 TCHAR *pszScheduleName,BOOL fCanMakeConnection
                                 ,JOBINFO **pJobInfo)

{
HRESULT hr = E_UNEXPECTED;
TCHAR *pszConnectionName;
TCHAR **pszConnectionNameArray;
CLock clockqueue(this);


    *pJobInfo = NULL;

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    if (m_QueueType != QUEUETYPE_CHOICE)
    {
        return E_UNEXPECTED;
    }

   clockqueue.Enter();

   Assert(NULL == m_pFirstJobInfo);

   // fix up connections so have at least one connection/job.
   // this currently happens on an UpdateItems.
    if (NULL == ppConnectionNames || 0 == cbNumConnectionNames )
    {
        cbNumConnectionNames = 1;
        pszConnectionName = TEXT("");
        pszConnectionNameArray = &pszConnectionName;
    }
    else
    {
        pszConnectionName = *ppConnectionNames;
        pszConnectionNameArray = ppConnectionNames;
    }

   // create a job requesting size for the number of connections passed in.
   hr = CreateJobInfo(&m_pFirstJobInfo,cbNumConnectionNames);

   if (NOERROR == hr)
   {
   DWORD dwConnectionIndex;

        Assert(cbNumConnectionNames >= 1); // Review assert for debugging to test when have multiple connections for first time.
        m_pFirstJobInfo->cbNumConnectionObjs = 0;

        // add a connectionObject for each connection
        for (dwConnectionIndex = 0; dwConnectionIndex < cbNumConnectionNames; ++dwConnectionIndex)
        {

            hr = ConnectObj_FindConnectionObj(pszConnectionNameArray[dwConnectionIndex],
                                        TRUE,&(m_pFirstJobInfo->pConnectionObj[dwConnectionIndex]));

            if (NOERROR != hr)
            {
                break;
            }
            else
            {
                ++m_pFirstJobInfo->cbNumConnectionObjs;
            }

        }

        if (NOERROR == hr)
        {
            m_pFirstJobInfo->dwSyncFlags = dwSyncFlags;

            if ((SYNCMGRFLAG_SCHEDULED == (dwSyncFlags & SYNCMGRFLAG_EVENTMASK)))
            {
                lstrcpy(m_pFirstJobInfo->szScheduleName,pszScheduleName);
                m_pFirstJobInfo->fCanMakeConnection = fCanMakeConnection;
                m_pFirstJobInfo->fTriedConnection = FALSE;
            }

        }
        else
        {
            // couldn't create the connectionObj so release our jobID
            m_pFirstJobInfo = NULL;
        }
   }

   *pJobInfo = m_pFirstJobInfo;
   clockqueue.Leave();

   return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::CHndlrQueue, public
//
//  Synopsis:   Constructor used to create a progress queue
//
//  Arguments:  [QueueType] - Type of Queue that should be created.
//              [hwndDlg] - Hwnd who owns this queue.
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CHndlrQueue::CHndlrQueue(QUEUETYPE QueueType,CBaseDlg *pDlg)
{

    Assert(QueueType == QUEUETYPE_PROGRESS
        || QueueType == QUEUETYPE_CHOICE );

    m_pFirstHandler = NULL;
    m_wHandlerCount = 0;
    m_dwShowErrororOutCallCount = 0;
    m_cRefs = 1;
    m_QueueType = QueueType;
    m_fItemsMissing = FALSE;
    m_dwQueueThreadId = GetCurrentThreadId();
    m_iNormalizedMax = 0;
    m_fNumItemsCompleteNeedsARecalc = TRUE;

    m_pDlg = pDlg;
    if (m_pDlg)
    {
        m_hwndDlg = m_pDlg->GetHwnd();
        Assert(m_hwndDlg);
    }

    m_fInCancelCall = FALSE;
    m_pFirstJobInfo = NULL;

}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::~CHndlrQueue, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CHndlrQueue::~CHndlrQueue()
{
CLock clockqueue(this);

    // for a progress queue all the jobInfos should be released
    // for the choice queue there should be one JobInfo that has to
    // be released that was addref'd in the constructor.

    Assert(0 == m_cRefs);
    Assert(NULL == m_pFirstJobInfo); // review - this should never fire anymore.

    Assert(NULL == m_pFirstJobInfo
            || m_QueueType == QUEUETYPE_CHOICE); // there shouldn't be any unreleased JobInfo

    Assert(m_pFirstHandler == NULL); // All Handlers should have been released by now.
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AddRef, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-June-98       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHndlrQueue::AddRef()
{
DWORD cRefs;

    Assert(m_cRefs >= 1); // should never zero bounce.
    cRefs = InterlockedIncrement((LONG *)& m_cRefs);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Release, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-June-98       rogerg        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHndlrQueue::Release()
{
DWORD cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRefs);

    Assert( ((LONG) cRefs) >= 0); // should never go negative.
    if (0 == cRefs)
    {
        delete this;
    }

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AddHandler, public
//
//  Synopsis:   Adds a new empty handler to the queue and returns it ID
//
//  Arguments:  [pwHandlerID] - on success contains the assigned Handler ID
//              [pJobInfo] - Job this item is associated with
//              [dwRegistrationFlags] - Flags the Handler has registered for.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::AddHandler(HANDLERINFO **ppHandlerId,JOBINFO *pJobInfo,DWORD dwRegistrationFlags)
{
HRESULT hr = E_OUTOFMEMORY;
LPHANDLERINFO pnewHandlerInfo;
CLock clockqueue(this);


    *ppHandlerId = 0;

    pnewHandlerInfo = (LPHANDLERINFO) ALLOC(sizeof(HANDLERINFO));

    if (pnewHandlerInfo)
    {
        clockqueue.Enter();

        m_fNumItemsCompleteNeedsARecalc = TRUE; // need to recalc next GetProgress.


        // initialize the new Handler Entry
        memset(pnewHandlerInfo,0,sizeof(HANDLERINFO));
        pnewHandlerInfo->HandlerState = HANDLERSTATE_CREATE;
        pnewHandlerInfo->pHandlerId =   pnewHandlerInfo;
        pnewHandlerInfo->dwRegistrationFlags = dwRegistrationFlags;

        // queue should be a choice queue and
        // there should already be a jobinfo.
        Assert(m_QueueType == QUEUETYPE_CHOICE);
        Assert(m_pFirstJobInfo);
        Assert(pJobInfo == m_pFirstJobInfo); // for now job info should always be the first one.

        if (m_QueueType == QUEUETYPE_CHOICE && pJobInfo)
        {
            AddRefJobInfo(pJobInfo);
            pnewHandlerInfo->pJobInfo = pJobInfo;
        }

        // add to end of list and set pHandlerId. End of list since in choice dialog want
        // first writer wins so don't have to continue searches when setting item state.

        if (NULL == m_pFirstHandler)
        {
            m_pFirstHandler = pnewHandlerInfo;
        }
        else
        {
        LPHANDLERINFO pCurHandlerInfo;

            pCurHandlerInfo = m_pFirstHandler;

            while (pCurHandlerInfo->pNextHandler)
                pCurHandlerInfo = pCurHandlerInfo->pNextHandler;

            pCurHandlerInfo->pNextHandler = pnewHandlerInfo;
        }

        *ppHandlerId = pnewHandlerInfo->pHandlerId;

        clockqueue.Leave();

        hr = NOERROR;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ForceKillHandlers, public
//
//  Synopsis:   Kills unresponsive handlers after timeout
//
//  Returns:    Appropriate return codes
//
//  History:    20-Nov-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ForceCompleteOutCalls(LPHANDLERINFO pCurHandler)
{

    // need to have lock for argument to be valid.

    ASSERT_LOCKHELD(this); 

    //prepare for sync out call
    if (pCurHandler->dwOutCallMessages & ThreadMsg_PrepareForSync)
    {
        CallCompletionRoutine(pCurHandler,ThreadMsg_PrepareForSync,
                              HRESULT_FROM_WIN32(ERROR_CANCELLED),0,NULL);
    }

    //Synchronize out call
    if (pCurHandler->dwOutCallMessages & ThreadMsg_Synchronize)
    {
        CallCompletionRoutine(pCurHandler,ThreadMsg_Synchronize,
                              HRESULT_FROM_WIN32(ERROR_CANCELLED),0,NULL);
    }
    //ShowProperties out call
    if (pCurHandler->dwOutCallMessages & ThreadMsg_ShowProperties)
    {
        CallCompletionRoutine(pCurHandler,ThreadMsg_ShowProperties,
                              HRESULT_FROM_WIN32(ERROR_CANCELLED),0,NULL);
    }
    //Show Errors out call
    if (pCurHandler->dwOutCallMessages & ThreadMsg_ShowError)
    {
        CallCompletionRoutine(pCurHandler,ThreadMsg_ShowError,
                              HRESULT_FROM_WIN32(ERROR_CANCELLED),0,NULL);
    }

    // force handler state to release.
    pCurHandler->HandlerState = HANDLERSTATE_RELEASE;

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ForceKillHandlers, public
//
//  Synopsis:   Kills unresponsive handlers after timeout
//
//  Returns:    Appropriate return codes
//
//  History:    30-Oct-98       susia        Created.
//              19-Nov-98       rogerg       Change to only kill first unresponsive handler
//
//----------------------------------------------------------------------------

#define BAD_HANDLERSTATE(pHandlerId) \
    (  (HANDLERSTATE_INSYNCHRONIZE >= pHandlerId->HandlerState)   \
    || (pHandlerId->dwOutCallMessages & ThreadMsg_SetItemStatus)  \
    )

STDMETHODIMP CHndlrQueue::ForceKillHandlers(BOOL *pfItemToKill)
{
HRESULT hr = NOERROR;
LPHANDLERINFO pCurHandler;
CLock clockqueue(this);

    *pfItemToKill = TRUE; // if something strange happens make sure timer gets reset.

    clockqueue.Enter();

    pCurHandler = m_pFirstHandler;

    while (pCurHandler)
    {
        // if handler is cancelled but still in a noncancelled state or
        // is cancelled but stuck in the outcall then terminate.

        // need to check both because some handlers may call the callback
        // to set the state done but still be stuck in an out call.

        if ( (TRUE == pCurHandler->fCancelled) &&  BAD_HANDLERSTATE(pCurHandler) )
        {
            
            TCHAR pszHandlerName[MAX_SYNCMGRHANDLERNAME + 1];

            ConvertString(pszHandlerName,
                          (pCurHandler->SyncMgrHandlerInfo).wszHandlerName,
                          MAX_SYNCMGRHANDLERNAME);

            // yield because of message box in Terminate Handler call.

            Assert(!pCurHandler->fInTerminateCall);
            pCurHandler->fInTerminateCall = TRUE;
            clockqueue.Leave();

            hr = pCurHandler->pThreadProxy->TerminateHandlerThread(pszHandlerName,TRUE);

            clockqueue.Enter();

            pCurHandler->fInTerminateCall = FALSE;

            if (hr == S_OK)
            {
            LPHANDLERINFO pKilledHandler = pCurHandler;

                ForceCompleteOutCalls(pCurHandler);

                // now need to loop through remaining instances handlers off the same clsid
                // we just killed
                 
                while(pCurHandler = pCurHandler->pNextHandler)
                {
                    if (pCurHandler->clsidHandler == pKilledHandler->clsidHandler)
                    {
                        // must meet original kil criteria
                        if ( (TRUE == pCurHandler->fCancelled) && BAD_HANDLERSTATE(pCurHandler) )
                        {
                        HRESULT hrProxyTerminate;

                            pCurHandler->fInTerminateCall = TRUE;

                            clockqueue.Leave();
                            hrProxyTerminate = pCurHandler->pThreadProxy->TerminateHandlerThread(pszHandlerName,FALSE);
                            clockqueue.Enter();

                            Assert(S_OK == hrProxyTerminate);// this should never fail.

                            ForceCompleteOutCalls(pCurHandler);

                            pCurHandler->fInTerminateCall = FALSE;
                        }

                    }


                }


            }

            // if handled one , break out and reqiure to be called again.
            break; 
        }

        pCurHandler = pCurHandler->pNextHandler;
    }


    // finally loop through the queue and see if there are any more items to kill

    *pfItemToKill = FALSE; 

    pCurHandler = m_pFirstHandler;

    while (pCurHandler)
    {
        // if handler is cancelled but still in a noncancelled state or
        // is cancelled but stuck in the outcall then terminate.

        // need to check both because some handlers may call the callback
        // to set the state done but still be stuck in an out call.
        if ( (TRUE == pCurHandler->fCancelled) && BAD_HANDLERSTATE(pCurHandler) )
        {
             *pfItemToKill = TRUE;
             break;
        }

        pCurHandler = pCurHandler->pNextHandler;
    }

    clockqueue.Leave();

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Cancel, public
//
//  Synopsis:   Set the current Handler Items in the queue
//              into cancel mode.
//
//          The Different States Are.
//              If the item is waiting for <= PrepareForSync place in Release
//              If InPrepareForSync Skip Items and then Synchrnoize
//                  will check the complete value before calling through
//                  and if set will just release the Handler.
//              If Waiting to Synchronize Skip Items then let Synchronize
//                  Check for complete value and just set release
//              If Item is currently In the Synchronize Skip all items
//                  and then just let synchronize return
//
//  Algorithm. If <= PrepareForSync then place in Release, Else if <= InSynchronize
//              then SkipTheItems
//
//         Note: Relies on Synchronize setting handler state before calling
//              through to Handlers Synchronize Method. PrepareForSync should
//              also check this in case new PrepareforSync request comes
//              in during an out call in this routine.
//
//  Arguments:
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Cancel(void)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pCurHandler;
CLock clockqueue(this);

    clockqueue.Enter();

    // don't do anything is still processing the last cancel request

    if (!m_fInCancelCall)
    {

        m_fInCancelCall = TRUE;

        // first thing set cancel to true on all handler items
        // so if sync,PrepareForSyncRequest comes in during SetItemStatus
        // out call it will be cancelled immediately.

        pCurHandler = m_pFirstHandler;

        while (pCurHandler)
        {
            pCurHandler->fCancelled = TRUE;
            pCurHandler = pCurHandler->pNextHandler;
        }

        // now loop through looking for any items that need to have
        // their item status set.

        // !!!remember new requests can come in so only make out call
        // if fCancelled is set.
        // !!! items can be removed from queue in between our cancel call
        //  and when we return.

        pCurHandler = m_pFirstHandler;

        while (pCurHandler)
        {
        CThreadMsgProxy *pThreadProxy = pCurHandler->pThreadProxy;

            if (pCurHandler->fCancelled && pThreadProxy
                && (pCurHandler->HandlerState >= HANDLERSTATE_INPREPAREFORSYNC)
                && (pCurHandler->HandlerState <= HANDLERSTATE_INSYNCHRONIZE) )
            {

                // could be in a setitemstatus call, if so then don't do another.
                // review - dup of SkipCode. should have a general purpose function
                // to call after setting what items should be cancelled.
                if (!(pCurHandler->dwOutCallMessages & ThreadMsg_SetItemStatus))
                {

                    pCurHandler->dwOutCallMessages |= ThreadMsg_SetItemStatus;            
                    clockqueue.Leave();

                    // send a reset to the hwnd we belong to if there is one

                    if (m_hwndDlg)
                    {
                        SendMessage(m_hwndDlg,WM_PROGRESS_RESETKILLHANDLERSTIMER,0,0);
                    }

                    hr = pThreadProxy->SetItemStatus(GUID_NULL,SYNCMGRSTATUS_STOPPED);

                    clockqueue.Enter();
                    pCurHandler->dwOutCallMessages &= ~ThreadMsg_SetItemStatus;

                }
            }
            else if (pCurHandler->HandlerState  <  HANDLERSTATE_INPREPAREFORSYNC)
            {
            LPITEMLIST pCurItem;

                pCurHandler->HandlerState = HANDLERSTATE_RELEASE;

                // need to setup HwndCallback so progres gets updated. 
                // review, after ship why can't setup HwndCallback on transferqueueu
                pCurHandler->hWndCallback = m_hwndDlg;


                // if handler hansn't been kicked off yet, just reset the items ourselves
                 pCurItem = pCurHandler->pFirstItem;

                while (pCurItem)
                {
                    if (pCurItem->fIncludeInProgressBar)
                    {
                    SYNCMGRPROGRESSITEM SyncProgressItem;


                        SyncProgressItem.cbSize = sizeof(SYNCMGRPROGRESSITEM);
                        SyncProgressItem.mask = SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE | SYNCMGRPROGRESSITEM_STATUSTYPE;
                        SyncProgressItem.iProgValue = HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE;
                        SyncProgressItem.iMaxValue = HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE;
                        SyncProgressItem.dwStatusType = SYNCMGRSTATUS_STOPPED;

                        // set progress faking we are in an out call so any releasecompleted
                        // handler that comes through doesn't release us.
                        // if already in outCall then progress just won't get updated
                        // until next time.
                        if (!(pCurHandler->dwOutCallMessages & ThreadMsg_SetItemStatus))
                        {

                            pCurHandler->dwOutCallMessages |= ThreadMsg_SetItemStatus;  
                            

                            clockqueue.Leave();

                            Progress(pCurHandler->pHandlerId,
                                        pCurItem->offlineItem.ItemID,&SyncProgressItem);

                            clockqueue.Enter();
                            pCurHandler->dwOutCallMessages &= ~ThreadMsg_SetItemStatus;
                        }

                    }

                    pCurItem = pCurItem->pnextItem;
                }

            }

            pCurHandler = pCurHandler->pNextHandler;
        }

        m_fInCancelCall = FALSE;
    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::MoveHandler, public
//
//  Synopsis:   Moves the Handler from a queue into this queue.
//
//  Arguments:  [pQueueMoveFrom] - Queue the handler is being moved from.
//              [pHandlerInfoMoveFrom] - Handler that is being moved
//              [ppHandlerId] - On Success contains the new HandlerID
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::MoveHandler(CHndlrQueue *pQueueMoveFrom,
                                      LPHANDLERINFO pHandlerInfoMoveFrom,
                                      HANDLERINFO **ppHandlerId,
                                      CLock *pclockQueue)
{
LPITEMLIST pCurItem = NULL;
JOBINFO *pJobInfo = NULL;
BOOL fHasItemsToSync = FALSE;

    ASSERT_LOCKHELD(this); // items should already be locked when this function is called.
    ASSERT_LOCKHELD(pQueueMoveFrom);

    if (QUEUETYPE_PROGRESS != m_QueueType
            &&  QUEUETYPE_CHOICE != m_QueueType)
    {
        Assert(QUEUETYPE_CHOICE == m_QueueType);
        Assert(QUEUETYPE_PROGRESS == m_QueueType);
        return E_UNEXPECTED; // review error code.
    }

    *ppHandlerId = 0;
    ++m_wHandlerCount;


  //  pHandlerInfoMoveFrom->pHandlerId = m_wHandlerCount;
    pHandlerInfoMoveFrom->pNextHandler = NULL;

     *ppHandlerId = pHandlerInfoMoveFrom->pHandlerId;

    // now fix up the items duplicate flag information.
    pCurItem = pHandlerInfoMoveFrom->pFirstItem;

    while (pCurItem)
    {
    LPHANDLERINFO pHandlerMatched;
    LPITEMLIST pItemListMatch;

        // setup the information for the UI depending on if this item is check and
        // the state it is in.

        // if item is now within a valid range then uncheck it.
       if (SYNCMGRITEMSTATE_CHECKED == pCurItem->offlineItem.dwItemState
           && ( (pHandlerInfoMoveFrom->HandlerState < HANDLERSTATE_PREPAREFORSYNC)
                || (pHandlerInfoMoveFrom->HandlerState >= HANDLERSTATE_RELEASE) )  )
       {
            Assert(pHandlerInfoMoveFrom->HandlerState >= HANDLERSTATE_PREPAREFORSYNC); // this should never happen.
            
            pCurItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
       }

       // setup the UI information based on if the item is checked.
       // or if its a hidden item.
        if (SYNCMGRITEMSTATE_UNCHECKED == pCurItem->offlineItem.dwItemState
            || pCurItem->fHiddenItem)
        {

            SetItemProgressValues(pCurItem,HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE,HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);
            pCurItem->fIncludeInProgressBar = FALSE;
        }
        else
        {

            fHasItemsToSync = TRUE;
            SetItemProgressValues(pCurItem,0,HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);
            pCurItem->fIncludeInProgressBar = TRUE;
        }


        if (IsItemAlreadyInList(pHandlerInfoMoveFrom->clsidHandler,
                                (pCurItem->offlineItem.ItemID),
                                pHandlerInfoMoveFrom->pHandlerId,
                                &pHandlerMatched,&pItemListMatch) )
        {
            pCurItem->fDuplicateItem = TRUE;

        }
        else
        {
            Assert(FALSE == pCurItem->fDuplicateItem); // catch case of duplicate getting lost
            pCurItem->fDuplicateItem = FALSE;
        }


        pCurItem = pCurItem->pnextItem;
    }


    // if the item we are moving has a Proxy then update the proxy to the new queue.
    // We update this when the item is not attached to either queue.
    if (pHandlerInfoMoveFrom->pThreadProxy)
    {
    HANDLERINFO *pHandlerInfoArg = pHandlerInfoMoveFrom->pHandlerId;

        // set the proxy to point to the new information
        pHandlerInfoMoveFrom->pThreadProxy->SetProxyParams(m_hwndDlg
                                                            ,m_dwQueueThreadId
                                                            ,this
                                                            ,pHandlerInfoArg);

    }


    // Add the handler to this list.
    if (NULL == m_pFirstHandler)
    {
        m_pFirstHandler = pHandlerInfoMoveFrom;
//      Assert(1 == m_wHandlerCount); // Review = HandlerCount doesn't have to be 1 if ReleaseCompltedHandlers has been called.

    }
    else
    {
    LPHANDLERINFO pCurHandlerInfo;

        pCurHandlerInfo = m_pFirstHandler;

        while (pCurHandlerInfo->pNextHandler)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;

        pCurHandlerInfo->pNextHandler = pHandlerInfoMoveFrom;
    }

    // if this is a progress queue and there are not items to sync for the
    // handler or the HandlerState isn't in PrepareForSync then set
    // the state to TransferRelease since it can be freed.

    if ((QUEUETYPE_PROGRESS == m_QueueType && !fHasItemsToSync )
        ||  (pHandlerInfoMoveFrom->HandlerState != HANDLERSTATE_PREPAREFORSYNC)) 
    {
        pHandlerInfoMoveFrom->HandlerState = HANDLERSTATE_TRANSFERRELEASE;
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::TransferQueueData, public
//
//  Synopsis:   Moves the Items from one queue to another. Currently we only
//              support transferrring items from a choice queueu to a choice or
//              progress queue. Only handlers in the PREPAREFORSYNC state are moved
//              when transferring to a Progress queue. When transferring to a choice
//              queue only items in the ADDHANDLERITEMS state are moved.
//
//              !!Warning - Cannot release lock during this process
//
//  Arguments:  [pQueueMoveFrom] - Queue to move items from.
//              [dwSyncFlags] - flags that started the sync
//              [pszConnectionName] - Connection the sync should be performed on, can be NULL
//              [szSchedulName] - Name of Schedule that started this Job. Can be NULL.
//              [hRasPendingEvent] - Event to signal when job is complete. Can be NULL.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::TransferQueueData(CHndlrQueue *pQueueMoveFrom
            /* ,DWORD dwSyncFlags,TCHAR *pzConnectionName,TCHAR *szScheduleName */)
{
HRESULT hr = E_UNEXPECTED;
HANDLERINFO HandlerInfoMoveFrom;
LPHANDLERINFO pHandlerInfoMoveFrom = &HandlerInfoMoveFrom;
CLock clockqueue(this);
CLock clockqueueMoveFrom(pQueueMoveFrom);

    clockqueue.Enter();
    clockqueueMoveFrom.Enter();

    m_fNumItemsCompleteNeedsARecalc = TRUE; // need to recalc NumItems next time

    if ((QUEUETYPE_PROGRESS != m_QueueType
            && QUEUETYPE_CHOICE != m_QueueType)|| QUEUETYPE_CHOICE != pQueueMoveFrom->m_QueueType)
    {
        Assert(QUEUETYPE_PROGRESS == m_QueueType || QUEUETYPE_CHOICE == m_QueueType);
        Assert(QUEUETYPE_CHOICE == pQueueMoveFrom->m_QueueType);
    }
    else if (NULL == pQueueMoveFrom->m_pFirstHandler) // if no job info then there aren't any items to move.
    {

    }
    else
    {
    JOBINFO *pMoveFromJobInfo = NULL;


        // transfer everything over and then release after done call freecompletedhandlers
        // to clean anything up.

        // transfer over all jobs

        Assert(pQueueMoveFrom->m_pFirstJobInfo);
        Assert(pQueueMoveFrom->m_pFirstJobInfo->pConnectionObj);

        pMoveFromJobInfo = pQueueMoveFrom->m_pFirstJobInfo;
        pQueueMoveFrom->m_pFirstJobInfo = NULL;

        if (NULL == m_pFirstJobInfo)
        {
            m_pFirstJobInfo = pMoveFromJobInfo;
        }
        else
        {
        JOBINFO *pCurLastJob = NULL;

            pCurLastJob = m_pFirstJobInfo;
            while (pCurLastJob->pNextJobInfo)
            {
                pCurLastJob = pCurLastJob->pNextJobInfo;
            }

            pCurLastJob->pNextJobInfo = pMoveFromJobInfo;

        }


        // loop through moving items, have to reassign the Handler ID and
        // !!Warning - This function does nothing with ListViewData it is up to the
        //     caller to make sure this is set up properly

        // review  - should just loop through fixing up necessary items and then
        // add entire list onto end. inneficient to do one at a time.

        pHandlerInfoMoveFrom->pNextHandler = pQueueMoveFrom->m_pFirstHandler;
        while (pHandlerInfoMoveFrom->pNextHandler)
        {
        LPHANDLERINFO pHandlerToMove;
        HANDLERINFO *pNewHandlerId;

            // Asserts for making sure the UI has been cleared from the queue
            Assert(FALSE == pHandlerInfoMoveFrom->pNextHandler->fHasErrorJumps);
            Assert(pHandlerInfoMoveFrom->pNextHandler->pJobInfo);

            // !!! Warning get next handler before transfer or next ptr will be invalid.

            pHandlerToMove = pHandlerInfoMoveFrom->pNextHandler;
            pHandlerInfoMoveFrom->pNextHandler = pHandlerToMove->pNextHandler;
            MoveHandler(pQueueMoveFrom,pHandlerToMove,&pNewHandlerId,&clockqueue);

            // now set the original queues head
            pQueueMoveFrom->m_pFirstHandler = HandlerInfoMoveFrom.pNextHandler;

            hr = NOERROR;
        }
    }

    clockqueue.Leave();
    clockqueueMoveFrom.Leave();

    // now free any handlers that came into the queue that we
    // don't want to do anything with .

    ReleaseHandlers(HANDLERSTATE_TRANSFERRELEASE);

    return hr;
 }

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetQueueHwnd, public
//
//  Synopsis:   informs the queue os the new dialog owner if any
//              queue must also loop through existing proxies
//              and reset their hwnd.
//
//  Arguments:
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetQueueHwnd(CBaseDlg *pDlg)
{
LPHANDLERINFO pCurHandlerInfo;
CLock clockqueue(this);

    clockqueue.Enter();

    m_pDlg = pDlg;
    if (m_pDlg)
    {
        m_hwndDlg = m_pDlg->GetHwnd();
    }
    else
    {
        m_hwndDlg = NULL;
    }

    m_dwQueueThreadId = GetCurrentThreadId(); // make sure queu threadId is updated.

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        if (pCurHandlerInfo->pThreadProxy)
        {
            pCurHandlerInfo->pThreadProxy->SetProxyParams(m_hwndDlg
                                                            ,m_dwQueueThreadId
                                                            ,this
                                                            ,pCurHandlerInfo->pHandlerId);

        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }


    clockqueue.Leave();

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ReleaseCompletedHandlers, public
//
//  Synopsis:   Releases any Handlers that are in the Release or free
//              dead state from the queue.
//
//  Arguments:
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ReleaseCompletedHandlers()
{
    return ReleaseHandlers(HANDLERSTATE_RELEASE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FreeAllHandlers, public
//
//  Synopsis:   Releases all handlers from the queue.
//
//  Arguments:
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FreeAllHandlers(void)
{
    return ReleaseHandlers(HANDLERSTATE_NEW); // release handlers in all states.
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ReleaseHandlers, public
//
//  Synopsis:   Releases any Handlers are in a state >= the requested state
//
//  Arguments:  HandlerState - Frees all handlers that have a state >= the requested state.
//
//      !!Warning: This should be the only place the proxy if freed and
//          the handler is removed from the list.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ReleaseHandlers(HANDLERSTATE HandlerState)
{
HANDLERINFO HandlerInfoStart;
LPHANDLERINFO pPrevHandlerInfo = &HandlerInfoStart;
LPHANDLERINFO pCurHandlerInfo = NULL;
LPHANDLERINFO pHandlerFreeList = NULL;
LPITEMLIST pCurItem = NULL;
LPITEMLIST pNextItem = NULL;
CLock clockqueue(this);

    ASSERT_LOCKNOTHELD(this); // shouldn't be any out calls in progress when this is called.

    clockqueue.Enter();

    m_fNumItemsCompleteNeedsARecalc = TRUE; // need to recalc next GetProgress.

    // loop through the handlers finding the one that match the criteria
    // removing them from list and adding them to the free list
    // we do this so don't have to worry about someone else accessing
    // handlers we are freeing during an out call.

    if (HANDLERSTATE_NEW == HandlerState)
    {
        // Release should only be called on this state if caller is sure no out
        // calls are in progress or else handler may not exist when
        // they come back
        pHandlerFreeList = m_pFirstHandler;
        m_pFirstHandler = NULL;
    }
    else
    {
        Assert(HandlerState >= HANDLERSTATE_RELEASE); // if in release no out calls are in progress.

        pPrevHandlerInfo->pNextHandler = m_pFirstHandler;

        while (pPrevHandlerInfo->pNextHandler)
        {
            pCurHandlerInfo = pPrevHandlerInfo->pNextHandler;

            // if meet handler state criteria and not in any out calls then can
            // remove from list.

            // if request for HANDLERSTATE_NEW then assert than there shouldn't be
            // any out calls in progress or terminating.
            Assert(!(HandlerState == HANDLERSTATE_NEW) || 
                    (0 == pCurHandlerInfo->dwOutCallMessages && !pCurHandlerInfo->fInTerminateCall));

            if ( (HandlerState <= pCurHandlerInfo->HandlerState)
                && (0 == pCurHandlerInfo->dwOutCallMessages) 
                && !(pCurHandlerInfo->fInTerminateCall))
            {

                Assert (HANDLERSTATE_RELEASE == pCurHandlerInfo->HandlerState  ||
                        HANDLERSTATE_TRANSFERRELEASE == pCurHandlerInfo->HandlerState ||
                        HANDLERSTATE_HASERRORJUMPS == pCurHandlerInfo->HandlerState ||
                        HANDLERSTATE_DEAD == pCurHandlerInfo->HandlerState);

                // remove from queue list and add to free.
                pPrevHandlerInfo->pNextHandler = pCurHandlerInfo->pNextHandler;

                pCurHandlerInfo->pNextHandler = pHandlerFreeList;
                pHandlerFreeList = pCurHandlerInfo;

            }
            else
            {
                // if no match then just continue.
                pPrevHandlerInfo = pCurHandlerInfo;
            }

        }

        // update the queue head.
        m_pFirstHandler = HandlerInfoStart.pNextHandler;

    }

    // now loop through the free list freeing the items.

    while (pHandlerFreeList)
    {
        pCurHandlerInfo = pHandlerFreeList;
        pHandlerFreeList = pHandlerFreeList->pNextHandler;


        // if the item has a job info release the reference on it.
        if (pCurHandlerInfo->pJobInfo)
        {
            ReleaseJobInfo(pCurHandlerInfo->pJobInfo);
            pCurHandlerInfo->pJobInfo = NULL;
        }


        if (pCurHandlerInfo->pThreadProxy)
        {
        CThreadMsgProxy *pThreadProxy = pCurHandlerInfo->pThreadProxy;
        HWND hwndCallback;

            Assert(HANDLERSTATE_DEAD != pCurHandlerInfo->HandlerState);

            pCurHandlerInfo->HandlerState = HANDLERSTATE_DEAD;
            pThreadProxy = pCurHandlerInfo->pThreadProxy;
            pCurHandlerInfo->pThreadProxy = NULL;

            hwndCallback = pCurHandlerInfo->hWndCallback;
            pCurHandlerInfo->hWndCallback = NULL;

            clockqueue.Leave(); // release lock when making the OutCall.
            pThreadProxy->Release(); // review, don't release proxy to try to catch race condition.

            clockqueue.Enter();
        }

        pCurItem = pCurHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            pNextItem = pCurItem->pnextItem;
            FREE(pCurItem);
            pCurItem = pNextItem;
        }

        FREE(pCurHandlerInfo);
    }

    clockqueue.Leave();

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetHandlerInfo, public
//
//  Synopsis:   Gets Data associated with the HandlerID and ItemID
//
//  Arguments:  [clsidHandler] - ClsiId Of Handler the Item belongs too
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetHandlerInfo(REFCLSID clsidHandler,
                                         LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
HRESULT hr = S_FALSE;
LPHANDLERINFO pCurHandlerInfo = NULL;
CLock clockqueue(this);

    clockqueue.Enter();

    // find first handler that matches the request CLSID
    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            *pSyncMgrHandlerInfo = pCurHandlerInfo->SyncMgrHandlerInfo;
            hr = NOERROR;
            break;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetHandlerInfo, public
//
//  Synopsis:   Gets Data associated with the HandlerID and ItemID
//
//  Arguments:  [wHandlerId] - Id Of Handler the Item belongs too
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetHandlerInfo(HANDLERINFO *pHandlerId,
                                         LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
HRESULT hr = S_FALSE;
LPHANDLERINFO pHandlerInfo = NULL;
CLock clockqueue(this);

    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        *pSyncMgrHandlerInfo = pHandlerInfo->SyncMgrHandlerInfo;
        hr = NOERROR;
    }

    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetItemDataAtIndex, public
//
//  Synopsis:   Gets Data associated with the HandlerID and ItemID
//
//  Arguments:  [wHandlerId] - Id Of Handler the Item belongs too
//              [wItemID] - Identifies the Item in the Handler
//              [pclsidHandler] - on return contains a pointer to the clsid of the Handler
//              [offlineItem] - on returns contains a pointer to the OfflineItem for the item.
//              [pfHiddenItem] - On return is a bool indicating if this item is hidden.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemDataAtIndex(HANDLERINFO *pHandlerId,WORD wItemID,
                                CLSID *pclsidHandler,SYNCMGRITEM *offlineItem,BOOL *pfHiddenItem)

{
BOOL fFoundMatch = FALSE;
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
CLock clockqueue(this);

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
        // only valid if Hanlder is in the PrepareForSync state.
        if (pHandlerId == pCurHandlerInfo->pHandlerId) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {

                if (wItemID == pCurItem->wItemId)
                {
                    fFoundMatch = TRUE;
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }


        }

        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    if (fFoundMatch)
    {
        if (pclsidHandler)
        {
                *pclsidHandler = pCurHandlerInfo->clsidHandler;
        }
        if (offlineItem)
        {
                *offlineItem = pCurItem->offlineItem;
        }
        if (pfHiddenItem)
        {
                *pfHiddenItem = pCurItem->fHiddenItem;
        }

    }

    clockqueue.Leave();

    return fFoundMatch ? NOERROR : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetItemDataAtIndex, public
//
//  Synopsis:   Gets Data associated with the HandlerID and OfflineItemID
//
//  Arguments:  [wHandlerId] - Id Of Handler the Item belongs too
//              [ItemID] - identifies the Item by its OfflineItemID
//              [pclsidHandler] - on return contains a pointer to the clsid of the Handler
//              [offlineItem] - on returns contains a pointer to the OfflineItem for the item.
//              [pfHiddenItem] - On return is a bool indicating if this item is a hidden item.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemDataAtIndex(HANDLERINFO *pHandlerId,REFSYNCMGRITEMID ItemID,CLSID *pclsidHandler,
                                            SYNCMGRITEM *offlineItem,BOOL *pfHiddenItem)
{
BOOL fFoundMatch = FALSE;
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
CLock clockqueue(this);

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
        // only valid if handler is in the PrepareForSync state.
        if (pHandlerId == pCurHandlerInfo->pHandlerId) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {

                if (ItemID == pCurItem->offlineItem.ItemID)
                {
                    fFoundMatch = TRUE;
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }


        }

        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    if (fFoundMatch)
    {
        *pclsidHandler = pCurHandlerInfo->clsidHandler;
        *offlineItem = pCurItem->offlineItem;
        *pfHiddenItem = pCurItem->fHiddenItem;

    }

    clockqueue.Leave();

    return fFoundMatch ? NOERROR : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindFirstItemInState, public
//
//  Synopsis:   Finds the first Item in the queue that matches the given state.
//
//  Arguments:  
//              [hndlrState]  - specifies matching state we are looking for.
//              [pwHandlerId] - on return contains the HandlerID of the Item
//              [pwItemID] - on returns contains the ItemID of the item in the queue.
//
//  Returns:    NOERROR if an Item was found with an unassigned ListView.
//              S_FALSE - if no Item was found.
//              Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindFirstItemInState(HANDLERSTATE hndlrState,
				   HANDLERINFO **ppHandlerId,WORD *pwItemID)
{
    return FindNextItemInState(hndlrState,0,0,ppHandlerId,pwItemID);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindNextItemInState, public
//
//  Synopsis:   Finds the first Item in the queue that matches the given state.
//              after the specified item.
//
//  Arguments:  
//              [hndlrState]  - specifies matching state we are looking for.
//              [pOfflineItemID] - on returns contains a pointer to the OfflineItem for the item.
//              [pwHandlerId] - on return contains the HandlerID of the Item
//              [pwItemID] - on returns contains the ItemID of the item in the queue.
//
//  Returns:    NOERROR if an Item was found with an unassigned ListView.
//              S_FALSE - if no Item was found.
//              Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindNextItemInState(HANDLERSTATE hndlrState,
                                 HANDLERINFO *pLastHandlerId,WORD wLastItemID,
				 HANDLERINFO **ppHandlerId,WORD *pwItemID)
{
BOOL fFoundMatch = FALSE;
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
CLock clockqueue(this);


    clockqueue.Enter();
    pCurHandlerInfo = m_pFirstHandler;

    if (0 != pLastHandlerId)
    {
        // loop until find the specified handler or hit end of list.
        while(pCurHandlerInfo && pLastHandlerId != pCurHandlerInfo->pHandlerId)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;

        if (NULL == pCurHandlerInfo) // reached end of list without finding the Handler
        {
            Assert(0); // user must have passed an invalid start HandlerID.
            clockqueue.Leave();
            return S_FALSE;
        }

        // loop until find item or end of item list
        pCurItem = pCurHandlerInfo->pFirstItem;
        while (pCurItem && pCurItem->wItemId != wLastItemID)
            pCurItem = pCurItem->pnextItem;

        if (NULL == pCurItem) // reached end of item list without finding the specified item
        {
            Assert(0); // user must have passed an invalid start ItemID.
            clockqueue.Leave();
            return S_FALSE;
        }

        // now we found the Handler and item. loop through remaining items for this handler 
        // if it still has another item then just return that.
        pCurItem = pCurItem->pnextItem;
        
        if (pCurItem)
        {
            Assert(hndlrState == pCurHandlerInfo->HandlerState); // should only be called in PrepareForSyncState
            fFoundMatch = TRUE;
        }

        if (!fFoundMatch)
            pCurHandlerInfo = pCurHandlerInfo->pNextHandler; // increment to next handler if no match
    }


    if (FALSE == fFoundMatch)
    {
        // in didn't find a match in the 
        while (pCurHandlerInfo)
        {
            if ((hndlrState == pCurHandlerInfo->HandlerState) 
                 && (pCurHandlerInfo->pFirstItem) )
            {
                pCurItem = pCurHandlerInfo->pFirstItem;
                fFoundMatch = TRUE;
                break;
            }

            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;        
        }
    }

    if (fFoundMatch)
    {
        *ppHandlerId = pCurHandlerInfo->pHandlerId;
        *pwItemID = pCurItem->wItemId;
    }

    clockqueue.Leave();

    return fFoundMatch ? NOERROR : S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetItemState, public
//
//  Synopsis:  Set the Item state for the first item finds that it 
//              matches in the Queue. Sets all other matches to unchecked.
//
//  Arguments:  
//
//  Returns:   Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetItemState(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID,DWORD dwState)
{
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
BOOL fFoundMatch = FALSE;
CLock clockqueue(this);


    if (QUEUETYPE_CHOICE != m_QueueType)
    {
        Assert(QUEUETYPE_CHOICE == m_QueueType);
        return E_UNEXPECTED;
    }

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (ItemID == pCurItem->offlineItem.ItemID)
                {

                    // if the handlerstate is not prepareforsync or not first match then uncheck
                    if ((HANDLERSTATE_PREPAREFORSYNC != pCurHandlerInfo->HandlerState)
                        || fFoundMatch)
                    {
                        pCurItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;


                    }
                    else
                    {
                        pCurItem->offlineItem.dwItemState = dwState;
                        fFoundMatch = TRUE;
                    }
                }

                pCurItem = pCurItem->pnextItem;
            }

        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;

    }

    clockqueue.Leave();

    Assert(fFoundMatch); // we should have found at least one match.

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SkipItem, public
//
//  Synopsis:   loop through handler and mark the items appropriately that match..
//
//  Arguments:  [iItem] - List View Item to skip.
//
//  Returns:   Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SkipItem(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID)
{
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
CLock clockqueue(this);
HRESULT hr = NOERROR;

    if (QUEUETYPE_PROGRESS != m_QueueType)
    {
        Assert(QUEUETYPE_PROGRESS == m_QueueType);
        return E_UNEXPECTED;
    }

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo )
    {

        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
            
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                // if item is cancelled then also treat as a match to
                // handle case cancel came in while in an out call.
                if ( ItemID == pCurItem->offlineItem.ItemID)
                {
                    // found an item, now if it hasn't started the sync or
                    // is not already complete set the value.

                    if ((pCurHandlerInfo->HandlerState < HANDLERSTATE_RELEASE) )
                    {
                           pCurItem->fItemCancelled = TRUE;

                        // If haven't called PrepareforSync yet then
                        // set uncheck the item so it isn't passed to PrepareForSync
                        // If PrepareForSync has already been called, call the items
                        // SkipMethod. if already in a setItemstatus call for this handler don't
                         // do anything.

                            // if not in another setitemstatus call loop through freeing all
                            // the items that have the cancel set.

                            // essentially a dup of cance and also handle case cancel
                             // comes win while this handler is in an out call.

                            if (!(pCurHandlerInfo->dwOutCallMessages & ThreadMsg_SetItemStatus))
                            {

                                pCurHandlerInfo->dwOutCallMessages |= ThreadMsg_SetItemStatus;

                                if (pCurHandlerInfo->HandlerState >= HANDLERSTATE_INPREPAREFORSYNC
                                        && pCurItem->fSynchronizingItem )
                                {
                                CThreadMsgProxy *pThreadProxy;
                                SYNCMGRITEMID ItemId;

                                    pThreadProxy = pCurHandlerInfo->pThreadProxy;
                                    ItemId = pCurItem->offlineItem.ItemID;
                                    clockqueue.Leave();

                                    if (pThreadProxy)
                                    {
                                        hr = pThreadProxy->SetItemStatus(ItemId,
                                                SYNCMGRSTATUS_SKIPPED);
                                    }

                                    clockqueue.Enter();

                                 }
                                 else 
                                 {
                                    // once done skipping handler if state is <= preparefor sync we set the state accordingly.
                                    // if were syncing up to handler.
                                    if ( (pCurHandlerInfo->HandlerState <= HANDLERSTATE_PREPAREFORSYNC)
                                        && (pCurItem->fIncludeInProgressBar) )
                                    {
                                    SYNCMGRPROGRESSITEM SyncProgressItem;

                                        // unheck the state so PrepareForsync doesn't include
                                        // this item.
                                        pCurItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;

                                        SyncProgressItem.cbSize = sizeof(SYNCMGRPROGRESSITEM);
                                        SyncProgressItem.mask = SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE | SYNCMGRPROGRESSITEM_STATUSTYPE;
                                        SyncProgressItem.iProgValue = HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE;
                                        SyncProgressItem.iMaxValue = HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE;
                                        SyncProgressItem.dwStatusType = SYNCMGRSTATUS_SKIPPED;

                                        // need to setup HwndCallback so progres gets updated. 
                                        // review, after ship why can't setup HwndCallback on transferqueueu
                                        pCurHandlerInfo->hWndCallback = m_hwndDlg;

                                        clockqueue.Leave();

                                        Progress(pCurHandlerInfo->pHandlerId,
                                                    pCurItem->offlineItem.ItemID,&SyncProgressItem);

                                       clockqueue.Enter();
                                    }

                                 }

                                 pCurHandlerInfo->dwOutCallMessages &= ~ThreadMsg_SetItemStatus;
                            }
                       }

                }

                pCurItem = pCurItem->pnextItem;
            }
        }


        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }


    clockqueue.Leave();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ItemHasProperties, public
//
//  Synopsis:  determines if the item in the queue has properties.
//              Uses the first item match it finds.
//
//  Arguments:  
//
//  Returns:   Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ItemHasProperties(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID)
{
LPHANDLERINFO pHandlerInfo;
LPITEMLIST pItem;
HRESULT hr = S_FALSE;
CLock clockqueue(this);


    Assert(QUEUETYPE_CHOICE == m_QueueType);
    ASSERT_LOCKNOTHELD(this);

    clockqueue.Enter();

    // item is guidNULL this is toplevel so use the getHandlerInfo, else see
    // if the item supports showProperties.

    if (NOERROR == FindItemData(clsidHandler,ItemID,
            HANDLERSTATE_PREPAREFORSYNC,HANDLERSTATE_PREPAREFORSYNC,&pHandlerInfo,&pItem))
    {
        if (GUID_NULL == ItemID)
        {
             Assert(NULL == pItem);

             hr = (pHandlerInfo->SyncMgrHandlerInfo).SyncMgrHandlerFlags 
                    & SYNCMGRHANDLER_HASPROPERTIES ? S_OK : S_FALSE;
        }
        else
        {
            Assert(pItem);
            
            if (pItem)
            {
                hr = (pItem->offlineItem).dwFlags & SYNCMGRITEM_HASPROPERTIES ? S_OK : S_FALSE;
            }
            else
            {
                hr = S_FALSE;
            }
        }

    }

    clockqueue.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ShowProperties, public
//
//  Synopsis:  Calls the ShowProperties Method on the first items it finds.
//              Uses the first item match it finds.
//
//  Arguments:  
//
//  Returns:   Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ShowProperties(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID,HWND hwndParent)
{
LPHANDLERINFO pHandlerInfo;
LPHANDLERINFO  pHandlerId = NULL;
LPITEMLIST pItem;
HRESULT hr = E_UNEXPECTED;
BOOL fHandlerCalled = FALSE;
BOOL fHasProperties = FALSE;
CThreadMsgProxy *pThreadProxy;
CLock clockqueue(this);

    Assert(QUEUETYPE_CHOICE == m_QueueType);
    ASSERT_LOCKNOTHELD(this);

    clockqueue.Enter();

    if (NOERROR == FindItemData(clsidHandler,ItemID,
            HANDLERSTATE_PREPAREFORSYNC,HANDLERSTATE_PREPAREFORSYNC,&pHandlerInfo,&pItem))
    {

        Assert(HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState);

        pThreadProxy = pHandlerInfo->pThreadProxy;
        pHandlerId = pHandlerInfo->pHandlerId;

        Assert(!(ThreadMsg_ShowProperties & pHandlerInfo->dwOutCallMessages));
        pHandlerInfo->dwOutCallMessages |= ThreadMsg_ShowProperties;


        if (GUID_NULL == ItemID && pHandlerInfo)
        {
            Assert(NULL == pItem);

            fHasProperties = (pHandlerInfo->SyncMgrHandlerInfo).SyncMgrHandlerFlags 
                    & SYNCMGRHANDLER_HASPROPERTIES ? TRUE : FALSE;

        }
        else if (pItem)
        {
            Assert(SYNCMGRITEM_HASPROPERTIES & pItem->offlineItem.dwFlags);
            fHasProperties = (pItem->offlineItem).dwFlags 
                        & SYNCMGRITEM_HASPROPERTIES ? TRUE : FALSE;

        }
        else
        {
            fHasProperties = FALSE;
        }
        
        clockqueue.Leave();

        // make sure properties flag isn't set.
        if (fHasProperties && pThreadProxy )
        {
            fHandlerCalled = TRUE;
            hr =  pThreadProxy->ShowProperties(hwndParent,ItemID);
        }
        else
        {
            AssertSz(0,"ShowProperties called on an Item without properties");
            hr = S_FALSE;
        }

        Assert(pHandlerId);

       if ( (fHandlerCalled && (FAILED(hr))) || (!fHandlerCalled) )
       {
       GUID guidCompletion = ItemID;
            
            CallCompletionRoutine(pHandlerId,ThreadMsg_ShowProperties,hr,1,&guidCompletion);

            // since called completion routine map anything but S_OK to S_FALSE;
            // so caller doesn't wait for the callback.

            if (S_OK != hr)
            {
                hr = S_FALSE;
            }
       }

    }
    else
    {
        Assert(FAILED(hr)); // should return some failure so caller knows callback isn't coming.
        clockqueue.Leave();
    }


   return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ReEnumHandlerItems, public
//
//  Synopsis:  Deletes any Items associated with any handlers that
//              match the clsid of the handler and then
//              call the first handlers in the list enumeration method
//              again.
//
//  Arguments:  
//
//  Returns:   Appropriate error return codes
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ReEnumHandlerItems(REFCLSID clsidHandler,REFSYNCMGRITEMID ItemID)
{
LPHANDLERINFO pCurHandlerInfo = NULL;
HANDLERINFO *pHandlerId = NULL;
LPITEMLIST pCurItem = NULL;
CLock clockqueue(this);

    if (QUEUETYPE_CHOICE != m_QueueType)
    {
        Assert(QUEUETYPE_CHOICE == m_QueueType);
        return E_UNEXPECTED;
    }

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        if (clsidHandler == pCurHandlerInfo->clsidHandler)
        {
        LPITEMLIST pNextItem;

            // if first handler we found update the handlerID
            if (NULL == pHandlerId)
            {
                pHandlerId = pCurHandlerInfo->pHandlerId;
                pCurHandlerInfo->HandlerState = HANDLERSTATE_ADDHANDLERTEMS; // put back to addhandlerItems statest
            }

            pCurHandlerInfo->wItemCount = 0;

            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                pNextItem = pCurItem->pnextItem;
                FREE(pCurItem);
                pCurItem = pNextItem;
            }

             pCurHandlerInfo->pFirstItem = NULL;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    // if have a handler id add them back to the queue
    if (pHandlerId)
    {
    DWORD cbNumItemsAdded;

        AddHandlerItemsToQueue(pHandlerId,&cbNumItemsAdded);
    }

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::IsItemCompleted, private
//
//  Synopsis:   Given an handler item determines if its
//              synchronization is completed
//
//              !!!This is not efficient. n! solution. If get
//              a lot of items may need to have to rewrite
//              and cache some information concerning dup
//              items.
//
//  Arguments:  [wHandlerId] - Handler the item belongs too.
//              [wItemID] - Identifies the Item
//
//  Returns:    
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CHndlrQueue::IsItemCompleted(LPHANDLERINFO pHandler,LPITEMLIST pItem)
{
CLSID clsidHandler;
SYNCMGRITEMID ItemId;
int iItemNotComplete = 0;

    Assert(pHandler);
    Assert(pItem);

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    clsidHandler = pHandler->clsidHandler;
    ItemId = pItem->offlineItem.ItemID;

    // back up to beginning of handler to simplify logic
    // items must be pCurItem->fIncludeInProgressBar && !pCurItem->fProgressBarHandled
    // to count toward not being a completion;

    while (pHandler)
    {
        if (pHandler->clsidHandler == clsidHandler)
        {
            // see if handler info has a matching item
            pItem = pHandler->pFirstItem;

            while (pItem)
            {
                if (pItem->offlineItem.ItemID
                            == ItemId)
                {

                    if (pItem->fIncludeInProgressBar 
                            && !pItem->fProgressBarHandled)
                    {
                        if (pItem->iProgValue < pItem->iProgMaxValue)
                        {
                            ++iItemNotComplete;
                        }

                        pItem->fProgressBarHandled = TRUE;
                    }
                }

                pItem = pItem->pnextItem;
            }
        }

        pHandler = pHandler->pNextHandler;
    }

    return iItemNotComplete ? FALSE : TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetItemProgressInfo, public
//
//  Synopsis:   Updates the stored progress information for the
//              Associated Items
//
//  Arguments:  [wHandlerId] - Handler the item belongs too.
//              [wItemID] - Identifies the Item
//              [pSyncProgressItem] - Pointer to Progress Information.
//              [pfProgressChanged] - returns true if any progress values were changed
//                      for the item
//
//  Returns:    NOERROR - at least one item with the iItem assigned was found
//              S_FALSE - Item does not have properties.
//              Appropriate error return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetItemProgressInfo(HANDLERINFO *pHandlerId,WORD wItemID,
                                                LPSYNCMGRPROGRESSITEM pSyncProgressItem,
                                                 BOOL *pfProgressChanged)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
BOOL fFoundMatch = FALSE;
LPITEMLIST pCurItem = NULL;
CLock clockqueue(this);

    Assert(pfProgressChanged);

    *pfProgressChanged = FALSE;

    if (QUEUETYPE_PROGRESS != m_QueueType)
    {
        Assert(QUEUETYPE_PROGRESS == m_QueueType);
        return E_UNEXPECTED; // review error code.
    }

    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {

        // try to find the matching item.
        pCurItem = pHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            if (wItemID == pCurItem->wItemId)
            {
                fFoundMatch = TRUE;
                break;
            }

            pCurItem = pCurItem->pnextItem;
        }
    }

    if (fFoundMatch)
    {
        SetItemProgressInfo(pCurItem,pSyncProgressItem,pfProgressChanged);
    }

    clockqueue.Leave();

    return fFoundMatch ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetItemProgressInfo, private
//
//  Synopsis:   Updates the stored progress information for the
//              Associated iTEM
//
//  Arguments:  [pItem] - Identifies the Item
//              [pSyncProgressItem] - Pointer to Progress Information.
//              [pfProgressChanged] - returns true if any progress values were changed
//                      for the item
//
//  Returns:    NOERROR - at least one item with the iItem assigned was found
//              Appropriate error return codes
//
//              !!Caller must have already taken a lock.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetItemProgressInfo(LPITEMLIST pItem,LPSYNCMGRPROGRESSITEM pSyncProgressItem,
                                        BOOL *pfProgressChanged)
{
BOOL fProgressAlreadyCompleted;


    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    // progress is considered complete if Values is >= Maxa
    fProgressAlreadyCompleted = (pItem->iProgMaxValue <= pItem->iProgValue);

    if (SYNCMGRPROGRESSITEM_MAXVALUE & pSyncProgressItem->mask)
    {
        // if Progress Max Value is negative then don't set.
        if (pSyncProgressItem->iMaxValue >= 0)
        {
            if (pItem->iProgMaxValue != pSyncProgressItem->iMaxValue)
            {
                *pfProgressChanged = TRUE;
                pItem->fProgValueDirty = TRUE;
                pItem->iProgMaxValue = pSyncProgressItem->iMaxValue;
            }
        }
    }

    if (SYNCMGRPROGRESSITEM_PROGVALUE & pSyncProgressItem->mask)
    {
        // if progress value is negative, don't change it
        if (pSyncProgressItem->iProgValue > 0)
        {
            if (pItem->iProgValue != pSyncProgressItem->iProgValue)
            {
                *pfProgressChanged = TRUE;
                pItem->fProgValueDirty = TRUE;
                pItem->iProgValue = pSyncProgressItem->iProgValue;
            }
        }
    }

    if (SYNCMGRPROGRESSITEM_STATUSTYPE & pSyncProgressItem->mask)
    {
        if (pItem->dwStatusType != pSyncProgressItem->dwStatusType)
        {
            *pfProgressChanged = TRUE;
            pItem->dwStatusType = pSyncProgressItem->dwStatusType;

            // if status is complete set the progvalue == to the max
            // on behalf of the handler so the Items completed and progress bar
            // gets updated.
            if (pItem->dwStatusType == SYNCMGRSTATUS_SKIPPED
                || pItem->dwStatusType == SYNCMGRSTATUS_SUCCEEDED
                || pItem->dwStatusType == SYNCMGRSTATUS_FAILED )
            {
                pItem->fProgValueDirty = TRUE;
                pItem->iProgValue = pItem->iProgMaxValue;
            }
        }
    }

    // if progressValue is > max then set it to max

    if (pItem->iProgValue > pItem->iProgMaxValue)
    {
        // AssertSz(0,"Progress Value is > Max");
        pItem->iProgValue = pItem->iProgMaxValue;
    }

    // see if need to recalc numItems completed next time
    // GetProgressInfo is Called.
    BOOL fProgressCompletedNow = (pItem->iProgMaxValue <= pItem->iProgValue);

    if (fProgressAlreadyCompleted != fProgressCompletedNow)
    {
        m_fNumItemsCompleteNeedsARecalc = TRUE;
    }

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetItemProgressValues, private
//
//  Synopsis:   Private helper function for updating/initializing
//              an items progress bar values. 
//
//  Arguments:  [pItem] - Identifies the Item
//              [pSyncProgressItem] - Pointer to Progress Information.
//              [pfProgressChanged] - returns true if any progress values were changed
//                      for the item
//
//  Returns:    NOERROR - at least one item with the iItem assigned was found
//              Appropriate error return codes
//
//              !!Caller must have already taken a lock.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetItemProgressValues(LPITEMLIST pItem,INT iProgValue,INT iProgMaxValue)
{
SYNCMGRPROGRESSITEM SyncProgressItem;
BOOL fProgressChanged;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    SyncProgressItem.cbSize = sizeof(SYNCMGRPROGRESSITEM);
    SyncProgressItem.mask = SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE;
    SyncProgressItem.iProgValue = iProgValue;
    SyncProgressItem.iMaxValue = iProgMaxValue;

    return SetItemProgressInfo(pItem,&SyncProgressItem,&fProgressChanged);
}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetProgressInfo, public
//
//  Synopsis:    calculates current progress bar values and number of items complete.
//
//  Arguments:  [piProgValue] - on return contains the new Progress Bar Value.
//              [piMaxValue] - on return contains the Progress Bar Max Value
//              [piNumItemsComplete] - on returns contains number of items complete.
//              [iNumItemsTotal] - on returns contains number of total items.
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetProgressInfo(INT *piProgValue,INT *piMaxValue,INT *piNumItemsComplete,
                                            INT *piNumItemsTotal)
{
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
INT iCurValue;
BOOL fNormalizedValueChanged = FALSE;
CLock clockqueue(this);

    if (QUEUETYPE_PROGRESS != m_QueueType)
    {
        Assert(QUEUETYPE_PROGRESS == m_QueueType);
        return E_UNEXPECTED; // review error code.
    }

    clockqueue.Enter();

     // if m_fNumItemsCompleteNeedsARecalc is set need 
    // to recalc normalized and numItems Comlete and Total Items.

    if (m_fNumItemsCompleteNeedsARecalc)
    {
    INT iNormalizedMax;

        m_ulProgressItemCount = 0;

        // get the number of selected items in the queue.
        pCurHandlerInfo = m_pFirstHandler;

        while (pCurHandlerInfo)
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (pCurItem->fIncludeInProgressBar)
                {
                     //if this item should be included in the progress, increment the progress bar count.
                      ++m_ulProgressItemCount;

                      pCurItem->fProgressBarHandled = FALSE; // reset handled 
                }

                pCurItem = pCurItem->pnextItem;
            }


            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
        }

        if (0 == m_ulProgressItemCount)
        {
            iNormalizedMax = 0;
        }
        else
        {
            iNormalizedMax = MAXPROGRESSVALUE/m_ulProgressItemCount;

            if (0 == iNormalizedMax)
            {
                iNormalizedMax = 1;
            }
        }

        if (m_iNormalizedMax != iNormalizedMax)
        {
            fNormalizedValueChanged = TRUE;
            m_iNormalizedMax = iNormalizedMax;
        }

    }

    // now loop thruogh again getting total CurValue and finished items
    // we say an item is finished if it is out of the synchronize method or the min==max.

    pCurHandlerInfo = m_pFirstHandler;
    iCurValue = 0;

    // if numitemcount needs updated reset the member vars
    if (m_fNumItemsCompleteNeedsARecalc)
    {
        m_iCompletedItems = 0;
        m_iItemCount = 0;
    }
        

    while (pCurHandlerInfo)
    {
        // see if handler info has a matching item
        pCurItem = pCurHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            if (pCurItem->fIncludeInProgressBar)
            {
                // if Progress is dirty or normalized value changed
                // need to recalc this items progress value

                if (pCurItem->fProgValueDirty || fNormalizedValueChanged)
                {
                int iProgValue = pCurItem->iProgValue;
                int iProgMaxValue = pCurItem->iProgMaxValue;
                
                    if (iProgValue && iProgMaxValue)
                    {
                        pCurItem->iProgValueNormalized =  (int) ((1.0*iProgValue*m_iNormalizedMax)/iProgMaxValue);
                    }
                    else
                    {
                        pCurItem->iProgValueNormalized = 0;
                    }

                    pCurItem->fProgValueDirty = FALSE;
                }

                iCurValue += pCurItem->iProgValueNormalized;

                // Handle NumItems needing to be recalc'd
                if (m_fNumItemsCompleteNeedsARecalc && !pCurItem->fProgressBarHandled)
                {

                    ++m_iItemCount;
            
                    // now loop through this item and  remaining items and if any match
                    // mark as handled and if complete then incrment the compleated count;
                    if (IsItemCompleted(pCurHandlerInfo,pCurItem))
                    {
                        ++m_iCompletedItems;
                    }

                }

            }


            pCurItem = pCurItem->pnextItem;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    m_fNumItemsCompleteNeedsARecalc = FALSE; 

    *piProgValue = iCurValue;
    *piMaxValue = m_iNormalizedMax*m_ulProgressItemCount;
    
    *piNumItemsComplete = m_iCompletedItems;
    *piNumItemsTotal = m_iItemCount;

    Assert(*piProgValue <= *piMaxValue);

    clockqueue.Leave();

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::RemoveFinishedProgressItems, public
//
//  Synopsis:   Loops through handler setting any finished items
//              fIncludeInProgressBar value to false
//
//  Arguments:
//
//  Returns:   Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::RemoveFinishedProgressItems()
{
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
CLock clockqueue(this);

    clockqueue.Enter();

    m_fNumItemsCompleteNeedsARecalc = TRUE;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        // mark any items that have completed their synchronization.
        if (HANDLERSTATE_INSYNCHRONIZE < pCurHandlerInfo->HandlerState)
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                pCurItem->fIncludeInProgressBar = FALSE;
                pCurItem = pCurItem->pnextItem;
            }

        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AreAnyItemsSelectedInQueue, public
//
//  Synopsis:   Determines if there are any items selected in the queue.
//              can be called by choice dialog for example before creating
//              progress and doing a transfer since there is no need to
//              if nothing to sync anyways.
//
//  Arguments:
//
//  Returns:   TRUE - At least one item is selected inthe queue
//             FALSE - No Items are slected in the queue.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CHndlrQueue::AreAnyItemsSelectedInQueue()
{
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
BOOL fFoundSelectedItem = FALSE;
CLock clockqueue(this);

    clockqueue.Enter();

    // invalidate UI that applies to entire queue
    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundSelectedItem)
    {

        // if handler state is less than a completion go ahead and
        // check the items.
        if (HANDLERSTATE_HASERRORJUMPS > pCurHandlerInfo->HandlerState)
        {

            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                // clear Item UI information
                if (pCurItem->offlineItem.dwItemState == SYNCMGRITEMSTATE_CHECKED)
                {
                    fFoundSelectedItem = TRUE;
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return fFoundSelectedItem;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::PersistChoices, public
//
//  Synopsis:   Saves Selected Users choices for the next time
//              the choice dialog is brought up. Only should
//              be called from a choice queue.
//
//  Arguments:
//
//  Returns:   Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::PersistChoices(void)
{
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
CLock clockqueue(this);

    if (QUEUETYPE_CHOICE != m_QueueType)
    {
        Assert(QUEUETYPE_CHOICE == m_QueueType);
        return S_FALSE;
    }

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    // currently only persist on a manual invoke since user
    // has to go to settings to change other invoke types and
    // that is persisted

    // since this is the choice queue we know all handlers have the
    // same JobID. if this ever changes, have to set on a case by
    // case basis.

    if (m_pFirstJobInfo && m_pFirstJobInfo->pConnectionObj &&
            (SYNCMGRFLAG_MANUAL  == (m_pFirstJobInfo->dwSyncFlags & SYNCMGRFLAG_EVENTMASK)) )
    {
    TCHAR *pszConnectionName = m_pFirstJobInfo->pConnectionObj[0]->pwszConnectionName;
    DWORD dwSyncFlags = m_pFirstJobInfo->dwSyncFlags;


        Assert(1 == m_pFirstJobInfo->cbNumConnectionObjs); // assert manual only ever has one connectionObj
        // delete all previously stored preferences.
        // this is valid because only called from choice queue that all ConnectionNames are the same.
        
        if (!m_fItemsMissing)
        {
            RegRemoveManualSyncSettings(pszConnectionName);
        }

        pCurHandlerInfo = m_pFirstHandler;

        while (pCurHandlerInfo)
        {
            // only save if Handler is in the PrepareForSync state.
            // bug, need to make sure return code from enum wasn't missing items
            if (HANDLERSTATE_PREPAREFORSYNC == pCurHandlerInfo->HandlerState )
            {
                // save out these items.
                pCurItem = pCurHandlerInfo->pFirstItem;

                while (pCurItem)
                {
                    if (!pCurItem->fDuplicateItem)
                    {
                        switch(dwSyncFlags & SYNCMGRFLAG_EVENTMASK)
                        {
                        case SYNCMGRFLAG_MANUAL:
                            RegSetSyncItemSettings(SYNCTYPE_MANUAL,
                                                pCurHandlerInfo->clsidHandler,
                                                pCurItem->offlineItem.ItemID,
                                                pszConnectionName,
                                                pCurItem->offlineItem.dwItemState,
                                                NULL);
                            break;
                        default:
                            AssertSz(0,"UnknownSyncFlag Event");
                            break;
                        };
                    }

                    pCurItem = pCurItem->pnextItem;
                }

            }

            pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
        }
    }

    clockqueue.Leave();

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindFirstHandlerInState, public
//
//  Synopsis:   Finds the first Handler that matches the specified
//              state in the queue.
//
//  Arguments:  [hndlrState] - Requested handler state.
//              [pwHandlerID] - on success filled with HandlerID that was found
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindFirstHandlerInState(HANDLERSTATE hndlrState, REFCLSID clsidHandler,
                                                    HANDLERINFO **ppHandlerId,CLSID *pMatchHandlerClsid)
{
    return FindNextHandlerInState(0,clsidHandler,hndlrState,ppHandlerId,pMatchHandlerClsid);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindNextHandlerInState, public
//
//  Synopsis:   Finds next handler after LastHandlerID in the queue that matches
//              the requested state. Passing in 0 for the LastHandlerID is the same
//              as calling FindFirstHandlerInState
//
//              if GUID_NULL is passed in for the clsidHandler the first handler that
//              matches the specified state is returned.
//
//  Arguments:  [wLastHandlerID] - Id of last handler found.
//              [clsidHandler] - specific handler classid is requested, only find matches with this clsid
//              [hndlrState] - Requested handler state.
//              [pwHandlerID] - on success filled with HandlerID that was found
//              [pMatchHandlerClsid] - on sucdess clsid of handler found.
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindNextHandlerInState(HANDLERINFO *pLastHandlerID,REFCLSID clsidHandler,
                                        HANDLERSTATE hndlrState,HANDLERINFO **ppHandlerID,CLSID *pMatchHandlerClsid)
{
HRESULT hr = S_FALSE;
LPHANDLERINFO pCurHandler;
CLock clockqueue(this);

    *ppHandlerID = 0;

    clockqueue.Enter();

    pCurHandler = m_pFirstHandler;

    if (0 != pLastHandlerID)
    {
        // loop foward until find the last handlerID we checked or hit the end
        while (pCurHandler)
        {

            if (pLastHandlerID == pCurHandler->pHandlerId)
            {
                break;
            }

            pCurHandler = pCurHandler->pNextHandler;
        }

        if (NULL != pCurHandler)
        {
            pCurHandler = pCurHandler->pNextHandler; // increment to next handler.
        }
    }

    while (pCurHandler)
    {
        if (hndlrState == pCurHandler->HandlerState
               && ((GUID_NULL == clsidHandler) || (clsidHandler ==  pCurHandler->clsidHandler)) )
        {
            *ppHandlerID = pCurHandler->pHandlerId;
            *pMatchHandlerClsid = pCurHandler->clsidHandler;
            hr = NOERROR;
            break;
        }

        pCurHandler = pCurHandler->pNextHandler;
    }

    clockqueue.Leave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::CreateServer, public
//
//  Synopsis:   Creates a new proxy then calls proxy to create and instance of the
//              specified handler.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [pCLSIDServer] - CLSID of Handler to Create.
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::CreateServer(HANDLERINFO *pHandlerId, const CLSID *pCLSIDServer)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
CLock clockqueue(this);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {

        Assert(HANDLERSTATE_CREATE == pHandlerInfo->HandlerState);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        if (HANDLERSTATE_CREATE == pHandlerInfo->HandlerState)
        {
            pHandlerInfo->HandlerState = HANDLERSTATE_INCREATE;
            Assert(NULL == pHandlerInfo->pThreadProxy);

            // see if there is already a thread for this handler's
            // CLSID.

            hr =  CreateHandlerThread(&(pHandlerInfo->pThreadProxy),m_hwndDlg,
                *pCLSIDServer);

            if (NOERROR == hr)
            {
            HANDLERINFO *pHandlerIdArg;
            CThreadMsgProxy *pThreadProxy;

                pHandlerIdArg = pHandlerInfo->pHandlerId;
                pThreadProxy = pHandlerInfo->pThreadProxy;

                clockqueue.Leave();

                hr = pThreadProxy->CreateServer(pCLSIDServer,this,pHandlerIdArg);

                clockqueue.Enter();

                pHandlerInfo->pThreadProxy = pThreadProxy;
            }

            if (NOERROR  == hr)
            {
                pHandlerInfo->clsidHandler = *pCLSIDServer;
                pHandlerInfo->HandlerState = HANDLERSTATE_INITIALIZE;
            }
            else
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
            }
        }

        pHandlerInfo->dwCallNestCount--;

    }

    clockqueue.Leave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Initialize, public
//
//  Synopsis:   Calls Hanlder's Initialize method
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [dwReserved] - Initialize reserved parameter
//              [dwSyncFlags] - Sync flags
//              [cbCookie] - size of cookie data
//              [lpCookie] - ptr to cookie data
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Initialize(HANDLERINFO *pHandlerId,DWORD dwReserved,DWORD dwSyncFlags,
                    DWORD cbCookie,const BYTE *lpCooke)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
CLock clockqueue(this);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(HANDLERSTATE_INITIALIZE == pHandlerInfo->HandlerState);
        Assert(NULL != pHandlerInfo->pThreadProxy);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        if (HANDLERSTATE_INITIALIZE == pHandlerInfo->HandlerState
                && (NULL != pHandlerInfo->pThreadProxy) )
        {
        CThreadMsgProxy *pThreadProxy;


            Assert(dwSyncFlags & SYNCMGRFLAG_EVENTMASK); // an event should be set
            pHandlerInfo->HandlerState = HANDLERSTATE_ININITIALIZE;

            pThreadProxy = pHandlerInfo->pThreadProxy;

            clockqueue.Leave();

            hr =  pThreadProxy->Initialize(dwReserved,dwSyncFlags,cbCookie,lpCooke);

            clockqueue.Enter();

            if (NOERROR  == hr)
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_ADDHANDLERTEMS;
            }
            else
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
            }

        }

        pHandlerInfo->dwCallNestCount--;
    }

    clockqueue.Leave();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AddHandlerItemsToQueue, public
//
//  Synopsis:   Calls through to proxy to add items to the queue
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//
//  Returns:    Appropriate return codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::AddHandlerItemsToQueue(HANDLERINFO *pHandlerId,DWORD *pcbNumItems)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
CLock clockqueue(this);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    Assert(pcbNumItems);
    Assert(QUEUETYPE_CHOICE == m_QueueType); // items should only be added in a choice queue.

    *pcbNumItems = 0;

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        Assert(HANDLERSTATE_ADDHANDLERTEMS == pHandlerInfo->HandlerState);
        Assert(NULL != pHandlerInfo->pThreadProxy);

        if (HANDLERSTATE_ADDHANDLERTEMS == pHandlerInfo->HandlerState
                && (NULL != pHandlerInfo->pThreadProxy) )
        {
         CThreadMsgProxy *pThreadProxy;

            pHandlerInfo->HandlerState = HANDLERSTATE_INADDHANDLERITEMS;
            pThreadProxy = pHandlerInfo->pThreadProxy;

            clockqueue.Leave();

            // on return all items should be filled in.
            hr =  pThreadProxy->AddHandlerItems(NULL /* HWND */,pcbNumItems);

            clockqueue.Enter();

            if (NOERROR  == hr || S_SYNCMGR_MISSINGITEMS == hr)
            {

                m_fItemsMissing |= (S_SYNCMGR_MISSINGITEMS == hr);

                hr = NOERROR; // review, need to handler missing items in registry.
                pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;
            }
            else
            {
                // on an error, go ahead and release the proxy if server can't enum
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
                *pcbNumItems = 0;
            }
        }

        pHandlerInfo->dwCallNestCount--;
    }

    clockqueue.Leave();
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetItemObject, public
//
//  Synopsis:   Calls through to proxy to get an items object pointer
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [wItemID] - ID of item to get the object of.
//              [riid] - interface requested of the object
//              [ppv] - on success is a pointer to the newly created object
//
//  Returns:    Currently all handlers should return E_NOTIMPL.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::GetItemObject(HANDLERINFO *pHandlerId,WORD wItemID,REFIID riid,void** ppv)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
CLock clockqueue(this);

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
    LPITEMLIST pCurItem;

        Assert(HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState);
        Assert(NULL != pHandlerInfo->pThreadProxy);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        if (HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState
                && (NULL != pHandlerInfo->pThreadProxy))
        {
            // now try to find the item.
            pCurItem = pHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (wItemID == pCurItem->wItemId)
                {
                CThreadMsgProxy *pThreadProxy;
                SYNCMGRITEMID ItemID;

                    pThreadProxy = pHandlerInfo->pThreadProxy;
                    ItemID = pCurItem->offlineItem.ItemID;
                    clockqueue.Leave();

                    hr = pThreadProxy->GetItemObject(ItemID,riid,ppv);

                    return hr;
                }

                pCurItem = pCurItem->pnextItem;
            }
        }

        pHandlerInfo->dwCallNestCount--;
    }

    clockqueue.Leave();

    AssertSz(0,"Specified object wasn't found");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetUpProgressCallback, public
//
//  Synopsis:   Calls through to proxy to set up the progress callback
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [fSet] - TRUE == create, FALSE == destroy.
//              [hwnd] - Callback info should be sent to specified window.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetUpProgressCallback(HANDLERINFO *pHandlerId,BOOL fSet,HWND hwnd)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
CLock clockqueue(this);

    AssertSz(0,"this function no longer used");

    return E_NOTIMPL;

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState || FALSE == fSet);
        Assert(NULL != pHandlerInfo->pThreadProxy);

        Assert(1 == pHandlerInfo->dwCallNestCount); // should be called from PrepareForSync
        pHandlerInfo->dwCallNestCount++;

        if ( ((FALSE == fSet) || (HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState))
                && (NULL != pHandlerInfo->pThreadProxy))
        {
        CThreadMsgProxy *pThreadProxy;

            pHandlerInfo->hWndCallback = hwnd;
            pHandlerInfo->HandlerState = HANDLERSTATE_INSETCALLBACK;

            pThreadProxy = pHandlerInfo->pThreadProxy;

            clockqueue.Leave();
            hr = pThreadProxy->SetupCallback(fSet);
            clockqueue.Enter();

            pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;

            if (hr != NOERROR) // make sure on error the hwnd gets set back to NULL.
                pHandlerInfo->hWndCallback = NULL;
        }

        pHandlerInfo->dwCallNestCount--;

    }

    clockqueue.Leave();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::PrepareForSync, public
//
//  Synopsis:   Calls through to Handlers PrepareForSync method.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [hWndParent] - Hwnd to use for any displayed dialogs.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::PrepareForSync(HANDLERINFO *pHandlerId,HWND hWndParent)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
ULONG cbNumItems;
SYNCMGRITEMID *pItemIDs;
BOOL fHandlerCalled = FALSE;
CLock clockqueue(this);


    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();



    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {

        Assert(HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState);
        Assert(NULL != pHandlerInfo->pThreadProxy);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        Assert(!(ThreadMsg_PrepareForSync & pHandlerInfo->dwOutCallMessages));
        pHandlerInfo->dwOutCallMessages |= ThreadMsg_PrepareForSync;

        if (HANDLERSTATE_PREPAREFORSYNC == pHandlerInfo->HandlerState)
        {

            // if item doesn't have a ThreadProxy or it has been cancelled,
            // put in the Release State

            if ( (NULL == pHandlerInfo->pThreadProxy) || (pHandlerInfo->fCancelled) )
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
            }
            else
            {
                // create a list of the selected items and pass to PrepareForSync
                cbNumItems = GetSelectedItemsInHandler(pHandlerInfo,0,NULL);
                if (0 == cbNumItems)
                {
                    // if no items selected don't call prepareforsync
                    // and set the HandlerState so it can be released
                    pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
                    hr = S_FALSE;
                }
                else
                {
                    pItemIDs = (SYNCMGRITEMID *) ALLOC(sizeof(SYNCMGRITEMID)*cbNumItems);

                    if (NULL != pItemIDs)
                    {
                        // loop through items filling in the proper data
                        GetSelectedItemsInHandler(pHandlerInfo,&cbNumItems,pItemIDs);

                        if (0 == cbNumItems)
                        {
                            hr = S_FALSE; // There are no selected items.
                        }
                        else
                        {
                        CThreadMsgProxy *pThreadProxy;
                        JOBINFO *pJobInfo = NULL;

                            pHandlerInfo->HandlerState = HANDLERSTATE_INPREPAREFORSYNC;

                            pThreadProxy = pHandlerInfo->pThreadProxy;
                            pHandlerInfo->hWndCallback = hWndParent;
                            pJobInfo = pHandlerInfo->pJobInfo;

                            // if we need to dial to make the connection do
                            // so now.

                            clockqueue.Leave();

                            DWORD dwSyncFlags = pJobInfo->dwSyncFlags & SYNCMGRFLAG_EVENTMASK;
                            BOOL fAutoDialDisable = TRUE;
                            if ( dwSyncFlags == SYNCMGRFLAG_MANUAL || dwSyncFlags == SYNCMGRFLAG_INVOKE )
                                fAutoDialDisable = FALSE;

                            //
                            // Ignore failure return from ApplySyncItemDialState
                            //
                            ApplySyncItemDialState( fAutoDialDisable );

                            hr = OpenConnection(pJobInfo);

                            if (NOERROR == hr)
                            {

                                // if this is on an idle write out the last
                                // handler id

                                // review - if don't wait to call PrepareForSync
                                // on idle the setlastIdlehandler should be called on sync.
                                if (pJobInfo && (SYNCMGRFLAG_IDLE ==
                                        (pJobInfo->dwSyncFlags  & SYNCMGRFLAG_EVENTMASK)) )
                                {
                                    SetLastIdleHandler(pHandlerInfo->clsidHandler);
                                }

                                fHandlerCalled = TRUE;
                                hr =  pThreadProxy->PrepareForSync(cbNumItems,pItemIDs,
                                                        hWndParent,0 /* dwReserved */ );

                            }
                            else
                            {
                                clockqueue.Enter();
                                pHandlerInfo->hWndCallback = NULL;
                                clockqueue.Leave();
                            }
                        }

                        // on return from PrepareFroSync or error need to free items
                        clockqueue.Enter();
                        FREE(pItemIDs);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }

    clockqueue.Leave();

    // if the handler returns an errorfrom PrepareForSync we need
    // to call the completion routine ourselves and/or we never got to the point
    // of making the outcall.

   if ( (fHandlerCalled && (NOERROR != hr)) || (!fHandlerCalled))
   {
        CallCompletionRoutine(pHandlerId,ThreadMsg_PrepareForSync,hr,0,NULL);
   }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::PrepareForSyncCompleted, public
//
//  Synopsis:   Called by completion routine on a PrepareForSyncCompleted
//
//              Warning: Assume queue is locked and pHandlerInfo has
//                  already been verified.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::PrepareForSyncCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult)
{

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    if (NOERROR  == hCallResult)
    {
         pHandlerInfo->HandlerState = HANDLERSTATE_SYNCHRONIZE;
    }
    else
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
    }

    if ( (pHandlerInfo->HandlerState != HANDLERSTATE_SYNCHRONIZE))
    {
    // if handler didn't make it to the synchronize state then fix up the items
    LPITEMLIST pCurItem = NULL;

        // prepare for sync either doesn't want to handle the
        // items or an error occured,
        // need to go ahead and mark the items as completed.
        // same routine that is after synchronize.

        pCurItem = pHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            SetItemProgressValues(pCurItem,
                    HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE,
                    HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);

            pCurItem->fSynchronizingItem = FALSE;

            pCurItem = pCurItem->pnextItem;
         }

    }

    pHandlerInfo->dwCallNestCount--; // decrement nestcount put on by PrepareForSync call.

    // if the handler state has been released but it has some jumptext, which it can if
    // the PrepareForsync was caused by a retry then set the results to HANDLERSTATE_HASERRORJUMPS
    if ((HANDLERSTATE_RELEASE == pHandlerInfo->HandlerState) && (pHandlerInfo->fHasErrorJumps))
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_HASERRORJUMPS;
    }

    return NOERROR;

}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Synchronize, public
//
//  Synopsis:   Calls through to Handlers Synchronize method.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [hWndParent] - Hwnd to use for any displayed dialogs.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Synchronize(HANDLERINFO *pHandlerId,HWND hWndParent)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
BOOL fHandlerCalled = FALSE;
CLock clockqueue(this);

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    ASSERT_LOCKNOTHELD(this);
    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {

        Assert(HANDLERSTATE_SYNCHRONIZE == pHandlerInfo->HandlerState);
        Assert(NULL != pHandlerInfo->pThreadProxy);

        Assert(0 == pHandlerInfo->dwCallNestCount);
        pHandlerInfo->dwCallNestCount++;

        Assert(!(ThreadMsg_Synchronize & pHandlerInfo->dwOutCallMessages));
        pHandlerInfo->dwOutCallMessages |= ThreadMsg_Synchronize;

        if (HANDLERSTATE_SYNCHRONIZE == pHandlerInfo->HandlerState
                && (NULL != pHandlerInfo->pThreadProxy) )
        {

            // make sure the handler has a proxy and the item
            // wasn't cancelled.
            if ( (NULL == pHandlerInfo->pThreadProxy) || (pHandlerInfo->fCancelled))
            {
                pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
            }
            else
            {
            CThreadMsgProxy *pThreadProxy;

                pHandlerInfo->HandlerState = HANDLERSTATE_INSYNCHRONIZE;
                pThreadProxy= pHandlerInfo->pThreadProxy;


                clockqueue.Leave();
                fHandlerCalled = TRUE;
                hr =  pThreadProxy->Synchronize(hWndParent);
                clockqueue.Enter();
            }
        }
    }


    clockqueue.Leave();

    // if the handler returns an error from Synchronize we need
    // to call the completion routine ourselves and/or we never got to the point
    // of making the outcall.

   if ( (fHandlerCalled && (NOERROR != hr)) || (!fHandlerCalled) )
   {
        CallCompletionRoutine(pHandlerId,ThreadMsg_Synchronize,hr,0,NULL);
   }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SynchronizeCompleted, public
//
//  Synopsis:   Called by completion routine on a SynchronizeCompleted
//
//              Warning: Assume queue is locked and pHandlerInfo has
//                  already been verified.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SynchronizeCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult)
{
LPITEMLIST pCurItem = NULL;
BOOL fRetrySync = FALSE;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    if (pHandlerInfo->fRetrySync)
    {
        // if a retry request came in during the sync, retry it.
        pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;
        pHandlerInfo->fRetrySync = FALSE; // reset the retry sync flag.
        fRetrySync = TRUE;
    }
    else if (pHandlerInfo->fHasErrorJumps)
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_HASERRORJUMPS;
    }
    else
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_RELEASE;
    }

     // when come out of synchronize we set the items values for them.
    // in case they were negligent.
    pCurItem = pHandlerInfo->pFirstItem;

    while (pCurItem)
    {
        SetItemProgressValues(pCurItem,
                    HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE,
                    HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);

        pCurItem->fSynchronizingItem = FALSE;

        pCurItem = pCurItem->pnextItem;

    }

    pHandlerInfo->dwCallNestCount--; // remove nest count

     // if the handler state has been released but it has some jumptext, which it can if
    // the sycnrhonize was caused by a retry then set the results to HANDLERSTATE_HASERRORJUMPS

    if ((HANDLERSTATE_RELEASE == pHandlerInfo->HandlerState) && (pHandlerInfo->fHasErrorJumps))
    {
        pHandlerInfo->HandlerState = HANDLERSTATE_HASERRORJUMPS;
    }

    return NOERROR;

}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ShowError, public
//
//  Synopsis:   Calls through to Handlers ShowError method.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [hWndParent] - Hwnd to use for any displayed dialogs.
//              [dwErrorID] - Identifies the error to show
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ShowError(HANDLERINFO *pHandlerId,HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
BOOL fHandlerCalled = FALSE;
BOOL fAlreadyInShowErrors = TRUE;
CLock clockqueue(this);

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        Assert(TRUE == pHandlerInfo->fHasErrorJumps);
        Assert(NULL != pHandlerInfo->pThreadProxy);

         // if we are already handling a ShowError for this handler then don't
        // start another one

        if (!(pHandlerInfo->fInShowErrorCall))
        {

            fAlreadyInShowErrors = FALSE;
            m_dwShowErrororOutCallCount++; // increment handlers ShowError OutCall Count.

            Assert(!(ThreadMsg_ShowError & pHandlerInfo->dwOutCallMessages));
            pHandlerInfo->dwOutCallMessages |= ThreadMsg_ShowError;


            if (NULL != pHandlerInfo->pThreadProxy )
            {
            CThreadMsgProxy *pThreadProxy;
            ULONG cbNumItems = 0; // review, these are not longer necessary.
            SYNCMGRITEMID *pItemIDs = NULL;

                pThreadProxy = pHandlerInfo->pThreadProxy;
                fHandlerCalled = TRUE;
                pHandlerInfo->fInShowErrorCall = TRUE;

                clockqueue.Leave();
                hr =  pThreadProxy->ShowError(hWndParent,ErrorID,&cbNumItems,&pItemIDs);
                clockqueue.Enter();
            }
        }
    }

    clockqueue.Leave();

    // if the handler returns an error from ShowError we need
    // to call the completion routine ourselves and/or we never got to the point
    // of making the outcall and there wasn't already an outcall in progress.
   if ( (fHandlerCalled && (NOERROR != hr)) ||
                (!fHandlerCalled && !fAlreadyInShowErrors) )
   {
        CallCompletionRoutine(pHandlerId,ThreadMsg_ShowError,hr,0,NULL);
   }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ShowErrorCompleted, public
//
//  Synopsis:   Called by completion routine on a ShowErrorCompleted
//
//              Warning: Assume queue is locked and pHandlerInfo has
//                  already been verified.
//
//  Returns:
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ShowErrorCompleted(LPHANDLERINFO pHandlerInfo,HRESULT hCallResult,
                                     ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    if (S_SYNCMGR_RETRYSYNC == hCallResult)
    {

        // validate we got something back for cbNumItems and pItemIDs or
        // don't do anything
        if ( (0 == cbNumItems) || (NULL == pItemIDs))
        {
            Assert(0 != cbNumItems); // assert in debug so can catch handlers.
            Assert(NULL != pItemIDs);
        }
        else
        {
        SYNCMGRITEMID *pCurItemItemId;
        ULONG cbNumItemsIndex;


            // if the handler is in the release state then change to prepareForSync
            // if it is still in a synchronize just set the fRetrySync flag in the
            // handler for it to check when done.

            // Cases
            //   Handlers PrepareForSync Method hasn't been called. Just add items to request
            //   Handlers is between  InPrepareForSync and InSynchronize. Set RetrySyncFlag
            //   Handler has is done with it synchronize. reset state to PrepareForSync

            // when prepareforsync is called on an item it state gets set back to unchecked
            // so just need to worry about setting appropriate items to checked.

           pCurItemItemId = pItemIDs;
           for (cbNumItemsIndex = 0 ; cbNumItemsIndex < cbNumItems; cbNumItemsIndex++)
           {
           BOOL fFoundMatch = FALSE;
           LPITEMLIST pHandlerItem;


                pHandlerItem = pHandlerInfo->pFirstItem;
                while (pHandlerItem)
                {
                    if (*pCurItemItemId == pHandlerItem->offlineItem.ItemID)
                    {
                        pHandlerItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

                        SetItemProgressValues(pHandlerItem,0,
                              HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);

                        pHandlerItem->fIncludeInProgressBar = TRUE;
                        fFoundMatch = TRUE;
                        break;
                    }

                    pHandlerItem = pHandlerItem->pnextItem;
                }

                if (!fFoundMatch)
                {
                LPITEMLIST pNewItem;
                SYNCMGRITEM syncItem;


                    // if didn't find a match this must be a new item, add it to the list
                    // and set up the appropriate states.
                    // Note: items added like this should not be included in the progress bar.
                    // first time progress is called on an item it will get included
                    // in the progress bar.

                    syncItem.cbSize = sizeof(SYNCMGRITEM);
                    syncItem.dwFlags = SYNCMGRITEM_TEMPORARY;
                    syncItem.ItemID = *pCurItemItemId;
                    syncItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;
                    syncItem.hIcon = NULL;
                    *syncItem.wszItemName = L'\0';

                    pNewItem =  AllocNewHandlerItem(pHandlerInfo,&syncItem);

                    if (pNewItem)
                    {
                        pNewItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

                        SetItemProgressValues(pNewItem,
                               HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE,
                              HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);

                        pNewItem->fHiddenItem = TRUE; // set to indicate not part of UI.
                        pNewItem->fIncludeInProgressBar = FALSE;
                    }


                }

                ++pCurItemItemId;
            }

            if (pHandlerInfo->HandlerState < HANDLERSTATE_INPREPAREFORSYNC)
             {
                // don't reset anything. just make sure requested items are added
                // to the request.
             }
             else if (pHandlerInfo->HandlerState > HANDLERSTATE_INSYNCHRONIZE)
             {
                // if synchronize is complete reset the state to PrepareForSync.
                pHandlerInfo->HandlerState = HANDLERSTATE_PREPAREFORSYNC;
             }
             else
             {
                 // retry request came in between the PrepareForSync call and Synchronize
                 // being complete.
                 Assert(pHandlerInfo->HandlerState >= HANDLERSTATE_INPREPAREFORSYNC);
                 Assert(pHandlerInfo->HandlerState < HANDLERSTATE_DEAD);
                 pHandlerInfo->fRetrySync = TRUE;
             }

             //
             // If the handler has been canceled, uncancel it to enable the retry
             //
             pHandlerInfo->fCancelled = FALSE;
        }
    }

    --m_dwShowErrororOutCallCount; // decrement handlers ShowError OutCall Count.

    // should never happen but in case out call goes negative fixup to zero.
    Assert( ((LONG) m_dwShowErrororOutCallCount) >= 0);
    if ( ((LONG) m_dwShowErrororOutCallCount) < 0)
    {
        m_dwShowErrororOutCallCount = 0;
    }

    pHandlerInfo->fInShowErrorCall = FALSE; // handler is no longer in a ShowError Call

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::FindItemData, private
//
//  Synopsis:   finds associated handler and item info. caller must be
//              holding the lock and access the returned info before
//              releasing the lock 
//
//              !! Only matches items that have a state between or equal
//              to the handler state ranges.
//
//              !!! If ItemID of GUID_NULL is passed it it returns a match
//                  of the first handler found and sets pItem out param to NULL
//
//  Arguments: 
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::FindItemData(CLSID clsidHandler,REFSYNCMGRITEMID OfflineItemID,
                                         HANDLERSTATE hndlrStateFirst,HANDLERSTATE hndlrStateLast,
                                         LPHANDLERINFO *ppHandlerInfo,LPITEMLIST *ppItem)
{
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
BOOL fNoMatchFound = TRUE;
HRESULT hr = S_FALSE;

    ASSERT_LOCKHELD(this);

    Assert(ppHandlerInfo);
    Assert(ppItem);

    *ppHandlerInfo = NULL;
    *ppItem = NULL;

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && fNoMatchFound)
    {
        if ( (clsidHandler == pCurHandlerInfo->clsidHandler)
            && (hndlrStateLast >= pCurHandlerInfo->HandlerState)
            && (hndlrStateFirst <= pCurHandlerInfo->HandlerState) )
        {

            *ppHandlerInfo = pCurHandlerInfo;

            // if top level item tem ppItem to NULL and return okay
            if (GUID_NULL == OfflineItemID)
            {
                *ppItem = NULL;
                hr = S_OK;
                fNoMatchFound = FALSE;
            }
            else
            {
                pCurItem = pCurHandlerInfo->pFirstItem;

                while (pCurItem)
                {
                    if (OfflineItemID == pCurItem->offlineItem.ItemID)
                    {
                        *ppItem = pCurItem;
                        hr = S_OK;
                        fNoMatchFound = FALSE;
                        break;
                    }
                    pCurItem = pCurItem->pnextItem;
                }
            }
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::LookupHandlerFromId, private
//
//  Synopsis:   Finds associate handler info from the given Id
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [pHandlerInfo] - on NOERROR pointer to handler info
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::LookupHandlerFromId(HANDLERINFO *pHandlerId,LPHANDLERINFO *pHandlerInfo)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pCurItem;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    *pHandlerInfo = NULL;
    pCurItem = m_pFirstHandler;

    while (pCurItem)
    {
        if (pHandlerId == pCurItem->pHandlerId )
        {
            *pHandlerInfo = pCurItem;
            Assert(pCurItem == pHandlerId);
            hr = NOERROR;
            break;
        }

        pCurItem = pCurItem->pNextHandler;
    }

    Assert(NOERROR == hr); // test assert to see if everv fires.

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AllocNewHandlerItem, public
//
//  Synopsis:   Adds new item to the specified handler.
//
//  Arguments:  [wHandlerId] - Id of handler.
//              [pOfflineItem] - Points to Items information to add.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    13-May-98      rogerg        Created.
//
//----------------------------------------------------------------------------

LPITEMLIST CHndlrQueue::AllocNewHandlerItem(LPHANDLERINFO pHandlerInfo,SYNCMGRITEM *pOfflineItem)
{
LPITEMLIST pNewItem = NULL;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    Assert(pHandlerInfo);
    Assert(pOfflineItem);

    // Allocate the item.
    pNewItem = (LPITEMLIST) ALLOC(sizeof(ITEMLIST));

    if (pNewItem)
    {
        // set up defaults.
        memset(pNewItem,0,sizeof(ITEMLIST));
        pNewItem->wItemId =     ++pHandlerInfo->wItemCount;
        pNewItem->pHandlerInfo = pHandlerInfo;
        pNewItem->fDuplicateItem = FALSE;
        pNewItem->fIncludeInProgressBar = FALSE;
        SetItemProgressValues(pNewItem,0,
                              HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);
        pNewItem->dwStatusType = SYNCMGRSTATUS_PENDING;
        pNewItem->fHiddenItem = FALSE;
        pNewItem->fSynchronizingItem = FALSE;

        pNewItem->offlineItem = *pOfflineItem;

        // stick the item on the end of the list
        if (NULL == pHandlerInfo->pFirstItem)
        {
            pHandlerInfo->pFirstItem = pNewItem;
            Assert(1 == pHandlerInfo->wItemCount);
        }
        else
        {
        LPITEMLIST pCurItem;

            pCurItem = pHandlerInfo->pFirstItem;

            while (pCurItem->pnextItem)
                pCurItem = pCurItem->pnextItem;

            pCurItem->pnextItem = pNewItem;

            Assert ((pCurItem->wItemId + 1) == pNewItem->wItemId);
        }
    }

    return pNewItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetHandlerInfo, public
//
//  Synopsis:   Adds item to the specified handler.
//              Called in context of the handlers thread.
//
//  Arguments:  [pHandlerId] - Id of handler.
//              [pSyncMgrHandlerInfo] - Points to SyncMgrHandlerInfo to be filled in.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    28-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetHandlerInfo(HANDLERINFO *pHandlerId,LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
CLock clockqueue(this);

    if (!pSyncMgrHandlerInfo)
    {
        return E_INVALIDARG;
        Assert(pSyncMgrHandlerInfo);
    }

    clockqueue.Enter();

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        if (HANDLERSTATE_INADDHANDLERITEMS != pHandlerInfo->HandlerState)
        {
            Assert(HANDLERSTATE_INADDHANDLERITEMS == pHandlerInfo->HandlerState);
            hr =  E_UNEXPECTED;
        }
        else
        {

            // Quick Check of Size here. other paramters should already
            // be validated by hndlrmsg
            if (pSyncMgrHandlerInfo->cbSize != sizeof(SYNCMGRHANDLERINFO) )
            {
                Assert(pSyncMgrHandlerInfo->cbSize == sizeof(SYNCMGRHANDLERINFO));
                hr = E_INVALIDARG;
            }
            else
            {
                pHandlerInfo->SyncMgrHandlerInfo = *pSyncMgrHandlerInfo;
	        hr = NOERROR;
            }
        }
    }

    clockqueue.Leave();

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::IsAllHandlerInstancesCancelCompleted, private
//
//  Synopsis:   Asks queue if all interintances of a Handler CLSID
//              are completed, Called in proxy terminate to see
//              if after requesting user input there are still items to 
//              kill.
//
//              Note: Only checks instances for this queue.
//
//  Arguments:  
//
//  Returns:    S_OK; if all handler instances are done.
//              S_FALSE - if still items going that should be killed.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::IsAllHandlerInstancesCancelCompleted(REFCLSID clsidHandler)
{
HRESULT hr = S_OK;
LPHANDLERINFO pCurHandlerInfo;
CLock clockqueue(this);

    // just loop through handlers matching clsid and if any are <= SynchronizeCompleted
    // and the cancelled flag set then an instance of the Handler is still
    // stuck in a Cancel.

    Assert(m_QueueType == QUEUETYPE_PROGRESS);

    clockqueue.Enter();

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo)
    {
        if ( (clsidHandler == pCurHandlerInfo->clsidHandler)
		&& (BAD_HANDLERSTATE(pCurHandlerInfo) )
                && (pCurHandlerInfo->fCancelled) )
        {
            hr = S_FALSE;
            break;
        }

        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    clockqueue.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::AddItemToHandler, public
//
//  Synopsis:   Adds item to the specified handler.
//              Called in context of the handlers thread.
//
//  Arguments:  [wHandlerId] - Id of handler.
//              [pOfflineItem] - Points to Items information to add.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::AddItemToHandler(HANDLERINFO *pHandlerId,SYNCMGRITEM *pOfflineItem)
{
HRESULT hr = E_UNEXPECTED; // review for Lookup failures
LPHANDLERINFO pHandlerInfo = NULL;
LPITEMLIST pNewItem = NULL;
LPHANDLERINFO pHandlerMatched;
LPITEMLIST pItemListMatch;
CLock clockqueue(this);

    clockqueue.Enter();

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        if (HANDLERSTATE_INADDHANDLERITEMS != pHandlerInfo->HandlerState)
        {
            Assert(HANDLERSTATE_INADDHANDLERITEMS == pHandlerInfo->HandlerState);
            hr =  E_UNEXPECTED;
        }
        else
        {

            // make sure the handler has a jobID and ConnectionObj
            // associated with it.

            Assert(pHandlerInfo->pJobInfo);
            Assert(pHandlerInfo->pJobInfo->pConnectionObj);

            if (pHandlerInfo->pJobInfo
                 && pHandlerInfo->pJobInfo->pConnectionObj)
            {
            DWORD dwSyncFlags = pHandlerInfo->pJobInfo->dwSyncFlags;

                // Allocate the item.
                pNewItem = AllocNewHandlerItem(pHandlerInfo,pOfflineItem);

                if (NULL == pNewItem)
                {
                    hr =  E_OUTOFMEMORY;
                }
                else
                {
                DWORD dwCheckState;
                DWORD dwDefaultCheck; // what default for the item should be.
                DWORD ConnectionIndex;
                DWORD dwSyncEvent = dwSyncFlags & SYNCMGRFLAG_EVENTMASK;


                    // if SyncType is SYNCMGRFLAG_CONNECT, SYNCMGRFLAG_PENDINGDISCONNECT
                    //  or Idle, set the defaults based on registration flags

                    // If change this logic need to also change logic in dll hndlrq.
                    
                    dwDefaultCheck = pOfflineItem->dwItemState;
                    if ( 
                           ( (dwSyncEvent == SYNCMGRFLAG_IDLE) && !(pHandlerInfo->dwRegistrationFlags & SYNCMGRREGISTERFLAG_IDLE) )
                        || ( (dwSyncEvent == SYNCMGRFLAG_CONNECT) && !(pHandlerInfo->dwRegistrationFlags & SYNCMGRREGISTERFLAG_CONNECT) )
                        || ( (dwSyncEvent == SYNCMGRFLAG_PENDINGDISCONNECT) && !(pHandlerInfo->dwRegistrationFlags & SYNCMGRREGISTERFLAG_PENDINGDISCONNECT) )
                       )
                    {
                        dwDefaultCheck = SYNCMGRITEMSTATE_UNCHECKED;
                    }

                    // get appropriate stored setting based on the sync flags
                    // invoke we just use whatever the handler tells us it should be.
                    if (SYNCMGRFLAG_INVOKE != dwSyncEvent)
                    {
                        for (ConnectionIndex = 0; ConnectionIndex <
                                        pHandlerInfo->pJobInfo->cbNumConnectionObjs;
                                                                        ++ConnectionIndex)
                        {
                        TCHAR *pszConnectionName =
                                  pHandlerInfo->pJobInfo->pConnectionObj[ConnectionIndex]->pwszConnectionName;

                            switch(dwSyncEvent)
                            {
                            case SYNCMGRFLAG_MANUAL:

                                // only support one connection for manual
                                 Assert(pHandlerInfo->pJobInfo->cbNumConnectionObjs == 1);

                                if (RegGetSyncItemSettings(SYNCTYPE_MANUAL,
                                                pHandlerInfo->clsidHandler,
                                                pOfflineItem->ItemID,
                                                pszConnectionName,&dwCheckState,
                                                dwDefaultCheck,
                                                NULL))
                                {
                                    pNewItem->offlineItem.dwItemState = dwCheckState;
                                }
                                break;
                            case SYNCMGRFLAG_CONNECT:
                            case SYNCMGRFLAG_PENDINGDISCONNECT:
                                if (RegGetSyncItemSettings(SYNCTYPE_AUTOSYNC,
                                                pHandlerInfo->clsidHandler,
                                                pOfflineItem->ItemID,
                                                pszConnectionName,&dwCheckState,
                                                dwDefaultCheck,
                                                NULL))
                                {
                                    // for logon/logoff a checkstate of set wins and
                                    // as soon as it is set break out of the loop

                                    if (0 == ConnectionIndex ||
                                            (SYNCMGRITEMSTATE_CHECKED == dwCheckState))
                                    {
                                        pNewItem->offlineItem.dwItemState = dwCheckState;
                                    }

                                    if (SYNCMGRITEMSTATE_CHECKED ==pNewItem->offlineItem.dwItemState)
                                    {
                                        break;
                                    }
                                }
                                break;
                            case SYNCMGRFLAG_IDLE:
                                if (RegGetSyncItemSettings(SYNCTYPE_IDLE,
                                                pHandlerInfo->clsidHandler,
                                                pOfflineItem->ItemID,
                                                pszConnectionName,&dwCheckState,
                                                dwDefaultCheck,
                                                NULL))
                                {
                                    // for Idle a checkstate of set wins and
                                    // as soon as it is set break out of the loop

                                    if (0 == ConnectionIndex ||
                                            (SYNCMGRITEMSTATE_CHECKED == dwCheckState))
                                    {
                                        pNewItem->offlineItem.dwItemState = dwCheckState;
                                    }

                                    if (SYNCMGRITEMSTATE_CHECKED ==pNewItem->offlineItem.dwItemState)
                                    {
                                        break;
                                    }
                                }
                                break;
                            case SYNCMGRFLAG_SCHEDULED: // if caused by an invoke, use whatever handler tells us.

                                  // only support one connection for schedule
                                 Assert(pHandlerInfo->pJobInfo->cbNumConnectionObjs == 1);

                                if (pHandlerInfo->pJobInfo)
                                {
                                    if (RegGetSyncItemSettings(SYNCTYPE_SCHEDULED,
                                                        pHandlerInfo->clsidHandler,
                                                        pOfflineItem->ItemID,
                                                        pszConnectionName,
                                                        &dwCheckState,
                                                        SYNCMGRITEMSTATE_UNCHECKED, // if don't find item, don't check
                                                        pHandlerInfo->pJobInfo->szScheduleName))
                                   {
                                        pNewItem->offlineItem.dwItemState = dwCheckState;
                                   }
                                   else
                                   {
                                       // If don't find then default is to be unchecked.
                                       pNewItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
                                   }
                                }
                               break;
                            case SYNCMGRFLAG_INVOKE: // if caused by an invoke, use whatever handler tells us.
                                break;
                            default:
                                AssertSz(0,"UnknownSyncFlag Event");
                                break;
                            };
                        }
                    }


                    //  Search and mark duplicate entries.
                    if (IsItemAlreadyInList(pHandlerInfo->clsidHandler,
                        (pOfflineItem->ItemID),pHandlerInfo->pHandlerId,
                          &pHandlerMatched,&pItemListMatch) )
                    {


                        Assert(QUEUETYPE_CHOICE == m_QueueType || QUEUETYPE_PROGRESS == m_QueueType);

                        pNewItem->fDuplicateItem = TRUE;

                        // duplicate handling
                        // if a manual sync then first writer to the queue wins,
                        if (QUEUETYPE_CHOICE == m_QueueType)
                        {
                            pNewItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
                        }

                    }

                    hr = NOERROR;
                }
            }
        }
    }

    clockqueue.Leave();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::Progress, public
//
//  Synopsis:   Updates items progress information
//              Called in the context of the Handlers thread
//
//  Arguments:  [wHandlerId] - Id of handler.
//              [ItemID] - OfflineItemID of the specified item.
//              [lpSyncProgressItem] - Pointer to SyncProgressItem.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::Progress(HANDLERINFO *pHandlerId,REFSYNCMGRITEMID ItemID,
                                                LPSYNCMGRPROGRESSITEM lpSyncProgressItem)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
BOOL fFoundMatch = FALSE;
PROGRESSUPDATEDATA progressData;
HWND hwndCallback;
CLock clockqueue(this);

    progressData.pHandlerID = pHandlerId;
    progressData.ItemID = ItemID;

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        pCurItem = pHandlerInfo->pFirstItem;

        while (pCurItem)
        {
            if (ItemID == pCurItem->offlineItem.ItemID)
            {
                fFoundMatch = TRUE;
                break;
            }

            pCurItem = pCurItem->pnextItem;
        }

        if (pHandlerInfo->fCancelled)
            hr = S_SYNCMGR_CANCELALL;
        else if (!fFoundMatch || pCurItem->fItemCancelled)
        {
            Assert(fFoundMatch);
            hr = S_SYNCMGR_CANCELITEM;
        }
        else
            hr = NOERROR;

    }

    if (fFoundMatch) // store everyting in local vars.
    {

        // if found match but shouldn't include in progress bar
        // fix it up.

        if ( (pCurItem->fHiddenItem) || (FALSE == pCurItem->fIncludeInProgressBar))
        {

            // if found a match it should be included in the progress bar
           // Assert(TRUE == pCurItem->fIncludeInProgressBar); // Review if test app hits this.
            Assert(FALSE == pCurItem->fHiddenItem); // shouldn't get progress on hidden items.

            fFoundMatch = FALSE;

            if (NOERROR == hr) 
            {
                hr = S_SYNCMGR_CANCELITEM; // return cancel item just as if item wasn't cancelled.
            }
            
        }
        else
        {
            progressData.clsidHandler = pHandlerInfo->clsidHandler;
            progressData.wItemId = pCurItem->wItemId;
            hwndCallback = pHandlerInfo->hWndCallback;
        }
    }

    clockqueue.Leave();

    if (fFoundMatch)
    {
        // send off data to the callback window.
        // it is responsible for updating the items progress values.
        if (hwndCallback)
        {
            // validate the ProgressItem structure before passing it on.

            if (IsValidSyncProgressItem(lpSyncProgressItem))
            {
                SendMessage(hwndCallback,WM_PROGRESS_UPDATE,
                                (WPARAM) &progressData,(LPARAM) lpSyncProgressItem);
            }
            else
            {
                if (NOERROR == hr) // CANCEL RESULTS OVERRIDE ARG PROBLEMS
                {
                    hr = E_INVALIDARG;
                }
            }
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::LogError, public
//
//  Synopsis:   Logs and error for the specified item
//              Called in the context of the Handlers thread
//
//  Arguments:  [wHandlerId] - Id of handler.
//              [dwErrorLevel] - ErrorLevel of the Error
//              [lpcErrorText] - Text of the Error.
//              [lpSyncLogError] - Pointer to SyncLogError structure
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::LogError(HANDLERINFO *pHandlerId,DWORD dwErrorLevel,
                                            const WCHAR *lpcErrorText, LPSYNCMGRLOGERRORINFO lpSyncLogError)
{
HRESULT hr = E_UNEXPECTED;
LPHANDLERINFO pHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;
BOOL fFoundMatch = FALSE;
MSGLogErrors msgLogErrors;
HWND hWndCallback = NULL;
CLock clockqueue(this);

    msgLogErrors.dwErrorLevel = dwErrorLevel;
    msgLogErrors.lpcErrorText = lpcErrorText;
    msgLogErrors.ErrorID = GUID_NULL;
    msgLogErrors.fHasErrorJumps = FALSE;
    msgLogErrors.mask = 0;

    Assert(QUEUETYPE_PROGRESS == m_QueueType);

    clockqueue.Enter();

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        hWndCallback = pHandlerInfo->hWndCallback;

        // validate the paramaters.
        if (NULL == hWndCallback)
        {
            hr = E_UNEXPECTED;
        }
        else if (!IsValidSyncLogErrorInfo(dwErrorLevel,lpcErrorText,lpSyncLogError))
        {
            hr = E_INVALIDARG;
        }
        else
        {

            if (lpSyncLogError && (lpSyncLogError->mask & SYNCMGRLOGERROR_ERRORID))
            {
                pHandlerInfo->fHasErrorJumps = TRUE;
                msgLogErrors.mask |= SYNCMGRLOGERROR_ERRORID;
                msgLogErrors.ErrorID = lpSyncLogError->ErrorID;
            }


            if (lpSyncLogError && (lpSyncLogError->mask & SYNCMGRLOGERROR_ERRORFLAGS))
            {
                if (SYNCMGRERRORFLAG_ENABLEJUMPTEXT & lpSyncLogError->dwSyncMgrErrorFlags)
                {
                    pHandlerInfo->fHasErrorJumps = TRUE;
                    msgLogErrors.fHasErrorJumps = TRUE;
                }
            }

            if (lpSyncLogError && (lpSyncLogError->mask & SYNCMGRLOGERROR_ITEMID))
            {
                msgLogErrors.mask |= SYNCMGRLOGERROR_ITEMID;
                msgLogErrors.ItemID = lpSyncLogError->ItemID;
            }

            hr = NOERROR;

        }

    }

    clockqueue.Leave();

    if (NOERROR == hr)
    {
        Assert(sizeof(WPARAM) >= sizeof(HANDLERINFO *));

        SendMessage(hWndCallback,WM_PROGRESS_LOGERROR,(WPARAM) pHandlerId, (LPARAM) &msgLogErrors);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::DeleteLogError, public
//
//  Synopsis:   Deletes an Error from the Results pane that was previously logged.
//
//  Arguments:
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::DeleteLogError(HANDLERINFO *pHandlerId,REFSYNCMGRERRORID ErrorID,DWORD dwReserved)

{
MSGDeleteLogErrors msgDeleteLogError;
HWND hWndCallback = NULL;
HANDLERINFO *pHandlerInfo;
CLock clockqueue(this);

    clockqueue.Enter();
    msgDeleteLogError.pHandlerId = pHandlerId;
    msgDeleteLogError.ErrorID = ErrorID;

    if (NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {
        hWndCallback = pHandlerInfo->hWndCallback;
    }

    // review, if handler doesn't have any more error jumps after the deletelogError we can now
    // release it (pHandlerInfo->fHasErrorJumps)

    clockqueue.Leave();

    if (hWndCallback)
    {
        SendMessage(hWndCallback,WM_PROGRESS_DELETELOGERROR,(WPARAM) 0, (LPARAM) &msgDeleteLogError);
    }

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::CallCompletionRoutine, public
//
//  Synopsis:   Called by callback on handler thread
//              to indicate a call with a completion callback
//              has completed.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CHndlrQueue::CallCompletionRoutine(HANDLERINFO *pHandlerId,DWORD dwThreadMsg,HRESULT hCallResult,
                                           ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{
HWND hWndDlg = NULL;
HRESULT hrHandlerCall = NOERROR;
BOOL fCallbackAlreadyCalled = FALSE;
HANDLERINFO *pHandlerInfo;
CLock clockqueue(this);


    if (!pHandlerId)
    {
        Assert(pHandlerId);
        return;
    }
    // Note: cbNumItems and pItemIDs is only valid for ShowErrors

    // make sure the handlid is valid and then if there
    // is a pdlg call its completion routine via the postmessage
    // method.

    clockqueue.Enter();

    hWndDlg = m_hwndDlg;
    Assert(hWndDlg);


    if (pHandlerId && NOERROR == LookupHandlerFromId(pHandlerId,&pHandlerInfo))
    {

     // if flag isn't set for the message
    // then it was already handled i.e. handler called
    // us even though it returned an error.

        if (dwThreadMsg & pHandlerInfo->dwOutCallMessages)
        {
            pHandlerInfo->dwOutCallMessages &= ~dwThreadMsg;
        }
        else
        {
            AssertSz(0,"Callback called twice"); // test apps currently do this.
            fCallbackAlreadyCalled = TRUE;
        }

        // if already handled don't call these again.
        if (!fCallbackAlreadyCalled)
        {
            // fix up internal states before informing caller
            // the call is complete.
            switch(dwThreadMsg)
            {
            case ThreadMsg_ShowProperties: // don't need to do anything on show properties.
                break;
            case ThreadMsg_PrepareForSync:
                hrHandlerCall = PrepareForSyncCompleted(pHandlerInfo,hCallResult);
                break;
            case ThreadMsg_Synchronize:
                hrHandlerCall = SynchronizeCompleted(pHandlerInfo,hCallResult);
                break;
            case ThreadMsg_ShowError:
                hrHandlerCall = ShowErrorCompleted(pHandlerInfo,hCallResult,cbNumItems,pItemIDs);
                break;
            default:
                AssertSz(0,"Unknown Queue Completion Callback");
                break;
            }
        }

        // possible completion routine comes in before handler has actually
        // returned from the original call. Wait until proxy is no longer in an
        // out call.
        // If switch to COM for messaging need to find a better way of doing this.

        if (pHandlerInfo->pThreadProxy &&
                pHandlerInfo->pThreadProxy->IsProxyInOutCall()
                && hWndDlg)
        {
            // tell proxy to post the message whenver it gets done.

            if ( 0 /* NOERROR ==
                pHandlerInfo->pThreadProxy->SetProxyCompletion(hWndDlg,WM_BASEDLG_COMPLETIONROUTINE,dwThreadMsg,hCallResult)*/)
            {
                hWndDlg = NULL;
            }
        }


    }
    else
    {
        // on handler lookup assert but still post the message to the hwnd
        // so it won't get stuck waiting for the completion routine

        // this is only valid for setproperties in the
        // case the user clicked on a non-existant item but
        // this shouldn't really happen either
        AssertSz(dwThreadMsg == ThreadMsg_ShowProperties,"LookupHandler failed in CompletionRoutine");

    }

    LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam =  (LPCALLCOMPLETIONMSGLPARAM) ALLOC(sizeof(CALLCOMPLETIONMSGLPARAM));

    if (lpCallCompletelParam)
    {
        lpCallCompletelParam->hCallResult = hCallResult;
        lpCallCompletelParam->clsidHandler = pHandlerId->clsidHandler;

        // itemID is GUID_NULL unless its a ShowProperties completed.
        if ((ThreadMsg_ShowProperties == dwThreadMsg) && (1 == cbNumItems))
        {
            lpCallCompletelParam->itemID = *pItemIDs;
        }
        else
        {
            lpCallCompletelParam->itemID = GUID_NULL;
        }
    }


    clockqueue.Leave();

    if (hWndDlg && !fCallbackAlreadyCalled) // if already out of out call  or proxy failed post the messge ourselves.
    {
        // if alloc of completion lparam fails send message anyways so callback count
        // remains accurate.
        PostMessage(hWndDlg,WM_BASEDLG_COMPLETIONROUTINE,dwThreadMsg,(LPARAM) lpCallCompletelParam);
    }
    else
    {
        // if don't post message up to us to free the lpCallCopmlete.
        if (lpCallCompletelParam)
        {
            FREE(lpCallCompletelParam);
        }

    }

}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::IsItemAlreadyInList, private
//
//  Synopsis:   Given a clsid and ItemID determines if a matchin
//              item is already in the list
//              Called in the context of the Handlers thread
//
//  Arguments:  [clsidHandler] - clsid of the handler
//              [ItemID] - ItemID of the item
//              [wHandlerId] - HandlerID of the item.
//              [ppHandlerMatched] - on out the handler that matched
//              [ppItemIdMatch] - on out Item that matched.
//
//  Returns:    Appropriate Error code
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CHndlrQueue::IsItemAlreadyInList(CLSID clsidHandler,REFSYNCMGRITEMID ItemID,
                                      HANDLERINFO *pHandlerId,
                                      LPHANDLERINFO *ppHandlerMatched,
                                      LPITEMLIST *ppItemListMatch)
{
BOOL fFoundMatch = FALSE;
LPHANDLERINFO pCurHandlerInfo = NULL;
LPITEMLIST pCurItem = NULL;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    pCurHandlerInfo = m_pFirstHandler;

    while (pCurHandlerInfo && !fFoundMatch)
    {
        if (pHandlerId == pCurHandlerInfo->pHandlerId) // when find hander know didn't find any before.
            break;

        if (clsidHandler == pCurHandlerInfo->clsidHandler) // see if CLSID matches
        {
            // see if handler info has a matching item
            pCurItem = pCurHandlerInfo->pFirstItem;

            while (pCurItem)
            {
                if (ItemID == pCurItem->offlineItem.ItemID)
                {

                    *ppHandlerMatched = pCurHandlerInfo;
                    *ppItemListMatch = pCurItem;

                    fFoundMatch = TRUE;
                    break;
                }

                pCurItem = pCurItem->pnextItem;
            }
        }
        pCurHandlerInfo = pCurHandlerInfo->pNextHandler;
    }

    return fFoundMatch;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::GetSelectedItemsInHandler, private
//
//  Synopsis:   Gets the number of selected items for this handler
//
//              for our implementation if a cbCount is passed and it doesn't match
//              the number of actually selected then assert since we call this routine
//              internally.
//
//
//  Arguments:  [pHandlerInfo] - Pointer to the HandlerInfo to look at.
//              [cbcount] - [in] cbCount == number of pItems allocated,
//                          [out] cbCpimt == number of items actually written.
//                                  if the buffer is too small items written will be zero.
//              [pItems] - Pointer to array of SYNCMGRITEMs to be filled in.
//
//  Returns:    Returns the number of selectd items.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD CHndlrQueue::GetSelectedItemsInHandler(LPHANDLERINFO pHandlerInfo,ULONG *cbCount,
                                        SYNCMGRITEMID* pItems)

{
LPITEMLIST pCurItem;
DWORD dwSelectCount = 0;
DWORD dwArraySizeIndex;
DWORD dwArraySize;

    ASSERT_LOCKHELD(this); // caller of this function should have already locked the queue.

    if (cbCount)
    {
        dwArraySizeIndex = *cbCount;
        dwArraySize = *cbCount;
        *cbCount = 0; // initialize to zero.
    }
    else
    {
        dwArraySizeIndex = 0;
        dwArraySize = 0;
    }


    if (0 != dwArraySize && NULL == pItems)
    {
        Assert(0 == dwArraySize || NULL != pItems);
        return 0;
    }


    if (NULL == pHandlerInfo)
    {
        Assert(pHandlerInfo);
        return 0;
    }

    pCurItem = pHandlerInfo->pFirstItem;

    while (pCurItem)
    {
        // dwItemState
        if (SYNCMGRITEMSTATE_CHECKED == pCurItem->offlineItem.dwItemState)
        {
            ++dwSelectCount;

            if (dwArraySizeIndex)
            {
                *pItems = pCurItem->offlineItem.ItemID;
                *cbCount += 1;
                ++pItems;
                --dwArraySizeIndex;
            

                if (!pCurItem->fHiddenItem) // if not a hidden item
                {
                    Assert(TRUE == pCurItem->fIncludeInProgressBar);
                    Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgMaxValue); 

                    // reset iProgValue back to zero since may not be zero if retry came in while still synchronizing.
                    SetItemProgressValues(pCurItem,0,HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE);
                }
                else
                {
                    // if item is hidden,a assert it doesn't have UI
                    Assert(FALSE == pCurItem->fIncludeInProgressBar);
                    Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgValue);
                    Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgMaxValue); 

                }
                
                 pCurItem->fSynchronizingItem = TRUE;  // item is now synchronizing
        
                // once added to the array uncheck the item so on a retry we can just
                // always reset items to checked
                pCurItem->offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;

            }

        }
        else
        {
            Assert(FALSE == pCurItem->fSynchronizingItem);
          //  Assert(FALSE == pCurItem->fIncludeInProgressBar); Can be included in progress bar if retry comes in before RemoveFinished is called.
            Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgValue);
            Assert(HNDRLQUEUE_DEFAULT_PROGRESS_MAXVALUE == pCurItem->iProgMaxValue); 
        }


        pCurItem = pCurItem->pnextItem;
    }

    // internal call should always request a proper array size.
    Assert(dwSelectCount == dwArraySize || 0 == dwArraySize);

    return dwSelectCount;
}

#ifdef _OLD

//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SetPendingDisconnectEvent, private
//
//  Synopsis:   Sets the Pending Disconnect Event, If on already
//              exists, S_FALSE is returned.
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SetPendingDisconnectEvent(HANDLE hRasPendingEvent)
{
HRESULT hr = S_FALSE;
CLock clockqueue(this);

    Assert(hRasPendingEvent);

    clockqueue.Enter();

    /*
    if (NULL == m_hRasPendingEvent)
    {
        m_hRasPendingEvent = hRasPendingEvent;
        hr = NOERROR;
    }

  */
    clockqueue.Leave();
    return hr;
}


// signals and resets any disconnect event objects.
STDMETHODIMP CHndlrQueue::SetDisconnectEvent()
{
CLock clockqueue(this);
HANDLE hRasPendingEvent = NULL;

    clockqueue.Enter();
    /*
    if (NULL != m_hRasPendingEvent)
    {
        hRasPendingEvent = m_hRasPendingEvent;
        m_hRasPendingEvent = NULL;
    }

  */

    clockqueue.Leave();

    if (NULL != hRasPendingEvent)
    {
        SetEvent(hRasPendingEvent);
    }

    return NOERROR;
}

#endif // _OLD

// job info methods

STDMETHODIMP CHndlrQueue::CreateJobInfo(JOBINFO **ppJobInfo,DWORD cbNumConnectionNames)
{
HRESULT hr = S_FALSE;
JOBINFO *pNewJobInfo = NULL;

    ASSERT_LOCKHELD(this);

    // create a new job and add it to the the JobInfo list.
    // allocate space for JobInfo + number of connection objects that
    // will be associated with this job.

    Assert(cbNumConnectionNames);

    if (cbNumConnectionNames < 1)
        return S_FALSE;

    pNewJobInfo = (JOBINFO *) ALLOC(sizeof(JOBINFO) +
            sizeof(CONNECTIONOBJ)*(cbNumConnectionNames - 1));

    if (pNewJobInfo)
    {
        memset(pNewJobInfo,0,sizeof(JOBINFO));

        pNewJobInfo->cRefs = 1;
        pNewJobInfo->pNextJobInfo = m_pFirstJobInfo;
        m_pFirstJobInfo = pNewJobInfo;

        *ppJobInfo = pNewJobInfo;

        hr = NOERROR;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

DWORD CHndlrQueue::ReleaseJobInfoExt(JOBINFO *pJobInfo)
{
DWORD dwRet;
CLock clockqueue(this);

    clockqueue.Enter();
    dwRet = ReleaseJobInfo(pJobInfo);
    clockqueue.Leave();

    return dwRet;
}


DWORD CHndlrQueue::ReleaseJobInfo(JOBINFO *pJobInfo)
{
DWORD cRefs;

    ASSERT_LOCKHELD(this);

    --(pJobInfo->cRefs);
    cRefs = pJobInfo->cRefs;

    Assert( ((LONG) cRefs) >= 0);

    if (0 == cRefs)
    {
    JOBINFO *pCurJobInfo = NULL;
    DWORD dwConnObjIndex;

        // loop through release all connection objs on this job
        for (dwConnObjIndex = 0 ; dwConnObjIndex < pJobInfo->cbNumConnectionObjs;
            dwConnObjIndex++)
        {
            Assert(pJobInfo->pConnectionObj[dwConnObjIndex]);
            if (pJobInfo->pConnectionObj[dwConnObjIndex])
            {
                ConnectObj_ReleaseConnectionObj(pJobInfo->pConnectionObj[dwConnObjIndex]);
                pJobInfo->pConnectionObj[dwConnObjIndex] = NULL;
            }
        }

        // remove this JobInfo from the list.
        if (pJobInfo == m_pFirstJobInfo)
        {
            m_pFirstJobInfo = pJobInfo->pNextJobInfo;
        }
        else
        {
            pCurJobInfo = m_pFirstJobInfo;

            while (pCurJobInfo->pNextJobInfo)
            {

                if (pJobInfo == pCurJobInfo->pNextJobInfo)
                {
                   pCurJobInfo->pNextJobInfo =  pJobInfo->pNextJobInfo;
                   break;
                }

                pCurJobInfo = pCurJobInfo->pNextJobInfo;
            }


        }

        FREE(pJobInfo);
    }

    return cRefs;
}

DWORD CHndlrQueue::AddRefJobInfo(JOBINFO *pJobInfo)
{
DWORD cRefs;

    ASSERT_LOCKHELD(this);

    ++(pJobInfo->cRefs);
    cRefs = pJobInfo->cRefs;

    return cRefs;
}

// determines ifthe specified JobInfo's connection can be openned.
// review should really call into connection Object help api.
STDMETHODIMP CHndlrQueue::OpenConnection(JOBINFO *pJobInfo)
{
CONNECTIONOBJ *pConnectionObj;
HRESULT hr;

    Assert(pJobInfo);

    if (NULL == pJobInfo) // if no job info go ahead and say the connection is open.
        return NOERROR;

    // turn off workOffline during the sync CloseConnection will turn
    // it back on if the user had it off.
    ConnectObj_SetWorkOffline(FALSE);


    // if this is anything but a schedule go ahead and say NOERROR;
    if (!(SYNCMGRFLAG_SCHEDULED ==
            (pJobInfo->dwSyncFlags & SYNCMGRFLAG_EVENTMASK)) )
    {
        return NOERROR;
    }

    // for schedule sink we only support one connection Object.
    Assert(1 == pJobInfo->cbNumConnectionObjs);
    if (1 != pJobInfo->cbNumConnectionObjs)
    {
        return E_UNEXPECTED;
    }

    pConnectionObj = pJobInfo->pConnectionObj[0];
    if (NULL == pConnectionObj)
        return NOERROR;

    // if we aren't suppose to make a connection of there is already
    // a hRasConn as part of the connection object then just
    // return NOERROR;

    // if connection is already open and we are on a job that
    // has already tried to open it then return NOERROR;
    if (pJobInfo->pConnectionObj[0]->fConnectionOpen
            && pJobInfo->fTriedConnection)
        return NOERROR;

    // if we haven't already tried to make the connection
    // on this job then call OpenConnection to make sure the
    // connection is still really open.
    if (!pJobInfo->fTriedConnection)
    {
        pJobInfo->fTriedConnection = TRUE;

        hr = ConnectObj_OpenConnection(pConnectionObj,pJobInfo->fCanMakeConnection,m_pDlg);
    }
    else
    {
        hr = S_FALSE;
    }

    // if get down to the bottom and still no hRasConn then return S_FALSE
    return hr;

}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::ScrambleIdleHandlers, private
//
//  Synopsis:   Called on an Idle Choice queue just before transfer
//              so the lastHandler is placed at the back of the list.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::ScrambleIdleHandlers(REFCLSID clsidLastHandler)
{
LPHANDLERINFO pMatchHandler;
LPHANDLERINFO pLastHandler;
CLock clockqueue(this);

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    clockqueue.Enter();

    // find the first occurance of specified handler and then place that handler
    // at the end of the list and everything after at the beginning of the list

    // no an error to not find the Handler since may have been deleted or
    // no longer has items.

     pMatchHandler = m_pFirstHandler;

     while (pMatchHandler)
     {

         if (pMatchHandler->clsidHandler == clsidLastHandler)
         {


             // if there are no items after the match then just break;
             if (NULL == pMatchHandler->pNextHandler)
             {
                 break;
             }

             // loop until find the last handler.
             pLastHandler = pMatchHandler->pNextHandler;
             while (pLastHandler->pNextHandler)
             {
                pLastHandler = pLastHandler->pNextHandler;
             }

             // now set the handler after the matchHandler to be the
             // head and set the next pointer of the LastHandler in
             // the list to point to the MatchHandler.

            pLastHandler->pNextHandler = m_pFirstHandler;
            m_pFirstHandler = pMatchHandler->pNextHandler;
            pMatchHandler->pNextHandler = NULL;
            break;
         }

        pMatchHandler = pMatchHandler->pNextHandler;
     }


    clockqueue.Leave();

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::BeginSyncSession
//
//  Synopsis:   Called to signal the beginning of the core synchronization session
//              to setup up dial support.
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::BeginSyncSession()
{

    HRESULT hr = ::BeginSyncSession();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::EndSyncSession
//
//  Synopsis:   Called to signal the end of the core synchronization session
//              to teardown dial support.
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::EndSyncSession()
{
    HRESULT hr = ::EndSyncSession();
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::SortHandlersByConnection
//
//  Synopsis:   Moves hanlders that won't establish connection to the end,
//              ie after handlers that can establish connectoin.
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::SortHandlersByConnection()
{
    CLock clockqueue(this);
    clockqueue.Enter();

    Assert(m_QueueType == QUEUETYPE_CHOICE);

    LPHANDLERINFO pFirstCannotDialHandler = NULL;
    LPHANDLERINFO pLastCannotDialHandler = NULL;

    LPHANDLERINFO pPrevHandler = NULL;
    LPHANDLERINFO pCurHandler = m_pFirstHandler;

    while ( pCurHandler )
    {
        if ( pCurHandler->SyncMgrHandlerInfo.SyncMgrHandlerFlags & SYNCMGRHANDLER_MAYESTABLISHCONNECTION )
        {
            //
            // Move to next handler
            //
            pPrevHandler = pCurHandler;
            pCurHandler = pCurHandler->pNextHandler;
        }
        else
        {
            //
            // Move handler to cannot dial list
            //
            if ( pPrevHandler == NULL )
            {
                //
                // This is the first handler in list
                //
                m_pFirstHandler = pCurHandler->pNextHandler;
                pCurHandler->pNextHandler = NULL;

                if ( pLastCannotDialHandler == NULL )
                {
                    Assert( pFirstCannotDialHandler == NULL );
                    pFirstCannotDialHandler = pLastCannotDialHandler = pCurHandler;
                }
                else
                {
                    pLastCannotDialHandler->pNextHandler = pCurHandler;
                    pLastCannotDialHandler = pCurHandler;
                }

                pCurHandler = m_pFirstHandler;
            }
            else
            {
                pPrevHandler->pNextHandler = pCurHandler->pNextHandler;
                pCurHandler->pNextHandler = NULL;

                if ( pLastCannotDialHandler == NULL )
                {
                    Assert( pFirstCannotDialHandler == NULL );
                    pFirstCannotDialHandler = pLastCannotDialHandler = pCurHandler;
                }
                else
                {
                    pLastCannotDialHandler->pNextHandler = pCurHandler;
                    pLastCannotDialHandler = pCurHandler;
                }

                pCurHandler = pPrevHandler->pNextHandler;
            }
        }
    }

    //
    // Attach cannot dial list at end of m_pFirstHandler list
    //
    if ( pPrevHandler )
    {
        Assert( pPrevHandler->pNextHandler == NULL );
        pPrevHandler->pNextHandler = pFirstCannotDialHandler;
    }
    else
    {
        //
        // Case where the original list became empty
        //
        Assert( m_pFirstHandler == NULL );
        m_pFirstHandler = pFirstCannotDialHandler;
    }


    clockqueue.Leave();

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHndlrQueue::EstablishConnection
//
//  Synopsis:   Called by handler to establish a connection.
//
//  Arguments:  [pHandlerID]      -- Ptr to handler
//              [lpwszConnection] -- Connection to establish
//              [dwReserved]      -- Must be zero for now
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CHndlrQueue::EstablishConnection( LPHANDLERINFO pHandlerID,
                                               WCHAR const * lpwszConnection,
                                               DWORD dwReserved )
{
    HRESULT hr = NOERROR;

    CLock clockqueue(this);

    clockqueue.Enter();

    CONNECTIONOBJ *pConnObj = NULL;
    BOOL fAutoDial = FALSE;

    LPHANDLERINFO pHandlerInfo = NULL;
    hr = LookupHandlerFromId( pHandlerID, &pHandlerInfo );

    if ( NOERROR == hr )
    {
        JOBINFO *pJobInfo = pHandlerInfo->pJobInfo;
        DWORD dwSyncFlags = pJobInfo->dwSyncFlags & SYNCMGRFLAG_EVENTMASK;
        if ( ( dwSyncFlags == SYNCMGRFLAG_MANUAL
               || dwSyncFlags == SYNCMGRFLAG_INVOKE )
             && pHandlerInfo->SyncMgrHandlerInfo.SyncMgrHandlerFlags & SYNCMGRHANDLER_MAYESTABLISHCONNECTION )
        {
            if ( lpwszConnection == NULL )
            {
                //
                // Null connection means use the default autodial connection
                //
                fAutoDial = TRUE;
            }
            else
            {
                hr = ConnectObj_FindConnectionObj(lpwszConnection,TRUE,&pConnObj);
            }
        }
        else
        {
            //
            // Either the handler invoke type does not permit establishing connection,
            // or GetHandlerInfo flags did not specify the EstablishConnection flag.
            //
            hr = E_UNEXPECTED;
        }
    }

    clockqueue.Leave();

    if (NOERROR == hr)
    {
        if (fAutoDial)
        {
            hr = ConnectObj_AutoDial(INTERNET_AUTODIAL_FORCE_ONLINE,m_pDlg);
        }
        else
        {
            Assert( pConnObj );
            if ( !pConnObj->fConnectionOpen )
            {
                hr = ConnectObj_OpenConnection(pConnObj, TRUE, m_pDlg );
                ConnectObj_ReleaseConnectionObj(pConnObj);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\msg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Msg.cpp
//
//  Contents:   Handles messages between threads
//
//  Classes:    CThreadMsgProxy
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern HINSTANCE g_hInst;
extern void UnitApplication();

// globals for handling QueryEndSession
HANDLE g_hEndSessionEvent = NULL; // created when an end session has occured.
BOOL   g_fShuttingDown = FALSE; // set when application begins to shutdown.(WM_QUIT)

// global for keeping track of handler's threads. We create on Thread for each handler
// CLSID

STUBLIST *g_FirstStub = NULL; // pointer to first proxy in our list.
CRITICAL_SECTION g_StubListCriticalSection; // Critical Section to use for adding proxy

//+---------------------------------------------------------------------------
//
//  Function:   TerminateStub, public
//
//  Synopsis:   Called by proxy to terminate a Stub of the given Id.
//
//  Arguments:  [pStubID] - Identifies the stub.
//
//  Returns:    S_OK - Stub was terminated
//              S_FALSE or Error - Stub either was already terminated
//                  or couldn't be found.
//
//  Modifies:
//
//  History:    17-Nov-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT  TerminateStub(STUBLIST *pStubID)
{
HRESULT hr = E_UNEXPECTED;
STUBLIST *pStubList;
CCriticalSection cCritSect(&g_StubListCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pStubList = g_FirstStub;
    while (pStubList)
    {
	if (pStubID == pStubList)
	{
            hr = pStubList->fStubTerminated ? S_FALSE : S_OK;
	    pStubList->fStubTerminated = TRUE;
	    break;
	}

	pStubList = pStubList->pNextStub;
    }

    cCritSect.Leave();

    AssertSz(SUCCEEDED(hr),"Didn't find StubID on Terminate");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoesStubExist, public
//
//  Synopsis:   Called by proxy see if Stub Exists
//              or has been terminated
//
//  Arguments:  [pStubID] - Identifies the stub.
//
//  Returns:    S_OK - Stubs exists
//              S_FALSE - Stub hasn't been terminated.
//
//  Modifies:
//
//  History:    17-Nov-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT DoesStubExist(STUBLIST *pStubID)
{
HRESULT hr = S_FALSE;
STUBLIST *pStubList;
CCriticalSection cCritSect(&g_StubListCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pStubList = g_FirstStub;
    while (pStubList)
    {
	if (pStubID == pStubList)
	{
            // if stub has already been terminated return S_FALSE
            hr = pStubList->fStubTerminated ? S_FALSE : S_OK;
	    break;
	}

	pStubList = pStubList->pNextStub;
    }

    cCritSect.Leave();
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   CreateHandlerThread, public
//
//  Synopsis:   Called by client to create a new handler thread
//
//  Arguments:  [pThreadProxy] - on success returns a pointer to Proxy
//		[hwndDlg] = hwnd of Window to associate with this proxy
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CreateHandlerThread(CThreadMsgProxy **pThreadProxy,HWND hwndDlg,
			    REFCLSID refClsid)
{
HRESULT hr = E_FAIL;
HANDLE hThread = NULL;
DWORD dwThreadId;
HandlerThreadArgs ThreadArgs;
STUBLIST *pStubList;
BOOL fExistingStub = FALSE;
CCriticalSection cCritSect(&g_StubListCriticalSection,GetCurrentThreadId());


    *pThreadProxy = new CThreadMsgProxy();
    if (NULL == *pThreadProxy)
	return E_OUTOFMEMORY;

    // lock the critical section and don't release it until the proxy
    // has been setup.

    cCritSect.Enter();

   // Look to see if there is already a thread for this handler's
    // clsid and if there is, reuse it, else create a new one.


    pStubList = g_FirstStub;
    while (pStubList)
    {
	if ((pStubList->clsidStub == refClsid) && (FALSE == pStubList->fStubTerminated))
	{
	    fExistingStub = TRUE;
	    break;
	}

	pStubList = pStubList->pNextStub;
    }

    // if found existing proxy then addref the cRefs and init the proxy
    // with the variables, else create a new one.

    if (fExistingStub)
    {
	++(pStubList->cRefs); // bump up the cRefs
	hr = (*pThreadProxy)->InitProxy(pStubList->hwndStub,
				    pStubList->ThreadIdStub,
				    pStubList->hThreadStub,
				    hwndDlg,
				    pStubList->clsidStub,
                                    pStubList);
    }
    else
    {

	ThreadArgs.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

	if (ThreadArgs.hEvent)
	{
	    hThread = CreateThread(NULL,0,HandlerThread,&ThreadArgs,0,&dwThreadId);

	    if (hThread)
	    {

	       WaitForSingleObject(ThreadArgs.hEvent,INFINITE);
	       hr = ThreadArgs.hr;

	       if (NOERROR == hr)
	       {
		STUBLIST *pNewStub;

		    pNewStub = (STUBLIST*) ALLOC(sizeof(STUBLIST));
		
		    if (pNewStub)
		    {
			pNewStub->pNextStub = NULL;
			pNewStub->cRefs = 1;
			pNewStub->hwndStub = ThreadArgs.hwndStub;
			pNewStub->ThreadIdStub = dwThreadId;
			pNewStub->hThreadStub = hThread;
			pNewStub->clsidStub = refClsid;
                        pNewStub->fStubTerminated = FALSE;

			if (NULL == g_FirstStub)
			{
			    g_FirstStub = pNewStub;
			}
			else
			{
			    pStubList = g_FirstStub;
			    while (pStubList->pNextStub)
			    {
				pStubList = pStubList->pNextStub;
			    }

			    pStubList->pNextStub = pNewStub;
			}
	
			(*pThreadProxy)->InitProxy(ThreadArgs.hwndStub,dwThreadId,hThread,hwndDlg,
					refClsid,pNewStub);

		    }
		    else
		    {
			hr = E_OUTOFMEMORY;
		    }

		
	       }

	       // if failed to create thread, initproxy or add it to
	       // global list, then bail

	       if (NOERROR != hr)
	       {
		   CloseHandle(hThread);
	       }

	    }
	    else
	    {
		hr = GetLastError();
	    }

	    CloseHandle(ThreadArgs.hEvent);
	}

    }


    cCritSect.Leave();

    // if got this far either found our created a handler thread, now need
    // to initialize the the stub side to create a hndlrMsg for this
    // instance of the handler. will return a hdnlrmsg that must be passed
    // along with everycall.

    if (NOERROR == hr
	    && (*pThreadProxy))
    {
	hr = (*pThreadProxy)->CreateNewHndlrMsg();

	// Review - if fail to create hndlr message, then
	// free proxy and return an error.

    }

    if (NOERROR != hr)
    {
	if ((*pThreadProxy))
	{
	    (*pThreadProxy)->Release();
	    *pThreadProxy = NULL;
	}
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HandlerThread, public
//
//  Synopsis:   main proc for Handler thread
//
//  Arguments:  [lpArg] - Ptr to HandlerThreadArgs
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD WINAPI HandlerThread( LPVOID lpArg )
{
MSG msg;
HRESULT hr;
CThreadMsgStub *pThreadMsgStub = NULL;
CMsgServiceHwnd *pMsgDlg;
HRESULT hrOleInitialize;
BOOL fMsgDlgInitialized = FALSE;
HandlerThreadArgs *pThreadArgs = (HandlerThreadArgs *) lpArg;
DWORD dwThreadID = GetCurrentThreadId();

__try
{				
   pThreadArgs->hr = E_UNEXPECTED;

   // need to do a PeekMessage and then set an event to make sure
   // a message loop is created before the first PostMessage is sent.
   PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

   hrOleInitialize = CoInitialize(NULL);

   // create our message hwnd
   pMsgDlg = new CMsgServiceHwnd;

   if (pMsgDlg)
   {
       if (pMsgDlg->Initialize(dwThreadID,MSGHWNDTYPE_HANDLERTHREAD))
       {
	    pThreadArgs->hwndStub = pMsgDlg->GetHwnd();
	    fMsgDlgInitialized = TRUE;
       }
   }


   // set the approriate error
   if (fMsgDlgInitialized && SUCCEEDED(hrOleInitialize))
	hr = NOERROR;
   else
	hr = E_UNEXPECTED;

   pThreadArgs->hr = hr;

   // let the caller know the thread is done initializing.
   if (pThreadArgs->hEvent)
     SetEvent(pThreadArgs->hEvent);

   if (NOERROR == hr)
   {
       // sit in loop receiving messages.
       while (GetMessage(&msg, NULL, 0, 0)) {
	     TranslateMessage(&msg);
	     DispatchMessage(&msg);
       }
   }

   if (SUCCEEDED(hrOleInitialize))
   {
	CoFreeUnusedLibraries();
	CoUninitialize();
   }

}
__except(QueryHandleException())
{
    AssertSz(0,"Exception in Handler Thread.");
}
   return 0;

}

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::HandleThreadMessage, public
//
//  Synopsis:   Responsible for determining the thread message that
//		was received and calling the proper handler routine
//
//  Arguments:  [pmsgInfo] - Ptr to MessagingInfo structure
//		[pgenMsg] - Ptr to Generic Message structure.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CMsgServiceHwnd::HandleThreadMessage(MessagingInfo *pmsgInfo,GenericMsg *pgenMsg)
{
CHndlrMsg *pHndlrMsg;

    pgenMsg->hr = E_UNEXPECTED; // initialize the return result.

    // review, look up in linked list to validate.

    pHndlrMsg = pmsgInfo->pCHndlrMsg;

    m_fInOutCall = TRUE;

    switch (pgenMsg->ThreadMsg)
    {
    case ThreadMsg_Release:
	{
	MSGInitialize *pmsg = (MSGInitialize *) pgenMsg;
	ULONG cRefs;

	    cRefs = pHndlrMsg->Release();
	    Assert(0 == cRefs);

	    m_pHndlrMsg = NULL; // review, change when done.
	    pgenMsg->hr = NOERROR;

	    m_fInOutCall = FALSE;
	}
	break;
    case ThreadMsg_Initialize:
	{
	MSGInitialize *pmsg = (MSGInitialize *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->Initialize(pmsg->dwReserved,pmsg->dwSyncFlags,
			pmsg->cbCookie,pmsg->lpCookie);

	}
	break;
    case ThreadMsg_GetHandlerInfo:
	{
	MSGGetHandlerInfo *pmsg = (MSGGetHandlerInfo *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->GetHandlerInfo(pmsg->ppSyncMgrHandlerInfo);

	}
	break;
    case ThreadMsg_GetItemObject:
	{
	MSGGetItemObject *pmsg = (MSGGetItemObject *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->GetItemObject(pmsg->ItemID,pmsg->riid,
			pmsg->ppv);

	}
	break;
    case ThreadMsg_ShowProperties:
	{
	MSGShowProperties *pmsg = (MSGShowProperties *) pgenMsg;
        pgenMsg->hr = pHndlrMsg->ShowProperties(pmsg->hWndParent,pmsg->ItemID);
	
	}
	break;
    case ThreadMsg_PrepareForSync:
	{
	MSGPrepareForSync *pmsg = (MSGPrepareForSync *) pgenMsg;
	HANDLE hEvent = pmsgInfo->hMsgEvent;

	    pgenMsg->hr = pHndlrMsg->PrepareForSync(pmsg->cbNumItems,pmsg->pItemIDs,
				    pmsg->hWndParent,pmsg->dwReserved);

	}
	break;
    case ThreadMsg_Synchronize:
	{
	MSGSynchronize *pmsg = (MSGSynchronize *) pgenMsg;
	HANDLE hEvent = pmsgInfo->hMsgEvent;

	    pgenMsg->hr = pHndlrMsg->Synchronize(pmsg->hWndParent);

	}
	break;
    case ThreadMsg_SetItemStatus:
	{
	MSGSetItemStatus *pmsg = (MSGSetItemStatus *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->SetItemStatus(pmsg->ItemID,pmsg->dwSyncMgrStatus);

	}
	break;
    case ThreadMsg_ShowError:
	{
	MSGShowConflicts *pmsg = (MSGShowConflicts *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->ShowError(pmsg->hWndParent,pmsg->ErrorID);

	}
	break;
    case ThreadMsg_AddHandlerItems:
	{
	MSGAddItemHandler *pmsg = (MSGAddItemHandler *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->AddHandlerItems(pmsg->hwndList,pmsg->pcbNumItems);

	}
	break;
    case ThreadMsg_CreateServer:
	{
	MSGCreateServer *pmsg = (MSGCreateServer *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->CreateServer(pmsg->pCLSIDServer,pmsg->pHndlrQueue,pmsg->pHandlerId,pmsg->dwProxyThreadId);
	}
	break;
    case ThreadMsg_SetHndlrQueue:
	{
	MSGSetHndlrQueue *pmsg = (MSGSetHndlrQueue *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->SetHndlrQueue(pmsg->pHndlrQueue,pmsg->pHandlerId,pmsg->dwProxyThreadId);
	}
	break;
    case ThreadMsg_SetupCallback:
	{
	MSGSetupCallback *pmsg = (MSGSetupCallback *) pgenMsg;

	    pgenMsg->hr = pHndlrMsg->SetupCallback(pmsg->fSet);
	}
	break;
    default:
	AssertSz(0,"Unknown Thread Message");
	break;
    }

    m_fInOutCall = FALSE;
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   DopModalLoop, public
//
//  Synopsis:   Sit in message loop until the specified object
//		becomes or thread becomes signalled.
//
//  Arguments:  [hEvent] - Event to wait on
//		[hThread] - Thread that if it becomes signalled indicates thread
//			    that is being called has died.
//		[hwndDlg] - hwnd of Dialog on thread we should check message for, can be null.
//		[fAllowIncomingCalls] - incoming Messages can be dispatched during out call.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT DoModalLoopoLD(HANDLE hEvent,HANDLE hThread,HWND hwndDlg,BOOL fAllowIncomingCalls,
                    DWORD dwTimeout)
{
HRESULT hr = NOERROR;
DWORD dwWakeup;
DWORD dwHandleCount;
DWORD dwStartTime = GetTickCount();
DWORD dwTimeoutValue;
HANDLE handles[2];

    handles[0] = hEvent;
    handles[1] = hThread;

    dwHandleCount = (NULL == hThread) ? 1 : 2;

    dwTimeoutValue = dwTimeout; // initial call to wait is just the passed in vaulue

    // just sit in a loop until the message has been processed or the thread
    // we are calling dies

    // if no event to wait on just fall through
    if (NULL == hEvent)
    {
        do
        {

	    if (fAllowIncomingCalls)
	    {
	        dwWakeup = MsgWaitForMultipleObjects(dwHandleCount,&handles[0],FALSE,dwTimeoutValue,QS_ALLINPUT);
	    }
	    else
	    {
	        dwWakeup = WaitForMultipleObjects(dwHandleCount,&handles[0],FALSE,dwTimeoutValue);
	    }

	    if (WAIT_OBJECT_0 == dwWakeup)
	    {  // call was completed.

	        hr = NOERROR;
	        break;
	    }
	    else if ((WAIT_OBJECT_0 +1 == dwWakeup) &&  (2== dwHandleCount) )
	    {
	        // thread died within call.
	        AssertSz(0,"Server Thread Terminated");
	        hr = E_UNEXPECTED;
	        break;
	    }
	    else if (WAIT_ABANDONED_0  == dwWakeup)
	    {
	        AssertSz(0,"Abandoned"); // this shouldn't ever happen
	        hr = E_UNEXPECTED;
	        break;
	    }
	    else if (WAIT_TIMEOUT == dwWakeup)
	    {
	        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
	        break;
	    }
	    else
	    {
	    MSG msg;

                // see if events are signalled themselves since can get into this
                // loop is items are in the queue even if events we are
                // waiting on are already set.

                if (WAIT_OBJECT_0 == WaitForSingleObject(hEvent,0))
                {
                    hr = NOERROR;
                    break;
                }
                else if (hThread && (WAIT_OBJECT_0 == WaitForSingleObject(hThread,0)) )
                {
	            AssertSz(0,"Server Thread Terminated");
	            hr = E_UNEXPECTED;
	            break;
                }

                // only grab out one peek message since dispatch could
                // cause another message to get placed in the queue.
	        if (PeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_REMOVE))
	        {	
                 //   Assert(msg.message != WM_QUIT);

		    if ( (NULL == hwndDlg) || !IsDialogMessage(hwndDlg,&msg))
		    {
		        TranslateMessage((LPMSG) &msg);
		        DispatchMessage((LPMSG) &msg);
		    }
	        }

	    }

            // update the timeout value
                    // adjust the timeout value
            if (INFINITE == dwTimeout)
            {
                dwTimeoutValue = INFINITE;
            }
            else
            {
            DWORD dwCurTime = GetTickCount();

                  // handle roll-over of GetTickCount. If this happens use has to wait
                  // for the StartTime again. so user may have to wait twice as long
                  // as originally anticipated.
                  if (dwCurTime < dwStartTime)
                  {
                      dwStartTime = dwCurTime;
                  }

                  // if the elapsed time is greater than the timeout set the
                  // timeout value to zero, else use the different/
                  if (dwTimeout <=  (dwCurTime - dwStartTime))
                  {
                     dwTimeoutValue = 0;
                  }
                  else
                  {
                      dwTimeoutValue = dwTimeout -  (dwCurTime - dwStartTime);
                  }

            }


        } while (1);
    }


    return hr;

}


//+---------------------------------------------------------------------------
//
//  Function:   DopModalLoop, public
//
//  Synopsis:   Sit in message loop until the specified object
//		becomes or thread becomes signalled.
//
//  Arguments:  [hEvent] - Event to wait on
//		[hThread] - Thread that if it becomes signalled indicates thread
//			    that is being called has died.
//		[hwndDlg] - hwnd of Dialog on thread we should check message for, can be null.
//		[fAllowIncomingCalls] - incoming Messages can be dispatched during out call.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT DoModalLoop(HANDLE hEvent,HANDLE hThread,HWND hwndDlg,BOOL fAllowIncomingCalls,
                    DWORD dwTimeout)
{
HRESULT hr = NOERROR;
DWORD dwWakeup;
DWORD dwHandleCount;
DWORD dwStartTime = GetTickCount();
DWORD dwTimeoutValue;
HANDLE handles[2];

    handles[0] = hEvent;
    handles[1] = hThread;

    Assert(NULL != hEvent);

    dwHandleCount = (NULL == hThread) ? 1 : 2;

    dwTimeoutValue = dwTimeout; // initial call to wait is just the passed in vaulue

    // just sit in a loop until the message has been processed or the thread
    // we are calling dies
    do
    {
    DWORD dwWaitValue;
    MSG msg;

        // check if hEvents are signalled yet
        if (WAIT_OBJECT_0 == (dwWaitValue = WaitForSingleObject(hEvent,0)) )
        {
            hr = NOERROR;
            break;
        }
        else if ( (dwWaitValue != WAIT_ABANDONED)
                    && hThread && (WAIT_OBJECT_0 == (dwWaitValue = WaitForSingleObject(hThread,0))) )
        {
            // possible on Release message event was set between the 
            // time we checked for it and our thread event check.
            if (WAIT_OBJECT_0 == (dwWaitValue = WaitForSingleObject(hEvent,0)) )
            {
                hr = NOERROR;
            }
            else
            {
	        AssertSz(0,"Server Thread Terminated");
	        hr = E_UNEXPECTED;
            }

            break;
        }

        // if come out af any of these calls with abandoned then assert and break;
        if (WAIT_ABANDONED  == dwWaitValue)
	{
	    AssertSz(0,"Abandoned"); // this shouldn't ever happen
	    hr = E_UNEXPECTED;
	    break;
	}

        // if not then either grab next PeekMessage or wait for objects depending
        if (fAllowIncomingCalls)
	{

            // Leave any completion posts in the queue until the call has returned.
            if (PeekMessage(&msg, NULL, 0, 0, PM_NOYIELD | PM_REMOVE) )
            {
                dwWakeup = WAIT_OBJECT_0 + dwHandleCount; // set it to wait MsgWait would.

                Assert (msg.message != WM_QUIT);

                if ( (NULL == hwndDlg) || !IsDialogMessage(hwndDlg,&msg))
	        {
		    TranslateMessage((LPMSG) &msg);
                    DispatchMessage((LPMSG) &msg);
                }
            }
            else
            {
                dwWakeup = MsgWaitForMultipleObjects(dwHandleCount,&handles[0],FALSE,dwTimeoutValue,QS_ALLINPUT);
            }
        }
	else
	{
	    dwWakeup = WaitForMultipleObjects(dwHandleCount,&handles[0],FALSE,dwTimeoutValue);
	}

	if (WAIT_TIMEOUT == dwWakeup)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
	    break;
	}

        // update the timeout value
        if (INFINITE == dwTimeout)
        {
            dwTimeoutValue = INFINITE;
        }
        else
        {
        DWORD dwCurTime = GetTickCount();

              // handle roll-over of GetTickCount. If this happens use has to wait
              // for the StartTime again. so user may have to wait twice as long
              // as originally anticipated.
              if (dwCurTime < dwStartTime)
              {
                  dwStartTime = dwCurTime;
              }

              // if the elapsed time is greater than the timeout set the
              // timeout value to zero, else use the different/
              if (dwTimeout <=  (dwCurTime - dwStartTime))
              {
                 dwTimeoutValue = 0;
              }
              else
              {
                  dwTimeoutValue = dwTimeout -  (dwCurTime - dwStartTime);
              }

        }


    } while (1);


    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::CThreadMsgProxy, public
//
//  Synopsis:   Constructor

//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CThreadMsgProxy::CThreadMsgProxy()
{
    m_Clsid = GUID_NULL;
    m_cRef = 1;
    m_hwndDlg = NULL;
    m_pCHndlrMsg = NULL;
    m_fTerminatedHandler = FALSE;

    m_hThreadStub = NULL;
    m_ThreadIdStub = 0;
    m_hwndStub = NULL;
    m_hwndDlg = NULL;
    m_ThreadIdProxy = 0;

    m_fNewHndlrQueue = FALSE;
    m_pHandlerId = 0;
    m_pHndlrQueue = NULL;
    m_dwNestCount = 0;
    m_fHaveCompletionCall = FALSE;

}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::~CThreadMsgProxy, public
//
//  Synopsis:   destructor

//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    03-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CThreadMsgProxy::~CThreadMsgProxy()
{
    Assert(0 == m_dwNestCount);
    Assert(NULL == m_pStubId);
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::InitProxy, public
//
//  Synopsis:   Initializes member vars of Thread Proxy

//  Arguments:  [hwndStub] - hwnd of the Stub to send messages too.
//		[ThreadId] - ThreadId of the Stub
//		[hThread] - Handle of the Stub Thread.
//
//  Returns:    !!!!This function should be written so it never fails.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::InitProxy(HWND hwndStub, DWORD ThreadId,HANDLE hThread,
					HWND hwndDlg,REFCLSID refClsid,
                                        STUBLIST *pStubId)
{
    m_hwndStub = hwndStub;
    m_ThreadIdStub =  ThreadId;
    m_hThreadStub = hThread;
    m_pStubId = pStubId;

    m_hwndDlg = hwndDlg;
    m_Clsid = refClsid;
    m_ThreadIdProxy = GetCurrentThreadId();

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::DispatchMsg, public
//
//  Synopsis:   Dispatches the specified messge

//  Arguments:  [pgenMsg] - Ptr to Generic Message structure.
//		[fAllowIncomingCalls] - incoming Messages can be dispatched during out call.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::DispatchMsg(GenericMsg *pgenMsg,BOOL fAllowIncomingCalls,BOOL fAsync)
{
HRESULT hr = E_UNEXPECTED;
MessagingInfo msgInfo;

    // if the hndlrmsg information needs to be updated update
    // it before sending requested message

    AssertSz(!m_fTerminatedHandler,"Dispatching Message on Terminated Thread");

    if (m_fTerminatedHandler)
    {
        return E_UNEXPECTED;
    }

    ++m_dwNestCount;

    msgInfo.hMsgEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

    if (NULL == msgInfo.hMsgEvent)
    {
        --m_dwNestCount;
	return GetLastError();
    }

    msgInfo.dwSenderThreadID = m_ThreadIdProxy;
    msgInfo.pCHndlrMsg = m_pCHndlrMsg;

    // Post the message to the handler thread.
    Assert(m_hwndStub); 
    Assert(m_pCHndlrMsg);
    Assert(m_hThreadStub);
    Assert(m_pStubId);

    if (m_hwndStub && m_pCHndlrMsg && m_hThreadStub && m_pStubId)
    {
    BOOL fPostMessage;

        fPostMessage = PostMessage(m_hwndStub,WM_THREADMESSAGE,(WPARAM) &msgInfo, (LPARAM) pgenMsg);
        
        Assert(fPostMessage || m_pStubId->fStubTerminated);

        if (fPostMessage)
        {
            hr = DoModalLoop(msgInfo.hMsgEvent,m_hThreadStub,m_hwndDlg,fAllowIncomingCalls,INFINITE);
        }

    }

    CloseHandle(msgInfo.hMsgEvent);

    --m_dwNestCount;

    // if have a callback message then post. Note don't have this code for stub messages
    // since it doesn;t have any callbacks

    if (m_fHaveCompletionCall)
    {
        PostMessage(m_msgCompletion.hwnd,m_msgCompletion.message,m_msgCompletion.wParam,m_msgCompletion.lParam);
        m_fHaveCompletionCall = FALSE;
    }

    return NOERROR != hr ? hr : pgenMsg->hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::DispatchsStubMsg, public
//
//  Synopsis:   Dispatches the specified Stub messge

//  Arguments:  [pgenMsg] - Ptr to Generic Message structure.
//		[fAllowIncomingCalls] - incoming Messages can be dispatched during out call.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::DispatchsStubMsg(GenericMsg *pgenMsg,BOOL fAllowIncomingCalls)
{
HRESULT hr = E_UNEXPECTED;
MessagingInfo msgInfo;
BOOL fPostMessage;


    AssertSz(!m_fTerminatedHandler,"Dispatching  Stub Message on Terminated Thread");

    if (m_fTerminatedHandler)
        return E_UNEXPECTED;

    msgInfo.hMsgEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

    if (NULL == msgInfo.hMsgEvent)
	return GetLastError();

    m_dwNestCount++;

    msgInfo.dwSenderThreadID = m_ThreadIdProxy;

    // Post the message to the handler thread.
    Assert(m_hwndStub);
    Assert(m_hThreadStub);
    Assert(m_pStubId);

    if (m_hwndStub && m_hThreadStub && m_pStubId)
    {
        fPostMessage = PostMessage(m_hwndStub,WM_THREADSTUBMESSAGE,(WPARAM) &msgInfo, (LPARAM) pgenMsg);
        Assert(fPostMessage || (m_pStubId->fStubTerminated));

        if (fPostMessage)
        {
            hr = DoModalLoop(msgInfo.hMsgEvent,m_hThreadStub,m_hwndDlg,fAllowIncomingCalls,INFINITE);
    
        }

    }
        
    CloseHandle(msgInfo.hMsgEvent);

    m_dwNestCount--;

    Assert(FALSE == m_fHaveCompletionCall); // catch any stub calls that occur at same time as dispatch
    return NOERROR != hr ? hr : pgenMsg->hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   TerminateHandlerThread, public
//
//  Synopsis:   terminate the non-responsive handler thread
//
//  Returns:    Appropriate status code
//
//  Modifies:   m_hThreadStub;
//
//  History:    02-Nov-98       susia        Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP  CThreadMsgProxy::TerminateHandlerThread(TCHAR *pszHandlerName,BOOL fPromptUser)
{
int         iEndSession;
TCHAR       pszFormatString[MAX_PATH + 1],
            pszMessageText[MAX_PATH + 1],
            pszTitleString[MAX_STRING_RES + 1];

    AssertSz(!m_fTerminatedHandler,"Terminate Handler called twice on same Proxy"); 

    if (S_OK == DoesStubExist(m_pStubId))
    {
    BOOL fAllHandlerInstancesComplete;
    BOOL bResult;

        // let use know of cases don't want to prompt user but haven't killed stub yet.
        Assert(fPromptUser); 

        if (fPromptUser)
        {
            if (!pszHandlerName)
            {
                LoadString(g_hInst,IDS_NULL_HANDLERNOTRESPONDING,pszMessageText, MAX_PATH); 
            }
            else
            {
                LoadString(g_hInst,IDS_HANDLERNOTRESPONDING,pszFormatString, MAX_PATH); 
                wsprintf(pszMessageText,pszFormatString, pszHandlerName);
            }
    
            LoadString(g_hInst,IDS_SYNCMGR_ERROR,pszTitleString, MAX_STRING_RES);

            iEndSession = MessageBox(m_hwndDlg,pszMessageText,pszTitleString,
                                     MB_YESNO | MB_ICONERROR );

            if (IDYES != iEndSession)
            {
                return S_FALSE;  //Yes will terminate the thread
            }
        }

        // make sure handler is still not responding.
        fAllHandlerInstancesComplete = TRUE;
        if (m_pHndlrQueue)
        {
            fAllHandlerInstancesComplete = m_pHndlrQueue->IsAllHandlerInstancesCancelCompleted(m_Clsid);
        }
        
        // if no longer any instancesof this handler that aren't responding just ignore
        // the terminate.
        if (S_OK == fAllHandlerInstancesComplete)
        {
            return S_FALSE;
        }

        // mark the stubId as terminated
        TerminateStub(m_pStubId);

        // now terminate the thread.
        bResult = TerminateThread (m_hThreadStub, 0);
        AssertSz(bResult,"Error Terminating Thread");

    }

    m_pStubId = NULL;


    // if get here means we should are terminating this thread
    m_fTerminatedHandler = TRUE;
    m_hThreadStub = 0; // set threadId of stub to zero.


    // set the proxy stubhwnd to NULL
    m_hwndStub = NULL;

    // if have a hndlrmsg tell it we are terminated and clear
    // out our member variable.
    if (m_pCHndlrMsg)
    {
    CHndlrMsg *pCHndlrMsg = m_pCHndlrMsg;

        m_pCHndlrMsg = NULL;
        pCHndlrMsg->ForceKillHandler();
    }

    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::CreateNewHndlrMsg, public
//
//  Synopsis:   Make a request to the stub to create a new
//		Handler Message object
//
//  Arguments:
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::CreateNewHndlrMsg()
{
HRESULT hr = NOERROR;
MSGSTUBCreateStub msg;

    msg.MsgGen.ThreadMsg = StubMsg_CreateNewStub;

    hr = DispatchsStubMsg( (GenericMsg *) &msg,TRUE);

    m_pCHndlrMsg = msg.pCHndlrMsg;

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::ReleaseStub, public
//
//  Synopsis:   Informst the Stub thread that it is no longer needed.

//  Arguments:
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::ReleaseStub()
{
HRESULT hr = NOERROR;
GenericMsg msg;

    msg.ThreadMsg = StubMsg_Release;

    hr = DispatchsStubMsg( (GenericMsg *) &msg,TRUE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CThreadMsgProxy::QueryInterface, public
//
//  Synopsis:   Standard QueryInterface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Always returns E_NOTIMPL;
//
//  Modifies:   [ppvObj]
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    AssertSz(0,"QI called on MsgProxy");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CThreadMsgProxy::AddRef, public
//
//  Synopsis:	Add reference
//
//  History:	05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CThreadMsgProxy::AddRef()
{
ULONG cRefs;

    cRefs = InterlockedIncrement((LONG *)& m_cRef);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:	CThreadMsgProxy::Release, public
//
//  Synopsis:	Release reference
//		Must properly handle the case Release is
//		called before the initialize method in case
//		createing the handler thread fails.
//
//  History:	05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CThreadMsgProxy::Release()
{
HRESULT hr = NOERROR;
GenericMsg msg;
ULONG cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRef);

    if (cRefs)
        return cRefs;

    if (m_hThreadStub && !m_fTerminatedHandler)
    {
    CCriticalSection cCritSect(&g_StubListCriticalSection,GetCurrentThreadId());
    BOOL fLastRelease = FALSE;
    BOOL fExistingStub = FALSE;
    STUBLIST *pStubList;

	// release the handler Thread.
	msg.ThreadMsg = ThreadMsg_Release;
	hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);
	m_pCHndlrMsg = NULL;
        

	// If the cRefs in our proxy list is zero
	// then sit in loop until the ThreadStub Dies.
	cCritSect.Enter();

	pStubList = g_FirstStub;
	while (pStubList)
	{
	    if (pStubList->clsidStub == m_Clsid)
	    {
		fExistingStub = TRUE;
		break;
	    }

	    pStubList= pStubList->pNextStub;
	}

	Assert(fExistingStub); // their should always be an existing proxy

	if (fExistingStub)
	{
	    Assert(pStubList->cRefs > 0);

	    (pStubList->cRefs)--;

	    if (0 == pStubList->cRefs)
	    {
	    STUBLIST CurStub;
	    STUBLIST *pCurStub = &CurStub;

		CurStub.pNextStub = g_FirstStub;

		while (pCurStub->pNextStub)
		{
		    if (pCurStub->pNextStub == pStubList)
		    {
			pCurStub->pNextStub = pStubList->pNextStub;
			g_FirstStub = CurStub.pNextStub;
			FREE(pStubList);
			break;
		    }

		    pCurStub = pCurStub->pNextStub;
		}

		fLastRelease = TRUE;
	    }

	}


	cCritSect.Leave();

	if (fLastRelease)
	{
	    // send the quit command to the stub,
	    if (NOERROR == ReleaseStub())
	    {
		// Review, what if stubthread never dies.
                m_dwNestCount++;
		DoModalLoop(m_hThreadStub,NULL,NULL,TRUE,INFINITE); // sit in loop until the stub thread dies
		CloseHandle(m_hThreadStub);
                m_dwNestCount--;
	    }
	}

        m_pStubId = NULL; // clear StubId

    }

    delete this;
    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::Initialize, public
//
//  Synopsis:   Sends Initialize command to the Handler thread

//  Arguments:  [dwReserved] - reserved.
//		[dwSyncFlags] - syncflags
//		[cbCookie] - size of cookie data
//		[lpCookie] - ptr to any cookie data
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::Initialize(DWORD dwReserved,
			    DWORD dwSyncFlags,
			    DWORD cbCookie,
			    const BYTE  *lpCookie)
{
HRESULT hr = NOERROR;
MSGInitialize msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_Initialize;

    // package up the parameters
    msg.dwReserved = dwReserved;
    msg.dwSyncFlags = dwSyncFlags;
    msg.cbCookie = cbCookie;
    msg.lpCookie = lpCookie;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::GetHandlerInfo, public
//
//  Synopsis:   Sends GetHandler command to the Handler thread

//  Arguments:  [ppSyncMgrHandlerInfo] - pointer to SyncMgrHandlerInfo pointer
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)

{
HRESULT hr = NOERROR;
MSGGetHandlerInfo msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_Initialize;

    // package up the parameters
    msg.ppSyncMgrHandlerInfo = ppSyncMgrHandlerInfo;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::EnumOfflineItems, public
//
//  Synopsis:   Sends Enum command to the Handler thread
//		Should not be called. AddItems method
//		should be called instead
//
//  Arguments:  [ppenumOfflineItems] - reserved.
//
//  Returns:    E_NOTIMPL;
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOfflineItems)
{
#ifdef DONOTCALL
HRESULT hr = NOERROR;
MSGEnumOfflineItems msgEnum;

    msgEnum.MsgGen.ThreadMsg = ThreadMsg_EnumOfflineItems;

    msgEnum.ppenumOfflineItems = ppenumOfflineItems;

    hr = DispatchMsg( (GenericMsg *) &msgEnum);
#endif // DONOTCALL

    AssertSz(0,"EnumMethod Called on Proxy");
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::GetItemObject, public
//
//  Synopsis:   Sends GetItemObject command to the Handler thread

//  Arguments:  [ItemID] - identifies the item.
//		[riid] - requested interface
//		[ppv] - On success, pointer to object
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv)

{
HRESULT hr = NOERROR;
MSGGetItemObject msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_GetItemObject;

    // package up the parameters
    msg.ItemID  = ItemID;
    msg.riid = riid;
    msg.ppv = ppv;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::ShowProperties, public
//
//  Synopsis:   Sends ShowProperties command to the Handler thread

//  Arguments:  [hWndParent] - hwnd to use as parent of any dialogs
//		[ItemID] - Identifies the Item
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID)
{
HRESULT hr = NOERROR;
MSGShowProperties msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_ShowProperties;

    // package up the parameters
    msg.hWndParent = hWndParent;
    msg.ItemID = ItemID;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,TRUE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetProgressCallback, public
//
//  Synopsis:   Sends SetProgressCallback command to the Handler thread
//		This method should not be called, SetupCallback method
//		should be called instead
//
//  Arguments:  [lpCallBack] - Ptr to callback.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
#ifdef DONTCALL
HRESULT hr = NOERROR;
MSGSetProgressCallback msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_SetProgressCallback;

    // package up the parameters
    msg.lpCallBack = lpCallBack;

    hr = DispatchMsg( (GenericMsg *) &msg);

    return hr;
#endif // DONTCALL

    AssertSz(0,"SetProgressCallback called on Proxy");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::PrepareForSync, public
//
//  Synopsis:   Sends PrepareForSync command to the Handler thread
//
//  Arguments:  [cbNumItems] - Number of items in the pItemIDs array.
//		[pItemIDs] - array of item ids
//		[hWndParent] - hwnd to use as the parent for any dialogs
//		[dwReserved] - Reserved parameter.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
				    HWND hWndParent,DWORD dwReserved)
{
HRESULT hr = NOERROR;
MSGPrepareForSync msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_PrepareForSync;

    // package up the parameters
    msg.cbNumItems = cbNumItems;
    msg.pItemIDs   = pItemIDs;
    msg.hWndParent = hWndParent;
    msg.dwReserved = dwReserved;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,TRUE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::Synchronize, public
//
//  Synopsis:   Sends Synchronize command to the Handler thread
//
//  Arguments:	[hWndParent] - hwnd to use as the parent for any dialogs
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::Synchronize(HWND hWndParent)
{
HRESULT hr = NOERROR;
MSGSynchronize msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_Synchronize;

    // package up the parameters
    msg.hWndParent = hWndParent;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,TRUE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetItemStatus, public
//
//  Synopsis:   Sends SetItemStatus command to the Handler thread
//
//  Arguments:	[ItemID] - Identifies the item
//		[dwSyncMgrStatus] - Status to set the item too.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus)
{
HRESULT hr = NOERROR;
MSGSetItemStatus msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_SetItemStatus;

    // package up the parameters
    msg.ItemID = ItemID;
    msg.dwSyncMgrStatus = dwSyncMgrStatus;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::ShowError, public
//
//  Synopsis:   Sends ShowError command to the Handler thread
//
//  Arguments:	[hWndParent] - hwnd to use as the parent for any dialogs
//		[dwErrorID] - Identifies the Error.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID,ULONG *pcbNumItems,SYNCMGRITEMID **ppItemIDs)
{
HRESULT hr = NOERROR;
MSGShowConflicts msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_ShowError;

    // package up the parameters
    msg.hWndParent = hWndParent;
    msg.ErrorID = ErrorID;
    msg.pcbNumItems = pcbNumItems;
    msg.ppItemIDs = ppItemIDs;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,TRUE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::CreateServer, public
//
//  Synopsis:   Sends CreateServer command to the Handler thread
//
//  Arguments:	[pCLSIDServer] - clsid of handler to create
//		[pHndlrQueue] - Queue the handler belongs too.
//		[wHandlerId] - ID assigned to this instance of the Handler
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::CreateServer(const CLSID *pCLSIDServer,CHndlrQueue *pHndlrQueue,
						HANDLERINFO *pHandlerId)
{
HRESULT hr = NOERROR;
MSGCreateServer msg;

    m_pHndlrQueue = pHndlrQueue;
    m_pHandlerId = pHandlerId;

    msg.MsgGen.ThreadMsg = ThreadMsg_CreateServer;

    // package up the parameters
    msg.pCLSIDServer = pCLSIDServer;
    msg.pHndlrQueue  = pHndlrQueue;
    msg.pHandlerId   = pHandlerId;
    msg.dwProxyThreadId = m_ThreadIdProxy;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetHndlrQueue, public
//
//  Synopsis:   Assigns a new queue to the Handler
//
//  Arguments:	[pHndlrQueue] - Queue the handler now belongs too.
//		[wHandlerId] - ID assigned to this instance of the Handler
//		[dwThreadIdProxy] - ThreadID the queue is in.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CThreadMsgProxy::SetHndlrQueue(CHndlrQueue *pHndlrQueue,
					    HANDLERINFO *pHandlerId,
					    DWORD dwThreadIdProxy)
{
HRESULT hr = NOERROR;
MSGSetHndlrQueue msg;

    AssertSz(0,"this shouldn't be called");

    m_ThreadIdProxy = dwThreadIdProxy; // update the threadId the Proxy is on.

    msg.MsgGen.ThreadMsg = ThreadMsg_SetHndlrQueue;

    // package up the parameters
    msg.pHndlrQueue  = pHndlrQueue;
    msg.pHandlerId   = pHandlerId;
    msg.dwProxyThreadId = dwThreadIdProxy;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);


    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::AddHandlerItems, public
//
//  Synopsis:   Request Handler adds its items to the queue.
//
//  Arguments:	[hwndList] - Currently not used..
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CThreadMsgProxy::AddHandlerItems(HWND hwndList,DWORD *pcbNumItems)
{
HRESULT hr = NOERROR;
MSGAddItemHandler msg;

    msg.MsgGen.ThreadMsg = ThreadMsg_AddHandlerItems;

    // package up the parameters
    msg.hwndList = hwndList;
    msg.pcbNumItems = pcbNumItems;

    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetupCallback, public
//
//  Synopsis:   Request stub sets up the Callback.
//
//  Arguments:	[fSet] - TRUE == set the callback, FALSE == revoke it.
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CThreadMsgProxy::SetupCallback(BOOL fSet)
{
HRESULT hr = NOERROR;
MSGSetupCallback msg;

    AssertSz(0,"Shouldn't be called");

    msg.MsgGen.ThreadMsg = ThreadMsg_SetupCallback;

    // package up the parameters
    msg.fSet = fSet;
    hr = DispatchMsg( (GenericMsg *) &msg,TRUE,FALSE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetProxyParams, public
//
//  Synopsis:   informs server thread that the queue has been chagned
//              on it..
//
//  Arguments:	
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CThreadMsgProxy::SetProxyParams(HWND hwndDlg, DWORD ThreadIdProxy,
			    CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId )
{
    m_hwndDlg = hwndDlg;
    m_ThreadIdProxy = ThreadIdProxy;
    m_pHndlrQueue = pHndlrQueue;
    m_pHandlerId = pHandlerId;

    Assert(m_pCHndlrMsg);
    if (m_pCHndlrMsg)
    {
        m_pCHndlrMsg->SetHndlrQueue(pHndlrQueue,pHandlerId,m_ThreadIdProxy);

    }

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Member:   CThreadMsgProxy::SetProxyCompletion, public
//
//  Synopsis:   sets values for any completion notification to
//              post when returning from an out call
//
//  Arguments:	
//
//  Returns:    Appropriate error code
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP  CThreadMsgProxy::SetProxyCompletion(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam)
{

    Assert(FALSE == m_fHaveCompletionCall); // should only ever have one.

    if (m_fHaveCompletionCall) // if already have a completion fail.
           return S_FALSE;

    m_fHaveCompletionCall = TRUE;

    m_msgCompletion.hwnd = hWnd;
    m_msgCompletion.message = Msg;
    m_msgCompletion.wParam = wParam;
    m_msgCompletion.lParam = lParam;

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::CMsgServiceHwnd, public
//
//  Synopsis:	Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CMsgServiceHwnd::CMsgServiceHwnd()
{
    m_hwnd = NULL;
    m_dwThreadID = -1;
    m_pHndlrMsg = NULL;
    m_fInOutCall = FALSE;
    m_pMsgServiceQueue = NULL;
    m_MsgHwndType = MSGHWNDTYPE_UNDEFINED;
}

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::~CMsgServiceHwnd, public
//
//  Synopsis:	Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CMsgServiceHwnd::~CMsgServiceHwnd()
{

}

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::Initialize, public
//
//  Synopsis:	Initializes the service HWND
//
//  Arguments:  [dwThreadID] - id of thread hwnd belongs too.
//		[MsgHwndType] - type of MsgHwnd this is.
//
//  Returns: TRUE on success, FALSE on failure
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------


BOOL CMsgServiceHwnd::Initialize(DWORD dwThreadID,MSGHWNDTYPE MsgHwndType)
{
BOOL fInitialized = FALSE;
TCHAR szWinTitle[MAX_STRING_RES];

    m_MsgHwndType = MsgHwndType;

   LoadString(g_hInst, IDS_SYNCMGRNAME, szWinTitle, ARRAY_SIZE(szWinTitle));

    m_hwnd = CreateWindowEx(0,
			      TEXT(MSGSERVICE_HWNDCLASSNAME),
			      szWinTitle,
			      // must use WS_POPUP so the window does not get
			      // assigned a hot key by user.
			      WS_DISABLED |   WS_POPUP,
			      CW_USEDEFAULT,
			      CW_USEDEFAULT,
			      CW_USEDEFAULT,
			      CW_USEDEFAULT,
			      NULL, // REVIEW, can we give it a parent to not show up.
			      NULL,
			      g_hInst,
			      this);

    Assert(m_hwnd);

    if (m_hwnd)
    {
	m_dwThreadID = dwThreadID;

	if (MSGHWNDTYPE_HANDLERTHREAD == m_MsgHwndType)
	{
	//    m_pHndlrMsg = new CHndlrMsg;
	//    if (NULL != m_pHndlrMsg)
		fInitialized = TRUE;
	}
	else
	{
	    fInitialized = TRUE;
	}
    }

    if (!fInitialized)
    {
	Assert(NULL == m_pHndlrMsg);
    }

    // caller still needs to call Destroy if initialize returns false.
    return fInitialized;
 }

//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::Destroy, public
//
//  Synopsis:	Destroys the ServiceHwnd
//
//  Arguments:

//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CMsgServiceHwnd::Destroy()
{
BOOL fDestroy;

    // HANDLER m_pHndlrMsg will be destroyed by the Release HandleThreadMessage call
    // only case that it shouldn't is if for some reason CreateThreadHndlr failed
    Assert(NULL == m_pHndlrMsg);

    if (m_pHndlrMsg)
    {
	m_pHndlrMsg->Release();
	m_pHndlrMsg = NULL;
    }

    if (m_hwnd)
    {
	fDestroy =  DestroyWindow(m_hwnd);
        Assert(TRUE == fDestroy);
    }

    delete this;
}


//+---------------------------------------------------------------------------
//
//  Member:   CMsgServiceHwnd::MsgThreadWndProc, public
//
//  Synopsis:	Servicer Side message handling window.
//
//  Arguments:

//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CALLBACK  MsgThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
CMsgServiceHwnd *pThis = (CMsgServiceHwnd *) GetWindowLongPtr(hWnd, DWL_THREADWNDPROCCLASS);

    if (pThis || (msg == WM_CREATE) )
    {
        switch (msg)
        {
	    case WM_CREATE :
	        {
	        CREATESTRUCT *pCreateStruct = (CREATESTRUCT *) lParam;


	        SetWindowLongPtr(hWnd, DWL_THREADWNDPROCCLASS,(LONG_PTR) pCreateStruct->lpCreateParams );
	        pThis = (CMsgServiceHwnd *) pCreateStruct->lpCreateParams ;
	        }
	        break;
	    case WM_DESTROY:

                SetWindowLongPtr(hWnd, DWL_THREADWNDPROCCLASS,(LONG_PTR) NULL);
                PostQuitMessage(0); // no longer need this thread

	        break;
	    case WM_THREADSTUBMESSAGE: // message send only to stub.
	        {
	        MessagingInfo *pmsgInfo = (MessagingInfo *) wParam;
	        GenericMsg *pgenMsg = (GenericMsg *) lParam;

		    Assert(MSGHWNDTYPE_HANDLERTHREAD == pThis->m_MsgHwndType);
		
		    pgenMsg->hr = E_UNEXPECTED;

		    switch(pgenMsg->ThreadMsg)
		    {
		    case StubMsg_Release:
		        // proxy is telling us there is no need to stick around
		        // any longer so post a quit message.
		        Assert(NULL == pThis->m_pHndlrMsg);

		        pThis->Destroy();  // no longer need this

		        pgenMsg->hr = NOERROR;
		        break;
		    case StubMsg_CreateNewStub:
		        // proxy is telling us there is no need to stick around
		        // any longer so post a quit message.

		        pThis->m_pHndlrMsg = new CHndlrMsg;
		        ((MSGSTUBCreateStub *) pgenMsg)->pCHndlrMsg = pThis->m_pHndlrMsg;

		        pThis->m_pHndlrMsg = NULL;
		        pgenMsg->hr = NOERROR;
		        break;
		    default:
		        AssertSz(0,"Unknown StubMessage");
		        break;
		    };

		    if (pmsgInfo->hMsgEvent)
		    {
		       SetEvent(pmsgInfo->hMsgEvent);
		    }

		    break;
	        }
	    case WM_THREADMESSAGE:
                {
                MessagingInfo *pmsgInfo = (MessagingInfo *) wParam;
                GenericMsg *pgenMsg = (GenericMsg *) lParam;

                    Assert(MSGHWNDTYPE_HANDLERTHREAD == pThis->m_MsgHwndType);

                    pThis->HandleThreadMessage(pmsgInfo,pgenMsg);

                    // won't be an hEvent on an async call
	            if (pmsgInfo->hMsgEvent)
	            {
	               SetEvent(pmsgInfo->hMsgEvent);
	            }

                    // on an async call we free

              break;
              }

	     case WM_CFACTTHREAD_REVOKE:
	        {
	        HRESULT hr;

	            Assert(MSGHWNDTYPE_MAINTHREAD == pThis->m_MsgHwndType);

		    hr = CoRevokeClassObject((DWORD)wParam);
		    Assert(NOERROR == hr);

	          break;
	        }
	     case WM_MAINTHREAD_QUIT: // handles shutdown of main thread.
	        {
	        HANDLE hThread = (HANDLE) lParam;

	            Assert(MSGHWNDTYPE_MAINTHREAD == pThis->m_MsgHwndType);


                    // set ShuttingDown Flag for race conditions with QueryEnd.
                    // bfore yielding.
                    g_fShuttingDown = TRUE; 
		    // if there is an hThread that was passed wait until
		    // it goes away

                    Assert(0 == hThread); // we currently don't support this.
		    if (hThread)
		    {
		        WaitForSingleObject(hThread,INFINITE);
		        CloseHandle(hThread);

		    }
                    // if have a queryEndSession object state its okay to return now
                    // no need to cleanup window.
                   if (g_hEndSessionEvent)
                   {
                   HANDLE hEvent = g_hEndSessionEvent;

                      // g_hEndSessionEvent = NULL; // leave EndSession NON-Null since only need to handle one.
                       SetEvent(hEvent);
                   }
                   else
                   {
                        pThis->Destroy(); // Clean up this window.
                   }

	           break;
	        }
            case WM_QUERYENDSESSION:
                {
                HWND hwndQueryParent;
                UINT uiMessageID;
                BOOL fLetUserDecide;
                BOOL fReturn = TRUE;

                   // only handle this message if it is the main thread window
                   if (MSGHWNDTYPE_MAINTHREAD != pThis->m_MsgHwndType)
                   {
                       break;
                   }

                   if (!g_fShuttingDown 
                       && (S_FALSE == ObjMgr_HandleQueryEndSession(&hwndQueryParent,&uiMessageID,&fLetUserDecide)))
                   {
                    TCHAR pszTitle[MAX_PATH];
                    TCHAR pszMessageText[MAX_PATH];
                    UINT uType; // style of messagebox.
                    int iEndSession;

                        LoadString(g_hInst,IDS_SYNCMGRNAME,pszTitle,sizeof(pszTitle)/sizeof(TCHAR));
                        LoadString(g_hInst,uiMessageID,pszMessageText,sizeof(pszMessageText)/sizeof(TCHAR));

                        if (fLetUserDecide)
                        {
                            uType = MB_YESNO | MB_ICONEXCLAMATION | MB_SETFOREGROUND;
                        }
                        else
                        {
                            uType = MB_OK | MB_ICONSTOP | MB_SETFOREGROUND;
                        }

                         iEndSession = MessageBox(hwndQueryParent,pszMessageText,
                                pszTitle,uType);

                         if (!fLetUserDecide || IDYES != iEndSession)
                         {
                             fReturn = FALSE;  // FALSE causes system to stop the shutdown.
                         }
                    }


                  // if we are going to allow shutdown cleanup our threads
                  // before returning since on Win9x its too late afterwards.
		    if (TRUE == fReturn)
		    {
                    HANDLE hEndSessionEvent = NULL;

                        // its possible that another QUERYENDSESSION comes
                        // in while we are still shutting down. If already
                        // handling an end sessios or in WM_MAINTHREAD_QUIT just fall through

			if (NULL == g_hEndSessionEvent && !g_fShuttingDown)
                        {
                            g_hEndSessionEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
                            hEndSessionEvent = g_hEndSessionEvent;
                            
                            ObjMgr_CloseAll(); // start the process of closing down the dialogs.

                            Assert(hEndSessionEvent);
		
                            // wait until other threads have cleaned up so we know its safe to terminate.
                            if (hEndSessionEvent)
                            {
                                DoModalLoop(hEndSessionEvent ,NULL,NULL,TRUE,INFINITE);
                                CloseHandle(hEndSessionEvent);
                            }
                        }

 		    }

                 return fReturn;
		}
		break;
	    default:
	        break;
        }

    }

    return DefWindowProc(hWnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Function:   InitMessageService, public
//
//  Synopsis:	Initializes our internal thread messaging service.
//		Must be called before any Messagin is done.
//
//  Arguments:

//  Returns: NOERROR if Service was successfully initialized.
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI InitMessageService()
{
ATOM aWndClass;
WNDCLASS        xClass;
DWORD dwErr;

    // initialize the proxy critical section
    InitializeCriticalSection(&g_StubListCriticalSection);

    // Register windows class.we need for handling thread communication
    xClass.style         = 0;
    xClass.lpfnWndProc   = MsgThreadWndProc;
    xClass.cbClsExtra    = 0;

    xClass.cbWndExtra    = sizeof(PVOID); // room for class this ptr
    xClass.hInstance     = g_hInst;
    xClass.hIcon         = NULL;
    xClass.hCursor       = NULL;
    xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    xClass.lpszMenuName  = NULL;
    xClass.lpszClassName = TEXT(MSGSERVICE_HWNDCLASSNAME);

    aWndClass = RegisterClass( &xClass );

    dwErr = GetLastError();

    Assert(0 != aWndClass);

    return 0 == aWndClass ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\msg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Msg.h
//
//  Contents:   Handles inter-thread communications
//
//  Classes:    CThreadMsgProxy
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _THREADMSG_
#define _THREADMSG_

// stublist for global stublist structure.
typedef struct tagSTUBLIST {
    struct tagSTUBLIST *pNextStub;	// pointer to next proxy.
    ULONG cRefs;			// number of proxies using Stub
    CLSID clsidStub;			// clsid for stub.
    HANDLE hThreadStub;			// Handle of the Stubs Thread
    DWORD ThreadIdStub;			// ThreadID to send Message to.
    HWND hwndStub;			// HWND OF STUB.
    BOOL fStubTerminated;	        // set if this stub was force terminated.
} STUBLIST;


// WMs for Thread communication

#define WM_THREADMESSAGE		(WM_USER + 1)
#define WM_CFACTTHREAD_REVOKE		(WM_USER + 2)
#define WM_MAINTHREAD_QUIT		(WM_USER + 3)
#define WM_THREADSTUBMESSAGE		(WM_USER + 4)


#define WM_USER_MAX 0x7FFF // maximum user message that can be defined.


// alll msgs are unique bits so hndlrq and others
// can keep track of out calls.

typedef enum _tagThreadMsg
{
    ThreadMsg_Initialize	    = 0x0001,
    ThreadMsg_GetHandlerInfo	    = 0x0002,
    ThreadMsg_EnumOfflineItems	    = 0x0004,
    ThreadMsg_GetItemObject	    = 0x0008,
    ThreadMsg_ShowProperties	    = 0x0010,
    ThreadMsg_SetProgressCallback   = 0x0020,

    ThreadMsg_PrepareForSync	    = 0x0040,
    ThreadMsg_Synchronize	    = 0x0080,
    ThreadMsg_SetItemStatus	    = 0x0100,
    ThreadMsg_ShowError		    = 0x0200,

    ThreadMsg_Release		    = 0x0400,
    // Private Messages
    ThreadMsg_AddHandlerItems	    = 0x1000,
    ThreadMsg_CreateServer	    = 0X2000,
    ThreadMsg_SetHndlrQueue	    = 0x4000,
    ThreadMsg_SetupCallback	    = 0x8000,

} ThreadMsg;

// messages sent to toplevel stub object.
typedef enum _tagStubMsg
{
    StubMsg_CreateNewStub	    = 0x0001,
    StubMsg_Release		    = 0x0002,
} StubMsg;

class CThreadMsgProxy;
class CThreadMsgStub;
class CHndlrMsg;
class CHndlrQueue;


typedef struct _tagHandlerThreadArgs {
HANDLE hEvent; // used to know when the message loop has been created.
HRESULT hr; // inidicates if creation was successfull
HWND hwndStub; // hwnd of stub window. This is the window messages should be posted to.
} HandlerThreadArgs;

// helper functions called by client and Server
HRESULT CreateHandlerThread(CThreadMsgProxy **pThreadProxy,HWND hwndDlg
			,REFCLSID refClsid);
STDAPI InitMessageService();



// WPARAM is messaging specific data

typedef struct _tagMessagingInfo
{
HANDLE hMsgEvent; // Handle to Message Event for synchronization.
DWORD  dwSenderThreadID; // ThreadID of the Caller.
CHndlrMsg *pCHndlrMsg; //handler message instance for this proxy.
}  MessagingInfo;



// LPARAM is information specific to the message being sent.


typedef struct _tagGenericMsg
{
HRESULT hr; // return value from the message.
UINT ThreadMsg;   // message to send.
}   GenericMsg;


// request to stubObject to create a new stub for a proxy
typedef struct _tagMSGSTUBCreateStub
{
    GenericMsg MsgGen;
    CHndlrMsg *pCHndlrMsg; // on success returns a pointer to a new hndlrMsg struct.
} MSGSTUBCreateStub;



// Message specific structures
typedef struct _tagMSGCreateServer
{
GenericMsg MsgGen;
const CLSID *pCLSIDServer;
CHndlrQueue *pHndlrQueue;
HANDLERINFO *pHandlerId;
DWORD dwProxyThreadId;
} MSGCreateServer;

// Message specific structures
typedef struct _tagSetHndlrQueue
{
GenericMsg MsgGen;
CHndlrQueue *pHndlrQueue;
HANDLERINFO *pHandlerId;
DWORD dwProxyThreadId;
} MSGSetHndlrQueue;

typedef struct _tagMSGInitialize
{
GenericMsg MsgGen;
DWORD dwReserved;
DWORD dwSyncFlags;
DWORD cbCookie;
const BYTE  *lpCookie;
} MSGInitialize;

typedef struct _tagMSGGetHandlerInfo
{
GenericMsg MsgGen;
LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo;
} MSGGetHandlerInfo;

typedef struct _tagMSGEnumOfflineItems
{
GenericMsg MsgGen;
ISyncMgrEnumItems** ppenumOfflineItems;
} MSGEnumOfflineItems;


typedef struct _tagMSGGetItemObject
{
GenericMsg MsgGen;
SYNCMGRITEMID ItemID;
GUID riid;
void** ppv;
} MSGGetItemObject;



typedef struct _tagMSGShowProperties
{
GenericMsg MsgGen;
HWND hWndParent;
SYNCMGRITEMID ItemID;
} MSGShowProperties;


typedef struct _tagMSGSetProgressCallback
{
GenericMsg MsgGen;
ISyncMgrSynchronizeCallback *lpCallBack;
} MSGSetProgressCallback;



typedef struct _tagMSGPrepareForSync
{
GenericMsg MsgGen;

// SetHndlrQueue Items
CHndlrQueue *pHndlrQueue;
HANDLERINFO *pHandlerId;

// PrepareForSyncItems 
ULONG cbNumItems;
SYNCMGRITEMID *pItemIDs;
HWND hWndParent;
DWORD dwReserved;
} MSGPrepareForSync;


typedef struct _tagMSGSynchronize
{
GenericMsg MsgGen;
HWND hWndParent;
} MSGSynchronize;

typedef struct _tagMSGSetItemStatus
{
GenericMsg MsgGen;
SYNCMGRITEMID ItemID;
DWORD dwSyncMgrStatus;
} MSGSetItemStatus;



typedef struct _tagMSGShowErrors
{
GenericMsg MsgGen;
HWND hWndParent;
SYNCMGRERRORID ErrorID;
ULONG *pcbNumItems;
SYNCMGRITEMID **ppItemIDs;
} MSGShowConflicts;

typedef struct _tagMSGLogErrors
{
DWORD mask;
SYNCMGRERRORID ErrorID;
BOOL fHasErrorJumps;
SYNCMGRITEMID ItemID;
DWORD dwErrorLevel;
const WCHAR *lpcErrorText;
} MSGLogErrors;


typedef struct _tagMSGDeleteLogErrors
{
HANDLERINFO *pHandlerId;
SYNCMGRERRORID ErrorID;
} MSGDeleteLogErrors;


typedef struct _tagMSGAddItemHandler
{
GenericMsg MsgGen;
HWND hwndList; // review, unused.
DWORD *pcbNumItems;
} MSGAddItemHandler;

typedef struct _tagMSGSetupCallback
{
GenericMsg MsgGen;
BOOL fSet;
} MSGSetupCallback;


// inherit from IOfflineSynchronize to catch any interface changes.

class CThreadMsgProxy 
{
public:
    CThreadMsgProxy();
    ~CThreadMsgProxy();

    STDMETHODIMP InitProxy(HWND hwndStub, DWORD ThreadId,HANDLE hThread,HWND hwndDlg,
			REFCLSID refClsid,STUBLIST *pStubId);					
    STDMETHODIMP DispatchMsg(GenericMsg *genMsg,BOOL fAllowIncomingCalls,BOOL fAsync);
    STDMETHODIMP DispatchsStubMsg(GenericMsg *pgenMsg,BOOL fAllowIncomingCalls);

    //IUnknown members
    STDMETHODIMP	    QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // IOfflineSynchronize Methods
    STDMETHODIMP Initialize(DWORD dwReserved,DWORD dwSyncFlags,
				DWORD cbCookie,const BYTE *lpCooke);

    STDMETHODIMP GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
        
    STDMETHODIMP EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOfflineItems);
    STDMETHODIMP GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv);
    STDMETHODIMP ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID);
    STDMETHODIMP SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack);
    STDMETHODIMP PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
			    HWND hWndParent,DWORD dwReserved);
    STDMETHODIMP Synchronize(HWND hWndParent);
    STDMETHODIMP SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus);
    STDMETHODIMP ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID,ULONG *pcbNumItems,SYNCMGRITEMID **ppItemIDs);

    // Private messages
    STDMETHODIMP  CreateServer(const CLSID *pCLSIDServer,CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId);
    STDMETHODIMP  SetHndlrQueue(CHndlrQueue *pHndlrQueue,
			HANDLERINFO *pHandlerId,
			DWORD dwThreadIdProxy);
    STDMETHODIMP  AddHandlerItems(HWND hwndList,DWORD *pcbNumItems);
    STDMETHODIMP  SetupCallback(BOOL fSet);
    STDMETHODIMP  SetProxyParams(HWND hwndDlg, DWORD ThreadIdProxy,
			    CHndlrQueue *pHndlrQueue,HANDLERINFO *pHandlerId );

    inline STDMETHODIMP  SetProxyHwndDlg(HWND hwndDlg) { 
			m_hwndDlg = hwndDlg; 
			return NOERROR; 
			}

    inline BOOL IsProxyInOutCall() { return m_dwNestCount; }
    STDMETHODIMP SetProxyCompletion(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);

    // messages sent to the toplevel stub object.

    STDMETHODIMP CreateNewHndlrMsg();
    STDMETHODIMP ReleaseStub();
    STDMETHODIMP TerminateHandlerThread(TCHAR *pszHandlerName,BOOL fPromptUser);

private:
    HANDLE m_hThreadStub; // Handle of the Stubs Thread
    DWORD m_ThreadIdStub; // ThreadID to send Message to.
    HWND m_hwndStub; // HWND OF STUB.
    CHndlrMsg *m_pCHndlrMsg; // HndlrMsg associated with this proxy.
    BOOL  m_fTerminatedHandler; // set to true if handler has been terminated.
    STUBLIST *m_pStubId; // Id of stub this proxy belongs to.
    HWND  m_hwndDlg; // hwnd of any dialog on this thread.
    CLSID m_Clsid; // clsid of this handler.
    DWORD m_ThreadIdProxy;

    
    // Proxy Side Information
    CHndlrQueue *m_pHndlrQueue;
    HANDLERINFO * m_pHandlerId;
    BOOL m_fNewHndlrQueue; // set to indicate if Stub side information is out of date.
    DWORD m_dwNestCount; // keeps track of number of nestcount on item so can determine if in out call.
    MSG m_msgCompletion;
    BOOL m_fHaveCompletionCall;

    DWORD m_cRef;
};

#define MSGSERVICE_HWNDCLASSNAME  "SyncMgr_HwndMsgService"
#define DWL_THREADWNDPROCCLASS 0 // window long offset to MsgService Hwnd this ptr.


LRESULT CALLBACK  MsgThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

typedef enum _tagMSGHWNDTYPE   
{	
    MSGHWNDTYPE_UNDEFINED			= 0x0, // Message Service has not been initialized
    MSGHWNDTYPE_HANDLERTHREAD			= 0x1, // Message Service if for a Handler Thread.
    MSGHWNDTYPE_MAINTHREAD			= 0x2, // Message Service if for the Main Thread
} MSGHWNDTYPE;

typedef struct _tagMSGSERVICEQUEUE
{
  struct _tagMSGSERVICEQUEUE *pNextMsg;
  DWORD dwNestCount; // nestcount completion should be called.
  MSG msg;
} MSGSERVICEQUEUE;

class CMsgServiceHwnd 
{
public:
    HWND m_hwnd;
    DWORD m_dwThreadID;
    CHndlrMsg *m_pHndlrMsg;
    MSGHWNDTYPE m_MsgHwndType;
    MSGSERVICEQUEUE *m_pMsgServiceQueue; // queue to hold any message to process when current
					// cal completes.
    BOOL m_fInOutCall;

    CMsgServiceHwnd();
    ~CMsgServiceHwnd();
    inline HWND GetHwnd() { return m_hwnd; };
    BOOL Initialize(DWORD dwThreadID,MSGHWNDTYPE MsgHwndType);
    HRESULT HandleThreadMessage(MessagingInfo *pmsgInfo,GenericMsg *pgenMsg);
    void Destroy();
};

// internal functions
HRESULT SendThreadMessage(DWORD idThread,UINT uMsg,WPARAM wParam,LPARAM lParam);
DWORD WINAPI HandlerThread( LPVOID );
HRESULT DoModalLoop(HANDLE hEvent,HANDLE hThread,HWND hwndDlg,BOOL fAllowIncomingCalls,DWORD dwTimeout);


#endif // _THREADMSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\objmgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ObjMgr.h
//
//  Contents:   Keeps track of our applications dialog objects
//              and lifetime
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _OBJMGR_
#define _OBJMGR_

class CBaseDlg;
class CChoiceDlg;
class CProgressDlg;

typedef enum _tagDLGTYPE   // type of dialog.
{
    DLGTYPE_CHOICE                      = 0x1,
    DLGTYPE_PROGRESS                    = 0x2,
} DLGTYPE;

enum EAutoDialState
{
    eQuiescedOn,        // Quiesced state and auto dial is on
    eQuiescedOff,       // Quiesced state and auto dial is off
    eAutoDialOn,        // During a sync session and auto dial is on
    eAutoDialOff        // During a sync session and auto dial is off
};


typedef struct _tagDLGLISTITEM {
    _tagDLGLISTITEM *pDlgNextListItem;  // pointer to the next dialog in the list.
    DLGTYPE dlgType;            // type of dialog this is.
    ULONG cRefs;                // number of references on this object
    ULONG cLocks;               // number of locks on this object
    CLSID clsid;                // clsid of this dialog, only applicable to choice.
    CBaseDlg *pDlg;
    DWORD dwThreadID;           // Thread the dialog is on.
    HANDLE hThread;             // Handle to the thread the dialog belongs too
    BOOL fHasReleaseDlgCmdId;   // boolean to indicate if there is a callback
    WORD wCommandID;            // CommandID to pass to the callback.
} DLGLISTITEM;


typedef struct _tagOBJECTMGRDATA {
    DLGLISTITEM *DlgList; // Ptr to Dialog list
    HANDLE hClassRegisteredEvent; // Event created by process that has registered the classFactory.
    DWORD dwRegClassFactCookie; // registered OLE Class Factory Cooke
    BOOL fRegClassFactCookieValid; // registered OLE Class Factory Cooke
    DWORD LockCountInternal;    // Internal lock count on Application
    DWORD LockCountExternal;    // External lock count on Application
    BOOL  fCloseAll;   // Set if told to CloseAll, used in ReleaseOneStopLifetime
    DWORD dwSettingsLockCount;  // number of lock counts on the settings dialog,.
    DWORD dwHandlerPropertiesLockCount; // number of lock counts on any handler properties dialogs open
    BOOL fDead; // set in release call to avoid multiple releases.
    DWORD dwMainThreadID; // Id of Main Thrad
    HWND hWndMainThreadMsg; //hwnd of Main Thread Message Hwnd.
    BOOL fIdleHandlerRunning; // SyncMgr is currently processing Idle.
    EAutoDialState   eAutoDialState;     // State machine for supporting autodial
    BOOL             fRasAutoDial;       // Is Ras auto dial on ?
    BOOL             fWininetAutoDial;   // Is Wininet auto dial on ?
    BOOL             fFirstSyncItem;     // Is the first PrepareForSyncItem being processed
    ULONG            cNestedStartCalls;  // Count of nested start calls
} OBJECTMGRDATA;


typedef struct _tagDlgThreadArgs {
HANDLE hEvent; // used to know when the message loop has been created.
HRESULT hr; // inidicates if creation was successfull
DLGTYPE dlgType; // requested dialog type to create.
CLSID clsid; // clsid identifies the dialog.
int nCmdShow; // how to display the dialog
CBaseDlg *pDlg; // pointer to the created dialog.
} DlgThreadArgs;

DWORD WINAPI DialogThread( LPVOID lpArg );

// onetime initialization routiens
STDAPI InitObjectManager(CMsgServiceHwnd *pMsgService);

// determines main threads response to WM_QUERYENDSESSION
STDAPI ObjMgr_HandleQueryEndSession(HWND *hwnd,UINT *uMessageId,BOOL *fLetUserDecide);
STDAPI_(ULONG) ObjMgr_AddRefHandlerPropertiesLockCount(DWORD dwNumRefs);
STDAPI_(ULONG) ObjMgr_ReleaseHandlerPropertiesLockCount(DWORD dwNumRefs);
STDAPI ObjMgr_CloseAll();

// idle managmenent
STDAPI RequestIdleLock();
STDAPI ReleaseIdleLock();

// routines for handling dialog lifetime
STDAPI FindChoiceDialog(REFCLSID rclsid,BOOL fCreate,int nCmdShow,CChoiceDlg **pChoiceDlg);
STDAPI_(ULONG) AddRefChoiceDialog(REFCLSID rclsid,CChoiceDlg *pChoiceDlg);
STDAPI_(ULONG) ReleaseChoiceDialog(REFCLSID rclsid,CChoiceDlg *pChoiceDlg);
STDAPI SetChoiceReleaseDlgCmdId(REFCLSID rclsid,CChoiceDlg *pChoiceDlg,WORD wCommandId);

STDAPI FindProgressDialog(REFCLSID rclsid,BOOL fCreate,int nCmdShow,CProgressDlg **pProgressDlg);
STDAPI_(ULONG) AddRefProgressDialog(REFCLSID rclsid,CProgressDlg *pProgressDlg);
STDAPI_(ULONG) ReleaseProgressDialog(REFCLSID rclsid,CProgressDlg *pProgressDlg,BOOL fForce);
STDAPI SetProgressReleaseDlgCmdId(REFCLSID rclsid,CProgressDlg *pProgressDlg,WORD wCommandId);
STDAPI LockProgressDialog(REFCLSID rclsid,CProgressDlg *pProgressDlg,BOOL fLock);

// helper routines called by dialog lifetime.
STDAPI FindDialog(DLGTYPE dlgType,REFCLSID rclsid,BOOL fCreate,int nCmdShow,CBaseDlg **pDlg);
STDAPI_(ULONG) AddRefDialog(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg);
STDAPI_(ULONG) ReleaseDialog(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg,BOOL fForce);
STDAPI SetReleaseDlgCmdId(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg,WORD wCommandId);

// Routines called for dial support
STDAPI BeginSyncSession();
STDAPI EndSyncSession();
STDAPI ApplySyncItemDialState( BOOL fAutoDialDisable );
STDAPI GetAutoDialState();
STDAPI LokDisableAutoDial();
STDAPI LokEnableAutoDial();

typedef struct _tagDlgSettingsArgs {
HANDLE hEvent; // used to know when thread has been initialized.
HWND hwndParent; // hwnd to use the parent as.
DWORD dwParentThreadId;
} DlgSettingsArgs;

DWORD WINAPI  SettingsThread( LPVOID lpArg );
STDAPI ShowOptionsDialog(HWND hwndParent);

// helper routine for OLE classes.
STDAPI RegisterOneStopClassFactory(BOOL fForce);

// routines for managing lifetime of application
STDAPI_(ULONG) AddRefOneStopLifetime(BOOL fExternal);
STDAPI_(ULONG) ReleaseOneStopLifetime(BOOL fExternal);

// routines for routing messages
BOOL IsOneStopDlgMessage(MSG *msg);

// declarations for CSingletonNetapi class.

//+-------------------------------------------------------------------------
//
//  Class:      CSingletonNetApi
//
//  Purpose:    Singleton net api object
//
//  History:    31-Jul-98     SitaramR      Created
//
//--------------------------------------------------------------------------

class CSingletonNetApi : CLockHandler
{
public:

    CSingletonNetApi()
       : m_pNetApi(0)
    {
    }

    ~CSingletonNetApi();

    LPNETAPI GetNetApiObj();
    void DeleteNetApiObj();

private:
    LPNETAPI  m_pNetApi;                  // Actual net api object
};

extern CSingletonNetApi gSingleNetApiObj;  // Global singleton NetApi object


#endif // _OBJMGR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\progress.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Progress.cpp
//
//  Contents:   Progress Dialog
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   Susia      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define TIMERID_TRAYANIMATION 3
#define TRAYANIMATION_SPEED 500 // speed in milliseconds

#define TIMERID_NOIDLEHANGUP 4  // inform wininet that connection isn't idle.
#define NOIDLEHANGUP_REFRESHRATE (1000*30) // inform of idle every 30 seconds.

#define TIMERID_KILLHANDLERS 5
#define TIMERID_KILLHANDLERSMINTIME (1000*15) // minimum timeout for kill handlers that are hung after cancel.
#define TIMERID_KILLHANDLERSWIN9XTIME (1000*60) // Timeout for for kill handlers other than NT 5.0

const TCHAR c_szTrayWindow[]            = TEXT("Shell_TrayWnd");
const TCHAR c_szTrayNotifyWindow[]      = TEXT("TrayNotifyWnd");

#ifndef IDANI_CAPTION
#define IDANI_CAPTION   3
#endif // IDANI_CAPTION

// list collapsed items first so only have to loop
// though first item to cbNumDlgResizeItemsCollapsed when
// not expanded.
const DlgResizeList g_ProgressResizeList[] = {
    IDSTOP,DLGRESIZEFLAG_PINRIGHT,
    IDC_DETAILS,DLGRESIZEFLAG_PINRIGHT,
    IDC_RESULTTEXT,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    IDC_STATIC_WHATS_UPDATING,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    IDC_STATIC_WHATS_UPDATING_INFO,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    IDC_STATIC_HOW_MANY_COMPLETE,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    IDC_SP_SEPARATOR,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT,
    // expanded items
    IDC_TOOLBAR, DLGRESIZEFLAG_PINRIGHT,
    IDC_PROGRESS_TABS,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINTOP,
    IDC_UPDATE_LIST,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINTOP,
    IDC_SKIP_BUTTON_MAIN,DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINLEFT,
    IDC_STATIC_SKIP_TEXT,DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINLEFT,
    IDC_PROGRESS_OPTIONS_BUTTON_MAIN,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM,
    IDC_LISTBOXERROR,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINLEFT | DLGRESIZEFLAG_PINBOTTOM | DLGRESIZEFLAG_PINTOP,
    IDC_PROGRESSRESIZESCROLLBAR,DLGRESIZEFLAG_PINRIGHT | DLGRESIZEFLAG_PINBOTTOM,
};

extern HINSTANCE g_hInst;      // current instance
extern TCHAR g_szSyncMgrHelp[];
extern ULONG g_aContextHelpIds[];

extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo, setup by WinMain.
extern LANGID g_LangIdSystem; // langID of system we are running on.
extern DWORD g_WMTaskbarCreated; // TaskBar Created WindowMessage;

BOOL CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);

//defined in progtab.cpp
extern BOOL CALLBACK UpdateProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
extern BOOL CALLBACK ResultsProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
extern BOOL OnProgressResultsMeasureItem(HWND hwnd,CProgressDlg *pProgress, UINT *horizExtent, UINT idCtl, MEASUREITEMSTRUCT *pMeasureItem);
extern BOOL OnProgressResultsDeleteItem(HWND hwnd, UINT idCtl, const DELETEITEMSTRUCT * lpDeleteItem);
extern void OnProgressResultsSize(HWND hwnd,CProgressDlg *pProgress,UINT uMsg,WPARAM wParam,LPARAM lParam);

//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::CProgressDlg()
//
//  PURPOSE:  Constructor
//
//      COMMENTS: Constructor for progress dialog
//
//
//--------------------------------------------------------------------------------
CProgressDlg::CProgressDlg(REFCLSID rclsid)
{

    m_clsid = rclsid;
    m_cInternalcRefs = 0;
    m_hwnd = NULL;
    m_hwndTabs = NULL;
    m_errorimage = NULL;
    m_HndlrQueue = NULL;
    m_iProgressSelectedItem = -1;
    m_iItem = -1;           // index to any new item to the list box.
    m_iResultCount = -1;    // Number of logged results
    m_iErrorCount = 0;      // Number of logged errors
    m_iWarningCount = 0;    // Number of logged warnings
    m_iInfoCount = 0;       // Number of logged info
    m_dwThreadID = -1;
    m_nCmdShow = SW_SHOWNORMAL;
//    m_hRasConn = NULL;
    m_pSyncMgrIdle = NULL;
    m_fHasShellTrayIcon = FALSE;
    m_fAddedIconToTray = FALSE;
    m_fnResultsListBox = NULL;

    m_ulIdleRetryMinutes = 0;
    m_ulDelayIdleShutDownTime = 0;

    m_fHwndRightToLeft = FALSE;

    m_iLastItem = -1;
    m_dwLastStatusType = -1;

    m_dwHandleThreadNestcount = 0;
    m_dwShowErrorRefCount = 0;
    m_dwSetItemStateRefCount = 0;
    m_dwHandlerOutCallCount = 0;
    m_dwPrepareForSyncOutCallCount = 0;
    m_dwSynchronizeOutCallCount = 0;
    m_dwQueueTransferCount = 0;
    m_clsidHandlerInSync = GUID_NULL;
    m_fForceClose = FALSE;
      
    // setup KillTimerTimeout based on paltform

    if ( (VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId) 
        && (g_OSVersionInfo.dwMajorVersion >=  5))
    {
        m_nKillHandlerTimeoutValue = TIMERID_KILLHANDLERSMINTIME;
    }
    else
    {
        m_nKillHandlerTimeoutValue = TIMERID_KILLHANDLERSWIN9XTIME;
    }


    m_dwProgressFlags = PROGRESSFLAG_NEWDIALOG;
    m_pItemListView =  NULL;
    m_iTrayAniFrame = IDI_SYSTRAYANI6; // initialize to end.

    LoadString(g_hInst, IDS_STOPPED,            m_pszStatusText[0], MAX_STRING_RES);
    LoadString(g_hInst, IDS_SKIPPED,            m_pszStatusText[1], MAX_STRING_RES);
    LoadString(g_hInst, IDS_PENDING,            m_pszStatusText[2], MAX_STRING_RES);
    LoadString(g_hInst, IDS_SYNCHRONIZING,      m_pszStatusText[3], MAX_STRING_RES);
    LoadString(g_hInst, IDS_SUCCEEDED,          m_pszStatusText[4], MAX_STRING_RES);
    LoadString(g_hInst, IDS_FAILED,                     m_pszStatusText[5], MAX_STRING_RES);
    LoadString(g_hInst, IDS_PAUSED,                     m_pszStatusText[6], MAX_STRING_RES);
    LoadString(g_hInst, IDS_RESUMING,           m_pszStatusText[7], MAX_STRING_RES);


    // Determine if SENS is installed
    LPNETAPI pNetApi;

    m_fSensInstalled = FALSE;
    if (pNetApi = gSingleNetApiObj.GetNetApiObj())
    {
        m_fSensInstalled = pNetApi->IsSensInstalled();
        pNetApi->Release();
    }

    m_CurrentListEntry = NULL;
    
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::AddRefProgressDialog, private
//
//  Synopsis:   Called to Addref ourselves
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    26-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CProgressDlg::AddRefProgressDialog()
{
ULONG cRefs;

    cRefs = ::AddRefProgressDialog(m_clsid,this); // addref GlobalRef

    Assert(0 <= m_cInternalcRefs);
    ++m_cInternalcRefs;

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::ReleaseProgressDialog, private
//
//  Synopsis:   Called to Release ourselves
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    26-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CProgressDlg::ReleaseProgressDialog(BOOL fForce)
{
ULONG cRefs;

    Assert(0 < m_cInternalcRefs);
    --m_cInternalcRefs;

    cRefs = ::ReleaseProgressDialog(m_clsid,this,fForce); // release global ref.

    return cRefs;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::Initialize()
//
//  PURPOSE:  Initialize the Progress Dialog
//
//      COMMENTS: Implemented on main thread.
//
//
//--------------------------------------------------------------------------------
BOOL CProgressDlg::Initialize(DWORD dwThreadID,int nCmdShow)
{
BOOL fCreated = FALSE;
    Assert(NULL == m_hwnd);

    m_nCmdShow = nCmdShow;

    if (NULL == m_hwnd)
    {
        m_dwThreadID = dwThreadID;

        m_hwnd =  CreateDialogParam(g_hInst,MAKEINTRESOURCE(IDD_PROGRESS),NULL,  (DLGPROC) ProgressWndProc,
                        (LPARAM) this);

        if (!m_hwnd)
            return FALSE;

        // expand/collapse dialog base on use settings.
        RegGetProgressDetailsState(m_clsid,&m_fPushpin, &m_fExpanded);
        ExpandCollapse(m_fExpanded, TRUE);

        // Set the state of the thumbtack
        if (m_fPushpin)
        {
            SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_SETSTATE, IDC_PUSHPIN,
                               MAKELONG(TBSTATE_CHECKED | TBSTATE_ENABLED, 0));
            SendMessage(m_hwnd, WM_COMMAND, IDC_PUSHPIN, 0);
        }


        m_HndlrQueue = new CHndlrQueue(QUEUETYPE_PROGRESS,this); // reivew, queueu should be created and passed in initialize??


        // if this is the idle progress then need to load up msidle and
        // set up the callback

        if (m_clsid == GUID_PROGRESSDLGIDLE)
        {
        BOOL fIdleSupport = FALSE;

            m_pSyncMgrIdle = new CSyncMgrIdle();

            if (m_pSyncMgrIdle)
            {
                fIdleSupport = m_pSyncMgrIdle->Initialize();

                if (FALSE == fIdleSupport)
                {
                    delete m_pSyncMgrIdle;
                    m_pSyncMgrIdle = NULL;
                }
            }

            // if couldn't load idle, then return a failure
            if (FALSE == fIdleSupport)
            {
                return FALSE;
            }

        }


        fCreated = TRUE;

        // When Window is first created show with specified nCmdShow.
        // Review if want to wait to show window until transfer comes in.
        UpdateWndPosition(nCmdShow,TRUE /* fForce */);

    }


   Assert(m_hwnd);

   UpdateWindow(m_hwnd);
   return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam)
//
//  PURPOSE:  moves and resizes dialog items based on current window size.
//
//--------------------------------------------------------------------------------

void CProgressDlg::OnSize(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
ULONG cbNumResizeItems;
HWND hwndSizeGrip;

    cbNumResizeItems  =  m_fExpanded ? m_cbNumDlgResizeItemsExpanded :
                                        m_cbNumDlgResizeItemsCollapsed;

    ResizeItems(cbNumResizeItems,m_dlgResizeInfo);

    // if expanded and not maximized show the resize, else hide it.
    hwndSizeGrip = GetDlgItem(m_hwnd,IDC_PROGRESSRESIZESCROLLBAR);
    if (hwndSizeGrip)
    {
    int nCmdShow = (m_fMaximized || !m_fExpanded) ? SW_HIDE : SW_NORMAL;

	// temporarily always hide if right to left
	if (m_fHwndRightToLeft)
	{
	    nCmdShow = SW_HIDE;
        }

        ShowWindow(hwndSizeGrip,nCmdShow);
    }

    // tell the error listbox it needs to recalc its items heights
    OnProgressResultsSize(m_hwnd,this,WM_SIZE,0,0);
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::OffIdle()
//
//  PURPOSE:  Informs progress dialog that the machine is no longer Idle.
//
// Scenarios
//
//      dialog is maximized, just keep processing.
//      dialog is minimized or in tray - Set our wait timer for a specified time
//          if dialog is still minimized, go away
//          if dialog is now maximized just keep processing.
//
//--------------------------------------------------------------------------------

void CProgressDlg::OffIdle()
{

    Assert(!(PROGRESSFLAG_DEAD & m_dwProgressFlags)); // make sure not notified after dialog gone.

     m_dwProgressFlags |=  PROGRESSFLAG_INOFFIDLE;

    // set flag that we received the OffIdle
    m_dwProgressFlags |= PROGRESSFLAG_RECEIVEDOFFIDLE;

    // reset Flag so know that no longer registered for Idle.
    m_dwProgressFlags &=  ~PROGRESSFLAG_REGISTEREDFOROFFIDLE;

     // make sure in all cases we release the idle reference.

    // if in shutdownmode or cancel has already been pressed
    // by the user or if window is visible but not in the Tray.
    // then don't bother with the wait.

    if ( !IsWindowVisible(m_hwnd) && m_fHasShellTrayIcon
        && !(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
        && !(m_dwProgressFlags & PROGRESSFLAG_CANCELPRESSED) 
        && (m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS) )
    {
    HANDLE hTimer =  CreateEvent(NULL,TRUE,FALSE,NULL);

        // should use Create/SetWaitable timer to accomplish this but these
        // functions aren't available on Win9x yet.

        if (hTimer)
        {
        UINT uTimeOutValue = m_ulDelayIdleShutDownTime;

            Assert(sizeof(UINT) >= sizeof(HANDLE));

            DoModalLoop(hTimer,NULL,m_hwnd,TRUE,uTimeOutValue);

            CloseHandle(hTimer);
        }
    }


    // now after our wait, check the window placement again
    // if window is not visible or is in the tray
    // then do a cancel on behalf of the User,

    if ( (!IsWindowVisible(m_hwnd) || m_fHasShellTrayIcon)
        && !(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
        && !(m_dwProgressFlags & PROGRESSFLAG_CANCELPRESSED) )
    {
        OnCancel(TRUE);
    }


    // now if we aren't syncing any items and no items
    // waiting in the queue release our idle lock
    // !!! warning. don't release until after wait above to
    // don't have to worry about next idle firing before
    // this method is complete.

    if (!(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS)
        || !(m_dwQueueTransferCount) )
    {
        ReleaseIdleLock();
    }

    m_dwProgressFlags &=  ~PROGRESSFLAG_INOFFIDLE;

    ReleaseProgressDialog(m_fForceClose); // release our addref.
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::OnIdle()
//
//  PURPOSE:  Informs progress dialog that the machine is still
//          Idle after a set amount of time.
//
//
//--------------------------------------------------------------------------------

void CProgressDlg::OnIdle()
{
CSynchronizeInvoke *pSyncMgrInvoke;

    Assert(!(m_dwProgressFlags & PROGRESSFLAG_DEAD)); // make sure not notified after dialog gone.

    // if received and offIdle then ignore this idle until next ::transfer
    if (!(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE)
        && !(m_dwProgressFlags & PROGRESSFLAG_INOFFIDLE) )
    {
        AddRefProgressDialog(); // hold alive until next items are queued.

        pSyncMgrInvoke = new CSynchronizeInvoke;

        if (pSyncMgrInvoke)
        {
            pSyncMgrInvoke->RunIdle();
            pSyncMgrInvoke->Release();
        }

        ReleaseProgressDialog(m_fForceClose);
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::SetIdleParams()
//
//  PURPOSE:  Sets the IdleInformation, last writer wins.
//
//
//--------------------------------------------------------------------------------

void CProgressDlg::SetIdleParams( ULONG ulIdleRetryMinutes,ULONG ulDelayIdleShutDownTime
                                 ,BOOL fRetryEnabled)
{
    Assert(m_clsid == GUID_PROGRESSDLGIDLE);

    m_ulIdleRetryMinutes = ulIdleRetryMinutes;
    m_ulDelayIdleShutDownTime = ulDelayIdleShutDownTime;

    if (fRetryEnabled)
    {
        m_dwProgressFlags |=  PROGRESSFLAG_IDLERETRYENABLED;
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   BOOL CProgressDlg::InitializeToolbar(HWND hwnd)
//
//  PURPOSE:    What dialog would be complete without a toolbar, eh?
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------------------
BOOL CProgressDlg::InitializeToolbar(HWND hwnd)
{
HWND hwndTool;
HIMAGELIST himlImages = ImageList_LoadBitmap(g_hInst,
                                        MAKEINTRESOURCE(IDB_PUSHPIN), 16, 0,
                                        RGB(255, 0, 255));

    hwndTool  = GetDlgItem(hwnd,IDC_TOOLBAR);

    //If we can't create the pushpin window
    //the user just won't get a pushpin.

    if (hwndTool)
    {
#ifdef _ZORDER
        SetWindowPos(GetDlgItem(hwnd, IDC_PROGRESS_TABS),HWND_BOTTOM,0,0,0,0,
                 SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

        SetWindowPos(GetDlgItem(hwnd, IDC_PROGRESSRESIZESCROLLBAR),
                 HWND_BOTTOM,0,0,0,0,SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

#endif // _ZORDER

        TBBUTTON tb = { IMAGE_TACK_OUT, IDC_PUSHPIN, TBSTATE_ENABLED, TBSTYLE_CHECK, 0, 0 };
        SendMessage(hwndTool, TB_SETIMAGELIST, 0, (LPARAM) himlImages);
        SendMessage(hwndTool, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(hwndTool, TB_SETBUTTONSIZE, 0, MAKELONG(14, 14));
        SendMessage(hwndTool, TB_SETBITMAPSIZE, 0, MAKELONG(14, 14));
        SendMessage(hwndTool, TB_ADDBUTTONS, 1, (LPARAM) &tb);
    }

    return (0);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::InitializeTabs(HWND hwnd)
//
//  PURPOSE:    Initializes the tab control on the dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------------------

BOOL CProgressDlg::InitializeTabs(HWND hwnd)
{
    m_hwndTabs = GetDlgItem(hwnd, IDC_PROGRESS_TABS);
        TC_ITEM tci;
    TCHAR szRes[MAX_STRING_RES];

        if (!m_hwndTabs )
                return FALSE;

    // "Updates"
    tci.mask = TCIF_TEXT;
    LoadString(g_hInst, IDS_UPDATETAB, szRes, ARRAY_SIZE(szRes));
    tci.pszText = szRes;
    TabCtrl_InsertItem(m_hwndTabs,PROGRESS_TAB_UPDATE, &tci);

    // "Results"
    LoadString(g_hInst, IDS_ERRORSTAB, szRes, ARRAY_SIZE(szRes));
    tci.pszText = szRes;
        TabCtrl_InsertItem(m_hwndTabs, PROGRESS_TAB_ERRORS, &tci);

    //Set the tab to the Update page to begin with
    m_iTab = PROGRESS_TAB_UPDATE;

    if (-1 != TabCtrl_SetCurSel(m_hwndTabs, PROGRESS_TAB_UPDATE))
    {
            m_iTab = PROGRESS_TAB_UPDATE;
            ShowWindow(GetDlgItem(hwnd, IDC_LISTBOXERROR), SW_HIDE);
    }
    else //ToDo:  What do we do if the set tab fails?
    {
            m_iTab = -1;
            return FALSE;
    }

    return (TRUE);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::InitializeUpdateList(HWND hwnd)
//
//  PURPOSE:    Initializes the update list view control on the progress dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------------------


BOOL CProgressDlg::InitializeUpdateList(HWND hwnd)
{
HWND hwndList = GetDlgItem(hwnd,IDC_UPDATE_LIST);
HIMAGELIST himage;
TCHAR pszProgressColumn[MAX_STRING_RES + 1];
int iListViewWidth;

    if (hwndList)
    {

        m_pItemListView = new CListView(hwndList,hwnd,IDC_UPDATE_LIST,WM_BASEDLG_NOTIFYLISTVIEWEX);
    }

    if (!m_pItemListView)
    {
        return FALSE;
    }

    if (m_pItemListView)
    {
    UINT ImageListflags;

        ImageListflags = ILC_COLOR | ILC_MASK;
        if (IsHwndRightToLeft(hwnd))
        {
             ImageListflags |=  ILC_MIRROR;
        }

        // create an imagelist
        himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                         GetSystemMetrics(SM_CYSMICON),ImageListflags,5,20);
        if (himage)
        {
            m_pItemListView->SetImageList(himage,LVSIL_SMALL);
        }

        // for column widths go 35%, 20%, 45%
        iListViewWidth = CalcListViewWidth(hwndList,410);

        //set up the columns
        LoadString(g_hInst, IDS_PROGRESS_DLG_COLUMN_NAME, pszProgressColumn, MAX_STRING_RES);
        InsertListViewColumn(m_pItemListView,PROGRESSLIST_NAMECOLUMN,pszProgressColumn,
                                   LVCFMT_LEFT,(iListViewWidth*7)/20 /* cx */);


        LoadString(g_hInst, IDS_PROGRESS_DLG_COLUMN_STATUS, pszProgressColumn, MAX_STRING_RES);
        InsertListViewColumn(m_pItemListView,PROGRESSLIST_STATUSCOLUMN,pszProgressColumn,
                           LVCFMT_LEFT,(iListViewWidth/5) /* cx */);


        LoadString(g_hInst, IDS_PROGRESS_DLG_COLUMN_INFO, pszProgressColumn, MAX_STRING_RES);
        InsertListViewColumn(m_pItemListView,PROGRESSLIST_INFOCOLUMN,pszProgressColumn,
                           LVCFMT_LEFT,(iListViewWidth*9)/20 /* cx */);

    }

    return (TRUE);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::InitializeResultsList(HWND hwnd)
//
//  PURPOSE:    Initializes the results list view control on the progress dialog.
//
//  RETURN VALUE:
//      TRUE if everything succeeded, FALSE otherwise.
//
//--------------------------------------------------------------------------------

BOOL CProgressDlg::InitializeResultsList(HWND hwnd)
{
HWND hwndList = GetDlgItem(hwnd,IDC_LISTBOXERROR);
LBDATA  *pData = NULL;
TCHAR pszError[MAX_STRING_RES];
UINT ImageListflags;


    LoadString(g_hInst, IDS_NOERRORSREPORTED, pszError, ARRAY_SIZE(pszError));

    if (!hwndList)
            return FALSE;

    SetCtrlFont(hwndList,g_OSVersionInfo.dwPlatformId,g_LangIdSystem);


        // Allocate a struct for the item data
    if (!(pData = (LBDATA *) ALLOC(sizeof(LBDATA) + sizeof(pszError))))
    {
        return FALSE;
    }


    pData->fIsJump = FALSE;
    pData->fTextRectValid = FALSE;
    pData->fHasBeenClicked = FALSE;
    pData->fAddLineSpacingAtEnd = FALSE;
    pData->ErrorID = GUID_NULL;
    pData->dwErrorLevel = SYNCMGRLOGLEVEL_INFORMATION;
    pData->pHandlerID = 0;
    lstrcpy(pData->pszText, pszError);

    // create the error image list based on the current System
    // metrics
    m_iIconMetricX =   GetSystemMetrics(SM_CXSMICON);
    m_iIconMetricY =   GetSystemMetrics(SM_CYSMICON);


    ImageListflags = ILC_COLOR | ILC_MASK;
    if (IsHwndRightToLeft(hwnd))
    {
         ImageListflags |=  ILC_MIRROR;
    }

    m_errorimage = ImageList_Create(m_iIconMetricX,m_iIconMetricY,ImageListflags, 0, MAX_ERR0R_ICONS);

    // load up the Error Images, if fail then just won't be an image next to the text
    if (m_errorimage)
    {
        m_ErrorImages[ErrorImage_Information] = ImageList_AddIcon(m_errorimage,LoadIcon(NULL,IDI_INFORMATION));
        m_ErrorImages[ErrorImage_Warning] = ImageList_AddIcon(m_errorimage,LoadIcon(NULL,IDI_WARNING));
        m_ErrorImages[ErrorImage_Error] = ImageList_AddIcon(m_errorimage,LoadIcon(NULL,IDI_ERROR));
    }
    else
    {
        m_ErrorImages[ErrorImage_Information] = m_ErrorImages[ErrorImage_Warning] =
             m_ErrorImages[ErrorImage_Error] = -1;
    }

    //Add a default Icon
    pData->IconIndex = m_ErrorImages[ErrorImage_Information];

    // Add the item data
    AddListData(pData, sizeof(pszError), hwndList);
    return TRUE;

}

void CProgressDlg::ReleaseDlg(WORD wCommandID)
{
    // put into dead state so know not
    // addref/release
    PostMessage(m_hwnd,WM_PROGRESS_RELEASEDLGCMD,wCommandID,0);
}

// notifies choice dialog when it is actually released.
void CProgressDlg::PrivReleaseDlg(WORD wCommandID)
{

    m_dwProgressFlags |=  PROGRESSFLAG_DEAD; // put us in the dead state.

    Assert(0 == m_dwQueueTransferCount); // shouldn't be going away if transfer is in progress!!

    RegSetProgressDetailsState(m_clsid,m_fPushpin, m_fExpanded);
    ShowWindow(m_hwnd,SW_HIDE);

    // if the tray is around hide it now.
    if (m_fHasShellTrayIcon)
    {
        RegisterShellTrayIcon(FALSE);
        m_fHasShellTrayIcon = FALSE;
    }


    switch (wCommandID)
    {
    case RELEASEDLGCMDID_OK: // on an okay sleep a little, then fall through to cancel.
    case RELEASEDLGCMDID_CANCEL:
        Assert(m_HndlrQueue);
    case RELEASEDLGCMDID_DESTROY: // called in Thread creation or initialize failed
    case RELEASEDLGCMDID_DEFAULT:
        if (m_HndlrQueue)
        {
            m_HndlrQueue->FreeAllHandlers();
            m_HndlrQueue->Release();
            m_HndlrQueue = NULL;
        }
        break;
    default:
        AssertSz(0,"Unknown Command");
        break;
    }


    Assert(m_hwnd);

    if (m_fHasShellTrayIcon)
    {
        RegisterShellTrayIcon(FALSE);
    }

     if (m_pSyncMgrIdle)
     {
        delete m_pSyncMgrIdle;
     }



    // if this is an idle progress then release our lock on the idle
    if (m_clsid == GUID_PROGRESSDLGIDLE)
    {
        ReleaseIdleLock();
    }


    if (m_pItemListView)
    {
        delete m_pItemListView;
        m_pItemListView = NULL;
    }

    if (m_hwnd)
        DestroyWindow(m_hwnd);

    delete this;

    return;
}

// updates window Z-Order and min/max state.
void CProgressDlg::UpdateWndPosition(int nCmdShow,BOOL fForce)
{
BOOL fRemoveTrayIcon = FALSE;
BOOL fWindowVisible = IsWindowVisible(m_hwnd);
BOOL fTrayRequest = ((nCmdShow == SW_MINIMIZE)|| (nCmdShow == SW_SHOWMINIMIZED) || (nCmdShow == SW_HIDE));
BOOL fHandledUpdate = FALSE;

    // only time we go to the tray is if the request is a minimize and
    // either the window is invisible or it is a force. note Hide for
    // now is treated as going to the tray.
    //
    // other cases or on tray failure we can just do a setforeground and show window.

    if (fTrayRequest && (fForce || !fWindowVisible))
    {

        if (m_fHasShellTrayIcon || RegisterShellTrayIcon(TRUE))
        {
             // if window was visible hide it and animiate
             if (fWindowVisible)
             {
                AnimateTray(TRUE);
                ShowWindow(m_hwnd,SW_HIDE);
             }

             fHandledUpdate = TRUE;
        }
    }

    if (!fHandledUpdate)
    {
        
        // if haven't handled then make sure window is shown and bring to
        // front

        if (m_fHasShellTrayIcon)
        {
            AnimateTray(FALSE);
        }

        ShowWindow(m_hwnd,SW_SHOW);
        SetForegroundWindow(m_hwnd);

        // if currently have a tray then lets animate
        // fAnimate =  m_fHasShellTrayIcon ? TRUE : FALSE;

        // if the tray is around but we didn't register it this time through then it should
        // be removed

        if (m_fHasShellTrayIcon)
        {
            RegisterShellTrayIcon(FALSE);
        }

    }

}

//--------------------------------------------------------------------------------
//
//  Member: CProgressDlg::AnimateTray
//
//  PURPOSE:  does animation to the tray
//
//  COMMENTS: true means we are animating to the tray, false means back to the hwnd.
//
//
//--------------------------------------------------------------------------------

BOOL CProgressDlg::AnimateTray(BOOL fTrayAdded)
{
BOOL fAnimate;
HWND hwndTray,hWndST;
RECT rcDlg;
RECT rcST;

    fAnimate = FALSE;

   // get rectangles for animation
    if (hwndTray = FindWindow(c_szTrayWindow, NULL))
    {
        if (hWndST = FindWindowEx(hwndTray, NULL, c_szTrayNotifyWindow, NULL))
        {
            GetWindowRect(m_hwnd, &rcDlg);
            GetWindowRect(hWndST, &rcST);

            fAnimate = TRUE;
        }
    }

    if (fAnimate)
    {
        if (fTrayAdded)
        {
            DrawAnimatedRects(m_hwnd, IDANI_CAPTION,&rcDlg,&rcST);
        }
        else
        {
            DrawAnimatedRects(m_hwnd, IDANI_CAPTION,&rcST,&rcDlg);
        }
    }

    return fAnimate;

}


//--------------------------------------------------------------------------------
//
//  Member: CProgressDlg::RegisterShellTrayIcon
//
//  PURPOSE:  Registers/Unregisters the dialog in the Tray.
//
//      COMMENTS:  Up to Caller to do the proper thing with the main hwnd.
//
//
//--------------------------------------------------------------------------------


BOOL CProgressDlg::RegisterShellTrayIcon(BOOL fRegister)
{
NOTIFYICONDATA icondata;


    if (fRegister)
    {
    BOOL fResult;

        m_fHasShellTrayIcon = TRUE;

        fResult = UpdateTrayIcon();

        if (!fResult) // if couldn't ad then say its not added.
        {
            m_fHasShellTrayIcon = FALSE;
        }

        return fResult;

   }
   else // remove ouselves from the tray.
   {
        Assert(TRUE == m_fHasShellTrayIcon);
        icondata.cbSize = sizeof(NOTIFYICONDATA);
        icondata.hWnd = m_hwnd;
        icondata.uID = 1;

        m_fHasShellTrayIcon = FALSE;
        m_fAddedIconToTray = FALSE;

        // ShellNotifyIcon Yields
        Shell_NotifyIcon(NIM_DELETE,&icondata);
   }

   return TRUE;
}

// called to Update the TrayIcon, Keeps track of highest warning state
// and sets the appropriate Icon in the tray. If the item is not already
// in the tray UpdateTrayIcon will not do a thing.

BOOL CProgressDlg::UpdateTrayIcon()
{
NOTIFYICONDATA icondata;
DWORD dwReturn = 0;

    if (m_fHasShellTrayIcon)
    {

        icondata.cbSize = sizeof(NOTIFYICONDATA);
        icondata.hWnd = m_hwnd;
        icondata.uID = 1;
        icondata.uFlags = NIF_ICON  | NIF_MESSAGE;
        icondata.uCallbackMessage = WM_PROGRESS_SHELLTRAYNOTIFICATION;

        // if progress animation is turned on then also animate
        // the tray.
        if (m_dwProgressFlags & PROGRESSFLAG_PROGRESSANIMATION)
        {
            // update the frame

            m_iTrayAniFrame++;

            if (m_iTrayAniFrame > IDI_SYSTRAYANI6)
                m_iTrayAniFrame = IDI_SYSTRAYANI1;

            icondata.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(m_iTrayAniFrame));
        }
        else
        {

            // update the Icon and tip text based on the current state .
            // Review - Currently don't have different Icons.

            if (m_iErrorCount > 0)
            {
                    icondata.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SYSTRAYERROR));
            }
            else if (m_iWarningCount > 0)
            {
                    icondata.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SYSTRAYWARNING));
            }
            else
            {
                    icondata.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SYSTRAYANI1));
            }
        }

        Assert(icondata.hIcon);

        TCHAR szBuf[MAX_STRING_RES];

         icondata.uFlags |= NIF_TIP;

        LoadString(g_hInst, IDS_SYNCMGRNAME, szBuf, ARRAY_SIZE(szBuf));
        lstrcpy(icondata.szTip,szBuf);


        dwReturn = Shell_NotifyIcon(m_fAddedIconToTray ? NIM_MODIFY : NIM_ADD ,&icondata);

        if (0 != dwReturn)
        {
            // possible for Shell_NotifyIcon(NIM_DELETE) to come in while still
            // in shell notify call so only set m_fAddedIconTray to true
            // if still have a shell tray icon after the call.

            if (m_fHasShellTrayIcon)
            {
                m_fAddedIconToTray = TRUE;
            }

            return TRUE;
        }
        else
        {
            // possible this failed becuase a Shell_DeleteIcon was in progress
            // which yields check if really have a Shell Tray and if not
            // reset the AddedIcon Flag
            
            if (!m_fHasShellTrayIcon)
            {
                m_fAddedIconToTray = FALSE;
            }

            return FALSE;
        }
    }

    return FALSE;
}

// given an ID sets the appropriate state.
BOOL CProgressDlg::SetButtonState(int nIDDlgItem,BOOL fEnabled)
{
BOOL fResult = FALSE;
HWND hwndCtrl = GetDlgItem(m_hwnd,nIDDlgItem);
HWND hwndFocus = NULL;

    if (hwndCtrl)
    {
        if (!fEnabled) // don't bother getting focus if not disabling.
        {
            hwndFocus = GetFocus();
        }

        fResult = EnableWindow(GetDlgItem(m_hwnd,nIDDlgItem),fEnabled);

        // if control had the focus. and now it doesn't then tab to the
        // next control
        if (hwndFocus == hwndCtrl
                && !fEnabled)
        {
            SetFocus(GetDlgItem(m_hwnd,IDC_DETAILS));
        }

    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::InitializeHwnd, private
//
//  Synopsis:   Called by WM_INIT.
//              m_hwnd member is not setup yet so refer to hwnd.
//
//              Sets up items specific to the UI
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::InitializeHwnd(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
HWND hwndList = GetDlgItem(hwnd,IDC_LISTBOXERROR);

    m_hwnd = hwnd; // setup the hwnd.

    m_fHwndRightToLeft = IsHwndRightToLeft(m_hwnd);

    // IF THE HWND IS RIGHT TO LEFT HIDE
    // SIZE CONTROL UNTIL RESIZE WORKS.

    if (m_fHwndRightToLeft)
    {
        ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESSRESIZESCROLLBAR),SW_HIDE);
    }
 
    InterlockedExchange(&m_lTimerSet, 0);

    if (m_fnResultsListBox =  (WNDPROC) GetWindowLongPtr(hwndList,GWLP_WNDPROC))
    {
        SetWindowLongPtr(hwndList, GWLP_WNDPROC, (LONG_PTR) ResultsListBoxWndProc);
    }


    m_cbNumDlgResizeItemsCollapsed = 0; // if fail then we don't resize anything.
    m_cbNumDlgResizeItemsExpanded = 0;

     // init resize items, be default nothing will move.
    m_ptMinimumDlgExpandedSize.x = 0;
    m_ptMinimumDlgExpandedSize.y = 0;
    m_cyCollapsed = 0;
    m_fExpanded = FALSE;

    m_fMaximized = FALSE;

    RECT rectParent;

    //Setup the toolbar pushpin
    InitializeToolbar(hwnd);

    if (GetClientRect(hwnd,&rectParent))
    {
    ULONG itemCount;
    DlgResizeList *pResizeList;


        // loop through resize list
        Assert(NUM_DLGRESIZEINFO_PROGRESS == (sizeof(g_ProgressResizeList)/sizeof(DlgResizeList)) );

        pResizeList = (DlgResizeList *) &g_ProgressResizeList;

        // loop through collapsed items
        for (itemCount = 0; itemCount < NUM_DLGRESIZEINFO_PROGRESS_COLLAPSED; ++itemCount)
        {
            if(InitResizeItem(pResizeList->iCtrlId,
                pResizeList->dwDlgResizeFlags,hwnd,&rectParent,&(m_dlgResizeInfo[m_cbNumDlgResizeItemsCollapsed])))
            {
                ++m_cbNumDlgResizeItemsCollapsed; // if fail then we don't resize anything.
                ++m_cbNumDlgResizeItemsExpanded;
            }

            ++pResizeList;
        }

        // loop through expanded items
        for (itemCount = NUM_DLGRESIZEINFO_PROGRESS_COLLAPSED;
                        itemCount < NUM_DLGRESIZEINFO_PROGRESS; ++itemCount)
        {
            if(InitResizeItem(pResizeList->iCtrlId,
                pResizeList->dwDlgResizeFlags,hwnd,&rectParent,&(m_dlgResizeInfo[m_cbNumDlgResizeItemsExpanded])))
            {
                ++m_cbNumDlgResizeItemsExpanded;
            }

            ++pResizeList;
        }

    }

    // store the current width and height as the
    // the min for expanded and as the current expanded height
    // if GetWindowRect fails not much we can do.
    if (GetWindowRect(hwnd,&m_rcDlg))
    {
    RECT rcSep;

        m_ptMinimumDlgExpandedSize.x = m_rcDlg.right - m_rcDlg.left;
        m_ptMinimumDlgExpandedSize.y = m_rcDlg.bottom - m_rcDlg.top;

        // use the separator position as the max height when collapsed
        if (GetWindowRect(GetDlgItem(hwnd, IDC_SP_SEPARATOR), &rcSep))
        {
            m_cyCollapsed = rcSep.top - m_rcDlg.top;
        }
    }


    if (InitializeTabs(hwnd)) // If these fail user just won't see probress..
    {
       InitializeUpdateList(hwnd);
       InitializeResultsList(hwnd);
    }

    // setup font for status text
    SetCtrlFont(GetDlgItem(hwnd,IDC_STATIC_WHATS_UPDATING),g_OSVersionInfo.dwPlatformId,g_LangIdSystem);
    SetCtrlFont(GetDlgItem(hwnd,IDC_STATIC_WHATS_UPDATING_INFO),g_OSVersionInfo.dwPlatformId,g_LangIdSystem);

    Animate_Open(GetDlgItem(hwnd,IDC_UPDATEAVI),MAKEINTRESOURCE(IDA_UPDATE));

    return TRUE; // return true if want to use default focus.
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::OnPaint()
//
//  PURPOSE:    Handle the WM_PAINT message dispatched from the dialog
//
//--------------------------------------------------------------------------------
void CProgressDlg::OnPaint(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    // if not currently animating and
    // have already added things to the dialog then draw the icons
    if (!(m_dwProgressFlags & PROGRESSFLAG_PROGRESSANIMATION)
        && !(m_dwProgressFlags & PROGRESSFLAG_NEWDIALOG) )
    {
    PAINTSTRUCT     ps;
    HDC hDC = BeginPaint(m_hwnd, &ps);

        if (hDC)
        {
        HICON hIcon;

            if (m_iErrorCount > 0)
            {
                hIcon = LoadIcon(NULL,IDI_ERROR);
            }
            else if (m_iWarningCount > 0)
            {
                hIcon = LoadIcon(NULL,IDI_WARNING);
            }
            else
            {
                hIcon = LoadIcon(NULL,IDI_INFORMATION);
            }

            if (hIcon)
            {
                DrawIcon(hDC, 7, 10,hIcon);
            }

            EndPaint(m_hwnd, &ps);
        }
    }

}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::RedrawIcon()
//
//  PURPOSE:    Clear/Draw the completed icon
//
//--------------------------------------------------------------------------------
BOOL CProgressDlg::RedrawIcon()
{
RECT rc;

    rc.left = 0;
    rc.top = 0;
    rc.right = 37;
    rc.bottom = 40;
    InvalidateRect(m_hwnd, &rc, TRUE);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnShowError, private
//
//  Synopsis:   Calls appropriate handlers ShowError method.
//
//  Arguments:  [wHandlerId] - Id of handler to call.
//              [hwndParent]- hwnd to use as the parent.
//              [ErrorId] - Identifies the Error.
//
//  Returns:    NOERROR - If ShowError was called
//              S_FALSE - if already in ShowErrorCall
//              appropriate error codes.
//
//  Modifies:
//
//  History:    04-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------


STDMETHODIMP CProgressDlg::OnShowError(HANDLERINFO *pHandlerId,HWND hwndParent,REFSYNCMGRERRORID ErrorID)
{
HRESULT hr = S_FALSE; // if don't call ShowError should return S_FALSE

    // only allow one ShowError Call at a time.
    if (!(m_dwProgressFlags & PROGRESSFLAG_INSHOWERRORSCALL)
        && !(m_dwProgressFlags &  PROGRESSFLAG_DEAD))
    {
        Assert(!(m_dwProgressFlags &  PROGRESSFLAG_SHOWERRORSCALLBACKCALLED));
        m_dwProgressFlags |= PROGRESSFLAG_INSHOWERRORSCALL;

        // hold alive - stick two references so we can always just release
        // at end of ShowError and ShowErrorCompleted methods.

        m_dwShowErrorRefCount += 2;
        AddRefProgressDialog();
        AddRefProgressDialog();

        hr = m_HndlrQueue->ShowError(pHandlerId,hwndParent,ErrorID);

        m_dwProgressFlags &= ~PROGRESSFLAG_INSHOWERRORSCALL;

       // if callback with an hresult or retry came in while we were
       // in our out call then post the transfer

       if (m_dwProgressFlags & PROGRESSFLAG_SHOWERRORSCALLBACKCALLED)
       {
            m_dwProgressFlags &= ~PROGRESSFLAG_SHOWERRORSCALLBACKCALLED;
            // need to sendmessage so queued up before release.
            SendMessage(m_hwnd,WM_PROGRESS_TRANSFERQUEUEDATA,(WPARAM) 0, (LPARAM) NULL);
       }

       --m_dwShowErrorRefCount;

       // count can go negative if handler calls completion routine on an error. if
        // this is the case just set it to zero
        if ( ((LONG) m_dwShowErrorRefCount) < 0)
        {
            AssertSz(0,"Negative ErrorCount");
            m_dwShowErrorRefCount = 0;
        }
        else
        {
            ReleaseProgressDialog(m_fForceClose);
        }


    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnResetKillHandlersTimers, private
//
//  Synopsis:   Called to reset the Kill Handlers
//              Timer. Called as a SendMessage From the handlrqueue
//              Cancel Call.
//              
//              !!!This funciton won't create the Timer if it doesn't
//              already exist by design since queue could be in a cancel
//              in a state we don't want to force kill as in the case
//              of an offIdle
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:
//
//  History:    19-Nov-1998       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnResetKillHandlersTimers(void)
{

    if (m_lTimerSet && !(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE))
    {

        // SetTimer with the same hwnd and Id will replace the existing.
        Assert(m_nKillHandlerTimeoutValue >= TIMERID_KILLHANDLERSMINTIME);

        SetTimer(m_hwnd,TIMERID_KILLHANDLERS,m_nKillHandlerTimeoutValue,NULL);
    }

}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::OnCancel()
//
//  PURPOSE:  handles cancelling of the dialog
//
//--------------------------------------------------------------------------------

void CProgressDlg::OnCancel(BOOL fOffIdle)
{
    // if dialog isn't dead and not in a showerrorcall then
    // already in a cancel
    // addref/release. if no more refs we will go away.

    if (!fOffIdle)
    {
        // set cancelpressed flag if the user invoked the cancel.
        m_dwProgressFlags |= PROGRESSFLAG_CANCELPRESSED;

        if (!m_lTimerSet)
        {
            InterlockedExchange(&m_lTimerSet, 1);
            Assert(m_nKillHandlerTimeoutValue >= TIMERID_KILLHANDLERSMINTIME);

            SetTimer(m_hwnd,TIMERID_KILLHANDLERS,m_nKillHandlerTimeoutValue,NULL);
        }

        if ( (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE)
                && !(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE) )
        {
            IdleCallback(STATE_USER_IDLE_END); // make sure offidle gets set if user presses cancel
        }
    }

    if (!(m_dwProgressFlags & PROGRESSFLAG_DEAD) && !m_dwShowErrorRefCount
        && !(m_dwProgressFlags & PROGRESSFLAG_INCANCELCALL)
        && !(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE))
    {
        // just cancel the queue, when items
        // come though cancel

       // it is possible that the dialog has already been removed from the
        // object list and the User hit stop again.

        SetProgressReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_CANCEL); // set so cleanup knows it was stopped by user..

        // if handlethread is in shutdown then just fall through


        if (!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP))
        {
            
            AddRefProgressDialog(); // hold dialog alive until cancel is complete
            
            // Get the state of the stop button before the call
            // because it could transition to close during the Canel
            BOOL fForceShutdown = !(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS);
                        
            m_dwProgressFlags |= PROGRESSFLAG_INCANCELCALL;
            if (m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS)
            {
                //
                // Replace the STOP button text with "Stopping" and 
                // disable the button.  This gives the user positive feedback
                // that the operation is being stopped.  We'll re-enable
                // the button whenever it's text is changed.
                //
                const HWND hwndStop = GetDlgItem(m_hwnd, IDSTOP);
                TCHAR szText[80];
                if (0 < LoadString(g_hInst, IDS_STOPPING, szText, ARRAY_SIZE(szText)))
                {
                    SetWindowText(hwndStop, szText);
                }
                EnableWindow(hwndStop, FALSE);
            }
            m_HndlrQueue->Cancel();
            m_dwProgressFlags &= ~PROGRESSFLAG_INCANCELCALL;


            // addref/release lifetime in case locked open.

            // OffIdle case: then do a soft release so dialog doesn't
            // go away.
            
            // Non Idle case:  Set the fForceClose After the call 
            // incase the pushpin change or errors came in during the Cancel
            
            ReleaseProgressDialog(fOffIdle ? m_fForceClose : fForceShutdown );
            
        }
        else
        {
            // set flag so shutdown knows a cancel was pressed
            m_dwProgressFlags |=  PROGRESSFLAG_CANCELWHILESHUTTINGDOWN;
        }
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::OnCommand()
//
//  PURPOSE:    Handle the various command messages dispatched from the dialog
//
//--------------------------------------------------------------------------------
void CProgressDlg::OnCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
WORD wID = LOWORD(wParam);  // item, control, or accelerator identifier
WORD wNotifyCode HIWORD(wParam);

    switch (wID)
    {
    case IDC_SKIP_BUTTON_MAIN:
        {
            if (m_pItemListView)
            {
                if (m_iProgressSelectedItem != -1)
                {
                    //Skip this item:
                   if (!(m_dwProgressFlags &  PROGRESSFLAG_DEAD))
                   {
                    LVHANDLERITEMBLOB lvHandlerItemBlob;

                        lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);

                        if (m_pItemListView->GetItemBlob(m_iProgressSelectedItem,
                                        (LPLVBLOB) &lvHandlerItemBlob,lvHandlerItemBlob.cbSize))
                        {
                            ++m_dwSetItemStateRefCount;
                            AddRefProgressDialog();

                            m_HndlrQueue->SkipItem(lvHandlerItemBlob.clsidServer,
                                                     lvHandlerItemBlob.ItemID);

                            --m_dwSetItemStateRefCount;
                            ReleaseProgressDialog(m_fForceClose);
                        }
                   }

                    //Disable the Skip button for this item
                   SetButtonState(IDC_SKIP_BUTTON_MAIN,FALSE);
                }

            }
        break;
        }
    case IDC_PROGRESS_OPTIONS_BUTTON_MAIN:
        {
            // !!! if skip has the focus set it to settings since while the
            // settings dialog is open the skip could go disabled.
            if (GetFocus() ==  GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN))
            {
                SetFocus(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN));
            }

            ShowOptionsDialog(m_hwnd);
        }
        break;
    case IDCANCEL:
        wNotifyCode = BN_CLICKED; // make sure notify code is clicked and fall through
    case IDSTOP:
        {
            if (BN_CLICKED == wNotifyCode)
            {
                OnCancel(FALSE);
            }
        }
        break;

    case IDC_PUSHPIN:
        {
            UINT state = (UINT)SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_GETSTATE,
                                            IDC_PUSHPIN, 0);

            m_fPushpin = state & TBSTATE_CHECKED;

            SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_CHANGEBITMAP,
                               IDC_PUSHPIN,
                               MAKELPARAM(m_fPushpin ? IMAGE_TACK_IN : IMAGE_TACK_OUT, 0));
                    
        }
        break;

    case IDC_DETAILS:
        ExpandCollapse(!m_fExpanded, FALSE);
        break;
    default:
        break;
    }

}



//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::ShowProgressTab(int iTab)
//
//  PURPOSE:
//
//--------------------------------------------------------------------------------

void CProgressDlg::ShowProgressTab(int iTab)
{
int nCmdUpdateTab;
int nCmdErrorTab;
int nCmdSettingsButton;
BOOL fIsItemWorking = FALSE;

    m_iTab = iTab;

    EnableWindow(GetDlgItem(m_hwnd, IDC_PROGRESS_TABS), m_fExpanded); // enable/disable tabs based on if dialog is expanded.
    EnableWindow(GetDlgItem(m_hwnd, IDC_TOOLBAR), m_fExpanded); // enable/disable  pushpin based on if dialog is expanded.

    nCmdUpdateTab = ((iTab == PROGRESS_TAB_UPDATE) && (m_fExpanded)) ? SW_SHOW: SW_HIDE;
    nCmdErrorTab = ((iTab == PROGRESS_TAB_ERRORS) && (m_fExpanded)) ? SW_SHOW: SW_HIDE;

    nCmdSettingsButton = ((iTab == PROGRESS_TAB_UPDATE) && (m_fExpanded)
                            && m_fSensInstalled) ? SW_SHOW: SW_HIDE;

    switch (iTab)
    {
        case PROGRESS_TAB_UPDATE:
            // Hide the error listview, show the tasks list
            ShowWindow(GetDlgItem(m_hwnd,IDC_LISTBOXERROR), nCmdErrorTab);
            TabCtrl_SetCurSel(m_hwndTabs, iTab);

            EnableWindow(GetDlgItem(m_hwnd,IDC_UPDATE_LIST),m_fExpanded);

            // only enable the skip button if there is a selection
            // and IsItemWorking()
            if (-1 != m_iProgressSelectedItem)
            {
                fIsItemWorking = IsItemWorking(m_iProgressSelectedItem);
            }

            EnableWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),m_fExpanded && fIsItemWorking);
            EnableWindow(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN),m_fExpanded && m_fSensInstalled);

            EnableWindow(GetDlgItem(m_hwnd,IDC_LISTBOXERROR), FALSE);


            ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_SKIP_TEXT),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN),nCmdSettingsButton);
            ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATE_LIST),nCmdUpdateTab);

            break;

        case PROGRESS_TAB_ERRORS:
                // Hide the update listview, show the error list
            ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATE_LIST),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_SKIP_TEXT),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),nCmdUpdateTab);
            ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN),nCmdSettingsButton);

            TabCtrl_SetCurSel(m_hwndTabs, iTab);

            EnableWindow(GetDlgItem(m_hwnd,IDC_UPDATE_LIST),FALSE);
            EnableWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),FALSE);
            EnableWindow(GetDlgItem(m_hwnd,IDC_PROGRESS_OPTIONS_BUTTON_MAIN),FALSE);
            EnableWindow(GetDlgItem(m_hwnd,IDC_LISTBOXERROR), m_fExpanded);

            ShowWindow(GetDlgItem(m_hwnd,IDC_LISTBOXERROR), nCmdErrorTab);
            break;
        default:
            AssertSz(0,"Unknown Tab");
            break;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::IsItemWorking, private
//
//  Synopsis:  Determines if Skip should be enabled
//              for the listViewItem;
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    12-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::IsItemWorking(int iListViewItem)
{
BOOL fItemWorking;
LPARAM ItemStatus;

    // lastest status is stored in the lParam of the ListBoxItem.
    if (!(m_pItemListView->GetItemlParam(iListViewItem,&ItemStatus)))
    {
        ItemStatus = SYNCMGRSTATUS_STOPPED;
    }

    fItemWorking = ( ItemStatus == SYNCMGRSTATUS_PENDING   ||
                                      ItemStatus == SYNCMGRSTATUS_UPDATING  ||
                                      ItemStatus == SYNCMGRSTATUS_PAUSED    ||
                                      ItemStatus == SYNCMGRSTATUS_RESUMING     );

    return fItemWorking;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnNotifyListViewEx, private
//
//  Synopsis:  Handles ListView Notifications
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CProgressDlg::OnNotifyListViewEx(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
int idCtrl = (int) wParam;
LPNMHDR pnmhdr = (LPNMHDR) lParam;

    if ( (IDC_UPDATE_LIST != idCtrl) || (NULL == m_pItemListView))
    {
        Assert(IDC_UPDATE_LIST == idCtrl);
        Assert(m_pItemListView);
        return 0;
    }

    switch (pnmhdr->code)
    {
        case LVN_ITEMCHANGED:
        {
        NM_LISTVIEW *pnmv = (NM_LISTVIEW FAR *) pnmhdr;

                if (pnmv->uChanged == LVIF_STATE)
                {
                    if (pnmv->uNewState & LVIS_SELECTED)
                    {
                        m_iProgressSelectedItem = ((LPNMLISTVIEW) pnmhdr)->iItem;


                        // see if an item is selected and set the properties
                        // button accordingly
                        SetButtonState(IDC_SKIP_BUTTON_MAIN,IsItemWorking(m_iProgressSelectedItem));
                    }
                    else if (pnmv->uOldState & LVIS_SELECTED)
                    {
                        // on deselect see if any other selected items and if not
                        // set skip to false.
                         if (0 == m_pItemListView->GetSelectedCount())
                         {
                            m_iProgressSelectedItem = -1;
                            SetButtonState(IDC_SKIP_BUTTON_MAIN,FALSE);
                         }
                    }
                }

                break;
            }
        default:
            break;
    }


    return 0;

}


//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
//
//  PURPOSE:    Handle the various notification messages dispatched from the dialog
//
//--------------------------------------------------------------------------------

LRESULT CProgressDlg::OnNotify(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
int idFrom = (int) wParam;
LPNMHDR pnmhdr = (LPNMHDR) lParam;

    // if notification for UpdateListPass it on.
    if ((IDC_UPDATE_LIST == idFrom) && m_pItemListView)
    {
        return m_pItemListView->OnNotify(pnmhdr);
    }
    else if (IDC_TOOLBAR == idFrom)
    {
        if (pnmhdr->code == NM_KEYDOWN)
        {
            if (((LPNMKEY) lParam)->nVKey == TEXT(' ') )
            {
                UINT state = (UINT)SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_GETSTATE, IDC_PUSHPIN, 0);

                state = state^TBSTATE_CHECKED;

                SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_SETSTATE, IDC_PUSHPIN, state);

                m_fPushpin = state & TBSTATE_CHECKED;
            
                SendDlgItemMessage(m_hwnd, IDC_TOOLBAR, TB_CHANGEBITMAP, IDC_PUSHPIN, 
                                   MAKELPARAM(m_fPushpin ? IMAGE_TACK_IN : IMAGE_TACK_OUT, 0));

            }
            
        }

    }
    else if (IDC_PROGRESS_TABS == idFrom)
    {

        switch (pnmhdr->code)
        {
            case TCN_SELCHANGE:
            {
                // Find out which tab is currently active
                m_iTab = TabCtrl_GetCurSel(GetDlgItem(m_hwnd, IDC_PROGRESS_TABS));
                if (-1 == m_iTab)
                {
                   break;
                }

                ShowProgressTab(m_iTab);
                break;
            }
            default:
                 break;
        }
    }

    return 0;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::UpdateProgressValues()
//
//  PURPOSE:    Updates the value of the ProgressBar
//
//--------------------------------------------------------------------------------


void CProgressDlg::UpdateProgressValues()
{
int iProgValue;
int iMaxValue;
int iNumItemsComplete;
int iNumItemsTotal;
TCHAR pszcomplete[MAX_STRING_RES];

    if (!m_pItemListView || !m_HndlrQueue)
    {
        return;
    }

    LoadString(g_hInst, IDS_NUM_ITEMS_COMPLETE, pszcomplete, ARRAY_SIZE(pszcomplete));

    if (NOERROR ==  m_HndlrQueue->GetProgressInfo(&iProgValue,&iMaxValue,&iNumItemsComplete,
                                            &iNumItemsTotal) )
    {
    HWND hwndProgress = GetDlgItem(m_hwnd,IDC_PROGRESSBAR);
    TCHAR szHowManBuf[50];

        if (hwndProgress)
        {
            SendMessage(hwndProgress,PBM_SETRANGE,0,MAKELPARAM(0, iMaxValue));
            SendMessage(hwndProgress,PBM_SETPOS,(WPARAM) iProgValue,0);
        }

        wsprintf(szHowManBuf,pszcomplete,iNumItemsComplete,iNumItemsTotal);
        Static_SetText(GetDlgItem(m_hwnd,IDC_STATIC_HOW_MANY_COMPLETE), szHowManBuf);
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::UpdateDetailsInfo(DWORD dwStatusType, HWND hwndList,
//                                                          int iItem, TCHAR *pszItemInfo)
//
//  PURPOSE:    provide info in the non-details progress view.
//
//--------------------------------------------------------------------------------
void CProgressDlg::UpdateDetailsInfo(DWORD dwStatusType,int iItem, TCHAR *pszItemInfo)
{
BOOL fNewNameField = TRUE;
BOOL fInfoField = FALSE;

TCHAR pszItemName[MAX_SYNCMGRITEMNAME + 1];
TCHAR pszFormatString[MAX_PATH + 1];
TCHAR pszNameString[MAX_PATH + 1];

    if ((m_dwLastStatusType == dwStatusType) && (m_iLastItem == iItem))
    {
        fNewNameField = FALSE;
    }

    //Strip the item info of white space
    if (pszItemInfo)
    {
        int i = lstrlen(pszItemInfo) - 1;

        while (i >=0 &&
                  (pszItemInfo[i] == TEXT(' ') || pszItemInfo[i] == TEXT('\n')
                            || pszItemInfo[i] == TEXT('\t')))
        {
                pszItemInfo[i] = NULL;
                i--;
        }
        if (i >= 0)
        {
                fInfoField = TRUE;
        }
    }


    // If Called Callback for an Item in Pending mode
    // but no item text don't bother updating the top display.

    if ((SYNCMGRSTATUS_PENDING == dwStatusType)
           && (FALSE == fInfoField))
    {
        return;
    }


    m_dwLastStatusType = dwStatusType;
    m_iLastItem = iItem;

    if (fNewNameField && m_pItemListView)
    {
            //Get the item name
        *pszItemName = NULL;

        m_pItemListView->GetItemText(iItem,PROGRESSLIST_NAMECOLUMN,
                        pszItemName, MAX_SYNCMGRITEMNAME);

        switch (dwStatusType)
        {
                case SYNCMGRSTATUS_STOPPED:
                {
                        LoadString(g_hInst, IDS_STOPPED_ITEM,pszFormatString, MAX_PATH);
                }
                break;
                case SYNCMGRSTATUS_SKIPPED:
                {
                        LoadString(g_hInst, IDS_SKIPPED_ITEM,pszFormatString, MAX_PATH);
                }
                break;
                case SYNCMGRSTATUS_PENDING:
                {
                        LoadString(g_hInst, IDS_PENDING_ITEM,pszFormatString, MAX_PATH);
                }
                break;
                case SYNCMGRSTATUS_UPDATING:
                {
                        LoadString(g_hInst, IDS_SYNCHRONIZING_ITEM,pszFormatString, MAX_PATH);
                }
                break;
                case SYNCMGRSTATUS_SUCCEEDED:
                {
                        LoadString(g_hInst, IDS_SUCCEEDED_ITEM,pszFormatString, MAX_PATH);
                }
                break;
                case SYNCMGRSTATUS_FAILED:
                {
                        LoadString(g_hInst, IDS_FAILED_ITEM,pszFormatString, MAX_PATH);
                }
                break;
                case SYNCMGRSTATUS_PAUSED:
                {
                        LoadString(g_hInst, IDS_PAUSED_ITEM,pszFormatString, MAX_PATH);
                }
                break;
                case SYNCMGRSTATUS_RESUMING:
                {
                        LoadString(g_hInst, IDS_RESUMING_ITEM,pszFormatString, MAX_PATH);
                }
                break;
                default:
                {
                    AssertSz(0,"Unknown Status Type");
                    lstrcpy(pszFormatString,TEXT("%ws"));
                }

                break;
        }

        wsprintf(pszNameString,pszFormatString, pszItemName);
        Static_SetText(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING), pszNameString);

    }

    // if don't have an info field but did update the name then set the info field
    // to blank
    if (fInfoField)
    {
        Static_SetText(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING_INFO), pszItemInfo);
    }
    else if (fNewNameField)
    {
        Static_SetText(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING_INFO), L"");
    }

}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::HandleProgressUpdate(HWND hwnd, WPARAM wParam,LPARAM lParam)
//
//  PURPOSE:    Handle the progress bar update for the progress dialog
//
//--------------------------------------------------------------------------------
void CProgressDlg::HandleProgressUpdate(HWND hwnd, WPARAM wParam,LPARAM lParam)
{
PROGRESSUPDATEDATA *progressData = (PROGRESSUPDATEDATA *) wParam;
SYNCMGRPROGRESSITEM *lpSyncProgressItem = (SYNCMGRPROGRESSITEM *) lParam;
LVHANDLERITEMBLOB lvHandlerItemBlob;
int iItem = -1;
BOOL fProgressItemChanged = FALSE;


    if (!m_pItemListView)
    {
        return;
    }

    // if emptyItem is in list View delete it.
    lvHandlerItemBlob.cbSize = sizeof(LVHANDLERITEMBLOB);
    lvHandlerItemBlob.clsidServer = (progressData->clsidHandler);
    lvHandlerItemBlob.ItemID = (progressData->ItemID);


    iItem = m_pItemListView->FindItemFromBlob((LPLVBLOB) &lvHandlerItemBlob);

    if (-1 == iItem)
    {
        AssertSz(0,"Progress Update on Item not in ListView");
        return;
    }

    if (SYNCMGRPROGRESSITEM_STATUSTYPE & lpSyncProgressItem->mask)
    {
        if (lpSyncProgressItem->dwStatusType <= SYNCMGRSTATUS_RESUMING) 
        {

            // update the listview items lParam
            m_pItemListView->SetItemlParam(iItem,lpSyncProgressItem->dwStatusType);

            m_pItemListView->SetItemText(iItem,PROGRESSLIST_STATUSCOLUMN,
                                         m_pszStatusText[lpSyncProgressItem->dwStatusType]);

            //Update Skip button if this item is selected
            if (m_iProgressSelectedItem == iItem)
            {
            BOOL fItemComplete = ( (lpSyncProgressItem->dwStatusType == SYNCMGRSTATUS_SUCCEEDED) ||
                                                       (lpSyncProgressItem->dwStatusType == SYNCMGRSTATUS_FAILED) ||
                                                       (lpSyncProgressItem->dwStatusType == SYNCMGRSTATUS_SKIPPED) ||
                                                       (lpSyncProgressItem->dwStatusType == SYNCMGRSTATUS_STOPPED)   );

                EnableWindow(GetDlgItem(m_hwnd,IDC_SKIP_BUTTON_MAIN),!fItemComplete);
            }
        }

    }

    if (SYNCMGRPROGRESSITEM_STATUSTEXT & lpSyncProgressItem->mask )
    {
    #define MAXDISPLAYBUF 256
    TCHAR displaybuf[MAXDISPLAYBUF]; // make a local copy of ths display buf

            *displaybuf = NULL;

            if (NULL != lpSyncProgressItem->lpcStatusText)
            {
                lstrcpyn(displaybuf,lpSyncProgressItem->lpcStatusText,MAXDISPLAYBUF);

                // make sure last char is a null in case handler passed us a large string.
                Assert(MAXDISPLAYBUF > 0);

                TCHAR *pEndBuf = displaybuf + MAXDISPLAYBUF -1;
                *pEndBuf = NULL;
            }

            if (NULL != displaybuf)
            {
                m_pItemListView->SetItemText(iItem,PROGRESSLIST_INFOCOLUMN,displaybuf);
            }


            LPARAM ItemStatus;
            if (!(SYNCMGRPROGRESSITEM_STATUSTYPE & lpSyncProgressItem->mask))
            {
                if (!(m_pItemListView->GetItemlParam(iItem,&ItemStatus)))
                {
                    AssertSz(0,"failed to get item lParam");
                    ItemStatus = SYNCMGRSTATUS_STOPPED;
                }
            }
            else
            {
                    ItemStatus = lpSyncProgressItem->dwStatusType;
            }

            Assert(ItemStatus == ((LPARAM) (DWORD) ItemStatus));

            UpdateDetailsInfo( (DWORD) ItemStatus,iItem, displaybuf);
    }


    // now update the items progress value information
    if (S_OK == m_HndlrQueue->SetItemProgressInfo(progressData->pHandlerID,
                        progressData->wItemId,
                        lpSyncProgressItem,&fProgressItemChanged))
    {

        // recalcing the progress bar and numItems completed values 
        // can become expensive with a large amount of items so it callback
        // was called but didn't change status or min/max of the item
        // don't bother updating the progress values.
        if (fProgressItemChanged)
        {
            UpdateProgressValues();
        }
    }
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::AddListData(LBDATA *pData,int iNumChars, HWND hwndList)
//
//  PURPOSE:    Handle the adding item data to the list for the results pane
//
//--------------------------------------------------------------------------------
void CProgressDlg::AddListData(LBDATA *pData, int iNumChars, HWND hwndList)
{
    // Save current item in global for use by MeasureItem handler

    Assert(NULL == m_CurrentListEntry); // catch any recursion case.

    m_CurrentListEntry = pData;
    // ... add the string first...
    //the text is freed by the list box

    int iItem = ListBox_AddString( hwndList, pData->pszText);
    
     // (Note that the WM_MEASUREITEM is sent at this point)
    // ...now attach the data.


    ListBox_SetItemData( hwndList, iItem, pData);

    m_CurrentListEntry = NULL;

    // pData is freed by the list box

}
//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::HandleLogError(HWND hwnd, WORD pHandlerID,MSGLogErrors *msgLogErrors)
//
//  PURPOSE:    Handle the error logging tab for the progress dialog
//
//--------------------------------------------------------------------------------
void CProgressDlg::HandleLogError(HWND hwnd, HANDLERINFO *pHandlerID,MSGLogErrors *lpmsgLogErrors)
{
LBDATA          *pData = NULL;
INT             iNumChars;
TCHAR           szBuffer[MAX_STRING_RES]; // buffer used for loading string resources
HWND            hwndList;

    hwndList = GetDlgItem(m_hwnd,IDC_LISTBOXERROR);
    if (!hwndList)
    {
        return;
    }

    //Remove the "No Errors" when the first error is encountered
    if (++m_iResultCount == 0)
    {
        ListBox_ResetContent(hwndList);
    }


    // determine if handlerId and ItemId are valid.ItemID
    // if handlerId isn't valid we don't bother with the ItemId

    SYNCMGRHANDLERINFO SyncMgrHandlerInfo;
    SYNCMGRITEM offlineItem;
    DWORD cbItemLen = 0;
    DWORD cbHandlerLen = 0;
    UINT uIDResource;

    // preset both to NULL
    *(SyncMgrHandlerInfo.wszHandlerName) = NULL;
    *(offlineItem.wszItemName) = NULL;

    // if can't get the ParentInfo then don't add the Item
    // pHandlerId can be NULL if we logged the Error Ourselves.
    if (pHandlerID && m_HndlrQueue
        && (NOERROR == m_HndlrQueue->GetHandlerInfo(pHandlerID,&SyncMgrHandlerInfo)))
    {

        cbHandlerLen = lstrlen(SyncMgrHandlerInfo.wszHandlerName);

        // now see if we can get the itemName.
        if (lpmsgLogErrors->mask & SYNCMGRLOGERROR_ITEMID)
        {
        BOOL fHiddenItem;
        CLSID clsidDataHandler;

            if (NOERROR == m_HndlrQueue->GetItemDataAtIndex(pHandlerID,
                                        lpmsgLogErrors->ItemID,
				        &clsidDataHandler,&offlineItem,&fHiddenItem) )
            {
                cbItemLen = lstrlen(offlineItem.wszItemName);
            }

        }
    }

    // note: handlerName can be an empty string even if GetHandlerInfo did not fail and we
    // can still have an Item so need to do the right thing.

    //  cases
    //  valid handler and ItemID in LogError
    // 1) <icon> <handler name> <(item name)>: <message> (valid handler and ItemID in LogError)
    // 2) <icon> <(item name)>: <message>  handler name NULL .
    // 3) <icon> <handler name>: <message> only valid handler in LogError
    // 4) <icon> <message> (handler invalid or mobsync error in LogError)
    // => three different format strings
    //  1,2     - "%ws (%ws): %ws"    // valid item
    //  3       - "%ws: %ws"          // only valid handler.
    //  4       - "%ws"               // no handler or item


    if (cbItemLen)
    {
        uIDResource = IDS_LOGERRORWITHITEMID;
    }
    else if (cbHandlerLen)
    {
        uIDResource = IDS_LOGERRORNOITEMID;
    }
    else
    {
        uIDResource = IDS_LOGERRORNOHANDLER;
    }

    if (0 == LoadString(g_hInst, uIDResource, szBuffer, ARRAY_SIZE(szBuffer)))
    {
        // if couldn't loadstring then set to empty string so an empty string
        // gets logged. If string is truncated will just print the trucated string.
        *szBuffer = NULL;
    }
    // get the number of characters we need to allocate for
    iNumChars = lstrlen(lpmsgLogErrors->lpcErrorText)
                    + cbHandlerLen
                    + cbItemLen
                    + lstrlen(szBuffer);

    // Allocate a struct for the item data
    if (!(pData = (LBDATA *) ALLOC(sizeof(LBDATA) + ((iNumChars + 1)*sizeof(TCHAR)))))
    {
        return;
    }

    // now format the string using the same logic as used to load
    // the proper resource
    if (cbItemLen)
    {
        wsprintf(pData->pszText,szBuffer,SyncMgrHandlerInfo.wszHandlerName,
                                offlineItem.wszItemName,lpmsgLogErrors->lpcErrorText);
    }
    else if (cbHandlerLen)
    {
        wsprintf(pData->pszText,szBuffer,SyncMgrHandlerInfo.wszHandlerName,
                                lpmsgLogErrors->lpcErrorText);
    }
    else
    {
        wsprintf(pData->pszText,szBuffer,lpmsgLogErrors->lpcErrorText);
    }

    // error text is not a jump but has same ErrorID
    pData->fIsJump = FALSE;
    pData->fTextRectValid = FALSE;
    pData->ErrorID = lpmsgLogErrors->ErrorID;
    pData->dwErrorLevel = lpmsgLogErrors->dwErrorLevel;
    pData->pHandlerID = pHandlerID;
    pData->fHasBeenClicked = FALSE;
    pData->fAddLineSpacingAtEnd = FALSE;

    //insert the icon
    //ToDo:Add client customizable icons?
    switch (lpmsgLogErrors->dwErrorLevel)
    {
        case SYNCMGRLOGLEVEL_INFORMATION:
                pData->IconIndex = m_ErrorImages[ErrorImage_Information];
        break;
        case SYNCMGRLOGLEVEL_WARNING:
                ++m_iWarningCount;
                pData->IconIndex = m_ErrorImages[ErrorImage_Warning];
        break;

        case SYNCMGRLOGLEVEL_ERROR:
        default:
                // if an error occurs we want to keep the dialog alive
                ++m_iErrorCount;
                pData->IconIndex = m_ErrorImages[ErrorImage_Error];
        break;
    }

    if (!lpmsgLogErrors->fHasErrorJumps)
    {
         pData->fAddLineSpacingAtEnd = TRUE;
    }

    // Add the item data
    AddListData(pData, (iNumChars)*sizeof(TCHAR), hwndList);
    if (lpmsgLogErrors->fHasErrorJumps)
    {
        //This is make the "For more info" apprear closer,
        //More associated with the item it corresponds to

        // Allocate a struct for the item data
        LoadString(g_hInst, IDS_JUMPTEXT, szBuffer, ARRAY_SIZE(szBuffer));

        // Review, why not strlen instead of total size of szBuffer.
        if (!(pData = (LBDATA *) ALLOC(sizeof(LBDATA) + sizeof(szBuffer))))
        {
            return;
        }

        pData->IconIndex = -1;

        // we always set ErrorID to GUID_NULL if one wasn't given
        // and fHasErrorJumpst to false.
        pData->fIsJump = lpmsgLogErrors->fHasErrorJumps;
        pData->fTextRectValid = FALSE;
        pData->ErrorID = lpmsgLogErrors->ErrorID;
        pData->dwErrorLevel = lpmsgLogErrors->dwErrorLevel;
        pData->pHandlerID = pHandlerID;
        pData->fHasBeenClicked = FALSE;
        pData->fAddLineSpacingAtEnd = TRUE; // always put space after


        lstrcpy(pData->pszText,szBuffer);

        AddListData(pData, sizeof(szBuffer), hwndList);
    }


    // new item could have caused the Scrollbar to be drawn. Need to
    // recalc listbox
    OnProgressResultsSize(m_hwnd,this,WM_SIZE,0,0);


    // if tray icon is shown and not currently syncing any items
    // make sure it has the most up to date info. if syncing just
    // let the timer.

    if (!(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS))
    {
        UpdateTrayIcon();
    }

    return;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::HandleDeleteLogError(HWND hwnds)
//
//  PURPOSE:    Deletes matching errors that have been logged.
//
//--------------------------------------------------------------------------------

void  CProgressDlg::HandleDeleteLogError(HWND hwnd,MSGDeleteLogErrors *pDeleteLogError)
{
HWND hwndList = GetDlgItem(m_hwnd,IDC_LISTBOXERROR);
int  iItemCount;
LBDATA  *pData = NULL;


    if (NULL == hwndList)
        return;

    iItemCount  = ListBox_GetCount(hwndList);

    // loop through the logged errors finding any matches.
    // if the passed in ErrorID is GUID_NULL then delete all errors associated with this
    // handler.
    while(iItemCount--)
    {
        if (pData = (LBDATA *) ListBox_GetItemData(hwndList,iItemCount))
        {

            if ((pData->pHandlerID == pDeleteLogError->pHandlerId)
                && ( (pData->ErrorID == pDeleteLogError->ErrorID)
                    || (GUID_NULL == pDeleteLogError->ErrorID) )
                )
            {
                if ( !pData->fIsJump )
                {
                    //
                    // Decrement count for non-jump items only to avoid
                    // double decrements.
                    //

                    m_iResultCount--;

                    if ( pData->dwErrorLevel == SYNCMGRLOGLEVEL_WARNING )
                    {
                        Assert( m_iWarningCount > 0 );
                        m_iWarningCount--;
                    }
                    else if ( pData->dwErrorLevel == SYNCMGRLOGLEVEL_ERROR )
                    {
                        Assert( m_iErrorCount > 0 );
                        m_iErrorCount--;
                    }
                }

                ListBox_DeleteString(hwndList,iItemCount);
            }

        }

    }

    //
    // If all items have been removed, add default no-error item
    //
    iItemCount = ListBox_GetCount(hwndList);

    if ( iItemCount == 0 )
    {
        m_iResultCount = -1;

        TCHAR pszError[MAX_STRING_RES];
        LoadString(g_hInst, IDS_NOERRORSREPORTED, pszError, ARRAY_SIZE(pszError));

        //
        // Allocate a struct for the item data
        //
        LBDATA  *pData = NULL;
        if (!(pData = (LBDATA *) ALLOC(sizeof(LBDATA) + sizeof(pszError))))
            return;

        pData->fIsJump = FALSE;
        pData->fTextRectValid = FALSE;
        pData->fHasBeenClicked = FALSE;
        pData->fAddLineSpacingAtEnd = FALSE;
        pData->ErrorID = GUID_NULL;
        pData->dwErrorLevel = SYNCMGRLOGLEVEL_INFORMATION;
        pData->pHandlerID = 0;
        lstrcpy(pData->pszText, pszError);
        pData->IconIndex = m_ErrorImages[ErrorImage_Information];

        AddListData(pData, sizeof(pszError), hwndList);
    }

    // recalc listbox heights to accomodate the new value.
    OnProgressResultsSize(m_hwnd,this,WM_SIZE,0,0);

    // if tray icon is shown and not currently syncing any items
    // make sure it has the most up to date info. if syncing just
    // let the timer.

    if (!(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS))
        UpdateTrayIcon();
}


//--------------------------------------------------------------------------------
//
//  FUNCTION:   BOOL CProgressDlg::ShowCompletedProgress(BOOL fComplete)
//
//  PURPOSE:   Show the dialog in the completed state
//
//--------------------------------------------------------------------------------
BOOL CProgressDlg::ShowCompletedProgress(BOOL fComplete,BOOL fDialogIsLocked)
{

    TCHAR szBuf[MAX_STRING_RES];

        LoadString(g_hInst, fComplete? IDS_PROGRESSCOMPLETETITLE : IDS_PROGRESSWORKINGTITLE,
                                        szBuf,
                    ARRAY_SIZE(szBuf));

        SetWindowText(m_hwnd, szBuf);

        if (fComplete)
        {
                ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATEAVI), SW_HIDE);
                ShowWindow(GetDlgItem(m_hwnd,IDC_FOLDER1), SW_HIDE);
                ShowWindow(GetDlgItem(m_hwnd,IDC_FOLDER2), SW_HIDE);
                ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING), SW_HIDE);
                ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING_INFO), SW_HIDE);
                ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESSBAR), SW_HIDE);
                ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_HOW_MANY_COMPLETE), SW_HIDE);

                if (m_iErrorCount > 0 )
                {
                        LoadString(g_hInst, IDS_PROGRESSCOMPLETEERROR, szBuf, ARRAY_SIZE(szBuf));
                }
                else if (m_iWarningCount > 0 )
                {
                        LoadString(g_hInst, IDS_PROGRESSCOMPLETEWARNING, szBuf, ARRAY_SIZE(szBuf));
                }
                else
                {
                        LoadString(g_hInst, IDS_PROGRESSCOMPLETEOK,     szBuf, ARRAY_SIZE(szBuf));

                }

                SetDlgItemText(m_hwnd, IDC_RESULTTEXT, szBuf);
				ShowWindow(GetDlgItem(m_hwnd,IDC_RESULTTEXT), SW_SHOW);

		//Change the Stop to "Close" if the dialog is going to be
                // remained open

                if (fDialogIsLocked)
                {
		    LoadString(g_hInst, IDS_CLOSE, szBuf, ARRAY_SIZE(szBuf));
		    SetWindowText(GetDlgItem(m_hwnd,IDSTOP), szBuf);      
                    EnableWindow(GetDlgItem(m_hwnd,IDSTOP), TRUE);
                }

        }
        else
        {
                ShowWindow(GetDlgItem(m_hwnd,IDC_RESULTTEXT), SW_HIDE);

                ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATEAVI), SW_SHOW);
                ShowWindow(GetDlgItem(m_hwnd,IDC_FOLDER1), SW_SHOW);
                ShowWindow(GetDlgItem(m_hwnd,IDC_FOLDER2), SW_SHOW);
                ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING), SW_SHOW);
                ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_WHATS_UPDATING_INFO), SW_SHOW);
                ShowWindow(GetDlgItem(m_hwnd,IDC_PROGRESSBAR), SW_SHOW);
                ShowWindow(GetDlgItem(m_hwnd,IDC_STATIC_HOW_MANY_COMPLETE), SW_SHOW);

                //Change the "Close" to "Stop"
		LoadString(g_hInst, IDS_STOP, szBuf, ARRAY_SIZE(szBuf));
		SetWindowText(GetDlgItem(m_hwnd,IDSTOP), szBuf);
                EnableWindow(GetDlgItem(m_hwnd,IDSTOP), TRUE);
        }

        RedrawIcon();

        return TRUE;

}

//--------------------------------------------------------------------------------
//
//  Function:   DoSyncTask
//
//  Synopsis:   Drives the handlers actual synchronization routines
//
//--------------------------------------------------------------------------------

void CProgressDlg::DoSyncTask(HWND hwnd)
{
HANDLERINFO *pHandlerID;
ULONG cDlgRefs;
BOOL fRepostedStart = FALSE; // set if posted message to ourselves.
CLSID pHandlerClsid;

    Assert(!(m_dwProgressFlags &  PROGRESSFLAG_DEAD));

    ++m_dwHandleThreadNestcount;

    // if handlerNestCount is > 1 which it can on a transfer
    // or when multiple items are going even on an error
    // if this is the case then just return
    if (m_dwHandleThreadNestcount > 1)
    {
        Assert(1 == m_dwHandleThreadNestcount);
        m_dwHandleThreadNestcount--;
        return;
    }


    // review - order should be set  inhandleroutcall
    // an then reset flags for completion and transfers.

    // reset callback flag so receive another one if
    // message comes in
    m_dwProgressFlags &= ~PROGRESSFLAG_CALLBACKPOSTED;

    // first thing through make sure all our state is setup.
    // set the syncing flag
    m_dwProgressFlags |= PROGRESSFLAG_SYNCINGITEMS;

    // set our Call flag so callback knows not to post to us
    // if we are handling call
    Assert(!(m_dwProgressFlags & PROGRESSFLAG_INHANDLEROUTCALL));
    m_dwProgressFlags |= PROGRESSFLAG_INHANDLEROUTCALL;
    m_dwProgressFlags &= ~PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL; // reset completion routine
    m_dwProgressFlags &= ~PROGRESSFLAG_NEWITEMSINQUEUE;  // reset new items in queue flag
    m_dwProgressFlags &=  ~PROGRESSFLAG_STARTPROGRESSPOSTED; // reset post flag.

    if (!(m_dwProgressFlags & PROGRESSFLAG_IDLENETWORKTIMER))
    {

        m_dwProgressFlags |= PROGRESSFLAG_IDLENETWORKTIMER;
        // reset network idle initially to keep hangup from happening and setup a timer
        // to keep resetting the idle until the sync is complete.
        ResetNetworkIdle();
        SetTimer(m_hwnd,TIMERID_NOIDLEHANGUP,NOIDLEHANGUP_REFRESHRATE,NULL);
    }

    UpdateProgressValues();

    if (m_clsid != GUID_PROGRESSDLGIDLE)
    {

        // if there is a server we are currently synchronizing but out count
        // is zero then reset to GUID_NULL else use our clsidHandlerInSync
        // so next handler matches the one we are currently syncing.

        if (0 == m_dwHandlerOutCallCount) // if no outcalls we don't care what handler gets matched.
        {
            m_clsidHandlerInSync = GUID_NULL;
        }

        // find the next set of items that match our criteria by seeing
        // if there is any handler that matches out guid (if guid_null just
        // matches first item in state

        // then loop through all handlers matching the guid
        // in the same state.

        // see if there are any items that need PrepareForSyncCalled on them
        if (NOERROR == m_HndlrQueue->FindFirstHandlerInState(
                                    HANDLERSTATE_PREPAREFORSYNC,m_clsidHandlerInSync,
                                    &pHandlerID,&m_clsidHandlerInSync))
        {
            ++m_dwHandlerOutCallCount;
            ++m_dwPrepareForSyncOutCallCount;
           m_HndlrQueue->PrepareForSync(pHandlerID,hwnd);

           // see if any other handlers that match the clsid and also call their
           // PrepareForSync methods.

            while (NOERROR == m_HndlrQueue->FindFirstHandlerInState(
                                    HANDLERSTATE_PREPAREFORSYNC,m_clsidHandlerInSync,
                                    &pHandlerID,&m_clsidHandlerInSync))
            {
                ++m_dwHandlerOutCallCount;
                ++m_dwPrepareForSyncOutCallCount;
                m_HndlrQueue->PrepareForSync(pHandlerID,hwnd);
            }
        }
        else if ( (0 == m_dwPrepareForSyncOutCallCount)
                    && (NOERROR == m_HndlrQueue->FindFirstHandlerInState(
                                    HANDLERSTATE_SYNCHRONIZE,m_clsidHandlerInSync,&pHandlerID,
                                    &m_clsidHandlerInSync)) )
        {
            // no prepareforsync so if there aren't any more handlers in prerpareforsync
            // calls kick off someones synchronize. see if any synchronize methods.
            ++m_dwHandlerOutCallCount;
            ++m_dwSynchronizeOutCallCount;
            m_HndlrQueue->Synchronize(pHandlerID,hwnd);

            // see if any other handlers that match the clsid and also call their
           // synchronize methods.

            while (NOERROR == m_HndlrQueue->FindFirstHandlerInState(
                                    HANDLERSTATE_SYNCHRONIZE,m_clsidHandlerInSync,
                                    &pHandlerID,&m_clsidHandlerInSync))
            {
                ++m_dwHandlerOutCallCount;
                ++m_dwSynchronizeOutCallCount;
                m_HndlrQueue->Synchronize(pHandlerID,hwnd);
            }
        }

        // set noMoreItemsToSync flag if
    }
    else
    {
        // for idle queue synchronize any items first since
        // no need to call prepareforsync until we have too and don't kick off more than
        // one at a time.

        // a transfer can come in while processing an out call should be the only time
        // this should happen. This can happen on Idle if in a Retry Error when the next
        // idle fires.

        // Assert(0 == m_dwHandlerOutCallCount);

        // not doing anything while still in an out call emulates the old behavior of
        // only ever doing one handler at a time.

        if (0 == m_dwHandlerOutCallCount)
        {
            if (NOERROR == m_HndlrQueue->FindFirstHandlerInState(
                                        HANDLERSTATE_SYNCHRONIZE,GUID_NULL,&pHandlerID,&pHandlerClsid))
            {
                ++m_dwHandlerOutCallCount;
                ++m_dwSynchronizeOutCallCount;
                m_HndlrQueue->Synchronize(pHandlerID,hwnd);
            }
            else if (NOERROR == m_HndlrQueue->FindFirstHandlerInState(
                                        HANDLERSTATE_PREPAREFORSYNC,GUID_NULL,&pHandlerID,&pHandlerClsid))
            {

                 // msidle only allows one idle registration at a time.
                // reset idle in case last handler we called took it away from us

                if (m_pSyncMgrIdle && 
                        (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE))
                {

                    // !!!don't reset the registered if idle flag will do this
                    //  when all handlers are completed.
                    if (!(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE))
                    {
                        m_pSyncMgrIdle->ReRegisterIdleDetection(this); // reregisterIdle in case handle overrode it.
                        m_pSyncMgrIdle->CheckForIdle();
                    }
                }



                ++m_dwHandlerOutCallCount;
                ++m_dwPrepareForSyncOutCallCount;
               m_HndlrQueue->PrepareForSync(pHandlerID,hwnd);
            }
            else
            {
                // even if nothing to do need to call
                // reset idle hack
                if (m_pSyncMgrIdle && !(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE)
                    && (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE))
                {

    
                    m_pSyncMgrIdle->ReRegisterIdleDetection(this); // reregisterIdle in case handle overrode it.
                    m_pSyncMgrIdle->CheckForIdle();
                }

            }
        }

    }


    UpdateProgressValues(); // update progress values when come out of calls.

    // no longer in any out calls, reset our flag and see if a completion
    // routine came in or items were added to the queue during our out call
    m_dwProgressFlags &= ~PROGRESSFLAG_INHANDLEROUTCALL;

    if ((PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL & m_dwProgressFlags)
        || (PROGRESSFLAG_NEWITEMSINQUEUE & m_dwProgressFlags) )
    {
        Assert(!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)); // shouldn't get here if shutting down.

        fRepostedStart = TRUE;

        if (!(m_dwProgressFlags &  PROGRESSFLAG_STARTPROGRESSPOSTED))
        {
            m_dwProgressFlags |=  PROGRESSFLAG_STARTPROGRESSPOSTED;
            PostMessage(m_hwnd,WM_PROGRESS_STARTPROGRESS,0,0);
        }
    }

    // if no more items to synchronize and all synchronizations
    // are done and we are currently syncing items then shut things down.
    // if user is currently in a cancel call then don't start shutting
    Assert(!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)); // assert if in shutdown this loop shouldn't get called.

    if (!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
        && (0 == m_dwHandlerOutCallCount) && !(fRepostedStart)
            && (m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS))
    {
    BOOL fTransferAddRef;
    BOOL fOffIdleBeforeShutDown = (m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE);
    BOOL fKeepDialogAlive;


        // if no out calls shouldn't be any call specific out calls either

        Assert(0 == m_dwPrepareForSyncOutCallCount);
        Assert(0 == m_dwSynchronizeOutCallCount);

        m_dwProgressFlags |= PROGRESSFLAG_SHUTTINGDOWNLOOP;
        // reset newItemsInQueue so know for sure it got set while we
        // yielded in cleanup calls.
        m_dwProgressFlags &= ~PROGRESSFLAG_NEWITEMSINQUEUE;

        // treat progress as one long out call
        Assert(!(m_dwProgressFlags & PROGRESSFLAG_INHANDLEROUTCALL));
        m_dwProgressFlags |= PROGRESSFLAG_INHANDLEROUTCALL;
        m_dwProgressFlags &= ~PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL; // reset completion routine.


        // reset PROGRESSFLAG_TRANSFERADDREF flag but don't release
        // if another transfer happens during this shutdown then the transfer
        // will reset the flag and put and addref on. need to store state
        // in case get this shutdown routine called twice without another
        // transfer we don't call too many releases.

        fTransferAddRef = m_dwProgressFlags & PROGRESSFLAG_TRANSFERADDREF;
        Assert(fTransferAddRef); // should always have a transfer at this statge.
        m_dwProgressFlags &= ~PROGRESSFLAG_TRANSFERADDREF;

        SetProgressReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_OK);

        UpdateProgressValues();
        m_HndlrQueue->RemoveFinishedProgressItems(); // let the queue know to reset the progress bar

        // if not in a cancel or setIetmstatus go ahead and release handlers
        // and kill the terminate timer.
        // review if there is a better opportunity to do cleanup.
        if (!(m_dwProgressFlags & PROGRESSFLAG_INCANCELCALL)
            && !(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE)
            && (0 == m_dwSetItemStateRefCount) )
        {
            if (m_lTimerSet)
            {
                 InterlockedExchange(&m_lTimerSet, 0);
                 KillTimer(m_hwnd,TIMERID_KILLHANDLERS);
            }
 
            m_HndlrQueue->ReleaseCompletedHandlers(); // munge the queue.
        }

        fKeepDialogAlive = KeepProgressAlive(); // determine if progress should stick around

        if ((m_dwProgressFlags & PROGRESSFLAG_PROGRESSANIMATION))
         {
            m_dwProgressFlags &= ~PROGRESSFLAG_PROGRESSANIMATION;
            KillTimer(m_hwnd,TIMERID_TRAYANIMATION);

            Animate_Stop(GetDlgItem(m_hwnd,IDC_UPDATEAVI));
            ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATEAVI),SW_HIDE);
            ShowCompletedProgress(TRUE /* fComplete */ ,fKeepDialogAlive /* fDialogIsLocked */);
         }

        UpdateTrayIcon(); // if Icon is showing make sure we have the uptodate one.

        ConnectObj_CloseConnections(); // Close any connections we held open during the Sync.

        if (m_dwProgressFlags & PROGRESSFLAG_IDLENETWORKTIMER)
        {
            m_dwProgressFlags &= ~PROGRESSFLAG_IDLENETWORKTIMER;
            KillTimer(m_hwnd,TIMERID_NOIDLEHANGUP); // don't need to keep connection open.
        }

        // make sure any previous locks on dialog are removed
        // before going into wait logic. This can happen in the case of a retry.
        LockProgressDialog(m_clsid,this,FALSE);

        // if there are no items to lock the progress open and the
        // force close flag isn't set wait in a loop
        // for two seconds
        if (!(fKeepDialogAlive) && (FALSE == m_fForceClose))
        {
        HANDLE hTimer =  CreateEvent(NULL,TRUE,FALSE,NULL);

            // should use Create/SetWaitable timer to accomplish this but these
            // functions aren't available on Win9x yet.
            if (hTimer)
            {
                // sit in loop until timer event sets it.
                DoModalLoop(hTimer,NULL,m_hwnd,TRUE,1000*2);
                CloseHandle(hTimer);
            }
        }
        else
        {
              LockProgressDialog(m_clsid,this,TRUE);
              ExpandCollapse(TRUE,FALSE); // make sure the dialog is expanded.
              ShowProgressTab(PROGRESS_TAB_ERRORS);
        }

        //if the user hit the pushpin after we started the 2 second delay
        if ((m_fPushpin) && !(fKeepDialogAlive))
        {
	      ShowCompletedProgress(TRUE /* fComplete */,TRUE /* fDialogIsLocked */);
              LockProgressDialog(m_clsid,this,TRUE);
        }

        // if this is an idle dialog handle the logic for
        // either releasing the IdleLock or reregistering.
        if (m_pSyncMgrIdle)
        {

            // if we have already received an OffIdle and not
            // still handling the offidle then release the Idle Lock.
            if ( (m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE)
               && !(m_dwProgressFlags &  PROGRESSFLAG_INOFFIDLE)) 
            {

                // Release our IdleLock so TS can fire use again even if progress
                // sticks around.
                ReleaseIdleLock();
            }
            else if ( (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE)
                    && !(m_dwProgressFlags & PROGRESSFLAG_RECEIVEDOFFIDLE) )
            {

                // if have registere for idle but haven't seen it yet then
                // we want to stay alive.

                // if we aren't suppose to repeat idle or
                // user has maximized the window then just call idle as if
                // an OffIdle occured. Mostly done as a safety precaution
                // in case someone has registered for Idle with MSIdle in 
                // our process space so we fail to receive the true offidle

                if (!(m_dwProgressFlags & PROGRESSFLAG_IDLERETRYENABLED)
                    || !m_fHasShellTrayIcon)
                {
                    IdleCallback(STATE_USER_IDLE_END);

                     // release idle lock since OffIdle won't since we are still
                    //  in the syncing Item state.
                    ReleaseIdleLock();
                }
                else
                {
                    // if haven't yet received an offidle reregister
                    m_pSyncMgrIdle->ReRegisterIdleDetection(this); // reregisterIdle in case handle overrode it.
                    m_pSyncMgrIdle->CheckForIdle();

                    // first thing hide our window. Only hide if we are in the shelltray
                    // and no errors have occured.

                    if (m_fHasShellTrayIcon
                            && !(KeepProgressAlive()))
                    {
                        RegisterShellTrayIcon(FALSE);
                    }

                    m_pSyncMgrIdle->ResetIdle(m_ulIdleRetryMinutes);
                }
            }

        }

        // if no new items in the queue no longer need the connection.
        // do this before releasing dialog ref 
        
        if (!(m_dwProgressFlags & PROGRESSFLAG_NEWITEMSINQUEUE))
        {
            m_HndlrQueue->EndSyncSession();
        }
        // see if Release takes care or our progress, if not,
        // there are more things to synchronize.

        if (fTransferAddRef)
        {
            cDlgRefs = ReleaseProgressDialog(m_fForceClose); // release transfer addref.
        }
        else
        {
            Assert(fTransferAddRef);  // this shouldn't happen but if it does addref/release.

            AddRefProgressDialog();
            cDlgRefs = ReleaseProgressDialog(m_fForceClose);
        }


        // !!!! warning - no longer hold onto a reference to
        // this dialog. Do not do anything to allow this thread
        // to be reentrant.

         // its possible that items got placed in the queue why we were in our
        // sleep loop, if so then restart the loop

        m_dwProgressFlags &= ~PROGRESSFLAG_INHANDLEROUTCALL;

        // if there are new items in the queue need to kick off another loop
        if (m_dwProgressFlags & PROGRESSFLAG_NEWITEMSINQUEUE)
        {
           // m_dwProgressFlags &= ~PROGRESSFLAG_NEWITEMSINQUEUE;
            Assert(0 != m_cInternalcRefs);

            // reset the user cancel flag if new items comein
            m_dwProgressFlags &= ~PROGRESSFLAG_CANCELPRESSED;


            if (!(m_dwProgressFlags & PROGRESSFLAG_STARTPROGRESSPOSTED))
            {
                m_dwProgressFlags |= PROGRESSFLAG_STARTPROGRESSPOSTED;
                PostMessage(hwnd,WM_PROGRESS_STARTPROGRESS,0,0); // restart the sync.
            }
        }
        else
        {
            if (m_dwShowErrorRefCount || m_dwSetItemStateRefCount
                || (m_dwProgressFlags & PROGRESSFLAG_INCANCELCALL) 
                || (m_dwProgressFlags & PROGRESSFLAG_INTERMINATE) )
            {
                // cases that crefs should not be zero caused by out calls
                Assert(0 != m_cInternalcRefs);
            }
            else
            {
                // if get here refs should be zero, be an idle or a queue transfer is in
                // progress.ADD
                Assert(0 == m_cInternalcRefs 
                    || (m_dwProgressFlags & PROGRESSFLAG_INOFFIDLE)
                    || (m_dwProgressFlags & PROGRESSFLAG_REGISTEREDFOROFFIDLE)
                    || (m_dwQueueTransferCount));
            }

            m_dwProgressFlags &= ~PROGRESSFLAG_SYNCINGITEMS; // no longer syncing items.

            
        }

        m_dwProgressFlags &=  ~PROGRESSFLAG_CANCELWHILESHUTTINGDOWN; // if cancel came in during shutdown reset flag now.
        m_dwProgressFlags &= ~PROGRESSFLAG_SHUTTINGDOWNLOOP;
    }


    --m_dwHandleThreadNestcount;

}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::KeepProgressAlive, private
//
//  Synopsis:  returns true if progress dialog shouln't go away
//              when the sync is complete
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::KeepProgressAlive()
{
HKEY  hkKeepProgress;
//Default behavior is to stick around on warnings and errors only.
DWORD dwKeepProgressSetting = PROGRESS_STICKY_WARNINGS | PROGRESS_STICKY_ERRORS;
DWORD dwErrorsFlag = 0;
DWORD dwType = REG_DWORD;
DWORD dwDataSize = sizeof(DWORD);

    if (m_fPushpin)
    {
        return TRUE;
    }
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,TOPLEVEL_REGKEY,0,
                                   KEY_READ,&hkKeepProgress))
    {
        RegQueryValueEx(hkKeepProgress,TEXT("KeepProgressLevel"),NULL, &dwType,
                                       (LPBYTE) &(dwKeepProgressSetting),
                                       &dwDataSize);

	RegCloseKey(hkKeepProgress);
    }

    if (m_iInfoCount)
    {
	dwErrorsFlag |= PROGRESS_STICKY_INFO;
    }
    if (m_iWarningCount)
    {
	dwErrorsFlag |= PROGRESS_STICKY_WARNINGS;
    }
    if (m_iErrorCount)
    {
	dwErrorsFlag |= PROGRESS_STICKY_ERRORS;
    }
	
    if (dwKeepProgressSetting & dwErrorsFlag)
    {
        return TRUE;
    }

    return FALSE;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::TransferQueueData(CHndlrQueue *HndlrQueue)
//
//  PURPOSE:  Get the queue date
//
//      COMMENTS:  transfer items from the specified queue into our queue
//              It is legal fo the HndlrQueue arg to be NULL in the case that
//              the queue is being restarted from a retry. Review - May want
//              to break this function to make the bottom part for the
//              retry a separate function so can assert if someone tries
//              to transfer a NULL queue.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CProgressDlg::TransferQueueData(CHndlrQueue *pHndlrQueue)
{
HRESULT hr = E_UNEXPECTED;

    SendMessage(m_hwnd,WM_PROGRESS_TRANSFERQUEUEDATA,(WPARAM) &hr, (LPARAM) pHndlrQueue);


    return hr;
}



//--------------------------------------------------------------------------------
//
//  FUNCTION: CProgressDlg::TransferQueueData(CHndlrQueue *HndlrQueue)
//
//  PURPOSE:  Get the queue date
//
//      COMMENTS:  transfer items from the specified queue into our queue
//              It is legal fo the HndlrQueue arg to be NULL in the case that
//              the queue is being restarted from a retry. Review - May want
//              to break this function to make the bottom part for the
//              retry a separate function so can assert if someone tries
//              to transfer a NULL queue.
//
//--------------------------------------------------------------------------------

STDMETHODIMP CProgressDlg::PrivTransferQueueData(CHndlrQueue *HndlrQueue)
{
HRESULT hr = NOERROR;


    Assert(!(m_dwProgressFlags & PROGRESSFLAG_DEAD));

    Assert(m_HndlrQueue);
    if (NULL == m_HndlrQueue)
    {
        return E_UNEXPECTED;
    }



    ++m_dwQueueTransferCount;

    if (HndlrQueue && m_HndlrQueue)
    {


        // set the transfer flag so main loop knows there are new items to look at
        m_HndlrQueue->TransferQueueData(HndlrQueue);

         // fill in the list box right away so

        // a) better visual UI
        // b) don't have to worry about race conditions with PrepareForSync.
        //      since adding UI won't make an outgoing call.


        if (m_pItemListView)
        {
            AddItemsFromQueueToListView(m_pItemListView,m_HndlrQueue,
                                LVS_EX_FULLROWSELECT |  LVS_EX_INFOTIP ,SYNCMGRSTATUS_PENDING,
                                -1 /* iDateColumn */ ,PROGRESSLIST_STATUSCOLUMN /*status column */
                                ,FALSE /* fUseHandlerAsParent */,TRUE /* fAddOnlyCheckedItems */);

            // set the selection to the first item
            m_pItemListView->SetItemState(0,
                     LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );

        }


        UpdateProgressValues();
	UpdateWindow(m_hwnd);

        // now check if there is already a transfer in progress and if
        // there isn't post the message, else Addref the progress dialog as appropriate.
    }

    m_dwProgressFlags &= ~PROGRESSFLAG_NEWDIALOG; // no longer a new dialog once something is in the queue.

    ShowCompletedProgress(FALSE,FALSE);

    // if the animation isn't going then start it up.
    if (!(m_dwProgressFlags & PROGRESSFLAG_PROGRESSANIMATION))
    {
       m_dwProgressFlags |= PROGRESSFLAG_PROGRESSANIMATION;

       RedrawIcon();
       ShowProgressTab(PROGRESS_TAB_UPDATE);

       Animate_Play(GetDlgItem(m_hwnd,IDC_UPDATEAVI),0,-1,-1);

       ShowWindow(GetDlgItem(m_hwnd,IDC_UPDATEAVI),SW_SHOW );
       SetTimer(m_hwnd,TIMERID_TRAYANIMATION,TRAYANIMATION_SPEED,NULL);
    }


    // if we are an idle set up our callback
    // successfully loaded msIdle, then set up the callback
    // review - make these progress flags
    if (m_pSyncMgrIdle && !(PROGRESSFLAG_REGISTEREDFOROFFIDLE & m_dwProgressFlags))
    {

         m_dwProgressFlags &= ~PROGRESSFLAG_RECEIVEDOFFIDLE; // reset offidle flag

        // read in the defaults to use for Idle shutdown delay and
        // wait until retryIdle based on the first Job in the queue.

        if (0 == m_pSyncMgrIdle->BeginIdleDetection(this,1,0))
        {
            m_dwProgressFlags |= PROGRESSFLAG_REGISTEREDFOROFFIDLE;
            AddRefProgressDialog(); // put an addref on to keep alive, will be released in OffIdle.
        }
        else
        {
            m_dwProgressFlags &= ~PROGRESSFLAG_REGISTEREDFOROFFIDLE;
        }

    }

    // if don't have a transfer addref then add one and make sure idle is setup
    if (!(PROGRESSFLAG_TRANSFERADDREF & m_dwProgressFlags))
    {
        m_dwProgressFlags |= PROGRESSFLAG_TRANSFERADDREF;
        AddRefProgressDialog(); // put an addref on to keep alive.
    }

    --m_dwQueueTransferCount;

    // don't post message if we are in an out call or in the shutdown
    // loop or if newitemsqueue is already set.
    if (!(m_dwProgressFlags & PROGRESSFLAG_INHANDLEROUTCALL)
            && !(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
            && !(m_dwProgressFlags & PROGRESSFLAG_NEWITEMSINQUEUE)
            && !(m_dwProgressFlags & PROGRESSFLAG_STARTPROGRESSPOSTED) )
    {
         if ( !(m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS) )
         {
             // set here even though main loop does in case power managment or another transfer
             // occurs between here and the postMessage being processed.
             m_dwProgressFlags |= PROGRESSFLAG_SYNCINGITEMS;
             m_HndlrQueue->BeginSyncSession();
         }

         m_dwProgressFlags |=  PROGRESSFLAG_STARTPROGRESSPOSTED;

         PostMessage(m_hwnd,WM_PROGRESS_STARTPROGRESS,0,0);
    }

    // set newitems flag event if don't post the message so when  handler comes out of
    // state can check the flag.

    m_dwProgressFlags |= PROGRESSFLAG_NEWITEMSINQUEUE;

    // reset the user cancel flag if new items comein
    m_dwProgressFlags &= ~PROGRESSFLAG_CANCELPRESSED;

    if (m_lTimerSet)
    {
        InterlockedExchange(&m_lTimerSet, 0);

        // if we are in a terminate no need to kill the Timer
        if (!(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE))
        {
            KillTimer(m_hwnd,TIMERID_KILLHANDLERS);
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::CallCompletionRoutine, private
//
//  Synopsis:   method called when a call has been completed.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    02-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::CallCompletionRoutine(DWORD dwThreadMsg,LPCALLCOMPLETIONMSGLPARAM lpCallCompletelParam)
{

    // !!!warning: This code assumes that the completion routine is only called
    // after the original out call has returned. This code is currently handled
    // by the queue and proxy. If switch to com need to make sure don't start winding
    // up the stack if handlers are calling comletion routines before the original
    // call comes back

    // for anything but ShowErrors can just kick off a progress.
    // for ShowErrors we need to pretend a transfer happened if a retry should occur
    // else don't do anything.

    switch(dwThreadMsg)
    {
    case ThreadMsg_ShowError:
        if (lpCallCompletelParam && (S_SYNCMGR_RETRYSYNC == lpCallCompletelParam->hCallResult))
        {

           // if still in original ShowError Call let ShowEror post the message
            // when done, else treat it like a transfer occured.
            if (m_dwProgressFlags & PROGRESSFLAG_INSHOWERRORSCALL)
            {
                Assert(!(m_dwProgressFlags & PROGRESSFLAG_SHOWERRORSCALLBACKCALLED)); // only support one.
                m_dwProgressFlags |=  PROGRESSFLAG_SHOWERRORSCALLBACKCALLED;
            }
            else
            {
                // sendmessage so it is queued up before release
                SendMessage(m_hwnd,WM_PROGRESS_TRANSFERQUEUEDATA,(WPARAM) 0, (LPARAM) NULL);
            }
        }
        --m_dwShowErrorRefCount;

        // count can go negative if handler calls completion routine on an error. if
        // this is the case just set it to zero
        if ( ((LONG) m_dwShowErrorRefCount) < 0)
        {
            AssertSz(0,"Negative ErrorRefCount");
            m_dwShowErrorRefCount = 0;
        }
        else
        {
            ReleaseProgressDialog(m_fForceClose);
        }
        break;
    case ThreadMsg_PrepareForSync:
    case ThreadMsg_Synchronize:
        {
        DWORD *pdwMsgOutCallCount = (ThreadMsg_PrepareForSync  == dwThreadMsg) ?
                        &m_dwPrepareForSyncOutCallCount : &m_dwSynchronizeOutCallCount;

            if (m_dwProgressFlags & PROGRESSFLAG_INHANDLEROUTCALL)
            {
               m_dwProgressFlags |=PROGRESSFLAG_COMPLETIONROUTINEWHILEINOUTCALL;
            }
            else
            {

                if (!(m_dwProgressFlags &  PROGRESSFLAG_STARTPROGRESSPOSTED))
                {
                    Assert(!(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP));
                    m_dwProgressFlags |= PROGRESSFLAG_CALLBACKPOSTED;
                    m_dwProgressFlags |=  PROGRESSFLAG_STARTPROGRESSPOSTED;
                    PostMessage(m_hwnd,WM_PROGRESS_STARTPROGRESS,0,0);
                }
            }

            // fix up call count.

            --(*pdwMsgOutCallCount);
            if ( ((LONG) *pdwMsgOutCallCount) < 0)
            {
                AssertSz(0,"Negative Message Specific OutCall");
                *pdwMsgOutCallCount = 0;
            }

            --m_dwHandlerOutCallCount; // decrement the handler outcall.
            if ( ((LONG) m_dwHandlerOutCallCount) < 0)
            {
                AssertSz(0,"NegativeHandlerOutCallCount");
                m_dwHandlerOutCallCount = 0;
            }

        }
        break;
    default:
        AssertSz(0,"Unknown Callback method");
        break;
    }

    // if have an lparam free it now
    if (lpCallCompletelParam)
    {
        FREE(lpCallCompletelParam);
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::QueryCanSystemShutdown, private
//
//  Synopsis:   called by object manager to determine if can shutdown.
//
//          !!!Warning - can be called on any thread. make sure this is
//              readonly.
//
//          !!!Warning - Do not yield in the function;
//
//  Arguments:
//
//  Returns:   S_OK - if can shutdown
//             S_FALSE - system should not shutdown, must fill in out params.
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CProgressDlg::QueryCanSystemShutdown(/* [out] */ HWND *phwnd, /* [out] */ UINT *puMessageId,
                                             /* [out] */ BOOL *pfLetUserDecide)
{
HRESULT hr = S_OK;

    if (m_dwShowErrorRefCount > 0)
    {
        *puMessageId = IDS_HANDLERSHOWERRORQUERYENDSESSION ;
        *phwnd = NULL; // don't know showError parent so keep NULL
        *pfLetUserDecide = FALSE;

        hr = S_FALSE;
    }
    else  if (m_clsid != GUID_PROGRESSDLGIDLE) // idle should allow shutdown even if syncing.
    {
            // if a sync is in progress prompt user to if they want to cancel.
        if (PROGRESSFLAG_SYNCINGITEMS & m_dwProgressFlags)
        {
            *puMessageId = IDS_PROGRESSQUERYENDSESSION;
            *phwnd = m_hwnd;
            *pfLetUserDecide = TRUE;

            hr = S_FALSE;
        }
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION:   CProgressDlg::ExpandCollapse()
//
//  PURPOSE:    Takes care of showing and hiding the "details" part of the
//                              dialog.
//
//  PARAMETERS:
//      <in> fExpand - TRUE if we should be expanding the dialog.
//              <in> fSetFocus - TRUE forces a recalc.
//
//--------------------------------------------------------------------------------
void CProgressDlg::ExpandCollapse(BOOL fExpand, BOOL fForce)
{
RECT rcSep;
TCHAR szBuf[MAX_STRING_RES];
RECT rcCurDlgRect;
BOOL fSetWindowPos = FALSE;
BOOL fOrigExpanded = m_fExpanded;

    if ( (m_fExpanded == fExpand) && !fForce) // no need to do anything if already in requested state
        return;

    m_fExpanded = fExpand;

    GetWindowRect(GetDlgItem(m_hwnd, IDC_SP_SEPARATOR), &rcSep);
    GetWindowRect(m_hwnd,&rcCurDlgRect);

    if (!m_fExpanded)
    {
        // update or rcDlg rect so can reset to proper height next time.
        if (GetWindowRect(m_hwnd,&m_rcDlg))
        {

            fSetWindowPos = SetWindowPos(m_hwnd, HWND_NOTOPMOST, 0, 0, rcCurDlgRect.right - rcCurDlgRect.left,
                     m_cyCollapsed, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
    }
    else
    {
        fSetWindowPos = SetWindowPos(m_hwnd, HWND_NOTOPMOST, 0, 0, rcCurDlgRect.right - rcCurDlgRect.left,
                     m_rcDlg.bottom - m_rcDlg.top,
                                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // if couldn't change window, leave as is
    if (!fSetWindowPos)
    {
        m_fExpanded = fOrigExpanded;
        return;
    }

    // Make sure the entire dialog is visible on the screen.  If not,
    // then push it up
    RECT rc;
    RECT rcWorkArea;
    GetWindowRect(m_hwnd, &rc);
    SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID) &rcWorkArea, 0);
    if (rc.bottom > rcWorkArea.bottom)
    {
        rc.top = max(0, (int) rc.top - (rc.bottom - rcWorkArea.bottom));

        SetWindowPos(m_hwnd, HWND_NOTOPMOST, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    LoadString(g_hInst, m_fExpanded ? IDS_HIDE_DETAILS : IDS_SHOW_DETAILS, szBuf,
                  ARRAY_SIZE(szBuf));
    SetDlgItemText(m_hwnd, IDC_DETAILS, szBuf);

    // Make sure the proper tab is up to date shown.
    ShowProgressTab(m_iTab);

    // Raid-34387: Spooler: Closing details with ALT-D while focus is on a task disables keyboard input
    // if any control other than the cancel button has the focus set the focus to details.

    if (!fExpand)
    {
    HWND hwndFocus = GetFocus();

        if (hwndFocus != GetDlgItem(m_hwnd, IDSTOP))
        {
            SetFocus(GetDlgItem(m_hwnd, IDC_DETAILS));
        }

    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnTimer, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnTimer(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
WORD wTimerID = (WORD) wParam;

    if (wTimerID == TIMERID_TRAYANIMATION)
    {
        UpdateTrayIcon();
    }
    else if (TIMERID_NOIDLEHANGUP == wTimerID)
    {
        ResetNetworkIdle();
    }
    else if (TIMERID_KILLHANDLERS == wTimerID)
    {
        if (m_lTimerSet)
        {

            if (!(m_dwProgressFlags & PROGRESSFLAG_DEAD)
                && !(m_dwProgressFlags & PROGRESSFLAG_SHUTTINGDOWNLOOP)
                && !(m_dwProgressFlags & PROGRESSFLAG_INTERMINATE))
            {
            BOOL fItemToKill;

                m_dwProgressFlags |= PROGRESSFLAG_INTERMINATE;

                // Even though KillTimer,
                // don't reset  m_lTimerSet timer until done with ForceKill
                // in case cancel is pressed again.

                KillTimer(m_hwnd,TIMERID_KILLHANDLERS);
            
                SetProgressReleaseDlgCmdId(m_clsid,this,RELEASEDLGCMDID_CANCEL); // set so cleanup knows it was stopped by user..


                AddRefProgressDialog(); // hold dialog alive until cancel is complete

                m_HndlrQueue->ForceKillHandlers(&fItemToKill);

                // reset the timer if TimerSet is still set, i.e. if was 
                // set to zero because of a transfer or actually done don't reset.

                if (m_lTimerSet)
                {
                    // only settimer if actually killed anything. if looped through
                    // and found nothing then can turn off timer.
                    if (fItemToKill)
                    {
                        Assert(m_nKillHandlerTimeoutValue >= TIMERID_KILLHANDLERSMINTIME);
                        SetTimer(m_hwnd,TIMERID_KILLHANDLERS,m_nKillHandlerTimeoutValue,NULL);
                    }
                    else
                    {
                        m_lTimerSet = 0;
                    }
                }

                m_dwProgressFlags &= ~PROGRESSFLAG_INTERMINATE;
                
                ReleaseProgressDialog(FALSE);
            }

        }

    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnTaskBarCreated, private
//
//  Synopsis:  Receive this when the Tray has been restarted.
//              Need to put back our tray icon.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    31-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnTaskBarCreated(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    if (m_fHasShellTrayIcon)
    {
        m_fAddedIconToTray = FALSE; // set added to false to force update to add again.
        UpdateTrayIcon();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnSysCommand, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::OnSysCommand(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
UINT uCmdType = (UINT) wParam;        // type of system command requested
WORD xPos = LOWORD(lParam);    // horizontal postion, in screen coordinates
WORD yPos = HIWORD(lParam);    // vertical postion, in screen coordinates

    //
    // WARNING: USER uses low four bits for some undocumented feature
    //  (only for SC_*). We need to mask those bits to make this case
    //  statement work.

   uCmdType &= 0xFFF0;

    switch(uCmdType)
    {
    case SC_MINIMIZE:

        // if already in the tray to nothing
        if (!m_fHasShellTrayIcon)
        {
            if (RegisterShellTrayIcon(TRUE))
            {
                AnimateTray(TRUE);
                ShowWindow(m_hwnd,SW_HIDE);
              //  AnimateTray(TRUE);
                return -1;
            }
        }
        else
        {
            return -1; // if already in the tray we handled.
        }
        break;
    case SC_MAXIMIZE:
    case SC_RESTORE:
        {
            // if we are being maximized or restored from a maximize
            // make sure  details is open

            if ( (uCmdType ==  SC_RESTORE && m_fMaximized)
                    || (uCmdType ==  SC_MAXIMIZE) )
            {
                if (!m_fExpanded)
                {
                    ExpandCollapse(TRUE,FALSE);
                }
            }

            m_fMaximized = (uCmdType ==  SC_MAXIMIZE) ?  TRUE : FALSE;
        }
        break;
    default:
        break;
    }

    return FALSE; // fall through to defWndProc
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnShellTrayNotification, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnShellTrayNotification(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
DWORD dwMsg = (DWORD) lParam;

    switch (dwMsg)
    {
    case WM_LBUTTONUP:
        {
            UpdateWndPosition(SW_SHOWNORMAL,TRUE /* fForce */);
        }
        break;
    #ifdef _TRAYMENU
    case WM_RBUTTONUP:
        {
        POINT Point;

                // show the context menu
                HMENU hmenu = LoadMenu(hInst,MAKEINTRESOURCE(IDR_MENU1));
                hmenu = CreatePopupMenu();

                //AppendMenu(hmenu,0,101,"Status");
                //AppendMenu(hmenu,0,100,"Settings");

                GetCursorPos(&Point); // want point that click occured at.

                // Review, change so TrackMenu returns index.
                TrackPopupMenuEx(hmenu,TPM_HORIZONTAL | TPM_VERTICAL,
                                    Point.x,Point.y,hwnd,NULL);


        }
        break;
    #endif // _TRAYMENU
    default:
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnClose, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnClose(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    OnCancel(FALSE /* fOffIdle */); // treat close as a cancel.
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnGetMinMaxInfo, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnGetMinMaxInfo(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
MINMAXINFO   *pMinMax = (MINMAXINFO *) lParam ;

    // minimum width is a constant but minimum height depends on
    // if dialog is collapsed or expanded.

    if (!m_fExpanded)
    {
         pMinMax->ptMinTrackSize.y = m_cyCollapsed;
         pMinMax->ptMaxTrackSize.y = m_cyCollapsed; // maximum is also the collapsed height
    }
    else
    {
        pMinMax->ptMinTrackSize.y = m_ptMinimumDlgExpandedSize.y;
    }

    pMinMax->ptMinTrackSize.x  = m_ptMinimumDlgExpandedSize.x;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnMoving, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CProgressDlg::OnMoving(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
LPRECT lprc = (LPRECT) lParam;    // screen coordinates of drag rectangle

    // if we are maxmized don't allow moving
    if (m_fMaximized)
    {
        GetWindowRect(m_hwnd,lprc);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnContextMenu, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL  CProgressDlg::OnContextMenu(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    WinHelp ((HWND)wParam,
                    g_szSyncMgrHelp,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)g_aContextHelpIds);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CProgressDlg::OnPowerBroadcast, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    17-Jun-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CProgressDlg::OnPowerBroadcast(UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    if (wParam == PBT_APMQUERYSUSPEND)
    {
        // if just created or syncing don't suspend
        if (m_dwProgressFlags & PROGRESSFLAG_NEWDIALOG
            || m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS)
        {
            SetWindowLongPtr(m_hwnd,DWLP_MSGRESULT,BROADCAST_QUERY_DENY);
            return TRUE;
        }
    }

    return TRUE;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam)
//
//  PURPOSE:  Callback for Progress Dialog
//
//      COMMENTS: Implemented on main thread.
//
//
//--------------------------------------------------------------------------------

BOOL CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam)
{
CProgressDlg *pThis = (CProgressDlg *) GetWindowLongPtr(hwnd, DWLP_USER);
UINT horizExtent = 0;
BOOL bResult;

    // spcial case destroy and init.
    switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0); // done with this thread.
	break;
    case WM_INITDIALOG:
        {
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
        pThis = (CProgressDlg *) lParam;

            if (pThis)
            {
                pThis->InitializeHwnd(hwnd,uMsg,wParam,lParam);
            }

            return FALSE; // return FALSE so system doesn't give us the focus

        break;
        }
    default:
        {
            if (pThis)
            {
                switch (uMsg)
                {
                case WM_POWERBROADCAST:
                    return pThis->OnPowerBroadcast(uMsg,wParam,lParam);
                    break;
                case WM_CONTEXTMENU:
                    return pThis->OnContextMenu(uMsg,wParam,lParam);
                    break;
                case WM_DRAWITEM:
                    return OnProgressResultsDrawItem(hwnd,pThis,(UINT)wParam,(const DRAWITEMSTRUCT*)lParam);
                    break;
                case WM_MEASUREITEM:
                    bResult = OnProgressResultsMeasureItem(hwnd,pThis, &horizExtent,(UINT)wParam,(MEASUREITEMSTRUCT *)lParam);
                    if (horizExtent)
                    {
                        //make sure there is a horizontal scroll bar if needed
                        SendMessage(GetDlgItem(hwnd,IDC_LISTBOXERROR),
                            LB_SETHORIZONTALEXTENT, horizExtent, 0L);
                    }
                    return bResult;
                    break;
                case WM_DELETEITEM:
                    return OnProgressResultsDeleteItem(hwnd,(UINT)wParam,(const DELETEITEMSTRUCT *)lParam);
                    break;
                case WM_NOTIFY:
                    pThis->OnNotify(uMsg,wParam,lParam);
                    break;
                case WM_COMMAND:
                    pThis->OnCommand(uMsg,wParam,lParam);
                    break;
                case WM_MOVING:
                     pThis->OnMoving(uMsg,wParam,lParam);
                     break;
                case WM_SIZE:
                    pThis->OnSize(uMsg,wParam,lParam);
                    break;
                case WM_GETMINMAXINFO:
                    pThis->OnGetMinMaxInfo(uMsg,wParam,lParam);
                    break;
                case WM_PAINT:
                    pThis->OnPaint(uMsg,wParam,lParam);
                    return 0;
                    break;
                case WM_BASEDLG_SHOWWINDOW:
                    pThis->UpdateWndPosition((int)wParam,FALSE); // nCmdShow is stored in the wParam
                    break;
                case WM_BASEDLG_NOTIFYLISTVIEWEX:
                    pThis->OnNotifyListViewEx(uMsg,wParam,lParam);
                    break;
                case WM_BASEDLG_COMPLETIONROUTINE:
                    pThis->CallCompletionRoutine((DWORD)wParam /*dwThreadMsg */ ,(LPCALLCOMPLETIONMSGLPARAM) lParam);
                    break;
                case WM_BASEDLG_HANDLESYSSHUTDOWN:
                    // set the force shutdown member then treat as a close
                    pThis->m_fForceClose = TRUE;
                    PostMessage(hwnd,WM_CLOSE,0,0);
                    break;
                case WM_TIMER: // timer message for delat when sync is done.
                   pThis->OnTimer(uMsg,wParam,lParam);
                   break;
                case WM_PROGRESS_UPDATE:
                    pThis->HandleProgressUpdate(hwnd,wParam,lParam);
                    break;
                case WM_PROGRESS_LOGERROR:
                    pThis->HandleLogError(hwnd,(HANDLERINFO *) wParam,(MSGLogErrors *) lParam);
                    break;
                case WM_PROGRESS_DELETELOGERROR:
                    pThis->HandleDeleteLogError(hwnd,(MSGDeleteLogErrors *) lParam);
                    break;
                case WM_PROGRESS_STARTPROGRESS:
                    pThis->DoSyncTask(hwnd);
                    break;
                case WM_PROGRESS_RESETKILLHANDLERSTIMER:
                    pThis->OnResetKillHandlersTimers();
                    break;
                case WM_CLOSE:
                    pThis->OnClose(uMsg,wParam,lParam);
                    break;
                case WM_PROGRESS_SHELLTRAYNOTIFICATION:
                    pThis->OnShellTrayNotification(uMsg,wParam,lParam);
                    break;
                case WM_SYSCOMMAND:
                    return pThis->OnSysCommand(uMsg,wParam,lParam);
                    break;
                case WM_PROGRESS_TRANSFERQUEUEDATA:
                    {
                    HRESULT *phr = (HRESULT *) wParam;
                    HRESULT hr;

                        hr = pThis->PrivTransferQueueData( (CHndlrQueue *) lParam);

                        // phr is only valid on a SendMessage.
                        if (NULL != phr)
                        {
                            *phr = hr;
                        }

                    return TRUE;
                    break;
                    }
                case WM_PROGRESS_RELEASEDLGCMD:
                    pThis->PrivReleaseDlg((WORD)wParam);
                    break;
                default:
                    if (uMsg == g_WMTaskbarCreated)
                    {
                        pThis->OnTaskBarCreated(uMsg,wParam,lParam);
                    }
                    break;
                }
            }
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\precomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       prcomp.h
//
//  Contents:   precompiled headers
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------


// Ensure Version 400 is defined
//

#ifndef WINVER
#define WINVER 0x400
#elif WINVER < 0x400
#undef WINVER
#define WINVER 0x400
#endif

// standard includes for  MobSync lib
#include <objbase.h>
#include <windows.h>
#include <windowsx.h>
#include <shellapi.h>
#include <commctrl.h>
#include <inetreg.h>
#include <advpub.h>
#include <mstask.h>
#include <msterr.h>

#include <mobsync.h>
#include <mobsyncp.h>

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "widewrap.h"
#include "stringc.h"
#include "smartptr.hxx"
#include "xarray.hxx"
#include "osdefine.h"

#include "validate.h"
#include "netapi.h"
#include "listview.h"
#include "util.hxx"
#include "clsobj.h"

// dll include files
#include "..\dll\dllreg.h"

#include "resource.h"
#include "resource.hm"

#include "reg.h"

#include "cmdline.h"
#include "idle.h"
#include "connobj.h"

#include "hndlrq.h"
#include "msg.h"
#include "callback.h"
#include "hndlrmsg.h"

#include "dlg.h"

#include "invoke.h"
#include "clsfact.h"

#include "objmgr.h"


#ifndef LVS_EX_INFOTIP
#define LVS_EX_INFOTIP          0x00000400 // listview does InfoTips
#endif  // LVS_EX_INFOTIP

#ifndef LVM_GETSELECTIONMARK
#define LVM_GETSELECTIONMARK    (LVM_FIRST + 66)
#define ListView_GetSelectionMark(hwnd) \
    (int)SNDMSG((hwnd), LVM_GETSELECTIONMARK, 0, 0)
#endif //  LVM_GETSELECTIONMARK

#define LVIS_STATEIMAGEMASK_CHECK (0x2000)
#define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\reg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Reg.cpp
//
//  Contents:   Registration Routines
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"




//--------------------------------------------------------------------------------
//
//  FUNCTION: GetLastIdleHandler()
//
//  PURPOSE:  returns last handler synchronized on an Idle
//
//
//--------------------------------------------------------------------------------

STDMETHODIMP GetLastIdleHandler(CLSID *clsidHandler)
{
HRESULT hr = E_UNEXPECTED;
HKEY hkeyIdle;
WCHAR wszGuid[GUID_SIZE];
TCHAR *pszGuid;
DWORD dwDataSize;
#ifndef _UNICODE
TCHAR szGuid[GUID_SIZE];
#endif // _UNICODE

    #ifdef _UNICODE
        dwDataSize = sizeof(wszGuid);
        pszGuid = wszGuid;
    #else
        dwDataSize = sizeof(szGuid);
        pszGuid = szGuid;
    #endif
     

   // write out the Handler to the Registry.
    if (ERROR_SUCCESS == RegCreateKeyExXp(HKEY_CURRENT_USER, 
                            IDLESYNC_REGKEY,0,NULL,
                            REG_OPTION_NON_VOLATILE,KEY_QUERY_VALUE,NULL,&hkeyIdle,
                            NULL,FALSE /*fSetSecurity*/))
    {
    DWORD dwType;

        dwType = REG_SZ;

        hr = RegQueryValueEx(hkeyIdle,SZ_IDLELASTHANDLERKEY
                             ,NULL, &dwType ,  
			     (LPBYTE) pszGuid,
			     &dwDataSize);

        RegCloseKey(hkeyIdle);
    }
    else
    {
        return S_FALSE;
    }

    if (hr != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        return hr;
    }

#ifndef _UNICODE
    MultiByteToWideChar(CP_ACP ,0,szGuid,-1,wszGuid,GUID_SIZE);
#endif // _UNICODE

    return CLSIDFromString(wszGuid,clsidHandler);
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: SetLastIdleHandler()
//
//  PURPOSE:  sets the last handler synchronized on an Idle
//
//
//--------------------------------------------------------------------------------

STDMETHODIMP SetLastIdleHandler(REFCLSID clsidHandler)
{
HRESULT hr = E_UNEXPECTED;
HKEY hkeyIdle;
WCHAR wszGuid[GUID_SIZE];
TCHAR *pszGuid;
DWORD dwDataSize;
#ifndef _UNICODE
TCHAR szGuid[GUID_SIZE];
#endif // _UNICODE

    
    if (0 == StringFromGUID2(clsidHandler,wszGuid, GUID_SIZE))
    {
        AssertSz(0,"SetLastIdleHandler Failed");
        return E_UNEXPECTED;
    }

#ifdef _UNICODE
    pszGuid = wszGuid;
    dwDataSize = sizeof(wszGuid);
#else
    BOOL fUsedDefaultChar;

    WideCharToMultiByte(CP_ACP ,0,wszGuid,
				    -1,szGuid,GUID_SIZE,
				    NULL,&fUsedDefaultChar);

    pszGuid = szGuid;
    dwDataSize = GUID_SIZE * sizeof(TCHAR);
#endif // _UNICODE

    // write out the Handler to the Registry.
    if (ERROR_SUCCESS ==  RegCreateKeyExXp(HKEY_CURRENT_USER, 
                            IDLESYNC_REGKEY,0,NULL,
                            REG_OPTION_NON_VOLATILE,KEY_WRITE,NULL,&hkeyIdle,
                            NULL,FALSE /*fSetSecurity*/))
    {

        hr = RegSetValueEx(hkeyIdle,SZ_IDLELASTHANDLERKEY
                             ,NULL, REG_SZ ,  
			     (LPBYTE) pszGuid,
			     dwDataSize);

        RegCloseKey(hkeyIdle);
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\objmgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Objmgr.cpp
//
//  Contents:   Keeps track of dialog objects and
//              application lifetime
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

STDAPI DisplayOptions(HWND hwndOwner); // OneStop.dll Export

CSingletonNetApi gSingleNetApiObj;         // Global singleton NetApi object

CRITICAL_SECTION g_LockCountCriticalSection; // Critical Section fo Object Mgr
OBJECTMGRDATA g_ObjectMgrData; // Global Object Mgr Data
extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo, setup by WinMain.

#ifdef _DEBUG
DWORD g_ThreadCount = 0;
#endif // _DEBUG

//+---------------------------------------------------------------------------
//
//  Function:   CreateDlgThread, public
//
//  Synopsis:   Called to Create a new Dlg Thread
//
//  Arguments:  [dlgType] - Type of Dialog to create
//              [nCmdShow] - How to display the Dialog.
//              [ppDlg] - on success returns a pointer to the new dialog
//              [pdwThreadID] - on Success Id of thread that was created.
//              [phThread] - Handle to newly created thread.
//
//  Returns:    Appropriate return codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

HRESULT CreateDlgThread(DLGTYPE dlgType,REFCLSID rclsid,int nCmdShow,CBaseDlg **ppDlg,
                            DWORD *pdwThreadID,HANDLE *phThread)
{
HRESULT hr = E_FAIL;
HANDLE hNewThread = NULL;
DlgThreadArgs ThreadArgs;

    *phThread = NULL;
    *ppDlg = NULL;

    ThreadArgs.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

    if (ThreadArgs.hEvent)
    {
        ThreadArgs.dlgType = dlgType;
        ThreadArgs.clsid = rclsid;
        ThreadArgs.pDlg = NULL;
        ThreadArgs.nCmdShow = nCmdShow;
        ThreadArgs.hr = E_UNEXPECTED;

        hNewThread = CreateThread(NULL,0,DialogThread,&ThreadArgs,0,pdwThreadID);

        if (hNewThread)
        {
           WaitForSingleObject(ThreadArgs.hEvent,INFINITE);
           if (NOERROR == ThreadArgs.hr)
           {
                *phThread = hNewThread;
                *ppDlg = ThreadArgs.pDlg;
                hr = NOERROR;
           }
           else
           {
                CloseHandle(hNewThread);
                hr = ThreadArgs.hr;
           }

        }
        else
        {
            hr = GetLastError();
        }

        CloseHandle(ThreadArgs.hEvent);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   DialogThread, public
//
//  Synopsis:   ThreadProc for a new Dlg Thread
//              !!!Warning - Must always ensure event in ThreadArg gets set.
//
//  Arguments:  [lpArg] - Pointer to DialogThreadArgs
//
//  Returns:    Appropriate return codes. Sets hr value in
//              ThreadArgs before setting event object
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD WINAPI DialogThread( LPVOID lpArg )
{
MSG msg;
HRESULT hr;
HRESULT hrCoInitialize;
DWORD cRefs;
HWND hwndDlg;
DlgThreadArgs *pThreadArgs = (DlgThreadArgs *) lpArg;

   pThreadArgs->hr = NOERROR;

   hrCoInitialize = CoInitialize(NULL);

   switch (pThreadArgs->dlgType)
   {
   case DLGTYPE_CHOICE:
        pThreadArgs->pDlg = new CChoiceDlg(pThreadArgs->clsid);
        break;
   case DLGTYPE_PROGRESS:
        pThreadArgs->pDlg = new CProgressDlg(pThreadArgs->clsid);
        break;
   default:
       pThreadArgs->pDlg = NULL;
       AssertSz(0,"Unknown Dialog Type");
       break;
   }

   // need to do a PeekMessage and then set an event to make sure
   // a message loop is created before the first PostMessage is sent.

   PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

   // initialize the dialog box before returning to main thread.
   if (NULL == pThreadArgs->pDlg ||
        FALSE == pThreadArgs->pDlg->Initialize(GetCurrentThreadId(),pThreadArgs->nCmdShow)
        || (FAILED(hrCoInitialize)) )
   {

        if (pThreadArgs->pDlg)
            pThreadArgs->pDlg->PrivReleaseDlg(RELEASEDLGCMDID_DESTROY);

        pThreadArgs->hr = E_OUTOFMEMORY;
   }
   else
   {
       hwndDlg = pThreadArgs->pDlg->GetHwnd();
   }

   hr = pThreadArgs->hr;
#ifdef _DEBUG
   ++g_ThreadCount;
#endif // _DEBUG

   cRefs = AddRefOneStopLifetime(FALSE /* !External */); // make sure we stay alive for lifetime of thread.
   Assert(cRefs > 1); // someone else should also have a lock during dialog creation.

   // let the caller know the thread is done initializing.
   if (pThreadArgs->hEvent)
     SetEvent(pThreadArgs->hEvent);

   if (NOERROR == hr)
   {
       // sit in loop receiving messages.
       while (GetMessage(&msg, NULL, 0, 0))
       {
            if (!IsDialogMessage(hwndDlg,&msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
   }

   if (SUCCEEDED(hrCoInitialize))
       CoUninitialize();


#ifdef _DEBUG
   --g_ThreadCount;
#endif // _DEBUG

    ReleaseOneStopLifetime(FALSE /* !External */);

   return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindDialog, private
//
//  Synopsis:   Looks to see if there is an existing  dialog
//              matching the type and  clsid. If not and fCreate is true a
//              new  dialog will be made. If fCreate is false
//              and no dialog is found S_FALSE will be returned.
//
//  Arguments:  [rclcisd] - clsid of choice dialog
//              [fCreate] - If true and no choice dialog found a new one will
//                          be created.
//              [nCmdShow] - How to Create the dialog
//              [pChoiceDlg] - On Success is a pointer to the new Choice Dialog.
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI FindDialog(DLGTYPE dlgType,REFCLSID rclsid,BOOL fCreate,int nCmdShow,CBaseDlg **pDlg)
{
DLGLISTITEM *pDlgListItem;
HWND hwnd = NULL;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

   *pDlg = NULL;

    cCritSect.Enter();

    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        if (rclsid == pDlgListItem->clsid
                &&  dlgType == pDlgListItem->dlgType)
        {
            break;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    if (pDlgListItem)
    {
        Assert((pDlgListItem->cRefs > 0) || (pDlgListItem->cLocks > 0) );

        ++pDlgListItem->cRefs;
        *pDlg = pDlgListItem->pDlg;
    }


    // didn't find a match if fCreate is set then try to create one.
    if (TRUE == fCreate && NULL == *pDlg)
    {
    CBaseDlg *pNewDlg;
    DLGLISTITEM *pNewDlgListItem;
    DWORD dwThreadID;
    pNewDlgListItem = (DLGLISTITEM *) ALLOC(sizeof(DLGLISTITEM));


        if (NULL != pNewDlgListItem)
        {
        HRESULT hr;
        HANDLE hThread;

            cCritSect.Leave();
            hr = CreateDlgThread(dlgType,rclsid,nCmdShow,&pNewDlg,&dwThreadID,&hThread);
            cCritSect.Enter();

            if (NOERROR == hr )
            {
                // its possible that while we had the lock count released a request
                // for the same  dialog came through so rescan to make sure we
                // don't have a match

                pDlgListItem = g_ObjectMgrData.DlgList;

                // look for existing.
                while (pDlgListItem)
                {
                    if (rclsid == pDlgListItem->clsid
                            &&  dlgType == pDlgListItem->dlgType)
                    {
                        break;
                    }

                    pDlgListItem = pDlgListItem->pDlgNextListItem;
                }

                // if found a match then incrmement its cRef,
                // delete the new one we just created,
                // and return a pointer to the one in the list
                // else add new dialog to the list.
                if (pDlgListItem)
                {
                    // delete our newly create dialog and structure.
                    CloseHandle(hThread);
                    FREE(pNewDlgListItem);
                    pNewDlg->ReleaseDlg(RELEASEDLGCMDID_DESTROY);

                    // increment found dialog and set the out param
                    Assert(pDlgListItem->cRefs > 0);
                    ++pDlgListItem->cRefs;
                    *pDlg = pDlgListItem->pDlg;
                }
                else
                {
                    // iniitalize the structure.
                    pNewDlgListItem->dlgType = dlgType;
                    pNewDlgListItem->cRefs = 1;
                    pNewDlgListItem->cLocks = 0;
                    pNewDlgListItem->clsid = rclsid;
                    pNewDlgListItem->pDlg = pNewDlg;
                    pNewDlgListItem->dwThreadID = dwThreadID;
                    pNewDlgListItem->hThread = hThread;
                    pNewDlgListItem->fHasReleaseDlgCmdId = FALSE;
                    pNewDlgListItem->wCommandID = RELEASEDLGCMDID_DEFAULT;

                    *pDlg = pNewDlg;

                    // now add to the beginning of the list.
                    pNewDlgListItem->pDlgNextListItem = g_ObjectMgrData.DlgList;
                    g_ObjectMgrData.DlgList = pNewDlgListItem;

                    ++g_ObjectMgrData.LockCountInternal; // increment the LockCount
                }
            }
            else
            {
                FREE(pNewDlgListItem);
            }
        }

    }

    // if found an existing dialog, update the z-Order
    if (*pDlg)
    {
        hwnd =  (*pDlg)->GetHwnd();
    }

    cCritSect.Leave();

    if (hwnd)
    {
        BASEDLG_SHOWWINDOW(hwnd,nCmdShow);
    }

    return *pDlg ? S_OK : S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddRefDialog, private
//
//  Synopsis:   Looks to see if there is an existing  dialog
//              matching the type and  clsid and puts an addref on it.
//
//  Arguments:
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) AddRefDialog(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg)
{
DLGLISTITEM dlgListDummy;
DLGLISTITEM *pDlgLi