ompiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\hotfixmanager.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Feb 16 13:06:19 2000
 */
/* Compiler settings for E:\HotfixManager\HotfixManager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __HotfixManager_h__
#define __HotfixManager_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IHotfixOCX_FWD_DEFINED__
#define __IHotfixOCX_FWD_DEFINED__
typedef interface IHotfixOCX IHotfixOCX;
#endif 	/* __IHotfixOCX_FWD_DEFINED__ */


#ifndef ___IHotfixOCXEvents_FWD_DEFINED__
#define ___IHotfixOCXEvents_FWD_DEFINED__
typedef interface _IHotfixOCXEvents _IHotfixOCXEvents;
#endif 	/* ___IHotfixOCXEvents_FWD_DEFINED__ */


#ifndef __HotfixOCX_FWD_DEFINED__
#define __HotfixOCX_FWD_DEFINED__

#ifdef __cplusplus
typedef class HotfixOCX HotfixOCX;
#else
typedef struct HotfixOCX HotfixOCX;
#endif /* __cplusplus */

#endif 	/* __HotfixOCX_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IHotfixOCX_INTERFACE_DEFINED__
#define __IHotfixOCX_INTERFACE_DEFINED__

/* interface IHotfixOCX */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IHotfixOCX;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("692E94C7-A5AC-401B-A471-BCD101B456F4")
    IHotfixOCX : public IDispatch
    {
    public:
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
            /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *ppFont) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Command( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Command( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ComputerName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProductName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProductName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ViewState( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Remoted( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HaveHotfix( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentState( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHotfixOCXVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHotfixOCX __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHotfixOCX __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHotfixOCX __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Font )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ IFontDisp __RPC_FAR *pFont);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Font )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ IFontDisp __RPC_FAR *pFont);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Font )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *ppFont);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Command )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Command )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ComputerName )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ComputerName )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProductName )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProductName )( 
            IHotfixOCX __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ViewState )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Remoted )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HaveHotfix )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentState )( 
            IHotfixOCX __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        END_INTERFACE
    } IHotfixOCXVtbl;

    interface IHotfixOCX
    {
        CONST_VTBL struct IHotfixOCXVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHotfixOCX_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHotfixOCX_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHotfixOCX_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHotfixOCX_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHotfixOCX_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHotfixOCX_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHotfixOCX_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHotfixOCX_putref_Font(This,pFont)	\
    (This)->lpVtbl -> putref_Font(This,pFont)

#define IHotfixOCX_put_Font(This,pFont)	\
    (This)->lpVtbl -> put_Font(This,pFont)

#define IHotfixOCX_get_Font(This,ppFont)	\
    (This)->lpVtbl -> get_Font(This,ppFont)

#define IHotfixOCX_get_Command(This,pVal)	\
    (This)->lpVtbl -> get_Command(This,pVal)

#define IHotfixOCX_put_Command(This,newVal)	\
    (This)->lpVtbl -> put_Command(This,newVal)

#define IHotfixOCX_get_ComputerName(This,pVal)	\
    (This)->lpVtbl -> get_ComputerName(This,pVal)

#define IHotfixOCX_put_ComputerName(This,newVal)	\
    (This)->lpVtbl -> put_ComputerName(This,newVal)

#define IHotfixOCX_get_ProductName(This,pVal)	\
    (This)->lpVtbl -> get_ProductName(This,pVal)

#define IHotfixOCX_put_ProductName(This,newVal)	\
    (This)->lpVtbl -> put_ProductName(This,newVal)

#define IHotfixOCX_get_ViewState(This,pVal)	\
    (This)->lpVtbl -> get_ViewState(This,pVal)

#define IHotfixOCX_get_Remoted(This,pVal)	\
    (This)->lpVtbl -> get_Remoted(This,pVal)

#define IHotfixOCX_get_HaveHotfix(This,pVal)	\
    (This)->lpVtbl -> get_HaveHotfix(This,pVal)

#define IHotfixOCX_get_CurrentState(This,pVal)	\
    (This)->lpVtbl -> get_CurrentState(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_putref_Font_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ IFontDisp __RPC_FAR *pFont);


void __RPC_STUB IHotfixOCX_putref_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_put_Font_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ IFontDisp __RPC_FAR *pFont);


void __RPC_STUB IHotfixOCX_put_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_Font_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *ppFont);


void __RPC_STUB IHotfixOCX_get_Font_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_Command_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_put_Command_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IHotfixOCX_put_Command_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_ComputerName_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_put_ComputerName_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IHotfixOCX_put_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_ProductName_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_ProductName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_put_ProductName_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IHotfixOCX_put_ProductName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_ViewState_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_ViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_Remoted_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_Remoted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_HaveHotfix_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_HaveHotfix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IHotfixOCX_get_CurrentState_Proxy( 
    IHotfixOCX __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHotfixOCX_get_CurrentState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHotfixOCX_INTERFACE_DEFINED__ */



#ifndef __HOTFIXMANAGERLib_LIBRARY_DEFINED__
#define __HOTFIXMANAGERLib_LIBRARY_DEFINED__

/* library HOTFIXMANAGERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HOTFIXMANAGERLib;

#ifndef ___IHotfixOCXEvents_DISPINTERFACE_DEFINED__
#define ___IHotfixOCXEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IHotfixOCXEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IHotfixOCXEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("7E2DCE25-E11D-45D6-9AE7-AD522D915FFC")
    _IHotfixOCXEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IHotfixOCXEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IHotfixOCXEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IHotfixOCXEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _IHotfixOCXEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _IHotfixOCXEventsVtbl;

    interface _IHotfixOCXEvents
    {
        CONST_VTBL struct _IHotfixOCXEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IHotfixOCXEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IHotfixOCXEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IHotfixOCXEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IHotfixOCXEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IHotfixOCXEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IHotfixOCXEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IHotfixOCXEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IHotfixOCXEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_HotfixOCX;

#ifdef __cplusplus

class DECLSPEC_UUID("883B970F-690C-45F2-8A3A-F4283E078118")
HotfixOCX;
#endif
#endif /* __HOTFIXMANAGERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\hotfixocx.h ===
// HotfixOCX.h : Declaration of the CHotfixOCX

#ifndef __HOTFIXOCX_H_
#define __HOTFIXOCX_H_
#include <atlctl.h>
#include "resource.h"       // main symbols
#include <windowsx.h>
#include <windows.h>
#include "CListViews.h"




/////////////////////////////////////////////////////////////////////////////
// CHotfixOCX
class ATL_NO_VTABLE CHotfixOCX : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CHotfixOCX, IHotfixOCX, &IID_IHotfixOCX, &LIBID_HOTFIXMANAGERLib>,
	public CComControl<CHotfixOCX>,
	public IPersistStreamInitImpl<CHotfixOCX>,
	public IOleControlImpl<CHotfixOCX>,
	public IOleObjectImpl<CHotfixOCX>,
	public IOleInPlaceActiveObjectImpl<CHotfixOCX>,
	public IViewObjectExImpl<CHotfixOCX>,
	public IOleInPlaceObjectWindowlessImpl<CHotfixOCX>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CHotfixOCX>,
	public IPersistStorageImpl<CHotfixOCX>,
	public ISpecifyPropertyPagesImpl<CHotfixOCX>,
	public IQuickActivateImpl<CHotfixOCX>,
	public IDataObjectImpl<CHotfixOCX>,
	public IProvideClassInfo2Impl<&CLSID_HotfixOCX, &DIID__IHotfixOCXEvents, &LIBID_HOTFIXMANAGERLib>,
	public IPropertyNotifySinkCP<CHotfixOCX>,
	public CComCoClass<CHotfixOCX, &CLSID_HotfixOCX>
{
public:
	CHotfixOCX()
	{
		m_bWindowOnly = TRUE;
		_tcscpy(ComputerName,_T("\0"));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_HOTFIXOCX)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHotfixOCX)
	COM_INTERFACE_ENTRY(IHotfixOCX)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CHotfixOCX)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("Font", DISPID_FONT, CLSID_StockFontPage)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CHotfixOCX)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CHotfixOCX)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_NOTIFY,OnNotify)
	MESSAGE_HANDLER(WM_COMMAND,OnCommand)
	MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
	CHAIN_MSG_MAP(CComControl<CHotfixOCX>)
	DEFAULT_REFLECTION_HANDLER()

END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&IID_IHotfixOCX,
		};
		for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
		{
		//	if (InlineIsEqualGUID(*arr[i], riid))
				return S_OK;
		}
		return S_FALSE;
	} 

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IHotfixOCX
public:
	STDMETHOD(get_CurrentState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_HaveHotfix)(/*[out, retval]*/ BOOL*pVal);
	STDMETHOD(get_Remoted)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(get_ViewState)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_ProductName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ProductName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ComputerName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ComputerName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Command)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Command)(/*[in]*/ long newVal);

	ShowWebPage(_TCHAR *HotFix);

	BOOL CreateButton( HINSTANCE hInst, HWND hWnd,RECT* rc);
	BOOL ResizeButtons(RECT *rc);
	HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

		HBRUSH hBrush = GetSysColorBrush (COLOR_BTNFACE );
		
		FillRect (di.hdcDraw, &rc, hBrush);
		SelectObject(di.hdcDraw, hBrush);
		DeleteObject (hBrush);

		return S_OK;
	}
	CComPtr<IFontDisp> m_pFont;
	CListViews ListViews;
	  HWND WebButton;
	   HWND UninstButton;
	   HWND RptButton;
	_TCHAR ComputerName[256];
	BOOL m_bInitComplete;
	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		_TCHAR TempName[255];
		DWORD dwLength = 255;
		m_bInitComplete = FALSE;
		// TODO : Add Code for message handler. Call DefWindowProc if necessary.
		RECT rc;
		GetClientRect(&rc);
		CreateButton(_Module.GetModuleInstance(),m_hWnd,&rc);
		::EnableWindow( WebButton,FALSE);
		::EnableWindow(UninstButton,FALSE);
		ListViews.Initialize(m_hWnd, _Module.GetModuleInstance(),ComputerName,
			WebButton, UninstButton, RptButton);
		ListViews.ShowLists(&rc);
        GetComputerName(TempName, &dwLength);
//		MessageBox(TempName, ComputerName,MB_OK);
	
	
		m_bInitComplete = TRUE;
		return 0;
	}

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		RECT rc;
		rc.top = 0;
		rc.left = 0;
		rc.right = LOWORD(lParam);
		rc.bottom = HIWORD(lParam);
		// TODO : Add Code for message handler. Call DefWindowProc if necessary.
		ListViews.Resize(&rc);
		ResizeButtons(&rc);
		return 0;
	}
	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return ListViews.OnNotify( uMsg, wParam,  lParam, bHandled,m_hWnd);
	}





	LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
	  
		 switch (HIWORD (wParam))
		 {
			 case BN_CLICKED:
			 if ( WebButton == (HWND)lParam)
			 {
				ShowWebPage(ListViews.GetCurrentHotfix());
				return 0;
			 }
			 else if (UninstButton == (HWND)lParam)
			 {
				 ListViews.Uninstall();
			}
			 else if (RptButton == (HWND)lParam)
			 {
				 ListViews.PrintReport();
			 }
				break;
		 }


		 switch (LOWORD (wParam))
		 {
		 case IDM_VIEW_WEB:
			  ShowWebPage(ListViews.GetCurrentHotfix());
			 break;
		 case IDM_UNINSTALL:
			 
			 ListViews.Uninstall();
			 break;
		 case IDM_EXPORT_LIST:
			 	ListViews.SaveToCSV();
			 break;
		 case IDM_VIEW_FILE:
			  ListViews.SetViewMode(VIEW_BY_FILE);
			  break;
		 case IDM_VIEW_HOTFIX:
			 ListViews.SetViewMode(VIEW_BY_HOTFIX);
			 break;
		 case ID_CONTEXTMENU_PRINT:
			 ListViews.PrintReport();
			 break;

		 }

		bHandled = FALSE;
		return 0;
	}
	LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		// TODO : Add Code for message handler. Call DefWindowProc if necessary.
		HMENU hMenuLoad,
		hMenu;

		DWORD dwCurrentState =0;
		hMenuLoad = LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_MENU1));
		
		hMenu = GetSubMenu(hMenuLoad, 0);
         
		 dwCurrentState = ListViews.GetState ();
		 if (!(dwCurrentState&UNINSTALL_OK) )
		           ::EnableMenuItem(hMenu,IDM_UNINSTALL,MF_BYCOMMAND | MF_GRAYED);
		 if (!(dwCurrentState&HOTFIX_SELECTED))
		 {
				   ::EnableMenuItem(hMenu,IDM_VIEW_WEB,MF_BYCOMMAND | MF_GRAYED);
		 }

		 if ( ! (dwCurrentState & DATA_TO_SAVE))
		 {
					::EnableMenuItem(hMenu,IDM_EXPORT_LIST,MF_BYCOMMAND | MF_GRAYED);
					
		 }
		 if (! (dwCurrentState & OK_TO_PRINT))
					::EnableMenuItem(hMenu,ID_CONTEXTMENU_PRINT,MF_BYCOMMAND | MF_GRAYED);

		 
		 if ( dwCurrentState & STATE_VIEW_FILE)
		 {
			 ::CheckMenuItem(hMenu, IDM_VIEW_FILE, MF_BYCOMMAND|MF_CHECKED);
			 ::CheckMenuItem(hMenu, IDM_VIEW_HOTFIX, MF_BYCOMMAND|MF_UNCHECKED);
		 }
		 else
		 {
			 ::CheckMenuItem(hMenu, IDM_VIEW_HOTFIX, MF_BYCOMMAND|MF_CHECKED);
			 ::CheckMenuItem(hMenu, IDM_VIEW_FILE, MF_BYCOMMAND|MF_UNCHECKED);
		 }
		 
		TrackPopupMenu(   hMenu,
                  TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                  GET_X_LPARAM(lParam),
                  GET_Y_LPARAM(lParam),
                  0,
                  m_hWnd,
                  NULL);

		DestroyMenu(hMenuLoad);

		return 0;
	}

};


#endif //__HOTFIXOCX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HotfixManager.rc
//
#define UNINSTALL_OK                    1
#define HOTFIX_SELECTED                 2
#define IS_REMOTED                      4
#define DATA_TO_SAVE                    8
#define OK_TO_PRINT                     16
#define STATE_VIEW_FILE                 32
#define STATE_VIEW_HOTFIX               64
#define IDS_PROJNAME                    100
#define IDB_HOTFIXOCX                   101
#define IDR_HOTFIXOCX                   102
#define IDR_MENU1                       201
#define IDC_RPT_BUTTON                  998
#define IDC_UNINST_BUTTON               999
#define VIEW_BY_FILE                    1000
#define IDC_WEB_BUTTON                  1000
#define VIEW_BY_HOTFIX                  1001
#define VIEW_FILE_INFO                  1002
#define VIEW_HOTFIX_INFO                1003
#define VIEW_ALL_FILE                   1004
#define VIEW_ALL_HOTFIX                 1005
#define IDC_VIEW_WEB                    2000
#define IDC_VIEW_BY_FILE                2001
#define IDC_VIEW_BY_HOTFIX              2002
#define IDC_UNINSTALL                   2003
#define IDC_REFRESH                     2004
#define IDC_EXPORT                      2005
#define IDC_PRINT_REPORT                2006
#define IDS_ARTICLE_NUMBER              32767
#define IDM_VIEW_FILE                   32768
#define IDM_VIEW_HOTFIX                 32769
#define IDM_GENERATE_REPORT             32770
#define IDM_VIEW_WEB                    32771
#define IDM_UNINSTALL                   32772
#define ID_CONTEXTMENU                  32773
#define IDS_PRODUCT_NAME                32774
#define ID_CONTEXTMENU_PRINT            32774
#define IDS_INSTALLED_BY                32775
#define IDM_EXPORT_LIST                 32775
#define IDS_DESCRIPTION                 32776
#define IDS_INSTALL_DATE                32777
#define IDS_SERVICE_PACK                32778
#define IDS_UPDATE_TYPE                 32779
#define IDS_FILE_NAME                   32780
#define IDS_FILE_CURRENT                32781
#define IDS_FILE_DATE                   32782
#define IDS_FILE_VERSION                32783
#define IDS_BN_VIEW_WEB                 32784
#define IDS_BN_UNINSTALL                32785
#define IDS_BN_PRINT_REPORT             32786
#define IDS_FILE_LOCATION               32787
#define IDS_RETRIEVE_DATA               32788
#define IDS_CSV_HEADER                  32789
#define IDS_NO_ITEMS                    32790
#define IDS_UNINSTALL_WRN               32791
#define IDS_UNINSTAL_WRN                32791
#define IDS_UNINSTAL_WRN_TITLE          32792
#define IDS_FILE_TITLE                  32793
#define IDS_NO_FILES                    32794
#define IDS_UPDATE_REPORT               32795
#define IDS_FILE                        32796
#define IDS_FILEVERSION                 32797
#define IDS_FILEDATE                    32798
#define IDS_FILEPATH                    32799
#define IDS_FILECURRENT                 32800
#define IDS_YES                         32801
#define IDS_NO                          32802

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\hotfixmanager.cpp ===
// HotfixManager.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f HotfixManagerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "HotfixManager.h"

#include "HotfixManager_i.c"
#include "HotfixOCX.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_HotfixOCX, CHotfixOCX)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HOTFIXMANAGERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\hotfixmanager_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Feb 16 13:06:19 2000
 */
/* Compiler settings for E:\HotfixManager\HotfixManager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IHotfixOCX = {0x692E94C7,0xA5AC,0x401B,{0xA4,0x71,0xBC,0xD1,0x01,0xB4,0x56,0xF4}};


const IID LIBID_HOTFIXMANAGERLib = {0x8384D1FB,0xF41D,0x4540,{0xB0,0xCA,0xC0,0x26,0xDA,0x83,0x64,0xBD}};


const IID DIID__IHotfixOCXEvents = {0x7E2DCE25,0xE11D,0x45D6,{0x9A,0xE7,0xAD,0x52,0x2D,0x91,0x5F,0xFC}};


const CLSID CLSID_HotfixOCX = {0x883B970F,0x690C,0x45F2,{0x8A,0x3A,0xF4,0x28,0x3E,0x07,0x81,0x18}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\hotfixocx.cpp ===
// HotfixOCX.cpp : Implementation of CHotfixOCX

#include "stdafx.h"
#include "HotfixManager.h"
#include "HotfixOCX.h"
#include <Windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <comdef.h>


/////////////////////////////////////////////////////////////////////////////
// CHotfixOCX
BOOL CHotfixOCX::ResizeButtons(RECT *rc)
{


	::MoveWindow(WebButton, 
            rc->left+40,
            rc->bottom - 40,
            100,
			28,
            TRUE);
	::MoveWindow(UninstButton,
			rc->left+180,
			rc->bottom - 40,
            100,
            28,
            TRUE);
	::MoveWindow(RptButton,
			rc->left+320,
			rc->bottom - 40,
            100,
            28,
            TRUE);

	return TRUE;
}
BOOL CHotfixOCX::CreateButton( HINSTANCE hInst, HWND hWnd, RECT * rc)							
{

	_TCHAR       Temp[255];
	DWORD        dwSize = 255;
	BOOL        bSuccess = TRUE;
	
	LoadString(hInst,IDS_BN_VIEW_WEB, Temp,dwSize);
	WebButton = CreateWindow (_T("button"), Temp,WS_CHILD | BS_DEFPUSHBUTTON|WS_VISIBLE,0,0,0,0,hWnd,(HMENU) IDC_WEB_BUTTON,hInst,NULL);
	LoadString(hInst,IDS_BN_UNINSTALL, Temp,dwSize);

	UninstButton = CreateWindow (_T("button"), Temp,WS_CHILD | BS_PUSHBUTTON|WS_VISIBLE,0,0,0,0,hWnd,(HMENU) IDC_UNINST_BUTTON,hInst,NULL);
	LoadString(hInst,IDS_BN_PRINT_REPORT, Temp,dwSize);

	RptButton = CreateWindow (_T("button"), Temp,WS_CHILD | BS_PUSHBUTTON|WS_VISIBLE,0,0,0,0,hWnd,(HMENU) IDC_RPT_BUTTON,hInst,NULL);

/*	if(!hButton)
	   return NULL;*/
    NONCLIENTMETRICS ncm;
	HFONT hFont;

		ncm.cbSize = sizeof(ncm);
		SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof (ncm),&ncm,0);
	
	//	_tcscpy(ncm.lfMenuFont.lfFaceName,_T("MS Shell Dlg"));
		 // = _T("MS Shell Dlg");
		hFont = CreateFontIndirect(&ncm.lfMenuFont);
		
	SendMessage(WebButton,WM_SETFONT, (WPARAM)hFont ,MAKELPARAM(TRUE, 0));
	SendMessage(UninstButton,WM_SETFONT, (WPARAM)hFont ,MAKELPARAM(TRUE, 0));
	SendMessage(RptButton,WM_SETFONT, (WPARAM)hFont ,MAKELPARAM(TRUE, 0));

	
//	MessageBox(NULL,_T("Got the Button Created"),_T(""),MB_OK);
	ResizeButtons(rc);
	return TRUE;
}

BOOL CHotfixOCX::ShowWebPage(_TCHAR *HotFix)
{
    char temp[255];
	char Command[255];	
	if (_tcscmp(HotFix,_T("\0")))
	{
		wcstombs(temp,HotFix,255);
        sprintf(Command, "Explorer.exe \"http://Support.Microsoft.com/Support/Misc/KbLookup.asp?ID=%s\"",  temp+1);
		 //MessageBox(Command,NULL,MB_OK);
		WinExec( (char*)Command, SW_SHOWNORMAL);
	}
	return TRUE;
}

STDMETHODIMP CHotfixOCX::get_Command(long *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CHotfixOCX::put_Command(long newVal)
{
	// TODO: Add your implementation code here
	switch (newVal)
	{
	case IDC_VIEW_BY_FILE:
		// Change the current view type to by file.
		ListViews.SetViewMode(VIEW_BY_FILE);
		break;
	case IDC_VIEW_BY_HOTFIX:
	    // Change the current view type to by hotfix
		ListViews.SetViewMode(VIEW_BY_HOTFIX);
		break;
	case IDC_UNINSTALL:
		// Uninstall the current hotfix if pointing at the local system
		ListViews.Uninstall();
		break;
	
	case IDC_VIEW_WEB:
		// View the web page for the current hotfix
		ShowWebPage(ListViews.GetCurrentHotfix());
		break;
		
	case IDC_EXPORT:
			ListViews.SaveToCSV();

        	// Generate a report for the current system
		break;
	case IDC_PRINT_REPORT:
			ListViews.PrintReport();
		break; 
	}
 	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_ComputerName(BSTR *pVal)
{
	// TODO: Add your implementation code here
	// Return the name of the current target computer.
	return S_OK;
}

STDMETHODIMP CHotfixOCX::put_ComputerName(BSTR newVal)
{
	// TODO: Add your implementation code here
	// Set the name of the target computer.
	//_bstr_t Val(newVal,FALSE);
	_tcscpy(ComputerName,newVal);

	ListViews.Initialize(ComputerName);
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_ProductName(BSTR *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CHotfixOCX::put_ProductName(BSTR newVal)
{
	_TCHAR Temp[255];
	// TODO: Add your implementation code here
	// Set the name of the current producted selected in the snap-in scope tree.
//	_bstr_t Val(newVal,FALSE);
    _tcscpy (Temp,newVal);
	
//	MessageBox(Temp,_T("Recieved....."),MB_OK);
	ListViews.SetProductName(Temp);
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_ViewState(long *pVal)
{
	// TODO: Add your implementation code here
	*pVal = ListViews.GetCurrentView();
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_Remoted(BOOL *pVal)
{
	// TODO: Add your implementation code here
	*pVal = ListViews.m_bRemoted;
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_HaveHotfix(BOOL *pVal)
{
	// TODO: Add your implementation code here
	if (_tcscmp( ListViews.m_CurrentHotfix, _T("\0")))
		*pVal = TRUE;
	else
		*pVal = FALSE;
	return S_OK;
}

STDMETHODIMP CHotfixOCX::get_CurrentState(long *pVal)
{
	// TODO: Add your implementation code here
    *pVal = ListViews.GetState();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\hotfixmanager_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Feb 16 13:06:19 2000
 */
/* Compiler settings for E:\HotfixManager\HotfixManager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "HotfixManager.h"

#define TYPE_FORMAT_STRING_SIZE   81                                
#define PROC_FORMAT_STRING_SIZE   365                               

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IHotfixOCX, ver. 0.0,
   GUID={0x692E94C7,0xA5AC,0x401B,{0xA4,0x71,0xBC,0xD1,0x01,0xB4,0x56,0xF4}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IHotfixOCX_ServerInfo;

#pragma code_seg(".orpc")
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short IHotfixOCX_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    28,
    56,
    84,
    112,
    140,
    168,
    196,
    224,
    252,
    280,
    308,
    336
    };

static const MIDL_SERVER_INFO IHotfixOCX_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IHotfixOCX_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IHotfixOCX_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IHotfixOCX_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(20) _IHotfixOCXProxyVtbl = 
{
    &IHotfixOCX_ProxyInfo,
    &IID_IHotfixOCX,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* IHotfixOCX::putref_Font */ ,
    (void *)-1 /* IHotfixOCX::put_Font */ ,
    (void *)-1 /* IHotfixOCX::get_Font */ ,
    (void *)-1 /* IHotfixOCX::get_Command */ ,
    (void *)-1 /* IHotfixOCX::put_Command */ ,
    (void *)-1 /* IHotfixOCX::get_ComputerName */ ,
    (void *)-1 /* IHotfixOCX::put_ComputerName */ ,
    (void *)-1 /* IHotfixOCX::get_ProductName */ ,
    (void *)-1 /* IHotfixOCX::put_ProductName */ ,
    (void *)-1 /* IHotfixOCX::get_ViewState */ ,
    (void *)-1 /* IHotfixOCX::get_Remoted */ ,
    (void *)-1 /* IHotfixOCX::get_HaveHotfix */ ,
    (void *)-1 /* IHotfixOCX::get_CurrentState */
};


static const PRPC_STUB_FUNCTION IHotfixOCX_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IHotfixOCXStubVtbl =
{
    &IID_IHotfixOCX,
    &IHotfixOCX_ServerInfo,
    20,
    &IHotfixOCX_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[1] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute, more than 32 methods in the interface.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure putref_Font */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pFont */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 18 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 24 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Font */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 36 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pFont */

/* 44 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 46 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 48 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 52 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Font */

/* 56 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 64 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 66 */	NdrFcShort( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x8 ),	/* 8 */
/* 70 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppFont */

/* 72 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
#ifndef _ALPHA_
/* 74 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 76 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Return value */

/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 80 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Command */

/* 84 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
/* 90 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 92 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x10 ),	/* 16 */
/* 98 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 100 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 102 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 108 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_Command */

/* 112 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 120 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 122 */	NdrFcShort( 0x8 ),	/* 8 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter newVal */

/* 128 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 130 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 134 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 136 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 138 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ComputerName */

/* 140 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 142 */	NdrFcLong( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 148 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 152 */	NdrFcShort( 0x8 ),	/* 8 */
/* 154 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 156 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 158 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 160 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 164 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ComputerName */

/* 168 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 176 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter newVal */

/* 184 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 186 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 188 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 190 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 192 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 194 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ProductName */

/* 196 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 198 */	NdrFcLong( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 204 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 212 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 214 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 216 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 220 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure put_ProductName */

/* 224 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 232 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 238 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter newVal */

/* 240 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 242 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 244 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 246 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 248 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_ViewState */

/* 252 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 254 */	NdrFcLong( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 260 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x10 ),	/* 16 */
/* 266 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 268 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 270 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 272 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 274 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 276 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 278 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_Remoted */

/* 280 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 286 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 288 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 290 */	NdrFcShort( 0x0 ),	/* 0 */
/* 292 */	NdrFcShort( 0x10 ),	/* 16 */
/* 294 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 296 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 298 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 300 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 302 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 304 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 306 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_HaveHotfix */

/* 308 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 310 */	NdrFcLong( 0x0 ),	/* 0 */
/* 314 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 316 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 320 */	NdrFcShort( 0x10 ),	/* 16 */
/* 322 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 324 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 326 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 330 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 332 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 334 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_CurrentState */

/* 336 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcShort( 0x13 ),	/* 19 */
#ifndef _ALPHA_
/* 344 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x10 ),	/* 16 */
/* 350 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pVal */

/* 352 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 354 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 358 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 360 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 362 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0xbef6e003 ),	/* -1091117053 */
/*  8 */	NdrFcShort( 0xa874 ),	/* -22412 */
/* 10 */	NdrFcShort( 0x101a ),	/* 4122 */
/* 12 */	0x8b,		/* 139 */
			0xba,		/* 186 */
/* 14 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 16 */	0x0,		/* 0 */
			0x30,		/* 48 */
/* 18 */	0xc,		/* 12 */
			0xab,		/* 171 */
/* 20 */	
			0x11, 0x10,	/* FC_RP */
/* 22 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (2) */
/* 24 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 26 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 30 */	NdrFcShort( 0x1a ),	/* Offset= 26 (56) */
/* 32 */	
			0x13, 0x0,	/* FC_OP */
/* 34 */	NdrFcShort( 0xc ),	/* Offset= 12 (46) */
/* 36 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 38 */	NdrFcShort( 0x2 ),	/* 2 */
/* 40 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 42 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 44 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 46 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
/* 50 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (36) */
/* 52 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x4 ),	/* 4 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (32) */
/* 66 */	
			0x12, 0x0,	/* FC_UP */
/* 68 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (46) */
/* 70 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x4 ),	/* 4 */
/* 76 */	NdrFcShort( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (66) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _HotfixManager_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IHotfixOCXProxyVtbl,
    0
};

const CInterfaceStubVtbl * _HotfixManager_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IHotfixOCXStubVtbl,
    0
};

PCInterfaceName const _HotfixManager_InterfaceNamesList[] = 
{
    "IHotfixOCX",
    0
};

const IID *  _HotfixManager_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _HotfixManager_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _HotfixManager, pIID, n)

int __stdcall _HotfixManager_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_HotfixManager_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo HotfixManager_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _HotfixManager_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _HotfixManager_StubVtblList,
    (const PCInterfaceName * ) & _HotfixManager_InterfaceNamesList,
    (const IID ** ) & _HotfixManager_BaseIIDList,
    & _HotfixManager_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "HotfixManager_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__186FC3A7_559D_4DB6_9E45_F0CEAEF2D00C__INCLUDED_)
#define AFX_DLLDATAX_H__186FC3A7_559D_4DB6_9E45_F0CEAEF2D00C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__186FC3A7_559D_4DB6_9E45_F0CEAEF2D00C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\ocx\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D0136A53_0029_4990_8249_8E89D9963E8B__INCLUDED_)
#define AFX_STDAFX_H__D0136A53_0029_4990_8249_8E89D9963E8B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D0136A53_0029_4990_8249_8E89D9963E8B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\hotfixmanager.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for hotfixmanager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __hotfixmanager_h__
#define __hotfixmanager_h__

/* Forward Declarations */ 

#ifndef __Hotfix_Manager_FWD_DEFINED__
#define __Hotfix_Manager_FWD_DEFINED__

#ifdef __cplusplus
typedef class Hotfix_Manager Hotfix_Manager;
#else
typedef struct Hotfix_Manager Hotfix_Manager;
#endif /* __cplusplus */

#endif 	/* __Hotfix_Manager_FWD_DEFINED__ */


#ifndef __Hotfix_ManagerAbout_FWD_DEFINED__
#define __Hotfix_ManagerAbout_FWD_DEFINED__

#ifdef __cplusplus
typedef class Hotfix_ManagerAbout Hotfix_ManagerAbout;
#else
typedef struct Hotfix_ManagerAbout Hotfix_ManagerAbout;
#endif /* __cplusplus */

#endif 	/* __Hotfix_ManagerAbout_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __HOTFIXMANAGERLib_LIBRARY_DEFINED__
#define __HOTFIXMANAGERLib_LIBRARY_DEFINED__

/* library HOTFIXMANAGERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HOTFIXMANAGERLib;

EXTERN_C const CLSID CLSID_Hotfix_Manager;

#ifdef __cplusplus

class DECLSPEC_UUID("E810E1EB-6B52-45D0-AB07-FB4B04392AB4")
Hotfix_Manager;
#endif

EXTERN_C const CLSID CLSID_Hotfix_ManagerAbout;

#ifdef __cplusplus

class DECLSPEC_UUID("4F0EBD75-DA9D-4D09-8A2E-9AF1D6E02511")
Hotfix_ManagerAbout;
#endif
#endif /* __HOTFIXMANAGERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\hotfix_manager.cpp ===
#include "stdafx.h"
#include "HotfixManager.h"
#include "Hotfix_Manager.h"
#ifndef DNS_MAX_NAME_LENGTH
#define DNS_MAX_NAME_LENGTH 255
#endif

#define   REMOTE_STATE 0
#define   HOTFIX_STATE 1

static CRITICAL_SECTION CritSec;

BSTR CHotfix_ManagerData::m_bstrColumnType;
BSTR CHotfix_ManagerData::m_bstrColumnDesc;
static CComPtr<IDispatch> gpDisp = NULL;




/////////////////////////////////////////////////////////////////////////////
// CHotfix_ManagerComponentData
static const GUID CHotfix_ManagerGUID_NODETYPE = 
{ 0x2315305b, 0x3abe, 0x4c07, { 0xaf, 0x6e, 0x95, 0xdc, 0xa4, 0x82, 0x5b, 0xdd } };
const GUID*  CHotfix_ManagerData::m_NODETYPE = &CHotfix_ManagerGUID_NODETYPE;
const OLECHAR* CHotfix_ManagerData::m_SZNODETYPE = OLESTR("2315305B-3ABE-4C07-AF6E-95DCA4825BDD");
const OLECHAR* CHotfix_ManagerData::m_SZDISPLAY_NAME = OLESTR("Hotfix_Manager");
const CLSID* CHotfix_ManagerData::m_SNAPIN_CLASSID = &CLSID_Hotfix_Manager;

static const GUID CHotfix_ManagerExtGUID_NODETYPE = 
{ 0x476e6448, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
const GUID*  CHotfix_ManagerExtData::m_NODETYPE = &CHotfix_ManagerExtGUID_NODETYPE;
const OLECHAR* CHotfix_ManagerExtData::m_SZNODETYPE = OLESTR("476e6448-aaff-11d0-b944-00c04fd8d5b0");
const OLECHAR* CHotfix_ManagerExtData::m_SZDISPLAY_NAME = OLESTR("Hotfix_Manager");
const CLSID* CHotfix_ManagerExtData::m_SNAPIN_CLASSID = &CLSID_Hotfix_Manager;



CHotfix_Manager::CHotfix_Manager()
	{
	
		
	
		DWORD dwSize = 255;
		GetComputerName(m_szComputerName,&dwSize);
		InitializeCriticalSection(&CritSec);
//		m_pNode = new CHotfix_ManagerData(NULL ,m_szComputerName, FALSE);
//		_ASSERTE(m_pNode != NULL);
		m_pComponentData = this;
		RegisterRemotedClass();
	}
HRESULT CHotfix_ManagerData::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
	if (pScopeDataItem->mask & SDI_STR)
		pScopeDataItem->displayname = m_bstrDisplayName;
	if (pScopeDataItem->mask & SDI_IMAGE)
		pScopeDataItem->nImage = m_scopeDataItem.nImage;
	if (pScopeDataItem->mask & SDI_OPENIMAGE)
		pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
	if (pScopeDataItem->mask & SDI_PARAM)
		pScopeDataItem->lParam = m_scopeDataItem.lParam;
	if (pScopeDataItem->mask & SDI_STATE )
		pScopeDataItem->nState = m_scopeDataItem.nState;

	// TODO : Add code for SDI_CHILDREN 
	if (pScopeDataItem->mask & SDI_CHILDREN )
		pScopeDataItem->cChildren = 0;
	return S_OK;
}

HRESULT CHotfix_ManagerData::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
	if (pResultDataItem->bScopeItem)
	{
		if (pResultDataItem->mask & RDI_STR)
		{
			pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
		}
		if (pResultDataItem->mask & RDI_IMAGE)
		{
			pResultDataItem->nImage = m_scopeDataItem.nImage;
		}
		if (pResultDataItem->mask & RDI_PARAM)
		{
			pResultDataItem->lParam = m_scopeDataItem.lParam;
		}

		return S_OK;
	}

	if (pResultDataItem->mask & RDI_STR)
	{
		pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
	}
	if (pResultDataItem->mask & RDI_IMAGE)
	{
		pResultDataItem->nImage = m_resultDataItem.nImage;
	}
	if (pResultDataItem->mask & RDI_PARAM)
	{
		pResultDataItem->lParam = m_resultDataItem.lParam;
	}
	if (pResultDataItem->mask & RDI_INDEX)
	{
		pResultDataItem->nIndex = m_resultDataItem.nIndex;
	}

	return S_OK;
}
HRESULT CHotfix_Manager::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
	HRESULT hr = E_UNEXPECTED;

	if (lpDataObject != NULL)
	{
			switch ( event )
			{
			
			case MMCN_EXPAND:
				{
					//
					// Process out the local or machine name if we're expanding.
					//
					if (arg == TRUE)
						{
						
						
							
							if (	ExtractString( lpDataObject,  m_ccfRemotedFormat, m_szComputerName, DNS_MAX_NAME_LENGTH + 1 ) )
							{
								if (!_tcscmp (m_szComputerName,_T("\0")))
								{
									DWORD dwSize = 255;
									GetComputerName(m_szComputerName,&dwSize);
								}
									
								
							}
							else
							{
								DWORD dwSize = 255;
								GetComputerName(m_szComputerName,&dwSize);
							}
						
						if (	_tcscmp (gszComputerName, m_szComputerName) )
						{
//								MessageBox (NULL,_T("Setting Computername sent to false"), _T("Main Data Notify"),MB_OK);
							ComputerNameSent = FALSE;
							_tcscpy (gszComputerName,m_szComputerName);
							
						
						}
					//
					// Intentionally left to fall through to default handler.
					//
				}
					
				}
				default:
				{
					//
					// Call our default handling.
					//
					hr = IComponentDataImpl<CHotfix_Manager, CHotfix_ManagerComponent>::Notify( lpDataObject, event, arg, param );
				}
			}
	}
	return( hr );
}

HRESULT CHotfix_ManagerData::Notify( MMC_NOTIFY_TYPE event,
    long arg,
    long param,
	IComponentData* pComponentData,
	IComponent* pComponent,
	DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.
	HRESULT hr = E_NOTIMPL;

	
	_ASSERTE(pComponentData != NULL || pComponent != NULL);

	CComPtr<IConsole> spConsole;
	CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
	if (pComponentData != NULL)
		spConsole = ((CHotfix_Manager*)pComponentData)->m_spConsole;
	else
	{
		spConsole = ((CHotfix_ManagerComponent*)pComponent)->m_spConsole;
		spHeader = spConsole;
	}

	switch (event)
	{
	case MMCN_INITOCX:
		{
//		MessageBox(NULL,_T("Recieved init OCX"),NULL,MB_OK);
		CComQIPtr<IDispatch,&IID_IDispatch> pDisp = (IUnknown *) param;
		gpDisp = pDisp;
//		MessageBox(NULL,m_szComputerName,_T("Init Ocx Sending"),MB_OK);
		SendComputerName(m_szComputerName, gpDisp);
//		MessageBox(NULL,_T("Setting ComputerNameSent to TRUE"),_T("ManagerData::Notify"),MB_OK);
		ComputerNameSent = TRUE;
		break;
		}

/*	case MMCN_CONTEXTHELP:
		{
			CComQIPtr<IDisplayHelp,&IID_IDisplayHelp> spHelp = spConsole;
			spHelp->ShowTopic(CoTaskDupString(OLESTR("snapsamp.chm::/default.htm")));
			hr = S_OK;
		}
		break;
*/
	case MMCN_SHOW:
		{
			
			if (arg == TRUE)
			{
				
				IUnknown *pUnk;
				if (gpDisp == NULL)
				{
					CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);
					spConsole->QueryResultView(&pUnk);
					CComQIPtr<IDispatch,&IID_IDispatch> pDisp = pUnk;
					gpDisp = pDisp;
				}
				EnterCriticalSection(&CritSec);

				if (!ComputerNameSent)
				{
						SendComputerName(m_szComputerName,gpDisp);
//						MessageBox(NULL,_T("Setting SentComputerName to TRUE:"), _T("ManagerData::Notify, Show"), MB_OK);
						ComputerNameSent = TRUE;
//					MessageBox(NULL,m_szComputerName,_T("Show Sending"),MB_OK);
				}
				LeaveCriticalSection(&CritSec);
				EnterCriticalSection(&CritSec);
					SendProductName(m_ProductName,gpDisp);
				LeaveCriticalSection(&CritSec);

			}
			hr = S_OK;
			break;
		}
	case MMCN_EXPAND:
		{
			HKEY hKLM = NULL;
	        HKEY hKey = NULL;
			DWORD dwProductIndex = 0;
			_TCHAR szProductName[255];
			DWORD dwBufferSize = 255;

			if (arg == TRUE)
			{
				gszManagerCtlDispatch = (IDispatch *) NULL;
				//SendProductName(m_ProductName);
			
				if ( !m_bChild)
				{

				
					if (!ComputerNameSent)
					{
//						MessageBox(NULL,_T("Expand Determining New ComputerName"),NULL,MB_OK);
//				        MessageBox(NULL,m_szComputerName,gszComputerName,MB_OK);
					
					    //_tcscpy(m_szComputerName,gszComputerName);
					
						b_Expanded = FALSE;
					}
					
				}
				if (  ( !m_bChild) && (!b_Expanded))
				{
					b_Expanded =TRUE;
				// open the updates registry key and enumerate the children
//				MessageBox(NULL,m_szComputerName,_T("Expand Connecting to "),MB_OK);
				RegConnectRegistry(m_szComputerName,HKEY_LOCAL_MACHINE,&hKLM);
				if (hKLM != NULL)
				{
					RegOpenKeyEx(hKLM,_T("SOFTWARE\\MICROSOFT\\UPDATES"),0,KEY_READ,&hKey);
					if (hKey != NULL)
					{
						dwProductIndex = 0;
						while (RegEnumKeyEx(hKey, dwProductIndex,szProductName, &dwBufferSize,0,NULL,NULL,NULL) != ERROR_NO_MORE_ITEMS)
						{
							CSnapInItem* m_pNode;
							CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
							// TODO : Enumerate scope pane items
							SCOPEDATAITEM *pScopeData;
							
//							MessageBox(NULL,szProductName,_T("Creating node"),MB_OK);
//							MessageBox(NULL, m_szComputerName,_T("With computer Name"),MB_OK);
							m_pNode = new CHotfix_ManagerData( szProductName,m_szComputerName, TRUE);
							m_pNode->GetScopeData( &pScopeData );
							pScopeData->cChildren = 0;
							pScopeData->relativeID = param;
							spConsoleNameSpace->InsertItem( pScopeData );

							_tcscpy(szProductName,_T("\0"));
							++dwProductIndex;
							dwBufferSize = 255;
						}
						RegCloseKey(hKey);
						RegCloseKey(hKLM);
					}
				}
//				SendProductName(m_ProductName);
				}
			
				//gf_NewComputer = FALSE;
		
			hr = S_OK;
			}
			break;
		}
	case MMCN_ADD_IMAGES:
		{
			// Add Images
			IImageList* pImageList = (IImageList*) arg;
			hr = E_FAIL;
			// Load bitmaps associated with the scope pane
			// and add them to the image list
			// Loads the default bitmaps generated by the wizard
			// Change as required
			HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HOTFIXMANAGER_16));
			if (hBitmap16 != NULL)
			{
				HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HOTFIXMANAGER_32));
				if (hBitmap32 != NULL)
				{
					hr = pImageList->ImageListSetStrip((long*)hBitmap16, 
					(long*)hBitmap32, 0, RGB(0, 128, 128));
					if (FAILED(hr))
						ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
				}
			}
			break;
		}
	}
	return hr;
}

LPOLESTR CHotfix_ManagerData::GetResultPaneColInfo(int nCol)
{
	//if (nCol == 0)
	//	return m_bstrDisplayName;
		LPOLESTR pStr = NULL;

	switch ( nCol )
	{
	case 0:
		pStr = m_bstrDisplayName;
		break;

	case 1:
		pStr = m_bstrColumnType;
		break;

	case 2:
		pStr = m_bstrColumnDesc;
		break;
	}

	_ASSERTE( pStr != NULL );
	return( pStr );
	// TODO : Return the text for other columns
//	return OLESTR("Override GetResultPaneColInfo");
}

HRESULT CHotfix_Manager::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CHotfix_Manager, CHotfix_ManagerComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HOTFIXMANAGER_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_HOTFIXMANAGER_32));
	if (hBitmap32 == NULL)
		return S_OK;

	if (spImageList->ImageListSetStrip((long*)hBitmap16, 
		(long*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}
	return S_OK;
}


//
// Retrieves the value of a given clipboard format from a given data object.
//
bool CHotfix_Manager::ExtractString( IDataObject* pDataObject, unsigned int cfClipFormat, LPTSTR pBuf, DWORD dwMaxLength)
{
    USES_CONVERSION;
	bool fFound = false;
    FORMATETC formatetc = { (CLIPFORMAT) cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    stgmedium.hGlobal = ::GlobalAlloc( GMEM_SHARE, dwMaxLength  * sizeof(TCHAR));
    HRESULT hr;

	do 
    {
		//
		// This is a memory error condition!
		//
        if ( NULL == stgmedium.hGlobal )
			break;

        hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
            break;

        LPWSTR pszNewData = reinterpret_cast<LPWSTR>( ::GlobalLock( stgmedium.hGlobal ) );
        if ( NULL == pszNewData )
            break;

        pszNewData[ dwMaxLength - 1 ] = L'\0';
        _tcscpy( pBuf, OLE2T( pszNewData ) );
		fFound = true;
    } 
	while( false );

    if ( NULL != stgmedium.hGlobal )
    {
        GlobalUnlock( stgmedium.hGlobal );
        GlobalFree( stgmedium.hGlobal );
    }
    _tcscpy (gszComputerName, pBuf);
	return( fFound );
}

//
// Determines if the enumeration is for a remoted machine or not.
//

bool CHotfix_Manager::IsDataObjectRemoted( IDataObject* pDataObject )
{
bool fRemoted = false;
    TCHAR szComputerName[ DNS_MAX_NAME_LENGTH + 1 ];
    DWORD dwNameLength = (DNS_MAX_NAME_LENGTH + 1) * sizeof(TCHAR);
	TCHAR szDataMachineName[ DNS_MAX_NAME_LENGTH + 1 ];

	//
	// Get local computer name.
	//
    GetComputerName(szComputerName, &dwNameLength);

	//
	// Get the machine name from the given data object.
	//
    if ( ExtractString( pDataObject,  m_ccfRemotedFormat, szDataMachineName, DNS_MAX_NAME_LENGTH + 1 ) )
	{
		_toupper( szDataMachineName );

		//
		// Find the start of the server name.
		//
		LPTSTR pStr = szDataMachineName;
		while ( pStr && *pStr == L'\\' )
			pStr++;

		//
		// Compare the server name.
		//
		if ( pStr && *pStr && wcscmp( pStr, szComputerName ) != 0 )
			fRemoted = true;
	}

	if (fRemoted)
		_tcscpy (m_szComputerName, szDataMachineName);
	else
		_tcscpy (m_szComputerName, szComputerName);
	return( fRemoted );
}

STDMETHODIMP  CHotfix_ManagerData::GetResultViewType ( LPOLESTR* ppViewType, long* pViewOptions )
{

	
	
		*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS; 

	*ppViewType = _T("{883B970F-690C-45F2-8A3A-F4283E078118}");
	 return S_OK;
}

/////////////////////////////////////////////////////
//
// Dispatch interface of the OCX  to send commands
//
/////////////////////////////////////////////////////
BOOL CHotfix_ManagerData::SendComputerName(_TCHAR *szDataMachineName, IDispatch * pDisp)
{
		HRESULT hr;


	// Ensure that we have a pointer to the  OCX
	if (pDisp == NULL ){
//		MessageBox(NULL,_T("Failed to send Message"),NULL,MB_OK);
			return( FALSE );
	}

	// get the  OCX dispatch interface
	CComPtr<IDispatch> pManagerCtlDispatch = pDisp;

	// get the ID of the "ComputerName" interface
	OLECHAR FAR* szMember = TEXT("ComputerName");  // maps this to "put_Command()"

	DISPID dispid;
	hr = pManagerCtlDispatch->GetIDsOfNames(
			IID_NULL,			// Reserved for future use. Must be IID_NULL.
			&szMember,			// Passed-in array of names to be mapped.
			1,					// Count of the names to be mapped.
			LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
			&dispid);			// Caller-allocated array

	if (!SUCCEEDED(hr)) {
//		MessageBox(NULL,_T("Failed to send Message"),NULL,MB_OK);
		return FALSE;
	}

	DISPID mydispid = DISPID_PROPERTYPUT;
	VARIANTARG* pvars = new VARIANTARG;
	

	VariantInit(&pvars[0]);
	BSTR NewVal( szDataMachineName);
	
	pvars[0].vt = VT_BSTR;
//	pvars[0].iVal = (short)lparamCommand;
	pvars[0].bstrVal = NewVal;
	DISPPARAMS disp = { pvars, &mydispid, 1, 1 };

	hr = pManagerCtlDispatch->Invoke(
			dispid, 				// unique number identifying the method to invoke
			IID_NULL,				// Reserved. Must be IID_NULL
			LOCALE_USER_DEFAULT,	// A locale ID
			DISPATCH_PROPERTYPUT,	// flag indicating the context of the method to invoke
			&disp,					// A structure with the parameters to pass to the method
			NULL,					// The result from the calling method
			NULL,					// returned exception information
			NULL);					// index indicating the first argument that is in error

	delete [] pvars;

	if (!SUCCEEDED(hr)) {
//		MessageBox(NULL,_T("Failed to send Message"),NULL,MB_OK);
		return FALSE;
	}
//	MessageBox(NULL,_T("Message sent"),NULL,MB_OK);
	return TRUE;
}

DWORD GetCtrlStatus()
{
		DISPID dispid;
	HRESULT hr;
	DWORD Status = 0;

	if ( gpDisp == NULL)
		return FALSE;
	// array of the interface names
	OLECHAR FAR* szMember[1] = {
		OLESTR("CurrentState")
	};
	
	hr = gpDisp->GetIDsOfNames(
			IID_NULL,			// Reserved for future use. Must be IID_NULL.
			&szMember[0],			// Passed-in array of names to be mapped.
			1/*INTERFACE_COUNT*/,					// Count of the names to be mapped.
			LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
			&dispid);			// Caller-allocated array (see help for details)

	if (!SUCCEEDED(hr)) {
//		MessageBox(NULL,_T("Failed to get Dispatch pointer"),NULL,MB_OK);
	
		return FALSE;
	}

	VARIANT varResult;
	VariantInit(&varResult);
	V_VT(&varResult) = VT_I2;
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

	hr = gpDisp->Invoke(
			dispid, 				// unique number identifying the method to invoke
			IID_NULL,				// Reserved. Must be IID_NULL
			LOCALE_USER_DEFAULT,	// A locale ID
			DISPATCH_PROPERTYGET,	// flag indicating the context of the method to invoke
			&dispparamsNoArgs,		// A structure with the parameters to pass to the method
			&varResult, 			// The result from the calling method
			NULL,					// returned exception information
			NULL);					// index indicating the first argument that is in error

		if (!SUCCEEDED(hr)) {
//			MessageBox(NULL,_T("Failed To Get Value"),NULL,MB_OK);
		return FALSE;
	}
		
//	 return  varResult.bVal;

	Status = varResult.lVal;
	//delete [] pvars;



	_TCHAR Message[100];
	_stprintf(Message,_T("%d"),Status);
//	MessageBox(NULL, Message, _T("Returned Status"),MB_OK);
	return Status;
	
}
BOOL CHotfix_ManagerData::SendProductName(_TCHAR *szProductName, IDispatch * pDisp)
{
		HRESULT hr;

	if ( pDisp == NULL ){
			return( FALSE );
	}

	// get the OCX dispatch interface
	CComPtr<IDispatch> pManagerCtlDispatch = pDisp;

	// get the ID of the "ComputerName" interface
	OLECHAR FAR* szMember = TEXT("ProductName");  // maps this to "put_Command()"

	DISPID dispid;
	hr = pManagerCtlDispatch->GetIDsOfNames(
			IID_NULL,			// Reserved for future use. Must be IID_NULL.
			&szMember,			// Passed-in array of names to be mapped.
			1,					// Count of the names to be mapped.
			LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
			&dispid);			// Caller-allocated array

	if (!SUCCEEDED(hr)) {
	//	MessageBox(NULL,_T("Failed to send Message"),NULL,MB_OK);
		return FALSE;
	}

	DISPID mydispid = DISPID_PROPERTYPUT;
	VARIANTARG* pvars = new VARIANTARG;
	

	VariantInit(&pvars[0]);
	BSTR NewVal( szProductName);
	
	pvars[0].vt = VT_BSTR;
//	pvars[0].iVal = (short)lparamCommand;
	pvars[0].bstrVal = NewVal;
	DISPPARAMS disp = { pvars, &mydispid, 1, 1 };

	hr = pManagerCtlDispatch->Invoke(
			dispid, 				// unique number identifying the method to invoke
			IID_NULL,				// Reserved. Must be IID_NULL
			LOCALE_USER_DEFAULT,	// A locale ID
			DISPATCH_PROPERTYPUT,	// flag indicating the context of the method to invoke
			&disp,					// A structure with the parameters to pass to the method
			NULL,					// The result from the calling method
			NULL,					// returned exception information
			NULL);					// index indicating the first argument that is in error

	delete [] pvars;

	if (!SUCCEEDED(hr)) {
		
		return FALSE;
	}

	return TRUE;
}
BOOL CHotfix_ManagerData::SendCommand(LPARAM lparamCommand)
{
	HRESULT hr;

	// Ensure that we have a pointer to the  OCX
	if ( gpDisp == NULL ){
			return( FALSE );
	}

	// get the OCX dispatch interface
	CComPtr<IDispatch> pManagerCtlDispatch = gpDisp;

	// get the ID of the "Command" interface
	OLECHAR FAR* szMember = TEXT("Command");  // maps this to "put_Command()"

	DISPID dispid;
	hr = pManagerCtlDispatch->GetIDsOfNames(
			IID_NULL,			// Reserved for future use. Must be IID_NULL.
			&szMember,			// Passed-in array of names to be mapped.
			1,					// Count of the names to be mapped.
			LOCALE_USER_DEFAULT,// The locale context in which to interpret the names.
			&dispid);			// Caller-allocated array

	if (!SUCCEEDED(hr)) {
		return FALSE;
	}

	DISPID mydispid = DISPID_PROPERTYPUT;
	VARIANTARG* pvars = new VARIANTARG;
	

	VariantInit(&pvars[0]);

	pvars[0].vt = VT_I2;
	pvars[0].iVal = (short)lparamCommand;
	DISPPARAMS disp = { pvars, &mydispid, 1, 1 };

	hr = pManagerCtlDispatch->Invoke(
			dispid, 				// unique number identifying the method to invoke
			IID_NULL,				// Reserved. Must be IID_NULL
			LOCALE_USER_DEFAULT,	// A locale ID
			DISPATCH_PROPERTYPUT,	// flag indicating the context of the method to invoke
			&disp,					// A structure with the parameters to pass to the method
			NULL,					// The result from the calling method
			NULL,					// returned exception information
			NULL);					// index indicating the first argument that is in error

	delete [] pvars;

	if (!SUCCEEDED(hr)) {
		
		return FALSE;
	}

	return TRUE;
}


///////////////////////////////////
// IExtendContextMenu::Command()
STDMETHODIMP CHotfix_ManagerData::Command(long lCommandID,		
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type)
{
	// Handle each of the commands.
	switch (lCommandID) {

	case ID_VIEW_BY_FILE:
//		MessageBox(NULL,_T("Sending View By File"),NULL,MB_OK);
		SendCommand(IDC_VIEW_BY_FILE);
		m_dwCurrentView = IDC_VIEW_BY_FILE;
		break;

	case ID_VIEW_BY_KB:
		SendCommand(IDC_VIEW_BY_HOTFIX);
		m_dwCurrentView = IDC_VIEW_BY_HOTFIX;
		break;

	case ID_UNINSTALL:
		SendCommand(IDC_UNINSTALL);
		break;

	case ID_VIEW_WEB:
		SendCommand(IDC_VIEW_WEB);
		break;

	case ID_PRINT_REPORT:
		SendCommand(IDC_PRINT_REPORT);
		break;
	case ID_EXPORT:
		SendCommand(IDC_EXPORT);
		break;



	default:
		break;
	}

	return S_OK;
}

HRESULT CHotfix_ManagerExtData::Notify( MMC_NOTIFY_TYPE event,
	long arg,
	long param,
	IComponentData* pComponentData,
	IComponent* pComponent,
	DATA_OBJECT_TYPES type)
{
	// Add code to handle the different notifications.
	// Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
	// In response to MMCN_SHOW you have to enumerate both the scope
	// and result pane items.
	// For MMCN_EXPAND you only need to enumerate the scope items
	// Use IConsoleNameSpace::InsertItem to insert scope pane items
	// Use IResultData::InsertItem to insert result pane item.

	HRESULT hr = E_NOTIMPL;
	bool fRemoted = false;

	_ASSERTE( pComponentData != NULL || pComponent != NULL );

	CComPtr<IConsole> spConsole;

	if ( pComponentData != NULL )
	{
		CHotfix_Manager* pExt = (CHotfix_Manager*) pComponentData;
		spConsole = pExt->m_spConsole;

		//
		// Determine if we're remoted.
		//
		fRemoted = pExt->IsRemoted();
	}
	else
	{
		spConsole = ( (CHotfix_ManagerComponent*) pComponent )->m_spConsole;
	}

	switch ( event )
	{
	case MMCN_SHOW:
		arg = arg;
		hr = S_OK;
		break;
	case MMCN_EXPAND:
		{
			if ( arg == TRUE )
			{
				CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
				SCOPEDATAITEM* pScopeData;
				DWORD dwSize = 255;
				if (!_tcscmp(gszComputerName,_T("\0")))
					GetComputerName(gszComputerName,&dwSize);
				m_pNode = new CHotfix_ManagerData( NULL,gszComputerName, FALSE);
				m_pNode->GetScopeData( &pScopeData );
				pScopeData->relativeID = param;
				spConsoleNameSpace->InsertItem( pScopeData );

				if ( pComponentData )
					( (CHotfix_Manager*) pComponentData )->m_pNode = m_pNode;  
			}
			
			hr = S_OK;
			break;
		}
	case MMCN_REMOVE_CHILDREN:
		{
			//
			// We are not deleting this node since this same pointer is
			// stashed in the pComponentData in response to the MMCN_EXPAND
			// notification. The destructor of pComponentData deletes the pointer
			// to this node.
			//
			//delete m_pNode;
			m_pNode = NULL;
			hr = S_OK;
			break;
		} 
		case MMCN_ADD_IMAGES:
		{
		}
	
	}  
 
	return S_OK; 
}

STDMETHODIMP CHotfix_ManagerComponent::Command(long lCommandID, LPDATAOBJECT pDataObject)
{
	HRESULT hr;

	if ( IS_SPECIAL_DATAOBJECT( pDataObject ) )
	{
		hr = m_pComponentData->m_pNode->Command( lCommandID, this, CCT_RESULT );
	}
	else
	{
		hr = IExtendContextMenuImpl<CHotfix_Manager>::Command( lCommandID, pDataObject );
	}

	return( hr );
}

STDMETHODIMP CHotfix_ManagerData::AddMenuItems(
	LPCONTEXTMENUCALLBACK pContextMenuCallback,
	long  *pInsertionAllowed,
	DATA_OBJECT_TYPES type)
{

	DWORD Status = GetCtrlStatus();
		HRESULT hr = S_OK;

	// Note - snap-ins need to look at the data object and determine
	// in what context, menu items need to be added. They must also
	// observe the insertion allowed flags to see what items can be 
	// added.
	/* handy comment:
	typedef struct	_CONTEXTMENUITEM
		{
		LPWSTR strName;
		LPWSTR strStatusBarText;
		LONG lCommandID;
		LONG lInsertionPointID;
		LONG fFlags;
		LONG fSpecialFlags;
		}	CONTEXTMENUITEM;
	*/
	CONTEXTMENUITEM singleMenuItem;
	TCHAR menuText[200];
	TCHAR statusBarText[300];

	singleMenuItem.strName = menuText;
	singleMenuItem.strStatusBarText = statusBarText;
	singleMenuItem.fFlags = 0;
	singleMenuItem.fSpecialFlags = 0;

    // Add each of the items to the Action menu
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) {

		// setting for the Action menu
		singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
		singleMenuItem.lCommandID = ID_VIEW_WEB;
		if (Status & HOTFIX_SELECTED)
			singleMenuItem.fFlags = MF_ENABLED;
		else
			singleMenuItem.fFlags = MF_GRAYED;
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_WEB, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_WEB_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr = pContextMenuCallback->AddItem(&singleMenuItem);

	
		singleMenuItem.lCommandID = ID_UNINSTALL;
		if (Status & UNINSTALL_OK)
			singleMenuItem.fFlags = MF_ENABLED;
		else
			singleMenuItem.fFlags = MF_GRAYED;

		LoadString(_Module.GetResourceInstance(), IDS_UNINSTALL, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_UNINSTALL_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr = pContextMenuCallback->AddItem(&singleMenuItem);


		if (Status & DATA_TO_SAVE)
		{
			singleMenuItem.lCommandID = ID_EXPORT;
			singleMenuItem.fFlags = MF_ENABLED;
			LoadString(_Module.GetResourceInstance(), IDS_EXPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
			LoadString(_Module.GetResourceInstance(), IDS_EXPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
			hr = pContextMenuCallback->AddItem(&singleMenuItem);

			
			singleMenuItem.lCommandID = ID_PRINT_REPORT;
			singleMenuItem.fFlags = MF_ENABLED;
			LoadString(_Module.GetResourceInstance(), IDS_PRINT_REPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
			LoadString(_Module.GetResourceInstance(), IDS_PRINT_REPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
			hr = pContextMenuCallback->AddItem(&singleMenuItem);
		}
		else
		{
			singleMenuItem.lCommandID = ID_EXPORT;
			singleMenuItem.fFlags = MF_GRAYED;
			LoadString(_Module.GetResourceInstance(), IDS_EXPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
			LoadString(_Module.GetResourceInstance(), IDS_EXPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
			hr = pContextMenuCallback->AddItem(&singleMenuItem);

			
			singleMenuItem.lCommandID = ID_PRINT_REPORT;
			singleMenuItem.fFlags = MF_GRAYED;
			LoadString(_Module.GetResourceInstance(), IDS_PRINT_REPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
			LoadString(_Module.GetResourceInstance(), IDS_PRINT_REPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
			hr = pContextMenuCallback->AddItem(&singleMenuItem);
		}

	}


    return S_OK;
	
}


STDMETHODIMP CHotfix_ManagerComponent::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK piCallback,long *pInsertionAllowed)
{
	HRESULT hr;

	if ( IS_SPECIAL_DATAOBJECT( pDataObject ) )
	{
			
	}
	else
	{
		CONTEXTMENUITEM singleMenuItem;
	TCHAR menuText[200];
	TCHAR statusBarText[300];
    DWORD State = GetCtrlStatus();
	
	//
	// Retrieve the control from the current component.
	//
//	assert( m_pComponent != NULL );
//	CComPtr<IDispatch> spDispCtl = m_pComponent->GetControl();
    
	singleMenuItem.strName = menuText;
	singleMenuItem.strStatusBarText = statusBarText;
	singleMenuItem.fFlags = 0;
	singleMenuItem.fSpecialFlags = 0;

    // Add each of the items to the Action menu
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
	{
	
		singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		singleMenuItem.lCommandID = ID_VIEW_BY_KB ;
		if ( State & STATE_VIEW_HOTFIX)
			singleMenuItem.fFlags = MF_CHECKED;
		else
			singleMenuItem.fFlags = MF_UNCHECKED; 
		LoadString(_Module.GetResourceInstance(), IDS_BY_KB_ARTICLE, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_BY_KB_ARTICLE_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr = piCallback->AddItem(&singleMenuItem);
		// setting for the Action menu
		singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		singleMenuItem.lCommandID = ID_VIEW_BY_FILE;
		if ( State & STATE_VIEW_FILE )
			singleMenuItem.fFlags = MF_CHECKED ;
		else
			singleMenuItem.fFlags = MF_UNCHECKED ;  
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_BY_FILE, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_BY_FILE_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr =  piCallback->AddItem(&singleMenuItem);

			hr = IExtendContextMenuImpl<CHotfix_Manager>::AddMenuItems( pDataObject, piCallback, pInsertionAllowed );
			// setting for the Action menu
	/*	singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
		singleMenuItem.lCommandID = IDM_VIEW_WEB;
		if (HaveHotfix)
			singleMenuItem.fFlags = MF_ENABLED;
		else
			singleMenuItem.fFlags = MF_GRAYED;
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_WEB, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_VIEW_WEB_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr = piCallback->AddItem(&singleMenuItem);

	//	singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		singleMenuItem.lCommandID = IDM_UNINSTALL;
//		singleMenuItem.fFlags = analyzeFlags;
		if ((!Remote) && (HaveHotfix))
			singleMenuItem.fFlags = MF_ENABLED;
		else
			singleMenuItem.fFlags = MF_GRAYED;

		LoadString(_Module.GetResourceInstance(), IDS_UNINSTALL, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_UNINSTALL_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr =  piCallback->AddItem(&singleMenuItem);

	//	singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
		singleMenuItem.lCommandID = IDM_GENERATE_REPORT;
		singleMenuItem.fFlags = MF_ENABLED;
		LoadString(_Module.GetResourceInstance(), IDS_GENERATE_REPORT, menuText, sizeof(menuText) / sizeof(TCHAR));
		LoadString(_Module.GetResourceInstance(), IDS_GENERATE_REPORT_STATUS_BAR, statusBarText, sizeof(statusBarText) / sizeof(TCHAR));
		hr =  piCallback->AddItem(&singleMenuItem); */
	} 
//	hr = m_pComponentData->m_pNode->AddMenuItems( piCallback, pInsertionAllowed, CCT_RESULT );
	}
	


	return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\hotfixmanager.cpp ===
// HotfixManager.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for HotfixManager.idl by adding the following 
//      files to the Outputs.
//          HotfixManager_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f HotfixManagerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "HotfixManager.h"
#include "dlldatax.h"

#include "HotfixManager_i.c"
#include "Hotfix_Manager.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Hotfix_Manager, CHotfix_Manager)
OBJECT_ENTRY(CLSID_Hotfix_ManagerAbout, CHotfix_ManagerAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
/*    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif */
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HOTFIXMANAGERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
/*#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif */
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
/*#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif*/
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
/*#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif*/
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\hotfixmanager_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for hotfixmanager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_HOTFIXMANAGERLib,0x7CF18F93,0x72F5,0x44D1,0x99,0x06,0xDB,0xFA,0x6A,0x21,0x6B,0xE8);


MIDL_DEFINE_GUID(CLSID, CLSID_Hotfix_Manager,0xE810E1EB,0x6B52,0x45D0,0xAB,0x07,0xFB,0x4B,0x04,0x39,0x2A,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_Hotfix_ManagerAbout,0x4F0EBD75,0xDA9D,0x4D09,0x8A,0x2E,0x9A,0xF1,0xD6,0xE0,0x25,0x11);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for hotfixmanager.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_HOTFIXMANAGERLib,0x7CF18F93,0x72F5,0x44D1,0x99,0x06,0xDB,0xFA,0x6A,0x21,0x6B,0xE8);


MIDL_DEFINE_GUID(CLSID, CLSID_Hotfix_Manager,0xE810E1EB,0x6B52,0x45D0,0xAB,0x07,0xFB,0x4B,0x04,0x39,0x2A,0xB4);


MIDL_DEFINE_GUID(CLSID, CLSID_Hotfix_ManagerAbout,0x4F0EBD75,0xDA9D,0x4D09,0x8A,0x2E,0x9A,0xF1,0xD6,0xE0,0x25,0x11);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\hotfix_manager.h ===
#ifndef HOTFIX_MANAGER
#define HOTFIX_MANAGER

#include "resource.h"
#include <atlsnap.h>

static _TCHAR gszComputerName[255];
static BOOL ComputerNameSent = FALSE;
static  IDispatch* gszManagerCtlDispatch = NULL;
inline LPOLESTR CoTaskDupString( LPOLESTR pszInput )
{
	USES_CONVERSION;
	LPOLESTR pszOut = NULL;

	//
	// We throw an exception if the following allocation fails.
	//
	pszOut = (LPOLESTR) CoTaskMemAlloc( ( wcslen( pszInput ) + 1 ) * sizeof( OLECHAR ) );
	if ( pszOut == NULL )
		throw;

	wcscpy( pszOut, pszInput );

	return( pszOut );
};

template <class T>        
class ATL_NO_VTABLE ISnapinHelpImpl : public ISnapinHelp
{
public:

	// get the dkms help file location and returns it
	STDMETHOD( GetHelpTopic )( LPOLESTR* lpCompiledHelpFile )
	{
		_ASSERT( lpCompiledHelpFile != NULL );
		USES_CONVERSION;
		HRESULT hr = E_FAIL;
		TCHAR szPath[ _MAX_PATH * 2 ];

		// this is where the dkms help file is stored
	
		wcscpy(szPath,L"C:\\mmc-samples\\Hotfix_Snapin\\snapsamp.chm");
//		MessageBox(NULL,szPath,_T("Help File Path"),MB_OK);
		// expand out the %systemroot% variable
	//	ExpandEnvVars(szPath);

	//	MessageBox(NULL,szPath,_T("Help File Path"),MB_OK);
		// Allocate the string and return it.
		*lpCompiledHelpFile = CoTaskDupString( T2W( szPath ) );
		hr = S_OK;

		return( hr );
	}
};

class CHotfix_ManagerComponent;
class CHotfix_ManagerData : public CSnapInItemImpl<CHotfix_ManagerData>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	_TCHAR m_szComputerName[255];
	_TCHAR m_szCreation[255];
    bool m_bChild;
	bool b_Expanded;
	DWORD m_dwCurrentView;
	_TCHAR m_ProductName[255];
    CHotfix_ManagerComponent* m_pComponent;
	static BSTR m_bstrColumnType;
	static BSTR m_bstrColumnDesc;
	CComPtr<IControlbar> m_spControlBar;

	BEGIN_SNAPINCOMMAND_MAP(CHotfix_ManagerData, FALSE)
	END_SNAPINCOMMAND_MAP()

//	SNAPINMENUID(IDR_HOTFIXMANAGER_MENU)

	BEGIN_SNAPINTOOLBARID_MAP(CHotfix_ManagerData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CHotfix_ManagerData(_TCHAR * ProductName,_TCHAR * new_ComputerName, bool Child)
	{
		_TCHAR Messg[255];
		m_dwCurrentView = IDC_VIEW_BY_HOTFIX;
			m_bChild = Child;
			_tcscpy (m_szComputerName, new_ComputerName);
		b_Expanded = false;
				
	
		// Image indexes may need to be modified depending on the images specific to 
		// the snapin.
		// Image indexes may need to be modified depending on the images specific to 
		// the snapin.
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
		m_scopeDataItem.displayname = MMC_CALLBACK;
		m_scopeDataItem.nImage = 4; 		// May need modification
		m_scopeDataItem.nOpenImage = 5; 	// May need modification
		m_scopeDataItem.lParam = (LPARAM) this;
		memset(&m_resultDataItem, 4, sizeof(RESULTDATAITEM));
		m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
		m_resultDataItem.str = MMC_CALLBACK;
		m_resultDataItem.nImage = 4;		// May need modification
		m_resultDataItem.lParam = (LPARAM) this;

		if (ProductName == NULL)
		{
		LoadString(_Module.GetResourceInstance(),IDS_DISPLAY_NAME,Messg,255);
		_tcscpy(m_ProductName,_T("\0"));
		}
		else 
		{
			_tcscpy(Messg,ProductName);
			_tcscpy(m_ProductName,ProductName);
			
		}

		m_bstrDisplayName = SysAllocString(Messg);
			
		LoadString(_Module.GetResourceInstance(),IDS_COLUMN_TYPE,Messg,255);
		m_bstrColumnType = SysAllocString(Messg);
		
		LoadString(_Module.GetResourceInstance(),IDS_COLUMN_DESC,Messg,255);
		m_bstrColumnDesc = SysAllocString( Messg );

	}

	~CHotfix_ManagerData()
	{
	}

	STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);

		STDMETHOD( GetResultViewType )( LPOLESTR* ppViewType, long* pViewOptions );

	
	STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);

	STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
		long arg,
		long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type);

	LPOLESTR GetResultPaneColInfo(int nCol);
	BOOL SendProductName(_TCHAR *szPoductName, IDispatch * pDisp);
	BOOL SendComputerName(_TCHAR *szDataMachineName,IDispatch * pDisp);



	BOOL SendCommand( LPARAM lparamCommand );
	
 
		STDMETHOD( Command )(long lCommandID,		
		CSnapInObjectRootBase* pObj,		
		DATA_OBJECT_TYPES type);

	STDMETHOD(AddMenuItems)(
	LPCONTEXTMENUCALLBACK pContextMenuCallback,
	long  *pInsertionAllowed,
	DATA_OBJECT_TYPES type); 


};

DWORD GetCtrlStatus();

class CHotfix_ManagerExtData : public CSnapInItemImpl<CHotfix_ManagerExtData, TRUE>
{
public:
	static const GUID* m_NODETYPE;
	static const OLECHAR* m_SZNODETYPE;
	static const OLECHAR* m_SZDISPLAY_NAME;
	static const CLSID* m_SNAPIN_CLASSID;

	BEGIN_SNAPINCOMMAND_MAP(CHotfix_ManagerExtData, FALSE)
	END_SNAPINCOMMAND_MAP()

//	SNAPINMENUID(IDR_HOTFIXMANAGER_MENU)

	BEGIN_SNAPINTOOLBARID_MAP(CHotfix_ManagerExtData)
		// Create toolbar resources with button dimensions 16x16 
		// and add an entry to the MAP. You can add multiple toolbars
		// SNAPINTOOLBARID_ENTRY(Toolbar ID)
	END_SNAPINTOOLBARID_MAP()

	CHotfix_ManagerExtData()
	{
		m_pNode = NULL;
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CHotfix_ManagerExtData()
	{
			if ( m_pNode != NULL )
			delete m_pNode;
	}

	IDataObject* m_pDataObject;
	virtual void InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
		// The default code stores off the pointer to the Dataobject the class is wrapping
		// at the time. 
		// Alternatively you could convert the dataobject to the internal format
		// it represents and store that information
	}

	CSnapInItem* GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}
	STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
		long arg,
		long param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type);

    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem)
	{
		return( S_OK );
	}

protected:
		CSnapInItem* m_pNode;

};

class CHotfix_Manager;

class CHotfix_ManagerComponent : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<2, CHotfix_Manager >,
	public IExtendContextMenuImpl<CHotfix_Manager>,
//	public IExtendControlbarImpl<CHotfix_ManagerComponent>,
	public IPersistStreamInit,
	public IComponentImpl<CHotfix_ManagerComponent>
{
public:
BEGIN_COM_MAP(CHotfix_ManagerComponent)
	COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
 //   COM_INTERFACE_ENTRY(IExtendControlbar)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
END_COM_MAP()
//	SNAPINMENUID(IDR_HOTFIXMANAGER_MENU)
public:
	CHotfix_ManagerComponent()
	{
	}

		STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
	{
		//
		// Check for a special data object being sent.
		// Might be able to extract the computer name here....
		if ( IS_SPECIAL_DATAOBJECT( lpDataObject ) )
			return( S_OK );
		if (lpDataObject != NULL)
			return IComponentImpl<CHotfix_ManagerComponent>::Notify(lpDataObject, event, arg, param);
		// TODO : Add code to handle notifications that set lpDataObject == NULL.
		return E_NOTIMPL;
	}

	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::GetClassID"));
	}	

	STDMETHOD(IsDirty)()
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::IsDirty"));
	}

	STDMETHOD(Load)(IStream *pStm)
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::Load"));
	}

	STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty)
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::Save"));
	}

	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
	{
		ATLTRACENOTIMPL(_T("CHotfix_ManagerComponent::GetSizeMax"));
	}

	STDMETHOD(Command)(long lCommandID,
        LPDATAOBJECT pDataObject);
	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("CHotfix_ManagerComponent::InitNew\n"));
		return S_OK;
	}
	STDMETHOD (AddMenuItems) (LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK piCallback,long *pInsertionAllowed);

};

class CHotfix_Manager : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<1, CHotfix_Manager>,
	public IComponentDataImpl<CHotfix_Manager, CHotfix_ManagerComponent>,
	public IExtendControlbarImpl<CHotfix_Manager>,
	public IExtendContextMenuImpl<CHotfix_Manager>,
	public IPersistStreamInit,
	public ISnapinHelpImpl<CHotfix_Manager>,
	public CComCoClass<CHotfix_Manager, &CLSID_Hotfix_Manager>
{
public:
	CHotfix_Manager();

	bool IsRemoted()
	{
		return( m_fRemoted );
	}


	~CHotfix_Manager()
	{
		delete m_pNode;
		m_pNode = NULL;
	}

EXTENSION_SNAPIN_DATACLASS(CHotfix_ManagerExtData)

BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CHotfix_Manager)
	EXTENSION_SNAPIN_NODEINFO_ENTRY(CHotfix_ManagerExtData)
END_EXTENSION_SNAPIN_NODEINFO_MAP()

BEGIN_COM_MAP(CHotfix_Manager)
	  COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_HOTFIXMANAGER)

DECLARE_NOT_AGGREGATABLE(CHotfix_Manager)

	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::GetClassID"));
	}	

	STDMETHOD(IsDirty)()
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::IsDirty"));
	}

	STDMETHOD(Load)(IStream *pStm)
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::Load"));
	}

	STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty)
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::Save"));
	}

	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
	{
		ATLTRACENOTIMPL(_T("CHotfix_Manager::GetSizeMax"));
	}


	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("CHotfix_Manager::InitNew\n"));
		return S_OK;
	}

	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}


	STDMETHOD(Notify)( LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

protected:
	_TCHAR m_szComputerName[255];
	bool ExtractString( IDataObject* pDataObject, unsigned int cfClipFormat, LPTSTR pBuf, DWORD dwMaxLength );
	//
	// Register the clipboard format and get the value to query on.
	//
	void RegisterRemotedClass()
	{
		m_ccfRemotedFormat = RegisterClipboardFormat( _T( "MMC_SNAPIN_MACHINE_NAME" ) );
		_ASSERTE( m_ccfRemotedFormat > 0 );
	}
	//
	// Determine if we're monitoring a local or remote machine based on the given data object.
	//
	bool IsDataObjectRemoted( IDataObject* pDataObject );
	//
	// Used to track whether we're remoted or not.
	//
	bool m_fRemoted;
	//
	// Initialized by RegisterRemoteClass(). Contains the clipboard ID
	// of MMC_SNAPIN_MACHINE_NAME after registered with the clipboard.
	//
	UINT m_ccfRemotedFormat;
};

class ATL_NO_VTABLE CHotfix_ManagerAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CHotfix_ManagerAbout, &CLSID_Hotfix_ManagerAbout>
{
public:
	DECLARE_REGISTRY(CHotfixManagerAbout, _T("Hotfix_ManagerAbout.1"), _T("Hotfix_ManagerAbout.1"), IDS_HOTFIXMANAGER_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CHotfix_ManagerAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_HOTFIXMANAGER_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_HOTFIXMANAGER_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_HOTFIXMANAGER_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = NULL;
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
		HBITMAP *hSmallImageOpen,
		HBITMAP *hLargeImage,
		COLORREF *cMask)
	{
		*hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
		return S_OK;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__ABD9AA5B_11DD_4A99_8030_DFD9F6C3701D__INCLUDED_)
#define AFX_STDAFX_H__ABD9AA5B_11DD_4A99_8030_DFD9F6C3701D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__ABD9AA5B_11DD_4A99_8030_DFD9F6C3701D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hotfixmanager\snapin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Hotfix_Snapin.rc
//
#define UNINSTALL_OK                    1
#define HOTFIX_SELECTED                 2
#define IS_REMOTED                      4
#define DATA_TO_SAVE                    8
#define OK_TO_PRINT                     16
#define STATE_VIEW_FILE                 32
#define STATE_VIEW_HOTFIX               64
#define IDS_PROJNAME                    100
#define IDB_HOTFIXMANAGER_16            101
#define IDB_HOTFIXMANAGER_32            102
#define IDR_HOTFIXMANAGER_MENU          103
#define IDD_HOTFIXMANAGER               104
#define IDS_HOTFIXMANAGER_DESC          105
#define IDS_HOTFIXMANAGER_PROVIDER      106
#define IDS_HOTFIXMANAGER_VERSION       107
#define IDR_HOTFIXMANAGER               108
#define IDS_VIEW_BY_FILE                108
#define IDS_BY_FILE_STATUS_BAR          109
#define IDS_BY_KB_ARTICLE_STATUS_BAR    110
#define IDS_BY_KB_ARTICLE               111
#define IDS_UNINSTALL                   112
#define IDS_UNINSTALL_STATUS_BAR        113
#define IDS_VIEW_WEB                    114
#define IDS_VIEW_WEB_STATUS_BAR         115
#define IDS_PRINT_REPORT                116
#define IDS_PRINT_REPORT_STATUS_BAR     117
#define IDS_COLUMN_TYPE                 118
#define IDS_COLUMN_DESC                 119
#define IDS_DISPLAY_NAME                120
#define IDS_EXPORT                      121
#define IDS_EXPORT_STATUS_BAR           122
#define IDS_NO_ACCESS                   123
#define IDC_VIEW_WEB                    2000
#define IDC_VIEW_BY_FILE                2001
#define IDC_VIEW_BY_HOTFIX              2002
#define IDC_UNINSTALL                   2003
#define IDC_REFRESH                     2004
#define IDC_EXPORT                      2005
#define IDC_PRINT_REPORT                2006
#define ID_VIEW_BY_FILE                 32770
#define ID_VIEW_BY_KB                   32771
#define ID_VIEW_WEB                     32772
#define ID_PRINT_REPORT                 32773
#define ID_EXPORT                       32774
#define ID_UNINSTALL                    32775

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hsplit\hsglobal.c ===
/****************************** Module Header ******************************\
* Module Name: hsglobals.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/06/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"

/***************************************************************************\
* Globals
\***************************************************************************/
/*
 * Files
 */
char * gpszInputFile = NULL;
HANDLE ghfileInput;
char * gpszPublicFile = NULL;
HANDLE ghfilePublic;
char * gpszInternalFile = NULL;
HANDLE ghfileInternal;

PHSEXTRACT gpExtractFile = NULL;

/*
 * Map file
 */
HANDLE ghmap;
char * gpmapStart;
char * gpmapEnd;

/*
 * Switches et al
 */
DWORD gdwOptions = 0;
DWORD gdwVersion = LATEST_WIN32_WINNT_VERSION;
char gszVerifyVersionStr [11];
DWORD gdwFilterMask = HST_DEFAULT;
char * gpszTagMarker = ";";
DWORD gdwTagMarkerSize = 1;
char gszMarkerCharAndEOL [] = ";" "\r";

DWORD gdwLineNumber = 0;

/*
 * Compatibility tags. Specify size so sizeof operator can be used to
 *  determine strlen at compile time
 */
char gsz35 [3] = "35";
char gszCairo [6] = "cairo";
char gszChicago [8] = "chicago";
char gszNashville [10] = "nashville";
char gszNT [3] = "NT";
char gszSur [4] = "sur";
char gszSurplus [8] = "surplus";
char gszWin40 [6] = "win40";
char gszWin40a [7] = "win40a";

/*
 * Predefined tags table (ghst).
 * begin-end are special tags that use HST_ bits but are not included in
 *  this table (because they must be the first tag afer the marker)
 * All other tags are user defined through the command line (-t?); up to
 *  32 - HST_MASKBITCOUNT user defined tags are allowed.
 *
 * Size is specified so sizeof operator work fine
 */

HSTAG ghstPredefined [16] = {
    /*
     * Headers - output file
     */
    {HSLABEL(public),   HST_PUBLIC},
    {HSLABEL(internal), HST_INTERNAL},
    {HSLABEL(both),     HST_BOTH},
    {HSLABEL($),        HST_SKIP},
    {HSLABEL(only),     HST_EXTRACTONLY},

    /*
     * Old tags used with all old switches
     */
    {HSLABEL(winver),                         HST_WINVER | HST_MAPOLD},
    {HSCSZSIZE(gszCairo),      gszCairo,      HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszChicago),    gszChicago,    HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszNashville),  gszNashville,  HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszNT),         gszNT,         HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszSur),        gszSur,        HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszSurplus),    gszSurplus,    HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszWin40),      gszWin40,      HST_SKIP | HST_MAPOLD},
    {HSCSZSIZE(gszWin40a),     gszWin40a,     HST_SKIP | HST_MAPOLD},
    
    /*
     * if tags.
     */
    {HSLABEL(if), HST_IF},

    {0, NULL, 0}
};

PHSTAG gphst = ghstPredefined;

DWORD gdwLastTagMask = HST_LASTMASK;

/*
 * Block stack
 */
HSBLOCK ghsbStack [HSBSTACKSIZE];
PHSBLOCK gphsbStackTop = ghsbStack;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hsplit\hsfile.c ===
/****************************** Module Header ******************************\
* Module Name: hsfile.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"

/*********************************************************************
* hsUnmapFile
*
\***************************************************************************/
void hsUnmapFile (void)
{
    LocalFree(gpmapStart);
    CloseHandle(ghfileInput);
}
/*********************************************************************
* hsMapFile
*
\***************************************************************************/
BOOL hsMapFile (void)
{
    DWORD dwFileSize, dwBytesRead;

    ghfileInput = CreateFile(gpszInputFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
    if (ghfileInput == INVALID_HANDLE_VALUE) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFile");
        goto CleanupAndFail;
    }

    dwFileSize = GetFileSize(ghfileInput, NULL);
    if (dwFileSize == 0xFFFFFFFF) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "GetFileSize");
        goto CleanupAndFail;
    }

    gpmapStart = LocalAlloc(LPTR, dwFileSize + 1);
    if (!gpmapStart) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "LocalAlloc");
        goto CleanupAndFail;
    }

    if (!ReadFile(ghfileInput, gpmapStart, dwFileSize, &dwBytesRead, NULL)) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "ReadFile");
        goto CleanupAndFail;
    }

    if (dwFileSize != dwBytesRead) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "ReadFile");
        goto CleanupAndFail;
    }

    gpmapEnd = gpmapStart + dwFileSize;
    gpmapStart[dwFileSize] = '\0';

#if 0
    ghmap = CreateFileMapping(ghfileInput, NULL, PAGE_READONLY, 0, 0, NULL);
    if (ghmap == NULL) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFileMapping");
        goto CleanupAndFail;
    }

    gpmapStart = MapViewOfFile(ghmap, FILE_MAP_READ, 0, 0, 0);
    if (gpmapStart == NULL) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "MapViewOfFile");
        goto CleanupAndFail;
    }

    gpmapEnd = gpmapStart + dwFileSize;
#endif

    return TRUE;

CleanupAndFail:
    hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "hsMapFile failed. File: '%s'", gpszInputFile);
    return FALSE;
}
/*********************************************************************
* hsCloseWorkingFiles
*
\***************************************************************************/
BOOL hsCloseWorkingFiles (void)
{
    CloseHandle(ghfilePublic);
    CloseHandle(ghfileInternal);

    hsUnmapFile();

   return TRUE;
}
/*********************************************************************
* hsOpenWorkingFiles
*
\***************************************************************************/
BOOL hsOpenWorkingFiles (void)
{
    char * pszFileFailed;

    /*
     * Map input file to memory
     */
    if (!hsMapFile()) {
        pszFileFailed = gpszInputFile;
        goto CleanupAndFail;
    }

    /*
     * Open/Create public header file
     */
    ghfilePublic = CreateFile(gpszPublicFile, GENERIC_WRITE, 0, NULL,
                            (gdwOptions & HSO_APPENDOUTPUT ? OPEN_EXISTING : CREATE_ALWAYS),
                            FILE_ATTRIBUTE_NORMAL,  NULL);

    if (ghfilePublic == INVALID_HANDLE_VALUE) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFile");
        pszFileFailed = gpszPublicFile;
        goto CleanupAndFail;
    }

    if (gdwOptions & HSO_APPENDOUTPUT) {
        if (0xFFFFFFFF == SetFilePointer (ghfilePublic, 0, 0, FILE_END)) {
            hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "SetFilePointer");
            pszFileFailed = gpszPublicFile;
            goto CleanupAndFail;
        }
    }

    /*
     * Open/Create internal header file
     */
    ghfileInternal = CreateFile(gpszInternalFile, GENERIC_WRITE, 0, NULL,
                            (gdwOptions & HSO_APPENDOUTPUT ? OPEN_EXISTING : CREATE_ALWAYS),
                            FILE_ATTRIBUTE_NORMAL,  NULL);

    if (ghfileInternal == INVALID_HANDLE_VALUE) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFile");
        pszFileFailed = gpszInternalFile;
        goto CleanupAndFail;
    }

    if (gdwOptions & HSO_APPENDOUTPUT) {
        if (0xFFFFFFFF == SetFilePointer (ghfileInternal, 0, 0, FILE_END)) {
            hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "SetFilePointer");
            pszFileFailed = gpszInternalFile;
            goto CleanupAndFail;
        }
    }

    return TRUE;

CleanupAndFail:
    hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "hsOpenWorkingFiles failed. File:'%s'", pszFileFailed);
    return FALSE;
}

/***************************************************************************\
* hsWriteHeaderFiles
*
\***************************************************************************/
BOOL hsWriteHeaderFiles (char * pmap, DWORD dwSize, DWORD dwFlags)
{
    DWORD dwWritten;

    /*
     * propagate the flags from previous blocks
     */
    if (ghsbStack < gphsbStackTop) {
        dwFlags |= (gphsbStackTop - 1)->dwMask;
    }

    /*
     * write this to the public/private files only if the
     * extractonly flag is not set !
     */
    if (!(dwFlags & HST_EXTRACTONLY)) {
        /*
         * If defaulting or if requested, write it to the public header
         */
        if (!(dwFlags & HST_BOTH)
                || (dwFlags & (HST_PUBLIC | HST_INCINTERNAL))) {

            if (!WriteFile(ghfilePublic, pmap, dwSize, &dwWritten, NULL)) {
                hsLogMsg(HSLM_APIERROR, "WriteFile");
                hsLogMsg(HSLM_ERROR, "Error writing public header: %s. Handle:%#lx.", gpszPublicFile, ghfilePublic);
                return FALSE;
            }
        }

        /*
         * Write it to internal header if requested
         */
        if ((dwFlags & HST_INTERNAL) && !(dwFlags & HST_INCINTERNAL)) {

            if (!WriteFile(ghfileInternal, pmap, dwSize, &dwWritten, NULL)) {
                hsLogMsg(HSLM_APIERROR, "WriteFile");
                hsLogMsg(HSLM_ERROR, "Error writing internal header: %s. Handle:%#lx.", gpszInternalFile, ghfileInternal);
                return FALSE;
            }
        }
    }

    /*
     * Write it to extract header if requested
     */
    if (!(dwFlags & HST_INTERNAL) && (dwFlags & HST_EXTRACT)) {

        PHSEXTRACT pe = gpExtractFile;

        while (pe != NULL) {
            if ((pe->dwMask & dwFlags) != HST_EXTRACT) {
                if (!WriteFile(pe->hfile, pmap, dwSize, &dwWritten, NULL)) {
                    hsLogMsg(HSLM_APIERROR, "WriteFile");
                    hsLogMsg(HSLM_ERROR, "Error writing extract header: %s. Handle:%#lx.",
                             pe->pszFile, pe->hfile);
                    return FALSE;
                }
            }
            pe = pe->pNext;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hsplit\hsplit.c ===
/****************************** Module Header ******************************\
* Module Name: hsplit.c
*
* Structure parser - struct field name-offset tabel generator.
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"

/*
 * Maximum size of tags (gphst) table including possible user defined tags
 */
#define HSTAGTABLESIZE (sizeof(ghstPredefined) + ((32 - HST_MASKBITCOUNT) * sizeof(HSTAG)))
/***************************************************************************\
* hsAddTag
*
\***************************************************************************/
PHSTAG hsAddTag (char * pszTag, DWORD dwMask)
{
    PHSTAG phst;
    DWORD dwTagSize;

    /*
     * Make sure we still have mask bits to uniquely identified this tag
     */
    if (((dwMask | HST_EXTRACT) == HST_EXTRACT) && (gdwLastTagMask == HST_MAXMASK)) {
        hsLogMsg(HSLM_ERROR, "Too many user defined tags. Max allowed: %d", 32 - HST_MASKBITCOUNT);
        return NULL;
    }

    /*
     * Create the table the first time around.
     */
    if (gphst == ghstPredefined) {
        gphst = (PHSTAG) LocalAlloc(LPTR, HSTAGTABLESIZE);
        if (gphst == NULL) {
            hsLogMsg(HSLM_APIERROR, "LocalAlloc");
            hsLogMsg(HSLM_ERROR, "hsAddTag Allocation failed. Size:%#lx", HSTAGTABLESIZE);
            return NULL;
        }

        CopyMemory(gphst, &ghstPredefined, sizeof(ghstPredefined));
    }

    /*
     * If the string is in the table, we update the mask.
     */
    dwTagSize = strlen(pszTag);
    phst = hsFindTagInList(gphst, pszTag, dwTagSize);
    if (phst == NULL) {
        /*
         * New string. Find next available entry in the table
         */
        phst = gphst;
        while (phst->dwLabelSize != 0) {
            phst++;
        }
    }

    /*
     * Initialize it
     */
    phst->dwLabelSize = dwTagSize;
    phst->pszLabel = pszTag;

    /*
     * If generating a mask, use the next available bit in the tag mask
     *  else use the one supplied by the caller
     */
    if ((dwMask | HST_EXTRACT) == HST_EXTRACT) {
        gdwLastTagMask *= 2;
        phst->dwMask = (gdwLastTagMask | dwMask);
    } else {
        phst->dwMask = dwMask;
    }

    /*
     * Add this tag's mask to the filter mask so lines mark with this tag
     *  will be included
     */
    gdwFilterMask |= (phst->dwMask & HST_USERTAGSMASK);

    return phst;
}
/***************************************************************************\
* hsIsSwitch
*
\***************************************************************************/
__inline BOOL hsIsSwitch(char c)
{
    return (c == '/') || (c == '-');
}

/***************************************************************************\
* hsAddUserDefinedTag
*
\***************************************************************************/

BOOL hsAddUserDefinedTag(DWORD* pdwMask, int* pargc, char*** pargv)
{
    DWORD  dwRetMask = *pdwMask;
    PHSTAG phst;

    if (*pargc < 2) {
        return FALSE;  // invalid switch
    }
    
    /*
     * Allow multiple tags to be specified for one switch
     *  i.e., -t tag1 <tag2 tag2....>
     */
    do {
        (*pargc)--, (*pargv)++;

        /*
         * Add tag to table
         */
        phst = hsAddTag(**pargv, *pdwMask);
        if (phst == NULL) {
            return 0;
        }
        
        dwRetMask |= phst->dwMask;

    } while ((*pargc >= 2) && !hsIsSwitch(**(*pargv + 1)));

    /*
     * save the new mask
     */
    *pdwMask = dwRetMask;

    return TRUE;
}

/***************************************************************************\
* hsAddExtractFile
*
\***************************************************************************/
BOOL hsAddExtractFile(char* pszExtractFile, DWORD dwMask, BOOL bAppend)
{
    PHSEXTRACT pe;

    pe = LocalAlloc(LPTR, sizeof(HSEXTRACT));
    
    if (pe == NULL) {
        return FALSE;
    }
    pe->pszFile = pszExtractFile;
    pe->dwMask  = dwMask;

    pe->hfile = CreateFile(pszExtractFile, GENERIC_WRITE, 0, NULL,
                            (bAppend ? OPEN_EXISTING : CREATE_ALWAYS),
                            FILE_ATTRIBUTE_NORMAL,  NULL);

    if (pe->hfile == INVALID_HANDLE_VALUE) {
        hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "CreateFile failed for file %s",
                 pszExtractFile);
        LocalFree(pe);
        return FALSE;
    }
    if (bAppend) {
        if (0xFFFFFFFF == SetFilePointer (pe->hfile, 0, 0, FILE_END)) {
            hsLogMsg(HSLM_APIERROR | HSLM_NOLINE, "SetFilePointer failed for file %s",
                     pszExtractFile);
            CloseHandle(pe->hfile);
            LocalFree(pe);
            return FALSE;
        }
    }
    
    /*
     * link it in the list of extract files
     */
    pe->pNext = gpExtractFile;
    gpExtractFile = pe;
    
    return TRUE;
}

/***************************************************************************\
* hsProcessParameters
*
\***************************************************************************/
int hsProcessParameters(int argc, LPSTR argv[])
{
    char c, *p;
    DWORD dwMask;
    int argcParm = argc;
    PHSTAG phst;

    /*
     * Compatibility. Assume default project the first time this
     *  function is called
     */
    if (!(gdwOptions & HSO_APPENDOUTPUT)) {
        gdwOptions |= HSO_OLDPROJSW_N;
    }

    /*
     * Loop through parameters.
     */
    while (--argc) {
        p = *++argv;
        if (hsIsSwitch(*p)) {
            while (c = *++p) {
                switch (toupper(c)) {
                /*
                 * Compatibility.
                 * Chicago/Nashvilled header.
                 */
               case '4':
                   gdwOptions &= ~HSO_OLDPROJSW;
                   gdwOptions |= HSO_OLDPROJSW_4;
                   break;

                /*
                 * Old bt2 and btb switches to replace internal and
                 *  both block tags.
                 */
                case 'B':
                   p++;
                   if (toupper(*p++) != 'T') {
                       goto InvalidSwitch;
                   }
                   if (toupper(*p) == 'B') {
                       dwMask = HST_BOTH | HST_USERBOTHBLOCK;
                       gdwOptions |= HSO_USERBOTHBLOCK;
                   } else if (*p == '2') {
                       dwMask = HST_INTERNAL | HST_USERINTERNALBLOCK;
                       gdwOptions |= HSO_USERINTERNALBLOCK;
                   } else {
                       goto InvalidSwitch;
                   }

                   if (argc < 3) {
                       goto InvalidSwitch;
                   }


                   /*
                    * Add these strings as tags and mark them as blocks
                    */
                   argc--, argv++;
                   phst = hsAddTag(*argv, HST_BEGIN | dwMask);
                   if (phst == NULL) {
                       return 0;
                   }

                   argc--, argv++;
                   phst = hsAddTag(*argv, HST_END | dwMask);
                   if (phst == NULL) {
                       return 0;
                   }
                   break;

                /*
                 * Tag marker
                 */
               case 'C':
                   if (argc < 2) {
                       goto InvalidSwitch;
                   }

                   argc--, argv++;
                   gpszTagMarker = *argv;
                   *gszMarkerCharAndEOL = *gpszTagMarker;
                   gdwTagMarkerSize = strlen(gpszTagMarker);
                   if (gdwTagMarkerSize == 0) {
                       goto InvalidSwitch;
                   }
                   break;

                /*
                 * Compatibility.
                 * NT SUR header
                 */
               case 'E':
                   gdwOptions &= ~HSO_OLDPROJSW;
                   gdwOptions |= HSO_OLDPROJSW_E;
                   break;

                /*
                 * Input file
                 */
                case 'I':
                    if (argc < 2) {
                        goto InvalidSwitch;
                    }

                    argc--, argv++;
                    gpszInputFile = *argv;
                    goto ProcessInputFile;
                    break;

                /*
                 * Extract file
                 */
                case 'X':
                    {
                        char* pszExtractFile;
                        BOOL  bAppend = FALSE;
                        
                        if (toupper(*(p+1)) == 'A') {
                            p++;
                            bAppend = TRUE;
                        }
                        
                        if (argc < 3) {
                            goto InvalidSwitch;
                        }
    
                        argc--, argv++;
                        pszExtractFile = *argv;
    
                        dwMask = HST_EXTRACT;
                        if (!hsAddUserDefinedTag(&dwMask, &argc, &argv))
                            goto InvalidSwitch;
                        
                        hsAddExtractFile(pszExtractFile, dwMask, bAppend);
                        
                        break;
                    }

                /*
                 * Old lt2 and ltb switches to replace internal and
                 *  both tags.
                 */
               case 'L':
                   p++;
                   if (toupper(*p++) != 'T') {
                       goto InvalidSwitch;
                   }
                   if (toupper(*p) == 'B') {
                       dwMask = HST_BOTH | HST_USERBOTHTAG;
                       gdwOptions |= HSO_USERBOTHTAG;
                   } else if (*p == '2') {
                       dwMask = HST_INTERNAL | HST_USERINTERNALTAG;
                       gdwOptions |= HSO_USERINTERNALTAG;
                   } else {
                       goto InvalidSwitch;
                   }

                   if (!hsAddUserDefinedTag(&dwMask, &argc, &argv))
                       goto InvalidSwitch;
                   
                   break;

                /*
                 * Compatibility.
                 * NT header
                 */
               case 'N':
                    gdwOptions &= ~HSO_OLDPROJSW;
                    gdwOptions |= HSO_OLDPROJSW_N;
                   break;

                /*
                 * Ouput files
                 */
                case 'O':
                    if (argc < 3) {
                        goto InvalidSwitch;
                    }

                    argc--, argv++;
                    gpszPublicFile = *argv;

                    argc--, argv++;
                    gpszInternalFile = *argv;
                    break;

                /*
                 * Compatibility.
                 * NT SURPlus header
                 */
               case 'P':
                   gdwOptions &= ~HSO_OLDPROJSW;
                   gdwOptions |= HSO_OLDPROJSW_P;
                   break;

                /*
                 * Split only. Process internal/both tags only. Tags
                 *  including other tags as well (i.e., internal_NT)
                 *  are treated as untagged.
                 */
               case 'S':
                   gdwOptions |= HSO_SPLITONLY;
                   break;

                /*
                 * User defined tags.
                 */
                case 'T':
                    switch (toupper(*++p)) {
                        /*
                         * Include lines mark with this tag
                         */
                        case 'A':
                            dwMask = 0;
                            break;
                        /*
                         * Ignore lines marked with this tag (i.e, treated
                         *  as untagged)
                         */
                        case 'I':
                            dwMask = HST_IGNORE;
                            break;
                        /*
                         * Skip lines marked with this tag (i.e., not
                         *  included in header files)
                         */
                        case 'S':
                            dwMask = HST_SKIP;
                            break;

                        default:
                            goto InvalidSwitch;
                    }

                    if (!hsAddUserDefinedTag(&dwMask, &argc, &argv))
                        goto InvalidSwitch;

                    break;

                /*
                 * Version
                 */
                case 'V':
                    if (argc < 2) {
                        goto InvalidSwitch;
                    }

                    argc--, argv++;
                    if (!hsVersionFromString (*argv, strlen(*argv), &gdwVersion)) {
                        goto InvalidSwitch;
                    }
                    break;

                /*
                 * Unknown tags are to be skipped, as opposed to ignored.
                 */
               case 'U':
                   gdwOptions |= HSO_SKIPUNKNOWN;
                   break;

                /*
                 * Invalid switch
                 */
                default:
InvalidSwitch:
                    hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "Invalid switch or parameter: %c", c);
                    // Fall through

                /*
                 * Help
                 */
                case '?':
                   goto PrintHelp;

                } /* switch (toupper(c)) */
            } /* while (c = *++p) */
        } else { /* hsIsSwitch(*p) { */
            /*
             * No switch specified. Process this input file
             */
            gpszInputFile = *argv;
            break;
        }
    } /* while (--argc) */

ProcessInputFile:
    /*
     * Make sure we got input and ouput files.
     */
    if ((gpszInputFile == NULL)
            || (gpszPublicFile == NULL)
            || (gpszInternalFile == NULL)) {

        hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "Missing input or ouput file");
        goto PrintHelp;
    }

    /*
     * Add compatibility tags for default projects (first call only)
     */
    if ((gdwOptions & HSO_OLDPROJSW) && !(gdwOptions & HSO_APPENDOUTPUT)) {
        if (!(gdwOptions & HSO_OLDPROJSW_4)) {
            phst = hsAddTag(gszNT, 0);
            if (phst == NULL) {
                return 0;
            }
            phst->dwMask |= HST_MAPOLD;
            dwMask = phst->dwMask;
        }

        if (gdwOptions & HSO_OLDPROJSW_E) {
            hsAddTag(gszCairo, dwMask);
            hsAddTag(gszSur, dwMask);
            hsAddTag(gszWin40, dwMask);
            hsAddTag(gsz35, dwMask);

        } else if (gdwOptions & HSO_OLDPROJSW_P) {
            hsAddTag(gszWin40, dwMask);
            hsAddTag(gszWin40a, dwMask);
            hsAddTag(gszCairo, dwMask);
            hsAddTag(gszSur, dwMask);
            hsAddTag(gszSurplus, dwMask);
            hsAddTag(gsz35, dwMask);

        } else if (gdwOptions & HSO_OLDPROJSW_4) {
            gdwOptions |= HSO_INCINTERNAL;
            phst = hsAddTag(gszChicago, 0);
            if (phst == NULL) {
                return 0;
            }
            phst->dwMask |= HST_MAPOLD;
            dwMask = phst->dwMask;
            hsAddTag(gszNashville, dwMask);
            hsAddTag(gszWin40, dwMask);
            hsAddTag(gszWin40a, dwMask);

        } else if (!(gdwOptions & HSO_APPENDOUTPUT)) {
            gdwOptions |= HSO_OLDPROJSW_N;
        }

    } /* (gdOptions & HSO_OLDPROJW) */


    /*
     * Compatibility. If doing split only, don't include internal tags
     *  in public file
     */
    if (gdwOptions & HSO_SPLITONLY) {
        gdwOptions &= ~HSO_INCINTERNAL;
    }

    return argcParm - argc;

PrintHelp:
    hsLogMsg(HSLM_DEFAULT, "Header Split Utility. Version 2.1");
    hsLogMsg(HSLM_NOLABEL, "Usage: hsplit [options] <-o PublicFile InternalFile> [-i] File1 [-i] File2...");
    hsLogMsg(HSLM_NOLABEL, "\t[-4] Generate chicago/nashville headers");
    hsLogMsg(HSLM_NOLABEL, "\t[-bt2 BeginStr EndStr] Replace begin_internal/end_internal - Obsolete");
    hsLogMsg(HSLM_NOLABEL, "\t[-btb BeginStr EndStr] Replace begin_both/end_both tags - Obsolete");
    hsLogMsg(HSLM_NOLABEL, "\t[-c TagMarker] Replace tag marker. default \";\"");
    hsLogMsg(HSLM_NOLABEL, "\t[-e] Generate NT sur headers");
    hsLogMsg(HSLM_NOLABEL, "\t[[-i] file1 file2 ..] Input files - Required");
    hsLogMsg(HSLM_NOLABEL, "\t[-lt2 str] Replace internal tag - Obsolete");
    hsLogMsg(HSLM_NOLABEL, "\t[-ltb str] Replace both tag - Obsolete");
    hsLogMsg(HSLM_NOLABEL, "\t[-n] Generate NT headers - default");
    hsLogMsg(HSLM_NOLABEL, "\t[-x[a] ExtractHeader ExtractTag] Extract files and tags files");
    hsLogMsg(HSLM_NOLABEL, "\t[-o PublicHeader InternalHeader] Output files - Required");
    hsLogMsg(HSLM_NOLABEL, "\t[-p] Generate NT surplus headers");
    hsLogMsg(HSLM_NOLABEL, "\t[-s] Process internal and both tags only");
    hsLogMsg(HSLM_NOLABEL, "\t[-ta tag1 tag2 ..] Include lines using these tags");
    hsLogMsg(HSLM_NOLABEL, "\t[-ti tag1 tag2 ..] Ignore these tags");
    hsLogMsg(HSLM_NOLABEL, "\t[-ts tag1 tag2 ..] Skip lines using these tags");
    hsLogMsg(HSLM_NOLABEL, "\t[-u] Skip unknown tags. Default: ignore");
    hsLogMsg(HSLM_NOLABEL, "\t[-v] Version number. Default: LATEST_WIN32_WINNT_VERSION");
    hsLogMsg(HSLM_NOLABEL, "\r\nTags Format:");
    hsLogMsg(HSLM_NOLABEL, "\t<TagMarker>[begin/end][_public/internal][[_tag1][_tag2]...][_if_(str)_version | _version]");
    return 0;
}
/***************************************************************************\
* main
*
\***************************************************************************/
int __cdecl main (int argc, char *argv[])
{
    int argcProcessed;

    /*
     * Each loop processes one input file
     */
    do {
        argcProcessed = hsProcessParameters(argc, argv);
        if (argcProcessed == 0) {
            break;
        }

        if (!hsOpenWorkingFiles()
                || !hsSplit()) {

            return TRUE;
        }

        hsCloseWorkingFiles();

        gdwOptions |= HSO_APPENDOUTPUT;

        argc -= argcProcessed;
        argv += argcProcessed;

    } while (argc > 1);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hsplit\hsutil.c ===
/****************************** Module Header ******************************\
* Module Name: hsutil.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"
/***************************************************************************\
* soLosgMsg
\***************************************************************************/
void __cdecl hsLogMsg(DWORD dwFlags, char *pszfmt, ...)
{
    static BOOL gfAppending = FALSE;

    va_list va;

    if (!(dwFlags & HSLM_NOLABEL)) {
        if (gfAppending) {
            fprintf(stdout, "\r\n");
        }
        fprintf(stdout, "HSPLIT: ");
    }

    if (dwFlags & HSLM_ERROR) {
        if (dwFlags & HSLM_NOLINE) {
            hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, "Error: ");
        } else {
            hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, "Error (line %d): ", gdwLineNumber);
        }
    } else if (dwFlags & HSLM_WARNING) {
        if (dwFlags & HSLM_NOLINE) {
            hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, "Warning: ");
        } else {
            hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, "Warning (line %d): ", gdwLineNumber);
        }
    }

    va_start(va, pszfmt);
    vfprintf(stdout, pszfmt, va);
    va_end(va);

    if (dwFlags & HSLM_API) {
        hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, " Failed. GetLastError: %d", GetLastError());
    } else if (dwFlags & HSLM_UNEXPECTEDEOF) {
        hsLogMsg (HSLM_NOLABEL | HSLM_NOEOL, " found unexpected end of file");
    }

    gfAppending = (dwFlags & HSLM_NOEOL);
    if (!gfAppending) {
        fprintf(stdout, "\r\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hsplit\hsplit.h ===
/****************************** Module Header ******************************\
* Module Name: hsplit.h
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include <stdio.h>
#include <stddef.h>
#include <windows.h>

/***************************************************************************\
 * Defines
\***************************************************************************/
// hsLogMsg
#define HSLM_DEFAULT        0x0000
#define HSLM_NOLABEL        0x0001
#define HSLM_ERROR          0x0002
#define HSLM_WARNING        0x0004
#define HSLM_API            0x0008
#define HSLM_APIERROR       (HSLM_API | HSLM_ERROR)
#define HSLM_NOEOL          0x0010
#define HSLM_APPEND         (HSLM_NOLABEL | HSLM_NOEOL)
#define HSLM_NOLINE         0x0020
#define HSLM_UNEXPECTEDEOF  0x0040
#define HSLM_EOFERROR       (HSLM_UNEXPECTEDEOF | HSLM_ERROR)

/*
 * Tag mask bits.
 * IMPORTANT: If you add a tag mask bit,
 *  update HST_MASKBITCOUNT and HST_NEXTMASK
 */
/*
 * Types
 */
#define HST_DEFAULT             0x00000000
#define HST_ERROR               0x00000001
#define HST_MAPOLD              0x00000002
#define HST_SKIP                0x00000004
#define HST_UNKNOWN             0x00000008
#define HST_IGNORE              0x00000010

/*
 * Headers
 */
#define HST_PUBLIC              0x00000020
#define HST_INTERNAL            0x00000040
#define HST_BOTH                (HST_PUBLIC | HST_INTERNAL)
#define HST_USERINTERNALTAG     0x00000080
#define HST_USERBOTHTAG         0x00000100
#define HST_USERHEADERTAG       (HST_USERINTERNALTAG | HST_USERBOTHTAG)

/*
 * Blocks
 */
#define HST_BEGIN               0x00000200
#define HST_END                 0x00000400
#define HST_BLOCK               (HST_BEGIN | HST_END)
#define HST_IF                  0x00000800
#define HST_USERINTERNALBLOCK   0x00001000
#define HST_USERBOTHBLOCK       0x00002000
#define HST_USERBLOCK           (HST_USERINTERNALBLOCK | HST_USERBOTHBLOCK)


#define HST_WINVER              0x00004000
#define HST_INCINTERNAL         0x00008000
#define HST_INTERNALNOTCOMP     0x00010000

#define HST_EXTRACTONLY         0x00020000
#define HST_EXTRACT             0x00040000

/*
 * This is the count of HST_ bits; 32 - HST_MASKBITCOUNT is the number
 *  of tags that can be created from the command line parameters
 */
#define HST_LASTMASK            0x00040000
#define HST_USERTAGSMASK        0xFFF80000
#define HST_MAXMASK             0x80000000
#define HST_MASKBITCOUNT        19

/*
 * Options
 */
#define HSO_APPENDOUTPUT        0x00000001
#define HSO_OLDPROJSW_N         0x00000002
#define HSO_OLDPROJSW_4         0x00000004
#define HSO_OLDPROJSW_E         0x00000008
#define HSO_OLDPROJSW_P         0x00000010
#define HSO_OLDPROJSW           (HSO_OLDPROJSW_N | HSO_OLDPROJSW_4 | HSO_OLDPROJSW_E | HSO_OLDPROJSW_P)
#define HSO_SPLITONLY           0x00000020
#define HSO_INCINTERNAL         0x00000040
#define HSO_USERINTERNALBLOCK   0x00000080
#define HSO_USERBOTHBLOCK       0x00000100
#define HSO_USERBLOCK           (HSO_USERINTERNALBLOCK | HSO_USERBOTHBLOCK)
#define HSO_USERINTERNALTAG     0x00000200
#define HSO_USERBOTHTAG         0x00000400
#define HSO_USERHEADERTAG       (HSO_USERINTERNALTAG | HSO_USERBOTHTAG)
#define HSO_SKIPUNKNOWN         0x00000800

/***************************************************************************\
 * Structures
\***************************************************************************/

typedef struct _HSTAG
{
    SIZE_T dwLabelSize;
    char * pszLabel;
    DWORD dwMask;
} HSTAG, * PHSTAG;

typedef struct _HSBLOCK
{
    DWORD dwMask;
    char * pszifLabel;
    DWORD dwLineNumber;
} HSBLOCK, * PHSBLOCK;

typedef struct _HSEXTRACT
{
    struct _HSEXTRACT * pNext;
    char *              pszFile;
    HANDLE              hfile;
    DWORD               dwMask;
} HSEXTRACT, * PHSEXTRACT;

/***************************************************************************\
 * Macros
\***************************************************************************/
#define HSCSZSIZE(sz) sizeof(sz)-1
#define HSLABEL(sz) HSCSZSIZE(#sz), #sz


/***************************************************************************\
 * Globals
\***************************************************************************/
/*
 * Files
 */
extern char * gpszInputFile;
extern HANDLE ghfileInput;
extern char * gpszPublicFile;
extern HANDLE ghfilePublic;
extern char * gpszInternalFile;
extern HANDLE ghfileInternal;

extern PHSEXTRACT gpExtractFile;

/*
 * Map file
 */
extern HANDLE ghmap;
extern char * gpmapStart;
extern char * gpmapEnd;

/*
 * Switches et al
 */
extern DWORD gdwOptions;
extern DWORD gdwVersion;
extern char gszVerifyVersionStr [];
extern DWORD gdwFilterMask;
extern char * gpszTagMarker;
extern DWORD gdwTagMarkerSize;
extern char gszMarkerCharAndEOL [];

extern DWORD gdwLineNumber;

/*
 * Compatibility tags.
 * Specify size so sizeof operator can be used to calculate strlen at
 *  compile time
 */
extern char gsz35 [3];
extern char gszCairo [6];
extern char gszChicago [8];
extern char gszNashville [10];
extern char gszNT [3];
extern char gszSur [4];
extern char gszSurplus [8];
extern char gszWin40 [6];
extern char gszWin40a [7];

/*
 * Tag labels
 * Specify size so sizeof operator can be used to calculate table size at
 *  compile time
 */
extern HSTAG ghstPredefined [16];

extern PHSTAG gphst;
extern DWORD gdwLastTagMask;

/*
 * Blocks stack
 */
#define HSBSTACKSIZE 20
extern HSBLOCK ghsbStack [HSBSTACKSIZE];
#define HSBSTACKLIMIT (ghsbStack + HSBSTACKSIZE - 1)
extern PHSBLOCK gphsbStackTop;

/***************************************************************************\
 * Funtion Prototypes
\***************************************************************************/
// hsfile.c
BOOL hsCloseWorkingFiles (void);
BOOL hsOpenWorkingFiles (void);
BOOL hsWriteHeaderFiles (char * pmap, DWORD dwSize, DWORD dwFlags);

// hsparse.c
PHSTAG hsFindTagInList (PHSTAG phst, char * pmapTag, DWORD dwTagSize);
BOOL hsSplit (void);

// hsutil.c
void __cdecl hsLogMsg(DWORD dwFlags, char *pszfmt, ...);

/***************************************************************************\
 * Inline functions
\***************************************************************************/
__inline BOOL hsVersionFromString (char * pString, DWORD dwSize, DWORD * pdwVersion)
{
    return sscanf(pString, "%x", pdwVersion)
            && (dwSize == (DWORD)sprintf(gszVerifyVersionStr, "%x", *pdwVersion));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\hsplit\hsparse.c ===
/****************************** Module Header ******************************\
* Module Name: hsparse.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 09/05/96 GerardoB Created
\***************************************************************************/
#include "hsplit.h"
/***************************************************************************\
* Globals
\***************************************************************************/
/*
 * #if - #endif strings
 * Compatibility: no space after #if and ( -- breaks wcshdr.exe
 */
static char gszIfStart [] = "\r\n#if(" ;
static char gszIfStop [] = ")";
static char gszDefCompOperator [] = ">=";
static char gszLessThan [] = "<";
static char gszEndStart [] = "\r\n#endif /* ";
static char gszEndStop [] = " */";

static char gszNewLine [] = "\r\n";
/*********************************************************************
* hsWriteNewLine
\***************************************************************************/
__inline BOOL hsWriteNewLine (DWORD dwMask)
{
    return hsWriteHeaderFiles(gszNewLine, sizeof(gszNewLine)-1, dwMask);
}
/***************************************************************************\
* hsFindFirstSubTag
\***************************************************************************/
char * hsFindFirstSubTag(char * pmap)
{
    /*
     * pmap points to the beginning of the tag marker. So skip it
     *  and any spaces after it
     */
    pmap += gdwTagMarkerSize;
    while (pmap < gpmapEnd) {
        if (*pmap == ' ') {
            pmap++;
        } else {
            return pmap;
        }
    }

    hsLogMsg(HSLM_EOFERROR, "hsFindFirstSubTag");
    return NULL;
}
/*********************************************************************
* hsFindFirstCharInString
*
* Finds the first occurrence of any character in psz
\***************************************************************************/
char * hsFindFirstCharInString (char * pmap, char * psz)
{
    char * pszNext;

    while (pmap < gpmapEnd) {
        /*
         * Compare current char to all chars in psz
         */
        pszNext = psz;
        do {
            if (*pmap == *pszNext++) {
                return pmap;
            }
        } while (*pszNext != '\0');

        pmap++;
    }

    return NULL;
}
/*********************************************************************
* hsFindEndOfString
\***************************************************************************/
__inline char * hsFindEndOfString (char * pmap)
{
    return hsFindFirstCharInString(pmap, " " "\r");
}
/***************************************************************************\
* hsIsString
\***************************************************************************/
BOOL hsIsString (char * pmap, char * psz)
{
    while (*psz != '\0') {
        if (pmap >= gpmapEnd) {
            return FALSE;
        }
        if (*pmap++ != *psz++) {
            return FALSE;
        }
    }

    return TRUE;
}
/***************************************************************************\
* hsFindTagMarker
\***************************************************************************/
char * hsFindTagMarker(char * pmap, char ** ppmapLineStart)
{
    char * pmapMarker;

    while (pmap < gpmapEnd) {
        /*
         * If this is the first character of the marker
         */
        if (*pmap == *gpszTagMarker) {
            /*
             * If this is the marker, find the last one in this line
             */
            if (hsIsString(pmap + 1, gpszTagMarker + 1)) {
                pmapMarker = pmap++;
                do {
                    /*
                     * Find the EOL or the first char of the next marker
                     */
                    pmap = hsFindFirstCharInString(pmap, gszMarkerCharAndEOL);
                    /*
                     * If EOL or end of map, return
                     */
                    if ((pmap == NULL) || (*pmap != *gpszTagMarker)) {
                        return pmapMarker;
                    }
                   /*
                    * If this is the marker, update pmapMarker
                    */
                   if (hsIsString(pmap + 1, gpszTagMarker + 1)) {
                        pmapMarker = pmap;
                   }
                   /*
                    * It wasn't a marker, keep looking for EOL
                    */
                   pmap++;
                } while (TRUE);
            } else {
                /*
                 * This wasn't the marker, continue parsing
                 */
                pmap++;
                continue;
            }
        } /* if (*pmap == *gpszTagMarker) */

        /*
         * If this is the end of a line, update *ppmapLineStart and
         *  gdwLineNumber. The line begins before the EOL
         */
        if (*pmap++ == '\r') {
            if (pmap >= gpmapEnd) {
                hsLogMsg(HSLM_EOFERROR, "hsFindTagMarker");
                return NULL;
            }
            if (*pmap++ != '\n') {
                hsLogMsg(HSLM_ERROR, "Missing \\n after \\r");
                return FALSE;
            }
            *ppmapLineStart = pmap - 2;
            gdwLineNumber++;
            continue;
        }
    } /* while (pmap < pmapEnd) */

    return NULL;
}
/***************************************************************************\
* hsSkipTag
\***************************************************************************/
char * hsSkipTag(char * pmap)
{

    while (pmap < gpmapEnd) {
        switch (*pmap) {
            case '_':
            case ' ':
            case '\r':
                return pmap;

            default:
                pmap++;
        }
    }

    hsLogMsg(HSLM_EOFERROR, "hsSkipTag");
    return NULL;
}
/***************************************************************************\
* hsSkipEmptyLines
* If there are multiple empty lines, skip all but one
\***************************************************************************/
char * hsSkipEmptyLines(char * pmap)
{
    char * pmapCurrentLine, *pmapLastEmptyLine;

    pmapCurrentLine = pmapLastEmptyLine = pmap;
    pmap++;
    while (pmap < gpmapEnd) {
        switch (*pmap) {
           case '\r':
                gdwLineNumber++;
                pmapLastEmptyLine = pmapCurrentLine;
                pmapCurrentLine = pmap;

            case '\n':
            case ' ':
                pmap++;
                break;

            default:
                /*
                 * If we've found more than one line,
                 * adjust line number since we're not skipping
                 * the last line we found
                 */
                if (pmapCurrentLine != pmapLastEmptyLine) {
                    gdwLineNumber--;
                }
                return pmapLastEmptyLine;
        }
    }

    return gpmapEnd;

}
/***************************************************************************\
* hsIsEmpty
* Returns TRUE if there is nothing but spaces and \r\n
\***************************************************************************/
BOOL hsIsEmpty(char * pmap, char * pmapEnd)
{
    while (pmap < pmapEnd) {
        switch (*pmap++) {
            case '\n':
            case '\r':
            case ' ':
                break;

            default:
                return FALSE;
        }
    }
    return TRUE;
}
/***************************************************************************\
* hsLastRealChar
* Returns a pointer past the last non-space non-line-break char.
* If there are multiple empty lines, returns a pointer past the last line break
\***************************************************************************/
char * hsLastRealChar(char * pmapLinesStart, char * pmap)
{

    char * pmapCurrentLine, *pmapLastEmptyLine;

    pmap--;
    pmapCurrentLine = pmapLastEmptyLine = NULL;
    while (pmapLinesStart < pmap) {
        switch (*pmap) {
            case '\n':
                pmapLastEmptyLine = pmapCurrentLine;
                pmapCurrentLine = pmap;
            case '\r':
            case ' ':
                pmap--;
                break;

            default:
                goto FoundIt;
        }
    }

FoundIt:
    /*
     * If we found multiple lines or spaces,
     *  then return a pointer to the last empty line
     * else if we didn't reach pmapLinesStart, we're at the last real char
     * else we're on an empty line
     */
    if (pmapLastEmptyLine != pmapCurrentLine) {
        if (pmapLastEmptyLine != NULL) {
            return pmapLastEmptyLine + 1;
        } else {
            return pmapCurrentLine + 1;
        }
    } else if (pmap > pmapLinesStart) {
        return pmap + 1;
    } else {
        return pmapLinesStart;
    }

}
/***************************************************************************\
* hsFindEOL
*
\***************************************************************************/
char * hsFindEOL(char * pmap)
{
    while (pmap < gpmapEnd) {
        if (*pmap++ == '\r') {
            if (pmap >= gpmapEnd) {
                hsLogMsg(HSLM_EOFERROR, "hsFindEOL");
                return NULL;
            }
            if (*pmap != '\n') {
                hsLogMsg(HSLM_ERROR, "Missing \\n after \\r");
                return NULL;
            }
            gdwLineNumber++;
            return pmap - 1;
        }
    }

    return NULL;
}
/***************************************************************************\
* hsFindTagInList
*
\***************************************************************************/
PHSTAG hsFindTagInList (PHSTAG phst, char * pmapTag, DWORD dwTagSize)
{

    while (phst->dwLabelSize != 0) {

        if ((phst->dwLabelSize == dwTagSize)
                && !_strnicmp(phst->pszLabel, pmapTag, dwTagSize)) {

            return phst;
        }
        phst++;
    }

    return NULL;

}
/***************************************************************************\
* hsSkipBlockTagIfPresent
*
\***************************************************************************/
char * hsSkipBlockTagIfPresent (char * pmap, DWORD * pdwMask)
{
    static char gszBegin [] = "begin";
    static char gszEnd [] = "end";

    char * pmapTag;
    DWORD dwTagSize;
    PHSTAG phst;

    /*
     * Remember the beginning of the tag
     */
    pmapTag = pmap;

    /*
     * Compatibility. Deal with old lt? and bt? switches.
     * If the whole tag was added to the tag list, get the flags
     *  and stop parsing.
     */
    if (gdwOptions & (HSO_USERBLOCK | HSO_USERHEADERTAG)) {
        pmap = hsFindEndOfString(pmap);
        if ((pmap != NULL) && (pmap != pmapTag)) {
            phst = hsFindTagInList (gphst, pmapTag, (DWORD)(pmap - pmapTag));
            if (phst != NULL) {
                *pdwMask |= phst->dwMask;
                return pmap;
            }
        }

        /*
         * Didn't find the string in the table so restore pmap and continue
         */
        pmap = pmapTag;
    }


    /*
     * Find the end of the current tag
     */
    pmap = hsSkipTag(pmap);
    if ((pmap == NULL) || (pmap == pmapTag)) {
        return pmap;
    }

    dwTagSize = (DWORD)(pmap - pmapTag);

    /*
     * If at separator, skip so the caller won't have to deal with it
     */
    if (*pmap == '_') {
        pmap++;
    }

    /*
     * begin tag
     */
    if ((HSCSZSIZE(gszBegin) == dwTagSize)
            && !_strnicmp(gszBegin, pmapTag, dwTagSize)) {

        *pdwMask |= HST_BEGIN;
        return pmap;
    }

    /*
     * end tag
     */
    if ((HSCSZSIZE(gszEnd) == dwTagSize)
            && !_strnicmp(gszEnd, pmapTag, dwTagSize)) {

        *pdwMask |= HST_END;
        return pmap;
    }

    return pmapTag;

}
/***************************************************************************\
* hsPopBlock
*
\***************************************************************************/
BOOL hsPopBlock (void)
{
    /*
     * Check for underflow
     */
    if (gphsbStackTop <= ghsbStack) {
        hsLogMsg(HSLM_ERROR, "Block stack underflow!");
        return FALSE;
    }

    if (gphsbStackTop->pszifLabel != NULL) {
        LocalFree(gphsbStackTop->pszifLabel);
    }

    gphsbStackTop--;

    return TRUE;
}
/***************************************************************************\
* hsPushBlock
*
\***************************************************************************/
BOOL hsPushBlock(void)
{
    /*
     * Make sure we got room in the block stack
     */
    if (gphsbStackTop >= HSBSTACKLIMIT) {
        hsLogMsg(HSLM_ERROR, "Too many nested blocks. Artificial limit:%#lx", HSBSTACKSIZE);
        return FALSE;
    }

    /*
     * Grow the stack and initialize the new entry
     */
    gphsbStackTop++;
    ZeroMemory(gphsbStackTop, sizeof(*gphsbStackTop));
    gphsbStackTop->dwLineNumber = gdwLineNumber;

    /*
     * propagate the mask
     */
    gphsbStackTop->dwMask |= (gphsbStackTop - 1)->dwMask;

    return TRUE;
}
/***************************************************************************\
* hsSkipBlock
*
\***************************************************************************/
char * hsSkipBlock(char * pmap)
{
    char * pmapLineStart;
    DWORD dwMask;

    while (pmap < gpmapEnd) {
        /*
         * Find the next marker (; by default)
         */
        pmap = hsFindTagMarker(pmap, &pmapLineStart);
        if (pmap == NULL) {
            return NULL;
        }

        /*
         * Skip the marker and any spaces after it
         */
        pmap = hsFindFirstSubTag(pmap);
        if (pmap == NULL) {
            return NULL;
        }

        /*
         * Check if this is the beginning-end of a block
         */
        dwMask = 0;
        pmap = hsSkipBlockTagIfPresent(pmap, &dwMask);
        if (pmap == NULL) {
            return NULL;
        }

        /*
         * If it found the beginning of another block, push it in the
         *  the stack and skip it.
         */
        if (dwMask & HST_BEGIN) {
            if (!hsPushBlock()) {
                return NULL;
            }
            pmap = hsSkipBlock(pmap);
            if (pmap == NULL) {
                return NULL;
            }
        } else if (dwMask & HST_END) {
            /*
             * It found the end of the block; pop it out of the stack
             *  and return the beginning of the next line
             */
            if (!hsPopBlock()) {
                return NULL;
            }
            return hsFindEOL(pmap);
        }

        /*
         * It wasn't a block tag so keep going
         */
        pmap++;
    }

    return NULL;
}
/***************************************************************************\
* hsBuildifString
*
\***************************************************************************/
BOOL hsBuildifString(char * pString, DWORD dwStringSize, char * pCompOperator, DWORD dwCompOperatorSize)
{
    char * psz;

    /*
     * Use default operator if none was provided.
     */
    if (pCompOperator == NULL) {
        pCompOperator = gszDefCompOperator;
        dwCompOperatorSize = HSCSZSIZE(gszDefCompOperator);
    }

    /*
     * Make a NULL terminated copy. Allocate enough space for the
     *  "label CompOperator version" string: 2 spaces + 10 digits (0xl#) +
     *  null termination
     */
    psz = (char *) LocalAlloc(LPTR, dwStringSize + dwCompOperatorSize + 13);
    if (psz == NULL) {
        hsLogMsg(HSLM_APIERROR, "LocalAlloc");
        hsLogMsg(HSLM_ERROR, "hsBuildifString allocation failed. Size:%#lx", dwStringSize+ dwCompOperatorSize + 13);
        return FALSE;
    }

    /*
     * Save it in the stack.
     */
    gphsbStackTop->pszifLabel = psz;

    /*
     * Build the string (the right side of the comparison (version) will
     *  be added later when available.
     */
    strncpy(psz, pString, dwStringSize);
    psz += dwStringSize;
    *psz++ = ' ';
    strncpy(psz, pCompOperator, dwCompOperatorSize);
    psz += dwCompOperatorSize;
    *psz++ = ' ';

    return TRUE;
}
/***************************************************************************\
* hsParseAndBuildifString
*
\***************************************************************************/
char * hsParseAndBuildifString(char * pmap, BOOL fSkip)
{
    BOOL fEnclosed;
    char * pmapTag, * pCompOperator;
    DWORD dwTagSize, dwCompOperatorSize;

    /*
     * Skip the tag concatenator (_)
     */
    if (*pmap++ != '_') {
        hsLogMsg(HSLM_ERROR, "Expected '_' after if tag");
        return NULL;
    }

    if (pmap >= gpmapEnd) {
        hsLogMsg(HSLM_EOFERROR, "hsParseAndBuildifString");
        return NULL;
    }

    /*
     * Find the end of the string. If it starts wiht '(', then the string
     *  is enclosed in parens. This is for strings that use _ (like _WIN32_WINDOWS)
     */
    pmapTag = pmap;
    fEnclosed = (*pmap == '(');
    if (fEnclosed) {
        pmapTag = ++pmap;
        pmap = hsFindFirstCharInString(pmap, ")" " " "\r");
        if ((pmap == NULL) || (*pmap != ')')) {
            hsLogMsg(HSLM_ERROR, "Expected ')' after if_(");
            return NULL;
        }
    } else {
        pmap = hsSkipTag(pmap);
        if ((pmap == NULL) || (pmap == pmapTag)) {
            hsLogMsg(HSLM_ERROR, "Expected string after if_");
            return NULL;
        }
    }
    dwTagSize = (DWORD)(pmap - pmapTag);


    /*
     * Skip the ')'
     */
    if (fEnclosed) {
        pmap++;
        if (pmap >= gpmapEnd) {
            hsLogMsg(HSLM_EOFERROR, "hsParseAndBuildifString");
            return NULL;
        }
    }

    /*
     * If a comparison operator follows, use it
     */
   if ((pmap + 1 < gpmapEnd) && (*pmap == '_')) {
       switch (*(pmap + 1)) {
           case '=':
           case '>':
           case '<':
               pCompOperator = ++pmap;
               pmap = hsSkipTag(pmap);
               if ((pmap == NULL) || (pmap == pCompOperator)) {
                   hsLogMsg(HSLM_EOFERROR, "hsParseAndBuildifString");
                   return NULL;
               }
               dwCompOperatorSize = (DWORD)(pmap - pCompOperator);
               break;

           default:
               pCompOperator = NULL;
               break;
       }
   }


    /*
     * Build the stirng a copy it into the block stack
     */
    if (!fSkip) {
        if (!hsBuildifString(pmapTag, (DWORD)dwTagSize, pCompOperator, (DWORD)dwCompOperatorSize)) {
            return NULL;
        }
    }

    return pmap;

}
/***************************************************************************\
* hsMapOldTag
*
\***************************************************************************/
BOOL hsMapOldTag(char * pmapTag, DWORD dwTagSize, DWORD * pdwTagMask, DWORD * pdwVersion)
{
    static char gszifWinver [] = "WINVER";
    static char gszif_WIN32_WINDOWS [] = "_WIN32_WINDOWS";
    static char gszif_WIN32_WINNT [] = "_WIN32_WINNT";

    char * pszLabel;
    UINT uSize;

    /*
     * Old tags must have a block or header bit set. Otherwise, they
     *  should be ignored
     */
    if (!(*pdwTagMask & (HST_BOTH | HST_BLOCK))) {
        *pdwTagMask |= HST_IGNORE;
        return TRUE;
    }

    /*
     * No mapping needed if at the end of a block or HST_SKIP is the only
     *  additional flag set.
     */
    if ((*pdwTagMask & HST_END)
        || ((*pdwTagMask & ~(HST_BLOCK | HST_USERBLOCK | HST_BOTH | HST_USERHEADERTAG))
                == (HST_SKIP | HST_MAPOLD))) {

        return TRUE;
    }

    /*
     * winver maps to if_winver
     */
    if (*pdwTagMask & HST_WINVER) {

        /*
         * Compatibility
         */
        if (!(gdwOptions & HSO_OLDPROJSW_4)
                && (*pdwTagMask & HST_INTERNAL)
                && !(gdwOptions & HSO_OLDPROJSW_E)) {

            *pdwTagMask |= HST_SKIP;
            return TRUE;
        }

        pszLabel = gszifWinver;
        uSize = HSCSZSIZE(gszifWinver);
        goto AddIf;
    }

    /*
     * nashville maps to if_(_WIN32_WINDOWS)_40a
     */
    if ((dwTagSize == HSCSZSIZE(gszNashville)) && !_strnicmp(pmapTag, gszNashville, dwTagSize)) {

        *pdwVersion = 0x40a;
        pszLabel = gszif_WIN32_WINDOWS;
        uSize = HSCSZSIZE(gszif_WIN32_WINDOWS);
        goto AddIf;
    }
    /*
     * sur and surplus map to if_(_WIN32_WINNT)_400 if public
     */
    if ((dwTagSize == HSCSZSIZE(gszSur)) && !_strnicmp(pmapTag, gszSur, dwTagSize)
        || (dwTagSize == HSCSZSIZE(gszSurplus)) && !_strnicmp(pmapTag, gszSurplus, dwTagSize)) {

        if (*pdwTagMask & HST_INTERNAL) {
            return TRUE;
        }

        *pdwVersion = 0x400;
        pszLabel = gszif_WIN32_WINNT;
        uSize = HSCSZSIZE(gszif_WIN32_WINNT);
        goto AddIf;
    }
    /*
     * 35 is excluded when building for old switch e and p
     */
    if ((dwTagSize == HSCSZSIZE(gsz35)) && !_strnicmp(pmapTag, gsz35, dwTagSize)) {

        *pdwTagMask |= HST_SKIP;
        return TRUE;
    }

    return TRUE;

AddIf:
        *pdwTagMask |= HST_IF;
        /*
         * If we're not in a block, push one to save the string
         */
        if (!(*pdwTagMask & HST_BEGIN)) {
            if (!hsPushBlock()) {
                return FALSE;
            }
        }

        if (!hsBuildifString(pszLabel, uSize, NULL, 0)) {
            return FALSE;
        }

    return TRUE;
}
/***************************************************************************\
* hsParseTag
*
\***************************************************************************/
DWORD hsParseTag(char * pmap, DWORD * pdwVersion)
{
    char * pmapTag;
    DWORD dwTagMask = HST_DEFAULT;
    DWORD dwTagSize;
    PHSTAG phst;

    *pdwVersion = 0;

    /*
     * Skip the marker and any spaces after it
     */
    pmap = hsFindFirstSubTag(pmap);
    if (pmap == NULL) {
        return HST_DEFAULT;
    }

    /*
     * Check for begin-end of block
     */
    pmap = hsSkipBlockTagIfPresent(pmap, &dwTagMask);
    if (pmap == NULL) {
        return HST_DEFAULT;
    }

    /*
     * If this the beginning of a block, push in the stack
     *  skip the tag concatenator (_)
     */
    if (dwTagMask & HST_BEGIN) {
        if (!hsPushBlock()) {
            return HST_ERROR;
        }
    }

    /*
     * Build tag mask. Tags are concatenated by underscores (_); each
     *  iteration of this loop processes one "sub-tag"
     */
    do {
        /*
         * Find current tag end. Bail if at last one.
         */
        pmapTag = pmap;
        pmap = hsSkipTag(pmap);
        if ((pmap == NULL) || (pmap == pmapTag)) {
            break;
        }

        /*
         * Look up the tag
         */
        dwTagSize = (DWORD)(pmap - pmapTag);
        phst = hsFindTagInList (gphst, pmapTag, dwTagSize);
        if (phst != NULL) {
            dwTagMask |= phst->dwMask;
            /*
             * Compatibility
             * If this is an old tag, map it.
             * No mapping needed if doing split only (tag is going to be
             *  ignored)
             */
            if ((dwTagMask & HST_MAPOLD)
                    && !(gdwOptions & HSO_SPLITONLY)) {

                if (!hsMapOldTag(pmapTag, dwTagSize, &dwTagMask, pdwVersion)) {
                    return HST_ERROR;
                }

            } else {
                /*
                 * If this is an if tag, copy the block string
                 */
                if (phst->dwMask & HST_IF) {
                    BOOL fEndBlock;
                    /*
                     * If not in a block, push a fake one in to save the string
                     */
                    if (!(dwTagMask & HST_BLOCK)) {
                        if (!hsPushBlock()) {
                            return HST_ERROR;
                        }
                    }
                    /*
                     * If we're at the end of a block, we want to skip
                     *  the if string (already taken care of at begin tag)
                     */
                    fEndBlock = (dwTagMask & HST_END);
                    if (fEndBlock) {
                        dwTagMask &= ~HST_IF;
                    }
                    pmap = hsParseAndBuildifString(pmap, fEndBlock);
                    if (pmap == NULL) {
                        return HST_ERROR;
                    }
                }
            } /* if ((dwTagMask & HST_MAPOLD)... */
        } else {
            /*
             * If this is not the version number, then this is an unkown tag
             */
            if (!hsVersionFromString (pmapTag, dwTagSize, pdwVersion)) {
                dwTagMask |= HST_UNKNOWN;
            }
        } /* if (phst != NULL) */

    } while (*pmap++ == '_');

    /*
     * Bail if we didn't find any tags
     */
    if (dwTagMask == HST_DEFAULT) {
        return HST_DEFAULT;
    }

   /*
    * Unknown tags are to be skipped or ignored
    */
   if (dwTagMask & HST_UNKNOWN) {
        if (gdwOptions & HSO_SKIPUNKNOWN) {
            dwTagMask |= HST_SKIP;
        } else {
            goto IgnoreTag;
        }
   }

   /*
    * Ignore the tag if marked as such
    */
   if (dwTagMask & HST_IGNORE) {
       goto IgnoreTag;
   }

    /*
     * Compatibility hack. public_winver_40a is not included for old -n and
     *  it's internal for old -e. 400 is goes to both headers for -n
     */
   if (dwTagMask & HST_WINVER) {
        if (*pdwVersion == 0x40a) {
            if (gdwOptions & HSO_OLDPROJSW_E) {
                dwTagMask |= HST_INTERNAL;
                dwTagMask &= ~HST_PUBLIC;
            } else if (gdwOptions & HSO_OLDPROJSW_N) {
                dwTagMask |= HST_SKIP;
            }
        } else if ((*pdwVersion == 0x400)
                && (gdwOptions & HSO_OLDPROJSW_N)) {

            dwTagMask |= HST_INTERNALNOTCOMP | HST_BOTH;
        }
   }

   /*
    * if using old lt2, ltb, bt2 or btb switches,
    *  then both/internal tag/block must be skipped
    */
   if ((gdwOptions & (HSO_USERBLOCK | HSO_USERHEADERTAG))
        && !(dwTagMask & ~(HST_BLOCK | HST_BOTH))) {

       if ((gdwOptions & HSO_USERINTERNALBLOCK)
                && ((dwTagMask == (HST_BEGIN | HST_INTERNAL))
                    || (dwTagMask == (HST_END | HST_INTERNAL)))) {

            dwTagMask &= HST_BLOCK;
            dwTagMask |= HST_SKIP;

       } else if ((gdwOptions & HSO_USERBOTHBLOCK)
                && ((dwTagMask == (HST_BEGIN | HST_BOTH))
                    || (dwTagMask == (HST_END | HST_BOTH)))) {

           dwTagMask &= HST_BLOCK;
           dwTagMask |= HST_SKIP;

       } else if ((gdwOptions & HSO_USERINTERNALTAG)
                && (dwTagMask == HST_INTERNAL)) {

           dwTagMask = HST_SKIP;

       } else if ((gdwOptions & HSO_USERBOTHTAG)
                && (dwTagMask == HST_BOTH)) {

           dwTagMask = HST_SKIP;
       }
   } /* if ((gdwOptions & (HSO_USERBLOCK | HSO_USERHEADERTAG))... */


   /*
    * If doing split only, anything other than both/internal is treated
    *  as untagged. If we pushed a block, pop it out as it will be ignored
    */
   if (gdwOptions & HSO_SPLITONLY) {
        if (dwTagMask & ~(HST_BLOCK | HST_USERBLOCK | HST_BOTH | HST_USERHEADERTAG)) {
            goto IgnoreTag;
        }
        *pdwVersion = 0;
   }


    /*
     * If this is the beginning of a block, save the mask in the block stack
     */
    if (dwTagMask & HST_BEGIN) {
        gphsbStackTop->dwMask |= dwTagMask;
    }

    return dwTagMask;


IgnoreTag:
    /*
     * If a block was pushed, pop it out.
     */
    if (dwTagMask & HST_BEGIN) {
        if (!hsPopBlock()) {
            return HST_ERROR;
        }
    }

    *pdwVersion = 0;
    return HST_DEFAULT;

}
/***************************************************************************\
* hsBeginEndBlock
*
\***************************************************************************/
BOOL hsBeginEndBlock (DWORD dwMask, DWORD dwVersion)
{

    char * psz;
    UINT uPasses;

    /*
     * Compatibility. If writting this block to the internal header
     *  using the not comp (ie., from >= to <), then do two passes
     *  writing one header each time.
     */
    if (dwMask & HST_INTERNALNOTCOMP) {
        uPasses = 2;
        if (dwMask & HST_BEGIN) {
            /*
             * Write public header first
             */
            dwMask &= ~HST_INTERNAL;
        } else {
            /*
             * Write internal header first
             */
            dwMask &= ~HST_PUBLIC;
        }
    } else {
        uPasses = 1;
    }

    /*
     * Add version to the string
     */
    if (dwMask & HST_BEGIN) {

        /*
         * Beginning of block or if
         * If there is no if string, done
         */
        if (gphsbStackTop->pszifLabel == NULL) {
            return TRUE;
        }

        /*
         * Something is fishy is dwVersion is 0
         */
        if (dwVersion == 0) {
            hsLogMsg(HSLM_ERROR, "if tag without version");
            return FALSE;
        }
        sprintf(gphsbStackTop->pszifLabel + strlen(gphsbStackTop->pszifLabel),
                "%#06lx", dwVersion);

    }


    /*
     * Write headers
     */
    do {
        if (dwMask & HST_BEGIN) {

            /*
             * Write #if to output file
             */
            if (!hsWriteHeaderFiles(gszIfStart, HSCSZSIZE(gszIfStart), dwMask)
                    || !hsWriteHeaderFiles(gphsbStackTop->pszifLabel, lstrlen(gphsbStackTop->pszifLabel), dwMask)
                    || !hsWriteHeaderFiles(gszIfStop, HSCSZSIZE(gszIfStop), dwMask)) {

                return FALSE;
            }

        } else {
            /*
             * End of block or if
             * If there is an if string, Write #endif to output file
             */
            if (gphsbStackTop->pszifLabel != NULL) {

                if (!hsWriteHeaderFiles(gszEndStart, HSCSZSIZE(gszEndStart), dwMask)
                        || !hsWriteHeaderFiles(gphsbStackTop->pszifLabel, lstrlen(gphsbStackTop->pszifLabel), dwMask)
                        || !hsWriteHeaderFiles(gszEndStop, HSCSZSIZE(gszEndStop), dwMask)) {

                    return FALSE;
                }
            }
        }

        /*
         * If doing a second pass, fix the mask and the string
         */
        if (uPasses > 1) {
            psz = gphsbStackTop->pszifLabel;
            if (dwMask & HST_BEGIN) {
                /*
                 * Write internal header now
                 */
                dwMask &= ~HST_PUBLIC;
                dwMask |= HST_INTERNAL;

                /*
                 * From >= to <
                 */
                while (*psz != '>') {
                    psz++;
                }
                *psz++ = '<';
                *psz = ' ';
            } else {
                /*
                 * Write public header now
                 */
                dwMask &= ~HST_INTERNAL;
                dwMask |= HST_PUBLIC;
                /*
                 * From < to >=
                 */
                while (*psz != '<') {
                    psz++;
                }
                *psz++ = '>';
                *psz = '=';
            }
        }

    } while (--uPasses != 0);


    /*
     * Clean up the block if at the end
     */
    if (dwMask & HST_END) {
        if (!hsPopBlock()) {
            return FALSE;
        }
    }


    return TRUE;
}
/***************************************************************************\
* hsSplit
*
\***************************************************************************/
BOOL hsSplit (void)
{
    BOOL fSkip;
    char * pmap, *pmapLineStart, *pmapLastLineStart, *pmapMarker, *pmapLastChar;
    DWORD dwMask, dwVersion, dwPreviousMask, dwLastMask;

    /*
     *  Initialize block stack top, map pointer, etc
     */
    ZeroMemory(gphsbStackTop, sizeof(*gphsbStackTop));
    dwLastMask = 0;
    pmap = pmapLineStart = pmapLastLineStart = gpmapStart;
    gdwLineNumber = 1;

    while (pmap < gpmapEnd) {
        /*
         * Find the marker and the line it is on
         */
        pmap = hsFindTagMarker(pmap, &pmapLineStart);
        if (pmap == NULL) {
            break;
        }

        /*
         * Parse the tag
         */
        dwMask = hsParseTag(pmap, &dwVersion);
        if (dwMask & HST_ERROR) {
            return FALSE;
        }

        /*
         * If this wasn't a tag (just the tag marker), continue
         */
        if ((dwMask == HST_DEFAULT) && (dwVersion == 0)) {
            pmap++;
            continue;
        }

        /*
         * Write any previous non-empty (untagged) lines.
         * If we're about to start a block, make sure to use the right mask.
         */
        dwPreviousMask = ((dwMask & (HST_BEGIN | HST_IF)) ? (gphsbStackTop - 1)->dwMask : gphsbStackTop->dwMask);
        pmapLastChar = hsLastRealChar(pmapLastLineStart, pmapLineStart);
        if (pmapLastLineStart < pmapLastChar) {
            /*
             * Empty lines between internal (block) tags go to the internal file
             */
            if (!(dwPreviousMask & HST_BOTH)
                    && ((dwMask & HST_BOTH) == HST_INTERNAL)
                    && ((dwLastMask & HST_BOTH) == HST_INTERNAL)
                    && hsIsEmpty(pmapLastLineStart, pmapLastChar)) {

                dwPreviousMask |= HST_INTERNAL;
            }

            if (!hsWriteHeaderFiles(pmapLastLineStart, (DWORD)(pmapLastChar - pmapLastLineStart), dwPreviousMask)) {
                return FALSE;
            }
        }

        /*
         * Determine if this tag is to be skipped.
         * If we're at the END tag, then we include it since the block was
         *  already included.
         * If gdwFilterMask contains any user-defined tags, then they must
         *  be present or the block is to be skipped -- note that this only
         *  applies for not HST_SKIP | HST_IGNORE blocks.
         */

        fSkip = (!(dwMask & HST_END)
                    && ((dwMask & HST_SKIP)
                        || (gdwVersion < dwVersion)
                        || ((gdwFilterMask & HST_USERTAGSMASK)
                             &&  ((gdwFilterMask & dwMask  & HST_USERTAGSMASK) != (dwMask & HST_USERTAGSMASK)))));


        /*
         * If it is to be skipped, do it
         */
        if (fSkip) {
            /*
             * If it's a block, skip the marker and the skip the block
             * Otherwise, skip the current line
             */
            if (dwMask & HST_BEGIN) {
                pmap = hsSkipBlock(++pmap);
            } else {
                /*
                 * If this was an if tag with no begin-end block, pop
                 *  the fake block out of the stack.
                 */
                if (dwMask & HST_IF) {
                    if (!hsPopBlock()) {
                        return FALSE;
                    }
                }

                /*
                 * Go to the beginning of the next line.
                 */
                pmap = hsFindEOL(pmap);
            }
            if (pmap == NULL) {
                return TRUE;
            }

            goto SkipEmptyLines;
        }

        /*
         * remember the marker position and the tag
         */
        pmapMarker = pmap;
        dwLastMask = dwMask;

        /*
         * For old switch 4, internal tags go into the public header
         */
        if ((gdwOptions & HSO_INCINTERNAL) && ((dwMask & HST_BOTH) == HST_INTERNAL)) {
            dwMask |= HST_INCINTERNAL;
            if (dwMask & HST_BEGIN) {
                gphsbStackTop->dwMask |= HST_INCINTERNAL;
            }
        }


        /*
         * If this is the end of a block, write the #endif statement
         *  else, if this is the beginning of a block or an if tag, add the
         *   #if statement.
         */
        if (dwMask & HST_END) {
            if (!hsBeginEndBlock(dwMask, dwVersion)) {
                return FALSE;
            }
        } else if (dwMask & (HST_BEGIN | HST_IF)) {
            if (!hsBeginEndBlock(dwMask | HST_BEGIN, dwVersion)) {
                return FALSE;
            }
        }

        //
        // Later: If we're inside a block and find a tag the needs to go to a file
        //  that doesn't have the ifdef, then we might want to add it to that file.
        // Few issues: more than one nesting. if add #if.. make sure to add #endif when
        //  block ends. Also hsBeginEnd doesn't expect to get called more than once
        //  per block. It would append the version twice.
        //
        //    else if ((gphsbStackTop->pszifLabel != NULL)
        //            && ((gphsbStackTop->dwMask & HST_BOTH) != (dwMask & HST_BOTH))) {
        //
        //            if ((gphsbStackTop->dwMask & HST_BOTH) == HST_INTERNAL) {
        //                hsLogMsg(HSLM_DEFAULT, "Public. Line:%d Block line:%d", gdwLineNumber, gphsbStackTop->dwLineNumber);
        //            } else if (!(gphsbStackTop->dwMask & HST_INTERNAL)
        //                    && ((dwMask & HST_BOTH) == HST_INTERNAL)) {
        //                hsLogMsg(HSLM_DEFAULT, "Internal. Line:%d Block line:%d", gdwLineNumber, gphsbStackTop->dwLineNumber);
        //            }
        //    }

        /*
         * Write the line up to the tag marker
         * If the line begins with the tag marker, then there is nothing to write
         * Compatibility: Don't copy any trailing spaces (breaks mc.exe).
         */
        if (pmapLineStart + 2 < pmapMarker) {
            pmapLastChar = hsLastRealChar(pmapLineStart, pmapMarker);
            if (pmapLineStart < pmapLastChar) {
                if (!hsWriteHeaderFiles(pmapLineStart, (DWORD)(pmapLastChar - pmapLineStart), dwMask)) {
                    return FALSE;
                }
            }
        }

        /*
         * If this is an if tag without a begin-end block,
         *  write the #endif statement
         */
        if ((dwMask & HST_IF) && !(dwMask & HST_BLOCK)) {
            if (!hsBeginEndBlock(dwMask | HST_END, dwVersion)) {
                return FALSE;
            }
        }

        /*
         * Skip the tag (go to the beginning of the next line)
         */
        pmap = hsFindEOL(pmapMarker);
        if (pmap == NULL) {
            return TRUE;
        }

        /*
         * If including internal tags in the public header, add the tag
         *  as a comment.
         */
        if (dwMask & HST_INCINTERNAL) {
            /*
             * Start a new line if at the end of a block
             */
            if (dwMask & HST_END) {
                if (!hsWriteNewLine(dwMask)) {
                    return FALSE;
                }
            }

            if (!hsWriteHeaderFiles(" // ", 4, dwMask)
                    || !hsWriteHeaderFiles(pmapMarker, (DWORD)(pmap - pmapMarker), dwMask)) {

                return FALSE;
            }
        }

SkipEmptyLines:
        /*
         * Update line pointers and move past beginning of new line
         */
        pmapLastLineStart = pmapLineStart = hsSkipEmptyLines(pmap);
        pmap = pmapLastLineStart + 2;
    } /* while (pmap < gpmapEnd) */


    /*
     * This is not good if we were inside a block
     */
    if (gphsbStackTop > ghsbStack) {
        hsLogMsg(HSLM_ERROR, "Missing end block");
        hsLogMsg(HSLM_ERROR | HSLM_NOLINE, "Last block Line: %d. if Label:'%s'. Mask: %#lx",
                gphsbStackTop->dwLineNumber, gphsbStackTop->pszifLabel, gphsbStackTop->dwMask);
        return FALSE;
    }

    /*
     * Write last (untagged) lines to public header.
     */
    if (pmapLastLineStart < gpmapEnd) {
        if (!hsWriteHeaderFiles(pmapLastLineStart, (DWORD)(gpmapEnd - pmapLastLineStart), HST_DEFAULT)) {
            return FALSE;
        }
    }

    /*
     * Terminate the last line
     */
    if (!hsWriteNewLine(HST_BOTH)) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ia64\inc\vxchange.h ===
/*****************************************************************************
Copyright (c) 1997-98 Intel Corp.

All Rights Reserved.

The source code contained or described herein and all documents
related to the source code ("Material") are owned by Intel Corporation
or its suppliers and licensors. Title to the Material remains with
Intel Corporation or its suppliers and licensors. The Material
contains trade secrets and proprietary and confidential information of
Intel or its suppliers and licensors. The Material is protected by
worldwide copyright and trade secret laws and treaty provisions. No
part of the Material may be used, copied, reproduced, modified,
published, uploaded, posted, transmitted, distributed, or disclosed in
any way without Intel's prior express written permission.

Unless otherwise expressly permitted by Intel in a separate license
agreement, use of the Material is subject to the copyright notices,
trademarks, warranty, use, and disclosure restrictions reflected on
the outside of the media, in the documents themselves, and in the
"About" or "Read Me" or similar file contained within this source
code, and identified as (name of the file) . Unless otherwise
expressly agreed by Intel in writing, you may not remove or alter such
notices in any way.


File:           vxchange.h

Description:    Defines the Ioctl API between the Win32 application and
                the kernel mode driver

Revision: $Revision:$ // Do not delete or replace

Notes:

Major History:

    When        Who         What
    ----------  ----------  ----------
    03/06/98    Jey         Created

*****************************************************************************/

#ifndef _VXCHANGE_H_
#define _VXCHANGE_H_

#include <windef.h>    // for MAX_PATH

/*-------------------------------------------------------------------------
// VxChange kernel mode device names
//------------------------------------------------------------------------*/

#define VXCHANGE_KERNEL_DEVICE_NAME     L"\\Device\\VxChange"
#define VXCHANGE_WIN32DEVICE_NAME       L"\\DosDevices\\VxChange"

/*-------------------------------------------------------------------------
// Interface structures and Defines
//------------------------------------------------------------------------*/

/*
// After the device open the following structure is queried from the
// driver to understand the version number of the interface supported.
*/

typedef struct tagVxChange_Attrs_t
{
    ULONG structSize;                /* Size of this structure    */
    ULONG Version;                   /* Driver Version            */
    UCHAR Data[1];                   /* more data in the future?  */
} VxChange_Attrs_t, *VxChange_Attrs_Ptr_t;


typedef struct tagVxChange_MapMem_t
{
    PVOID            ProcessVirtualAddress;
    ULONG            MapLength;
} VxChange_MapMem_t, *VxChange_MapMem_Ptr_t;


/*-------------------------------------------------------------------------
// Ioctl defines
//------------------------------------------------------------------------*/

#define FUNCTION_GET_DRIVER_ATTRIBUTES  3000    /* read request           */
#define FUNCTION_CREATE_FILE            3001    /* read/write request     */
#define FUNCTION_CLOSE_FILE             3002    /* write request          */
#define FUNCTION_READ_FILE              3003    /* buff io  read request  */
#define FUNCTION_WRITE_FILE             3004    /* buff io  write request */
#define FUNCTION_DISABLE_OS_EVENT_NOTIFICATION 3005
#define FUNCTION_ENABLE_OS_EVENT_NOTIFICATION  3006
#define FUNCTION_LOCK_MEMORY            3007
#define FUNCTION_UNLOCK_MEMORY          3008
#define FUNCTION_OPEN_FILE				3009    /* open request - no create */


#define IOCTL_VXCHANGE_GET_DRIVER_ATTRIBUTES  \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_GET_DRIVER_ATTRIBUTES,   \
            METHOD_BUFFERED,                  \
            FILE_ANY_ACCESS )

/* This IOCTL is used to open an existing file on the host.  No create */
#define IOCTL_VXCHANGE_OPEN_FILE            \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_OPEN_FILE,             \
            METHOD_BUFFERED,                  \
            FILE_ANY_ACCESS )

/* This IOCTL is used to open a file on the host.  If the file does not exist,
 *	it will be created. */
#define IOCTL_VXCHANGE_CREATE_FILE            \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_CREATE_FILE,             \
            METHOD_BUFFERED,                  \
            FILE_ANY_ACCESS )

#define IOCTL_VXCHANGE_CLOSE_FILE             \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_CLOSE_FILE,              \
            METHOD_BUFFERED,                  \
            FILE_ANY_ACCESS )

#define IOCTL_VXCHANGE_READ_FILE              \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_READ_FILE,               \
            METHOD_BUFFERED,                  \
            FILE_READ_ACCESS )

#define IOCTL_VXCHANGE_WRITE_FILE             \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_WRITE_FILE,              \
            METHOD_BUFFERED,                  \
            FILE_WRITE_ACCESS )

#define IOCTL_VXCHANGE_DISABLE_OS_EVENT_NOTIFICATION       \
  CTL_CODE( FILE_DEVICE_UNKNOWN,                           \
            FUNCTION_DISABLE_OS_EVENT_NOTIFICATION,        \
            METHOD_BUFFERED,                               \
            FILE_WRITE_ACCESS )

#define IOCTL_VXCHANGE_ENABLE_OS_EVENT_NOTIFICATION        \
  CTL_CODE( FILE_DEVICE_UNKNOWN,                           \
            FUNCTION_ENABLE_OS_EVENT_NOTIFICATION,         \
            METHOD_BUFFERED,                               \
            FILE_WRITE_ACCESS )

#define IOCTL_VXCHANGE_LOCK_MEMORY            \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_LOCK_MEMORY,             \
            METHOD_BUFFERED,                  \
            FILE_WRITE_ACCESS )

#define IOCTL_VXCHANGE_UNLOCK_MEMORY          \
  CTL_CODE( FILE_DEVICE_UNKNOWN,              \
            FUNCTION_UNLOCK_MEMORY,           \
            METHOD_BUFFERED,                  \
            FILE_WRITE_ACCESS )


#endif // _VXCHANGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ia64\sscget\sscget.c ===
/*****************************************************************************
Copyright (c) 1997-98 Intel Corp.

All Rights Reserved.

The source code contained or described herein and all documents
related to the source code ("Material") are owned by Intel Corporation
or its suppliers and licensors. Title to the Material remains with
Intel Corporation or its suppliers and licensors. The Material
contains trade secrets and proprietary and confidential information of
Intel or its suppliers and licensors. The Material is protected by
worldwide copyright and trade secret laws and treaty provisions. No
part of the Material may be used, copied, reproduced, modified,
published, uploaded, posted, transmitted, distributed, or disclosed in
any way without Intel's prior express written permission.

Unless otherwise expressly permitted by Intel in a separate license
agreement, use of the Material is subject to the copyright notices,
trademarks, warranty, use, and disclosure restrictions reflected on
the outside of the media, in the documents themselves, and in the
"About" or "Read Me" or similar file contained within this source
code, and identified as (name of the file) . Unless otherwise
expressly agreed by Intel in writing, you may not remove or alter such
notices in any way.


File:           sscget.c

Description:    sscget console mode file copy utility

Revision: $Revision:$ // Do not delete or replace

Notes:

Major History:

    When        Who         What
    ----------  ----------  ----------
    03/06/98    Jey         Created

*****************************************************************************/


#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>

#include <vxchange.h>

void print_usage(char *module)
{
	printf("\n%s usage: filename1 filename2 \n\n",module);
	printf("Note: where filename1 is the source HOST file name\n");
	printf("      where filename2 is the destination VPC file name\n\n");
}


int
__cdecl
main(
  IN int  argc,
  IN char *argv[]
)
{
    HANDLE  hDevice;
    VxChange_Attrs_t DriverAttrs;
	DWORD BytesDone;
	unsigned char *VpcFile;
	unsigned char *HostFile;
	HANDLE hVpc;
	unsigned char *Data;
	BOOLEAN rc;
		
    if (argc < 3)
	{
		print_usage(argv[0]);
		return 1;
	}

	// open the kernel mode driver
    if ((hDevice = CreateFile("\\\\.\\VxChange",
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              )) == ((HANDLE)-1))
    {
        printf("%s error: Can't get a handle to VxChange device\n", argv[0]);
        return 2;
    }

	// get the Driver Attributes
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_GET_DRIVER_ATTRIBUTES,   // DWORD dwIoControlCode, // control code of operation to perform
             NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             0,                                      // DWORD nInBufferSize,   // size of input buffer
             &DriverAttrs,                           // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             sizeof(VxChange_Attrs_t),               // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Query Driver Attributes failed\n", argv[0]);
		CloseHandle(hDevice);
		return 3;
	}

    HostFile = argv[1];
	VpcFile  = argv[2];
	
	// open/create the Host file
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_OPEN_FILE,               // DWORD dwIoControlCode, // control code of operation to perform
             HostFile,                               // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             MAX_PATH,                               // DWORD nInBufferSize,   // size of input buffer
             NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Can't open the Host file %s\n", argv[0], HostFile);

		CloseHandle(hDevice);
		return 5;
	}

	// open/create the Vpc file
    if ((hVpc = CreateFile(VpcFile,
		                   GENERIC_WRITE,
                           FILE_SHARE_WRITE,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           )) == ((HANDLE)-1))
    {
        printf("%s error: Can't open the Vpc file %s\n", argv[0], VpcFile);
		CloseHandle(hDevice);
		CloseHandle(hVpc);
        return 4;
    }
  
#define  DATA_BUFFER_SIZE   4096

	// allocate 4096 bytes of memory and commit the pages
	Data = (unsigned char *)VirtualAlloc(NULL, DATA_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (Data == NULL)
	{
		printf("%s error: Can't allocate memory for data buffers\n", argv[0]);
		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 6;
	}

	rc = TRUE;
	
	// read from the source file and write to destination
    while (rc)
	{
		// read data from the Host file 
	    if(!DeviceIoControl(
			    hDevice,                                // HANDLE hDevice,	     // handle to device of interest
				IOCTL_VXCHANGE_READ_FILE,               // DWORD dwIoControlCode, // control code of operation to perform
				NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
				0,                                      // DWORD nInBufferSize,   // size of input buffer
				Data,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
				DATA_BUFFER_SIZE,                       // DWORD nOutBufferSize,	 // size of output buffer             
				&BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
				NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
				))
		{
			printf("%s error: Can't read from the Host file %s\n", argv[0], HostFile);

			CloseHandle(hDevice);
			CloseHandle(hVpc);
			return 5;
		}

		if (BytesDone < DATA_BUFFER_SIZE)
			rc = FALSE;

		// write data to the Vpc file
		if (!WriteFile(
					hVpc,
					Data,
					BytesDone,
					&BytesDone,
					NULL))
		{
			printf("%s error: Can't write to the Vpc file %s\n", argv[0], VpcFile);
				
			CloseHandle(hDevice);
			CloseHandle(hVpc);
			return 6;
		}
	} 

	// close the Vpc file
	CloseHandle(hVpc);

	// close the Host file
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_CLOSE_FILE,              // DWORD dwIoControlCode, // control code of operation to perform
             NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             0,                                      // DWORD nInBufferSize,   // size of input buffer
             NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Can't close the Host file %s\n", argv[0], HostFile);

		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 9;
	}
	
    CloseHandle(hDevice);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\command.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    command.h
//
// SYNOPSIS
//
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version. Thierry Perraut
//
///////////////////////////////////////////////////////////////////////////////
#include "precomp.hpp"
#include "database.h"

// from command.cpp
HRESULT ProcessCommand(
                       int          argc, 
                       wchar_t      * argv[],  
                       HINF         *ppHINF,
                       CDatabase&   pDatabase
                       );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ia64\sscput\sscput.c ===
/*****************************************************************************
Copyright (c) 1997-98 Intel Corp.

All Rights Reserved.

The source code contained or described herein and all documents
related to the source code ("Material") are owned by Intel Corporation
or its suppliers and licensors. Title to the Material remains with
Intel Corporation or its suppliers and licensors. The Material
contains trade secrets and proprietary and confidential information of
Intel or its suppliers and licensors. The Material is protected by
worldwide copyright and trade secret laws and treaty provisions. No
part of the Material may be used, copied, reproduced, modified,
published, uploaded, posted, transmitted, distributed, or disclosed in
any way without Intel's prior express written permission.

Unless otherwise expressly permitted by Intel in a separate license
agreement, use of the Material is subject to the copyright notices,
trademarks, warranty, use, and disclosure restrictions reflected on
the outside of the media, in the documents themselves, and in the
"About" or "Read Me" or similar file contained within this source
code, and identified as (name of the file) . Unless otherwise
expressly agreed by Intel in writing, you may not remove or alter such
notices in any way.


File:           vxchange.c

Description:    VxChane Console Mode File Copy utility

Revision: $Revision:$ // Do not delete or replace

Notes:

Major History:

    When        Who         What
    ----------  ----------  ----------
    03/06/98    Jey         Created

*****************************************************************************/


#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>

#include <vxchange.h>

void print_usage(char *module)
{
	printf("\n%s usage: filename1 filename2 \n\n",module);
	printf("Note: where filename1 is the source VPC file name\n");
	printf("      where filename2 is the destination HOST file name\n\n");
}


int
__cdecl
main(
  IN int  argc,
  IN char *argv[]
)
{
    HANDLE  hDevice;
    VxChange_Attrs_t DriverAttrs;
	DWORD BytesDone;
	unsigned char *VpcFile;
	unsigned char *HostFile;
	HANDLE hVpc;
	unsigned char *Data;
	BOOLEAN rc;
		
    if (argc < 3)
	{
		print_usage(argv[0]);
		return 1;
	}

	// open the kernel mode driver
    if ((hDevice = CreateFile("\\\\.\\VxChange",
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              )) == ((HANDLE)-1))
    {
        printf("%s error: Can't get a handle to VxChange device\n", argv[0]);
        return 2;
    }

	// get the Driver Attributes
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_GET_DRIVER_ATTRIBUTES,   // DWORD dwIoControlCode, // control code of operation to perform
             NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             0,                                      // DWORD nInBufferSize,   // size of input buffer
             &DriverAttrs,                           // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             sizeof(VxChange_Attrs_t),               // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Query Driver Attributes failed\n", argv[0]);
		CloseHandle(hDevice);
		return 3;
	}

	VpcFile = argv[1];
	HostFile = argv[2];

	// open/create the Vpc file
    if ((hVpc = CreateFile(VpcFile,
		                   GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           )) == ((HANDLE)-1))
    {
        printf("%s error: Can't open the Vpc file %s\n", argv[0], VpcFile);
        return 4;
    }
  
	// open/create the Host file
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_CREATE_FILE,             // DWORD dwIoControlCode, // control code of operation to perform
             HostFile,                               // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             MAX_PATH,                               // DWORD nInBufferSize,   // size of input buffer
             NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Can't open the Host file %s\n", argv[0], HostFile);

		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 5;
	}

#define  DATA_BUFFER_SIZE   4096

	// allocate 4096 bytes of memory and commit the pages
	Data = (unsigned char *)VirtualAlloc(NULL, DATA_BUFFER_SIZE, MEM_COMMIT, PAGE_READWRITE);

	if (Data == NULL)
	{
		printf("%s error: Can't allocate memory for data buffers\n", argv[0]);
		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 6;
	}

	rc = TRUE;
	
	// read from the source file and write to destination
    while (rc)
	{
		// read data from the Vpc file
		if (!ReadFile(
					hVpc,
					Data,
					DATA_BUFFER_SIZE,
					&BytesDone,
					NULL))
		{
			printf("%s error: Can't read from the Vpc file %s\n", argv[0], VpcFile);

			CloseHandle(hDevice);
			CloseHandle(hVpc);
			return 7;
		}

		if (BytesDone < DATA_BUFFER_SIZE)
			rc = FALSE;

		//  write data to the Host file
	    if(!DeviceIoControl(
			    hDevice,                                // HANDLE hDevice,	     // handle to device of interest
				IOCTL_VXCHANGE_WRITE_FILE,              // DWORD dwIoControlCode, // control code of operation to perform
				Data,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
				BytesDone,                              // DWORD nInBufferSize,   // size of input buffer
				NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
				0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
				&BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
				NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
				))
		{
			printf("%s error: Can't write to the Host file %s\n", argv[0], HostFile);

			CloseHandle(hDevice);
			CloseHandle(hVpc);
			return 8;
		}


	}

	// close the Vpc file
	CloseHandle(hVpc);

	// close the Host file
    if(!DeviceIoControl(
             hDevice,                                // HANDLE hDevice,	     // handle to device of interest
             IOCTL_VXCHANGE_CLOSE_FILE,              // DWORD dwIoControlCode, // control code of operation to perform
             NULL,                                   // LPVOID lpInBuffer,     // pointer to buffer to supply input data
             0,                                      // DWORD nInBufferSize,   // size of input buffer
             NULL,                                   // LPVOID lpOutBuffer,	 // pointer to buffer to receive output data
             0,                                      // DWORD nOutBufferSize,	 // size of output buffer             
			 &BytesDone,                             // LPDWORD lpBytesReturned,	// pointer to variable to receive output byte count
             NULL                                    // LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation
             ))
	{
		printf("%s error: Can't open the Host file %s\n", argv[0], HostFile);

		CloseHandle(hDevice);
		CloseHandle(hVpc);
		return 9;
	}
	
    CloseHandle(hDevice);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\bitvec.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998-1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    BitVec.h
//
// SYNOPSIS
//
//    This file implements the class BitVector
//
// MODIFICATION HISTORY
//
//    02/09/1998    Original version.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _BITVEC_H_
#define _BITVEC_H_

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    BitVector
//
// DESCRIPTION
//
//    Very simple bit vector optimized for use by the CSimpleTable class.
//
///////////////////////////////////////////////////////////////////////////////
class BitVector
{
public:
   // Type used to store bits.
   typedef unsigned long Bucket;

   BitVector()
      : numBuckets(0), numSet(0), bits(NULL) { }

   ~BitVector()
   {
      delete[] bits;
   }

   // Returns true if any bits are set.
   bool any() const
   {
      return numSet != 0;
   }

   // Returns the number of bits set.
   size_t count() const
   {
      return numSet;
   }

   // Returns true if no bits are set.
   bool none() const
   {
      return numSet == 0;
   }

   // Clears all bits.
   void reset()
   {
      if (any())
      {
         memset(bits, 0, numBuckets * sizeof(Bucket));

         numSet = 0;
      }
   }

   // Resizes the bitvector to have room for at least 'n' bits. Also clears
   // any existing bits.
   bool resize(size_t n)
   {
      size_t newBuckets = (n + sizeof(Bucket) - 1)/sizeof(Bucket);

      if (newBuckets >= numBuckets)
      {
         numBuckets = newBuckets;

         delete[] bits;

         bits = new (std::nothrow) Bucket[numBuckets];
         if ( !bits )
         {
             return false;
         }
      }

      memset(bits, 0, numBuckets * sizeof(Bucket));

      numSet = 0;
      return true;
   }

   // Sets the given bit.
   void set(size_t i)
   {
      if (!test(i))
      {
         ++numSet;

         getBucket(i) |= getBit(i);
      }
   }

   // Returns true if the given bit is set.
   bool test(size_t i) const
   {
      return (getBucket(i) & getBit(i)) != 0;
   }

protected:
   // Return the bit for a given index.
   static Bucket getBit(size_t i)
   { return (Bucket)1 << (i % sizeof(Bucket)); }

   // Return the bucket for a given index.
   Bucket& getBucket(size_t i) const
   { return bits[i / sizeof(Bucket)]; }

   size_t numBuckets;  // Number of bit buckets.
   size_t numSet;      // Number of bits currently set.
   Bucket* bits;       // Array of bit buckets.

   // Not implemented.
   BitVector(const BitVector&);
   BitVector& operator=(const BitVector&);
};

#endif  // _BITVEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\command.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    command.cpp
//
// SYNOPSIS
//
//    Process the command-line parameters of iasinfdb.exe
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version. Thierry Perraut
//
//////////////////////////////////////////////////////////////////////////////
#include "precomp.hpp"
#include "command.h"

using namespace std;

//////////////////////////////////////////////////////////////////////////////
//
// ProcessCommand
//
//
//////////////////////////////////////////////////////////////////////////////
HRESULT ProcessCommand(
                       int argc,
                       wchar_t * argv[],  
                       HINF *ppHINF, 
                       CDatabase& Database
                       )
{
   _ASSERTE(ppHINF != NULL);

    HRESULT                 hres;

    if (argc != NUMBER_ARGUMENTS)
    {
        /////////////////////////////////////
        // not the right number of arguments
        /////////////////////////////////////

       cerr << "inf2db Import an INF file into a Jet4 Database\n\ninf2db ";
       cerr << "[drive:][path]template.mdb [drive:][path]filename.inf";
       cerr << "[drive:][path]destination_database.mdb\n";
       hres = E_INVALIDARG;
    }
    else
    {
       /////////////////////////////////////
       // argv[1] = template database
       /////////////////////////////////////
       BOOL bCopyOk = CopyFileW(
                                 argv[1],     
                                 TEMPORARY_FILENAME, 
                     // here false means success even if file already exists
                                 FALSE        
                                );            
 
        if (!bCopyOk)
        {
           TracePrintf("Error: copy template %S -> new file %S failed ",
                                                        argv[1], 
                                                        TEMPORARY_FILENAME
                                                        );
           
           hres = E_FAIL;
        }
        else
        {
           ///////////////////////////////////////////////////////
           // suppress the read-only attribute from the new file
           ///////////////////////////////////////////////////////
           BOOL bChangedAttributeOK = SetFileAttributesW(
                                                        TEMPORARY_FILENAME, 
                                                        FILE_ATTRIBUTE_NORMAL
                                                        );
           if(!bChangedAttributeOK)
           {
              TracePrintf("Error: change attribute (RW) on %S failed",
                                                TEMPORARY_FILENAME
                                                ); 
              hres = E_FAIL;
           }
           else
           {
             ///////////////////////////////////////////////////////
             // three arg (argc = 4) Open the INF file for reading
             // Open for read (will fail if file does not exist) 
             ///////////////////////////////////////////////////////
       
             UINT                    lErrorCode;
             if( (*ppHINF = (HINF) SetupOpenInfFileW(
                                    // name of the INF to open
                                    argv[2], 
                                    // optional, the class of the INF file
                                    NULL, 
                                    // specifies the style of the INF file
                                    INF_STYLE_WIN4,  
                                    &lErrorCode  
                                    ))
                == INVALID_HANDLE_VALUE
               )
              {
                  //////////////////////////////////
                  // Error situation
                  //////////////////////////////////

                  LPVOID                 lpMsgBuf;
                  FormatMessageW( 
                                  FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                  FORMAT_MESSAGE_FROM_SYSTEM | 
                                  FORMAT_MESSAGE_IGNORE_INSERTS,
                                  NULL,
                                  GetLastError(),
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (LPWSTR) &lpMsgBuf,
                                  0,
                                  NULL 
                                );

                  TracePrintf("Error: %S",(LPCWSTR)lpMsgBuf);
                  cerr << "Error: " << (LPCWSTR)lpMsgBuf << "\n";
                  /////////////////////
                  // Free the buffer.
                  /////////////////////
                  LocalFree(lpMsgBuf);
                  cerr << "ERROR: Can't open the INF file " << argv[1] <<"\n";
                  hres = E_INVALIDARG;
              }
              else 
              {
              #ifdef DEBUG
                 TraceString("Info: inf file open\n");
              #endif
                 ////////////////////////////////////////////////                  
                 // argv[3] = destination path to the database 
                 // call the initialize member function
                 ////////////////////////////////////////////////                  
                 Database.InitializeDB(argv[3]);
                 hres = S_OK;
              }
           }
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\database.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    database.h
//
// SYNOPSIS
//
//   Interface for the CDatabase class
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version. Thierry Perraut
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6_INCLUDED)
#define AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.hpp"
using namespace std;

class CDatabase  
{
public:
	HRESULT Uninitialize(bool  bFatalError);
    HRESULT InitializeDB(WCHAR *pDatabasePath);
    HRESULT InitializeRowset(WCHAR *pTableName, IRowset **ppRowset);
    HRESULT Compact();
    
private:
    ITransactionLocal*          m_pITransactionLocal;
    IOpenRowset*                m_pIOpenRowset;
    IDBCreateSession*           m_pIDBCreateSession;
    IDBInitialize*              m_pIDBInitialize;

    DBID                        mTableID;
    DBPROPSET                   mlrgPropSets[1]; // number will not change
    DBPROP                      mlrgProperties[2]; //number will not change
    wstring                     mpDBPath;
};

#endif
 // !defined(AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\helper.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    helper.cpp
//
// SYNOPSIS
//
//    Helper functions: log file, string conversion
//
// MODIFICATION HISTORY
//
//    01/25/1999    Original version. Thierry Perraut
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.hpp"
#include "SimpleTableEx.h"


//////////////////////////////////////////////////////////////////////////////
//
// TracePrintf: trace function
//
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TracePrintf(
     IN PCSTR szFormat,
     ...
    )
{
    va_list marker;
    va_start(marker, szFormat);
    printf(
           szFormat,
           marker
          );
    va_end(marker);
}


//////////////////////////////////////////////////////////////////////////////
//
// TraceString: trace function
//
//////////////////////////////////////////////////////////////////////////////
void TraceString(char* cString)
{
    _ASSERTE(cString);
    printf("%s\n", cString);
}


// ///////////////////////////////////////////////////////////////////////////
//
// ConvertTypeStringToLong
//
//
// ///////////////////////////////////////////////////////////////////////////
HRESULT ConvertTypeStringToLong(const WCHAR *lColumnType, LONG *pType)
{
   _ASSERTE(pType != NULL);
   HRESULT                  hres = S_OK;

   if(wcscmp(L"DBTYPE_I4",lColumnType) == 0)
   {
      *pType = DBTYPE_I4;
   }
   else if(wcscmp(L"DBTYPE_WSTR",lColumnType) == 0)
   {
      *pType = DBTYPE_WSTR;
   }
   else if(wcscmp(L"DBTYPE_BOOL",lColumnType) == 0)
   {
      *pType = DBTYPE_BOOL;
   }
   else
   {
      *pType = -1;
      hres = E_FAIL;
   }

   return    hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\database.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
// Database.cpp
//
// SYNOPSIS
//
//    Implementation of the CDatabase class. Mainly initialize, compact...
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version. Thierry Perraut       
//
//////////////////////////////////////////////////////////////////////////////
#include "precomp.hpp"

#include "database.h"
#include "msjetoledb.h"
#include "jetoledb.h"


//////////////////////////////////////////////////////////////////////////////
//
// Uninitialize: called at the end by main(), that calls compact()
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CDatabase::Uninitialize (bool bFatalError)
{
    HRESULT                 hres;

    #ifdef THPDEBUG
        bFatalError = false;
    #endif
    
    ////////////////////////////////////////
    // if a fatal error occured before
    ////////////////////////////////////////
    if (bFatalError)
    {
        hres = (m_pITransactionLocal->Abort (NULL, TRUE, FALSE));
        TracePrintf ("Fatal Error: import to the database aborted.");
    }
    else
    {
        hres = (m_pITransactionLocal->Commit (TRUE, XACTTC_SYNC, 0));
#ifdef DEBUG
        TracePrintf ("Successful import.\n");
#endif        
    }
    
    ///////////
    // Clean
    ///////////
    m_pIOpenRowset->Release();
    m_pITransactionLocal->Release();  
    m_pIDBCreateSession->Release();

    ////////////////////////////////////////
    // compact the DB
    ////////////////////////////////////////
    CHECK_CALL_HRES (Compact()); 

    m_pIDBInitialize->Release();

    return hres;
}


//////////////////////////////////////////////////////////////////////////////
//
// Compact the database
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CDatabase::Compact ()
{
    HRESULT                     hres;

    CHECK_CALL_HRES (m_pIDBInitialize->Uninitialize ());
 
    ///////////////////////////////////////////////
    // Set the properties for the data source.
    //////////////////////////////////////////////
    CComPtr <IDBProperties>  l_pIDBProperties;

    CHECK_CALL_HRES (m_pIDBInitialize->QueryInterface (
                                                 __uuidof (IDBProperties),
                                                 (void **) &l_pIDBProperties)
                                                 );

    //////////////////////////////////
    // Prepare the create session
    //////////////////////////////////
    DBPROP                      lprop[2];

    VariantInit(&lprop[0].vValue);
    lprop[0].dwOptions              = DBPROPOPTIONS_REQUIRED;
    lprop[0].dwPropertyID           = DBPROP_INIT_DATASOURCE;
    V_VT (&(lprop[0].vValue))       = VT_BSTR;
    
    //////////////////////////////////////////////////////
    // put the path to the DB in the property.
    // remark: temporaryname was used befire
    // but the compacted database will have the name
    // that was given as a parameter to that program
    //////////////////////////////////////////////////////
    V_BSTR (&(lprop[0].vValue))     = SysAllocString (TEMPORARY_FILENAME);

    VariantInit(&lprop[1].vValue);
    lprop[1].dwOptions              = DBPROPOPTIONS_REQUIRED;
    lprop[1].dwPropertyID           = DBPROP_INIT_MODE;
    V_VT (&(lprop[1].vValue))       = VT_I4;
    V_I4 (&(lprop[1].vValue))       = DB_MODE_READ;


    DBPROPSET                      lPropSet;
    lPropSet.rgProperties           = lprop;
    lPropSet.cProperties            = 2;
    lPropSet.guidPropertySet        = DBPROPSET_DBINIT;

    ///////////////////////
    // Set the properties
    ///////////////////////
    CHECK_CALL_HRES (l_pIDBProperties->SetProperties (
                                                 1,
                                                 &lPropSet
                                                 ));


    CHECK_CALL_HRES (m_pIDBInitialize->Initialize ());

    IJetCompact*                l_pIJetCompact;
    CHECK_CALL_HRES ((m_pIDBInitialize->QueryInterface (
                                                 __uuidof (IJetCompact),
                                                 (void **) &l_pIJetCompact))
                                                   );

    /////////////////////////////////////////////////////////////
    // Prepare the properties for the data dest. (destination)
    /////////////////////////////////////////////////////////////
    DBPROP                          lpropDest[1];

    VariantInit (&lprop[0].vValue);
    lpropDest[0].dwOptions          = DBPROPOPTIONS_REQUIRED;
    lpropDest[0].dwPropertyID       = DBPROP_INIT_DATASOURCE;
    V_VT (&(lpropDest[0].vValue))   = VT_BSTR;

    ///////////////////////////////////////////////////
    // Delete the database file if it already existed.
    // that should be safe because the temporary DB
    // was succesfully created
    ///////////////////////////////////////////////////
    DeleteFileW(mpDBPath.c_str());

    //////////////////////////////////////////////
    // put the path to the DB in the property.
    //////////////////////////////////////////////
    V_BSTR (&(lpropDest[0].vValue)) = SysAllocString (mpDBPath.c_str());

    DBPROPSET                       lPropSetDest[1];
    lPropSetDest[0].rgProperties        = lpropDest;
    lPropSetDest[0].cProperties         = 1;
    lPropSetDest[0].guidPropertySet     = DBPROPSET_DBINIT;

    
    CHECK_CALL_HRES (l_pIJetCompact->Compact(1, lPropSetDest));
    
    /////////////
    // Clean
    /////////////
    CHECK_CALL_HRES (m_pIDBInitialize->Uninitialize());
    
    ////////////////////////////////////////////
    //result not checked: that's not important
    ////////////////////////////////////////////
    DeleteFileW(TEMPORARY_FILENAME);	
    SysFreeString( V_BSTR (&(lpropDest[0].vValue)) );
    SysFreeString( V_BSTR (&(lprop[0].vValue)) );

    // The CHECK_CALL_HRES set the value of hres
    return hres; 
}


// ///////////////////////////////////////////////////////////////////////////
//
// InitializeDB
//
// Comes from the file \ias\devtest\services\dictionary\dnary\dnarydump.cpp
//
// ///////////////////////////////////////////////////////////////////////////
HRESULT CDatabase::InitializeDB(WCHAR * pDatabasePath)
{
    CLSID                       clsid;
    HRESULT                     hres;

    ////////////////////////////////////////////////////
    // Retrieve the classID for the jet 4.0 provider
    ////////////////////////////////////////////////////
    CHECK_CALL_HRES(
                    CLSIDFromProgID (
                                     OLESTR ("Microsoft.Jet.OLEDB.4.0"),
                                     &clsid	//Pointer to the CLSID
                                     )
                   );


    ////////////////////////////////////
    // init: init the provider directly
    ////////////////////////////////////
    CHECK_CALL_HRES(
                    CoCreateInstance (
                                      clsid,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      __uuidof (IDBInitialize),
                                      (void **) &m_pIDBInitialize
                                     )
                   );

    mpDBPath = pDatabasePath;

    //////////////////////////////////////////////
    // Set the properties for the data source.
    //////////////////////////////////////////////
    CComPtr <IDBProperties>         pIDBProperties;

    CHECK_CALL_HRES(
                    m_pIDBInitialize->QueryInterface(
                                                     __uuidof (IDBProperties),
                                                     (void **) &pIDBProperties
                                                    )
                   );

    ///////////////////////////////
    // Prepare the create session
    ///////////////////////////////
    DBPROP                      lprop[2];

    VariantInit (&lprop[0].vValue);
    lprop[0].dwOptions              = DBPROPOPTIONS_REQUIRED;
    lprop[0].dwPropertyID           = DBPROP_INIT_DATASOURCE;
    V_VT (&(lprop[0].vValue))       = VT_BSTR;

    //////////////////////////////////////////////
    // put the path to the DB in the property.
    // this is the temporary filename
    //////////////////////////////////////////////
    V_BSTR (&(lprop[0].vValue))     = SysAllocString (TEMPORARY_FILENAME);
    
    VariantInit(&lprop[1].vValue);
    lprop[1].dwOptions              = DBPROPOPTIONS_REQUIRED;
    lprop[1].dwPropertyID           = DBPROP_INIT_MODE;
    V_VT (&(lprop[1].vValue))       = VT_I4;
    V_I4 (&(lprop[1].vValue))       = DB_MODE_READWRITE;


    DBPROPSET                   lPropSet;
    lPropSet.rgProperties           = lprop;
    lPropSet.cProperties            = 2;
    lPropSet.guidPropertySet        = DBPROPSET_DBINIT;


    // Set the properties
    CHECK_CALL_HRES(pIDBProperties->SetProperties (1, &lPropSet));


    ////////////////////
    // Lock properties 
    ////////////////////
    DBPROP dbpropb[1];
    dbpropb[0].dwPropertyID    = DBPROP_JETOLEDB_DATABASELOCKMODE;
    dbpropb[0].dwOptions       = DBPROPOPTIONS_REQUIRED;
    dbpropb[0].colid           = DB_NULLID;
    dbpropb[0].vValue.vt       = VT_I4;
    dbpropb[0].vValue.lVal     = DBPROPVAL_DL_OLDMODE;


    DBPROPSET dbpropSetb;
    dbpropSetb.guidPropertySet = DBPROPSET_JETOLEDB_DBINIT;
    dbpropSetb.cProperties     = 1;
    dbpropSetb.rgProperties    = dbpropb;

    // Set the properties
    CHECK_CALL_HRES (pIDBProperties->SetProperties(1, &dbpropSetb));

    CHECK_CALL_HRES (m_pIDBInitialize->Initialize ());


    CHECK_CALL_HRES(
                    m_pIDBInitialize->QueryInterface(
                                            __uuidof (IDBCreateSession),
                                            (void **) &m_pIDBCreateSession
                                            )
                   );


    CHECK_CALL_HRES(
                    m_pIDBCreateSession->CreateSession (
                                            NULL,	// pUnkOuter
                                            __uuidof (IOpenRowset),
                                            (IUnknown **) & m_pIOpenRowset
                                            )
                   );


    CHECK_CALL_HRES(
                    m_pIOpenRowset->QueryInterface (
                                            __uuidof (ITransactionLocal),
                                            (PVOID *) & m_pITransactionLocal
                                            )
                   );

    //////////////////////////////////////////////
    // start a transaction
    // everything is "under" that transaction
    //////////////////////////////////////////////

    CHECK_CALL_HRES(
                    m_pITransactionLocal->StartTransaction (
                                            ISOLATIONLEVEL_READUNCOMMITTED,
                                            0,
                                            NULL,
                                            NULL
                                            )
                   );

    ////////////////////////////
    // prepare the properties
    ////////////////////////////

    mlrgProperties[0].dwPropertyID          = DBPROP_IRowsetChange;
    mlrgProperties[0].dwOptions             = DBPROPOPTIONS_REQUIRED;
    mlrgProperties[0].colid                 = DB_NULLID;
    VariantInit(&mlrgProperties[0].vValue);
    V_VT (&(mlrgProperties[0].vValue))      = VT_BOOL;
    V_BOOL (&(mlrgProperties[0].vValue))    = VARIANT_TRUE;


    mlrgProperties[1].dwPropertyID      = DBPROP_UPDATABILITY;
    mlrgProperties[1].dwOptions         = DBPROPOPTIONS_REQUIRED;
    mlrgProperties[1].colid             = DB_NULLID;
    VariantInit (&mlrgProperties[1].vValue);
    V_VT (&(mlrgProperties[1].vValue))  = VT_I4;
    V_I4 (&(mlrgProperties[1].vValue))  = DBPROPVAL_UP_CHANGE |
                                          DBPROPVAL_UP_DELETE |
                                          DBPROPVAL_UP_INSERT;

    mlrgPropSets->rgProperties          = mlrgProperties;
    mlrgPropSets->cProperties           = 2;
    mlrgPropSets->guidPropertySet       = DBPROPSET_ROWSET;


    SysFreeString(V_BSTR (&(lprop[0].vValue)));

    return hres;
}


// ///////////////////////////////////////////////////////////////////////////
//
// InitializeRowset
//
// ///////////////////////////////////////////////////////////////////////////
HRESULT CDatabase::InitializeRowset(WCHAR * pTableName, IRowset ** ppRowset)
{
    //Create the tableID
    mTableID.eKind          = DBKIND_NAME;
    mTableID.uName.pwszName = pTableName;

    //Open the (defined by parameters) rowset
    return m_pIOpenRowset->OpenRowset(
                                        NULL,
                                        &mTableID,
                                        NULL,
                                        __uuidof (IRowset),
                                        1,
                                        mlrgPropSets,
                                        (IUnknown **) ppRowset
                                      );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\inf2db.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    inf2db.h
//
// SYNOPSIS
//    import the information stored in an INF file into a MSJet4 relational
//    database
//
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version.
//
///////////////////////////////////////////////////////////////////////////////
// inf2db.cpp : Defines the entry point for the console application.
//
#include "precomp.hpp"
#include "inf2db.h"

///////////////////////////////////////////////////////////////////////////////
//
//  Main
//
///////////////////////////////////////////////////////////////////////////////
extern "C"
void __cdecl wmain(int argc, wchar_t* argv[])
{
    HINF           lHINF;

    HRESULT     hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hres))
    {
        cerr << "Unable to initialize COM!\n";
    }
    else
    {
        CDatabase               Database;

        ////////////////////////////////////////////////////////////////
        // Call the process command (process the command-line arguments)
        ////////////////////////////////////////////////////////////////
        hres = ProcessCommand(argc, argv, &lHINF, Database);
        if (FAILED(hres))
        {
            g_FatalError = true;
        }
        else
        {
             ////////////////////////////////////////////////
             // Call the process function to parse the file
             ////////////////////////////////////////////////
            hres = Process(lHINF, Database);
            if (FAILED(hres))
            {
                g_FatalError = true;
            }

            //////////////////////////
            // then call uninitialize
            //////////////////////////
            hres = Uninitialize(&lHINF, Database);

            if (g_FatalError)
            {
                cerr << "Fatal Error: check the Trace file.";
                cerr << "Import operation aborted.\n";
            }
            else
            {
                cerr << "Import successful.\n";
            }
        }
    }
    CoUninitialize();
}


//////////////////////////////////////////////////////////////////////////////
//
// Unitialize
//
//////////////////////////////////////////////////////////////////////////////
HRESULT Uninitialize(HINF *phINF, CDatabase& Database)
{
   _ASSERTE(phINF != NULL);

   SetupCloseInfFile(*phINF);

   return Database.Uninitialize(g_FatalError);
}


//////////////////////////////////////////////////////////////////////////////
//
// Process
//
//////////////////////////////////////////////////////////////////////////////
HRESULT Process(const HINF& hINF, CDatabase& Database)
{

    // get the number of tables
    LONG lTotalTableNumber = SetupGetLineCountW(
                                    // handle to the INF file
                                    hINF,
                                    // the section in which to count lines
                                    TABLE_SECTION
                                    );


    bool            bError = false; //needs to be outside the if, loop...
    HRESULT         hres;

    if (lTotalTableNumber > 0)
    {
    #ifdef DEBUG
        TracePrintf("Info: number of tables = %d\n",lTotalTableNumber);
    #endif

        INFCONTEXT        lTableContext;
        // if <>0 do a loop on the tables
        BOOL bOK = SetupFindFirstLineW(
                                       hINF,
                                       TABLE_SECTION,
                                       NULL,
                                       &lTableContext
                                       );

        for (
             LONG lTableCounter = 0;
             lTableCounter < lTotalTableNumber;
             lTableCounter++
             )
        {
            // read the Table name in the Tables section
            WCHAR lTableName[SIZELINEMAX];

            bOK = SetupGetLineTextW(
                                   &lTableContext,
                                   NULL,
                                   NULL,
                                   NULL,
                                   lTableName,
                                   SIZELINEMAX,
                                   NULL
                                   );

            // fetch the next line's context
            if (!bOK)
            {
                g_FatalError = true;
                bError = true;
                break;
            }

            // Rowset pointer
            CComPtr<IRowset>  lpRowset;

            //////////////////////
            // create one rowset
            //////////////////////
            hres = Database.InitializeRowset(lTableName, &lpRowset);

            if (FAILED(hres))
            {
                g_FatalError = true;
                bError = true;
                break;
            }
            else
            {
                // create the simpletable
                CSimpleTableEx    lSimpleTable;

                lSimpleTable.Attach(lpRowset);
                lSimpleTable.MoveFirst();

                //////////////////////////////////////////////////////
                // now one table and all its columns are well known.
                // empty database assumed
                // process the rows
                //////////////////////////////////////////////////////
                hres = ProcessAllRows(
                                      hINF,
                                      lSimpleTable,
                                      lTableName
                                      );

                if (FAILED(hres))
                {
                    // process rows should not fail, even if no rows are read
                    bError       = true;
                    g_FatalError = true;
                }
            }

            //////////////////////////////////////////////////////
            // Read the next table's name (if any)
            //////////////////////////////////////////////////////
            bOK = SetupFindNextLine(
                                      &lTableContext,
                                      &lTableContext
                                     );
            if (!bOK)
            {
                if ((lTableCounter + 1) < lTotalTableNumber)
                {
                   // find next line should not crash. fatal error
                   g_FatalError = true;
                   bError       = true;
                   break;
                }
                break;
            } //end of tables
        }
    }
    else
    {// no tables: do nothing
        TracePrintf("Info: No [tables] section in the inf file\n");
        // bError = true;
    }

    if (bError)
    {
        LPVOID              lpMsgBuf;
        FormatMessageW(
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      NULL,
                      GetLastError(),
                      // Default language
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      (LPWSTR) &lpMsgBuf,
                      0,
                      NULL
                      );

        // Display the string.
        TracePrintf("Error: %S",lpMsgBuf);

        // Free the buffer.
        LocalFree( lpMsgBuf );
        hres = E_FAIL;
    }

    return      hres;
}


//////////////////////////////////////////////////////////////////////////////
//
// ProcessAllRows
//
//////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAllRows(
                       const HINF&       hINF,
                       CSimpleTableEx&  pSimpleTable,
                       const WCHAR*     pTableName
                       )
{
   _ASSERTE(pTableName != NULL);

    ////////////////////
    // process the rows.
    ////////////////////

   wstring              lwsRowSection;
   lwsRowSection        += pTableName;

   LONG                 lRowCounter = 1;

   INFCONTEXT           lRowContext;

    #ifdef DEBUG
       TracePrintf("Info: %S",lwsRowSection.c_str());
    #endif

    ////////////////////////////////////////////////////
    // if <>0 do a loop on the lines (ie row names)
    ////////////////////////////////////////////////////
    BOOL bOK = SetupFindFirstLineW(
                           hINF,
                           // section in which to find a line
                           lwsRowSection.c_str(),
                           NULL,          // optional, key to search for
                           &lRowContext  // context of the found line
                           );

    HRESULT              hres = S_OK;

    if (!bOK)
    {
        //no such section (end of section = end of rows)
    }
    else
    {

        LONG                lTotalLinesNumber = 0; //safer
        //////////////////////////////////////////////////////
        // Get the Number of lines in that section. (& check)
        //////////////////////////////////////////////////////
        lTotalLinesNumber = SetupGetLineCountW(
                                          hINF, // handle to the INF file
                                   // the section in which to count lines
                                          lwsRowSection.c_str()
                                          );


        //////////////////////////////
        // Read eerything (loop)
        //////////////////////////////
        for (
             LONG lLinesCounter = 0;
             lLinesCounter < lTotalLinesNumber;
             lLinesCounter++
            )
        {

            #ifdef DEBUG
              TracePrintf("Info: for loop: %d", lLinesCounter);
            #endif

            ///////////////////////////////////////////////
            // read the Table name in the Tables section
            ///////////////////////////////////////////////
            WCHAR lLineName[SIZELINEMAX];

            bOK = SetupGetLineTextW(
                                    &lRowContext,
                                    NULL,
                                    NULL,
                                    NULL,
                                    lLineName,
                                    SIZELINEMAX,
                                    NULL
                                   );

            if (!bOK)
            {
                g_FatalError = true;
                TracePrintf("Error: SetupGetLineText Failed "
                               "in ProcessAllRows");
            }
            else //everything is ok, process the corresponding row
            {
                ///////////////////////
                // process the rows
                ///////////////////////
                hres = ProcessOneRow(
                                      hINF,
                                      pSimpleTable,
                                      lLineName
                                    );
                if (FAILED(hres)) { g_FatalError = true; }

            }

            //////////////////////////////////
            // fetch the next line's context
            //////////////////////////////////
            bOK = SetupFindNextLine(
                                    // starting context in an INF file
                                    &lRowContext,
                                    // context of the next line
                                    &lRowContext
                                   );
            if (!bOK)
            {
                ////////////////////////////////////////////////
                // end of the lines
                // compare the counter to the max to make sure
                // that last line is ok
                ////////////////////////////////////////////////
                if((lLinesCounter + 1) < lTotalLinesNumber)
                {
                    // too early
                    g_FatalError = true;
                    TracePrintf("Error: FindNext Line failed."
                                  "Not enough lines in the section %S",
                                  lwsRowSection.c_str());

                }
            }
        }
    }

    return      hres;
}


//////////////////////////////////////////////////////////////////////////////
//
// ProcessOneRow
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
ProcessOneRow(
    HINF inf,
    CSimpleTableEx& table,
    PCWSTR rowName
    )
{
   // Iterate through the columns in the database and see if the INF file
   // specifies a value for each column.
   for (DBORDINAL i = 0; i < table.GetColumnCount(); ++i)
   {
      // First try with a stack-based buffer.
      WCHAR buffer[1024];
      PWCHAR text = buffer;
      DWORD textSize = sizeof(buffer) / sizeof(buffer[0]);
      BOOL success = SetupGetLineTextW(
                         NULL,
                         inf,
                         rowName,
                         table.GetColumnName(i),
                         text,
                         textSize,
                         &textSize
                         );
      DWORD error = success ? NO_ERROR : GetLastError();

      if (error == ERROR_INSUFFICIENT_BUFFER)
      {
         // The stack-based buffer wasn't big enough, so allocate one on the
         // heap ...
         text = (PWCHAR)HeapAlloc(
                            GetProcessHeap(),
                            0,
                            textSize * sizeof(WCHAR)
                            );
         if (!text) { return E_OUTOFMEMORY; }

         // ... and try again.
         success = SetupGetLineTextW(
                       NULL,
                       inf,
                       rowName,
                       table.GetColumnName(i),
                       text,
                       textSize,
                       &textSize
                       );
         error = success ? NO_ERROR : GetLastError();
      }

      // If we successfully retrieved the line text AND it has at least one
      // character ...
      if (!error && textSize > 1)
      {
         // ... then process based on the column data type.
         switch (table.GetColumnType(i))
         {
            case DBTYPE_I4:
            {
               table.SetValue(i, _wtol(text));
               break;
            }

            case DBTYPE_WSTR:
            {
               table.SetValue(i, text);
               break;
            }

            case DBTYPE_BOOL:
            {
               table.SetValue(i, (VARIANT_BOOL)_wtol(text));
               break;
            }
         }
      }

      // Free the heap-based buffer if necessary.
      if (text != buffer) { HeapFree(GetProcessHeap(), 0, text); }

      switch (error)
      {
         case NO_ERROR:
            // Everything succeeded.
         case ERROR_INVALID_PARAMETER:
            // SETUPAPI didn't like the column name.
         case ERROR_LINE_NOT_FOUND:
            // The INF file didn't provide a value for this column.
            break;

         default:
            // Something went wrong.
            return HRESULT_FROM_WIN32(error);
      }
   }

   // All the columns are populated, so insert the row.
   return table.Insert();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\simpletableex.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    SimpleTableEx.h
//
// SYNOPSIS
//
//    SimpleTableEx.h: header for CSimpleTableEx
//    derived from CSimpleTable. Only difference
//    is SetValue() overloaded for WCHAR *
//
// MODIFICATION HISTORY
//
//    01/26/1999    Original version.
//    
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MYSIMPLETABLE_H__EEA1D7F0_B649_11D2_9E24_00C04F6EA5B6_INCLUDED)
#define AFX_MYSIMPLETABLE_H__EEA1D7F0_B649_11D2_9E24_00C04F6EA5B6_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.hpp"
#include "simTable.h"


//////////////////////////////////////////////////////////////////////////////
//
// Class CSimpleTableEx
//
//////////////////////////////////////////////////////////////////////////////
class CSimpleTableEx : public CSimpleTable  
{
public:
   using CSimpleTable::SetValue;
    // set public a protected method from the super class
   template <>
   void SetValue(DBORDINAL nOrdinal, WCHAR *szValue)
   {
      wcscpy((WCHAR *)_GetDataPtr(nOrdinal), szValue);
   }
   HRESULT Attach(IRowset* pRowset);

};

#endif 
// !defined(AFX_MYSIMPLETABLE_H__EEA1D7F0_B649_11D2_9E24_00C04F6EA5B6_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\precomp.hpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    precomp.h
//
// SYNOPSIS
//
//    Include file for the inf2db project
//
// MODIFICATION HISTORY
//
//    02/12/1999    Original version.
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(PRECOMP_H__61594E40_C20F_11D2_9E31_00C04F6EA5B6__INCLUDED_)
#define PRECOMP_H__61594E40_C20F_11D2_9E31_00C04F6EA5B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////
// Old-type defines
////////////////////////
#define DBINITCONSTANTS // Initialize OLE constants...
#define SIZELINEMAX     512

////////////////////////////////////
// Macro
////////////////////////////////////

#define CHECK_CALL_HRES(expr) \
hres = expr;      \
if (FAILED(hres)) \
{       \
    TracePrintf("%s returned 0x%X\n",  ## #expr, hres); \
    return hres; \
}

// Return the error code from a failed COM invocation.  Useful if you don't
// have to do any special clean-up.
#define RETURN_ERROR(expr) \
   { HRESULT __hr__ = (expr); if (FAILED(__hr__)) return __hr__; }

#include <atlbase.h>

#include <crtdbg.h>

#include <iostream>
#include <vector>
#include <list>
#include <string>

#include "oledb.h"
#include "oledberr.h"
#include "setupapi.h"

namespace
{
    const WCHAR     TABLE_SECTION[]         = L"Tables";
    const WCHAR     VERSION_SECTION[]       = L"Version";
    const WCHAR     DATABASE_KEY[]          = L"Database";
    const WCHAR     TEMPORARY_FILENAME[]    = L".\\_temporary.mdb";

    const long      SIZELONGMAX             = 10; //10 digits ?
    const int       NUMBER_ARGUMENTS        = 4;

    const long      SIZE_MEMO_MAX           = 32768;
}


// from helper
HRESULT ConvertTypeStringToLong(const WCHAR *lColumnType, LONG *pType);
void __cdecl TracePrintf(IN PCSTR szFormat, ...);
void TraceString(IN WCHAR* wcString);
void TraceString(IN char* cString);



#endif
// !defined(PRECOMP_H__61594E40_C20F_11D2_9E31_00C04F6EA5B6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\inf2db.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    inf2db.h
//
// SYNOPSIS
//
// Header file for inf2db: the main file for that project.
//    
//
// MODIFICATION HISTORY
//
//    02/11/1999    Original version.
//
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6__INCLUDED_)
#define AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.hpp"

#include "database.h"
#include "simpletableex.h"
#include "command.h"

using namespace std;

namespace
{
    bool g_FatalError;

    class CLocalBinding  
    {
        public:
            WCHAR    ColumnName[SIZELINEMAX];
            LONG     Ordinal;
            LONG     DBType;
    };
}


HRESULT Uninitialize(HINF *phINF, CDatabase& Database);

HRESULT Process(const HINF& hINF, CDatabase& Database);

HRESULT ProcessAllRows(
                       const HINF&       hINF,
                       CSimpleTableEx&  pSimpleTable,
                       const WCHAR*     pTableName
                       );

HRESULT ProcessOneRow(
                        HINF inf,
                        CSimpleTableEx& table,
                        PCWSTR rowName);




#endif
 // !defined(AFX_DATABASE_H__2B7B2F60_C53F_11D2_9E33_00C04F6EA5B6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\simpletableex.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    MySimpleTable.cpp
//
// SYNOPSIS
//
//    MySimpleTable.cpp: derived from CSimpleTable. Only difference
//    is _GetDataPtr now public instead of being protected
//
// MODIFICATION HISTORY
//
//    01/26/1999    Original version.
//
//
//////////////////////////////////////////////////////////////////////

#include "precomp.hpp"
#include "simpletableex.h"

#ifdef _DEBUG
    #undef THIS_FILE
    static char THIS_FILE[]=__FILE__;
    #define new DEBUG_NEW
#endif


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    DBBinding
//
// DESCRIPTION
//
//    This struct extends the DBBINDING struct to provide functionality
//    to initialize the struct from a DBCOLUMNINFO struct.
//
///////////////////////////////////////////////////////////////////////////////
struct DBBinding : DBBINDING
{
   //////////
   // 'offset' is the offset in bytes of this column's data within the
   //  row buffer.
   //////////
   void Initialize(DBCOLUMNINFO& columnInfo, DBBYTEOFFSET& offset)
   {
      iOrdinal   = columnInfo.iOrdinal;
      obValue    = offset;
      obLength   = offset + columnInfo.ulColumnSize;
      obStatus   = obLength + sizeof(DBLENGTH);
      pTypeInfo  = NULL;
      pObject    = NULL;
      pBindExt   = NULL;
      dwPart     = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
      eParamIO   = DBPARAMIO_NOTPARAM;
      dwMemOwner = (columnInfo.wType & DBTYPE_BYREF) ? DBMEMOWNER_PROVIDEROWNED
                                                     : DBMEMOWNER_CLIENTOWNED;
      cbMaxLen   = columnInfo.ulColumnSize;
      dwFlags    = 0;
      wType      = columnInfo.wType;
      bPrecision = columnInfo.bPrecision;
      bScale     = columnInfo.bScale;

      offset = obStatus + sizeof(DBSTATUS);
   }
};

   
///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTableEx::Attach
//
//    Size bug "fixed"
//
// DESCRIPTION
//
//    This method binds the table object to a new rowset. The previous rowset
//    (if any) will be detached.
//
// REMARK: see "Changes" below
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTableEx::Attach(IRowset* pRowset)
{
   // Make sure we didn't get a null pointer.
   if (!pRowset) { return E_POINTER; }

   // Detach the current rowset.
   Detach();

   // We don't care if this returns an error. It will just prevent
   // the user from updating.
   pRowset->QueryInterface(IID_IRowsetChange, (void**)&rowsetChange);

   //////////
   // Get the column information for the table.
   //////////

   CComPtr<IColumnsInfo> ColumnsInfo;
   RETURN_ERROR(pRowset->QueryInterface(IID_IColumnsInfo,
                                        (void**)&ColumnsInfo));

   RETURN_ERROR(ColumnsInfo->GetColumnInfo(&numColumns,
                                           &columnInfo,
                                           &stringsBuffer));

   //////////
   // Allocate the per-column data.
   //////////

   // tperraut Bug 449498
   columnBinding = new (std::nothrow) DBBinding[numColumns];

   if ( !columnBinding )
   {
      return E_OUTOFMEMORY;
   }

   // 449498 resize changed: will not throw an exception. 
   // false if out of memory
   if ( !dirty.resize(numColumns) )
   {
       return E_OUTOFMEMORY;
   }

   //////////
   // Create a binding for each column.
   //////////

   bufferLength = 0;

   for (DBORDINAL i = 0; i < numColumns; ++i)
   {
      // Compute the width of the column.
      DBLENGTH width = columnInfo[i].ulColumnSize;

      //////////////////////////////////////////////////////////////////
      //
      // CHANGES: if size is too big (1 giga byte), then size = a 
      // pre-defined value. Note: that's dangerous 
      //
      //////////////////////////////////////////////////////////////////
      if (SIZE_MEMO_MAX < width)
      {
          width = SIZE_MEMO_MAX;
      }

      // Add room for the null terminator.
      if (columnInfo[i].wType == DBTYPE_STR)
      {
         width += 1;
      }
      else if (columnInfo[i].wType == DBTYPE_WSTR)
      {
         width = (width + 1) * sizeof(WCHAR);
      }

      // Round to an 8-byte boundary (could peek ahead and be more efficient).
      width = (width + 7) >> 3 << 3;

      columnInfo[i].ulColumnSize = width;

      // We're using the pTypeInfo element to store the offset to our data.
      // We have to store the offset now, since it will be overwritten by
      // DBBinding::Initialize.
      columnInfo[i].pTypeInfo = (ITypeInfo*)bufferLength;

      columnBinding[i].Initialize(columnInfo[i], bufferLength);
   }

   //////////
   // Allocate a buffer for the row data.
   //////////

   buffer = new (std::nothrow) BYTE[bufferLength];

   if (!buffer) { return E_OUTOFMEMORY; }

   //////////
   // Create an accessor.
   //////////

   RETURN_ERROR(pRowset->QueryInterface(IID_IAccessor,
                                        (void**)&accessor));

   RETURN_ERROR(accessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                         numColumns,
                                         columnBinding,
                                         bufferLength,
                                         &readAccess,
                                         NULL));

   // I used this hokey method of assigning the pointer to avoid a
   // dependency on atlimpl.cpp
   //
   // We do this assignment last, so that the presence of a rowset means the
   // entire initialization succeeded.
   (rowset.p = pRowset)->AddRef();

   endOfRowset = false;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idlemon\idlemon.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    idlemon.c

Abstract:

    Little program for recording the various idle states of a machine

Author:

    John Vert (jvert) 1/14/2000

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <conio.h>

#define DISPLAY_TOTAL 0
#define DISPLAY_DELTA 1
#define DISPLAY_RAW   2

int Display=DISPLAY_TOTAL;
int ShowTransitions=FALSE;

#define printtime(_x_) {                                        \
        ULONGLONG ms = (_x_)/10000;                              \
        ULONG hours, minutes, seconds;                           \
        hours = (ULONG)ms/(1000*60*60);                                 \
        if (hours) printf("%3d:",(ULONG)(ms/(1000*60*60)));                 \
        ms=ms%(1000*60*60);                                     \
        minutes = (ULONG)ms/(1000*60);                                 \
        if (minutes || hours) printf("%02d:",(ULONG)(ms/(1000*60)));                 \
        ms=ms%(1000*60);                                        \
        seconds = (ULONG)ms/1000;                                      \
        printf("%02d.",seconds);                      \
        ms=ms%1000;                                             \
        printf("%03d",(ULONG)ms);                       \
    }

__cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    CHAR Buff[sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION)*MAXIMUM_PROCESSORS];
    PSYSTEM_PROCESSOR_IDLE_INFORMATION IdleInfo = (PSYSTEM_PROCESSOR_IDLE_INFORMATION)Buff;
    ULONG Length;
    NTSTATUS Status;
    ULONGLONG LastIdleTime[MAXIMUM_PROCESSORS];
    ULONGLONG LastC1Time[MAXIMUM_PROCESSORS], LastC2Time[MAXIMUM_PROCESSORS], LastC3Time[MAXIMUM_PROCESSORS];
    ULONG LastC1Transitions[MAXIMUM_PROCESSORS], LastC2Transitions[MAXIMUM_PROCESSORS], LastC3Transitions[MAXIMUM_PROCESSORS];
    ULONG i,NumProc;
    LARGE_INTEGER Delay;
    ULONGLONG DeltaTime;
    ULONGLONG Diff;
    ULONG Delta;

    for (i=0;i<MAXIMUM_PROCESSORS;i++) {
        LastIdleTime[i] = LastC1Time[i] = LastC2Time[i] = LastC3Time[i] = 0;
        LastC1Transitions[i] = LastC2Transitions[i] = LastC3Transitions[i] = 0;

    }

    Delay.QuadPart = -5 * 1000 * 1000 * 10;
    printf("TOT IDLE     TOTC1    TOTC2  TOTC3    DELTA IDLE  DELTAC1    DELTAC2    DELTAC3\n");

    while (1) {
        if (_kbhit()) {
            int Char=_getch();
            switch (toupper(Char)) {
                case 'T':
                    Display = DISPLAY_TOTAL;
                    break;
                case 'D':
                    Display = DISPLAY_DELTA;
                    break;
                case 'R':
                    Display = DISPLAY_RAW;
                    break;
                case 'C':
                    ShowTransitions = !ShowTransitions;
                    break;
                case 'P':
                    printf("Hit a key to continue\n");
                    _getch();
                    break;

                default:
                    printf("Type :\n");
                    printf("\t'T' - display Total\n");
                    printf("\t'D' - display Delta\n");
                    printf("\t'R' - display Raw\n");
                    printf("\t'C' - toggle between transition Counts and time\n");
                    printf("\t'P' - Pause\n");

            }
        }
        Status = NtQuerySystemInformation(SystemProcessorIdleInformation,
                                          IdleInfo,
                                          sizeof(Buff),
                                          &Length);
        if (!NT_SUCCESS(Status)) {
            fprintf(stderr, "NtQuerySystemInformation failed: %lx\n",Status);
            return(Status);
        }
        NumProc = Length/sizeof(SYSTEM_PROCESSOR_IDLE_INFORMATION);
        for (i=0;i<NumProc;i++) {
            if (NumProc > 1) {
                printf("%2d>",i);
            } else {
                printf("   ");
            }
            if (ShowTransitions) {
                switch (Display) {
                    case DISPLAY_TOTAL:
                        printf("Idle ");
                        printtime(IdleInfo[i].IdleTime);
                        printf("  C1 %d (%d us)",
                               IdleInfo[i].C1Transitions,
                               (ULONG)(IdleInfo[i].C1Time*10/IdleInfo[i].C1Transitions));
                        printf("  C2 %d (%d us)",
                               IdleInfo[i].C2Transitions,
                               (ULONG)(IdleInfo[i].C2Time*10/IdleInfo[i].C2Transitions));
                        printf("  C3 %d (%d us)",
                               IdleInfo[i].C3Transitions,
                               (ULONG)(IdleInfo[i].C3Time*10/IdleInfo[i].C3Transitions));
                        break;

                    case DISPLAY_DELTA:
                        printf("Idle ");
                        DeltaTime = IdleInfo[i].IdleTime-LastIdleTime[i];
                        printtime(DeltaTime);
                        DeltaTime = IdleInfo[i].C1Time-LastC1Time[i];
                        Delta = IdleInfo[i].C1Transitions-LastC1Transitions[i];
                        printf("  C1 %d (%d us)",
                               Delta,
                               (Delta == 0) ? 0 : (ULONG)(DeltaTime/10/Delta));
                        DeltaTime = IdleInfo[i].C2Time-LastC2Time[i];
                        Delta = IdleInfo[i].C2Transitions-LastC2Transitions[i];
                        printf("  C2 %d (%d us)",
                               Delta,
                               (Delta == 0) ? 0 : (ULONG)(DeltaTime/10/Delta));
                        DeltaTime = IdleInfo[i].C3Time-LastC3Time[i];
                        Delta = IdleInfo[i].C3Transitions-LastC3Transitions[i];
                        printf("  C3 %d (%d us)",
                               Delta,
                               (Delta == 0) ? 0 : (ULONG)(DeltaTime/10/Delta));
                        break;

                    case DISPLAY_RAW:
                        printf("Idle %I64X  C1 %d  C2 %d  C3 %d",
                               IdleInfo[i].IdleTime,
                               IdleInfo[i].C1Transitions,
                               IdleInfo[i].C2Transitions,
                               IdleInfo[i].C3Transitions);
                        break;

                }
            } else {
                switch (Display) {
                    case DISPLAY_TOTAL:
                        printf("Idle ");
                        printtime(IdleInfo[i].IdleTime);
                        printf("  C1 ");
                        printtime(IdleInfo[i].C1Time);
                        printf("(%2d%%)  C2 ",IdleInfo[i].C1Time*100/IdleInfo[i].IdleTime);
                        printtime(IdleInfo[i].C2Time);
                        printf("(%2d%%)  C3 ",IdleInfo[i].C2Time*100/IdleInfo[i].IdleTime);
                        printtime(IdleInfo[i].C3Time);
                        printf("(%2d%%) ",IdleInfo[i].C3Time*100/IdleInfo[i].IdleTime);
                        break;

                    case DISPLAY_DELTA:
                        printf("Idle ");
                        printtime(IdleInfo[i].IdleTime-LastIdleTime[i]);
                        printf("  C1 ");
                        printtime(IdleInfo[i].C1Time-LastC1Time[i]);
                        DeltaTime = IdleInfo[i].C1Time-LastC1Time[i];
                        Diff = IdleInfo[i].IdleTime - LastIdleTime[i];
                        printf("(%2d%%)  C2 ",(Diff == 0 ? 0 : (DeltaTime * 100 / Diff) ) );
                        DeltaTime = IdleInfo[i].C2Time-LastC2Time[i];
                        printtime(IdleInfo[i].C2Time-LastC2Time[i]);
                        printf("(%2d%%)  C3 ",(Diff == 0 ? 0 : (DeltaTime * 100/ Diff) ) );
                        DeltaTime = IdleInfo[i].C3Time-LastC3Time[i];
                        printtime(IdleInfo[i].C3Time-LastC3Time[i]);
                        printf("(%2d%%) ",(Diff == 0 ? 0 : (DeltaTime * 100 / Diff) ) );
                        break;
                    case DISPLAY_RAW:
                        printf("Idle %I64X  C1 %I64X  C2 %I64X  C3 %I64X",
                               IdleInfo[i].IdleTime,
                               IdleInfo[i].C1Time,
                               IdleInfo[i].C2Time,
                               IdleInfo[i].C3Time);
                        break;
                }

            }


            LastIdleTime[i] = IdleInfo[i].IdleTime;
            LastC1Time[i] = IdleInfo[i].C1Time;
            LastC2Time[i] = IdleInfo[i].C2Time;
            LastC3Time[i] = IdleInfo[i].C3Time;

            LastC1Transitions[i] = IdleInfo[i].C1Transitions;
            LastC2Transitions[i] = IdleInfo[i].C2Transitions;
            LastC3Transitions[i] = IdleInfo[i].C3Transitions;

            printf("\n");
        }
        NtDelayExecution(FALSE, &Delay);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\simtable.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997-1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    SimTable.cpp
//
// SYNOPSIS
//
//    This file implements the class CSimpleTable
//
// MODIFICATION HISTORY
//
//    10/31/1997    Original version.
//    02/09/1998    Reorganized some things to make is easier to extend.
//    02/27/1998    Changes to support moving it into the iasutil.lib
//    10/16/1998    Support DBTYPE_WSTR.
//
///////////////////////////////////////////////////////////////////////////////

#include "precomp.hpp"
#include <oledberr.h>
#include <SimTable.h>

//////////
// Stack version of the new operator.
//////////
#define stack_new(obj, num) new (_alloca(sizeof(obj)*num)) obj[num]


///////////////////////////////////////////////////////////////////////////////
//
// STRUCT
//
//    DBBinding
//
// DESCRIPTION
//
//    This struct extends the DBBINDING struct to provide functionality
//    to initialize the struct from a DBCOLUMNINFO struct.
//
///////////////////////////////////////////////////////////////////////////////
struct DBBinding : DBBINDING
{
   //////////
   // 'offset' is the offset in bytes of this column's data within the
   //  row buffer.
   //////////
   void Initialize(DBCOLUMNINFO& columnInfo, DBBYTEOFFSET& offset)
   {
      iOrdinal   = columnInfo.iOrdinal;
      obValue    = offset;
      obLength   = offset + columnInfo.ulColumnSize;
      obStatus   = obLength + sizeof(DBLENGTH);
      pTypeInfo  = NULL;
      pObject    = NULL;
      pBindExt   = NULL;
      dwPart     = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
      eParamIO   = DBPARAMIO_NOTPARAM;
      dwMemOwner = (columnInfo.wType & DBTYPE_BYREF) ? DBMEMOWNER_PROVIDEROWNED
                                                     : DBMEMOWNER_CLIENTOWNED;
      cbMaxLen   = columnInfo.ulColumnSize;
      dwFlags    = 0;
      wType      = columnInfo.wType;
      bPrecision = columnInfo.bPrecision;
      bScale     = columnInfo.bScale;

      offset = obStatus + sizeof(DBSTATUS);
   }
};


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::CSimpleTable
//
// DESCRIPTION
//
//    Constructor.
//
///////////////////////////////////////////////////////////////////////////////
CSimpleTable::CSimpleTable()
   : numColumns(0),
     columnInfo(NULL),
     stringsBuffer(NULL),
     columnBinding(NULL),
     readAccess(NULL),
     buffer(NULL),
     numRows(0),
     currentRow(0),
     endOfRowset(false)
{
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::~CSimpleTable
//
// DESCRIPTION
//
//    Destructor.
//
///////////////////////////////////////////////////////////////////////////////
CSimpleTable::~CSimpleTable()
{
   Detach();
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Attach
//
// DESCRIPTION
//
//    This method binds the table object to a new rowset. The previous rowset
//    (if any) will be detached.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Attach(IRowset* pRowset)
{
   // Make sure we didn't get a null pointer.
   if (!pRowset) { return E_POINTER; }

   // Detach the current rowset.
   Detach();

   // We don't care if this returns an error. It will just prevent
   // the user from updating.
   pRowset->QueryInterface(IID_IRowsetChange, (void**)&rowsetChange);

   //////////
   // Get the column information for the table.
   //////////

   CComPtr<IColumnsInfo> ColumnsInfo;
   RETURN_ERROR(pRowset->QueryInterface(IID_IColumnsInfo,
                                        (void**)&ColumnsInfo));

   RETURN_ERROR(ColumnsInfo->GetColumnInfo(&numColumns,
                                           &columnInfo,
                                           &stringsBuffer));

   //////////
   // Allocate the per-column data.
   //////////

   // tperraut Bug 449498
   columnBinding = new (std::nothrow) DBBinding[numColumns];

   if ( !columnBinding )
   {
      return E_OUTOFMEMORY;
   }

   // 449498 resize changed: will not throw an exception. 
   // false if out of memory
   if ( !dirty.resize(numColumns) )
   {
       return E_OUTOFMEMORY;
   }

   //////////
   // Create a binding for each column.
   //////////

   bufferLength = 0;

   for (DBORDINAL i = 0; i < numColumns; ++i)
   {
      // Compute the width of the column.
      DBLENGTH width = columnInfo[i].ulColumnSize;

      // Add room for the null terminator.
      if (columnInfo[i].wType == DBTYPE_STR)
      {
         width += 1;
      }
      else if (columnInfo[i].wType == DBTYPE_WSTR)
      {
         width = (width + 1) * sizeof(WCHAR);
      }

      // Round to an 8-byte boundary (could peek ahead and be more efficient).
      width = (width + 7) >> 3 << 3;

      columnInfo[i].ulColumnSize = width;

      // We're using the pTypeInfo element to store the offset to our data.
      // We have to store the offset now, since it will be overwritten by
      // DBBinding::Initialize.
      columnInfo[i].pTypeInfo = (ITypeInfo*)bufferLength;

      columnBinding[i].Initialize(columnInfo[i], bufferLength);
   }

   //////////
   // Allocate a buffer for the row data.
   //////////

   buffer = new (std::nothrow) BYTE[bufferLength];

   if (!buffer) { return E_OUTOFMEMORY; }

   //////////
   // Create an accessor.
   //////////

   RETURN_ERROR(pRowset->QueryInterface(IID_IAccessor,
                                        (void**)&accessor));

   RETURN_ERROR(accessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                         numColumns,
                                         columnBinding,
                                         bufferLength,
                                         &readAccess,
                                         NULL));

   // I used this hokey method of assigning the pointer to avoid a
   // dependency on atlimpl.cpp
   //
   // We do this assignment last, so that the presence of a rowset means the
   // entire initialization succeeded.
   (rowset.p = pRowset)->AddRef();

   endOfRowset = false;

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Detach
//
// DESCRIPTION
//
//    Frees all the resources associated with the current rowset.
//
///////////////////////////////////////////////////////////////////////////////
IRowset* CSimpleTable::Detach()
{
   ReleaseRows();

   delete[] buffer;
   buffer = NULL;

   delete[] columnBinding;
   columnBinding = NULL;

   CoTaskMemFree(columnInfo);
   columnInfo = NULL;

   CoTaskMemFree(stringsBuffer);
   stringsBuffer = NULL;

   accessor.Release();
   rowsetChange.Release();

   IRowset* temp = rowset;
   rowset.Release();
   return temp;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::MoveFirst
//
// DESCRIPTION
//
//    Positions the cursor over the first row in the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::MoveFirst()
{
   if (rowset == NULL) return E_FAIL;

   ReleaseRows();

   RETURN_ERROR(rowset->RestartPosition(NULL));

   endOfRowset = false;

   return MoveNext();
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::MoveNext
//
// DESCRIPTION
//
//    Positions the cursor over the next row in the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::MoveNext()
{
   // If the data wasn't opened successfully then fail
   if (rowset == NULL) return E_FAIL;

   // Too late to save any changes.
   DiscardChanges();

   // If we've used all the rows from the last fetch, then get some more.
   if (++currentRow >= numRows)
   {
      ReleaseRows();

      // We have to do this check here, since some providers automatically
      // reset to the beginning of the rowset.
      if (endOfRowset) { return DB_S_ENDOFROWSET; }

      HROW* pRow = row;
      HRESULT hr = rowset->GetNextRows(NULL,
                                       0,
                                       FETCH_QUANTUM,
                                       &numRows,
                                       &pRow);

      if (hr == DB_S_ENDOFROWSET)
      {
         // Mark that we've reached the end of the rowset.
         endOfRowset = true;

         // If we didn't get any rows, then we're really at the end.
         if (numRows == 0) { return DB_S_ENDOFROWSET; }
      }
      else if (FAILED(hr))
      {
         return hr;
      }
   }

   // Load the data into the buffer.
   RETURN_ERROR(rowset->GetData(row[currentRow], readAccess, buffer));

   return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Insert
//
// DESCRIPTION
//
//    Inserts the contents of the accessor buffer into the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Insert()
{
   // Is a rowset attached?
   if (!rowset) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   // Get an accessor for the dirty columns.
   HACCESSOR writeAccess;
   RETURN_ERROR(CreateAccessorForWrite(&writeAccess));

   // Release the existing rows to make room for the new one.
   ReleaseRows();

   HRESULT hr = rowsetChange->InsertRow(NULL, writeAccess, buffer, row);

   if (SUCCEEDED(hr))
   {
      // The changes were save successfully, so reset the dirty vector.
      DiscardChanges();

      // We now have exactly one row in our buffer.
      numRows = 1;
   }

   // Release the accessor.
   accessor->ReleaseAccessor(writeAccess, NULL);

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::Delete
//
// DESCRIPTION
//
//    Deletes the current row from the rowset.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::Delete()
{
   // Are we positioned over a valid row?
   if (!rowset || currentRow >= numRows) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   DBROWSTATUS rowStatus[1];

   return rowsetChange->DeleteRows(NULL, 1, row + currentRow, rowStatus);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::SetData
//
// DESCRIPTION
//
//    Updates the current row with the data in the accessor buffer.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::SetData()
{
   // Are we positioned over a valid row?
   if (!rowset || currentRow >= numRows) { return E_FAIL; }

   // Does this rowset support changes?
   if (!rowsetChange) { return E_NOINTERFACE; }

   // Get an accessor for the dirty columns.
   HACCESSOR writeAccess;
   RETURN_ERROR(CreateAccessorForWrite(&writeAccess));

   HRESULT hr = rowsetChange->SetData(row[currentRow], writeAccess, buffer);

   if (SUCCEEDED(hr))
   {
      // The changes were save successfully, so reset the dirty vector.
      DiscardChanges();
   }

   // Release the accessor.
   accessor->ReleaseAccessor(writeAccess, NULL);

   return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetLength
//
// DESCRIPTION
//
//    Returns the length of the current value for a given column.
//
///////////////////////////////////////////////////////////////////////////////
DBLENGTH CSimpleTable::GetLength(DBORDINAL nOrdinal) const
{
   return *(DBLENGTH*)((BYTE*)_GetDataPtr(nOrdinal) +
                       columnInfo[OrdinalToColumn(nOrdinal)].ulColumnSize);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetOrdinal
//
// DESCRIPTION
//
//    Returns the ordinal for a given column name.
//
///////////////////////////////////////////////////////////////////////////////
bool CSimpleTable::GetOrdinal(LPCWSTR szColumnName, DBORDINAL* pOrdinal) const
{
   for (DBORDINAL i = 0; i < numColumns; ++i)
   {
      if (lstrcmpW(columnInfo[i].pwszName, szColumnName) == 0)
      {
         *pOrdinal = columnInfo[i].iOrdinal;

         return true;
      }
   }

   return false;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::GetStatus
//
// DESCRIPTION
//
//    Returns the status code associated with the current value of a column.
//
///////////////////////////////////////////////////////////////////////////////
DBSTATUS CSimpleTable::GetStatus(DBORDINAL nOrdinal) const
{
   return *(DBSTATUS*)((BYTE*)_GetDataPtr(nOrdinal) +
                       columnInfo[OrdinalToColumn(nOrdinal)].ulColumnSize +
                       sizeof(DBLENGTH));
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::CreateAccessorForWrite
//
// DESCRIPTION
//
//    Creates an accessor that is only to bound to columns that have been
//    modified.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::CreateAccessorForWrite(HACCESSOR* phAccessor)
{
   //////////
   // Allocate temporary space for the bindings.
   //////////

   DBBINDING* writeBind = stack_new(DBBINDING, dirty.count());

   //////////
   // Load in all the dirty columns.
   //////////

   size_t total = 0;

   for (size_t i = 0; total < dirty.count(); ++i)
   {
      if (dirty.test(i))
      {
         // We only want to bind the value.
         (writeBind[total++] = columnBinding[i]).dwPart = DBPART_VALUE;
      }
   }

   //////////
   // Create the accessor.
   //////////

   return accessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                   dirty.count(),
                                   writeBind,
                                   bufferLength,
                                   phAccessor,
                                   NULL);
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::_GetDataPtr
//
// DESCRIPTION
//
//    Non-const version of _GetDataPtr. Marks the target column as dirty.
//
///////////////////////////////////////////////////////////////////////////////
void* CSimpleTable::_GetDataPtr(DBORDINAL nOrdinal)
{
   DBORDINAL nColumn = OrdinalToColumn(nOrdinal);

   dirty.set(nColumn);

   return buffer + (ULONG_PTR)columnInfo[nColumn].pTypeInfo;
}


///////////////////////////////////////////////////////////////////////////////
//
// METHOD
//
//    CSimpleTable::ReleaseRows
//
// DESCRIPTION
//
//    Releases all the rows returned by the last fetch.
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSimpleTable::ReleaseRows()
{
   if (rowset != NULL)
   {
      HRESULT hr = rowset->ReleaseRows(numRows, row, NULL, NULL, NULL);

      currentRow = numRows = 0;

      return hr;
   }

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\iasinfdb\simtable.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997-1999, Microsoft Corp. All rights reserved.
//
// FILE
//
//    SimTable.h
//
// SYNOPSIS
//
//    This file describes the class CSimpleTable
//
// MODIFICATION HISTORY
//
//    10/31/1997    Original version.
//    02/09/1998    Reorganized some things to make is easier to extend.
//                  Thierry Perraut
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _SIMTABLE_H_
#define _SIMTABLE_H_

#include <atlbase.h>
#include <oledb.h>
#include <bitvec.h>
struct DBBinding;

///////////////////////////////////////////////////////////////////////////////
//
// CLASS
//
//    CSimpleTable
//
// DESCRIPTION
//
//    This class provides a simple read-only wrapper for iterating through a
//    rowset and retrieving information.  The interface is based on the ATL
//    CTable<> class. I kept all the function signatures the same, so the two
//    should be almost interchangeable. The main difference is that CTable<>
//    opens a table and retrieves a rowset, while CSimpleTable is handed a
//    rowset that was retrieved elsewhere.
//
///////////////////////////////////////////////////////////////////////////////
class CSimpleTable
{
public:

   CSimpleTable();
   ~CSimpleTable();

   HRESULT Attach(IRowset* pRowset);
   IRowset* Detach();

   HRESULT MoveFirst();
   HRESULT MoveNext();

   HRESULT Insert();
   HRESULT Delete();
   HRESULT SetData();

   void DiscardChanges()
   {
      dirty.reset();
   }

   DBORDINAL GetColumnCount() const
   {
      return numColumns;
   }

   DBCOLUMNFLAGS GetColumnFlags(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].dwFlags;
   }

   LPCWSTR GetColumnName(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].pwszName;
   }

   DBTYPE GetColumnType(DBORDINAL nOrdinal) const
   {
      return columnInfo[OrdinalToColumn(nOrdinal)].wType;
   }

   DBLENGTH GetLength(DBORDINAL nOrdinal) const;

   bool GetOrdinal(LPCWSTR szColumnName, DBORDINAL* pOrdinal) const;

   DBSTATUS GetStatus(DBORDINAL nOrdinal) const;

   const void* GetValue(DBORDINAL nOrdinal) const
   {
      return _GetDataPtr(nOrdinal);
   }

   template <class T>
   void SetValue(DBORDINAL nOrdinal, const T& t)
   {
      *(T*)_GetDataPtr(nOrdinal) = t;
   }

   template <>
   void SetValue(DBORDINAL nOrdinal, PCSTR szValue)
   {
      strcpy((PSTR)_GetDataPtr(nOrdinal), szValue);
   }

   template <>
   void SetValue(DBORDINAL nOrdinal, PSTR szValue)
   {
      strcpy((PSTR)_GetDataPtr(nOrdinal), szValue);
   }

   bool HasBookmark() const
   {
      return (numColumns > 0) && (columnInfo->iOrdinal == 0);
   }

protected:

   enum { FETCH_QUANTUM = 256 };   // The number of rows fetched at a time.

   HRESULT CreateAccessorForWrite(HACCESSOR* phAccessor);

   void* _GetDataPtr(DBORDINAL nOrdinal);

   const void* _GetDataPtr(DBORDINAL nOrdinal) const
   {
      return buffer +
             (ULONG_PTR)columnInfo[OrdinalToColumn(nOrdinal)].pTypeInfo;
   }

   HRESULT ReleaseRows();

   DBORDINAL OrdinalToColumn(DBORDINAL nOrdinal) const
   {
      return nOrdinal -= columnInfo->iOrdinal;
   }

   // Various representations of the rowset being manipulated.
   CComPtr<IRowset> rowset;
   CComPtr<IAccessor> accessor;
   CComPtr<IRowsetChange> rowsetChange;

   DBORDINAL numColumns;      // Number of columns in the table.
   DBCOLUMNINFO* columnInfo;  // Column info.
   OLECHAR* stringsBuffer;    // Buffer used by columnInfo.
   DBBinding* columnBinding;  // Column bindings.
   HACCESSOR readAccess;      // Handle for read accessor.
   PBYTE buffer;              // Accessor buffer.
   DBLENGTH bufferLength;     // Length of accessor buffer.
   HROW row[FETCH_QUANTUM];   // Array of row handles.
   DBCOUNTITEM numRows;       // Number of rows in the row array.
   DBCOUNTITEM currentRow;    // Current row being accessed.
   BitVector dirty;           // Columns that have been modified.
   bool endOfRowset;          // True if we've reached the end of the rowset.
};

#endif  // _SIMTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\files.cpp ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <winver.h>
#include "network.h"
#include "idw_dbg.h"
#include "machines.h"
#include "files.h"

//#include <setupapi.h>

/*++

   Filename :  Files.c

   Description: Contains the network access code.

   Created by:  Wally Ho

   History:     Created on 20/02/2000.

	09.19.2001	Joe Holman	fixes for idwlog bugs 409338, 399178, and 352810


   Contains these functions:

   1. BOOL GetCurrentSystemBuildInfo      ( IN OUT  LPINSTALL_DATA pId);
   2. BOOL GetCurrentInstallingBuildInfo  ( IN OUT  LPINSTALL_DATA pId);
   3. BOOL GetImageHlpDllInfo             ( OUT   LPINSTALL_DATA pId,
                                             IN   INT iFlag);
   4. BOOL MyGetFileVersionInfo(LPTSTR  lpszFilename,
                                LPVOID  *lpVersionInfo);
   5. BOOL GetSkuFromDosNetInf (IN OUT LPINSTALL_DATA pId);


	03.29.2001	Joe Holman	Made the code work on Win9x.

--*/

DWORD gdwLength;  // global used for Win9x data mining, length of buffer.

BOOL
GetCurrentSystemBuildInfo ( IN OUT  LPINSTALL_DATA pId)
/*++

Routine Description:

   This loads the three items of
      DWORD dwSystemBuild;
      DWORD dwSystemBuildDelta;
      TCHAR szSystemBuildSourceLocation[100]

   From information gleaned from the imagehlp.dll.

   *NOTE*
   The  ImageHlp.dll according to Micheal Lekas is compiled everytime a
   build is put out. We are banking on this for this function.

   For XP SPs, this will be from the ntoskrnl.exe file.

Arguments:
   An Install Data struct for loading the data.

Return Value:

     TRUE  if success
     FALSE if fail

--*/

{
   //Initialize all the variables first to expected values.
   pId->dwSystemBuild        = 0;
   pId->dwSystemBuildDelta   = 0;
   pId->dwSystemSPBuild	     = 0;
   pId->dwSystemMajorVersion = 0;
   pId->dwSystemMinorVersion = 0;
   _stprintf(pId->szSystemBuildSourceLocation, TEXT("%s"),
             TEXT("No_Build_Lab_Information"));


  if (DTC == TRUE){

      if (FALSE == GetBuildInfoFromOSAndBldFile(pId, F_SYSTEM )){
            Idwlog(TEXT("GetBuildInfoFromOSAndBldFile failed. Could not retrieved build, delta, location.\n"));
         return FALSE;
      }else{

         Idwlog(TEXT("Success in retrieving build, delta, location.\n"));
         return TRUE;
      }

   // This is Whistler.
   }else{

      if (FALSE == GetImageHlpDllInfo(pId, F_SYSTEM_IMAGEHLP_DLL)){
            Idwlog(TEXT("GetImageHlpDllInfo failed. Could not retrieved build, delta, location.\n"));
         return FALSE;
      }else{

         Idwlog(TEXT("Success in retrieving build, delta, location.\n"));
         return TRUE;
      }
   }

}


BOOL
GetCurrentInstallingBuildInfo ( IN OUT  LPINSTALL_DATA pId)
/*++

Routine Description:

   This loads the three items of
      DWORD dwInstallingBuild;
      DWORD dwInstallingBuildDelta;
      TCHAR szCurrentBuildSourceLocation[100];

   From information gleaned from the imagehlp.dll.

   *NOTE*
   The  ImageHlp.dll according to Micheal Lekas is compiled everytime a
   build is put out. We are banking on this for this function.


Arguments:
   An Install Data struct for loading the data.

Return Value:

     TRUE  if success
     FALSE if fail

--*/

{
   //Initialize all the variables first to expected values.
   pId->dwInstallingBuild        = 0;
   pId->dwInstallingBuildDelta   = 0;
   pId->dwInstallingSPBuild      = 0;
   pId->dwInstallingMajorVersion = 0;
   pId->dwInstallingMinorVersion = 0;
   _stprintf(pId->szInstallingBuildSourceLocation, TEXT("%s"),
             TEXT("No_Build_Lab_Information"));


   if (DTC == 1){

      if (FALSE == GetBuildInfoFromOSAndBldFile(pId, F_INSTALLING )){
            Idwlog(TEXT("GetBuildInfoFromOSAndBldFile failed. Could not retrieved build, delta, location.\n"));
         return FALSE;
      }else{

         Idwlog(TEXT("Success in retrieving build, delta, location.\n"));
         return TRUE;
      }

   }else{
      if (FALSE == GetImageHlpDllInfo(pId, F_INSTALLING_IMAGEHLP_DLL )){
            Idwlog(TEXT("GetImageHlpDllInfo failed. Could not retrieved build, delta, location.\n"));
         return FALSE;
      }else{

         Idwlog(TEXT("Success in retrieving build, delta, location.\n"));
         return TRUE;
      }
   }
}



BOOL
GetBuildInfoFromOSAndBldFile( OUT  LPINSTALL_DATA pId,
                              IN   INT iFlag)
/*++

Routine Description:

   This loads the three items of
      DWORD dwInstallingBuild;
      DWORD dwInstallingBuildDelta;
      TCHAR szCurrentBuildSourceLocation[100];

   From information gleaned from the OS and the BLD file.

   *NOTE*
   This is assuming the changes of having the bld files on
   the CD in the same dir as the idwlog.exe and in the x86 share in on the server.


Arguments:
   These flags are.

   F_SYSTEM                  0x1
   F_INSTALLING              0x2

Return Value:

     TRUE  if success
     FALSE if fail

--*/

{

   WIN32_FIND_DATA fd;
   HANDLE   hFind;
   TCHAR    szFullPath     [ MAX_PATH ];
   TCHAR    szCurDir       [ MAX_PATH ];
   LPTSTR   ptstr;

   OSVERSIONINFO osex;
   DWORD   dwLength = MAX_PATH;
   DWORD   dwBuild;
   DWORD   dwBuildDelta;
   TCHAR   szDontCare[30];
   DWORD   dwDontCare;

   szCurDir[0] = TEXT('\0');

   switch (iFlag){
   case F_INSTALLING:
      // Get the installing files location of the 2195.0XX.bld file
      GetModuleFileName( NULL,szCurDir, dwLength);
      // Remove the Idwlog.exe part and get only the directory structure.
      ptstr = _tcsrchr(szCurDir,TEXT('\\'));
      if (NULL == ptstr) {

         Idwlog(TEXT("ERROR GetBuildInfoFromOSAndBldFile could find the file to get bld info from.\n"));
         return FALSE;
      }
      *ptstr = TEXT('\0');

      Idwlog(TEXT("Getting Build, Delta, Build lab for the installing files.\n"));
      Idwlog(TEXT("Getting Installing file location as %s.\n"), szCurDir);


      // Use this to get the location
      // idwlog.exe -1  is run from. This tool
      // will always assume the 2195.xxx.bld is in its
      // current path or two up.
      _stprintf (szFullPath, TEXT("%s\\*.bld"),szCurDir);
      Idwlog(TEXT("First look for the XXXX.xxx.bld in [CD location] %s.\n"),
         szFullPath);

      // On a network share the 2195.xxx.bld is two up from where
      // idwlog.exe -1 is located.
      // On a CD its located in the same directory as where the
      // idwlog.exe -1 is located. We will look in both places.

      hFind = FindFirstFile (szFullPath, &fd);
      if (INVALID_HANDLE_VALUE == hFind){
         //
         // Now we know the file in not in the
         // immediate directory. Move up another 2 levels by
         // culling off two more directory.
         //
         for (INT i = 0; i < 2; i++) {
            ptstr = _tcsrchr(szCurDir,TEXT('\\'));
            if (NULL == ptstr) {
               Idwlog(TEXT("ERROR GetBuildInfoFromOSAndBldFile could not find the file to get bld info from.\n"));
               return FALSE;
            }
            *ptstr = TEXT('\0');
         }

         _stprintf (szFullPath, TEXT("%s\\*.bld"),szCurDir);
         Idwlog(TEXT("Second look for the XXXX.xxx.bld in [NET location] %s.\n"),
                szFullPath);

         hFind = FindFirstFile (szFullPath,&fd);
         if (INVALID_HANDLE_VALUE == hFind){
            // In case we cannot find it we will exit.
            // Set the currentBuild number to 0;
            //_tcscpy (id.szCurrentBuild, TEXT("latest"));
            Idwlog(TEXT("Could not find the XXXX.xxx.bld file in %s.\n"),
                   szFullPath);
            Idwlog(TEXT("ERROR - Cannot get build number or delta of the installing build.\n"));
            return FALSE;
         }

      }
      _stscanf(fd.cFileName,TEXT("%lu.%lu.%s"),&dwBuild, &dwBuildDelta,szDontCare);

      Idwlog(TEXT("Inserting into struct Build, Delta, Build lab for the installing files.\n"));
      // Build Location
      _tcscpy( pId->szInstallingBuildSourceLocation,TEXT("No_Build_Lab_Information"));
      //  Major version X.51
      pId->dwInstallingMajorVersion = 0;
      //  Minor version 5.XX
      pId->dwInstallingMinorVersion = 0;
      //  Build
      pId->dwInstallingBuild        = dwBuild;
      //  Build Delta.
      pId->dwInstallingBuildDelta   = dwBuildDelta;
      pId->dwInstallingSPBuild      = dwBuildDelta;

      if ( pId->dwInstallingMajorVersion == 0 || pId->dwInstallingMinorVersion == 0 ) {

	Idwlog(TEXT("GetBuildInfoFromOSAndBldFile F_INSTALLING ERROR - need Major or Minor #\n"));

      }

      Idwlog(TEXT("GetBuildInfoFromOSAndBldFile F_INSTALLING - Build = %ld, Major = %ld, Minor = %ld.\n"),
			pId->dwInstallingBuild,
			pId->dwInstallingMajorVersion,
			pId->dwInstallingMinorVersion
			);

      break;

   case F_SYSTEM:
      osex.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
      GetVersionEx(&osex);

      // The output is like "RC 0.31"
      _stscanf(osex.szCSDVersion, TEXT("%s %lu.%lu"),
         szDontCare, &dwDontCare, &dwBuildDelta);

      // Get the local systems location of the imagehlp.dll
      Idwlog(TEXT("Inserting into struct Build, Delta, Build lab for the local system.\n"));
      // Build Location
      _tcscpy( pId->szSystemBuildSourceLocation,TEXT("No_Build_Lab_Information"));
      //  Major version X.51
      pId->dwSystemMajorVersion = 0;
      //  Minor version 5.XX
      pId->dwSystemMinorVersion = 0;
      //  Build
      pId->dwSystemBuild        = osex.dwBuildNumber;
      //  Build Delta.
      pId->dwSystemBuildDelta   = dwBuildDelta;
      pId->dwSystemSPBuild      = dwBuildDelta;

      Idwlog(TEXT("Getting Build, Delta, Build lab for local system.\n"));

      if ( pId->dwInstallingMajorVersion == 0 || pId->dwInstallingMinorVersion == 0 ) {

	Idwlog(TEXT("GetBuildInfoFromOSAndBldFile F_SYSTEM ERROR - need Major or Minor #\n"));

      }

      Idwlog(TEXT("GetBuildInfoFromOSAndBldFile F_SYSTEM - Build = %ld, Major = %ld, Minor = %ld.\n"),
			pId->dwInstallingBuild,
			pId->dwInstallingMajorVersion,
			pId->dwInstallingMinorVersion
			);


      break;
   }
   return TRUE;
}


BOOL
GetImageHlpDllInfo ( OUT  LPINSTALL_DATA pId,
                     IN   INT iFlag)
/*++

Routine Description:

   This loads the three items of
      DWORD dwInstallingBuild;
      DWORD dwInstallingBuildDelta;
      TCHAR szCurrentBuildSourceLocation[100];

   From information gleaned from the imagehlp.dll.

   *NOTE*
   The  ImageHlp.dll according to Micheal Lekas is compiled everytime a
   build is put out. We are banking on this for this function.


Arguments:
   An Install Data struct and the Imagehelp DLL location.
   It so it can be reused for both local probing and
   Installation probing.
   iFlag for System Probe or Installing Probe.
   Also if we want the data from imagehlp.dll or from the
   System. These flags are.

   F_SYSTEM_IMAGEHLP_DLL     0x1
   F_INSTALLING_IMAGEHLP_DLL 0x2

Return Value:

     TRUE  if success
     FALSE if fail

--*/

{

   VS_FIXEDFILEINFO* pv;

   WIN32_FIND_DATA fd;
   HANDLE   hFind;
   TCHAR    szFullPath     [ MAX_PATH ] = "\0";
   TCHAR    szCurDir       [ MAX_PATH ] = "\0";
   TCHAR    szBuildLocation[ MAX_PATH ] = "\0";
   TCHAR    szTempDir      [ MAX_PATH ] = "\0";
   TCHAR    szTempDirFile  [ MAX_PATH ] = "\0";

   DWORD    dwError = 0;

   LPTSTR   ptstr;
   DWORD   dwTemp;
   BOOL    b;
   LPVOID  lpData = NULL;
   LPVOID  lpInfo = NULL;
   TCHAR   key[80];
   DWORD  *pdwTranslation;
   UINT    cch, uLen;
   DWORD   dwDefLang = 0x40904b0;
   DWORD   dwLength = MAX_PATH;
   CHAR	  *p = NULL;
  
   DWORD	dwHandle;

   Idwlog ( TEXT ( "GetImageHlpDllInfo - entered.\n") );

   szCurDir[0] = TEXT('\0');



   // Configure the path to the where the image file lives.
   // This is different for the currently installed system vs. the installing build during -1.
   // However, for -3, it's a no-op, since we are installed and logged in.
   //

   // If we are in phase 3, we switch where the path points to.
   //




if ( g_InstallData.bSPUninst || g_InstallData.bSPPatch || g_InstallData.bSPFull || g_InstallData.bSPUpdate ) {

	// New code to work with SPs.
	//
   if (iFlag == F_INSTALLING_IMAGEHLP_DLL && (g_InstallData.iStageSequence == 3 || g_InstallData.iStageSequence == 2) ) {

	iFlag = F_SYSTEM_IMAGEHLP_DLL;
   }

   switch (iFlag){
   case F_INSTALLING_IMAGEHLP_DLL:

       // Get the image data for the build that we are installing.

	

 	p = _tcsstr (GetCommandLine(), TEXT("Path="));

   	if ( p == NULL ) {

      		Idwlog ( TEXT ( "GetImageHlpDllInfo ERROR - Could not determine path from command line, you need a Path=<path to the installing build> with trailing slash.\n") );
     
      		return(FALSE);

   	}

   	p += _tcsclen ( TEXT ("Path=" ) );

	//  We now have the location of the file to expand.
	//
	//_stprintf (szCurDir, TEXT("%s\\system32\\idwlog.exe"),p);

	_stprintf (szFullPath, TEXT("%s\\imagehlp.dll"),p);

/*****

	//  Get a temporary location to expand the file.
        //  Can use this if the file is compressed from the media.  This will NOT work on Win9x though (setupapi).
	//
	//
	dwError = GetTempPath ( MAX_PATH, szTempDir );	

	if ( dwError == 0 ) {

		Idwlog(TEXT("GetImageHlpDllInfo - ERROR GetTempPath gle = %ld.\n"), GetLastError () );
	}


	// Uncompress it, and point to that location.
	//

	_stprintf ( szTempDirFile, TEXT("%s\\ntoskrnl.exe"), szTempDir);

	dwError = SetupDecompressOrCopyFile ( szCurDir, szTempDirFile, NULL );

	if ( dwError != ERROR_SUCCESS ) {

		Idwlog(TEXT("GetImageHlpDllInfo - ERROR SetupDecompressOrCopyFile gle = %ld.\n"), GetLastError () );

	}	


	// Pass the location of the file.
        //
	 _stprintf (szFullPath, TEXT("%s\\ntoskrnl.exe"),szTempDir );


****/


	 Idwlog(TEXT("GetImageHlpDllInfo - szFullPath(1) = %s.\n"), szFullPath );



      break;

   case F_SYSTEM_IMAGEHLP_DLL:

      // Get the local systems location for the image file
      GetSystemDirectory( szCurDir, MAX_PATH );

       _stprintf (szFullPath, TEXT("%s\\imagehlp.dll"),szCurDir);
	 Idwlog(TEXT("GetImageHlpDllInfo - szFullPath(2) = %s.\n"), szFullPath );

      break;
   }

  





	// end of new code.
	//

}

else {

	// This is the old standard code.
	//

   if (iFlag == F_INSTALLING_IMAGEHLP_DLL && (g_InstallData.iStageSequence == 3 || g_InstallData.iStageSequence == 2)) {

	iFlag = F_SYSTEM_IMAGEHLP_DLL;
   }

   switch (iFlag){
   case F_INSTALLING_IMAGEHLP_DLL:

       // Get the image data for the build that we are installing.

	

 	p = _tcsstr (GetCommandLine(), TEXT("Path="));

   	if ( p == NULL ) {

      		Idwlog ( TEXT ( "GetImageHlpDllInfo ERROR - Could not determine path from command line, you need a Path=<path to the installing build> with trailing slash.\n") );
     
      		return(FALSE);

   	}

   	p += _tcsclen ( TEXT ("Path=" ) );

	_stprintf (szCurDir, TEXT("%s"),p);


  
      Idwlog(TEXT("GetImageHlpDllInfo - Getting Installing file location as %s.\n"), szCurDir);


      break;

   case F_SYSTEM_IMAGEHLP_DLL:

      // Get the local systems location for the image file
      GetSystemDirectory( szCurDir, MAX_PATH );

      Idwlog(TEXT("GetImageHlpDllInfo - Getting Build, Delta, Build lab for local system.\n"));

      break;
   }

   _stprintf (szFullPath, TEXT("%s\\imagehlp.dll"),szCurDir);
    Idwlog(TEXT("GetImageHlpDllInfo - szFullPath(3) = %s.\n"), szFullPath );

}


    
   Idwlog(TEXT("GetImageHlpDllInfo - Will look in [%s] for build information.\n"),szFullPath);

/*******
   // On a network share the Imagehlp.dll is one up from where
   // idwlog.exe -1 is located.
   // On a CD its located in the same directory as where the
   // idwlog.exe -1 is located. We will look in both places.

   hFind = FindFirstFile (szFullPath, &fd);
   if (INVALID_HANDLE_VALUE == hFind){
      //
      // Now we know the file in not in the
      // immediate directory. Move up one by
      // culling off one more directory.
      ptstr = _tcsrchr(szCurDir,TEXT('\\'));
      if (NULL == ptstr) {

         Idwlog(TEXT("GetBuildInfoFromOSAndBldFile could find the file to get bld info from.\n"));
         return FALSE;
      }
      *ptstr = TEXT('\0');

      _stprintf (szFullPath, TEXT("%s\\imagehlp.dll"),szCurDir);
      Idwlog(TEXT("First look for imagehlp.dll in %s.\n"),szFullPath);

      hFind = FindFirstFile (szFullPath,&fd);
      if (INVALID_HANDLE_VALUE == hFind){
         // In case we cannot find it we will exit.
         // Set the currentBuild number to 0;
         //_tcscpy (id.szCurrentBuild, TEXT("latest"));
         Idwlog(TEXT("Could not find the imagehlp.dll file in %s.\n"),szFullPath);
         Idwlog(TEXT("Cannot get build number of the installing build.\n"));
         return FALSE;
      }
   }
************/


	Idwlog ( TEXT ( ">>>>> MyGetFileVersionInfo path = %s\n"), szFullPath );

   	if (FALSE == MyGetFileVersionInfo(szFullPath,&lpData)){

      		if(lpData) {

         		free(lpData);
		}
      		Idwlog(TEXT("ERROR - GetFileVersionInfo failed to retrieve Version Info from: %s.\n"), szFullPath );
      		return FALSE;
   	}
   	else {

		Idwlog ( TEXT ( "MyGetFileVersionInfo call OK.\n") );
   	}

/*****

	Idwlog ( TEXT ( ">>>>> GetFileVersionInfoSize path = %s\n"), szFullPath );


	uLen = GetFileVersionInfoSize ( szFullPath, &dwHandle );

	if ( uLen == 0 ) {

		Idwlog ( TEXT ( "GetFileVersionInfoSize ERROR, gle = %ld\n"), GetLastError() );
		return FALSE;
	}
	else {
		Idwlog ( TEXT ( "GetFileVersionInfoSize call OK returned uLen = %ld.\n"), uLen );
	}
	

	b = GetFileVersionInfo ( szFullPath,
				 dwHandle,
				 uLen,
				 &lpData );

	if ( b == 0 ) {

		Idwlog ( TEXT ( "GetFileVersionInfo ERROR, gle = %ld\n"), GetLastError() );
		return FALSE;

	}
	else {
		Idwlog ( TEXT ( "GetFileVersionInfo call OK.\n") );	
	}

*****/
				 

   	b = VerQueryValue(lpData,
                   	TEXT("\\VarFileInfo\\Translation"),
                   	(LPVOID*)&pdwTranslation,
                   	&uLen);

   	if( b == 0 ){
      		Idwlog ( TEXT("VerQueryValue ERROR (name does not exist or the specified resource is not valid) \\VarFileInfo\\Translation, assuming default language as: %08lx\n"), dwDefLang);
      		pdwTranslation = &dwDefLang;
  	}
	else {
		Idwlog ( TEXT("VerQueryValue call OK. The specified version-information structure exists, and version information is available.\n" ));

		if ( uLen == 0 ) {

			Idwlog ( TEXT("However, no value is available...\n") );
		}
		else {
			Idwlog ( TEXT("A value is available, it's size is: %ld.\n"), uLen );
		}
	}

   	_stprintf(key, TEXT("\\StringFileInfo\\%04x%04x\\%s"),
                  LOWORD(*pdwTranslation),
                  HIWORD(*pdwTranslation),
                  TEXT("FileVersion"));


	Idwlog ( TEXT ( "Just before 2nd VerQueryValue -- key = >>>%s<<<  >>%x<<\n"), key, *pdwTranslation );

        
	b = VerQueryValue(lpData, key, &lpInfo, &cch);
	if( b ){


		
		Idwlog(TEXT("Retrieved string:  >>>%s<<<\n"), lpInfo );

      		// The output of this should be something like
      		// 5.0.2195. 30 (LAB01_N.000215-2216)
      		// we want the Lab part.
      		//
      		if (NULL == _tcsstr((LPTSTR)lpInfo,TEXT("(") )){
         		_stprintf(szBuildLocation,
                   		TEXT("%s"),
                   		TEXT("No_Build_Lab_Information"));

      		}else{
         		ptstr = _tcsstr((LPTSTR)lpInfo,TEXT("(") );
         		ptstr++;
         		_stprintf(szBuildLocation,TEXT("%s"),ptstr);
         		// remove the trailing ")"
			//
         		szBuildLocation[_tcslen(szBuildLocation) -1 ] = 0;
      		}

   	}else{

		DWORD i;
		TCHAR * p =  (TCHAR*)lpData;
		TCHAR szNewString[2048];
		DWORD dwAmount;
		DWORD dwR;

		Idwlog ( TEXT("VerQueryValue ERROR (name does not exist or the specified resource is not valid), gle = %ld\n"), GetLastError());

      		_stprintf(szBuildLocation,
                	TEXT("%s"),
                	TEXT("No_Build_Lab_Information"));
      		
		Idwlog(TEXT("Warning - Failed to get the build location in VerQueryValue.\n"));

		Idwlog(TEXT("Will manually try to find the data...\n"));


		// Let's try to find the data ourselves.  We *must* do this on Win9x since Win9x doesn't know what
		// to do with Unicode.
		//
		// We will be careful to stay away from end of the buffer.  This should be cleaned up where the 26 values are
		// with strlen.
		//
		for ( i = 0; i < (gdwLength - 26); i++, p++ ) {

			//Idwlog ( TEXT("i = %ld, p = %s\n"), i, p );

			//Idwlog ( TEXT ( "i = %ld, %x %c" ), i, *p, *p );

			if ( *p == 'F' && 
                             *(p+2) == 'i' && 
                             *(p+4) == 'l' &&
			     *(p+6) == 'e' &&
			     *(p+8) == 'V' &&
				*(p+10) == 'e' &&
				*(p+12) == 'r' &&
				*(p+14) == 's' 

						) {

				Idwlog(TEXT(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>We found FileVersion data by2...\n"));

				p += 26;  // to get past word "fileversion"
				break;
			}

/***
			if ( _tcsstr ( p, TEXT("FileVersion")) ){

				Idwlog(TEXT("We found FileVersion data...\n"));
				break;
			}
			//Idwlog ( TEXT ( "i = %ld, %x %c" ), i, *p, *p ); 

***/
		}

		Idwlog ( TEXT ( "p = %s\n"), p );
		Idwlog ( TEXT ( "%x %c" ), i, *p, *p );
		Idwlog ( TEXT ( "%x %c" ), i, *(p+1), *(p+1) );
		Idwlog ( TEXT ( "%x %c" ), i, *(p+2), *(p+2) );
		
		
		dwR = WideCharToMultiByte ( CP_ACP,
                            WC_NO_BEST_FIT_CHARS,
                            (const unsigned short *)p,
                            -1,
                            szNewString,
                            2048,
                            NULL,
                            NULL );
		if ( !dwR ) {
    			Idwlog ( TEXT("ERROR WideChartoMultiByte:  dwR = %ld, gle = %ld\n"), dwR, GetLastError () );
		}
		else {

			Idwlog ( TEXT("amount converted dwR = %ld, %s\n"), dwR, p = szNewString );
		}
		

		
		Idwlog(TEXT("Will print out data manually:  %s\n"), p );
		
		// The output of this should be something like
      		// 5.0.2195. 30 (LAB01_N.000215-2216)
      		// we want the Lab part.
      		//
      		if (NULL == _tcsstr((LPTSTR)p,TEXT("(") )){
         		_stprintf(szBuildLocation,
                   		TEXT("%s"),
                   		TEXT("No_Build_Lab_Information"));

			Idwlog ( TEXT ( "Build lab ERROR - we could not find the build # and lab, even manually.\n") );

      		}else{
         		ptstr = _tcsstr((LPTSTR)p,TEXT("(") );
         		ptstr++;
         		_stprintf(szBuildLocation,TEXT("%s"),ptstr);
         		// remove the trailing ")"
			//
         		szBuildLocation[_tcslen(szBuildLocation) -1 ] = 0;

			Idwlog ( TEXT ( "Build lab found:  %s.\n"), szBuildLocation );
      		}
		
   	}
/*********
   	if(VerQueryValue(lpData, key, &lpInfo, &cch)){


      // The output of this should be something like
      // 5.0.2195. 30 (LAB01_N.000215-2216)
      // we want the Lab part.
      //
      if (NULL == _tcsstr((LPTSTR)lpInfo,TEXT("(") )){
         _stprintf(szBuildLocation,
                   TEXT("%s"),
                   TEXT("No_Build_Lab_Information"));

      }else{
         ptstr = _tcsstr((LPTSTR)lpInfo,TEXT("(") );
         ptstr++;
         _stprintf(szBuildLocation,TEXT("%s"),ptstr);
         // remove the trailing ")"
         szBuildLocation[_tcslen(szBuildLocation) -1 ] = 0;
      }

   }else{

      _stprintf(szBuildLocation,
                TEXT("%s"),
                TEXT("No_Build_Lab_Information"));
      Idwlog(TEXT("ERROR - Failed to get the build location in VerQueryValue.\n"));
   }
**************/


   // This should retrieve the Major/Minor Version and build and build deltas
   //
   if (0 == VerQueryValue(lpData, "\\", (PVOID*) &pv, (UINT*) &dwTemp)) {

      // We have a problem.
      //_tcscpy (szBld, TEXT("latest"));
      //
      Idwlog(TEXT("ERROR VerQueryValue failed to retrieve Version Info from: %s\n"), szFullPath );
      if(lpData)
         free (lpData);
      return FALSE;
   }


   Idwlog(TEXT("GetImageHlpDllInfo - pv->dwSignature = %x\n"), pv->dwSignature );
   Idwlog(TEXT("GetImageHlpDllInfo - pv->dwFileVersionMS = %x\n"), pv->dwFileVersionMS );
   Idwlog(TEXT("GetImageHlpDllInfo - pv->dwFileVersionLS  = %x\n"), pv->dwFileVersionLS );

   // Cast the pvoid into the correct memory arrangement
   //
   switch (iFlag){

   case F_INSTALLING_IMAGEHLP_DLL:

      Idwlog(TEXT("GetImageHlpDllInfo F_INSTALLING_IMAGEHLP_DLL - Inserting into struct Build, Delta, Build lab for the installing files.\n"));

      // Build Location
      _tcscpy( pId->szInstallingBuildSourceLocation,szBuildLocation);
      //  Major version X.51
      pId->dwInstallingMajorVersion = HIWORD(pv->dwFileVersionMS);
      //  Minor version 5.XX
      pId->dwInstallingMinorVersion = LOWORD(pv->dwFileVersionMS);
      //  Build
      pId->dwInstallingBuild        = HIWORD(pv->dwFileVersionLS);
      //  Build Delta.
      pId->dwInstallingBuildDelta   = LOWORD(pv->dwFileVersionLS);
      pId->dwInstallingSPBuild      = LOWORD(pv->dwFileVersionLS);

      Idwlog(TEXT("GetImageHlpDllInfo F_INSTALLING_IMAGEHLP_DLL - Build = %ld, Major = %ld, Minor = %ld, Delta = %ld\n"),
			pId->dwInstallingBuild,
			pId->dwInstallingMajorVersion,
			pId->dwInstallingMinorVersion,
			pId->dwInstallingBuildDelta
			);


      break;

   case F_SYSTEM_IMAGEHLP_DLL:

      // Get the local systems location of the imagehlp.dll

      Idwlog(TEXT("GetImageHlpDllInfo F_SYSTEM_IMAGEHLP_DLL - Inserting into struct Build, Delta, Build lab for the local system.\n"));

      // Build Location
      _tcscpy( pId->szSystemBuildSourceLocation,szBuildLocation);
      //  Major version X.51
      pId->dwSystemMajorVersion = HIWORD(pv->dwFileVersionMS);
      //  Minor version 5.XX
      pId->dwSystemMinorVersion = LOWORD(pv->dwFileVersionMS);
      //  Build
      pId->dwSystemBuild        = HIWORD(pv->dwFileVersionLS);
      //  Build Delta.
      pId->dwSystemBuildDelta   = LOWORD(pv->dwFileVersionLS);
      pId->dwSystemSPBuild      = LOWORD(pv->dwFileVersionLS);


	Idwlog(TEXT("GetImageHlpDllInfo F_SYSTEM_IMAGEHLP_DLL - Build = %ld, Major = %ld, Minor = %ld, Delta = %ld\n"),
			pId->dwSystemBuild,
			pId->dwSystemMajorVersion,
			pId->dwSystemMinorVersion,
			pId->dwSystemBuildDelta
			);


      break;
   }

   // The MyGetFileVersion allocates its own memory.
   if(lpData)
      free (lpData);

   return TRUE;
}




typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

/*
 Used from Filever.c wallyho. For some reason regular calls fail easier to just reuse this code
 *  [alanau]
 *
 *  MyGetFileVersionInfo: Maps a file directly without using LoadLibrary.  This ensures
 *   that the right version of the file is examined without regard to where the loaded image
 *   is.  Since this is a local function, it allocates the memory which is freed by the caller.
 *   This makes it slightly more efficient than a GetFileVersionInfoSize/GetFileVersionInfo pair.
 */
BOOL
MyGetFileVersionInfo(LPTSTR lpszFilename, LPVOID *lpVersionInfo)
{
    VS_FIXEDFILEINFO  *pvsFFI = NULL;
    UINT              uiBytes = 0;
    HINSTANCE         hinst;
    HRSRC             hVerRes;
    HANDLE            FileHandle = NULL;
    HANDLE            MappingHandle = NULL;
    LPVOID            DllBase = NULL;
    VERHEAD           *pVerHead;
    BOOL              bResult = FALSE;
    DWORD             dwHandle;
    DWORD             dwLength;

    Idwlog ( TEXT ( "Entering MyGetFileVersionInfo.\n") );

    if (!lpVersionInfo) {

	Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR lpVersionInfo not.\n") );
        return FALSE;
    }

    *lpVersionInfo = NULL;

    FileHandle = CreateFile( lpszFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL
                            );
    if (FileHandle == INVALID_HANDLE_VALUE) {

	Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR INVALID_HANDLE.\n") );
        goto Cleanup;
    }

    MappingHandle = CreateFileMapping( FileHandle,
                                        NULL,
                                        PAGE_READONLY,
                                        0,
                                        0,
                                        NULL
                                      );

    if (MappingHandle == NULL) {

	Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR MappingHandle == NULL.\n") );
        goto Cleanup;
    }

    DllBase = MapViewOfFileEx( MappingHandle,
                               FILE_MAP_READ,
                               0,
                               0,
                               0,
                               NULL
                             );
    if (DllBase == NULL) {

	Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR DllBase == NULL.\n") );
        goto Cleanup;
    }

    hinst = (HMODULE)((ULONG_PTR)DllBase | 0x00000001);

    __try {

        hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
        if (hVerRes == NULL)
        {
            // Probably a 16-bit file.  Fall back to system APIs.
            if(!(dwLength = GetFileVersionInfoSize(lpszFilename, &dwHandle)))
            {
                if(!GetLastError()) {
		    Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR resource not found.\n") );
                    SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
	        }
                __leave;
            }

            if(!(*lpVersionInfo = malloc( dwLength) ) ) {

		Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR could not malloc.\n") );
                __leave;
            }
	    else {
		Idwlog ( TEXT ( "MyGetFileVersionInfo:  malloc size was: %ld.\n"), gdwLength = dwLength );
	    }

            if(!GetFileVersionInfo(lpszFilename, 0, dwLength, *lpVersionInfo)) {

		Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR GetFileVersionInfo failed.\n") );
                __leave;
            }

            bResult = TRUE;
	    Idwlog ( TEXT ( "MyGetFileVersionInfo:  result is true.\n") );
            __leave;
        }

        pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
        if (pVerHead == NULL) {

	    Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR pVerHead == NULL.\n") );
            __leave;
        }

        *lpVersionInfo = malloc(pVerHead->wTotLen + pVerHead->wTotLen/2);
        if (*lpVersionInfo == NULL) {

	    Idwlog ( TEXT ( "MyGetFileVersionInfo:  ERROR *lpVersionInfo == NULL.\n") );
            __leave;
        }

        memcpy(*lpVersionInfo, (PVOID)pVerHead, gdwLength = pVerHead->wTotLen);
        bResult = TRUE;

        Idwlog ( TEXT ( "MyGetFileVersionInfo:  bResult == TRUE.\n") );

    } __except (EXCEPTION_EXECUTE_HANDLER) {

       Idwlog(TEXT("MyGetFileVersionIfno ERROR - Memory problems failed to retrieve version Info from image file of the installing build.\n"));
    }

Cleanup:
    if (FileHandle)
        CloseHandle(FileHandle);
    if (MappingHandle)
        CloseHandle(MappingHandle);
    if (DllBase)
        UnmapViewOfFile(DllBase);

    if (*lpVersionInfo && bResult == FALSE)
        free(*lpVersionInfo);

    Idwlog ( TEXT ( "Exiting MyGetFileVersionInfo:  bResult = %ld.\n"), bResult );
    return bResult;
}


BOOL
GetSkuFromDosNetInf (IN OUT LPINSTALL_DATA pId)
/*++

Routine Description:

   This will retrieve the values from Miscellaneous that tell us
   if the build is a personal, enterprise, etc...

   This will then load the value into the pId field of dwSku.


Arguments:
   A install_data struct which contains all the recording variables necessary.

Return Value:

     TRUE  if success
     FALSE if fail

--*/
{

   WIN32_FIND_DATA fd;
   HANDLE   hFind;
   TCHAR    szFullPath     [ MAX_PATH ];
   TCHAR    szCurDir       [ MAX_PATH ];//
   LPTSTR   ptstr;

//   OSVERSIONINFO osex;
   DWORD   dwLength = MAX_PATH;
//   DWORD   dwBuild;
//   DWORD   dwBuildDelta;
   TCHAR   szSku[5] = "ERR";
  // DWORD   dwDontCare;
   TCHAR * p = NULL;
   TCHAR  szTmp[MAX_PATH];

   ptstr = szTmp;

   // Get the installing files location of the dosnet.inf file

/****
   szCurDir[0] = TEXT('\0');
   GetModuleFileName( NULL,szCurDir, dwLength);
   // Remove the Idwlog.exe part and get only the directory structure.
   ptstr = szCurDir + _tcsclen(szCurDir);
   while (*ptstr-- != TEXT('\\'));
   ptstr++;
   *ptstr = TEXT('\0');
   Idwlog(TEXT("Getting DosNet.inf file location as %s.\n"), szCurDir);
****/

   p = _tcsstr (GetCommandLine(), TEXT("Path="));

   if ( p == NULL ) {

      Idwlog ( TEXT ( "GetSkuFromDosNetInf ERROR - Could not determine path from command line, you need a Path=<path to the installing build> with trailing slash.\n") );
      pId->dwSku = 666;
      return(FALSE);

   }

   p += _tcsclen ( TEXT ("Path=" ) );

   Idwlog(TEXT("Source path = %s\n"), p );


   // Use this to get the location
   // idwlog.exe -1  is run from. This tool
   // will always assume the dosnet.inf is in its
   // current path or two up.

   _stprintf (szFullPath, TEXT("%s\\dosnet.inf"),p);

   Idwlog(TEXT("Will attempt to open to get ProductType in szFullPath = %s.\n"), szFullPath);



   GetPrivateProfileString(TEXT("Miscellaneous"),
                           TEXT("ProductType"),
                           TEXT("0"),
                           szSku,
                           sizeof(szSku)/sizeof(TCHAR),
                           szFullPath);


   // 	Check to see if there was an error in the above call getting the value.
   //	If so, default to Professional for the value, but return.
   //
   if ( _tcsstr (szSku, TEXT("ERR")) ) {

      pId->dwSku = 0;
      Idwlog ( TEXT ( "ERROR - GetSkuFromDosNetInf GetPrivateProfileString FAILed. Will return pid->dwSku = %d\n"), pId->dwSku );
      return(FALSE);

   }

   /*
      case 0: // Professional
      case 1: // Server
      case 2: // Advanced Server
      case 3: // DataCenter
      case 4: // Personal
      case 5: // Blade Server
      case 6: // Small Business Server
      default: // Professional
    */

   *ptstr = TEXT('\0');
    pId->dwSku = _tcstoul(szSku, &ptstr, 10);



   if(pId->dwSku > 6){
      // default to Professional
      Idwlog ( TEXT ( "ERROR - found an unknown ProductType in dosnet.inf pid->dwSku = %d\n"), pId->dwSku );
      pId->dwSku = 0;
      return(FALSE);
   }

   Idwlog ( TEXT ( "We found the following product type: %d\n"), pId->dwSku );

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\idwlog.cpp ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>

// for the SH...
#include <shlwapi.h>
#include <shlobj.h>


#include "network.h"
#include "idw_dbg.h"
#include "service.h"
#include "machines.h"
#include "server.h"
#include "files.h"
#include "idwlog.h"

/*++

   Filename :  idwlog.cpp

   Description: Main for idwlog.cpp
   
   Created by:  Wally Ho

   History:     Created on 31/01/2000.
                Made the machineID only 9 chars long 18/08/2000

   Contains these functions:


	03.29.2001	Joe Holman	Made the code work on Win9x.
	09.19.2001	Joe Holman	fixes for idwlog bugs 409338, 399178, and 352810
	09.20.2001	Joe Holman	Added code to copy machine's setuperr.log to a server location for analysis.


--*/

// Global data
INSTALL_DATA   g_InstallData;
TCHAR          g_szServerData[4096];



INT WINAPI 
WinMain (HINSTANCE hInstance,
         HINSTANCE hPrev,
         LPSTR     lpCmdLine,
         INT       nCmdShow)
{

   BOOL            b;
   MACHINE_DETAILS md;

   INSTALL_DATA d;

   GetBuildInfoFromOSAndBldFile(&d,1);
   __try{

      // By doing this everything boolean is set to FALSE
      ZeroMemory((LPINSTALL_DATA) &g_InstallData,sizeof(INSTALL_DATA));
      ZeroMemory((LPMACHINE_DETAILS) &md,sizeof(md));

      // Set the error codes so that nothing will show up
      // if this fails.
      SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

      //Setup up a command parser.
      // by using else if statements we are assured of only the first one 
      // being executed and no further code check initiated.

      //____<installing service>_____________________________________________________
      if (FALSE != _tcsstr(GetCommandLine(), TEXT("-install")  )) {

         RemoveIdwlogDebugFile(WRITE_SERVICE_DBG);
         OpenIdwlogDebugFile(WRITE_SERVICE_DBG);


         // if -install specified then we'll register the service.
         TCHAR szServiceExe[ MAX_PATH ];
         GetModuleFileName(NULL, szServiceExe, MAX_PATH);         

         /*
         LPTSTR p;
         p = _tcsrchr(szServiceExe,TEXT('\\'));
         if (NULL == p) {
           return FALSE;
         }
         *p = TEXT('\0');
         _tcscat( szServiceExe, TEXT("\\s.exe"));
         */

         InstallService(SCM_SERVICE_NAME , SCM_DISPLAY_NAME, szServiceExe);
         CloseIdwlogDebugFile();
      }

      //____<removing service>_______________________________________________________
      else if (FALSE !=_tcsstr(GetCommandLine(), TEXT("-remove")  )) {

         OpenIdwlogDebugFile(WRITE_SERVICE_DBG);
         // if -remove specified then we'll flag it for removal.
         RemoveService( SCM_SERVICE_NAME );

         CloseIdwlogDebugFile();
      }

      //____<Idwlog -1 or 2 >_____________________________________________________________
      else if (FALSE != _tcsstr(GetCommandLine(), TEXT("-1")) ||
               FALSE != _tcsstr(GetCommandLine(), TEXT("-0")) ) {

         g_InstallData.bCancel = ( _tcsstr (GetCommandLine(), TEXT("-0")) ?  TRUE : FALSE );

         // Setting Instance Mutex.
         b =  SetInstanceMutex();
         if (TRUE == b && g_InstallData.bCancel == FALSE) {
            //already exists exit.
            return FALSE;
         }

         g_InstallData.bFindBLDFile = TRUE;
         if (FALSE == g_InstallData.bCancel) {

            RemoveIdwlogDebugFile(WRITE_NORMAL_DBG);
            OpenIdwlogDebugFile(WRITE_NORMAL_DBG);
            Idwlog(TEXT("STARTED -- [IDWLOG: Stage1 - Initial Install]\n")); 

            // Initially clean out the link.
            // We should delete the shortcut to idwlog from startup group.
            RemoveStartupLink(IDWLOG_LINK_SHORTCUT);

            // This is to prevent multiple 1 files going through if the user backs up
            // and goes again fo whatever reasons.

            LPINSTALL_DATA pid = (LPINSTALL_DATA)malloc(sizeof(INSTALL_DATA));
            if ( NULL == pid ) {
               Idwlog(TEXT("Failed to allocate memory. Exiting.\n")); 
               return FALSE;
            }
            b = ReadIdwlogCookie (pid);
            pid->iStageSequence = 1;
            if (TRUE == b) {
               DeleteDatafile (pid);
               DeleteCookieFile();
               Idwlog(TEXT("Dash 1 repeated. Clean 1 file from server and/ or put 0 file on it.\n")); 
               Idwlog(TEXT("Dash 1 repeated. Server file: %s \n"), pid->szIdwlogServer); 
            } else {
               Idwlog(TEXT("No old cookie file. Fresh dash 1.\n")); 
            }
            free (pid);


            g_InstallData.iStageSequence = 1;
            // If this returned false its because the /? case was executed.
            if (FALSE == IdwlogClient(&g_InstallData, &md)) {
               // Check if we don't fild a BLD file we write a cookie anyway
               // Why? So that in part 2 if we don't find a cookie we assume
               // a CD BOOT install took place and Part 1 never ran.
               if (FALSE == g_InstallData.bFindBLDFile) {
                  WriteIdwlogCookie( &g_InstallData );
               }
               // Close the debug file.
               CloseIdwlogDebugFile();
               ClearInstanceMutex();
               return FALSE;
            }


            //Set a mutex for cancel by same process.
            SetCancelMutex ();

            // Write out the idwlog cookie file.
            // We will specify a nonexistent server so we can get the cookie right away.
            // Then if if all goes well we'll write the correct one.
            // If not then the service and -3 will do a server probe.
            //
            _tcscpy(g_InstallData.szIdwlogServer, TEXT("\\\\Bogus\\Bogus"));
            WriteIdwlogCookie(&g_InstallData);

            // This forces a server probe immediately.
            g_InstallData.szIdwlogServer[0] = TEXT('\0');         

            // Create the idwlog.cookie file.
            // At this point, the id struct should be full of necessary data.
            // Write the client 1 file.
            // At this point, we have a NULL szIdwlogServer. This will make it search.

            ServerWriteMaximum (&g_InstallData, &md);

            // Write out the idwlog cookie file.
            // This must be called after ServerWriteMaximum as it
            // loads the server the file eventually gets to.
            WriteIdwlogCookie(&g_InstallData);

            ClearCancelMutex();
            Idwlog(TEXT("ENDED ---- [IDWLOG: Stage1 - Initial Install]\n")); 
            // Close the debug file.
            CloseIdwlogDebugFile();
            ClearInstanceMutex();

            // Here is where we can consider launching other test processes when someone call's winnt32.exe.
            //
            // newjoe.
            //		We will grab the Server data file with the list of programs to launch.
            //		We will not return until each is performed.
	    //		However, we need to add code to winnt32.exe wizard.c that will:
            //			- keep the idwlog -1 process id
            //			- kill this process if it timesout -- see the sysparse code.
            //			- we need to pass down if upgrade, cdrom, net, msi, etc. appropriately.
	    //
	    //		Need routine to insert program's paths to call on the logon side of things into the registry.
	    //
	    //	Requirments of test application:  no UI, windows app.
	    //	

/*
in winnt32.exe's wizard.c, just before calling the idwlog -0, if the process of idwlog -1 still exists, timeout on it similar to as we do with the sysparse item.

in winnt32.c, we need to do the same as all the code surrounding the SysParseDlgProc for when we are shutting down the system.
we will need to force any test program down.
*/

	    // end of newjoe.	

         }	
         else {

	    // This is for the cancel case.
	    // That is where winnt32.exe's wizard is in it's cancel code, so we want to 
	    // cancel out also.
	    //

            // if return == false then write idwlogcookie has already happened
            if (FALSE == PauseForMutex()) {
               g_InstallData.iStageSequence = 1;
               OpenIdwlogDebugFile(WRITE_NORMAL_DBG);
               Idwlog(TEXT("STARTED -- [IDWLOG: Stage1 - CANCEL utilized]\n")); 

               b = ReadIdwlogCookie (&g_InstallData);
               if (TRUE == b) {
                  // Delete for the new behaviour
                  DeleteDatafile (&g_InstallData);

                  DeleteCookieFile();
                  Idwlog(TEXT("Successfully canceled and propagated server delete file. Cookie deleted.\n")); 
                  Idwlog(TEXT("Server file: %s \n"), g_InstallData.szIdwlogServer); 
               } else {
                  Idwlog(TEXT("Canceled failed to delete server file. Cookie could not be read.\n")); 
               }
            }
            Idwlog(TEXT("ENDED ---- [IDWLOG: Stage1 - CANCEL utilized]\n")); 
            // Close the debug file.
            CloseIdwlogDebugFile();
            ClearInstanceMutex();
         }
      }

      //____<Idwlog -3 >_____________________________________________________________
      else if (FALSE != _tcsstr(GetCommandLine(), TEXT("-3"))) {

         INSTALL_DATA 	id3;
         BOOL         	bSafeBuild = FALSE;
//	 HINF		hinfLang = NULL;
//	 LANGID		langidValue = 0;
	 TCHAR		szFileName[MAX_PATH];
	 TCHAR 		szWindowsDirectory[MAX_PATH];
	 TCHAR		szOEMFileToDelete[MAX_PATH];		// this is our special file to denote an OEM image, we need to delete it
	 UINT  		ui;
	 TCHAR		szBuf[MAX_PATH];

         ZeroMemory((LPINSTALL_DATA) &id3, sizeof(id3));

         // if -3 specified then we know its at stage 3.
         //First set the Write to know this is a *.3 file.

         g_InstallData.iStageSequence = 3;
         OpenIdwlogDebugFile(WRITE_NORMAL_DBG);
         Idwlog(TEXT("STARTED -- [IDWLOG: Stage3 - Final Logon]\n")); 
         IdwlogClient(&g_InstallData,&md);


	 // We want to track what language'd builds are being installed.
	 // Although the above IdwlogClient call provides the locale information that was selected,
	 // we are going to override that information for now.  At some time, we likely will want to 
 	 // make the structure contain both locale and language SKU, but perhaps not, when we have "one" language shipping.
	 //

	ui = GetWindowsDirectory ( szWindowsDirectory, MAX_PATH );

	if ( ui == 0 ) {

        	Idwlog ( TEXT("build language - ERROR - GetWindowsDirectory gle = %ld\n"), GetLastError());
        
		// leave locale data in.
	}
	else {


		long l = 666;

		
		// Change locale data to system build language.
		//
	

		

		_stprintf(szFileName, TEXT("%s\\inf\\intl.inf"), szWindowsDirectory );

		Idwlog ( TEXT("szFileName = %s\n"), szFileName );

	 	GetPrivateProfileString (	TEXT("DefaultValues"),
						TEXT("Locale"),
						TEXT("ERROR"),
						szBuf,
						MAX_PATH,
						szFileName );


		Idwlog ( TEXT("szBuf = %s\n"), szBuf );

		l = _tcstol ( szBuf, NULL, 16 );

		if ( l == 0 ) {

			Idwlog ( TEXT("ERROR - Buffer translated = %x(hex) %d(dec)\n"), l, l );
		}
				
		Idwlog ( TEXT("Buffer translated = %x(hex) %d(dec)\n"), l, l );

		 

		if ( FALSE == GetLocaleInfo( l, LOCALE_SABBREVLANGNAME, g_InstallData.szLocaleId, sizeof( g_InstallData.szLocaleId ))) {

			Idwlog(TEXT("ERROR GetLocaleInfo:  gle = %ld\n"), GetLastError() );
		}

		else {

			Idwlog(TEXT("Got the abbreviation:  %s\n"), g_InstallData.szLocaleId );
		}
      			




		Idwlog(TEXT("g_InstallData.szLocaleId = %s\n"), &g_InstallData.szLocaleId );

		
	}

	 
         // The below will overwrite fields that are filled in as wrong 
         // from the above call.
	 //
         g_InstallData.bFindBLDFile = TRUE;
         b = ReadIdwlogCookie (&g_InstallData);


         if (TRUE == b && TRUE == g_InstallData.bFindBLDFile) {

            Idwlog(TEXT("Server from cookie is %s.\n"), g_InstallData.szIdwlogServer); 


            /*
               "If the current build number is less than the build number in the file,
               chances are the last setup attempt failed and this current build
               is the "safe" build. So do nothing. We get burned if the build lab
               doesn't put the right version on the builds. --Dshiflet" 
               This fact is impossible with my imagehlp.dll version probe. 
               It's always updated. Wallyho.
            */

            /*****************************************************************************************************************
                         if (DTC == FALSE) {
                            GetCurrentSystemBuildInfo(&id3);
                            // This case if safebuild it running
                            if (id3.dwSystemBuild < g_InstallData.dwSystemBuild)
                               bSafeBuild = TRUE;
                            else
                               bSafeBuild = FALSE;
            
                            // This case is same build but different deltas
                            if (id3.dwSystemBuild == g_InstallData.dwSystemBuild &&
                                id3.dwSystemBuildDelta    < g_InstallData.dwSystemBuildDelta)
                               bSafeBuild = TRUE;
                            else
                               bSafeBuild = FALSE;
            
                            if (TRUE == bSafeBuild) {
                               Idwlog(TEXT("The Current build or delta on the machine is less than the installed build.\n"));
                               Idwlog(TEXT("Most likely the last attempt failed. So we are in a safe build.\n"));
                               // What do do in this case? Wally ho
                               // I think we'll write nothing as this is a fail.
                               // Commented out for now as testing will fail this.
            
                               //Remove the CookieFile.
                               DeleteCookieFile();
			       
                               Idwlog(TEXT("ENDED ---- [IDWLOG -3]\n"));
                               CloseIdwlogDebugFile();
                               return FALSE;
                            }
                         }
            *****************************************************************************************************************/

            // If this returns fail we leave the link
            // and the file intact upon next boot.
            if (FALSE == ServerWriteMaximum (&g_InstallData, &md)) {

	       // Copy the machine's Setup error log file to our Server to analyze.
	       //
	       CopySetupErrorLog (&g_InstallData);


		

               Idwlog(TEXT("ENDED ---- [IDWLOG: Stage3 - Final Logon]\n")); 
               CloseIdwlogDebugFile();
               return FALSE;
            }


         } else {
            //If we are here we have read the cookie and 
            // found that NO_BUILD_DATA was in the cookie.
            // Which means part one didn't find a bld file.
            // and the cookie is empty.
            // What we do now is make an assumption. This being
            // That the system build is the current build that
            // we either couldn't get to begin with or that 
            // a CD BOOT happened. Both cases we distinguish.
            // We get the current system information and then 
            // send it as the installing build.
            // of course we blank out the data for everything else.
            GetCurrentSystemBuildInfo(&id3);

            g_InstallData.dwSystemBuild      = 0;
            g_InstallData.dwSystemBuildDelta = 0;
   	    g_InstallData.dwSystemSPBuild    = 0;
            _tcscpy(g_InstallData.szInstallingBuildSourceLocation, TEXT("No_Build_Lab_Information"));

            g_InstallData.dwInstallingBuild      = id3.dwSystemBuild ;
            g_InstallData.dwInstallingBuildDelta = id3.dwSystemBuildDelta;
            g_InstallData.dwInstallingSPBuild    = id3.dwSystemBuildDelta;

            _tcscpy(g_InstallData.szInstallingBuildSourceLocation, id3.szSystemBuildSourceLocation);
            g_InstallData.bFindBLDFile = g_InstallData.bFindBLDFile;


            if (FALSE == g_InstallData.bFindBLDFile) {

               g_InstallData.bCDBootInstall = FALSE;
               // If there was no build file found.
               Idwlog(TEXT("There was no build file in stage 1; logging as such.\n"));             
               //Remove the CookieFile.
               DeleteCookieFile();

	       // Copy the machine's Setup error log file to our Server to analyze.
	       //
	       CopySetupErrorLog (&g_InstallData);

	       Idwlog(TEXT("ENDED ---- [IDWLOG: Stage3 - Final Logon]\n")); 
               CloseIdwlogDebugFile();
               return FALSE;

            } else {
               // We will probe the machine as it is now to get a build number
               // then we will send a minimal server file over to the server.
               // This will have a build number machine id name of computer
               // on the file name. But will have a delta inside.

               g_InstallData.bCDBootInstall = TRUE;
               Idwlog(TEXT("This is a CD Boot Install logging as such.\n")); 

               // This forces a server probe immediately.
               g_InstallData.szIdwlogServer[0] = TEXT('\0');         
               if (FALSE == ServerWriteMinimum (&g_InstallData, &md)) {

		  // Copy the machine's Setup error log file to our Server to analyze.
	 	  //
	 	  CopySetupErrorLog (&g_InstallData);

		  

                  Idwlog(TEXT("ENDED ---- [IDWLOG: Stage3 - Final Logon]\n")); 
                  CloseIdwlogDebugFile();
                  return FALSE;
               }
            }


            //         Idwlog(TEXT("Failed to read cookie. Writing minimal success file to server.\n"));
            //         Idwlog(TEXT("This will correct CD installs that don't generate a *.1.\n"));
         }

         //Clean up.
         // We should delete the shortcut to idwlog from startup group.
         RemoveStartupLink(IDWLOG_LINK_SHORTCUT);

         // If this is idwlog.exe, delete the program.
         //  We only need to write once.
         /*
         GetModuleFileName (NULL, szExePath, MAX_PATH);
         if (_tcsstr(CharLower(szExePath), TEXT("idwlog.exe")))
            MoveFileEx (szExePath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
         */
         //Remove the CookieFile.
         DeleteCookieFile();

	 // Copy the machine's Setup error log file to our Server to analyze.
	 //
	 CopySetupErrorLog (&g_InstallData);

	 
         Idwlog(TEXT("ENDED ---- [IDWLOG: Stage3 - Final Logon]\n")); 
         CloseIdwlogDebugFile();
      }

      else {

         //____<running service>_____________________________________________________

         // default is to start as a service.
         SERVICE_TABLE_ENTRY st[] ={
            { SCM_DISPLAY_NAME , (LPSERVICE_MAIN_FUNCTION)ServiceMain},
            { NULL, NULL}
         };

         Idwlog(TEXT("Start the StartServiceCtrlDispatcher %lu.\n"),GetLastError());

         b = StartServiceCtrlDispatcher(st);
      }


   }__except (EXCEPTION_EXECUTE_HANDLER) {
      // This is here as for some reason this faults in NT 4.0.
      Idwlog(TEXT("Unhandled Exception Fault. Exiting.. EC %lu!\n"), GetLastError());
      CloseIdwlogDebugFile();
   }
   return FALSE;
}



DWORD	GetSkuFromSystem ( VOID ) {


 	OSVERSIONINFOEX osv;
	BOOL	b;


  /*
     case 0: // Professional
     case 1: // Server
     case 2: // Advanced Server
     case 3: // DataCenter
     case 4: // Home Edition
     case 5: // Blade Server
     case 6: // Small Business Server
  */


    //  We call this routine only in the -3 phase so we are logging on on XP+ builds.  Thus,
    //  we can call the EX version of this routine.
    //
    osv.dwOSVersionInfoSize = sizeof ( OSVERSIONINFOEX );
    b = GetVersionEx ( (OSVERSIONINFO * ) &osv );

    if ( !b ) {

	Idwlog(TEXT("ERROR GetSkuFromSystem - GetVersionEx rc = %ld\n"), GetLastError());

        return 666;
    }

   
    //  OK.  We have these products we need to look for:
    //
    //          Home Edition (NT 5.1 and greater).
    //          DataCenter
    //          Enterprise
    //          Server
    //          Professional 
    //          
    //
    //  
    //  We'll start from the top here, because some are based upon Suite masks, not product type, as some are.
    //



    if ( osv.wSuiteMask & VER_SUITE_SMALLBUSINESS ) {

	Idwlog(TEXT("GetSkuFromSystem - System is SBS\n"));
	return 6;
      	
    }

    if ( osv.wSuiteMask & VER_SUITE_BLADE ) {

	Idwlog(TEXT("GetSkuFromSystem - System is BLADE\n"));
	return 5;
      	
    }

    if ( osv.wSuiteMask & VER_SUITE_PERSONAL ) {

	Idwlog(TEXT("GetSkuFromSystem - System is HOME EDITION\n"));
	return 4;
      	
    }

    if ( osv.wSuiteMask & VER_SUITE_DATACENTER ) {

	Idwlog(TEXT("GetSkuFromSystem - System is DATACENTER\n"));
	return 3;     

    }

    if ( osv.wSuiteMask & VER_SUITE_ENTERPRISE ) {

	Idwlog(TEXT("GetSkuFromSystem - System is ENTERPRISE\n"));
	return 2;

    }

    //  Note:  don't have to use VER_NT_SERVER, because this value is
    //          a combination of bit 1 and bit 0 (workstation).  We are
    //          just interested in the the "server" part.
    //
    if ( osv.wProductType & VER_NT_DOMAIN_CONTROLLER ) {

	Idwlog(TEXT("GetSkuFromSystem - System is SERVER\n"));
	return 1;
       
    }

    if ( osv.wProductType & VER_NT_WORKSTATION ) {

	Idwlog(TEXT("GetSkuFromSystem - System is PROFESSIONAL\n"));
	return 0;

    }


	Idwlog(TEXT("ERROR GetSkuFromSystem - We didn't find the system type (%x,%x)\n"), osv.wSuiteMask, osv.wProductType);

	return 666;

}



BOOL
IdwlogClient( LPINSTALL_DATA    pId,
              LPMACHINE_DETAILS pMd)
/*++

Author: Wallyho.
    
Routine Description:
   This load system information into the structures for the 
   Install Data and the Machine Details.

Arguments:

   Two pointer to two created structures.
 
Return Value:

   TRUE for success.
   FALSE for failure.

--*/
{

   OSVERSIONINFO osVer;
   DWORD dwComputerNameLen;
   SYSTEM_INFO    SysInfo ;
   MEMORYSTATUS   msRAM;
   TCHAR          szHelpMessage[MAX_PATH];



   Idwlog(TEXT("IdwLogClient - entered.\n") );


   // if -1 specified then we'll use Part 1.
   // Spray up a simple help screen for /?
   if ( FALSE != _tcsstr(GetCommandLine(), TEXT("/?")) ||
        FALSE != _tcsstr(GetCommandLine(), TEXT("-?"))    ) {
      Idwlog(TEXT("STARTED -- [IDWLOG: Stage1 - HELP called]\n")); 

      _stprintf(szHelpMessage,
                TEXT("idwlog -1 upgrade cancel cdrom MSI sp_remove sp_patch sp_update sp_full oemimage\0") );

      _stprintf (szHelpMessage+_tcsclen(szHelpMessage),
                 TEXT("idwlog -3 \0") );

      MessageBox(NULL,szHelpMessage,
                 TEXT("Help Parameters"),MB_ICONQUESTION | MB_OK);

      Idwlog(TEXT("ENDED ---- [IDWLOG: Stage1 - HELP called]\n")); 
      return FALSE;
   }


   // Load the command line booleans for the below items.
   // We need these here because the image loading for build #s is depenedent upon it for SPs.
   //

   pId->bSPUninst= ( _tcsstr (GetCommandLine(), TEXT("sp_remove")) ? TRUE : FALSE );
   pId->bSPPatch = ( _tcsstr (GetCommandLine(), TEXT("sp_patch")) ?     TRUE : FALSE );
   pId->bSPUpdate= ( _tcsstr (GetCommandLine(), TEXT("sp_update")) ?    TRUE : FALSE );
   pId->bSPFull  = ( _tcsstr (GetCommandLine(), TEXT("sp_full")) ?      TRUE : FALSE );
   pId->bOEMImage= ( _tcsstr (GetCommandLine(), TEXT("oemimage")) ?     TRUE : FALSE );


   Idwlog(TEXT("IdwLogClient - pId->bSPFull = %ld\n"), pId->bSPFull );





   osVer.dwOSVersionInfoSize= sizeof( osVer );
   GetVersionEx( &osVer );
   switch (osVer.dwPlatformId) {
   case VER_PLATFORM_WIN32_NT:
      //refine it to earlier versions
      switch (osVer.dwMajorVersion) {
      case 3:
         _tcscpy(pId->szPlatform,TEXT("Windows NT 3.51"));
         Idwlog(TEXT("This is for winver %s.\n"),pId->szPlatform);
         pId->dwSystemBuild        = osVer.dwBuildNumber;
         pId->dwSystemBuildDelta   = 0;
         pId->dwSystemSPBuild      = 0;
         pId->dwSystemMajorVersion = osVer.dwMajorVersion;
         pId->dwSystemMinorVersion = osVer.dwMinorVersion;
         _stprintf(pId->szSystemBuildSourceLocation, TEXT("%s"),
                   TEXT("No_Build_Lab_Information"));
         // fix the number of displays for non Windows 2000 systems
         pMd->iNumDisplays = 1;
         Idwlog(TEXT("Getting Displays Info.\n"));
         break;
      case 4:
         _tcscpy(pId->szPlatform,TEXT("Windows NT 4.0"));
         Idwlog(TEXT("This is for winver %s.\n"),pId->szPlatform);
         pId->dwSystemBuild        = osVer.dwBuildNumber;
         pId->dwSystemBuildDelta   = 0;
         pId->dwSystemSPBuild      = 0;
         pId->dwSystemMajorVersion = osVer.dwMajorVersion;
         pId->dwSystemMinorVersion = osVer.dwMinorVersion;
         _stprintf(pId->szSystemBuildSourceLocation, TEXT("%s"),
                   TEXT("No_Build_Lab_Information"));
         // fix the number of displays for non Windows 2000 systems
         pMd->iNumDisplays = 1;
         Idwlog(TEXT("Getting Displays Info.\n"));

         break;
      case 5: 
         //This is the current build of the machine its 
         // running on. So this will be the previous
         // build as we see it and not the current installing build.
         _tcscpy(pId->szPlatform, TEXT("Windows 2000, XP, or .NET Server"));
         Idwlog(TEXT("This is for winver %s.\n"),pId->szPlatform);

         pMd->iNumDisplays = GetSystemMetrics(SM_CMONITORS); 
         Idwlog(TEXT("Getting Displays Info.\n"));

         if (FALSE == GetCurrentSystemBuildInfo(pId)) {
            if (pId->iStageSequence == 1) {
               Idwlog(TEXT("Failed getting build, build delta, VBL location.\n"));
               return FALSE;
            }
         } else
            Idwlog(TEXT("Succeded in getting build, build delta, VBL location. Build %lu Delta %lu.\n"), 
                   pId->dwSystemBuild,
                   pId->dwSystemBuildDelta);               
         break;
      default:

         // if the size is > 5 (Mostlikely won't be less that 3)
         //_itoa (osVer.dwBuildNumber, szCurBld, sizeof(szCurBld));
         _tcscpy(pId->szPlatform, TEXT("Windows 64? Future?"));
         Idwlog(TEXT("This is for winver %s.\n"),pId->szPlatform);

         if (FALSE == GetCurrentSystemBuildInfo(pId)) {
            if (pId->iStageSequence == 1) {
               Idwlog(TEXT("Failed getting build, build delta, VBL location.\n"));
               return FALSE;
            }
         } else
            Idwlog(TEXT("Succeded in getting build, build delta, VBL location. Build %lu Delta %lu.\n"), 
                   pId->dwSystemBuild,
                   pId->dwSystemBuildDelta);               

         pId->dwSystemBuild = osVer.dwBuildNumber;
      }
      GetEnvironmentVariable ( TEXT("NUMBER_OF_PROCESSORS"), pId->szCpu, 6);
      GetEnvironmentVariable ( TEXT("PROCESSOR_ARCHITECTURE"), pId->szArch, 20);
      break;


   case VER_PLATFORM_WIN32_WINDOWS:
      _tcscpy(pId->szPlatform,TEXT("Windows 9x"));
      _tcscpy(pId->szArch, TEXT("X86"));
      pId->dwSystemBuild        = osVer.dwBuildNumber;
      pId->dwSystemBuildDelta   = 0;
      pId->dwSystemSPBuild      = 0;
      pId->dwSystemMajorVersion = osVer.dwMajorVersion;
      pId->dwSystemMinorVersion = osVer.dwMinorVersion;
      // fix the number of displays for non Windows 2000 systems
      pMd->iNumDisplays = GetSystemMetrics(SM_CMONITORS); 
      if (pMd->iNumDisplays == 0)
         pMd->iNumDisplays = 1;
      Idwlog(TEXT("Getting Displays Info.\n"));
      _stprintf(pId->szSystemBuildSourceLocation, TEXT("%s"),
                TEXT("No_Build_Lab_Information"));
      break;

   default:
      _tcscpy(pId->szPlatform,TEXT("Unknown Platform"));
      _tcscpy(pId->szArch, TEXT("Unknown Arch"));
      pId->dwSystemBuild        = 0;
      pId->dwSystemBuildDelta   = 0;
      pId->dwSystemSPBuild      = 0;
      pId->dwSystemMajorVersion = 0;
      pId->dwSystemMinorVersion = 0;
      _stprintf(pId->szSystemBuildSourceLocation, TEXT("%s"),
                TEXT("No_Build_Lab_Information"));
      pMd->iNumDisplays = 1;
      break;
   }
   Idwlog(TEXT("Identified OS version as %s\n"),pId->szPlatform);

   
   // Get the Sku from the dosnet.inf
   // This will show what build we are trying to go to.
   if (pId->iStageSequence == 1) {
      if (FALSE == GetSkuFromDosNetInf(pId)) {
         Idwlog(TEXT("IdwLogClient ERROR - Failed getting sku from dosnet.inf.\n"));
         return FALSE;
      } else
         Idwlog(TEXT("Succeded in getting sku from dosnet.inf.\n"));
   }
   else if ( pId->iStageSequence == 3 ) {

	pId->dwSku = GetSkuFromSystem ();
   }


   //Get the Current build thats is being installed if its windows 2000
   if (FALSE == GetCurrentInstallingBuildInfo(pId)) {
      if (pId->iStageSequence == 1) {
         Idwlog(TEXT("Failed getting build, build delta, VBL location.\n"));
         pId->bFindBLDFile = FALSE;

         return FALSE;
      }
   } else
      Idwlog(TEXT("Succeded in getting build, build delta, VBL location. Build %lu Delta %lu.\n"), 
             pId->dwInstallingBuild,
             pId->dwInstallingBuildDelta);


   Idwlog(TEXT("Loading the booleans with install data.\n"));

   pId->bCancel  = ( _tcsstr (GetCommandLine(), TEXT("cancel")) ?  TRUE : FALSE );
   pId->bCdrom   = ( _tcsstr (GetCommandLine(), TEXT("cdrom")) ?   TRUE : FALSE );
   pId->bNetwork = !pId->bCdrom;
   pId->bUpgrade = ( _tcsstr (GetCommandLine(), TEXT("upgrade")) ? TRUE : FALSE );
   pId->bClean   = !pId->bUpgrade;
   pId->bMsi     = ( _tcsstr (GetCommandLine(), TEXT("MSI")) ?     TRUE : FALSE );


   //Get the computerName
   //
   dwComputerNameLen = sizeof(pId->szComputerName);

   if ( FALSE == GetComputerName (pId->szComputerName, &dwComputerNameLen)) {

      Idwlog(TEXT("Could not get the computer name. Default NoComputerName.\n"));
      _tcscpy(pId->szComputerName,TEXT("NoComputerName"));

   } else {

//	TCHAR szDest[MAX_PATH];

        Idwlog(TEXT("IdwLogClient - Computer name is: %s\n"), pId->szComputerName );

/***   this is bogus, we are ansi right now...
	//	Because idwlog's backend processing can't handle Unicode compternames (log file names),
	//	we will convert to ansi.
	//
	if ( 0 == WideCharToMultiByte( CP_ACP, 0, pId->szComputerName, -1, szDest, MAX_PATH, NULL, NULL ) ) {

		//	Error converting, just keep unicode name.
		//
		Idwlog(TEXT("IdwLogClient - WideCharToMultiByte FAILed rc = %ld, pId->szComputerName is: %s\n"), 
				GetLastError(), pId->szComputerName );

	} else {

		// No error converting, copy the ansi name back into the location.
		//
		_tcscpy (pId->szComputerName, szDest );

		Idwlog(TEXT("IdwLogClient - Computer name is (after Unicode to Ansi conversion): %s\n"), pId->szComputerName );
	}
***/

   }


   //Generate the MachineId
   pId->dwMachineID = RandomMachineID();
   Idwlog(TEXT("Generating the Machine Id: %lu.\n"), pId->dwMachineID);


   //Get the UserName
   if (FALSE == 
       GetEnvironmentVariable (TEXT("Username"), pId->szUserName, 30)) {

      Idwlog(TEXT("Failed to get the UserName! Setting default Unknown."));
      _tcscpy (pId->szUserName, TEXT("Unknown"));
   } else
      Idwlog(TEXT("Getting User Name: %s.\n"), pId->szUserName);


   //Get the UserDomain
   if (FALSE == 
       GetEnvironmentVariable (TEXT("Userdomain"), pId->szUserDomain, 30)) {
      Idwlog(TEXT("Failed to get the Userdomain! Setting default Unknown."));
      _tcscpy (pId->szUserDomain, TEXT("Unknown"));
   } else
      Idwlog(TEXT("Getting User domain: %s.\n"), pId->szUserDomain);

   //	Get the Processor Architecture
   //
   if (FALSE ==  GetEnvironmentVariable (TEXT("PROCESSOR_ARCHITECTURE"), pId->szArch, 20)) {

	//	Assumes we set szArch above in Win9x case.  But, we don't want to overwrite it now since Win9x
	//	does not have this environment variable set.
	//
	if ( osVer.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS ) {

      		Idwlog(TEXT("Failed to get the Proc_Architecture! Setting default Unknown."));
      		_tcscpy (pId->szArch, TEXT("Unknown"));
	} 
	else {
		Idwlog(TEXT("szArch Env Win9x case.  Will not give error since it should be filled in above code."));
	}
   } else
      Idwlog(TEXT("Getting processor Architecture: %s.\n"), pId->szArch);


   // Get locale abbreviation so we know about language pack usage
   if ( FALSE == GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_SABBREVLANGNAME, pId->szLocaleId, sizeof( pId->szLocaleId ))) {
      Idwlog(TEXT("Could not get the locale abbreviation. Settingto default of unknown."));
      _tcscpy(pId->szLocaleId, TEXT("UKNW"));
   } else
      Idwlog(TEXT("Getting locale: %s.\n"), pId->szLocaleId);


   //Get the system Information.
   GetSystemInfo( &SysInfo );
   pMd->dwNumberOfProcessors  = SysInfo.dwNumberOfProcessors;
   pMd->dwProcessorType       = SysInfo.dwProcessorType; 
   pMd->dwProcessorLevel      = (DWORD)SysInfo.wProcessorLevel;
   pMd->dwProcessorRevision   = (DWORD)SysInfo.wProcessorRevision;
   Idwlog(TEXT("Getting System Info.\n"));


   //Get the Memory Config on the system
   msRAM.dwLength = sizeof (msRAM);
   GlobalMemoryStatus (&msRAM);
   pMd->dwPhysicalRamInMB = (DWORD) msRAM.dwTotalPhys/ (1024 *1024);
   Idwlog(TEXT("Getting Ram size.\n"));


   //Get the Video Chip type, Memory and DAC type.
   /*
   Because we have a problem on Terminal Server sp6 on one machine
   Bogdana's suggestion was to not do this for NT4.
   */

   if (4 != pId->dwSystemMajorVersion) {
      GetVidInfo (pMd);
      Idwlog(TEXT("Getting Video Info.\n"));
   } else {
      // Set some defaults in case we encounter this problem.
      _tcscpy(pMd->szVideoDisplayName,TEXT("Unknown"));
      pMd->szVideoInfo[0] = TEXT('\0');
      Idwlog(TEXT("Because of a problem on Terminal Server sp6 we will not get the Video Info.\n"));
   }

   //Get the Sound information
   GetNTSoundInfo(pMd);
   Idwlog(TEXT("Geting Sound Info.\n"));

   //Get Network/SCSI/ Modem PNP stuff.
   GetPNPDevices(pMd);
   Idwlog(TEXT("Getting Network scsi modem pnp Info.\n"));

   //Get the Terminal server information.
   pId->bHydra = IsHydra ();
   Idwlog(TEXT("Getting Hydra Info.\n"));

   return TRUE;
}


//
// For SHGetFolderPath LoadLibrary/GetProcAddress
//

typedef HRESULT (*SHGETFOLDERPATH) (HWND, int, HANDLE, DWORD, LPTSTR);

BOOL 
RemoveStartupLink( LPTSTR szLinkToRemove )
/*++

Author: Wallyho.
    
Routine Description:


Arguments:
 
Return Value:


--*/ 
{

   TCHAR  szProfileDir[ MAX_PATH ];
   TCHAR  sz[ MAX_PATH ];
   BOOL   bDeleted = FALSE;

   SHGETFOLDERPATH pSHGetFolderPath = NULL;
   HMODULE         hModule = NULL;
   BOOL            b1 = TRUE, b2 = TRUE;


   // If the current build is 2195 or greater 
   // Then this is NT50 and we kill the link.
   // Otherwise we don't care.
   if (GetCurrentMachinesBuildNumber() >= 2195) {

      //
      // Make sure the strings are not hard-coded in English...
      //
      hModule = LoadLibrary(TEXT("SHFolder.dll"));
      if (hModule) {
         #ifdef UNICODE
         pSHGetFolderPath = (SHGETFOLDERPATH)GetProcAddress(hModule, TEXT("SHGetFolderPathW"));
         #else
         pSHGetFolderPath = (SHGETFOLDERPATH)GetProcAddress(hModule, TEXT("SHGetFolderPathA"));
         #endif
      }

      
      if (pSHGetFolderPath) {

         Idwlog(TEXT("Will use SHGetFolderPath.\n"));
         // This will get from startup All Users.
         (*pSHGetFolderPath) (NULL, CSIDL_COMMON_STARTUP, NULL, 0, szProfileDir);
         //   SHGetSpecialFolderPath (NULL, szExePath, CSIDL_COMMON_STARTUP, FALSE );
         PathAppend (szProfileDir, szLinkToRemove);
         if (FALSE == DeleteFile (szProfileDir) ) {
            b1 = FALSE;
         }          
         Idwlog(TEXT("%s in removing %s.\n"), (b1 ? TEXT("Succedeed"): TEXT("Failed")), szProfileDir);


         // This will get it for the current user.
         //   SHGetSpecialFolderPath (NULL, szExePath, CSIDL_STARTUP, FALSE );
         (*pSHGetFolderPath) (NULL, CSIDL_STARTUP , NULL, 0, szProfileDir);
         PathAppend (szProfileDir, szLinkToRemove);
         if (FALSE == DeleteFile (szProfileDir) ) {
            b2 = FALSE;
         } 

         Idwlog(TEXT("%s in removing %s.\n"), (b2 ? TEXT("Succedeed"): TEXT("Failed")), szProfileDir);

         if ( b1 == FALSE || b2 == FALSE)
            return FALSE;
         else
            return TRUE;

      } else {
         // 
         // Default to the old and broken behavior (this should never happen, 
         // but just in case...)
         // 
         //
         Idwlog(TEXT("Will use hardcoded strings.\n"));

         // Kill it from the Allusers directory.
         // The link can be in only 2 places.
         // Upon upgrade its in windir\profiles\All Users\Start Menu\Programs\Startup
         // Upon Clean install it is
         //    sysdrive:\Documents and Settings\All Users\Start Menu\Programs\Startup

         GetWindowsDirectory(szProfileDir, MAX_PATH);
         _stprintf( sz,
                    TEXT("\\profiles\\All Users\\Start Menu\\Programs\\Startup\\%s"),
                    szLinkToRemove);
         _tcscat( szProfileDir, sz);
         bDeleted = DeleteFile (szProfileDir);

         if (FALSE == bDeleted) {
            // Kill the all user one if its there.
            GetEnvironmentVariable(TEXT("allusersprofile"),szProfileDir, MAX_PATH);
            _stprintf( sz,
                       TEXT("\\Start Menu\\Programs\\Startup\\%s"),
                       szLinkToRemove);
            _tcscat( szProfileDir, sz);
            bDeleted = DeleteFile (szProfileDir);
         }

         if (FALSE == bDeleted) {
            // Kill the user one too if its there.
            GetEnvironmentVariable(TEXT("userprofile"),szProfileDir, MAX_PATH);
            _stprintf( sz,
                       TEXT("\\Start Menu\\Programs\\Startup\\%s"),
                       szLinkToRemove);
            _tcscat( szProfileDir, sz);
            bDeleted = DeleteFile (szProfileDir);
         }

         if (FALSE == bDeleted ) {
            if (2 == GetLastError()) {
               Idwlog(TEXT("The link is not found.\n"));
            } else {
               Idwlog(TEXT("Problems removing the startup link. Error %lu.\n"), GetLastError());
            }
            return FALSE;
         } else {
            Idwlog(TEXT("Startup link removed sucessfully.\n"));
            return TRUE;
         }
      }
      /* Doesn't work for all NT4.0
            */
   } else {
      Idwlog(TEXT("W2k Startup link removal. Nothing done.\n"));
      return TRUE;
   }
}


VOID 
GlobalInit(VOID)
/*++

Author: Wallyho.
    
Routine Description:

   Initializes global Values.

Arguments:
   NONE
 
Return Value:

   NONE

--*/

{

   //
   // Do some global initializations.
   //

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\idwlog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Filename :  
         
        idwlog.h

Abstract:
        Header for idwlog.cpp
	
Author:
   Wally Ho (wallyho)
 


Revision History:
    Created on 7/18/2000
	
--*/

CONST LPTSTR IDWLOG_LINK_SHORTCUT = TEXT("IDW Logging Tool.lnk");


   // Global data
  extern INSTALL_DATA   g_InstallData;
  extern TCHAR          g_szServerData[4096];
   
   
   // Prototypes
   BOOL
   IdwlogClient ( LPINSTALL_DATA pId,
                  LPMACHINE_DETAILS pMd);
   
   BOOL 
   RemoveStartupLink( LPTSTR szLinkToRemove );
   
   // The name of the service
//   extern LPTSTR SERVICE_NAME;

/*
#include "idw_dbg.h"
#include "service.h"

class CIdwlog: public CDebugOutput, public CServices{



public:
   ~CIdwlog();
   CIdwlog();
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\files.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Filename :

        files.h

Abstract:

        Header for files
	
Author:

        Wally Ho (wallyho) 20-Feb-2000

Revision History:
   Created
	
 --*/


// Definition of constants 

#ifndef FILES_H
#define FILEs_H
#include <windows.h>
#include "machines.h"


CONST BOOL DTC = FALSE; // FALSE for whistler; TRUE for DTC.  


CONST INT F_SYSTEM              = 0x1;
CONST INT F_INSTALLING          = 0x2;
CONST INT F_SYSTEM_IMAGEHLP_DLL = 0x3;
CONST INT F_INSTALLING_IMAGEHLP_DLL = 0x4;


BOOL GetCurrentSystemBuildInfo ( IN OUT  LPINSTALL_DATA pId);

BOOL GetCurrentInstallingBuildInfo ( IN OUT  LPINSTALL_DATA pId);


BOOL GetBuildInfoFromOSAndBldFile( OUT  LPINSTALL_DATA pId,
                                   IN   INT iFlag);

BOOL GetImageHlpDllInfo (OUT  LPINSTALL_DATA pId,
                          IN  INT iFlag);

BOOL MyGetFileVersionInfo(LPTSTR lpszFilename, LPVOID *lpVersionInfo);

BOOL GetSkuFromDosNetInf (IN OUT LPINSTALL_DATA pId);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\machines.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Filename :

        Machines.h

Abstract:

        Header for machines.c
	
Author:

        Wally Ho (wallyho) 01-Feb-2000

Revision History:
   Created
	
--*/
#ifndef MACHINES_H
#define MACHINES_H
#include <windows.h>


#define  MAX_WAVEOUT_DEVICES 2
typedef struct 
_MACHINE_DETAILS{

   // System info
   DWORD dwNumberOfProcessors;
   DWORD dwProcessorType;
   DWORD dwProcessorLevel;
   DWORD dwProcessorRevision;

   // Types for the sound card.
   INT   iNumWaveOutDevices;                         // Number of WaveOut Devices (~ number of sound cards)
   TCHAR szWaveOutDesc   [MAX_WAVEOUT_DEVICES][128];// WaveOut description
   TCHAR szWaveDriverName[MAX_WAVEOUT_DEVICES][128];// Wave Driver name

   // Types for the video card.
   TCHAR szVideoInfo[ MAX_PATH ];
   TCHAR szVideoDisplayName[ MAX_PATH ];
   UINT  iNumDisplays;

   //Type for the PNP Cards
   TCHAR szNetcards[ MAX_PATH ];
   TCHAR szModem   [ MAX_PATH ];
   TCHAR szScsi    [ MAX_PATH ];
   BOOL  bUSB;
   BOOL  bPCCard;
   BOOL  bACPI;
   BOOL  bIR;
   DWORD dwPhysicalRamInMB;


} MACHINE_DETAILS, *LPMACHINE_DETAILS;


   // video cards Defines
   CONST LPTSTR VIDEOKEY    = TEXT("SYSTEM\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet\\Services");   
   CONST LPTSTR SERVICEKEY  = TEXT("SYSTEM\\CurrentControlSet\\Services");
   CONST LPTSTR DEVICE_DESCR= TEXT("Device Description");
   CONST LPTSTR CHIP_TYPE   = TEXT("HardwareInformation.ChipType");
   CONST LPTSTR DAC_TYPE    = TEXT("HardwareInformation.DacType");
   CONST LPTSTR MEM_TYPE    = TEXT("HardwareInformation.MemorySize");

   // Prototypes!
   
   DWORD GetCurrentMachinesBuildNumber( VOID );
   
   DWORD RandomMachineID ( VOID );
   
   VOID  GetNTSoundInfo  ( OUT LPMACHINE_DETAILS pMd);
   
   VOID  GetVidInfo      ( OUT LPMACHINE_DETAILS pMd);
   
   VOID  GetPNPDevices   ( OUT LPMACHINE_DETAILS pMd);
                           
   BOOL  IsHydra         ( VOID );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\idw_dbg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Filename :  
         
        idw_dbg.h

Abstract:
        Header for idw_dbg.c
	
Author:

        Wally Ho (wallyho) 31-Jan-2000

Revision History:
   Created
	
--*/
#ifndef IDW_DBG_H
#define IDW_DBG_H

#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <stdarg.h>


CONST DWORD WRITE_SERVICE_DBG = 0x1;
CONST DWORD WRITE_NORMAL_DBG  = 0x0;
 

// Global
extern   FILE* fpIdwlogDebugFile;

// Prototypes

VOID  OpenIdwlogDebugFile(DWORD dwPart);

VOID  CloseIdwlogDebugFile(VOID);

VOID  RemoveIdwlogDebugFile(DWORD dwPart);

VOID  Idwlog (LPTSTR szMessage,...);

VOID  CopySetupErrorLog ( LPINSTALL_DATA );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\machines.cpp ===
/*++

   Filename :  Machines.c

   Description: This contains the functions that will interrogate the
   machine for details.
   The GetNTSoundINfo function is directly copied from David Shiftlet's code.
   Since we didn't use it, I'm not going to waste debug time figuring out
   if the random code he put in actually works.

     
   Created by:  Wally Ho

   History:     Created on 02/01/99.


   Contains these functions:

   1. DWORD GetCurrentMachinesBuildNumber( VOID );
   2. DWORD RandomMachineID(VOID)
   3. VOID  GetNTSoundInfo(OUT LPMACHINE_DETAILS pMd)
   4. VOID  GetVidInfo (OUT LPMACHINE_DETAILS pMd)
   5. VOID  GetPNPDevices (OUT LPMACHINE_DETAILS pMd)
   6. BOOL  IsHydra ( VOID )
   7. BOOL  GetPnPDisplayInfo(LPTSTR pOutputData)


--*/
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <time.h>
#include <sys/timeb.h>
#include <tchar.h>
#include <winuser.h>
#include "network.h"
#include "machines.h"
#include "idw_dbg.h"

// For PnP Stuff
#include <devguid.h>
#include <initguid.h>
#include <setupapi.h>
#include <syssetup.h>
#include <regstr.h>
#include <setupbat.h>
#include <cfgmgr32.h>
#include "netinfo.h"

// These aren't used but I think I can use them
// somewhere so I'll leave them here. Wallyho
LPTSTR Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
LPTSTR Months[] = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

DWORD
GetCurrentMachinesBuildNumber( VOID )
/*++
   
Author: Wallyho.
    
Routine Description:

     Purpose this should get the current build number of the 
     running OS.

Arguments:
   NONE
 
Return Value:

  The DWORD of the build.
  

--*/
{

   OSVERSIONINFO osVer;

   osVer.dwOSVersionInfoSize= sizeof( osVer );
   if (GetVersionEx( &osVer )&&osVer.dwMajorVersion >= 5) 
      return osVer.dwBuildNumber;
   else
      return FALSE;

}



DWORD
RandomMachineID(VOID)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    8/18/2000

   Routine Description:
       Generates DWORD random MachineID for each machine.
       There is a very slim chance that duplicates could occur. 
   Arguments:
       NONE

   Return Value:
      The DWORD random ID.
--*/
{
   INT      i;
   INT      iLenCName;
   INT      iNameTotal = 0;
   TCHAR    szComputerName[MAX_COMPUTERNAME_LENGTH+1];
   DWORD    dwSize;
   DWORD    dwMachineID;    
   CHAR     szRandomID[ 4 ]; // need 4 bytes to contain the DWORD.
   struct _timeb tm;


   //
   // This will get us the milliseconds
   _ftime(&tm);
   //
   // Seed the random number generator.
   // We will seed with the seconds + milliseconds at
   // at that time. I was getting the same number 
   // if I pressed the keyboard too fast in testing this.
   // The milli seconds should decrease the expectancy of
   // duplication.
   //
   srand(  ((UINT)time(NULL)) + tm.millitm);
   //
   // This will guarantee a mostly random identifier.
   // Even with no computer name. We will tally the
   // ascii decimal value of the computer name and
   // add that to the randomly generated number.
   // The possibility of a dup is greatly decreased
   // since we switched to a dword system.
   // This computername tweak should be unnecessary.
   //
   dwSize = sizeof(szComputerName);
   if (0 == GetComputerName(szComputerName,&dwSize) ){
      //
      // This algorithm will limit the random number to 
      // uppercase ascii alphabet.
      //
      szComputerName[0] = 65 + (rand() % 25);
      szComputerName[1] = 65 + (rand() % 25);
      szComputerName[2] = 65 + (rand() % 25);
      szComputerName[3] = 65 + (rand() % 25);
      szComputerName[4] = 65 + (rand() % 25);
      szComputerName[5] = 65 + (rand() % 25);
      szComputerName[6] = 65 + (rand() % 25);
      szComputerName[7] = TEXT('\0');
   }
   iLenCName = _tcslen (szComputerName);
   //
   // Tally up the individual elements in the file
   //
   for (i = 0; i < iLenCName; i++)
      iNameTotal += szComputerName[i];
   //
   //   Generate four 8 bit numbers.
   //   Add the some random number based on the
   //   computername mod'ed to 0-100.
   //   Limit the 8 bit number to 0-155 to make room
   //   for the 100 from the computer name tweak.
   //   Total per 8 bit is 256.
   //   Do this tweak to only 2.
   //   We will then cast and shift to combine it
   //   into a DWORD.
   //
   szRandomID[0] = (rand() % 155) + (iNameTotal % 100);
   szRandomID[1] =  rand() % 255;
   szRandomID[2] = (rand() % 155) + (iNameTotal % 100);
   szRandomID[3] =  rand() % 255; 
   // This should limit the last digit to 0011 only two binaries so we will
   // only get 9 chars in the random id. 10 chars may cause an overflow
   // of the dword we are using.


   //
   //   This will combine the 4 8bit CHAR into one DWORD 
   //
   dwMachineID  =   (DWORD)szRandomID[0] * 0x00000001 + 
                    (DWORD)szRandomID[1] * 0x00000100 +
                    (DWORD)szRandomID[2] * 0x00010000 +
                    (DWORD)szRandomID[3] * 0x01000000;

   return dwMachineID;
}


VOID 
GetNTSoundInfo(OUT LPMACHINE_DETAILS pMd)
{
   HKEY    hKey;
   DWORD   dwCbData;
   ULONG   ulType;
   LPTSTR  sSubKey=TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
   INT     i;
   TCHAR   szSubKeyName[ MAX_PATH ];
   TCHAR   szTempString[ MAX_PATH ];

   
   // Get Sound Card Info
   pMd->iNumWaveOutDevices = 0;
   hKey = 0;
   if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){
      // Loop through the key to see how many wave devices we have, but skip mmdrv.dll.
      for (i = 0; i <= 1; i++){

         if (i != 0)
            _stprintf(szSubKeyName, TEXT("wave%d"),i);
         else
            _tcscpy(szSubKeyName, TEXT("wave"));
 

         dwCbData = sizeof (szTempString);
         if (RegQueryValueEx(hKey, szSubKeyName, 0, &ulType, (LPBYTE)szTempString, &dwCbData))
            break;
         else{
            // We want to skip mmdrv.dll - not relevant.
            if (szTempString[0] && 
                _tcscmp(szTempString, TEXT("mmdrv.dll")))  {
               
               _tcscpy(&pMd->szWaveDriverName[pMd->iNumWaveOutDevices][0], 
                       szTempString);
               pMd->iNumWaveOutDevices++;
            }
         }
      }
   }
   if (hKey){
      RegCloseKey(hKey);
      hKey = 0;
   }

   sSubKey = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");
   hKey = 0;
   if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){

      // Now grab the sound device string for each wave device
      for (i = 0; i < pMd->iNumWaveOutDevices; i++){
         dwCbData = sizeof szTempString;
         if (RegQueryValueEx(hKey, pMd->szWaveDriverName[i], 0, &ulType, (LPBYTE)szTempString, &dwCbData))
            _tcscpy(pMd->szWaveOutDesc[i], TEXT("Unknown"));
         else
            _tcscpy(pMd->szWaveOutDesc[i], szTempString);
      }
   }
   if (hKey){
      RegCloseKey(hKey);
      hKey = 0;
   }
   return;
}



VOID 
GetVidInfo (OUT LPMACHINE_DETAILS pMd)
/*++

   GetVidInfo reads registry information about the installed
   video cards and produces one string

--*/
{

   TCHAR    szDeviceKey[256];
   WCHAR    szWideBuf[128];
   
   HKEY     hkHardware;
   HKEY     hkCard;
   DWORD    dwSize;
   TCHAR    szSubKey[128];
   DWORD    dwIndex=0;
   DWORD    dwMem;   
   DWORD    iLoop;
   LPTSTR   pch;
   DISPLAY_DEVICE displayDevice;
   DEVMODE        dmCurrent;

   // make sure its zeroed even though it should be from ZeroMemory.
   pMd->szVideoInfo[0] = TEXT('\0');
   szWideBuf[0] = TEXT('\0');

   // Look in HWKEY to find out what services are used.
   if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, VIDEOKEY, 0, KEY_READ, &hkHardware)){
      Idwlog(TEXT("Failed to open the Video hardware Key. Video is NULL."));
      return;
   }

   dwSize=128;
   while (ERROR_SUCCESS == RegEnumKeyEx (hkHardware, dwIndex++,szSubKey, &dwSize,NULL,NULL,NULL,NULL)){

      // Append the subkey name to SERVICEKEY. 
      // Look up only Device0 for this card
      _stprintf (szDeviceKey, ("%s\\%s\\Device0"), SERVICEKEY, szSubKey);
      RegOpenKeyEx (HKEY_LOCAL_MACHINE, szDeviceKey, 0, KEY_READ, &hkCard);

      // First get the description
      dwSize=256;
      if (ERROR_SUCCESS == RegQueryValueEx( hkCard, DEVICE_DESCR, NULL, NULL, (_TUCHAR *)szDeviceKey, &dwSize)){
         if (_tcsclen(pMd->szVideoInfo ) + dwSize < 254){
            _tcscpy(pMd->szVideoInfo , szDeviceKey);
            _tcscat (pMd->szVideoInfo , TEXT(" "));
         }
      }

      // Read the chip type. This is a UNICODE string stored in REG_BINARY format
      dwSize=256;
      lstrcpyW (szWideBuf, L"ChipType:");
      if (ERROR_SUCCESS == RegQueryValueEx (hkCard, CHIP_TYPE,NULL, NULL, (LPBYTE)(szWideBuf+9), &dwSize)){
         if ((dwSize=lstrlen(pMd->szVideoInfo))+lstrlenW(szWideBuf)<254)         {
            WideCharToMultiByte (CP_ACP, 
                                 0,
                                 szWideBuf, 
                                 -1,
                                 pMd->szVideoInfo + dwSize, 
                                 256-dwSize, 
                                 NULL,
                                 NULL);
            _tcscat (pMd->szVideoInfo, TEXT(" "));
         }
      }

    // Read the DAC. Another UNICODE string
    dwSize=256;
    lstrcpyW (szWideBuf, L"DACType:");
    if (ERROR_SUCCESS == RegQueryValueEx (hkCard, DAC_TYPE, NULL, NULL, (LPBYTE)(szWideBuf+8), &dwSize)){
        
       if ((dwSize=lstrlen(pMd->szVideoInfo))+lstrlenW(szWideBuf)<254){
            
          WideCharToMultiByte (CP_ACP, 
                               0,
                               szWideBuf, 
                               -1,
                               pMd->szVideoInfo + dwSize, 
                               256 - dwSize, 
                               NULL,
                               NULL);
          _tcscat (pMd->szVideoInfo, TEXT(" "));
       }
    }
    
    // Read the memory size. This is a binary value.
    dwSize=sizeof(DWORD);
    if (ERROR_SUCCESS == RegQueryValueEx (hkCard, MEM_TYPE, NULL,NULL,(LPBYTE)&dwMem, &dwSize)){

       _stprintf (szDeviceKey, TEXT("Memory:0x%x ;"), dwMem);
       
       if (_tcsclen(pMd->szVideoInfo)+lstrlen(szDeviceKey)<255)
            _tcscat (pMd->szVideoInfo, szDeviceKey);
    }

    RegCloseKey (hkCard);
    dwSize=128;
   }
   RegCloseKey (hkHardware);
//__________________________________________________________________

   // Video Information for ChrisW
   // Video display name.
   _tcscpy(pMd->szVideoDisplayName,TEXT("Unknown"));


   displayDevice.cb = sizeof(DISPLAY_DEVICE);
   iLoop = 0;
   while(EnumDisplayDevices(NULL, iLoop, &displayDevice, 0)) {

      ZeroMemory( &dmCurrent, sizeof(dmCurrent) );
      dmCurrent.dmSize= sizeof(dmCurrent);
      if( EnumDisplaySettings( displayDevice.DeviceName, ENUM_CURRENT_SETTINGS, &dmCurrent ) ) {
         if(iLoop == 0)
            pMd->szVideoDisplayName[0] = 0;
         else
            _tcscat( pMd->szVideoDisplayName, TEXT(",") );

         _tcscat( pMd->szVideoDisplayName, (LPCTSTR)dmCurrent.dmDeviceName );
      }
      iLoop++;
   }
   // replace spaces so we don't break the perl script the build lab is using
   pch = pMd->szVideoDisplayName;
   while(*pch) {
      if(*pch == TEXT(' '))
         *pch = TEXT('.');
      pch++;
   }
}




extern DEV_INFO *g_pdiDevList;
// in netinfo.c

VOID 
GetPNPDevices (OUT LPMACHINE_DETAILS pMd)
/*++

   GetPNP Devices like net, scsi, pcmcia etc.
   This is a wally created function incorporting the random
   placement of this from before.

--*/
{

   DEV_INFO *pdi;
   
   // Get PNP net card info
   _tcscpy(pMd->szNetcards,   TEXT("Unknown"));
   _tcscpy(pMd->szScsi,       TEXT("Unknown"));
   _tcscpy(pMd->szModem    ,  TEXT("Unknown"));
  
   CollectDevData ();
   pdi=g_pdiDevList;

   while (pdi){
      if (0 == _tcscmp(pdi->szClass, TEXT("Net"))){
           if (_tcsclen(pMd->szNetcards) + _tcsclen(pdi->szDescription) + _tcsclen(pdi->szService) < 250){
               _tcscpy (pMd->szNetcards, pdi->szDescription);
               _tcscat (pMd->szNetcards, "(");
               _tcscat (pMd->szNetcards, pdi->szService);
               _tcscat (pMd->szNetcards, TEXT(")"));
           }
       }
       else if (0 == _tcscmp(pdi->szClass, TEXT("SCSIAdapter"))){
           if (_tcsclen(pMd->szScsi) + _tcsclen(pdi->szService) < 250){
               _tcscpy (pMd->szScsi, pdi->szService);
               _tcscat (pMd->szScsi, TEXT(","));
           }
       }
       else if (0 == _tcscmp(pdi->szClass, TEXT("Modem"))){
           if (_tcsclen( pMd->szModem) + _tcsclen(pdi->szDescription) < 250){
               _tcscpy ( pMd->szModem, pdi->szDescription);
               _tcscat ( pMd->szModem, TEXT(","));
           }
       }
       else if (0 == _tcscmp(pdi->szClass, TEXT("USB")))
           pMd->bUSB = TRUE;

       else if (0 == _tcscmp(pdi->szClass, TEXT("Infrared")))
           pMd->bIR = TRUE;
       
       else if (0 == _tcscmp(pdi->szClass,   TEXT("PCMCIA") ) || 
                0 == _tcscmp(pdi->szService, TEXT("PCMCIA") ))
           pMd->bPCCard = TRUE;

       else if (_tcsstr(pdi->szClass,   TEXT("ACPI")) || 
                _tcsstr(pdi->szService, TEXT("ACPI")))
           pMd->bACPI = TRUE;

       pdi=pdi->Next;
    }
   Cleanup(); //free all the pnp data and restore configuration

   if (pMd->szNetcards[0] == 0)
         _tcscpy (pMd->szNetcards, TEXT("Unknown"));
}

BOOL 
IsHydra ( VOID )
// Hydra is denoted by "Terminal Server" in the ProductOptions key
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

    __try{
    Rslt = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPTSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
    if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p) {
        if (_tcscmp( p, TEXT("Terminal Server") ) == 0) {
            rVal = TRUE;
            break;
        }
        p += (_tcslen( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

   }__except (EXCEPTION_EXECUTE_HANDLER) {
      // This is here as for some reason this faults in NT 4.0.
   }


    return rVal;
}




/*
BOOL
GetPnPDisplayInfo(
    LPTSTR pOutputData
    )
{
    BOOL            bRet = FALSE;
    HDEVINFO        hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD           index = 0;
    TCHAR           RegistryProperty[256];
    ULONG           BufferSize;

    //
    // Let's find all the video drivers that are installed in the system
    //

    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);

    while (hDevInfo != INVALID_HANDLE_VALUE){
        if (bRet) 
            strcat(pOutputData, TEXT(",") );
 
        ZeroMemory(&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiEnumDeviceInfo(hDevInfo,
                                   index++,
                                   &DeviceInfoData))
            break;
        BufferSize = sizeof(RegistryProperty);
        if (CR_SUCCESS ==
                CM_Get_Device_ID(DeviceInfoData.DevInst,
                                 RegistryProperty,
                                 sizeof(RegistryProperty),
                                 0)){
            bRet = TRUE;
            strcat(pOutputData, RegistryProperty);
        }
    }
    return (bRet);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\idw_dbg.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <stdarg.h>
#include <time.h>
#include "network.h"
#include "idw_dbg.h"
#include "server.h"

/*++

   Filename :  idw_dbg.cpp

   Description: Contains the idwlog1.dbg idwlog2.dbg error logging functions.
   
   Created by:  Wally Ho

   History:     Created on 31/01/2000.
                Modified to TCHAR from my implementation in the MPK test suite.

	09.19.2001	Joe Holman	fixes for idwlog bugs 409338, 399178, and 352810
	10.03.2001	Joe Holman	make the log file report a 'w' instead of a 'a' fopen call.
	11.02.2001	Joe Holman	Added code to make a connection to ntburnlab2 with particular user so we
					can authenticate when a machine is not in the same domain thus allowing 
					the file copy of logs to succeed.
	11.12.2001	Joe Holman	Added language value to the output log.


   Contains these functions:

   1. VOID OpenIdwlogDebugFile(DWORD dwPart);
   2. VOID CloseIdwlogDebugFile(VOID);
   3. VOID RemoveIdwlogDebugFile(DWORD dwPart);
   4. VOID Idwlog (LPTSTR szMessage,...);

--*/

// Global
FILE* fpIdwlogDebugFile;

CONST DWORD MAX_SIZE_OF_DEBUG_FILE = 4000000;
 
static CONST LPTSTR IDWLOG_LOG          = TEXT("Idwlog.log");
static CONST LPTSTR IDWLOGSERVICE_LOG   = TEXT("IdwlogService.log");

TCHAR szSuiteMask[MAX_PATH*2];
TCHAR szProductType[MAX_PATH*2];

#define CLEAR_LOG	TRUE
#define APPEND_LOG	FALSE


VOID
MyLogger ( TCHAR * String, DWORD dwBuild, BOOL bClearLog, DWORD dwDelta ) 

/*++

Routine Description:
   This function does the following:

	- get's the computer name
	- tries to create the log directory for the build
	- opens the log file in append mode or overwrites
	- writes out the specified string
	- closes the log file

Arguments:

   String - this is the text that we want to copy over to the server
   dwBuild - the build # for the machine
   bClearLog - if TRUE, we fopen with "w" (zero out), if FALSE, we fopen with "a" (append)

Return Value:

   NONE

Notes:

   NONE

Author: Joe Holman (joehol) 09.20.2001

--*/

{ 
     
	FILE * stream;
        TCHAR szName[MAX_PATH];
        TCHAR szComputerName [ MAX_COMPUTERNAME_LENGTH + MAX_PATH] = "DefCompName";
        DWORD dwSize;


        dwSize = sizeof ( szComputerName );

        if ( GetComputerName ( szComputerName, &dwSize ) ) {

	    // Try to make the directory name.  This will only be succussful on the first instance for
	    // for this build, but we need to do the operation always to make sure it gets created.
	    //

	    if ( dwBuild == 2600 ) {	// For Service Pack builds we want to use minor and major build # also to differentiate.


		//	We are going to use the format of:
		//
		//		2600.1001   (for internal use, we don't need to worry about having the major and minor data.
		//

		_stprintf ( szName, TEXT("\\\\ntburnlab2\\joehol\\logs\\%ld.%ld"), dwBuild, dwDelta );

		CreateDirectory ( szName, NULL );

	    	_stprintf ( szName, TEXT("\\\\ntburnlab2\\joehol\\logs\\%ld.%ld\\%s"), dwBuild, dwDelta, szComputerName );

	    }
	    else {

	    	_stprintf ( szName, TEXT("\\\\ntburnlab2\\joehol\\logs\\%ld"), dwBuild );

		CreateDirectory ( szName, NULL );

	    	_stprintf ( szName, TEXT("\\\\ntburnlab2\\joehol\\logs\\%ld\\%s"), dwBuild, szComputerName );
            }

	    
	//    Idwlog ( TEXT("MyLogger szName = %s.\n"), szName );


            if ( (stream = _tfopen ( szName, (bClearLog?TEXT("w"):TEXT("a")) )) != NULL ) {  

                TCHAR szBuf[2*MAX_PATH];

                _stprintf ( szBuf, TEXT("%s"), String ); 

                if ( fwrite ( szBuf, 1, _tcsclen(szBuf), stream ) < 1 ) {
	
			Idwlog ( TEXT("MyLogger ERROR fwrite had an error writing.\n") );

		}

                fclose ( stream );

            } 
	    else {
                Idwlog ( TEXT("MyLogger ERROR fopen had a problem on (%s).\n"), szName );
	    }
        }
        else {

	 	Idwlog ( TEXT("MyLogger ERROR GetComputerName gle = %ld\n"), GetLastError() );
	}
}

TCHAR * ShowProductType ( DWORD dwProductType )

/*++

Routine Description:
   This function does the following:

	- determines what the product type is and returns it in string format

Arguments:

   dwProductType - the bit mask to examine

Return Value:

   Pointer to global string to display.

Notes:

   NONE

Author: Joe Holman (joehol) 09.20.2001

--*/
 {

	

	switch ( dwProductType ) {

	case  VER_NT_WORKSTATION :
		_tcscpy ( szProductType, TEXT("VER_NT_WORKSTATION") );
		break;

	case  VER_NT_DOMAIN_CONTROLLER :
		_tcscpy ( szProductType, TEXT("VER_NT_DOMAIN_CONTROLLER") );
		break;

	case  VER_NT_SERVER :
		_tcscpy ( szProductType, TEXT("VER_NT_SERVER") );
		break;

	
	default :

		strcpy ( szProductType, "ERRORUNKNOWNPRODUCTTYPE" );

	}

	return ( szProductType );

}


TCHAR * ShowSuiteMask ( DWORD dwSuiteMask ) 

/*++

Routine Description:
   This function does the following:

 	- examines the suite mask provided and appends each suite characteristic to the global string.

Arguments:

   dwSuiteMask - suite mask to do bit compares against.

Return Value:

   Pointer to global string to display.

Notes:

   NONE

Author: Joe Holman (joehol) 09.20.2001

--*/

{


	_tcscpy ( szSuiteMask, "  " );



	if ( dwSuiteMask & VER_SUITE_SMALLBUSINESS ) {

		_tcscat( szSuiteMask, TEXT("Small Business, ") );

	}

	if ( dwSuiteMask & VER_SUITE_BACKOFFICE ) {

		_tcscat( szSuiteMask, TEXT("BackOffice, ") );

	}

	if ( dwSuiteMask & VER_SUITE_COMMUNICATIONS ) {

		_tcscat( szSuiteMask, TEXT("Communications, ") );

	}

	if ( dwSuiteMask & VER_SUITE_TERMINAL ) {

		_tcscat( szSuiteMask, TEXT("Terminal, ") );

	}

	if ( dwSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED ) {

		_tcscat( szSuiteMask, TEXT("Small Business Restricted, ") );

	}

	if ( dwSuiteMask & VER_SUITE_EMBEDDEDNT ) {

		_tcscat( szSuiteMask, TEXT("Embedded NT, ") );

	}

	if ( dwSuiteMask & VER_SUITE_SINGLEUSERTS ) {

		_tcscat( szSuiteMask, TEXT("Supports Single User Terminal Service, ") );

	}

	if ( dwSuiteMask & VER_SUITE_PERSONAL ) {

		_tcscat( szSuiteMask, TEXT("Home Edition, ") );

	}

	if ( dwSuiteMask & VER_SUITE_DATACENTER ) {

		_tcscat( szSuiteMask, TEXT("Data Center, ") );

	}

	if ( dwSuiteMask & VER_SUITE_ENTERPRISE ) {

		_tcscat( szSuiteMask, TEXT("Enterprise(old Advanced Server), ") );

	}

	if ( dwSuiteMask & VER_SUITE_BLADE ) {

		_tcscat( szSuiteMask, TEXT("Blade, ") );

	}

	return ( szSuiteMask );
}



typedef struct _tagLANGINFO {
    LANGID LangID;
    INT    Count;
} LANGINFO,*PLANGINFO;

BOOL
CALLBACK
EnumLangProc(
    HANDLE hModule,     // resource-module handle
    LPCTSTR lpszType,   // pointer to resource type
    LPCTSTR lpszName,   // pointer to resource name
    WORD wIDLanguage,   // resource language identifier
    LONG_PTR lParam     // application-defined parameter
   )
/*++

Routine Description:

    Callback that counts versions stamps.

Arguments:

    Details of version enumerated version stamp. (Ignore.)

Return Value:

    Indirectly thru lParam: count, langID

--*/
{
    PLANGINFO LangInfo;

    LangInfo = (PLANGINFO) lParam;

    LangInfo->Count++;

    //
    // for localized build contains multiple resource, 
    // it usually contains 0409 as backup lang.
    //
    // if LangInfo->LangID != 0 means we already assigned an ID to it
    //
    // so when wIDLanguage == 0x409, we keep the one we got from last time 
    //
    if ((wIDLanguage == 0x409) && (LangInfo->LangID != 0)) {
        return TRUE;
    }

    LangInfo->LangID  = wIDLanguage;

    return TRUE;        // continue enumeration
}




VOID
CopySetupErrorLog ( LPINSTALL_DATA pID ) 

/*++

Routine Description:
   This function copies the machines SetupError.log file
   to one of our specified servers for later analysis.

   It will copy it to the following directory:

	\\ntburnlab2\joehol\logs\<build#>\<machinename>

Arguments:
   
   NONE

Return Value:

   NONE

Notes:

   This function should silently fail gracefully if any error
   is encountered.


Author: Joe Holman (joehol) 09.20.2001

--*/
{

	TCHAR szLog[2*MAX_PATH];
	TCHAR szWindowsDirectory[MAX_PATH];
	TCHAR Line[2*MAX_PATH];
	UINT  ui;
	FILE* fp;
	OSVERSIONINFOEX osv;
	BOOL  b;
	DWORD dwBuild = 0;
	NETRESOURCE NetResource;
	TCHAR       szRemoteName [MAX_PATH];
	TCHAR       szPassWord  [ MAX_PATH ];
	TCHAR       szUserId    [ MAX_PATH ];
	DWORD	dwError=0;
	LPCTSTR Type = (LPCTSTR) RT_VERSION;
	LPCTSTR Name = (LPCTSTR) 1;
	LANGINFO LangInfo;

	

	Idwlog ( TEXT("Entering CopySetupErrorLog.\n") );

	Idwlog ( TEXT("CopySetupErrorLog pID.szSystemBuildSourceLocation = %s\n"),     pID->szSystemBuildSourceLocation );
	Idwlog ( TEXT("CopySetupErrorLog pID.szInstallingBuildSourceLocation = %s\n"), pID->szInstallingBuildSourceLocation );

	Idwlog ( TEXT("CopySetupErrorLog g_InstallData.dwInstallingBuildDelta = %ld\n"), g_InstallData.dwInstallingBuildDelta );


	//	Get the windows directory for the machine.
	//

	ui = GetWindowsDirectory ( szWindowsDirectory, MAX_PATH );

	if ( ui == 0 ) {

		Idwlog ( TEXT("CopySetupErrorLog ERROR - GetWindowsDirectory gle = %ld\n"), GetLastError());
		return;	
	}
	

	//	Gain access to the machine via a user and password since a lot of machines are NOT
	//	setup on the same domain and thus cannot authenticate unless we specify this.
	//	We will log an error if this doesn't work, but we won't stop.
	//

	_stprintf(szRemoteName, TEXT("%s"), SETUPLOGS_MACH);
	_stprintf(szPassWord,   TEXT("%s"), SETUPLOGS_PW);
	_stprintf(szUserId,     TEXT("%s"), SETUPLOGS_USER);

	// Setup the memory for the connection.
	ZeroMemory( &NetResource, sizeof( NetResource ) );
	NetResource.dwType         = RESOURCETYPE_DISK ;
	NetResource.lpLocalName    = NULL;
	NetResource.lpRemoteName   = szRemoteName;
	NetResource.lpProvider     = NULL;

	_stprintf(szUserId, TEXT("%s"), SETUPLOGS_USER );

	dwError = WNetAddConnection2( &NetResource, szPassWord, szUserId, 0 );

	//Idwlog(TEXT("WNetAddConnection2 %s [dwError=%ld] using:  %s, %s, %s\n"), (dwError==NO_ERROR)?TEXT("OK"):TEXT("ERROR"), dwError, szRemoteName, szUserId, szPassWord );

	Idwlog(TEXT("WNetAddConnection2 %s [dwError=%ld] using:  %s\n"), (dwError==NO_ERROR)?TEXT("OK"):TEXT("ERROR"), dwError, szRemoteName );
    
	

	//	Write the header out to the log file.
	//
	//	Note: the first writes clear the log file.
	//

	ZeroMemory (&osv, sizeof(osv) ); 
    	osv.dwOSVersionInfoSize = sizeof ( OSVERSIONINFOEX );
    	b = GetVersionEx ( (OSVERSIONINFO * ) &osv );

    	if ( !b ) {

        	Idwlog ( TEXT("CopySetupErrorLog ERROR GetVersionEx FAILed, gle = %ld\n"), GetLastError());
		dwBuild = 0;
        	MyLogger ( TEXT("IdwLog Header (GetVersionEx ERROR.)\n"), dwBuild, CLEAR_LOG, g_InstallData.dwInstallingBuildDelta );
    	}
	else {

		dwBuild = osv.dwBuildNumber;

		Idwlog ( TEXT("CopySetupErrorLog retreived os version info. dwBuild = %ld\n"), dwBuild );
    
     		_stprintf ( szLog, TEXT ("IdwLog\nosv.dwOSVersionInfoSize = %x\nosv.dwMajorVersion = %d\nosv.dwMinorVersion = %d\nosv.dwBuildNumber = %d\nosv.dwPlatformId = %x\nosv.szCSDVersion = %s\nosv.wServicePackMajor = %x\nosv.wServicePackMinor = %x\nosv.wSuiteMask = %x (%s)\nosv.wProductType = %x (%s)\nszSystemBuildSource = %s\nszInstallingBuildSource = %s\n"), 
        	osv.dwOSVersionInfoSize, 
        	osv.dwMajorVersion, 
        	osv.dwMinorVersion, 
        	osv.dwBuildNumber, 
        	osv.dwPlatformId, 
        	osv.szCSDVersion, 
        	osv.wServicePackMajor, 
        	osv.wServicePackMinor, 
        	osv.wSuiteMask, 
		ShowSuiteMask (osv.wSuiteMask),
        	osv.wProductType,
		ShowProductType (osv.wProductType),
		pID->szSystemBuildSourceLocation,
		pID->szInstallingBuildSourceLocation
		  );

		MyLogger ( szLog, dwBuild, CLEAR_LOG, g_InstallData.dwInstallingBuildDelta) ;

	}


	//	Write out the language information.
	//
	//



	ZeroMemory(&LangInfo,sizeof(LangInfo));

	EnumResourceLanguages(
        	GetModuleHandle(TEXT("ntdll.dll")),
        	Type,
        	Name,
        	(ENUMRESLANGPROC) EnumLangProc,
        	(LONG_PTR) &LangInfo );


	_stprintf ( szLog, "LangInfo.LangID = %X\n\n", LangInfo.LangID );
	MyLogger ( szLog, dwBuild, APPEND_LOG, g_InstallData.dwInstallingBuildDelta );



	
	//	Open the setup error log.
	//

	_stprintf ( szLog, TEXT("%s\\setuperr.log"), szWindowsDirectory );

    	fp = _tfopen ( szLog, TEXT("r") );
    
        if ( fp == NULL ) {

		Idwlog ( TEXT("CopySetupErrorLog  ERROR Couldn't open log file:  %s\n"), szLog );
		return;
    	}
	
    	Idwlog ( TEXT("CopySetupErrorLog opened local setuperr.log file.\n") );

       	while ( _fgetts ( Line, MAX_PATH, fp ) ) {


		//	Prepend our tag text and write to the Server.
		//

            	_stprintf ( szLog, TEXT("SetupErr.Log ERROR:  %s"), Line );
            	MyLogger ( szLog, dwBuild, APPEND_LOG, g_InstallData.dwInstallingBuildDelta );
           

       	}

        
       	fclose ( fp );


	Idwlog ( TEXT("CopySetupErrorLog finished.\n") );


}

VOID
OpenIdwlogDebugFile(DWORD dwPart)
/*++

Routine Description:
   This will open a logfile for the dbg output for the idwlog
   The parameter it takes will let it write a *.log file for either
   Part1 or Part two of the tools execution.

Arguments:
   1 for service otherwise its idwlog.log.

Return Value:
   NONE

Author: Wally Ho (wallyho) Jan 31st, 2000

--*/
{

   TCHAR sztimeClock[128];
   TCHAR sztimeDate[128];
   TCHAR szmsg[MAX_PATH];
   TCHAR szIdwlogFile[30];
   TCHAR szIdwlogFileAndPath[100];
   TCHAR szSystemDrive[4];
   BOOL  bUseSysDrive;
   HANDLE hTestExistence;
   WIN32_FIND_DATA ffd;
   UINT    i;
   TCHAR szLogDirectoryToCreate[100] = TEXT("c:\\idwlog");


   fpIdwlogDebugFile = NULL;

   // Determine which part is the one we want.
   if (1 == dwPart){
      _tcscpy(szIdwlogFile,IDWLOGSERVICE_LOG );
   }
   else {
      _tcscpy(szIdwlogFile, IDWLOG_LOG );
   }

   // Do a look for where we wrote the file first.
   // The case is this: we install with a system on C drive.
   // We install to d: drive. D drive boots up; we write the dbg
   // on system root d:. This splits it from the initial write.
   // This will find it if its on C.
   // if it doesn't find it then we default to system drive.
   

   bUseSysDrive = TRUE;
   
   for (i= TEXT('c'); i <= TEXT('z'); i++){

      _stprintf ( szIdwlogFileAndPath, 
                  TEXT("%c:\\idwlog\\Idwlo*.dbg"), i);

      hTestExistence = FindFirstFile(szIdwlogFileAndPath, &ffd);

      if (INVALID_HANDLE_VALUE != hTestExistence){

         FindClose(hTestExistence);

         // Delete Old DBG files.
         //
         _stprintf ( szIdwlogFileAndPath, TEXT("%c:\\idwlog\\%s"), i, IDWLOGSERVICE_LOG );
         SetFileAttributes(szIdwlogFileAndPath,FILE_ATTRIBUTE_NORMAL);
         DeleteFile( szIdwlogFileAndPath);
         _stprintf ( szIdwlogFileAndPath, TEXT("%c:\\idwlog\\%s"), i, IDWLOG_LOG );
         SetFileAttributes(szIdwlogFileAndPath,FILE_ATTRIBUTE_NORMAL);
         DeleteFile( szIdwlogFileAndPath);
      }
   }
   
   for (i= TEXT('c'); i <= TEXT('z'); i++){

      _stprintf ( szIdwlogFileAndPath, 
                  TEXT("%c:\\idwlog\\%s"), i,szIdwlogFile);

      hTestExistence = FindFirstFile(szIdwlogFileAndPath, &ffd);
      
      if (INVALID_HANDLE_VALUE != hTestExistence){

	 //	We found a log file in this case here.
	 //

         bUseSysDrive = FALSE;
         FindClose(hTestExistence);
 
         _stprintf ( szIdwlogFileAndPath, 
                     TEXT("%c:\\idwlog\\%s"), i, szIdwlogFile);
         
         // Check for FileSize if Greater that 500,000 bytes then delete it.
         if (ffd.nFileSizeLow >= MAX_SIZE_OF_DEBUG_FILE ) {
            SetFileAttributes(szIdwlogFileAndPath,FILE_ATTRIBUTE_NORMAL);
            DeleteFile( szIdwlogFileAndPath);
         }
         break;
      }
   }

   if (TRUE == bUseSysDrive){

      //  Get the system Drive
      //
      if ( 0 == GetEnvironmentVariable(TEXT("SystemDrive"),szSystemDrive, 4)) {
         //
         // Default to C: (we're probably running on Win9x where there is
         // no SystemDrive envinronment variable)
         //
         _tcscpy(szSystemDrive, TEXT("C:"));
      }
      _stprintf(szIdwlogFileAndPath,TEXT("%s\\idwlog\\%s"),
                szSystemDrive,szIdwlogFile);


      _stprintf( szLogDirectoryToCreate, TEXT("%s\\idwlog"), szSystemDrive );	// new
   }
   else {
      _stprintf( szLogDirectoryToCreate, TEXT("%c\\idwlog"), szIdwlogFileAndPath[0] );	// new, szIdwlogFileAndPath filled out above.	
   }

   // We want to store the logs in the our idwlog directory from the root, in order to fix bug #352810 - on logon, non-admin can't write log.
   CreateDirectory ( szLogDirectoryToCreate, NULL );  // don't check return code since it will fail in some cases if exist.



   fpIdwlogDebugFile = _tfopen(szIdwlogFileAndPath,TEXT("a"));

   if(NULL == fpIdwlogDebugFile) {

      // nothing we can do if the logfile is not formed?

      //_tprintf ( TEXT("ERROR - Could not open log file:  %s\n"), szIdwlogFileAndPath );
      ExitProcess(GetLastError());
   } 

   _tstrtime(sztimeClock);
   _tstrdate(sztimeDate);
   _stprintf(szmsg,TEXT("[Started on %s %s]\n"), sztimeDate, sztimeClock); 
   _ftprintf( fpIdwlogDebugFile,TEXT("%s"), szmsg);

/***	This is too annoying to have it hidden, so I'm removing it.  JoeHol 09.17.2001
   if(FALSE == SetFileAttributes(szIdwlogFileAndPath, FILE_ATTRIBUTE_HIDDEN)) {
      Idwlog(TEXT("OpenIdwlogDebugFile ERROR - Could not set the debug file to Hidden.\n"));
   }
***/

   return; 
}

VOID
CloseIdwlogDebugFile(VOID)
/*++

Routine Description:
   This will close the logfile for the dbg output for the idwlog

Arguments:
   NONE

Return Value:
   NONE

Author: Wally Ho (wallyho) Jan 31st, 2000


--*/
{
    if ( NULL != fpIdwlogDebugFile){
      fclose(fpIdwlogDebugFile);
      fpIdwlogDebugFile = NULL;
    }
      
}


VOID
RemoveIdwlogDebugFile(DWORD dwPart)
/*++

Routine Description:
   This will remove the logfile for the dbg output for the idwlog

Arguments:
   NONE

Return Value:
   NONE

Author: Wally Ho (wallyho) Jan 31st, 2000


--*/
{

   TCHAR szIdwlogFile[50];
   TCHAR szIdwlogFileAndPath[100];
   HANDLE hTestExistence;
   WIN32_FIND_DATA ffd;
   UINT  i; 

   // Determine which part is the one we want.
   if (1 == dwPart){
      _tcscpy(szIdwlogFile, IDWLOGSERVICE_LOG );
   }
   else
      _tcscpy(szIdwlogFile, IDWLOG_LOG );


   // Search all drives and kill the idwlog.dbg file
   for (i= TEXT('c'); i <= TEXT('z'); i++){
      _stprintf ( szIdwlogFileAndPath, 
                  TEXT("%c:\\idwlog\\%s"), i,szIdwlogFile);

      hTestExistence = FindFirstFile(szIdwlogFileAndPath, &ffd);
      if (INVALID_HANDLE_VALUE != hTestExistence){
         FindClose(hTestExistence);
         _stprintf ( szIdwlogFileAndPath, 
                     TEXT("%c:\\idwlog\\%s"), i,szIdwlogFile);
         // Make sure the file is removed so we have a fresh file everytime.
         _tremove(szIdwlogFile);
         break;
      }
   }

}
  


VOID
Idwlog (LPTSTR szMessage,...)
/*++

Routine Description:
   This is the logging function for the idwlog.
   It behaves much like printf.

Arguments:
   same as printf.

Return Value:
   NONE

Author: Wally Ho (wallyho) Jan 31st, 2000

--*/
{
   va_list vaArgs;
   time_t t;
   TCHAR szTimeBuffer[30];

   if ( NULL != fpIdwlogDebugFile) {

      //  Write the time to the log.
      time(&t); 
      _stprintf ( szTimeBuffer, TEXT("%s"), ctime(&t) );

      // ctime addes a new line to the buffer. Erase it here.
      szTimeBuffer[_tcslen(szTimeBuffer) - 1] = TEXT('\0');

      _ftprintf( fpIdwlogDebugFile, TEXT("[%s] "),szTimeBuffer);  


      //  Write the formatted string to the log.
      va_start( vaArgs, szMessage );
      _vftprintf( fpIdwlogDebugFile, szMessage, vaArgs );
      va_end  ( vaArgs );
      // Flush the stream
      fflush(fpIdwlogDebugFile);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\netinfo.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <regstr.h>
#include <cfgmgr32.h>
#include "netinfo.h"


// Globals

DEV_INFO *g_pdiDevList;          // Head of device list



/*++

Routine Description: (21) GetDevNodeInfoAndCreateNewDevInfoNode

   Creates new list node, then gets registry and resource information for
   a specific device and copies it into that node. Finally, adds new node
   to beginning of linked list

Arguments:

    dnDevNode:    the device to find information about
    szDevNodeID:  the registry path name of the device
    szEnumBuffer: name of enumerator this device is under

Return Value:                                         
    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL GetDevNodeInfoAndCreateNewDevInfoNode(IN DEVNODE dnDevNode,
                                           IN PTCHAR  szDevNodeID,
                                           IN PTCHAR  szEnumBuffer)
{
   LOG_CONF  lcLogConf = 0, lcLogConfNew;
   CONFIGRET cmret, cmret2;

   PDEV_INFO pdiDevInfo=(PDEV_INFO)malloc(sizeof(DEV_INFO));

   int       i;
   BOOL      boolForcedFound = FALSE, boolAllocFound = FALSE;
   USHORT    ushLogConfType[4] = {BOOT_LOG_CONF, ALLOC_LOG_CONF, BASIC_LOG_CONF, FORCED_LOG_CONF};

   if (pdiDevInfo == NULL)
      goto RetFALSE;


   // If this is not a PnP device, skip it
   if (!lstrcmpi(szEnumBuffer, TEXT("Root"))) {
      free(pdiDevInfo);
      goto RetTRUE;

   }

   //
   // Initialize fields inside the node
   //
   if (!InitializeInfoNode(pdiDevInfo, szDevNodeID, dnDevNode)) {
      // This is a device we don't want to list. Skip it
      free(pdiDevInfo);
      goto RetTRUE;
   }

   
   for (i = 0; i < NUM_LOG_CONF_TYPES; i++) {
      // Get logical configuration information
      cmret = CM_Get_First_Log_Conf(&lcLogConfNew,
                                    dnDevNode,
                                    ushLogConfType[i]);

      while (CR_SUCCESS == cmret) {
         lcLogConf = lcLogConfNew;

         if (ALLOC_LOG_CONF == ushLogConfType[i]) {
            boolAllocFound = TRUE;
         }

         if (!(GetResDesList(pdiDevInfo, lcLogConf, ushLogConfType[i]))) {
            goto RetFALSE;
         }

         cmret = CM_Get_Next_Log_Conf(&lcLogConfNew,
                                      lcLogConf,
                                      0);

         cmret2 = CM_Free_Log_Conf_Handle(lcLogConf);

      }
   }

   //
   // If device has no Alloc configurations, skip
   // to the next device
   //
   if (!boolAllocFound) {



      //free(pdiDevInfo);
      //goto RetTRUE;
   }

   //
   // Insert new pdiDevInfo into Linked List of DevNodes
   //
   if (g_pdiDevList == NULL) {
      //
      // DevList is empty
      //
      g_pdiDevList = pdiDevInfo;
   } else {
      //
      // Add new pdiDevInfo to beginning of linked list
      //
      pdiDevInfo->Next = g_pdiDevList;
      g_pdiDevList->Prev = pdiDevInfo;

      g_pdiDevList = pdiDevInfo;
   }

   RetTRUE:
   return TRUE;

   RetFALSE:
   return FALSE;

} 





/*++

Routine Description: (20) ParseEnumerator

   Gets devices listed under enumerator name in registry

Arguments:

    szEnumBuffer: the enumerator name

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL 
ParseEnumerator(IN PTCHAR szEnumBuffer)
{

   PTCHAR    szDevIDBuffer = NULL;
   PTCHAR    szDevNodeID = NULL;
   ULONG     ulDevIDBufferLen = 0, ulCount = 0, ulStart = 0;
   CONFIGRET cmret = CR_SUCCESS;
   DEVNODE   dnDevNode;
   BOOL      bReturn = TRUE;

   //
   // Get buffer length
   //
   cmret = CM_Get_Device_ID_List_Size(&ulDevIDBufferLen,
                                      szEnumBuffer,
                                      CM_GETIDLIST_FILTER_ENUMERATOR);

   if (CR_SUCCESS != cmret) {
      //ErrorLog(20, TEXT("CM_Get_Device_ID_List_Size"), cmret, NULL);
      bReturn = FALSE;
      goto RetFALSE;
   }

   if ((szDevIDBuffer =(PTCHAR) malloc(sizeof(TCHAR) * ulDevIDBufferLen)) == NULL ||
       (szDevNodeID   =(PTCHAR) malloc(sizeof(TCHAR) * ulDevIDBufferLen)) == NULL) {
      bReturn = FALSE;
      goto RetFALSE;
   }

   //
   // Get the Device ID List
   //
   cmret = CM_Get_Device_ID_List(szEnumBuffer,
                                 szDevIDBuffer,
                                 ulDevIDBufferLen,
                                 CM_GETIDLIST_FILTER_ENUMERATOR);

   if (CR_SUCCESS != cmret) {
      //ErrorLog(20, TEXT("CM_Get_Device_ID_List"), cmret, NULL);
      bReturn = FALSE;
      goto RetFALSE;
   }

   //
   // Note that ulDevIDBufferLen is a loose upper bound. The API may have
   // returned a size greater than the actual size of the list of strings.
   //
   for (ulCount = 0; ulCount < ulDevIDBufferLen; ulCount++) {
      ulStart = ulCount;

      if (szDevIDBuffer[ulCount] != '\0') {
         cmret = CM_Locate_DevNode(&dnDevNode,
                                   szDevIDBuffer + ulCount,
                                   CM_LOCATE_DEVNODE_NORMAL);

         //
         // Go to the next substring
         //
         while (szDevIDBuffer[ulCount] != TEXT('\0')) {
            ulCount++;

         }
         // Stop when we reach the double-NULL terminator

         if (szDevIDBuffer[ulCount+1] == TEXT('\0')) {
            ulCount=ulDevIDBufferLen;
            continue;
         }

         if (cmret == CR_SUCCESS) {
            _tcsncpy(szDevNodeID, szDevIDBuffer + ulStart, ulDevIDBufferLen);

            // Found the DevNode, so add its information to the device list
            if (!(GetDevNodeInfoAndCreateNewDevInfoNode(dnDevNode,
                                                        szDevNodeID,
                                                        szEnumBuffer))) {
               bReturn = FALSE;
               goto RetFALSE;
            }
         }
      }
   }

   bReturn = TRUE;
RetFALSE:
      // fix to rajeshm old code. Selective free bug number 137987
      if (NULL != szDevIDBuffer)
         free (szDevIDBuffer);
      if (NULL != szDevNodeID)
         free (szDevNodeID);
   return bReturn;
} 




void 
CollectDevData() {


   CONFIGRET cmret = CR_SUCCESS;
   ULONG     ulIndexNum = 0;
   ULONG     ulEnumBufferLen = 0;
   PTCHAR    szEnumBuffer;

   szEnumBuffer = (PTCHAR) malloc(sizeof(TCHAR) * MAX_DEVNODE_ID_LEN);

   if (NULL == szEnumBuffer)
      return;

   for (ulIndexNum = 0; cmret == CR_SUCCESS; ulIndexNum++) {

      ulEnumBufferLen = MAX_DEVNODE_ID_LEN;
      cmret = CM_Enumerate_Enumerators( ulIndexNum,
                                        szEnumBuffer,
                                        &ulEnumBufferLen,
                                        0);
      if (cmret == CR_SUCCESS)
         ParseEnumerator(szEnumBuffer);
   }

   free (szEnumBuffer);
}



BOOL CopyRegistryLine(IN DEVNODE   dnDevNode,
                      IN ULONG     ulPropertyType,
                      IN PDEV_INFO pdiDevInfo)

/*++

Routine Description: (22) CopyRegistryLine

   Copies one specific string of registry data to new list node

Arguments:

    dnDevNode:      the device to get information about
    ulpropertyType: which registry string to get
    pdiDevInfo:     the new list node

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
{
   ULONG     ulRegDataLen = 0, ulRegDataType = 0;
   CONFIGRET cmret = CR_SUCCESS;
   PTCHAR    szRegData = NULL;

   //
   // Get the length of the buffer  don't bother checking return value
   // If RegProperty doesn't exist, we'll just move on
   //
   CM_Get_DevNode_Registry_Property(dnDevNode,
                                    ulPropertyType,
                                    NULL,
                                    NULL,
                                    &ulRegDataLen,
                                    0);

   if (!ulRegDataLen ||
       (szRegData = (PTCHAR) malloc(sizeof(TCHAR) * ulRegDataLen)) == NULL) {
      goto RetFALSE;
   }

   //
   // Now get the registry information
   //
   cmret = CM_Get_DevNode_Registry_Property( dnDevNode,
                                            ulPropertyType,
                                            &ulRegDataType,
                                            szRegData,
                                            &ulRegDataLen,
                                            0);

   if (CR_SUCCESS == cmret) {
      if (!(CopyRegDataToDevInfoNode(pdiDevInfo,
                                     ulPropertyType,
                                     szRegData))) {
         goto RetFALSE;
      }
   }

   if (szRegData == NULL) 
      free (szRegData);
   return TRUE;


   RetFALSE:
   return FALSE;

} /* CopyRegistryLine */




/*++

Routine Description: (23) CopyRegDataToDevInfoNode

   Copies a registry string to a list node

Arguments:

    pdiDevInfo:     the new list node
    ulPropertyType: which registry string to copy
    szRegData:      the data to be copied

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL CopyRegDataToDevInfoNode(IN OUT PDEV_INFO pdiDevInfo,
                              IN     ULONG     ulPropertyType,
                              IN     PTCHAR    szRegData)
{
   if (pdiDevInfo == NULL) {
      goto RetFALSE;
   }

   switch (ulPropertyType) {
   case CM_DRP_DEVICEDESC:

      _tcsncpy(pdiDevInfo->szDescription, szRegData, MAX_PATH );
      break;

   case CM_DRP_HARDWAREID:

      _tcsncpy(pdiDevInfo->szHardwareID, szRegData, MAX_PATH );
      break;

   case CM_DRP_SERVICE:

      _tcsncpy(pdiDevInfo->szService, szRegData, MAX_PATH );
      break;

   case CM_DRP_CLASS:

      _tcsncpy(pdiDevInfo->szClass, szRegData, MAX_PATH );
      break;

   case CM_DRP_MFG:

      _tcsncpy(pdiDevInfo->szManufacturer, szRegData, MAX_PATH );
      break;

   case CM_DRP_CONFIGFLAGS:

      _tcsncpy(pdiDevInfo->szConfigFlags, szRegData, MAX_PATH );
      break;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* CopyRegDataToDevInfoNode */




/*++

Routine Description: (58) InitializeInfoNode

   Initialized fields inside the new node

Arguments:

    pdiDevInfo:  the node
    szDevNodeID: used to find the dnDevNode in the future
    dnDevNode:   the device we're storing information about

Return Value:

    BOOL: TRUE if we should keep this node, FALSE if we should throw it away

--*/
BOOL InitializeInfoNode(IN PDEV_INFO pdiDevInfo,
                        IN PTCHAR    szDevNodeID,
                        IN DEVNODE   dnDevNode)
{
   if (pdiDevInfo) {
      pdiDevInfo->Next = NULL;
      pdiDevInfo->Prev = NULL;

      pdiDevInfo->szDevNodeID[0]    = TEXT('\0');
      pdiDevInfo->szDescription[0]  = TEXT('\0');
      pdiDevInfo->szHardwareID[0]   = TEXT('\0');
      pdiDevInfo->szService[0]      = TEXT('\0');
      pdiDevInfo->szClass[0]        = TEXT('\0');
      pdiDevInfo->szManufacturer[0] = TEXT('\0');
      pdiDevInfo->szConfigFlags[0]  = TEXT('\0');
      pdiDevInfo->szFriendlyName[0] = TEXT('\0');

      pdiDevInfo->boolSavedOrigConfiguration = FALSE;
      pdiDevInfo->boolDisabled = FALSE;

      pdiDevInfo->prddForcedResDesData = NULL;
      pdiDevInfo->prddAllocResDesData  = NULL;
      pdiDevInfo->prddBasicResDesData  = NULL;
      pdiDevInfo->prddBootResDesData   = NULL;

      //
      // Store devNodeID in pdiDevInfo to get handles to devnode in future
      //
      _tcsncpy(pdiDevInfo->szDevNodeID, szDevNodeID, MAX_PATH);

      // Extract information from the registry about this DevNode
      CopyRegistryLine(dnDevNode, CM_DRP_DEVICEDESC,  pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_HARDWAREID,  pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_SERVICE,     pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_CLASS,       pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_MFG,         pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_CONFIGFLAGS, pdiDevInfo);

      RecordFriendlyName(pdiDevInfo);
   }

   //
   // Check the friendly name to see if we want to throw this node away
   //
   if (strcmp(pdiDevInfo->szFriendlyName, "STORAGE/Volume") == 0 ||
       strcmp(pdiDevInfo->szFriendlyName, "Unknown Device") == 0) {
      return FALSE;
   }

   return TRUE;

} /* InitializeInfoNode */




/*++

Routine Description: (57) RecordFriendlyName

   Finds the best user friendly name for this device

Arguments:

    pdiDevInfo: node containing all possible names

Return Value:

    void

--*/
void 
RecordFriendlyName(IN PDEV_INFO pdiDevInfo)
{
   
   if (pdiDevInfo) {
      
      if (pdiDevInfo->szDescription && pdiDevInfo->szDescription[0] != TEXT('\0'))

         _tcsncpy(pdiDevInfo->szFriendlyName, pdiDevInfo->szDescription, MAX_PATH );
      
      else if (pdiDevInfo->szHardwareID && pdiDevInfo->szHardwareID[0] != TEXT('\0')) 
         
         _tcsncpy(pdiDevInfo->szFriendlyName, pdiDevInfo->szHardwareID, MAX_PATH);
      
      else if (pdiDevInfo->szManufacturer && pdiDevInfo->szManufacturer[0] != TEXT('\0')) 
         
         _tcsncpy(pdiDevInfo->szFriendlyName, pdiDevInfo->szHardwareID, MAX_PATH);
      
      else if (pdiDevInfo->szService && pdiDevInfo->szService[0] != TEXT('\0')) 
         
         _tcsncpy(pdiDevInfo->szFriendlyName, pdiDevInfo->szService, MAX_PATH);
      
      else if (pdiDevInfo->szClass && pdiDevInfo->szClass[0] != TEXT('\0')) 
         
         _tcsncpy(pdiDevInfo->szFriendlyName, pdiDevInfo->szClass, MAX_PATH);
      
      else 
         _tcscpy(pdiDevInfo->szFriendlyName, TEXT("Unknown Device"));
   }
} /* RecordFriendlyName */







/*++

Routine Description: (24) GetResDesList

   Creates new resource data node and copies resource information to that node

Arguments:

    pdiDevInfo:    the list node which will contain the new resource node
    lcLogConf:     the logical configuration information
    ulLogConfType: FORCED, ALLOC, BOOT, or BASIC logical configuration

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL 
GetResDesList(IN OUT PDEV_INFO pdiDevInfo,
              IN     LOG_CONF  lcLogConf,
              IN     ULONG     ulLogConfType) 
{
   CONFIGRET     cmret, cmret2;
   RES_DES       rdResDes = 0, rdResDesNew;
   RESOURCEID    ridResourceID = 0;
   PRES_DES_DATA prddResDesData;

   prddResDesData = (PRES_DES_DATA)malloc(sizeof(RES_DES_DATA));

   if (prddResDesData == NULL)
      goto c0;
   
   prddResDesData->Next = NULL;
   prddResDesData->Prev = NULL;
   prddResDesData->pmresMEMResource = NULL;
   prddResDesData->piresIOResource = NULL;
   prddResDesData->pdresDMAResource = NULL;
   prddResDesData->pqresIRQResource = NULL;


   cmret = CM_Get_Next_Res_Des(&rdResDesNew,
                               lcLogConf,
                               ResType_All,
                               &ridResourceID,
                               0);

   //
   // Go through each resource type and copy data to new node
   //
   while (CR_SUCCESS == cmret) {
      rdResDes = rdResDesNew;

      if (ridResourceID >= ResType_Mem && ridResourceID <= ResType_IRQ) {
         if (!(ProcessResDesInfo(prddResDesData,
                                 rdResDes,
                                 ridResourceID))) {
            goto c1;
         }
      }

      cmret = CM_Get_Next_Res_Des(&rdResDesNew,
                                  rdResDes,
                                  ResType_All,
                                  &ridResourceID,
                                  0);

      cmret2 = CM_Free_Res_Des_Handle(rdResDes);

      if (cmret2 != CR_SUCCESS) {
         //ErrorLog(24, TEXT("CM_Free_Res_Des_Handle"), cmret2, NULL);
      }
   }
   
   // Add the new node to the linked list
   switch (ulLogConfType) {
   case FORCED_LOG_CONF:

      if (!pdiDevInfo->prddForcedResDesData) {
         //
         // This is the first entry into the linked list
         //
         pdiDevInfo->prddForcedResDesData = prddResDesData;
      } else {
         //
         // Add new node to beginning of linked list
         //
         prddResDesData->Next = pdiDevInfo->prddForcedResDesData;
         pdiDevInfo->prddForcedResDesData->Prev = prddResDesData;

         pdiDevInfo->prddForcedResDesData = prddResDesData;
      }
      break;

   case ALLOC_LOG_CONF:

      if (!pdiDevInfo->prddAllocResDesData) {
         //
         // This is the first entry into the linked list
         //
         pdiDevInfo->prddAllocResDesData = prddResDesData;
      } else {
         //
         // Add new node to beginning of linked list
         //
         prddResDesData->Next = pdiDevInfo->prddAllocResDesData;
         pdiDevInfo->prddAllocResDesData->Prev = prddResDesData;

         pdiDevInfo->prddAllocResDesData = prddResDesData;
      }
      break;

   case BASIC_LOG_CONF:

      if (!pdiDevInfo->prddBasicResDesData) {
         //
         // This is the first entry into the linked list
         //
         pdiDevInfo->prddBasicResDesData = prddResDesData;
      } else {
         //
         // Add new node to beginning of linked list
         //
         prddResDesData->Next = pdiDevInfo->prddBasicResDesData;
         pdiDevInfo->prddBasicResDesData->Prev = prddResDesData;

         pdiDevInfo->prddBasicResDesData = prddResDesData;
      }
      break;

   case BOOT_LOG_CONF:

      if (!pdiDevInfo->prddBootResDesData) {
         //
         // This is the first entry into the linked list
         //
         pdiDevInfo->prddBootResDesData = prddResDesData;
      } else {
         //
         // Add new node to beginning of linked list
         //
         prddResDesData->Next = pdiDevInfo->prddBootResDesData;
         pdiDevInfo->prddBootResDesData->Prev = prddResDesData;

         pdiDevInfo->prddBootResDesData = prddResDesData;
      }
      break;
   default:
      goto c1;
   }
   return TRUE;

   c1:
   free(prddResDesData);
   c0:
   return FALSE;

}


/* GetResDestList */

/*++

Routine Description: (25) ProcessResDesInfo

   Gets information for one resource descriptor

Arguments:

    prddResDesData: the new resource data node receiving the info
    rdResDes:       the resource descriptor containing the info
    ridResourceID:  tells the resource type (DMA, IO, MEM, IRQ, or CS)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL 
ProcessResDesInfo(IN OUT PRES_DES_DATA prddResDesData,
                  IN     RES_DES       rdResDes,
                  IN     RESOURCEID    ridResourceID)
{
   PVOID     pvResDesDataBuffer = NULL;
   ULONG     ulResDesDataBufferLen;
   CONFIGRET cmret;

   cmret = CM_Get_Res_Des_Data_Size(&ulResDesDataBufferLen,
                                    rdResDes,
                                    0);

   if (CR_SUCCESS != cmret) {
      //ErrorLog(25, TEXT("CM_Get_Res_Des_Data_Size"), cmret, NULL);
      goto RetFALSE;
   }

   if ((pvResDesDataBuffer = malloc(sizeof(PVOID) * ulResDesDataBufferLen))
       == NULL) {
//      Log(25, SEV2, TEXT("resDesDataBuffer malloc size of %d failed."),
      //                  ulResDesDataBufferLen);
      goto RetFALSE;
   }

   //
   // Get the data
   //
   cmret = CM_Get_Res_Des_Data(rdResDes,
                               pvResDesDataBuffer,
                               ulResDesDataBufferLen,
                               0);

   if (CR_SUCCESS != cmret) {
      //ErrorLog(25, TEXT("CM_Get_Res_Des_Data"), cmret, NULL);
      goto RetFALSE;
   }

   //
   // Copy data into ResDesData node
   //
   switch (ridResourceID) {
   case ResType_Mem:

      prddResDesData->pmresMEMResource = (PMEM_RESOURCE)pvResDesDataBuffer;
      break;

   case ResType_IO:

      prddResDesData->piresIOResource = (PIO_RESOURCE)pvResDesDataBuffer;
      break;

   case ResType_DMA:

      prddResDesData->pdresDMAResource = (PDMA_RESOURCE)pvResDesDataBuffer;
      break;

   case ResType_IRQ:

      prddResDesData->pqresIRQResource = (PIRQ_RESOURCE)pvResDesDataBuffer;
      break;

   default:

//         Log(25, SEV2, TEXT("Illegal ResourceID - %ul"), ridResourceID);
      goto RetFALSE;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* ProcessResDesInfo */




/*++

Routine Description: (26) UpdateDeviceList

    Frees resource information for all devices and then collects the
    information again

Arguments:

    none (g_pdiDevList is global head of device list)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL UpdateDeviceList()
{
   PDEV_INFO pdiTmpDevInfo;

   pdiTmpDevInfo = g_pdiDevList;

   //
   // Go through linked list and delete each node's ResDes lists
   //
   while (pdiTmpDevInfo) {
      if (pdiTmpDevInfo->prddForcedResDesData) {
         DeleteResDesDataNode(pdiTmpDevInfo->prddForcedResDesData);
         pdiTmpDevInfo->prddForcedResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddAllocResDesData) {
         DeleteResDesDataNode(pdiTmpDevInfo->prddAllocResDesData);
         pdiTmpDevInfo->prddAllocResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddBasicResDesData) {
         DeleteResDesDataNode(pdiTmpDevInfo->prddBasicResDesData);
         pdiTmpDevInfo->prddBasicResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddBootResDesData) {
         DeleteResDesDataNode(pdiTmpDevInfo->prddBootResDesData);
         pdiTmpDevInfo->prddBootResDesData = NULL;
      }

      pdiTmpDevInfo = pdiTmpDevInfo->Next;
   }

   pdiTmpDevInfo = g_pdiDevList;

   //
   // Recreate the ResDesLists for each node
   //
   while (pdiTmpDevInfo) {
      if (!(RecreateResDesList(pdiTmpDevInfo, FORCED_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, ALLOC_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, BASIC_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, BOOT_LOG_CONF)))
         goto RetFALSE;

      pdiTmpDevInfo = pdiTmpDevInfo->Next;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* UpdateDeviceList */




/*++

Routine Description: (27) DeleteResDesDataNode

    Deletes a string of RES_DES_DATA structures

Arguments:

    prddTmpResDes: the head of the linked list

Return Value:

    void

--*/
void 
DeleteResDesDataNode(IN PRES_DES_DATA prddTmpResDes)
{
   PRES_DES_DATA prddNextResDes;

   while (prddTmpResDes) {
      prddNextResDes = prddTmpResDes->Next;

      free (prddTmpResDes);
      prddTmpResDes = prddNextResDes;
   }

} /* DeleteResDesDataNode */





/*++

Routine Description: (56) CopyDataToLogConf

   Calls CM_Add_Res_Des to add a resDes to a lcLogConf

Arguments:

    lcLogConf:     the lcLogConf receiving the resDes
    ridResType:    ResType_Mem, IO, DMA or IRQ
    pvResData:     the new data
    ulResourceLen: size of the data

Return Value:

    BOOL: TRUE if the CM call succeeds, FALSE if not

--*/
BOOL 
CopyDataToLogConf(IN LOG_CONF   lcLogConf,
                  IN RESOURCEID ridResType,
                  IN PVOID      pvResData,
                  IN ULONG      ulResourceLen)
{
   CONFIGRET cmret;
   RES_DES   rdResDes;

   //
   // Copy the data to the logConf
   //
   cmret = CM_Add_Res_Des(&rdResDes,
                          lcLogConf,
                          ridResType,
                          pvResData,
                          ulResourceLen,
                          0);

   if (CR_SUCCESS != cmret) {

      goto RetFALSE;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* CopyDataToLogConf */



/*++

Routine Description: (28) RecreateResDesList

    Uses CM calls to find ResDes information and creates linked list
    of this information inside of given DEV_INFO

Arguments:

    pdiTmpDevInfo: the node receiving the information
    ulLogConfType: the LogConf type (FORCED_LOG_CONF,
                                     ALLOC_LOG_CONF,
                                     BASIC_LOG_CONF,
                                     BOOT_LOG_CONF)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL 
RecreateResDesList(IN OUT PDEV_INFO pdiTmpDevInfo,
                   IN     ULONG     ulLogConfType)
{
   CONFIGRET cmret, cmret2;
   DEVNODE   dnDevNode;
   LOG_CONF  lcLogConf, lcLogConfNew;

   //
   // Get handle to the devnode
   //
   cmret = CM_Locate_DevNode(&dnDevNode,
                             pdiTmpDevInfo->szDevNodeID,
                             CM_LOCATE_DEVNODE_NORMAL);

   if (CR_SUCCESS != cmret) {
      //ErrorLog(28, TEXT("CM_Locate_DevNode"), cmret, NULL);
      goto RetFALSE;
   }

   //
   // Get logical configuration information
   //
   cmret = CM_Get_First_Log_Conf(&lcLogConfNew,
                                 dnDevNode,
                                 ulLogConfType);

   while (CR_SUCCESS == cmret) {
      lcLogConf = lcLogConfNew;

      if (!(GetResDesList(pdiTmpDevInfo, lcLogConf, ulLogConfType))) {
         goto RetFALSE;
      }

      cmret = CM_Get_Next_Log_Conf(&lcLogConfNew,
                                   lcLogConf,
                                   0);

      cmret2 = CM_Free_Log_Conf_Handle(lcLogConf);

      if (CR_SUCCESS != cmret2) {
         //ErrorLog(28, TEXT("CM_Free_Log_Conf"), cmret2, NULL);
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* RecreateResDesList */





void Cleanup()
{
   PDEV_INFO pdiDevInfo = g_pdiDevList;
   PDEV_INFO pdiNextInfoNode;



   while (pdiDevInfo) {

      pdiNextInfoNode = pdiDevInfo->Next;

      DeleteResDesDataNode(pdiDevInfo->prddForcedResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddAllocResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddBasicResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddBootResDesData);

      free(pdiDevInfo);

      pdiDevInfo = pdiNextInfoNode;
   }

} /* Cleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\netinfo.h ===
#define BUFFER_LEN         200
#define REG_STR_LEN        100
#define NUM_LOG_CONF_TYPES 4
#define MAX_STR_LEN        300

typedef DWORD NEXTRET;

#define NR_SUCCESS 0x00000000
#define NR_DONE    0x00000001  // no more configurations
#define NR_INVALID 0x00000002  // invalid previous configuration

//
// Structures
//

//
// Stores information about a device's resource descriptors
//
typedef struct _RES_DES_DATA
{
   struct _RES_DES_DATA *Next;
   struct _RES_DES_DATA *Prev;

   PMEM_RESOURCE pmresMEMResource;
   PIO_RESOURCE  piresIOResource;
   PDMA_RESOURCE pdresDMAResource;
   PIRQ_RESOURCE pqresIRQResource;
} RES_DES_DATA, *PRES_DES_DATA;


//
// Stores registry and resource information about a device
//
typedef struct _DEV_INFO
{
   struct _DEV_INFO *Next;
   struct _DEV_INFO *Prev;

   TCHAR szDevNodeID  [ MAX_PATH ];
   TCHAR szDescription[ MAX_PATH ];
   TCHAR szHardwareID [ MAX_PATH ];
   TCHAR szService    [ MAX_PATH ];
   TCHAR szClass      [ MAX_PATH ];
   TCHAR szManufacturer[ MAX_PATH ];
   TCHAR szConfigFlags [ MAX_PATH ];
   TCHAR szFriendlyName[ MAX_PATH ];

   PRES_DES_DATA prddForcedResDesData;
   PRES_DES_DATA prddAllocResDesData;
   PRES_DES_DATA prddBasicResDesData;
   PRES_DES_DATA prddBootResDesData;

   DEVNODE dnParent;

   RES_DES_DATA rddOrigConfiguration;
   BOOL boolSavedOrigConfiguration;

   BOOL boolConfigurable;
   BOOL boolDisabled;

} DEV_INFO, *PDEV_INFO;
void CollectDevData();

BOOL ParseEnumerator(IN PTCHAR szEnumBuffer);

BOOL GetDevNodeInfoAndCreateNewDevInfoNode(IN DEVNODE dnDevNode,
                                           IN PTCHAR  szDevNodeID,
                                           IN PTCHAR  szEnumBuffer);

BOOL CopyRegistryLine(IN DEVNODE   dnDevNode,
                      IN ULONG     ulPropertyType,
                      IN PDEV_INFO pdiDevInfo);

BOOL CopyRegDataToDevInfoNode(IN OUT PDEV_INFO pdiDevInfo,
                              IN     ULONG     ulPropertyType,
                              IN     PTCHAR    szRegData);


BOOL InitializeInfoNode(IN PDEV_INFO pdiDevInfo,
                        IN PTCHAR    szDevNodeID,
                        IN DEVNODE   dnDevNode);

void RecordFriendlyName(IN PDEV_INFO pdiDevInfo);

BOOL SaveAndDeletePreviousForcedLogConf(IN  LOG_CONF  lcLogConf,
                                        OUT PDEV_INFO pdiDevInfo);

BOOL GetResDesList(IN OUT PDEV_INFO pdiDevInfo,
                   IN     LOG_CONF  lcLogConf,
                   IN     ULONG     ulLogConfType);

BOOL ProcessResDesInfo(IN OUT PRES_DES_DATA prddResDesData,
                       IN     RES_DES       rdResDes,
                       IN     RESOURCEID    ridResourceID);

BOOL UpdateDeviceList();

void DeleteResDesDataNode(IN PRES_DES_DATA prddTmpResDes);

BOOL RecreateResDesList(IN OUT PDEV_INFO pdiTmpDevInfo,
                        IN     ULONG     ulLogConfType);

void Cleanup();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by idwlog.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\network.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Filename :

        Network.h

Abstract:

        Header for Network
	
Author:

        Wally Ho (wallyho) 31-Jan-2000

Revision History:
   Created
	
 --*/

// Definition of constants 

#ifndef NETWORK_H
#define NETWORK_H
#include <windows.h>
#include <stdlib.h> 
#include <malloc.h>
#include "machines.h"



typedef struct _INSTALL_DATA {

   // ComputerName WALLYHO_DEV
   // SystemBuild 2190
   // InstallingBuild 2195
   // MachineID 3212115354 
   // Cdrom YES|NO
   // Network YES|NO
   // Type CLEAN|UPGRADE
   // Msi N

   TCHAR szComputerName[50];
   TCHAR szUserName[30];
   TCHAR szUserDomain[30];
   DWORD dwSku;

   // Added because of DTC functionality.
   DWORD dwSystemMajorVersion;
   DWORD dwSystemMinorVersion;
   DWORD dwSystemBuild;
   DWORD dwSystemBuildDelta;
   DWORD dwSystemSPBuild;
   TCHAR szSystemBuildSourceLocation[100];

   DWORD dwInstallingMajorVersion;
   DWORD dwInstallingMinorVersion;
   DWORD dwInstallingBuild;
   DWORD dwInstallingBuildDelta;
   DWORD dwInstallingSPBuild;
   TCHAR szInstallingBuildSourceLocation[100];

   
   DWORD dwMachineID;
   BOOL  bCancel;
   BOOL  bHydra;   
   BOOL  bCdrom;
   BOOL  bNetwork;
   BOOL  bClean;
   BOOL  bUpgrade;
   BOOL  bMsi;
   TCHAR szSPMethod[MAX_PATH];		// sp_patch, sp_full, sp_remove, sp_update
   BOOL	 bSPUninst;
   BOOL  bSPPatch;
   BOOL  bSPFull;
   BOOL  bSPUpdate;
   BOOL  bOEMImage;
   
   // Other data.
   TCHAR  szCpu[6];
   TCHAR  szArch[20];
   TCHAR  szPlatform[40];
   TCHAR  szIdwlogServer[200];
   TCHAR  szLocaleId[4]; // locale abbreviation
   BOOL   bIsServerOnline;
   UINT   iStageSequence;
   BOOL   bFindBLDFile;
   BOOL   bCDBootInstall;
   LPTSTR szServerData;
} INSTALL_DATA, *LPINSTALL_DATA;



FILE* OpenCookieFile(VOID);

VOID  CloseCookieFile(IN FILE* fpOpenFile);

VOID  DeleteCookieFile( VOID );

BOOL  WriteIdwlogCookie( IN  LPINSTALL_DATA pId);

BOOL  ReadIdwlogCookie ( OUT LPINSTALL_DATA lpId);

BOOL  ServerWriteMinimum  (LPINSTALL_DATA pId,
                           LPMACHINE_DETAILS pMd);

BOOL  ServerWriteMaximum (LPINSTALL_DATA pId,
                          LPMACHINE_DETAILS pMd);
DWORD WINAPI WriteThread(IN LPINSTALL_DATA pId);


VOID  DeleteIPCConnections( VOID );
VOID  DeleteDatafile (LPINSTALL_DATA);
BOOL  FileExistsEx( IN  LPTSTR szFileName);


BOOL  WriteDataToAvailableServer (LPINSTALL_DATA pId,
                                  LPTSTR szServerData);

BOOL  SetCancelMutex ( VOID );
BOOL  ClearCancelMutex ( VOID );
BOOL  PauseForMutex( VOID );

BOOL  SetInstanceMutex ( VOID );

BOOL  ClearInstanceMutex ( VOID );

//
// Global declarations:
// The INSTALL_DATA to be passed to the worker threads
// Replaces id in idwlog.cpp, winmain()
// 
extern INSTALL_DATA g_InstallData;
//
// Replaces szServerData in network.cpp, ServerWriteMinimum() and
// ServerWriteMaximum()
//
extern TCHAR        g_szServerData[4096];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\servers.cpp ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include "machines.h"
#include "network.h"
#include "server.h"
#include "idw_dbg.h"
/*++

   Filename :  servers.c

   Description: This file will be for testing the servers access.


   Created by:  Wally Ho

   History:     Created on 03/29/99.

	09.14.2001	Joe Holman	Bug fixes for:

		399178	Test Tools	Triage	joehol	2	chuckco	STRESS: idwlog doesn't check for the validity of the handle coming back from CreateProcess
		409338	Test Tools	NtStress	joehol	2	daviea	STRESS:IdwLog - global file pointer becomes NULL and idwlog dies in crt call
	09.19.2001	Joe Holman	fixes for idwlog bugs 409338, 399178, and 352810
	10.07.2001	Joe Holman	Structure sometimes not filled in with Server name, so use global.




   Contains these functions:

   1. IsServerOnline       (IN LPTSTR szMachineName)
   2. ServerOnlineThread   (IN LPTSTR szServerFile)


--*/


BOOL
IsServerOnline(IN LPINSTALL_DATA pId,
               IN LPTSTR szSpecifyShare)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    03/29/99
   
   Routine Description:
      This will go through the list of servers specified in server.h
      It will return the first in it sees and reset the server share
      name in the LPINSTALL_DATA struct.
       
   Arguments:
      The LPINSTALL_DATA structure with the servername.
      Manual Server Name: NULL will give default behaviour.

   Return Value:
	TRUE for success.
   FALSE for no name.

--*/
{
   
   HANDLE   hThrd[NUM_SERVERS];
   DWORD    dw[NUM_SERVERS];
   DWORD    dwExitCode;

   INT      i;
   DWORD    dwTimeOutInterval;

   BOOL		b;

   Idwlog(TEXT("Entered IsServerOnLine().\n"));

   // This should allow for a 
   // manually specified server.
   if (NULL != szSpecifyShare){
       _tcscpy(pId->szIdwlogServer,szSpecifyShare);

      Idwlog(TEXT("Returning IsServerOnLine() as FALSE (no name).\n"));

      return TRUE;
   }


   //make certain. The zeromemory we did should have set this.
   pId->bIsServerOnline = FALSE;

   // Initialize the Server.
   // Variable. Since we are using a single thread
   // to do a time out we don't care about mutexes and
   // sychronization.
   i = 0;

#define TTEST
#ifdef TTEST

	while ( i < NUM_SERVERS) {

		Idwlog(TEXT("IsServerOnLine - Trying connection to the server (i=%d,%d) %s.\n"), i, NUM_SERVERS, g_ServerBlock[i].szSvr);

		b = ServerOnlineThread ( (LPSERVERS)&g_ServerBlock[i] );

		if ( b ) {

			_tcscpy(pId->szIdwlogServer,g_ServerBlock[i].szSvr);
         		pId->bIsServerOnline = TRUE;
         	

         		Idwlog(TEXT("Returning IsServerOnLine() TRUE due to online of: %s.\n"), pId->szIdwlogServer );
         		return TRUE;

		}

		++i;	// try next server

	}

	Idwlog(TEXT("Returning IsServerOnLine() as FALSE (no name).\n"));
   	return FALSE;

#endif // TTEST

   
   while ( i < NUM_SERVERS) {

      hThrd[i] = NULL;
      Idwlog(TEXT("IsServerOnLine - Making connection to the server (i=%d,%d) %s.\n\n"), i, NUM_SERVERS, g_ServerBlock[i].szSvr);
      hThrd[i]  = CreateThread(NULL,
                               0,
                               (LPTHREAD_START_ROUTINE) ServerOnlineThread,
                               (LPSERVERS)&g_ServerBlock[i],
                               0,
                               &dw[i]);


      if ( hThrd[i] == NULL ) {

	Idwlog(TEXT("IsServerOnLine - ERROR CreateProcess: gle=%ld.\n"), GetLastError());
	++i;
	continue;

      }

      // This is in milli seconds so the time out is secs.
      dwTimeOutInterval = TIME_TIMEOUT * 1000;
      g_ServerBlock[i].dwTimeOut = WaitForSingleObject (hThrd[i], dwTimeOutInterval);

      // This means the server was found and the timeout did not expire.
      if (g_ServerBlock[i].dwTimeOut != WAIT_TIMEOUT &&
          g_ServerBlock[i].bOnline == TRUE) {
         
         _tcscpy(pId->szIdwlogServer,g_ServerBlock[i].szSvr);
         pId->bIsServerOnline = TRUE;
         if (hThrd[i] != NULL) {
            CloseHandle (hThrd[i]);
            hThrd[i] = NULL;
         }

         Idwlog(TEXT("Returning IsServerOnLine() TRUE.\n"));
         return TRUE;
      } else {


         // We'll make sure the threads are killed so that we don't have a a race condition.
         Idwlog(TEXT("ServerOnlineTest: We could not connect to Server:  %s\n"), /*pId->szIdwlogServer*/ g_ServerBlock[i].szSvr );
         // Exit the thread
         if (FALSE == GetExitCodeThread(hThrd[i],&dwExitCode))
            Idwlog(TEXT("IsServerOnLine - Failed to exit the server probe thread.\n"));
         else {
            // Don't terminate the thread yet...
            // TerminateThread(hThrd[i], dwExitCode);
            Idwlog(TEXT("IsServerOnLine - Timed out thread: %lu \n"), hThrd[i]);
         }
         CloseHandle (hThrd[i]);
         hThrd[i] = NULL;
      }
      i++;
   }

   Idwlog(TEXT("Returning IsServerOnLine() as FALSE (no name).\n"));
   return FALSE;
}


DWORD WINAPI 
ServerOnlineThread( IN LPSERVERS pServerBlock)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    03/29/99

   Routine Description:
      This create a thread and then time it out to see if we can get to
      a server faster.  
   Arguments:
       A server Block

   Return Value:
      TRUE for  success.
      FALSE for failure.
--*/
{

   BOOL        bCopy = FALSE;
   TCHAR       szServerTestFile [MAX_PATH];
   TCHAR       szRemoteName [MAX_PATH];
   HANDLE      hServerTest;
   NETRESOURCE NetResource ;
   DWORD       dwError;
   TCHAR       szPassWord  [ MAX_PATH ] = "\0";
   TCHAR       szUserId    [ MAX_PATH ] = "\0";
   LPTSTR      p;

   Idwlog(TEXT("\n\nEntered ServerOnLineThread().\n\n"));

   // RemoteName is the server name alone without the share.
   // pServerBlock->szSvr comes in as \\idwlog\idwlogwhstl
   // make it idwlog only..
   _tcscpy(szRemoteName, pServerBlock->szSvr);
   
   if (szRemoteName){
      *_tcsrchr(szRemoteName,TEXT('\\')) = TEXT('\0'); 
       p = szRemoteName + 2;
   }


   // Let try to create the test file as the current logged-on user.
   // We don't expect every user to be able to connect in every domain.
   //


   _stprintf (szServerTestFile, TEXT("%s\\TST%lu.TST"), pServerBlock->szSvr, RandomMachineID());

   Idwlog(TEXT("ServerOnLineThread - Try to create test file with logged-on user: %s.\n"), szServerTestFile );

   hServerTest = CreateFile( szServerTestFile,
                             GENERIC_WRITE,
                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL| FILE_FLAG_WRITE_THROUGH,
                             NULL );

   if ( hServerTest != INVALID_HANDLE_VALUE ){
      
      		// Flush the buffers to make sure it all makes it to the drive.
      		FlushFileBuffers(hServerTest);
      
      		Idwlog(TEXT("ServerOnlineThread - Createfile success with specific user.\n"));
      		// If succeeded delete the test file.
      		CloseHandle( hServerTest );

      		SetFileAttributes(szServerTestFile,FILE_ATTRIBUTE_NORMAL);
      		DeleteFile( szServerTestFile );
      		
		// Denote we have a server online.
		//
		pServerBlock->bOnline = TRUE;
      
      		Idwlog(TEXT("ServerOnLineThread - returning TRUE.\n\n"));

      		return TRUE;

   }
   else {

	Idwlog(TEXT("ServerOnLineThread - Warning Logged-on file creation test CreateFile FAILed gle = %ld.\n"), GetLastError());
   }



   // Setup the memory for the connection.
   //
   ZeroMemory( &NetResource, sizeof( NetResource ) );
   NetResource.dwType         = RESOURCETYPE_DISK ;
   NetResource.lpLocalName    = NULL;
   NetResource.lpRemoteName   = szRemoteName;
   NetResource.lpProvider     = NULL;


   Idwlog ( TEXT("ServerOnLineThread - szRemoteName=%s\n"), szRemoteName );

   // First, try to connect with the Guest Account
   _stprintf(szUserId , TEXT("%s\\Unknown"), p);
   _stprintf(szPassWord, TEXT(""));

   Idwlog(TEXT("ServerOnLineThread - First try with Guest.\n"));

   dwError = WNetAddConnection2( &NetResource, szPassWord, szUserId, 0 );

   if (NO_ERROR == dwError) {

	Idwlog(TEXT("ServerOnLineThread - WNetAddConnection2 authorized as guest on %s.\n"), pServerBlock->szSvr);

	// We connected, lets ALSO verify we can write a file.
	// 
   	_stprintf (szServerTestFile, TEXT("%s\\TST%lu.TST"), pServerBlock->szSvr, RandomMachineID());

   	hServerTest = CreateFile( szServerTestFile,
                             GENERIC_WRITE,
                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL| FILE_FLAG_WRITE_THROUGH,
                             NULL );

   	if ( hServerTest != INVALID_HANDLE_VALUE ){
      
      		// Flush the buffers to make sure it all makes it to the drive.
      		FlushFileBuffers(hServerTest);
      
      		Idwlog(TEXT("ServerOnlineThread - Createfile success with guest.\n"));
      		// If succeeded delete the test file.
      		CloseHandle( hServerTest );

      		SetFileAttributes(szServerTestFile,FILE_ATTRIBUTE_NORMAL);
      		DeleteFile( szServerTestFile );
      		
		// Denote we have a server online.
		//
		pServerBlock->bOnline = TRUE;
      
      		Idwlog(TEXT("ServerOnLineThread - returning TRUE.\n\n"));

      		return TRUE;

   	}
        else {

		Idwlog(TEXT("ServerOnLineThread - ERROR Guest file creation test CreateFile gle = %ld.\n"), GetLastError(), szServerTestFile );
	}
   }
   else {

	Idwlog(TEXT("ServerOnLineThread - ERROR Guest WNetAddConnection2 gle = %ld.\n"), dwError );

   }


   _stprintf(szUserId , TEXT("%s\\%s"), p, LOGSHARE_USER );
   _stprintf(szPassWord, TEXT("%s"), LOGSHARE_PW);

   Idwlog(TEXT("ServerOnLineThread - Second try with specific account.\n"));

   dwError = WNetAddConnection2( &NetResource, szPassWord, szUserId, 0 );
 
   if (NO_ERROR == dwError) {

	Idwlog(TEXT("ServerOnLineThread - WNetAddConnection2 authorized as specific user on %s.\n"), pServerBlock->szSvr);

	// We connected, lets ALSO verify we can write a file.
	// 
   	_stprintf (szServerTestFile, TEXT("%s\\TST%lu.TST"), pServerBlock->szSvr, RandomMachineID());

   	hServerTest = CreateFile( szServerTestFile,
                             GENERIC_WRITE,
                             FILE_SHARE_WRITE | FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL| FILE_FLAG_WRITE_THROUGH,
                             NULL );

   	if ( hServerTest != INVALID_HANDLE_VALUE ){
      
      		// Flush the buffers to make sure it all makes it to the drive.
      		FlushFileBuffers(hServerTest);
      
      		Idwlog(TEXT("ServerOnlineThread - Createfile success with specific user.\n"));
      		// If succeeded delete the test file.
      		CloseHandle( hServerTest );

      		SetFileAttributes(szServerTestFile,FILE_ATTRIBUTE_NORMAL);
      		DeleteFile( szServerTestFile );
      		
		// Denote we have a server online.
		//
		pServerBlock->bOnline = TRUE;
      
      		Idwlog(TEXT("ServerOnLineThread - returning TRUE.\n\n"));

      		return TRUE;

   	}
        else {

		Idwlog(TEXT("ServerOnLineThread - ERROR Specific user file creation test CreateFile gle = %ld, %s.\n"), GetLastError(), szServerTestFile );
	}
   }
   else {

	Idwlog(TEXT("ServerOnLineThread - ERROR Specific user WNetAddConnection2 gle = %ld.\n"), dwError );

   }

   // Must return that we couldn't authenticate and write test file in both cases.
   //
   
   Idwlog(TEXT("ServerOnLineThread - returning FALSE.\n\n"));
   return FALSE;

}


VOID
WhatErrorMessage (IN DWORD dwError)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    11/7/2000

   Routine Description:
       This gives a textual formatted message for any error code.
   Arguments:
       dword of the error code.

   Return Value:
       NONE
--*/

{

   HLOCAL hl = NULL;

/***
   BOOL b = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL, dwError, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                           (LPTSTR) &hl, 0, NULL);

   if ( NULL != hl) {
      Idwlog(TEXT("Error %.5lu: %s"), dwError, (PCTSTR) LocalLock(hl));
      LocalFree(hl);
   }

***/

    DWORD dw = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        NULL, dwError, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                        (LPTSTR) &hl, 0, NULL);

    if ( dw == 0 ) {

	Idwlog ( TEXT ( "ERROR - WhatErrorMessage's FormatMessage gle = %ld\n"), GetLastError () );

    }
    else {

	if ( NULL != hl) {

		//	Show the error message when the string got translated.
		//
    		Idwlog(TEXT("Error %.5lu: %s"), dwError, (PCTSTR) LocalLock(hl));
   		 LocalFree(hl);
	}
	else {
		
		//	Show a generic text message with the error code when we can't translate it.
		//

	 	Idwlog(TEXT("An ERROR occurred, but we are having problems getting the message for it: %x (HEX)"), dwError );
	}
    }
	

}






/*
BOOL IsMSI(VOID)
++

Routine Description:

	This will check if its an MSI install.
   It will check for the running process
   and then check for the path.

Arguments:


Return Value:

    BOOL - True if link is good. False otherwise.
--
{

	DWORD		   numTasks = 0;
	TASK_LIST	tlist[ MAX_PATH ];
   UINT        i;
   BOOL        bFound = FALSE;
   //
	//	Get the Running Tasks.
	//
	numTasks = GetTaskList(tlist, MAX_PATH);
   //
   // If the MSI process exists log it as such.
   //
   for(i = 1; i <= numTasks; i++){
      if(_tcsstr(tlist[i].ProcessName, TEXT("msiexec.exe"))){
         MessageBox(NULL,tlist[i].ProcessName, TEXT("Caption"),MB_OK);
           lpCmdFrom.b_MsiInstall = TRUE;
         return FALSE;
      }else{
           lpCmdFrom.b_MsiInstall = TRUE;
         return TRUE;
	   }
   }

   return TRUE;
}
*/

/*
DWORD
GetTaskList( PTASK_LIST  pTask,
             DWORD       dwNumTasks)

++

// Borrowed with modifications from tlist a wesw invention.

  Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses the registry performance data to get the
    task list and is therefor straight WIN32 calls that anyone can call.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--

{
    DWORD                        rc;
    HKEY                         hKeyNames;
    DWORD                        dwType;
    DWORD                        dwSize;
    LPBYTE                       buf = NULL;
    CHAR                         szSubKey[1024];
    LANGID                       lid;
    LPSTR                        p;
    LPSTR                        p2;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter;
    CHAR                         szProcessName[MAX_PATH];
    DWORD                        dwLimit = dwNumTasks - 1;



    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    sprintf( szSubKey, "%s\\%03x", REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (LPBYTE) malloc( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //
    p = buf;
    while (*p) {
        if (p > buf) {
            for( p2=p-2; isdigit(*p2); p2--) ;
        }
        if (_stricmp(p, PROCESS_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; isdigit(*p2); p2--) ;
            strcpy( szSubKey, p2+1 );
        }
        else
        if (_stricmp(p, PROCESSID_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; isdigit(*p2); p2--) ;
            dwProcessIdTitle = atol( p2+1 );
        }
        //
        // next string
        //
        p += (strlen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    free( buf );
    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = malloc( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );


    while (TRUE) {

        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              buf,
                              &dwSize
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)'P' &&
            (pPerf)->Signature[1] == (WCHAR)'E' &&
            (pPerf)->Signature[2] == (WCHAR)'R' &&
            (pPerf)->Signature[3] == (WCHAR)'F' ) {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) {
            dwSize += EXTEND_SIZE;
            buf = realloc( buf, dwSize );
            memset( buf, 0, dwSize );
        }
        else {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((DWORD*)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD *)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    dwNumTasks = min( dwLimit, (DWORD)pObj->NumInstances );

    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD*)pObj + pObj->DefinitionLength);

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //
    for (i=0; i<dwNumTasks; i++) {
        //
        // pointer to the process name
        //
        p = (LPSTR) ((DWORD*)pInst + pInst->NameOffset);

        //
        // convert it to ascii
        //
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  (LPCWSTR)p,
                                  -1,
                                  szProcessName,
                                  sizeof(szProcessName),
                                  NULL,
                                  NULL
                                );

        if (!rc) {
            //
            // if we cant convert the string then use a bogus value
            //
            strcpy( pTask->ProcessName, UNKNOWN_TASK );
        }

        if (strlen(szProcessName)+4 <= sizeof(pTask->ProcessName)) {
            strcpy( pTask->ProcessName, szProcessName );
            strcat( pTask->ProcessName, ".exe" );
        }

        //
        // get the process id
        //
        pCounter = (PPERF_COUNTER_BLOCK) ((DWORD*)pInst + pInst->ByteLength);
        pTask->flags = 0;
        pTask->dwProcessId = *((LPDWORD) ((DWORD*)pCounter + dwProcessIdCounter));
        if (pTask->dwProcessId == 0) {
            pTask->dwProcessId = (DWORD)-2;
        }

        //
        // next process
        //
        pTask++;
        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD*)pCounter + pCounter->ByteLength);
    }

exit:
    if (buf) {
        free( buf );
    }

    RegCloseKey( hKeyNames );
    RegCloseKey( HKEY_PERFORMANCE_DATA );
	//
	//	W.Ho added a minus 1 to get it to reflect the
	//	tasks properly.
	//
    return dwNumTasks -1;
}

*/



/*
typedef struct _SERVERS {
   TCHAR szSvr [ MAX_PATH ];
   BOOL  bCFTest;
   DWORD dwNetStatus;
} *LPSERVERS, SERVERS;

typedef struct _ERRMSG {
   TCHAR szMsg[ MAX_PATH ];
   DWORD dwErr;
} *LPERRMSG, ERRMSG;


BOOL
IsServerOnline(VOID)
/*++

Routine Description:


Arguments:

Return Value:
	NONE.
--
{
#define NUM_SERVERS 6

   INT   i;
   TCHAR    sz[ MAX_PATH ];
   ERRMSG e[12] = {
      {TEXT("Access is denied."), ERROR_ACCESS_DENIED},
      {TEXT("The device specified in the lpLocalName parameter is already connected."), ERROR_ALREADY_ASSIGNED  },
      {TEXT("The device type and the resource type do not match."), ERROR_BAD_DEV_TYPE},
      {TEXT("The value specified in lpLocalName is invalid."), ERROR_BAD_DEVICE},
      {TEXT("The value specified in the lpRemoteName parameter is not valid or cannot be located."), ERROR_BAD_NET_NAME},
      {TEXT("The user profile is in an incorrect format."), ERROR_BAD_PROFILE},
      {TEXT("The system is unable to open the user profile to process persistent connections."),ERROR_CANNOT_OPEN_PROFILE },
      {TEXT("An entry for the device specified in lpLocalName is already in the user profile."), ERROR_DEVICE_ALREADY_REMEMBERED},
      {TEXT("A network-specific error occurred. To get a description of the error, use the WNetGetLastError function."), ERROR_EXTENDED_ERROR},
      {TEXT("The specified password is invalid."), ERROR_INVALID_PASSWORD},
      {TEXT("The operation cannot be performed because either a network component is not started or the specified name cannot be used."),ERROR_NO_NET_OR_BAD_PATH },
      {TEXT("The network is not present."),ERROR_NO_NETWORK}
   };

   SERVERS  s[NUM_SERVERS] ={
      {TEXT("\\\\donkeykongjr\\public"), -1, -1},
      {TEXT("\\\\popcorn\\public"), -1, -1},
      {TEXT("\\\\NotExists\\idwlog"), -1, -1},
      {TEXT("\\\\Paddy\\idwlog"), -1, -1},
      {TEXT("\\\\Bear\\idwlog"), -1, -1},
      {TEXT("\\\\JustTesting\\idwlog"), -1, -1}

   };


   for (i = 0; i < 12; i++) {
      _tprintf(TEXT("Error %s  %lu\n"),e[i].szMsg, e[i].dwErr);
   }

   for (i = 0; i < NUM_SERVERS; i++){
     s[i].dwNetStatus = WNetAddConnection(TEXT("donkeykongjr\\public\0"),NULL,NULL);


     _stprintf(sz,TEXT("%s%s"),s[i].szSvr,TEXT("\\test") );
     s[i].bCFTest = CopyFile(TEXT("c:\\test"),sz,FALSE);
     _tprintf(TEXT("Did this work for %s %s %lu\n"),
         sz,
         s[i].bCFTest? TEXT("WORKED"): TEXT("FAILED"),
         s[i].dwNetStatus
         );
   }

   return FALSE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\service.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Filename:

        service.h

Abstract:

        Header for service.cpp
	

Author:

        Wally Ho (wallyho) 31-Jan-2000

Revision History:
   Created

   7/27/2000  Added new names for the service to work.
   	
--*/

#ifndef SERVICE_H
#define SERVICE_H
#include <windows.h>


   CONST LPTSTR SCM_DISPLAY_NAME = TEXT("Idwlog Service");
   CONST LPTSTR SCM_SERVICE_NAME = TEXT("Idwlog");
   


   BOOL RemoveService(LPTSTR szServiceNameSCM);

   BOOL InstallService(LPTSTR szServiceNameSCM,
                       LPTSTR szServiceLabel,
                       LPTSTR szExeFullPath);
   
   VOID  ServiceMain(DWORD argc, LPTSTR *argv);

   
   BOOL  InitService();
   VOID  ResumeService();
   VOID  PauseService();
   VOID  StopService();

   BOOL  SendStatusToSCM ( DWORD dwCurrentState,
                           DWORD dwWin32ExitCode, 
                           DWORD dwServiceSpecificExitCode,
                           DWORD dwCheckPoint,
                           DWORD dwWaitHint);
   VOID ServiceCtrlHandler (DWORD controlCode);
   VOID Terminate(DWORD error);
   
   DWORD ServiceThread(LPDWORD param);
#endif


/*

class CService{


public:
   BOOL RemoveService(LPTSTR szServiceNameSCM);
   BOOL InstallService(LPTSTR szServiceNameSCM,
                       LPTSTR szServiceLabel,
                       LPTSTR szExeFullPath);
   
   VOID friend ServiceMain(DWORD argc, LPTSTR *argv);

   ~CService();
   CService();

private:   
   
   BOOL  InitService();
   VOID  ResumeService();
   VOID  PauseService();
   VOID  StopService();

   BOOL  SendStatusToSCM ( DWORD dwCurrentState,
                           DWORD dwWin32ExitCode, 
                           DWORD dwServiceSpecificExitCode,
                           DWORD dwCheckPoint,
                           DWORD dwWaitHint);
   VOID ServiceCtrlHandler (DWORD controlCode);
   VOID Terminate(DWORD error);
   
   DWORD ServiceThread(LPDWORD param);
   DWORD friend WINAPI ServiceThreadStub( IN CService* csv );


};
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\network.cpp ===
#include <windows.h>
#include <stdio.h>
#include <tchar.h>
#include <winver.h>

#include <winnetwk.h>

#include "network.h"
#include "idw_dbg.h"
#include "machines.h"
#include "server.h"

#define TTEST	// Test non-threaded execution for server reporting.

/*++

   Filename :  Network.c

   Description: Contains the network access code.
   
   Created by:  Wally Ho

   History:     Created on 28/01/2000.


	09.19.2001	Joe Holman	fixes for idwlog bugs 409338, 399178, and 352810




   Contains these functions:

   1. FILE* OpenCookieFile();
   2. VOID  CloseCookieFile(IN FILE* fpOpenFile);
   3. VOID  DeleteCookieFile( VOID )
   4. BOOL  WriteIdwlogCookie ( IN  LPINSTALL_DATA pId);
   5. BOOL  ReadIdwlogCookie  ( OUT LPINSTALL_DATA lpId);
   6. BOOL  ServerWriteMinimum  (LPINSTALL_DATA pId,
                                 LPMACHINE_DETAILS pMd);
   7. VOID  ServerWriteMaximum (LPTSTR szFileName,
                                LPINSTALL_DATA pId);
   8. VOID  WriteThread(IN LPSERVER_WRITE_PARAMS pSw);
   9. VOID  DeleteDatafile (LPINSTALL_DATA);
  10. BOOL  WriteDataToAvailableServer (LPINSTALL_DATA pId,
                                        LPTSTR szServerData)
  11. BOOL  SetCancelMutex ( VOID );
  12. BOOL  ClearCancelMutex ( VOID );
  13. BOOL  PauseForMutex( VOID );
  14. BOOL  FileExistsEx( IN  LPTSTR szFileName);
  15  VOID  DeleteIPCConnections( VOID );


--*/

// Global Mutex Handle;
HANDLE g_hCancelMutex;
HANDLE g_hInstanceMutex;

FILE* 
OpenCookieFile(VOID)
/*++

Routine Description:
   This will try drives c through z to find the idwlog.cookie file.

Arguments:
   
   NONE

Return Value:
	NULL for failure.
   The file handle if found.

Author: Wally Ho (wallyho) Jan 31st, 2000

--*/
{
   FILE* fpOpenFile;
   TCHAR   szDriveFile [ 20];
   UINT    i;

   for (i= TEXT('c'); i <= TEXT('z'); i++){
      _stprintf ( szDriveFile, TEXT("%c:\\idwlog.cookie"), i);

      fpOpenFile = _tfopen(szDriveFile, TEXT("r"));
      // if we find the file we return the handle to it.
      if (NULL != fpOpenFile)
         return fpOpenFile;
   }
   // if we get here we know we found nothing.
   return NULL;
}

VOID 
CloseCookieFile(IN FILE* fpOpenFile)
/*++

Author: Wally Ho (wallyho) Jan 31st, 2000

Routine Description:
   This will close the cookie file and Delete it
   It will try drives c through z to find the idwlog.cookie file.

Arguments:
   
   The File Handle.

Return Value:
   NONE
   
--*/
{

   fclose(fpOpenFile);

}



VOID 
DeleteCookieFile( VOID )
/*++

Author: Wally Ho (wallyho) Jan 31st, 2000

Routine Description:
   This will delete the cookiefile.
   It will try drives c through z to find the idwlog.cookie file.

Arguments:
   
   NONE

Return Value:
   NONE
   
--*/
{
   TCHAR   szDriveFile [ 20];
   UINT    i;
   BOOL    bDeleteSuccess = FALSE;


   //	Try to delete the idwlog.cookie file.	
   //	specifies.
   for (i = TEXT('c'); i <= TEXT('z');i++){
      _stprintf ( szDriveFile, TEXT("%c:\\idwlog.cookie"), i);
      //
      //  If we get a non zero return from DeleteFile
      //  then we know the delete file was a success.
      //
      if (FALSE != DeleteFile(szDriveFile) ){
         bDeleteSuccess = TRUE;
         break;
      }
   }
   if (FALSE == bDeleteSuccess)
      Idwlog(TEXT("DeleteCookieFile ERROR - There was a problem deleting the idwlog.cookie file, gle = %ld, file = %s\n"), GetLastError(), szDriveFile );
   else
      Idwlog(TEXT("The idwlog.cookie file was successfully deleted.\n"));
}



BOOL 
WriteIdwlogCookie (IN LPINSTALL_DATA pId)
                   
/*++

   Routine Description:
      The cookie file will be saved as idwlog.cookie.
      The file will be hidden and will wind up on the root of the system
      drive.
      This cookie file passes information we can only get from the install 
      program over to the second part of the idwlog.

      The new cookie file format is this. Keyword seprated by 1 space.
      Much cleaner and easily extensible.
   
      ComputerName WALLYHO_DEV
      SystemBuild 2190
      SystemBuildDelta 30
      SystemBuildLocation LAB
      InstallingBuild 2195
      InstallingBuildDelta 30
      InstallingBuildLocation LAB
      MachineID 3212115354 
      Cdrom YES|NO
      Network YES|NO
      Type CLEAN|UPGRADE
      Msi N
      SPMethod
      OEMImage YES|NO

   Arguments:
      INSTALL_DATA structure.
  
   Return Value:
      NONE
--*/
{
   HANDLE   hFile;
   TCHAR    szLineBuffer [ MAX_PATH ];
   TCHAR    szIdwlogCookieFile[30];
   DWORD    dwNumWritten;


   if (TRUE == pId->bFindBLDFile){
      // wallyho:
      // Get the system drive and write the cookie file there.
      // originally it would write it in the SAVE_FILE and thats
      // always c:. If this fails say %SystemDrive% doesn't exist in
      // windows 9X (I don't know if it does?) then we'll default to c:
      if(FALSE == GetEnvironmentVariable(TEXT("SystemDrive"), szIdwlogCookieFile, 30))
         _stprintf(szIdwlogCookieFile,TEXT("c:"));
      _tcscat(szIdwlogCookieFile,TEXT("\\idwlog.cookie"));

      hFile = CreateFile (szIdwlogCookieFile,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_HIDDEN,
                          NULL );
      
      if (hFile == INVALID_HANDLE_VALUE){
         OutputDebugString ("Unable to write idwlog.cookie file.\n");
         Idwlog(TEXT("Problem writing the idwlog.cookie file.\n\
            Returning without writing. Last Error %lu\n"), GetLastError());
         return FALSE;
      }
      /*
         New format for the idwlog.cookie file.
         
         ComputerName WALLYHO_DEV
         SystemBuild 2190
         SystemBuildDelta 30
         SystemBuildLocation Lab01_N.000219-2219
         InstallingBuild 2195
         InstallingBuildDelta 30
         InstallingBuildLocation Lab01_N.000219-2219
         MachineID 3212115354 
         Cdrom YES|NO
         Network YES|NO
         Type CLEAN|UPGRADE
         Msi N
	 SPMethod
         SPMSI  YES|NO
         OEMImage YES|NO
         IdwlogServer \\ntcore2\idwlog

       */

      // Write into idwlog.cookie
      ZeroMemory((LPTSTR)szLineBuffer,MAX_PATH);
      //The computer name
      _stprintf (szLineBuffer, TEXT("\nComputerName %s\r"), pId->szComputerName);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The user name
      _stprintf (szLineBuffer, TEXT("\nUserName %s\r"), pId->szUserName );
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);
      
      //The domain name
      _stprintf (szLineBuffer, TEXT("\nDomainName %s\r"), pId->szUserDomain );
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The System build.
      _stprintf (szLineBuffer, TEXT("\nSystemBuild %lu\r"), pId->dwSystemBuild);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);
      
      //The System build Delta   
      _stprintf (szLineBuffer, TEXT("\nSystemBuildDelta %lu\r"), pId->dwSystemBuildDelta);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The SP build, same as above different name for backend.   
      _stprintf (szLineBuffer, TEXT("\nSystemSPBuild %lu\r"), pId->dwSystemSPBuild);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The System build location name
      _stprintf (szLineBuffer, TEXT("\nSystemBuildLocation %s\r"), pId->szSystemBuildSourceLocation);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The Installing build.
      _stprintf (szLineBuffer, TEXT("\nInstallingBuild %lu\r"), pId->dwInstallingBuild);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The Installing build Delta   
      _stprintf (szLineBuffer, TEXT("\nInstallingBuildDelta %lu\r"), pId->dwInstallingBuildDelta);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The Installing SP build, same as above but with different name for backend. 
      _stprintf (szLineBuffer, TEXT("\nInstallingSPBuild %lu\r"), pId->dwInstallingSPBuild);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The Installing build location name
      _stprintf (szLineBuffer, TEXT("\nInstallingBuildLocation %s\r"), pId->szInstallingBuildSourceLocation);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The Machine Id.
      _stprintf (szLineBuffer, TEXT("\nMachineID %0.9lu\r"), pId->dwMachineID);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The Cdrom Bool
      _stprintf (szLineBuffer, TEXT("\nCdrom %s\r"), pId->bCdrom? TEXT("YES"): TEXT("NO"));
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The Network Bool
      _stprintf (szLineBuffer, TEXT("\nNetwork %s\r"), pId->bNetwork? TEXT("YES"): TEXT("NO"));
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      //The Type Bool
      _stprintf (szLineBuffer, TEXT("\nType %s\r"), pId->bClean? TEXT("CLEAN"): TEXT("UPGRADE"));
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);
     
      // Check for MSI install
      _stprintf (szLineBuffer, TEXT("\nMsi %s\r"), pId->bMsi ? TEXT("YES"): TEXT("NO"));
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);



      // Check for SP install type.  We can have:  uninstall, patch, or full.
      //
      if ( pId->bSPUninst ) {

	_stprintf (szLineBuffer, TEXT("\nSPMethod %s\r"), TEXT("REMOVE"));
      }

      if ( pId->bSPPatch ) {
	_stprintf (szLineBuffer, TEXT("\nSPMethod %s\r"), TEXT("PATCH"));
      }

      if ( pId->bSPFull ) {
	_stprintf (szLineBuffer, TEXT("\nSPMethod %s\r"), TEXT("FULL"));
      }

      if ( pId->bSPUpdate ) {
	_stprintf (szLineBuffer, TEXT("\nSPMethod %s\r"), TEXT("UPDATE"));
      }
      

      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);


     
      // Check for OEM Image
      //
      _stprintf (szLineBuffer, TEXT("\nOEMImage %s\r"), pId->bOEMImage? TEXT("YES"): TEXT("NO"));
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);



      // Check for Sku 
      _stprintf (szLineBuffer, TEXT("\nSku %lu\r"), pId->dwSku);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      // Write out the server.
      _stprintf (szLineBuffer, TEXT("\nIdwlogServer %s\r"), pId->szIdwlogServer);
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);

      CloseHandle (hFile);
   }
   else{
      // wallyho:
      // Get the system drive and write the cookie file there.
      // originally it would write it in the SAVE_FILE and thats
      // always c:. If this fails say %SystemDrive% doesn't exist in
      // windows 9X (I don't know if it does?) then we'll default to c:

      Idwlog(TEXT("Writing the NO_BUILD_DATA cookie. So we know its not a CD BOOT INSTALL.\n"));

      if(FALSE == GetEnvironmentVariable(TEXT("SystemDrive"), szIdwlogCookieFile, 30))
         _stprintf(szIdwlogCookieFile,TEXT("c:"));
      
      _tcscat(szIdwlogCookieFile,TEXT("\\idwlog.cookie"));
      hFile = CreateFile (szIdwlogCookieFile,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_HIDDEN,
                          NULL );
      if (hFile == INVALID_HANDLE_VALUE){
         OutputDebugString ("Unable to write idwlog.cookie file.\n");
         Idwlog(TEXT("Problem writing the idwlog.cookie file.\n\
            Returning without writing. Last Error %lu\n"), GetLastError());
         return FALSE;
      }
      
      /*
         New format for the no BLD idwlog.cookie file.
         
         NO_BUILD_DATA
       
       */
      // Write into idwlog.cookie
      ZeroMemory((LPTSTR)szLineBuffer,MAX_PATH);
      // The A file to show no build occured.
      _tcscpy(szLineBuffer, TEXT("\nNO_BUILD_DATA\r"));
      WriteFile (hFile,(LPTSTR)szLineBuffer,_tcsclen(szLineBuffer)+1 , &dwNumWritten, NULL);
      CloseHandle (hFile);
   }

   return TRUE;
}


BOOL 
ReadIdwlogCookie( OUT LPINSTALL_DATA lpId)
/*++

Routine Description:
   This will get the install data from the idwlog cookie file. 

Arguments:
   Structure to hold all the data we have from the install.

Return Value:
	TRUE for success.
   FALSE for non success.

Author: Wally Ho (wallyho) Jan 31st, 2000

--*/
{
   FILE*    fpOpenFile;
   TCHAR    szLineBuffer[256];
   TCHAR    szResponse[10];
   TCHAR    szDontCare[50];
   BOOL     b = TRUE;
   DWORD    dw;
/*   
   If \idwlog.cookie exists, then use the data from here to 
   create the file on the database. Otherwise  ??
    
   Example idwlog.cookie
   
         ComputerName WALLYHO_DEV
         SystemBuild 2190
         SystemBuildDelta 30
         SystemBuildLocation Lab01_N.000219-2219
         InstallingBuild 2195
         InstallingBuildDelta 30
         InstallingBuildLocation Lab01_N.000219-2219
         MachineID 3212115354 
         Cdrom YES|NO
         Network YES|NO
         Type CLEAN|UPGRADE
         Msi N
	 SPMehthod
         OEMImage YES|NO
         IdwlogServer \\ntcore2\idwlog

   or
      NO_BUILD_DATA
*/

   fpOpenFile = OpenCookieFile();
   if (NULL == fpOpenFile){
      // Do something about not finding the cookie.
      Idwlog(TEXT("Could not find the Cookie file!! Err: %d\n"), GetLastError());
      // OutputDebugString (TEXT("Idwlog could not find cookie file\n"));
      //<Do some minimal task here. To alert? What? I'll think of later.>
      b = FALSE;

   }else{

      do {

         // we've found the cookie.
         // Get the line one after another.
         _fgetts(szLineBuffer, 256,fpOpenFile);


	 Idwlog(TEXT("ReadIdwlogCookie:  szLineBuffer=>>>%s<<<"), szLineBuffer );



         // NO_BUILD_DATA
         if (NULL != _tcsstr(szLineBuffer, TEXT("NO_BUILD_DATA"))){
            lpId->bFindBLDFile = FALSE;
            b = FALSE;
         }
   
         //ComputerName
         if (NULL != _tcsstr(szLineBuffer, TEXT("ComputerName")))
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,lpId->szComputerName);
         
         //UserName
         if (NULL != _tcsstr(szLineBuffer, TEXT("UserName")))
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,lpId->szUserName );

         //DomainName
         if (NULL != _tcsstr(szLineBuffer, TEXT("DomainName")))
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,lpId->szUserDomain );

         //SystemBuild
         else if( NULL != _tcsstr (szLineBuffer, TEXT("SystemBuild ") )){ 
            _stscanf(szLineBuffer,TEXT("%s %lu"),szDontCare,&dw);
            lpId->dwSystemBuild = dw;
            dw = 0;
         }
         //SystemBuildDelta
         else if( NULL != _tcsstr (szLineBuffer, TEXT("SystemBuildDelta ") )){
            _stscanf(szLineBuffer,TEXT("%s %lu"),szDontCare, &dw);
            lpId->dwSystemBuildDelta = dw;
            dw = 0;
         }
	 //SystemSPBuild
         else if( NULL != _tcsstr (szLineBuffer, TEXT("SystemSPBuild ") )){
            _stscanf(szLineBuffer,TEXT("%s %lu"),szDontCare, &dw);
            lpId->dwSystemSPBuild = dw;
            dw = 0;
         }
         //SystemBuildLocation
         else if( NULL != _tcsstr (szLineBuffer, TEXT("SystemBuildLocation ") )) 
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,lpId->szSystemBuildSourceLocation);

         //InstallingBuild
         else if( NULL != _tcsstr (szLineBuffer, TEXT("InstallingBuild ") )){ 
            _stscanf(szLineBuffer,TEXT("%s %lu"),szDontCare,&dw);
            lpId->dwInstallingBuild = dw;
            dw = 0;
         }
         //InstallingBuildDelta
         else if( NULL != _tcsstr (szLineBuffer, TEXT("InstallingBuildDelta") )){ 
            _stscanf(szLineBuffer,TEXT("%s %lu"),szDontCare,&dw);
            lpId->dwInstallingBuildDelta = dw;
            dw = 0;
         }
         //InstallingSPBuild
         else if( NULL != _tcsstr (szLineBuffer, TEXT("InstallingSPBuild") )){ 
            _stscanf(szLineBuffer,TEXT("%s %lu"),szDontCare,&dw);
            lpId->dwInstallingSPBuild = dw;
            dw = 0;
         }
         //InstallingBuildLocation
         else if( NULL != _tcsstr (szLineBuffer, TEXT("InstallingBuildLocation") ))
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,lpId->szInstallingBuildSourceLocation);

         // MachineID
         else if(NULL != _tcsstr(szLineBuffer, TEXT("MachineID"))){
            _stscanf(szLineBuffer,TEXT("%s %lu"),szDontCare,&dw);
            lpId->dwMachineID = dw;
            dw = 0;
         }
        
         // Sku
         else if(NULL != _tcsstr(szLineBuffer, TEXT("Sku"))){
            _stscanf(szLineBuffer,TEXT("%s %lu"),szDontCare,&dw);
            lpId->dwSku = dw;
            dw = 0;
         }

         // Get the server. This prevents server serparation.
         else if(NULL != _tcsstr(szLineBuffer, TEXT("IdwlogServer")))
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,lpId->szIdwlogServer);

         // Cdrom
         else if(NULL != _tcsstr(szLineBuffer, TEXT("Cdrom"))){
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,szResponse);
            if(szResponse[0] == TEXT('Y'))
               lpId->bCdrom = TRUE;
             else 
               lpId->bCdrom = FALSE;
         }
         // Network
         else if(NULL != _tcsstr(szLineBuffer, TEXT("Network"))){
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,szResponse);
            if(szResponse[0] == TEXT('Y'))
               lpId->bNetwork = TRUE;
             else 
               lpId->bNetwork = FALSE;
         }
         // Type
         else if(NULL != _tcsstr(szLineBuffer, TEXT("Type"))){
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,szResponse);
            if(szResponse[0] == TEXT('C')){
               lpId->bClean   = TRUE;
               lpId->bUpgrade = FALSE;
            }
            else{ 
               lpId->bClean   = FALSE;
               lpId->bUpgrade = TRUE;
            }
         }
         // Msi
         else if(NULL != _tcsstr(szLineBuffer, TEXT("Msi"))){
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,szResponse);
            if(szResponse[0] == TEXT('Y'))
               lpId->bMsi = TRUE;
             else 
               lpId->bMsi = FALSE;
         }

	 // SP Method (of install)
	 //
         else {

	    Idwlog(TEXT("compare: >>>%s<<<\n"), szLineBuffer );

	    if( _tcsstr(szLineBuffer, TEXT("SPMethod"))){

            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,szResponse);

            if(szResponse[0] == TEXT('R'))		// uninstall/remove
               lpId->bSPUninst = TRUE;
             else 
               lpId->bSPUninst = FALSE;

	    if(szResponse[0] == TEXT('P'))		// patch
               lpId->bSPPatch = TRUE;
             else 
               lpId->bSPPatch = FALSE;

	    if(szResponse[0] == TEXT('F'))		// full (winnt32)
               lpId->bSPFull = TRUE;
             else 
               lpId->bSPFull = FALSE;

	     if(szResponse[0] == TEXT('U'))		// update
               lpId->bSPUpdate = TRUE;
             else 
               lpId->bSPUpdate = FALSE;

	    
	     Idwlog(TEXT("read-in values:  bSPUninst = %d, bSPPatch = %d, bSPFull = %d, bSPUpdate = %d\n"), lpId->bSPUninst, lpId->bSPPatch, lpId->bSPFull, lpId->bSPUpdate );

	    
	    
         }
	
	 // OEMImage
         else if(NULL != _tcsstr(szLineBuffer, TEXT("OEMImage"))){
            _stscanf(szLineBuffer,TEXT("%s %s"),szDontCare,szResponse);
            if(szResponse[0] == TEXT('Y'))
               lpId->bOEMImage = TRUE;
             else 
               lpId->bOEMImage = FALSE;
         }
	
	}

      } while( 0 == feof(fpOpenFile) );
      CloseCookieFile( fpOpenFile );
   }
   return b;
}




BOOL
ServerWriteMinimum  (LPINSTALL_DATA pId,
                     LPMACHINE_DETAILS pMd)
/*++

Author: Wally Ho (wallyho) Jan 31st, 2000

Routine Description:

   This writes a *.2 file when we cannot find a *.1.
   There isn't any data in this one as its only the 
   title we care about build and machine. This should
   catch all the CD installs that don't have a *.1 file written.
   Ie. Its run from setuploader.
Arguments:
   
  

Return Value:
   NONE

--*/
{

   //TCHAR      szServerData[4096];
   BOOL       bReturn;


	Idwlog(TEXT("Entered ServerWriteMinimum.\n"));

   GetNTSoundInfo(pMd);


  //	If we are doing an OEMImage, we NEVER want to say that it was from a CDBOOT.
  //

  if ( pId->bOEMImage ) {

	// OEMImage
	//
	_stprintf (g_szServerData, TEXT("OEMImage:YES\r\n") );

  }
  else {

	// CDBootInstall
        //
      _stprintf (g_szServerData,
             TEXT("CDBootInstall:%s\r\n"), 
             pId->bCDBootInstall? TEXT("YES") : TEXT("NO"));


      //  OEMImage
      //
      _stprintf (g_szServerData+_tcsclen(g_szServerData), TEXT("OEMImage:NO\r\n") );


  }


  // Installed Build
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuild:%lu\r\n"), pId->dwInstallingBuild);

  // Installed Build Major
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuildMajor:%lu\r\n"), pId->dwInstallingMajorVersion);

   // Installed Build Minor
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuildMinor:%lu\r\n"), pId->dwInstallingMinorVersion);

   // Installed Build Delta
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuildDelta:%lu\r\n"), pId->dwInstallingBuildDelta);

   // same as above but different name for backend
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingSPBuild:%lu\r\n"), pId->dwInstallingSPBuild);


   // Installed Build Location
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuildLocation:%s\r\n"), pId->szInstallingBuildSourceLocation);

    // MachineId
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
             TEXT("MachineID:%0.9lu\r\n"), pId->dwMachineID);
   //UserName
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Username:%s\r\n"),pId->szUserName);

   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Platform:%s\r\n"),pId->szPlatform);

   // Ram
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("RAM:%lu\r\n"),pMd->dwPhysicalRamInMB);

   // Architeture        
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Arch:%s\r\n"), pId->szArch);

   // Num Processors
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("NumProcs:%lu\r\n"), pMd->dwNumberOfProcessors);

   // Video Information
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Vidinfo:%s\r\n"),pMd->szVideoInfo);

   // Display Name
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("VidDriver:%s\r\n"), pMd->szVideoDisplayName);

   // Locale
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Locale:%s\r\n"), pId->szLocaleId );

   // Sound Card
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Sound:%s\r\n"), 
      pMd->iNumWaveOutDevices? pMd->szWaveDriverName[0] : TEXT("NONE")
      );
   // Network Cards.
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("NetCards:%s\r\n"),pMd->szNetcards);
   
   // Is ACPI
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("ACPI:%d\r\n"),pMd->bACPI);

   //Is PcCard?
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("PCMCIA:%d\r\n"), pMd->bPCCard);

   // Stepping Level of the proccessor
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("CPU:%lu\r\n"), pMd->dwProcessorLevel);

   // Scsi
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("SCSI:%s\r\n"), pMd->szScsi);

   // Is Usb?
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("USB:%d\r\n"), pMd->bUSB);

   // Is Infrared?
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Infrared:%d\r\n"),pMd->bIR);
   
   // Modem
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Modem:%s\r\n"), pMd->szModem);
   // Is Hydra
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Hydra:%d\r\n"), pId->bHydra);

   // Number of Displays
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Displays:%d\r\n"), pMd->iNumDisplays);


   // Sku
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Sku:%lu\r\n"),pId->dwSku);


	Idwlog(TEXT("pId->dwSku = %ld\n"), pId->dwSku);

   bReturn = WriteDataToAvailableServer(pId, g_szServerData);
   
   return bReturn;
   
}

BOOL
ServerWriteMaximum (LPINSTALL_DATA pId,
                    LPMACHINE_DETAILS pMd)

/*++

Author: Wally Ho (wallyho) Jan 31st, 2000

Routine Description:

   This does the connection to the server machine and then 
   uploads the file. This is the Maximal data case.

Arguments:
   

Return Value:
   TRUE for success and
   FALSE for 15 minute time out for servers. Try again when rebooting.
--*/
{

   //TCHAR g_szServerData[4096];
   BOOL  bReturn;


	Idwlog(TEXT("Entered ServerWriteMaximum.\n"));

   //wsprintf only accepts 1k buffers.

   // Wallyho's Addition. I'm going to split it into separate
   // calls to make sure above is true. It also makes it easier
   // to read. :-)


   // OEMImage
   //
   if ( pId->bOEMImage ) {

	_stprintf (g_szServerData, TEXT("OEMImage:YES\r\n") );

   }
   else {
        _stprintf (g_szServerData, TEXT("OEMImage:NO\r\n") );
   }



   // MachineId
   _stprintf (g_szServerData,
      TEXT("MachineID:%0.9lu\r\n"), pId->dwMachineID);
   
   // System Build
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("SystemBuild:%lu\r\n"), pId->dwSystemBuild);

   // System Build Major
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("SystemBuildMajor:%lu\r\n"), pId->dwSystemMajorVersion);

   // System Build Minor
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("SystemBuildMinor:%lu\r\n"), pId->dwSystemMinorVersion);

   // System Build Delta
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("SystemBuildDelta:%lu\r\n"), pId->dwSystemBuildDelta);

   // same as above, but just different name for backend processing.
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("SystemSPBuild:%lu\r\n"), pId->dwSystemSPBuild);

   // System Build Location
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("SystemBuildLocation:%s\r\n"), pId->szSystemBuildSourceLocation);

   // Installed Build
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuild:%lu\r\n"), pId->dwInstallingBuild);

   // Installed Build Major
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuildMajor:%lu\r\n"), pId->dwInstallingMajorVersion);

   // Installed Build Minor
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuildMinor:%lu\r\n"), pId->dwInstallingMinorVersion);

   // Installed Build Delta
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuildDelta:%lu\r\n"), pId->dwInstallingBuildDelta);

   // same as above but different name for backend processing
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingSPBuild:%lu\r\n"), pId->dwInstallingSPBuild);

   // Installed Build Location
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("InstallingBuildLocation:%s\r\n"), pId->szInstallingBuildSourceLocation);


   // Source Media
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Source Media:%s\r\n"),pId->bCdrom?  TEXT("C"): TEXT("N"));

   // Upgrade
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Type:%s\r\n"), pId->bUpgrade? TEXT("U"):TEXT("C"));

   // Sku
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Sku:%lu\r\n"),pId->dwSku);

   //UserName
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Username:%s\r\n"),pId->szUserName);

   // Ram
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("RAM:%lu\r\n"),pMd->dwPhysicalRamInMB);

   //PlatForm
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Platform:%s\r\n"),pId->szPlatform);

   // Architeture        
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Arch:%s\r\n"), pId->szArch);

   // Num Processors
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("NumProcs:%lu\r\n"), pMd->dwNumberOfProcessors);

   // Video Information
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Vidinfo:%s\r\n"),pMd->szVideoInfo);

   // Display Name
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("VidDriver:%s\r\n"), pMd->szVideoDisplayName);

   // Locale
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Locale:%s\r\n"), pId->szLocaleId );

   // Sound Card
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Sound:%s\r\n"), 
      pMd->iNumWaveOutDevices? pMd->szWaveDriverName[0] : TEXT("NONE")
      );

   // Network Cards.
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("NetCards:%s\r\n"),pMd->szNetcards);
   
   // Is ACPI
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("ACPI:%d\r\n"),pMd->bACPI);

   //Is PcCard?
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("PCMCIA:%d\r\n"), pMd->bPCCard);

   // Stepping Level of the proccessor
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("CPU:%lu\r\n"), pMd->dwProcessorLevel);

   // Scsi
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("SCSI:%s\r\n"), pMd->szScsi);

   // Is Usb?
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("USB:%d\r\n"), pMd->bUSB);

   // Is Infrared?
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Infrared:%d\r\n"),pMd->bIR);
   
   // Modem
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Modem:%s\r\n"), pMd->szModem);
   // Is Hydra
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Hydra:%d\r\n"), pId->bHydra);

   // Number of Displays
   _stprintf (g_szServerData+_tcsclen(g_szServerData),
      TEXT("Displays:%d\r\n"), pMd->iNumDisplays);

   // Is Msi?
   _stprintf (g_szServerData + _tcsclen(g_szServerData),
      TEXT("MSI:%s\r\n"), pId->bMsi? TEXT("Y") : TEXT("N") );

   // Is SP uninst ?
      if ( pId->bSPUninst ) {

        _stprintf (g_szServerData + _tcsclen(g_szServerData),
             TEXT("SPMethod:%s\r\n"), TEXT("REMOVE") );

	Idwlog(TEXT("ServerWriteMaximum - SPMethod:UNINSTALL\n"));

      }

   // Is SP Patching?
      if ( pId->bSPPatch ) {


	_stprintf (g_szServerData + _tcsclen(g_szServerData),
             TEXT("SPMethod:%s\r\n"), TEXT("PATCH") );

	Idwlog(TEXT("ServerWriteMaximum - SPMethod:PATCH\n"));
	
      }

    // Is SP Full ?      
      if ( pId->bSPFull ) {

	_stprintf (g_szServerData + _tcsclen(g_szServerData),
             TEXT("SPMethod:%s\r\n"), TEXT("FULL") );

	Idwlog(TEXT("ServerWriteMaximum - SPMethod:FULL\n"));

      }

    // Is SP Update ?      
      if ( pId->bSPUpdate ) {

	_stprintf (g_szServerData + _tcsclen(g_szServerData),
             TEXT("SPMethod:%s\r\n"), TEXT("UPDATE") );

	Idwlog(TEXT("ServerWriteMaximum - SPMethod:UPDATE\n"));

      }

      

   bReturn = WriteDataToAvailableServer(pId, g_szServerData);
   return bReturn;
         
}



BOOL
WriteDataToAvailableServer (LPINSTALL_DATA pId,
                            LPTSTR g_szServerData)
/*++

   Author:  Wally W. Ho (wallyho) 
   Date:    5/22/2000

   Routine Description:
      This routines allows us to time out a write operation so that 
      bad network access won't hold us up.
       
   Arguments:
       LPINSTALL_DATA  pId
       LPTSTR          g_szServerData

   Return Value:
       TRUE for success.
       FALSE for failure.
--*/
{
   DWORD       dw;   
   DWORD       dwTimeOut;
   HANDLE      hThrd;
   DWORD       dwTimeOutInterval;
   DWORD       dwExitCode;

   BOOL		b;

//____<Thread Probing >______________________________________________________________________
   // This will stop the probing after say 10 minutes of probing.
   // Or when it succeeds.



#ifdef TTEST

	Idwlog(TEXT("Entered WriteDataToAvailableServer().\n"));

     	pId->szServerData = g_szServerData;

     	b = WriteThread ( pId );

	Idwlog(TEXT("Exiting WriteDataToAvailableServer() with b = %d.\n"), b );

   	return ( b );

#endif TTEST
   


   pId->szServerData = g_szServerData;
   
   hThrd  = CreateThread(NULL,
                     0,
                     (LPTHREAD_START_ROUTINE)WriteThread,
                     (LPINSTALL_DATA) pId,
                     0,
                     &dw);
   // This is in milli seconds so 10 * factor is 10 minutes.
   dwTimeOutInterval = 10 * (1000 * 60);
   dwTimeOut = WaitForSingleObject (hThrd, dwTimeOutInterval);
   
   // This means the server passed the timeout.
   if (dwTimeOut == WAIT_TIMEOUT){

      // Exit the thread
      if(FALSE == GetExitCodeThread(hThrd,&dwExitCode))
         Idwlog(TEXT("Failed to get the exit code for the write thread.\n"));
      else{
         //
         // Don't terminate the thread
         //
         //TerminateThread(hThrd, dwExitCode);
         Idwlog(TEXT("Timeout Write Thread: %lu \n"), hThrd);
      }
      
      Idwlog(TEXT("Tried all servers we are concluding after 10 minutes elapsed!.\n"));
      Idwlog(TEXT("Leaving shortcut, idwlog.exe and cookie available for next reboot.\n"));
      Idwlog(TEXT("Ending connection to server.\n"));
      
      //Leaving everything in place so that a reboot will catch this.
      CloseHandle (hThrd);
      return FALSE;
   }
   
   CloseHandle (hThrd);
   Idwlog(TEXT("Ending connection to server.\n"));
   return TRUE;
//____<Thread Probing >______________________________________________________________________
}





DWORD WINAPI
WriteThread(IN LPINSTALL_DATA pId)
/*++

   Author:  Wally W. Ho (wallyho) 
   Date:    2/22/2000

   Routine Description:
         This routine finds the best server to write the data package to.
       
   Arguments:
       LPINSTALL_DATA

   Return Value:
       TRUE or FALSE as thread exit codes.
--*/

{
   BOOL     bRet;
   UINT     iAttempts;
   DWORD    Actual;
   DWORD    Size;
   BOOL     bWrite = TRUE;
   HANDLE   hWrite = INVALID_HANDLE_VALUE;
   TCHAR    szInstallingBuild [20];   
   TCHAR    szIdwlogUniqueName [ MAX_PATH ];   
   BOOL     b;


	Idwlog(TEXT("Entered WriteThread().\n"));


   // Build the name for the file.
   // ie \\ntcore2\idwlog\computername2195.1
   if ( 0 == pId->dwInstallingBuild)
      _stprintf (szInstallingBuild, TEXT("latest"));
   else
      _stprintf (szInstallingBuild, TEXT("%lu"), pId->dwInstallingBuild);



   // In the 1st case we enter this routine with no known server.
   // In the second case we get the server from the cookie.
   // So we should try to see if that server works before
   // probing. 
   if (TEXT('\0') == pId->szIdwlogServer[0])
      b = FALSE;
   else {
      SERVERS sb;
      _tcscpy(sb.szSvr, pId->szIdwlogServer );
      b = (BOOL) ServerOnlineThread( &sb);
   }


   // This is the retry Loop!>
   // We'll try the found server 5 times with 5 second spacing.
   // Then we'll query the server list again and try that server
   // Do until we get on pausing 1 second between


#define NUM_TRIES 5

   Idwlog(TEXT("WriteThread - Starting retry loop.\n"));


   while (TRUE) {

      if ( FALSE == b  ) {
         pId->bIsServerOnline = FALSE;
         iAttempts = 0;

         while (pId->bIsServerOnline == FALSE && iAttempts < NUM_TRIES) {

            Idwlog(TEXT("WriteThread - SERVER Attempt %d just before IsServerOnLine()\n"), iAttempts);
            IsServerOnline( pId );
	    Idwlog(TEXT("WriteThread - after IsServerOnLine(), pId->bIsServerOnLine = %d\n"), pId->bIsServerOnline );
            // Wait for 2 seconds between server tries.
            Sleep( 2 * (1000) );

            iAttempts++;

	    // We are going to end here if we can find all the servers in 5 tries.
	    //

            if ( iAttempts >= NUM_TRIES ) {
		Idwlog(TEXT("WriteThread ERROR - After %d attempts, we are quitting since we coundn't find a Server.\n"), iAttempts);
	        return (FALSE);
	    }

         }

	
	 Idwlog(TEXT("WriteThread - after the while loop.\n") );


      }else{
         Idwlog( TEXT("Server FOUND no probing attempted.\n") );
         pId->bIsServerOnline = TRUE;
      }



      // We've got a server!!
      // Add the server to the end of the datapackage.         
      if ( pId->bIsServerOnline == TRUE ) {
         _stprintf (pId->szServerData + _tcslen(pId->szServerData),
                    TEXT("IdwlogServer:%s\r\n"),pId->szIdwlogServer );

         // Make sure the file gets written. 
         // Don't want stoppage by bandwidth constriction etc..
         // Make 3 hits on the same server.
         iAttempts = 0;      
         bRet = FALSE;
         
         while (bRet == FALSE && iAttempts < 3) {

            _stprintf (szIdwlogUniqueName, TEXT("%s\\%s-%lu-%s.%d"),
                       pId->szIdwlogServer,
                       szInstallingBuild,               
                       pId->dwMachineID,
                       pId->szComputerName,
                       pId->iStageSequence);
            

            hWrite = CreateFile( szIdwlogUniqueName,
                                 GENERIC_WRITE,
                                 0,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                                 NULL );

            if (INVALID_HANDLE_VALUE != hWrite) {
               // We have a handle to a active server.
               // Upload the package.
               SetFilePointer( hWrite, 0, NULL, FILE_END );
               Size = _tcsclen( pId->szServerData );

               bRet = WriteFile( hWrite, pId->szServerData, Size, &Actual, NULL );
               if (FALSE == bRet) {
                  Idwlog(TEXT("FILE Attempt %d: Writing data package to Servershare: %s failed! Last Error is %lu\n"),
                         iAttempts + 1, pId->szIdwlogServer, GetLastError());
               }
               // Flush the buffers to make sure its all makes it to the drive.
               FlushFileBuffers(hWrite);
               // wait 3 seconds between attempts
               Sleep(3000);
               CloseHandle(hWrite );
            }else
               Idwlog(TEXT("FILE Attempt %d: Failed in trying to directly write the file: %s."),
                            iAttempts + 1,
                            szIdwlogUniqueName);
            iAttempts++;
         }
         
         if (FALSE == bRet && iAttempts >= 3 ) {
            Idwlog(TEXT("After %d FILE attempts, still could not write to Servershare: %s! Last Error is %lu.\n"),
                   iAttempts, pId->szIdwlogServer, GetLastError());
            WhatErrorMessage(GetLastError());    

            Idwlog(TEXT("We will try the same server a second time.\n"));
            Idwlog(TEXT("The servers will be enumerated again at 10 second intervals.\n"));
            // <At this point we could purge the file locally?>
            // Wait for 10 seconds between server tries.
            Sleep( 10 * ( 1000 ) );

            // Means server was not found. Try to find another server.
            // Get the Server that is online.
            pId->bIsServerOnline = FALSE;

         } else {
            Idwlog(TEXT("Writing data package to Servershare: %s Succeeded.\n"),
                   pId->szIdwlogServer);
            break;
         }
      }
      
      b = FALSE;
   }
   // Delete all the known connections.
   DeleteIPCConnections();

   Idwlog(TEXT("Exiting WriteThread() with return of TRUE.\n"));

   return TRUE;
}


VOID
DeleteIPCConnections( VOID )
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    12/5/2000

   Routine Description:
       This function will delete all the IPC$ NULL net authentications
   Arguments:
       NONE

   Return Value:
       NONE
--*/

{

   TCHAR szRemoteName [MAX_PATH];

   for (INT i = 0; i < sizeof(g_ServerBlock) / sizeof(SERVERS); i++){
      // RemoteName is the server name alone without the share.
      // pServerBlock->szSvr comes in as \\idwlog\idwlogwhstl
      // make it idwlog only..
   
      _tcscpy(szRemoteName, g_ServerBlock[i].szSvr);
      *_tcsrchr(szRemoteName,TEXT('\\')) = TEXT('\0');  
      // make sure it always disconnnected
      _tcscat(szRemoteName,TEXT("\\IPC$"));
      WNetCancelConnection2( szRemoteName,  0, TRUE);
   }
}

/*
        
      //____<Below is Authentication with guest account probe>___________
      
      // Setup the memory for the connection.
      // Try This Connection then try the file probe.
      // This will log us onto the service to make it work.
   
      // RemoteName is the server name along without the share.
      // szIdwlogServer comes in as \\idwlog\idwlogwhstl
      // make is idwlog only..
      _tcscpy(szRemoteName,pId->szIdwlogServer);
      pRemoteName = szRemoteName;
      pRemoteName = pRemoteName + 2;
      l = pRemoteName;
      
      //*_tcsrchr(pRemoteName,TEXT('\\')) = TEXT('\0');


      Idwlog(TEXT("Remote name is %s.\n"), szRemoteName);
      // if the drive is being used shut it down so we can use it.
      // WNetCancelConnection2( DRIVE_LETTER_TO_SHARE, CONNECT_UPDATE_PROFILE, TRUE );
      
      ZeroMemory( &NetResource, sizeof( NetResource ) );
      NetResource.dwType         = RESOURCETYPE_DISK ;
      NetResource.lpLocalName    = DRIVE_LETTER_TO_SHARE;
      NetResource.lpRemoteName   = szRemoteName;
      NetResource.lpProvider     = NULL;
      
      _stprintf(szUserId,TEXT("%s\\guest"),szRemoteName);

      // First, try to connect with the current user ID
      if (NO_ERROR != ( dwError = WNetAddConnection2( &NetResource, NULL, NULL, 0 )) ){
         Idwlog(TEXT("WNetAddConnection2 FAILED with ID = NULL and PWD = NULL.\n"));

         // Second, try to connect with idwuser as user and pw.
         if ( NO_ERROR != ( dwError = WNetAddConnection2( &NetResource, NULL, szUserId, 0 )) )
            Idwlog(TEXT("WNetAddConnection2 FAILED using authentication credentials on %s. Error %lu.\n"), 
                         pId->szIdwlogServer, dwError);
      }
      if ( NO_ERROR == dwError )
         Idwlog(TEXT("WNetAddConnection2 successfully connected.\n"));


//____<Below is File probe>___________
      // ie \\idwlog\idwlog\2195-MachineId-ComputerName.1

      _stprintf (szIdwlogUniqueName, TEXT("%s\\%s-%lu-%s.%d"),
                pId->szIdwlogServer,// DRIVE_LETTER_TO_SHARE,
                szInstallingBuild,               
                pId->dwMachineID,
                pId->szComputerName,
                pId->iStageSequence);

      hWrite = CreateFile( szIdwlogUniqueName,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                           NULL );

  
*/


VOID
DeleteDatafile (LPINSTALL_DATA pId)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    8/23/2000

   Routine Description:
      Deletes the file from the server if the user cancels it.
       
   Arguments:
       Data Structure.

   Return Value:
       NONE
--*/

{
 
   TCHAR    szFileToDelete[MAX_PATH];
   TCHAR    szInstallingBuild [20];
   TCHAR    szServerData[ 200 ];
   HANDLE   hWrite;
   BOOL     bRet;
   DWORD    dwActual;

   /*
      Wallyho: This isn't a trivial problem. Why?
      Its because I've multithreaded the probing.
      So we have to check if both the idwlog.exe is running
      if so kill it.
      If it writes the Idwlog Cookie then we know it finished.
      So we have to stop it. The only way is to use a mutex.
      Which we check. This is just a piece of memory that sits in
      kernel space or simply its the global space of the computer.
      We check if its there at the end if so we delete both the 
      cookie and the file off the server.

      This is the best way I can think of to do this as we have no idea
      where the file is being written.

      Two cases occur:
      1. If the process writing the file has not finished.
         We set a mutex in the cancel. Which this checks for.
         If set we delete the file and the cookie.
      2. If the process writing the file is passed the last check
         then we cannot delete the file in the first process.
         We then read the cookie for the server.
         We go to that server and delete the file.
         Then we delete the cookie and finally the mutex.

      
         
  */
   
   //
   // If there is no IdwlogServer data, there is nothing to delete
   //
   if (NULL == pId->szIdwlogServer ||
       0 != _tcsncmp(pId->szIdwlogServer, TEXT("\\\\"), 2)) {
      return;
   }

   if ( 0 == pId->dwInstallingBuild)
      _stprintf (szInstallingBuild, TEXT("latest"));
   else
      _stprintf (szInstallingBuild, TEXT("%lu"), pId->dwInstallingBuild);


   // ie \\ntcore2\idwlog\2195-MachineId-Computername.1
   _stprintf (szFileToDelete, TEXT("%s\\%s-%lu-%s.%d"),
              pId->szIdwlogServer,
              szInstallingBuild,               
              pId->dwMachineID,
              pId->szComputerName,
              pId->iStageSequence);
   
   Idwlog(TEXT("File deleted is: %s"), szFileToDelete);
   
   SetFileAttributes(szFileToDelete,FILE_ATTRIBUTE_NORMAL);
   
   if (TRUE == FileExistsEx(szFileToDelete)) {
      DeleteFile( szFileToDelete);
   }
   else{

      szFileToDelete[_tcslen(szFileToDelete) -1] = TEXT('0');
      // If we succeed in deleting the file,  then don't write a 0. 
      //Create the *.0 file.
      hWrite = CreateFile( szFileToDelete,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                           NULL );

      if ( hWrite == INVALID_HANDLE_VALUE ) {
         Idwlog(TEXT("Problems creating the %lu delete file."), pId->iStageSequence );
      } else {

         // Upgrade: This we need for the timeout in the 0 files
         _stprintf ( szServerData,
                     TEXT("Type:%s\r\n"), pId->bUpgrade? TEXT("U"):TEXT("C"));
         bRet = WriteFile( hWrite, szServerData, _tcsclen( szServerData ), &dwActual, NULL );
         CloseHandle(hWrite);
      }
   }
}




BOOL
SetCancelMutex ( VOID )
/*++

   Author: wallyho
    
   Routine Description:

   Arguments:

 
   Return Value:
      
--*/
{

   g_hCancelMutex = CreateMutex( NULL,TRUE, TEXT("IdwlogCancelMutex")); 

   if (g_hCancelMutex == NULL){
      Idwlog(TEXT("Could not set mutex.\n"));
      return  FALSE;
   }else{
      Idwlog(TEXT("Mutex set.\n"));
      return TRUE;
   }
}

BOOL
ClearCancelMutex ( VOID )
/*++

   Author: wallyho
    
   Routine Description:

   Arguments:

 
   Return Value:
      
--*/
{

   if (FALSE == ReleaseMutex(g_hCancelMutex)){
      Idwlog(TEXT("Problems releasing cancel mutex.\n"));
      return TRUE;
   }
   else{
    
      Idwlog(TEXT("Released cancel mutex.\n"));
      return FALSE;
   }
}


BOOL 
PauseForMutex(VOID )
/*++

   Author: wallyho
    
   Routine Description:
      This checks a mutex by opening it. we put in the systems global space
      or as better know the "kernel space". This way the separate processes
      can synchronize and delete file in case of canceling.
      Since we randomly find servers online we have no way of finding out 
      what is available or not. We will wait till the cookie is complete
      and then we delete.

   Arguments:

 
   Return Value:
      FALSE Immediately if we don't find the mutex.
      FALSE after we wait for the mutex.
--*/
{

   HANDLE hOpenMutex;

   hOpenMutex = OpenMutex( MUTEX_ALL_ACCESS, FALSE, TEXT("IdwlogCancelMutex") );
   if (hOpenMutex == NULL){ 
//      Idwlog(TEXT("Mutex turned off already. Lets look for the cookie.\n"));
      return FALSE;
   }else{
      Idwlog(TEXT("Have to wait on -1 to finish then completing cancel.\n"));
      WaitForSingleObject(hOpenMutex,60000 /* Up to 1 minute wait*/);
      Idwlog(TEXT("Finished waiting. Continuing....\n"));
      return FALSE;
   }
}


BOOL
SetInstanceMutex ( VOID )
/*++

   Author: wallyho
    
   Routine Description:

   Arguments:

 
   Return Value:
      TRUE if exists.
--*/
{

   g_hInstanceMutex = CreateMutex( NULL,TRUE, TEXT("IdwlogInstanceMutex")); 
   
   if (g_hInstanceMutex == NULL){
      return  FALSE;
   }else{
      if (ERROR_ALREADY_EXISTS == GetLastError())
         return TRUE;
      else
         return FALSE;
   }
}


BOOL
ClearInstanceMutex ( VOID )
/*++

   Author: wallyho
    
   Routine Description:

   Arguments:

 
   Return Value:
      
--*/
{

   if (FALSE == ReleaseMutex(g_hInstanceMutex)){
      Idwlog(TEXT("Problems releasing cancel mutex.\n"));
      return TRUE;
   }
   else{
    
      Idwlog(TEXT("Released cancel mutex.\n"));
      return FALSE;
   }
}

BOOL
FileExistsEx( IN  LPTSTR szFileName)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    8/7/2000

   Routine Description:
       This test the existence of a partially matching FileName.
       
   Arguments:
       NONE

   Return Value:
      SUCCESS TRUE
      FAIL    FALSE
--*/
{

   HANDLE            hFile = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA   W32FD;

	hFile = FindFirstFile(szFileName, &W32FD);
   
   if( INVALID_HANDLE_VALUE == hFile ){
      return FALSE;
   }else{
      FindClose(hFile);
      return TRUE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\service.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "service.h"
#include "network.h"
#include "idw_dbg.h"
#include "idwlog.h"
#include "files.h"



// Global variables
   HANDLE terminateEvent = NULL;
   HANDLE g_hThread = 0;
   SERVICE_STATUS          ssStatus;
   SERVICE_STATUS_HANDLE serviceStatusHandle;
   BOOL bPause   = FALSE;
   BOOL bRunning = FALSE;
   BOOL bKeepThreadAlive = TRUE;

/*******************************************************

 #if _MSC_FULL_VER >= 13008827
 #pragma warning(push)
 #pragma warning(disable:4715)
 // Not all control paths return (due to infinite loop)
 #endif

*******************************************************/


/******************************
 #if _MSC_FULL_VER >= 13008827
 #pragma warning(pop)
 #endif

******************************/



DWORD
ServiceThread(LPDWORD param)
{

   MACHINE_DETAILS md;
   BOOL b;
   INSTALL_DATA id2;
   DWORD dwError = TRUE;
    
   __try{

      ZeroMemory((LPINSTALL_DATA) &id2, sizeof(id2));
      // Set the sequence of which stage we are in.
      g_InstallData.iStageSequence = 2;

      OpenIdwlogDebugFile(WRITE_NORMAL_DBG);
      Idwlog(TEXT("\nSTARTED -- [IDWLOG: Stage2 - Service]\n")); 
      IdwlogClient( &g_InstallData, &md );
      
      // The below will overwrite fields that are filled in as wrong 
      // from the above call to IdwlogClient. Such as the username and 
      // userdomain.

      g_InstallData.bFindBLDFile = TRUE;

      Idwlog(TEXT("Reading the username and userdomain from the cookie\n")); 
      b = ReadIdwlogCookie (&g_InstallData);


      if (TRUE == b && 
          TRUE == g_InstallData.bFindBLDFile) {

         Idwlog(TEXT("Server from cookie is %s.\n"), g_InstallData.szIdwlogServer); 

         // If this returns fail we leave the link
         // and the file intact upon next boot.
         if (FALSE == ServerWriteMaximum (&g_InstallData, &md)) {
            dwError = FALSE;
            __leave;
         }

      } else {
         //If we are here we have read the cookie and 
         // found that NO_BUILD_DATA was in the cookie.
         // Which means part one didn't find a bld file.
         // and the cookie is empty.
         // What we do now is make an assumption. This being
         // That the system build is the current build that
         // we either couldn't get to begin with or that 
         // a CD BOOT happened. Both cases we distinguish.
         // We get the current system information and then 
         // send it as the installing build.
         // of course we blank out the data for everything else.
         GetCurrentSystemBuildInfo(&id2);

         g_InstallData.dwSystemBuild      = 0;
         g_InstallData.dwSystemBuildDelta = 0;
         _tcscpy(g_InstallData.szInstallingBuildSourceLocation, TEXT("No_Build_Lab_Information"));

         g_InstallData.dwInstallingBuild      = id2.dwSystemBuild ;
         g_InstallData.dwInstallingBuildDelta = id2.dwSystemBuildDelta;

         _tcscpy(g_InstallData.szInstallingBuildSourceLocation, id2.szSystemBuildSourceLocation);
         g_InstallData.bFindBLDFile = g_InstallData.bFindBLDFile;


         if (FALSE == g_InstallData.bFindBLDFile) {

            g_InstallData.bCDBootInstall = FALSE;
            // If there was no build file found.
            Idwlog(TEXT("There was no build file in part 1 logging as such.\n"));             
            //Remove the CookieFile.
            // DeleteCookieFile();
            dwError = FALSE;
            __leave;

         } else {
            // We will probe the machine to get a build number
            // then we will send a minimal server file over to the server.
            // This will have a build number machine id name of computer
            // on the file name. But will have a delta inside.

            g_InstallData.bCDBootInstall = TRUE;
            Idwlog(TEXT("This is a CD Boot Install logging as such.\n")); 

            // This forces a server probe immediately.
            g_InstallData.szIdwlogServer[0] = TEXT('\0');         
            if (FALSE == ServerWriteMinimum (&g_InstallData, &md)) {
               dwError = FALSE;
               __leave;
            }
         }

      }
      dwError = TRUE;
   }
   __finally {
      // We should delete the shortcut to idwlog from startup group.
      Idwlog(TEXT("ENDED ---- [IDWLOG: Stage2 - Service]\n")); 
      CloseIdwlogDebugFile();
      StopService();
   }
   return dwError;
}



/******************************
 #if _MSC_FULL_VER >= 13008827
 #pragma warning(pop)
 #endif

******************************/



BOOL
InitService()
// Initializes the service by starting its thread
{
	
   DWORD dw;

   // Start the service's thread
	g_hThread = CreateThread(0,
                            0,
                            (LPTHREAD_START_ROUTINE)ServiceThread,
                            0,
                            0,
                            &dw);
   if (g_hThread==0)
      return FALSE;
   else{
		bRunning = TRUE;
		return TRUE;
	}
}


VOID
ResumeService()
// Resumes a paused service
{
	bPause = FALSE;
	ResumeThread(g_hThread);
}


VOID
PauseService()
// Pauses the service
{
	bPause = TRUE;
	SuspendThread(g_hThread);
}


VOID
StopService()
// Stops the service by allowing ServiceMain to
// complete
{
	
   bRunning = FALSE;
   // Set the event that is holding ServiceMain
	// so that ServiceMain can return
	SetEvent(terminateEvent);
}





BOOL
SendStatusToSCM ( DWORD dwCurrentState,
	               DWORD dwWin32ExitCode,
	               DWORD dwServiceSpecificExitCode,
	               DWORD dwCheckPoint,
	               DWORD dwWaitHint)
/*
   This function consolidates the activities of
   updating the service status with
   SetServiceStatus
*/

{
   BOOL success;
   SERVICE_STATUS serviceStatus;


   ZeroMemory (&serviceStatus, sizeof(serviceStatus));

   // Fill in all of the SERVICE_STATUS fields
   serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
   serviceStatus.dwCurrentState = dwCurrentState;


   // If in the process of something, then accept
   // no control events, else accept anything
   if (dwCurrentState == SERVICE_START_PENDING)
      serviceStatus.dwControlsAccepted = 0;
   else
      serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                         SERVICE_ACCEPT_PAUSE_CONTINUE |
                                         SERVICE_ACCEPT_SHUTDOWN;
   // if a specific exit code is defines, set up
   // the win32 exit code properly
   if (dwServiceSpecificExitCode == 0)
      serviceStatus.dwWin32ExitCode = dwWin32ExitCode;
   else
      serviceStatus.dwWin32ExitCode =  ERROR_SERVICE_SPECIFIC_ERROR;

   
   serviceStatus.dwServiceSpecificExitCode = dwServiceSpecificExitCode;
   serviceStatus.dwCheckPoint = dwCheckPoint;
   serviceStatus.dwWaitHint   = dwWaitHint;

   
   // Pass the status record to the SCM
   success = SetServiceStatus (serviceStatusHandle,&serviceStatus);
   if (!success)
      StopService();
   return success;
}




VOID
ServiceCtrlHandler (DWORD controlCode)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    7/31/2000

   Routine Description:
       This handles events received from the service control manager.
   Arguments:
       Standard control codes for a service of:
         SERVICE_CONTROL_STOP;
         SERVICE_CONTROL_PAUSE;
         SERVICE_CONTROL_CONTINUE;
         SERVICE_CONTROL_INTERROGATE;
         SERVICE_CONTROL_SHUTDOWN;
         
   Return Value:
       NONE
--*/
{

   DWORD  currentState = 0;
   BOOL success;

   switch (controlCode) {


   // Stop the service
   case SERVICE_CONTROL_STOP:
      currentState = SERVICE_STOP_PENDING;
      success = SendStatusToSCM(SERVICE_STOP_PENDING, NO_ERROR, 0, 1, 5000);
      // Stop the service
      StopService();
      return ;

      // Pause the service
   case SERVICE_CONTROL_PAUSE:
      if (bRunning && !bPause) {
         success = SendStatusToSCM(SERVICE_PAUSE_PENDING,NO_ERROR, 0, 1, 1000);
         PauseService();
         currentState = SERVICE_PAUSED;
      }
      break;
      // Resume from a pause
   case SERVICE_CONTROL_CONTINUE:
      if (bRunning && bPause) {

         success = SendStatusToSCM( SERVICE_CONTINUE_PENDING,NO_ERROR, 0, 1, 1000);
         ResumeService();
         currentState = SERVICE_RUNNING;
      }
      break;
      // Update current status
   case SERVICE_CONTROL_INTERROGATE:
      break;

   case SERVICE_CONTROL_SHUTDOWN:
      // Do nothing on shutdown
      return ;
   default:
      break;
   }
   SendStatusToSCM(currentState, NO_ERROR, 0, 0, 0);
}


VOID
Terminate(DWORD error)
/*++
   
   Handle an error from ServiceMain by cleaning up
   and telling SCM that the service didn't start.

--*/ 

{
   
   // if terminateEvent has been created, close it.
   if (terminateEvent)
      CloseHandle(terminateEvent);
    
   // Send a message to the scm to tell about stoppage
   if (serviceStatusHandle)
      SendStatusToSCM(SERVICE_STOPPED, error,0, 0, 0);

   // If the thread has started kill it off
   if (g_hThread)
      CloseHandle(g_hThread);
   // Do not need to close serviceStatusHandle
   
}




VOID
ServiceMain(DWORD argc, LPTSTR *argv)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    8/2/2000

   Routine Description:
         ServiceMain is called when the SCM wants to start the service. 
         When it returns, the service has stopped. It therefore waits 
         on an event just before the end of the function, and that event
          gets set when it is time to stop. It also returns on any error 
          because the service cannot start if there is an error.
 
   Arguments:
       Normal arguments like Main would have.
   Return Value:
       NONE
--*/

{
	BOOL success;

   __try{

      // Call Registration function
      serviceStatusHandle =
      RegisterServiceCtrlHandler( SCM_DISPLAY_NAME,(LPHANDLER_FUNCTION)ServiceCtrlHandler);

      if (!serviceStatusHandle) __leave;

      // Notify SCM of progress
      success = SendStatusToSCM( SERVICE_START_PENDING, NO_ERROR, 0, 1, 5000);
      if (!success) __leave;

      // create the termination event
      terminateEvent = CreateEvent (0, TRUE, FALSE,0);
      if (!terminateEvent) __leave;

      // Notify SCM of progress
      success = SendStatusToSCM( SERVICE_START_PENDING, NO_ERROR, 0, 3, 5000);
      if (!success) __leave;

      // Start the service itself
      success = InitService();
      if (!success) __leave;

      // The service is now running. Notify SCM of progress
      success = SendStatusToSCM(SERVICE_RUNNING,NO_ERROR, 0, 0, 0);
      if (!success) __leave;
   
      
      // Wait for stop signal, and then terminate
      WaitForSingleObject (terminateEvent, INFINITE);

      // Tag the file to be removed after running.
      OpenIdwlogDebugFile(WRITE_SERVICE_DBG);
      RemoveService( SCM_SERVICE_NAME );
      CloseIdwlogDebugFile();
      SetLastError(0);
   }
   __finally {
      // Final Clean Up.
      Terminate(GetLastError());
   }
}

BOOL
InstallService( LPTSTR szServiceNameSCM,
                LPTSTR szServiceLabel,
                LPTSTR szExeFullPath)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    7/27/2000

   Routine Description:
       This installs a service.
   Arguments:
       szServiceNameSCM is the name used internally by the SCM\n";
       szServiceLabel is the name that appears in the Services applet\n";
       szExeFullPath ie. eg "c:\winnt\xxx.exe"

   Return Value:
       NONE
--*/
{

   SC_HANDLE newScm;

   Idwlog(TEXT("Installing a new service\n"));

   // open a connection to the SCM
   SC_HANDLE scm = OpenSCManager(0, 0, SC_MANAGER_CREATE_SERVICE);

   if (!scm)
      Idwlog(TEXT("In OpenScManager: Error %lu\n"),GetLastError());

   newScm = CreateService( scm,
                           szServiceNameSCM,
                           szServiceLabel,
                           SERVICE_ALL_ACCESS,
                           SERVICE_WIN32_OWN_PROCESS,
                           SERVICE_AUTO_START,
                           SERVICE_ERROR_NORMAL,
                           szExeFullPath,
                           NULL,
                           NULL, 
                           NULL, 
                           NULL, 
                           NULL);
   if (!newScm){
      Idwlog(TEXT("Problem installing Service: Error %lu.\n"),GetLastError());
      CloseServiceHandle(scm);
      return FALSE;
   }
   else
      Idwlog(TEXT("Finished installing a new service.\n"));

   // clean up
   CloseServiceHandle(newScm);
   CloseServiceHandle(scm);
   return TRUE;
}


BOOL
RemoveService( IN LPTSTR szServiceNameSCM)
/*++
   Copyright (c) 2000, Microsoft.

   Author:  Wally W. Ho (wallyho) 
   Date:    7/27/2000

   Routine Description:
       This function removes the specified service from the machine.
       
   Arguments:
       The service to remove's internal name.

   Return Value:
       TRUE on success
       FALSE on failure
--*/

{

   
   SC_HANDLE service, scm;
   BOOL success;
   SERVICE_STATUS status;
	
   Idwlog(TEXT("Removing the %s service.\n"), szServiceNameSCM);

   // open a connection to the SCM
   scm = OpenSCManager(NULL, 
                       NULL,
                       SC_MANAGER_ALL_ACCESS);
   if (!scm)
      Idwlog(TEXT("In OpenScManager: Error %lu\n"),GetLastError());

   // Get the service's handle
   service = OpenService(scm,
                         szServiceNameSCM,
                         DELETE);
   if (!service)
      Idwlog(TEXT("In OpenService: Error %lu\n"),GetLastError());
	
   



   // Stop the service if necessary
   success = QueryServiceStatus(service, &status);
   if (!success)
      Idwlog(TEXT("In QueryServiceStatus: Error %lu\n"),GetLastError());
   if (status.dwCurrentState != SERVICE_STOPPED){
      Idwlog(TEXT("Stopping Service...\n"));
      success = ControlService(service,
                               SERVICE_CONTROL_STOP,
                               &status);
      if (!success)
         Idwlog(TEXT("In ControlService: Error %lu\n"),GetLastError());
      Sleep(500);
   }


   // Remove the service
	success = DeleteService(service);
   if (success)
      Idwlog(TEXT("Finished Deleting Service.\n"));
   else {
      Idwlog(TEXT("Problem Deleting Service: Error %lu.\n"),GetLastError());
      if ( ERROR_SERVICE_MARKED_FOR_DELETE == GetLastError()) {
         Idwlog(TEXT(" This service is already marked for delete.\n"));
      }
   }
   // clean up
   CloseServiceHandle(service);
   CloseServiceHandle(scm);
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\idwlog\server.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Filename:

        server.h

Abstract:

        Header for server.cpp
	
Author:

        Wally Ho (wallyho) 31-Jan-2000

Revision History:
   Created
	
--*/
#ifndef SERVER_H
#define SERVER_H

#include <windows.h>

static CONST DWORD TIME_TIMEOUT = 8;

//	Name and password used to so that if you are not in a domain we can 
//	connect and get permissions to copy logs or information to our servers.

static CONST LPTSTR LOGSHARE_USER = TEXT("idwuser");
static CONST LPTSTR LOGSHARE_PW   = TEXT("idwuser");

//	These are used for Setup logs.

static CONST LPTSTR SETUPLOGS_MACH = TEXT("\\\\ntburnlab2");
static CONST LPTSTR SETUPLOGS_USER = TEXT("ntburnlab2\\Setuplogs");
static CONST LPTSTR SETUPLOGS_PW   = TEXT("!csLogs");


#define RTM

// Struct Declarations
typedef struct _SERVERS {
   TCHAR szSvr [ MAX_PATH ];
   BOOL  bOnline;
   DWORD dwTimeOut;
   DWORD dwNetStatus;
} *LPSERVERS, SERVERS;



#ifdef RTM
// #define NUM_SERVERS (sizeof(s) / sizeof(SERVERS))

#define NUM_SERVERS 4

static SERVERS g_ServerBlock[NUM_SERVERS] = {
      {TEXT("\\\\pnptriage\\idwlogWHSTL"), FALSE, -1,-1},
      {TEXT("\\\\nttriage\\idwlogWHSTL"),  FALSE, -1,-1},
      {TEXT("\\\\taxman\\idwlogWHSTL"),    FALSE, -1,-1},
      {TEXT("\\\\ntcore2\\idwlogWHSTL"),   FALSE, -1,-1}
   };

#else
#define NUM_SERVERS 6
static   SERVERS g_ServerBlock[NUM_SERVERS] = {
      {TEXT("\\\\wallyho-dev\\idwlog"),     FALSE, -1,-1},
      {TEXT("\\\\wallyho-dev\\idwlog"),    FALSE, -1,-1},
      {TEXT("\\\\zoopa\\idwlog"),          FALSE, -1,-1},
      {TEXT("\\\\nttriage\\idwlogWHSTL"),  FALSE, -1,-1},
      {TEXT("\\\\ntpnpsrv\\idwlogWHSTL"),  FALSE, -1,-1},
      {TEXT("\\\\idwlog\\idwlogTest"),      FALSE, -1,-1}
   };
#endif



// Prototypes
BOOL  IsServerOnline(IN LPINSTALL_DATA pId, IN LPTSTR szSpecifyShare = NULL);
//DWORD WINAPI ServerOnlineThread( IN LPTSTR szIdwlogServer);
DWORD WINAPI ServerOnlineThread( IN LPSERVERS pServerBlock);

VOID  WhatErrorMessage (IN DWORD dwError);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\infgen\infgen.h ===
#include <tchar.h>
#include <olectl.h>
#include <setupapi.h>
#include "interface.h"
#include "simpledb.h"

#define BUFFER_SIZE 64*1024

struct _SectionList;
typedef _SectionList SECTION, *PSECTION;

struct _SectionEntry;
typedef _SectionEntry SECTIONENTRY, *PSECTIONENTRY;


#define HASH_BUCKETS 128
struct _SectionAssociationList;
typedef _SectionAssociationList SECTIONASSOCIATIONLIST, *PSECTIONASSOCIATIONLIST;

class CUpdateInf : public IUpdateInf
{
public:
    // IUnknown
    ULONG __stdcall AddRef( void );
    ULONG __stdcall Release( void );
    HRESULT __stdcall QueryInterface( REFIID, void ** );
    
    // IDispatch
    HRESULT _stdcall GetTypeInfoCount( UINT * );
    HRESULT __stdcall GetTypeInfo( UINT, LCID, ITypeInfo ** );
    HRESULT __stdcall GetIDsOfNames( REFIID, LPOLESTR *, UINT, LCID, DISPID * );
    HRESULT __stdcall Invoke( DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT * );
        
    // IUpdateInf
    HRESULT __stdcall InsertFile( BSTR bstrFileName );
    HRESULT __stdcall WriteSectionData( BSTR bstrSection, BSTR bstrValue );
    HRESULT __stdcall SetConfigurationField( BSTR bstrFieldName, BSTR bstrValue );
    HRESULT __stdcall AddSourceDisksFilesEntry( BSTR bstrFile, BSTR bstrTag );
    HRESULT __stdcall AddEquality( BSTR bstrSection, BSTR bstrLVal, BSTR bstrRVal );
    HRESULT __stdcall SetVersionField( BSTR bstrFieldName, BSTR bstrValue );
    HRESULT __stdcall SetDB( BSTR bstrServer, BSTR bstrDB, BSTR bstrUser, BSTR bstrPassword );
    HRESULT __stdcall InitGen( BSTR bstrInxFile, BSTR bstrInfFile );
    HRESULT __stdcall CloseGen( BOOL bTrimInf );
    HRESULT __stdcall get_InfGenError( BSTR *bstrError );

    CUpdateInf();
    ~CUpdateInf();
    BOOL Init();
private:
    void  Cleanup();
    BOOL  TrimInf(LPTSTR szINFIn, LPTSTR szINFOut);
    BOOL  ReverseSectionList( void );
    BOOL  WriteSmallINF(LPTSTR szINFIn, LPTSTR szINFOut);
    BOOL  IdentifyUninstallSections();
    BOOL  DeleteUnusedEntries();
    BOOL  DeleteUnusedDirIdSections();
    BOOL  MarkAssociatedEntriesForDelete(PSECTION ps);
    BOOL  RemoveSectionFromMultiEntry(PSECTIONENTRY pse, LPCTSTR szSectionName);
    BOOL  AddEntryToSection(PSECTION ps, LPCTSTR szEntry);
    BOOL  AssociateEntryWithSection(PSECTIONENTRY pse, LPCTSTR szSectionName, BOOL fMultiEntry);
    DWORD CalcHashFromSectionName(LPCTSTR szSectionName);
    BOOL  ReadSectionEntries(LPCTSTR szINF);
    BOOL  GetSectionListFromInF( LPTSTR szINF );
    DWORD GetFileSizeByName(IN LPCTSTR pszFileName, OUT PDWORD pdwFileSizeHigh );

    DWORD    m_bGenInitCalled;
    DWORD    m_dwInfGenError;
    
    TCHAR    m_textBuffer[ BUFFER_SIZE ];
    TCHAR    m_textBuffer2[ BUFFER_SIZE ];
    TCHAR    m_textBuffer3[ BUFFER_SIZE ];
    
    TCHAR    m_szInxFile[ MAX_PATH]; // The inf template. This acts as a database
    TCHAR    m_szOutFile[ MAX_PATH]; // The output file. This is generated.
    TCHAR    m_szFilledInxFile[ MAX_PATH]; // The intermediate work file where the files are injected.

    TCHAR    m_szDataServer[ MAX_PATH ]; // Name of the server hosting the DB
    TCHAR    m_szDatabase[ MAX_PATH ]; // Name of the database
    TCHAR    m_szUserName[ MAX_PATH ]; // Username to connect to database with
    TCHAR    m_szPassword[ MAX_PATH ]; // password to supply to database

    HINF     m_hInf;

    BOOL     m_bActiveDB;

    PSECTION m_sectionList;
    _SectionAssociationList *m_rgNameHash[HASH_BUCKETS];

    CSimpleDatabase *m_pdb;

    ULONG m_cRef;
    ITypeInfo *m_pTypeInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ini\ini.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    munge.h

Abstract:

    This is the main include file for the Windows ini file dumper

Author:

    Steve Wood (stevewo) 16-May-1989

Revision History:

--*/

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>

#include <tools.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\infgen\simpledb.h ===
#include <windows.h>
#include <msdasc.h>

class CSimpleDBResults
{
public:
    CSimpleDBResults( IMultipleResults *pResults );
    ~CSimpleDBResults();
    
    HRESULT NextResultSet();
    HRESULT GetFieldValue( LPCTSTR szField, LPTSTR szValue, DWORD dwMaxChars );
    HRESULT NextRow();

private:
    void FreeRowset();
    void FreeRow();

    struct _BindResult
    {
        DWORD    status;
        DBLENGTH length;
        PVOID    value;
    };

    IMultipleResults *m_pResults;
    IRowset          *m_pCurRowset;
    DBCOLUMNINFO     *m_rgColumnInfo;
    HROW             *m_phRow;
    LPWSTR           m_pColumnBuf;
    DBORDINAL        m_numColumns;
    struct ColInfo
    {
        HACCESSOR hAccessor;
#ifndef UNICODE
        char      *szColumnName;
#endif
    }                *m_colInfo;
};



class CSimpleDatabase
{
public:
    CSimpleDatabase();
    ~CSimpleDatabase();
    HRESULT Connect( LPCTSTR szServer,
                     LPCTSTR szDatabase,
                     LPCTSTR szUserName,
                     LPCTSTR szPassword );
    HRESULT Execute( LPCTSTR szCommand,
                     CSimpleDBResults **ppOutResults );

private:
    HRESULT EstablishSession( IDBInitialize *pDBInitialize );
    
    IDataInitialize  *m_pDataInit;
    IDBCreateCommand *m_pSession;
    BOOL             m_bCreated;
    BOOL             m_bSession;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\infgen\infgen.cpp ===
// infgen.cpp : Defines the initialization routines for the DLL.
//

#include <windows.h>
#include <stdio.h>
#include <mbctype.h>
#include <Shlwapi.h>
#include "infgen.h"
#include "message.h"


#define DELETE_EMPTY 1

#define MAX_LINE    ( MAX_PATH * 2 )

struct _SectionEntry
{
    
    TCHAR   *szLine;
    DWORD   cRef;
    
};

// Track entries throughout the INF related to a section
typedef struct _AssociatedEntries
{
    PSECTIONENTRY pse;
    _AssociatedEntries *pNext;
} ASSOCIATEDENTRIES, *PASSOCIATEDENTRIES;

struct _SectionList
{
    TCHAR              szSectionName[ MAX_PATH ];
    PSECTIONENTRY      pseSectionEntries;
    PASSOCIATEDENTRIES pAssociatedEntries;
    DWORD              dwSectionEntries;
    DWORD              cRef;
    struct             _SectionList *Next;
};

struct _SectionAssociationList
{
    _SectionList            *pSection;
    _SectionAssociationList *pNext;
};


extern HINSTANCE g_hMyInstance;

CUpdateInf::CUpdateInf(
    void
    ) : m_bGenInitCalled(FALSE), m_dwInfGenError(0),
        m_sectionList(NULL), m_bActiveDB(FALSE), m_hInf(INVALID_HANDLE_VALUE),
        m_pTypeInfo(NULL), m_cRef(1)
{
    memset( m_rgNameHash, 0, sizeof( m_rgNameHash ) );

    // Default DB connection
    // WINSEQFE default DB with windows auth
    _tcscpy( m_szDataServer, _T("WINSEQFE") );
    m_szDatabase[0] = _T('\0');
    m_szUserName[0] = _T('\0');
}

CUpdateInf::~CUpdateInf(
    void
    )
{
    if ( m_pTypeInfo ) {
        m_pTypeInfo->Release();
        m_pTypeInfo = NULL;
    }
    Cleanup();
}

//
// IUnknown
//
ULONG 
CUpdateInf::AddRef( void )
{
    return ++m_cRef;
}

ULONG 
CUpdateInf::Release( void )
{
    if ( 0L == --m_cRef )
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT 
CUpdateInf::QueryInterface( REFIID riid, void **ppv )
{
    if ( NULL == ppv )
        return E_POINTER;

    *ppv = NULL;
    if ( IID_IUnknown == riid )
        *ppv = (IUnknown *)this;
    else if ( IID_IDispatch == riid )
        *ppv = (IDispatch *)this;
    else if ( IID_IUpdateInf == riid )
        *ppv = (IUpdateInf *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

//
// IDispatch
//
HRESULT 
CUpdateInf::GetTypeInfoCount( UINT *pCountTypeInfo )
{
    *pCountTypeInfo = 1;
    return S_OK;
}

HRESULT 
CUpdateInf::GetTypeInfo( UINT iTypeInfo,
                               LCID lcid,
                               ITypeInfo **ppTypeInfo )
{
    *ppTypeInfo = NULL;

    if ( 0 != iTypeInfo )
        return DISP_E_BADINDEX;

    m_pTypeInfo->AddRef();
    *ppTypeInfo = m_pTypeInfo;

    return S_OK;
}

HRESULT 
CUpdateInf::GetIDsOfNames( REFIID riid,
                                 LPOLESTR *aszNames,
                                 UINT cNames,
                                 LCID lcid,
                                 DISPID *aDispIDs )
{
    if ( IID_NULL != riid )
        return DISP_E_UNKNOWNINTERFACE;

    return DispGetIDsOfNames( m_pTypeInfo,
                              aszNames,
                              cNames,
                              aDispIDs );
}

HRESULT 
CUpdateInf::Invoke( DISPID dispIdMember,
                         REFIID riid,
                         LCID lcid,
                         WORD wFlags,
                         DISPPARAMS *pDispParams,
                         VARIANT *pVarResult,
                         EXCEPINFO *pExcepInfo,
                         UINT *puArgErr )
{
    if ( IID_NULL != riid )
       return DISP_E_UNKNOWNINTERFACE;
    
    return DispInvoke( this,
                      m_pTypeInfo,
                      dispIdMember,
                      wFlags,
                      pDispParams,
                      pVarResult,
                      pExcepInfo,
                      puArgErr );
}            

//
// Initialization function so we can use type-library based
//       functions to handle the IDispatch calls
//
BOOL
CUpdateInf::Init(
    void
    )
{
    HRESULT hr;
    ITypeLib *pTypeLib = NULL;

    hr = LoadRegTypeLib( LIBID_InfGeneratorLib, (1), (0), LANG_NEUTRAL, &pTypeLib );
    if ( FAILED(hr) )
    {
        return FALSE;
    }

    hr = pTypeLib->GetTypeInfoOfGuid( IID_IUpdateInf, &m_pTypeInfo );
    if ( FAILED(hr) )
    {
        return FALSE;
    }

    // Cleanup
    pTypeLib->Release();
    return TRUE;
}

//
// IUpdateInf
//
HRESULT
CUpdateInf::InsertFile(
    BSTR bstrFileName
    )
{    
    HRESULT hr;
    BOOL    bRet = FALSE;
    DWORD   dwRecordCount;
    LPTSTR lpszSQL;
    CSimpleDBResults *prs;
   
    if ( !m_bActiveDB )
    {
        m_dwInfGenError = FAIL_NO_DATABASE;
        return E_FAIL;
    }

    if( NULL == bstrFileName ) {
        m_dwInfGenError = FAIL_INVALIDPARAM;
        return E_FAIL;
    }
    if( m_bGenInitCalled == FALSE ) {
        m_dwInfGenError = FAIL_NOINITGENCALL;
        return E_FAIL;
    }
    
    lpszSQL = new TCHAR [1000];
    if( NULL == lpszSQL ) {
        return E_OUTOFMEMORY;
    }

#ifndef UNICODE
    char *szFileName;
    size_t lenFileName = SysStringLen(bstrFileName) + 1;
    szFileName = new char[lenFileName];
    if ( NULL == szFileName )
    {
        m_dwInfGenError = ERROR_NOT_ENOUGH_MEMORY;
        return E_FAIL;
    }

    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrFileName,
                                   lenFileName,
                                   szFileName,
                                   lenFileName,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
#else
    wchar_t *szFileName = bstrFileName;
#endif
    _stprintf( lpszSQL,
        _T("Select DISTINCT Section,Entry from Ref_SrcFileLocations,Ref_DefaultInstallerInf where Ref_SrcFileLocations.FileName = '%s' AND  Ref_SrcFileLocations.FileID = Ref_DefaultInstallerInf.FileID"), szFileName );
    
    //sprintf( lpszSQL,
    //  "Select * from Ref_SrcFileLocations" );
    
    
    if( SUCCEEDED(m_pdb->Execute( lpszSQL, &prs )) ) {            
        
        
        if ( S_OK == (hr = prs->NextRow()) )
        {
            bRet = TRUE;                        
            do {
                // an entry can consist of one or more null-terminated
                //     strings, so we clear the entry buffer here
                memset( m_textBuffer2, 0, sizeof(m_textBuffer2) );
                
                if ( FAILED(prs->GetFieldValue( _T("Section"), m_textBuffer, BUFFER_SIZE )) ||
                     FAILED(prs->GetFieldValue( _T("Entry"), m_textBuffer2, BUFFER_SIZE )) ) {
                    m_dwInfGenError = FAIL_RECORDSET;
                    bRet = FALSE;
                    break;
                }
                if ( !WritePrivateProfileSection( m_textBuffer, m_textBuffer2,  m_szFilledInxFile ) ) {
                    m_dwInfGenError = GetLastError();
                    bRet = FALSE;
                    break;
                }
            
            } while( S_OK == (hr = prs->NextRow()) );
            
            if ( FAILED(hr) )
            {
                m_dwInfGenError = hr;
                bRet = FALSE;
            }

            if ( bRet ) {
                // Write an entry in the [SourceDiskFiles] section for this file
                if ( !WritePrivateProfileString( _T("SourceDisksFiles"), szFileName, _T("1"), m_szFilledInxFile ) ) {
                    m_dwInfGenError = GetLastError();
                    bRet = FALSE;
                }
            }
        } else if ( SUCCEEDED(hr) ) {
            m_dwInfGenError = FAIL_NOSECTION;
        }
        else
        {
            m_dwInfGenError = hr;
        }
        
        delete prs;
    } else {
        m_dwInfGenError = FAIL_RECORDSET;
    }
    
#ifndef UNICODE
    delete [] szFileName;
#endif
    delete [] lpszSQL;
    
    if ( bRet ) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
    
}

HRESULT
CUpdateInf::WriteSectionData(
    BSTR bstrSection,
    BSTR bstrValue
    )
{
    BOOL bRet = TRUE;
    size_t lenSection = SysStringLen(bstrSection) + 1,
           lenValue = SysStringLen(bstrValue) + 1;

    if( m_bGenInitCalled == FALSE ) {
        m_dwInfGenError = FAIL_NOINITGENCALL;
        return E_FAIL;
    }

    if ( lenSection >= BUFFER_SIZE ||
         lenValue + 1 >= BUFFER_SIZE )
    {
        m_dwInfGenError = FAIL_MAX_BUFFER;
        return E_FAIL;
    }

#ifndef UNICODE
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrSection,
                                   lenSection,
                                   m_textBuffer,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrValue,
                                   lenValue,
                                   m_textBuffer2,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
#else
    memcpy( m_textBuffer, bstrSection, sizeof(wchar_t) * lenSection );
    memcpy( m_textBuffer2, bstrValue, sizeof(wchar_t) * lenValue );
#endif
    m_textBuffer2[lenValue] = '\0'; // end with a double NULL

    if ( !WritePrivateProfileSection( m_textBuffer, m_textBuffer2,  m_szFilledInxFile ) ) {
        m_dwInfGenError = GetLastError();
        bRet = FALSE;
    }

    if (bRet) {
        return S_OK;
    }
    else {
      return E_FAIL;
    }
}

HRESULT
CUpdateInf::SetConfigurationField(
    BSTR bstrFieldName,
    BSTR bstrValue
    )
{
    BOOL bRet = TRUE;
    size_t lenFieldName = SysStringLen(bstrFieldName) + 1,
           lenValue = SysStringLen(bstrValue) + 1;

    if( m_bGenInitCalled == FALSE ) {
        m_dwInfGenError = FAIL_NOINITGENCALL;
        return E_FAIL;
    }

    if ( lenFieldName >= BUFFER_SIZE ||
         lenValue >= BUFFER_SIZE )
    {
        m_dwInfGenError = FAIL_MAX_BUFFER;
        return E_FAIL;
    }


#ifndef UNICODE
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrFieldName,
                                   lenFieldName,
                                   m_textBuffer,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrValue,
                                   lenValue,
                                   m_textBuffer2,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
#else
    memcpy( m_textBuffer, bstrFieldName, sizeof(wchar_t) * lenFieldName );
    memcpy( m_textBuffer2, bstrValue, sizeof(wchar_t) * lenValue );
#endif

    if ( !WritePrivateProfileString( _T("Configuration"), m_textBuffer, m_textBuffer2, m_szFilledInxFile ) ) {
        m_dwInfGenError = GetLastError();
        bRet = FALSE;
    }
    
    if (bRet) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT
CUpdateInf::SetVersionField(
    BSTR bstrFieldName,
    BSTR bstrValue
    )
{
    BOOL bRet = TRUE;
    size_t lenFieldName = SysStringLen(bstrFieldName) + 1,
           lenValue = SysStringLen(bstrValue) + 1;

    if( m_bGenInitCalled == FALSE ) {
        m_dwInfGenError = FAIL_NOINITGENCALL;
        return E_FAIL;
    }

    if ( lenFieldName >= BUFFER_SIZE ||
         lenValue >= BUFFER_SIZE )
    {
        m_dwInfGenError = FAIL_MAX_BUFFER;
        return E_FAIL;
    }

#ifndef UNICODE
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrFieldName,
                                   lenFieldName,
                                   m_textBuffer,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrValue,
                                   lenValue,
                                   m_textBuffer2,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
#else
    memcpy( m_textBuffer, bstrFieldName, sizeof(wchar_t) * lenFieldName );
    memcpy( m_textBuffer2, bstrValue, sizeof(wchar_t) * lenValue );
#endif
    
    if ( !WritePrivateProfileString( _T("Version"), m_textBuffer, m_textBuffer2, m_szFilledInxFile ) ) {
        m_dwInfGenError = GetLastError();
        bRet = FALSE;
    }
    
    if (bRet) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT
CUpdateInf::AddSourceDisksFilesEntry(
    BSTR bstrFile,
    BSTR bstrTag
    )
{
    BOOL bRet = TRUE;
    size_t lenFile = SysStringLen(bstrFile) + 1,
           lenTag  = SysStringLen(bstrTag) + 1;

    if( m_bGenInitCalled == FALSE ) {
        m_dwInfGenError = FAIL_NOINITGENCALL;
        return E_FAIL;
    }

    if ( lenFile >= BUFFER_SIZE ||
         lenTag  >= BUFFER_SIZE )
    {
        m_dwInfGenError = FAIL_MAX_BUFFER;
        return E_FAIL;
    }

#ifndef UNICODE
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrFile,
                                   lenFile,
                                   m_textBuffer,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrTag,
                                   lenTag,
                                   m_textBuffer2,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
#else
    memcpy( m_textBuffer, bstrFile, sizeof(wchar_t) * lenFile );
    memcpy( m_textBuffer2, bstrTag, sizeof(wchar_t) * lenTag );
#endif

    if ( !WritePrivateProfileString( _T("SourceDisksFiles"), m_textBuffer, m_textBuffer2, m_szFilledInxFile ) ) {
        m_dwInfGenError = GetLastError();
        bRet = FALSE;
    }
    
    if (bRet) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT
CUpdateInf::AddEquality(
    BSTR bstrSect,
    BSTR bstrLVal,
    BSTR bstrRVal
    )
{
    BOOL bRet = TRUE;
    size_t lenSect = SysStringLen(bstrSect) + 1,
           lenLVal = SysStringLen(bstrLVal) + 1,
           lenRVal = SysStringLen(bstrRVal) + 1;

    if( m_bGenInitCalled == FALSE ) {
        m_dwInfGenError = FAIL_NOINITGENCALL;
        return E_FAIL;
    }

    if ( lenLVal >= BUFFER_SIZE ||
         lenRVal >= BUFFER_SIZE ||
         lenSect >= BUFFER_SIZE )
    {
        m_dwInfGenError = FAIL_MAX_BUFFER;
        return E_FAIL;
    }

#ifndef UNICODE
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrLVal,
                                   lenLVal,
                                   m_textBuffer,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrRVal,
                                   lenRVal,
                                   m_textBuffer2,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrSect,
                                   lenSect,
                                   m_textBuffer3,
                                   BUFFER_SIZE,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
#else
    memcpy( m_textBuffer,  bstrLVal, sizeof(wchar_t) * lenLVal );
    memcpy( m_textBuffer2, bstrRVal, sizeof(wchar_t) * lenRVal );
    memcpy( m_textBuffer3, bstrSect, sizeof(wchar_t) * lenSect );
#endif

    if ( !WritePrivateProfileString( m_textBuffer3, m_textBuffer, m_textBuffer2, m_szFilledInxFile ) ) {
        m_dwInfGenError = GetLastError();
        bRet = FALSE;
    }
    
    if (bRet) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

void
CUpdateInf::Cleanup(
    void
    )
{
    PSECTION psRef = m_sectionList;
    OutputDebugString( _T("Freeing m_sectionList ...\n") );
    while( psRef ) {    
        
        PSECTION psRef1 = psRef;
        PSECTIONENTRY pse = psRef1->pseSectionEntries;
        PASSOCIATEDENTRIES pAssoc = psRef1->pAssociatedEntries;
        psRef = psRef->Next;
        if ( NULL != pse ) {
            for ( DWORD i = 0; i < psRef1->dwSectionEntries; i++ ) { 
                if ( pse[i].szLine ) delete [] pse[i].szLine;
            }
            delete [] pse;
        }
        while ( pAssoc ) {
            PASSOCIATEDENTRIES pDel = pAssoc;
            pAssoc = pAssoc->pNext;
            delete pDel;
        }
        delete psRef1;
    }
    m_sectionList = NULL;

    OutputDebugString( _T("Freeing m_rgNameHash ...\n") );
    for ( short i = 0; i < HASH_BUCKETS; i++ ) {
        if ( m_rgNameHash[i] ) {
            PSECTIONASSOCIATIONLIST pAssocList = m_rgNameHash[i];
            while ( pAssocList ) {
                PSECTIONASSOCIATIONLIST pDel = pAssocList;
                pAssocList = pAssocList->pNext;
                delete pDel;
            }

            m_rgNameHash[i] = NULL;
        }
    }

    OutputDebugString( _T("Cleanup finished\n") );
}

HRESULT
CUpdateInf::CloseGen(
    BOOL bTrimInf
    )
{
    BOOL bRet = TRUE;

    if( m_bGenInitCalled == FALSE ) {
        m_dwInfGenError = FAIL_NOINITGENCALL;
        return E_FAIL;
    }

    if ( bTrimInf ) {    
        if ( !TrimInf( m_szFilledInxFile, m_szOutFile ) ) {
            bRet = FALSE;
        }
    }
    else {
        if ( !CopyFile( m_szFilledInxFile, m_szOutFile, FALSE ) ) {
            m_dwInfGenError = GetLastError();
            bRet = FALSE;
        }
    }
    
    if ( !DeleteFile( m_szFilledInxFile ) ) {
        m_dwInfGenError = GetLastError();
        return S_FALSE;
    }

    Cleanup();
    
    m_bGenInitCalled = FALSE;

    if ( bRet ) return S_OK;
    else return E_FAIL;   
}

HRESULT
CUpdateInf::SetDB(
    BSTR bstrServer,
    BSTR bstrDB,
    BSTR bstrUser,
    BSTR bstrPassword
    )
{
    size_t lenServer   = SysStringLen(bstrServer) + 1,
           lenDB       = SysStringLen(bstrDB) + 1, 
           lenUser     = SysStringLen(bstrUser) + 1,
           lenPassword = SysStringLen(bstrPassword) + 1;

    if ( lenServer   >= MAX_PATH ||
         lenDB       >= MAX_PATH ||
         lenUser     >= MAX_PATH ||
         lenPassword >= MAX_PATH )
    {
        m_dwInfGenError = FAIL_MAX_BUFFER;
        return E_FAIL;
    }

    // Server
    if ( lenServer > 1 )
    {
#ifndef UNICODE
        if ( 0 == WideCharToMultiByte( CP_ACP,
                                       0L,
                                       bstrServer,
                                       lenServer,
                                       m_szDataServer,
                                       MAX_PATH,
                                       NULL,
                                       NULL ) ) {
            m_dwInfGenError = GetLastError();
            return E_FAIL;
        }
#else
        memcpy( m_szDataServer, bstrServer, sizeof(wchar_t) * lenServer );
#endif
    }
    else
    {
        m_szDataServer[0] = _T('\0');
    }

    // Default DB
    if ( lenDB > 1 )
    {
#ifndef UNICODE
        if ( 0 == WideCharToMultiByte( CP_ACP,
                                       0L,
                                       bstrDB,
                                       lenDB,
                                       m_szDatabase,
                                       MAX_PATH,
                                       NULL,
                                       NULL ) ) {
            m_dwInfGenError = GetLastError();
            return E_FAIL;
        }
#else
        memcpy( m_szDatabase, bstrDB, sizeof(wchar_t) * lenDB );
#endif
    }
    else
    {
        m_szDatabase[0] = _T('\0');
    }

    // Username
    if ( lenUser > 1 )
    {
#ifndef UNICODE
        if ( 0 == WideCharToMultiByte( CP_ACP,
                                       0L,
                                       bstrUser,
                                       lenUser,
                                       m_szUserName,
                                       MAX_PATH,
                                       NULL,
                                       NULL ) ) {
            m_dwInfGenError = GetLastError();
            return E_FAIL;
        }
#else
        memcpy( m_szUserName, bstrUser, sizeof(wchar_t) * lenUser );
#endif
    }
    else
    {
        m_szUserName[0] = _T('\0');
    }

    // Password
    if ( lenPassword > 1 )
    {
#ifndef UNICODE
        if ( 0 == WideCharToMultiByte( CP_ACP,
                                       0L,
                                       bstrPassword,
                                       lenPassword,
                                       m_szPassword,
                                       MAX_PATH,
                                       NULL,
                                       NULL ) ) {
            m_dwInfGenError = GetLastError();
            return E_FAIL;
        }
#else
        memcpy( m_szPassword, bstrPassword, sizeof(wchar_t) * lenPassword );
#endif
    }
    else
    {
        m_szPassword[0] = _T('\0');
    }

    return S_OK;
}

HRESULT
CUpdateInf::InitGen(
    BSTR bstrInxFile,
    BSTR bstrInfFile
    )
{
    size_t lenInxFile = SysStringLen(bstrInxFile) + 1,
           lenInfFile = SysStringLen(bstrInfFile) + 1;

    if( lenInxFile <= 1 ||
        lenInfFile <= 1 )
    {
        m_dwInfGenError = FAIL_INVALIDPARAM;
        return E_FAIL;
    }
    else if ( lenInxFile >= MAX_PATH ||
              lenInfFile + 2 >= MAX_PATH ) // might need room to add '.\\'
    {
        m_dwInfGenError = FAIL_MAX_BUFFER;
        return E_FAIL;
    }

#ifndef UNICODE
    char *szInxFile,
         *szInfFile;
    szInxFile = new char[lenInxFile];
    szInfFile = new char[lenInfFile];
    if ( NULL == szInxFile ||
         NULL == szInfFile )
    {
        m_dwInfGenError = ERROR_NOT_ENOUGH_MEMORY;
        return E_FAIL;
    }
    
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrInxFile,
                                   lenInxFile,
                                   szInxFile,
                                   lenInxFile,
                                   NULL,
                                   NULL ) ) {
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   bstrInfFile,
                                   lenInfFile,
                                   szInfFile,
                                   lenInfFile,
                                   NULL,
                                   NULL ) ) {
        delete [] szInxFile;
        m_dwInfGenError = GetLastError();
        return E_FAIL;
    }
#else
    wchar_t *szInxFile = bstrInxFile,
            *szInfFile = bstrInfFile;
#endif
    
    _tcscpy( m_szInxFile, szInxFile );
    _tcscpy( m_szOutFile,szInfFile );

    // The Setup* function will infer a path given only a
    // file, so we ensure that a path is always specified
    _stprintf( m_szFilledInxFile, _T("%s%s"), (!_tcschr( szInfFile, _T('\\') )?_T(".\\"):_T("")), szInfFile );
    _tcscpy( m_szFilledInxFile+_tcslen(m_szFilledInxFile)-3, _T("TMP") );
        
    if( CopyFile( m_szInxFile, m_szFilledInxFile, FALSE ) ) {
            
        SetFileAttributes( m_szFilledInxFile, FILE_ATTRIBUTE_NORMAL );            

#ifndef UNICODE
        delete [] szInfFile;
        delete [] szInxFile;
#endif

        // Open up a DB connection if a server was specified    
        if( m_szDataServer[0] ){
            m_pdb = new CSimpleDatabase();
            if ( SUCCEEDED(m_pdb->Connect( m_szDataServer,
                                           m_szDatabase[0]?m_szDatabase:NULL,
                                           m_szUserName[0]?m_szUserName:NULL,
                                           m_szPassword[0]?m_szPassword:NULL )) ) {
                m_bActiveDB = TRUE;
            }
            else {
                m_dwInfGenError = FAIL_DSNOPEN;
                return E_FAIL;
            }
        }
    
        m_bGenInitCalled = TRUE;
        return S_OK;
    }
    else {
#ifndef UNICODE
        delete [] szInfFile;
        delete [] szInxFile;
#endif
        m_dwInfGenError = FAIL_COPYBASEINF;
        return E_FAIL;
    }
}

HRESULT
CUpdateInf::get_InfGenError(
    BSTR *bstrError
    )
{
    LPVOID pErrorMsg;
    DWORD dwFormatFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS;
#ifndef UNICODE
    wchar_t *wszErrorMsg;
    size_t  lenErrorMsg;
#endif

    // assume system error codes will be win32-style or 0x8 stlye
    if ( m_dwInfGenError | 0xc0000000 )
    {
        dwFormatFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }
    else
    {
        dwFormatFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    
    if ( NULL == bstrError ) {
        return E_POINTER;
    }

    if ( !FormatMessage( dwFormatFlags,
                         g_hMyInstance,
                         m_dwInfGenError,
                         NULL,
                         (LPTSTR) &pErrorMsg,
                         0,
                         NULL ) )
    {
        return E_FAIL;
    }

#ifndef UNICODE
    lenErrorMsg = strlen((LPSTR)pErrorMsg) + 1;
    wszErrorMsg = new wchar_t[lenErrorMsg];
    if ( NULL == wszErrorMsg )
    {
        LocalFree( pErrorMsg );
        return E_OUTOFMEMORY;
    }
    if ( 0 == MultiByteToWideChar( _getmbcp(),
                                   0L,
                                   (LPSTR)pErrorMsg,
                                   lenErrorMsg,
                                   wszErrorMsg,
                                   lenErrorMsg ) )
    {
        delete [] wszErrorMsg;
        LocalFree( pErrorMsg );
        return E_FAIL;
    }

    *bstrError = SysAllocString( wszErrorMsg );
    delete [] wszErrorMsg;
#else
    *bstrError = SysAllocString( (LPWSTR)pErrorMsg );
#endif

    LocalFree( pErrorMsg );

    if ( NULL == *bstrError ) {
        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}


BOOL
CUpdateInf::TrimInf(
    LPTSTR szINFIn,
    LPTSTR szINFOut
    )
{
    BOOL bRet = TRUE;

    // Open a handle to the INF
    m_hInf = SetupOpenInfFile( szINFIn, NULL, INF_STYLE_WIN4 ,  NULL );
    if ( INVALID_HANDLE_VALUE == m_hInf ) {
        m_dwInfGenError = GetLastError();
        return FALSE;
    }

    if ( !GetSectionListFromInF( szINFIn ) ||
         !ReadSectionEntries( szINFIn ) ||
         !IdentifyUninstallSections() ||
         !DeleteUnusedEntries() ||
         !WriteSmallINF( szINFIn, szINFOut ) ) {
        bRet = FALSE;
    }

    SetupCloseInfFile( m_hInf );
    m_hInf = INVALID_HANDLE_VALUE;

    return bRet;
}



BOOL
CUpdateInf::ReverseSectionList(
    void
    )
{
    PSECTION pSectionList2 = NULL;
    PSECTION psRef,psRef2;
    
    
    psRef = m_sectionList;
    psRef2 = psRef->Next;
    
    while( psRef ) {       
        
        psRef->Next = NULL;
        m_sectionList = psRef2;
        
        if( pSectionList2 == NULL ) {
            
            pSectionList2 = psRef;
            
        } else {
            
            psRef->Next = pSectionList2 ;
            pSectionList2 = psRef;
            
        }
        psRef = psRef2; 
        if( psRef != NULL ) {
            psRef2 = psRef->Next;
        }
    }
    m_sectionList = pSectionList2;
    
    return TRUE;
}

BOOL 
CUpdateInf::WriteSmallINF( 
              LPTSTR szINFIn, 
              LPTSTR szINFOut 
              )
{
    BOOL    bRet = FALSE;    
    FILE    *fp2 = NULL;
    PSECTION    ps;
    
    ReverseSectionList();
    
    fp2 = _tfopen( szINFOut, _T("w+") );
    if( fp2 ) {        
        // write all the entries from in file to out file excluding the empty sections from sectionlist
        
        ps = m_sectionList;
        while( ps ) {  
            
            
            if( ps->cRef ) {  
                
                if ( _ftprintf( fp2, _T("[%s]\n"),ps->szSectionName) < 0 ) {
                    m_dwInfGenError = GetLastError();
                    goto fail;
                }

                
                for( DWORD i=0; i < ps->dwSectionEntries ; i++ ) {
                    if( ps->pseSectionEntries[i].cRef ) {
                        if ( _ftprintf(fp2, _T("    %s\n"), ps->pseSectionEntries[i].szLine) < 0 ) {
                            m_dwInfGenError = GetLastError();
                            goto fail;
                        }
                        
                    }
                }
                _ftprintf( fp2,_T("\n") );
                
            }
            ps = ps->Next;
        }

        bRet = TRUE;
        
    }

fail:    
    if( fp2 ) {
        
        fclose( fp2 );
    }
    
    return bRet ;
}


BOOL
CUpdateInf::DeleteUnusedEntries(
    void
    )
{
    HINF    hInf;
    BOOL    bRet = TRUE;
    PSECTION    ps, ps2;

    if ( INVALID_HANDLE_VALUE == m_hInf ) {
        return FALSE;
    }
    
    ps = m_sectionList;
    while( ps ) {
            
        if ( 0 == SetupGetLineCount( m_hInf, ps->szSectionName  )  ) {
            if ( 0 == --ps->cRef )
            {
                MarkAssociatedEntriesForDelete( ps );
            }
        }
        ps = ps->Next;
    }

    ps2 = m_sectionList;
    
    while( ps2 ) {
        
        // If all the directives are marked delete, then mark this section
        PSECTIONENTRY pse = ps2->pseSectionEntries;
        
        // If this section has already been removed, ignore it
        if ( ps2->cRef )
        {
            for( DWORD dwCount = 0; dwCount < ps2->dwSectionEntries ; dwCount++ ) {                
                
                if( pse[ dwCount ].cRef ) {
                    break;
                }
            }
            if( dwCount ==  ps2->dwSectionEntries ) {
                //All the directives are marked delete So mark this for delete.
                if ( 0 == --ps2->cRef )
                {
                    MarkAssociatedEntriesForDelete( ps2 );
                }
            }
        }
        ps2=ps2->Next;
    }
    
    // Determine if we can discard any AddDirId sections
    DeleteUnusedDirIdSections();

    return bRet;
}

/*
AddDirId sections are unused if their InstallFromSection entry has been marked
as deleted (as is the case if the corresponding section is empty). We identify
AddDirId sections by looking in the DirectoryId.Include section. This function
goes through all of the AddDirId section identified in the DirectoryId.Include
section and determines if the section is no longer used (based on whether
InstallFromSection has been marked deleted or not).
*/
BOOL
CUpdateInf::DeleteUnusedDirIdSections(
    void
    )
{
    HINF    hInf;
    BOOL    bRet = TRUE;
    INFCONTEXT Context;  
    TCHAR       szDirIDSection[ MAX_PATH ];
    
    if ( INVALID_HANDLE_VALUE == m_hInf )
    {
        return FALSE;
    }
    
    if ( SetupFindFirstLine( m_hInf, _T("DirectoryId.Include"), _T("AddDirId"), &Context ) ) {
        do{
            if( SetupGetLineText( &Context, NULL, NULL, NULL , szDirIDSection, MAX_PATH , NULL ) ) {
                PSECTIONASSOCIATIONLIST pSectionAssoc;
                DWORD dwHash = CalcHashFromSectionName( szDirIDSection );

                pSectionAssoc = m_rgNameHash[dwHash];
                while ( pSectionAssoc && _tcsicmp( szDirIDSection, pSectionAssoc->pSection->szSectionName ) )
                {
                    pSectionAssoc = pSectionAssoc->pNext;
                }
                // If we found a matching section, find the InstallFromSection entry
                if ( pSectionAssoc ) {
                    PSECTIONENTRY pse = pSectionAssoc->pSection->pseSectionEntries;
                    DWORD dwCount;

                    for( dwCount = 0; dwCount < pSectionAssoc->pSection->dwSectionEntries ; dwCount++ ) {                
            
                        if( 0 == _tcsncicmp( _T("InstallFromSection="), pse[ dwCount ].szLine, 19 ) ) {
                            break;
                        }
                    }
                    // If we found the InstallFromSection entry and it is marked for delete
                    // then this section is no longer needed; remove it and its associated
                    // entries
                    if( dwCount < pSectionAssoc->pSection->dwSectionEntries &&
                        !pse[dwCount].cRef ) {

                        if ( 0 == --pSectionAssoc->pSection->cRef )
                        {
                            MarkAssociatedEntriesForDelete( pSectionAssoc->pSection );
                        }
                    }
                    else if ( dwCount < pSectionAssoc->pSection->dwSectionEntries )
                    {
                        // Can InstallFromSection have more than one
                        // comma-delimited entry?
                    }
                }
            }
        } while( SetupFindNextLine( &Context, &Context  ) );
    }

    return bRet;   
}

BOOL
CUpdateInf::IdentifyUninstallSections(
    void
    )
{
    PSECTIONASSOCIATIONLIST pSectionFinder;

    DWORD dwHash = CalcHashFromSectionName( _T("UninstallSections") );

    pSectionFinder = m_rgNameHash[dwHash];
    while ( pSectionFinder && _tcsicmp( _T("UninstallSections"), pSectionFinder->pSection->szSectionName ) )
    {
        pSectionFinder = pSectionFinder->pNext;
    }

    // If we found the [UninstallSections] section, identify the other sections
    if ( pSectionFinder ) {
        DWORD dwCount;
        PSECTION pUninstallSection = pSectionFinder->pSection;

        // the uninstall section is used by the installer
        pUninstallSection->cRef++;

        // for each entry of <uninstall_name>,<current_name> update the current_name section
        for( dwCount = 0; dwCount < pUninstallSection->dwSectionEntries ; dwCount++ ) {
            PSECTIONASSOCIATIONLIST pAssocSection;
            TCHAR *pCurName;

            pCurName = _tcschr( pUninstallSection->pseSectionEntries[dwCount].szLine, _T(',') );
            if ( pCurName ) {
                pCurName++; // move past the ,
                dwHash = CalcHashFromSectionName( pCurName );
                
                pAssocSection = m_rgNameHash[dwHash];
                while ( pAssocSection && _tcsicmp( pCurName, pAssocSection->pSection->szSectionName ) )
                {
                    pAssocSection = pAssocSection->pNext;
                }

                if ( pAssocSection )
                {
                    DWORD dwEntry = 0;

                    // Update reference count on section
                    // NOTE: this is only necessary if we want to keep
                    //       empty sections around, but since we don't
                    //       know a lot about the uninstall logic we
                    //       are playing it safe
                    pAssocSection->pSection->cRef++;

                    // Update reference count on all of the section's entries
                    while ( dwEntry < pAssocSection->pSection->dwSectionEntries ) {
                        pAssocSection->pSection->pseSectionEntries[dwEntry++].cRef++;
                    }

                    // Associate the current entry with this found section
                    AssociateEntryWithSection( &pUninstallSection->pseSectionEntries[dwCount], pCurName, FALSE );
                }
            }
        }
        
    }

    return TRUE;
}

BOOL
CUpdateInf::RemoveSectionFromMultiEntry(
    PSECTIONENTRY pse,
    LPCTSTR       szSectionName
    )
{
    TCHAR *pSectionName = StrStrI( pse->szLine, szSectionName );
    TCHAR *pEndSection;

    if ( NULL != pSectionName )
    {
        pEndSection = _tcschr( pSectionName, _T(',') );
        if ( pEndSection )
        {
            memmove( pSectionName, pEndSection + 1, sizeof(TCHAR) * (_tcslen(pEndSection+1) + 1) );
        }
        else
        {
            // We might be the last entry in the list
            pSectionName--;
            while ( pSectionName > pse->szLine &&
                    _istspace( *pSectionName ) ) pSectionName--;
            if ( _T(',') == *pSectionName )
            {
                *pSectionName = _T('\0');
            }
            // We must be the only remaining entry
            else
            {
                *(pSectionName+1) = _T('\0');
            }
        }

        return TRUE;
    }
    else
    {
        // We didn't find the section name to remove it
        return FALSE;
    }
}


BOOL
CUpdateInf::MarkAssociatedEntriesForDelete(
    PSECTION ps
    )
{
    PASSOCIATEDENTRIES pAssociatedEntries = ps->pAssociatedEntries;

    while ( pAssociatedEntries )
    {
        if ( --pAssociatedEntries->pse->cRef )
        {
            // This line apparently references more than one section
            // so remove ourselves so the line is still useable
            RemoveSectionFromMultiEntry(pAssociatedEntries->pse, ps->szSectionName);
        }
        pAssociatedEntries = pAssociatedEntries->pNext;
    }

    return TRUE;
}

BOOL
CUpdateInf::ReadSectionEntries(
    LPCTSTR szINF
    )
{
    HINF        hInf;
    INFCONTEXT  Context;
    BOOL        bRet = TRUE;
    DWORD       dwSectionEntries;
    DWORD       dwNumChars;
    PSECTION    ps;
    
    
    if ( INVALID_HANDLE_VALUE == m_hInf ) {
        return FALSE;
    }
    
    ps = m_sectionList;
    while( ps ) {
            
        if( ps->cRef ) {
                
            dwSectionEntries = SetupGetLineCount( m_hInf, ps->szSectionName  );
            if( dwSectionEntries > 0 ) {
                ps->pseSectionEntries = new SECTIONENTRY [dwSectionEntries];
                if ( NULL == ps->pseSectionEntries ) {
                    m_dwInfGenError = ERROR_NOT_ENOUGH_MEMORY;
                    return FALSE;
                }
                memset( ps->pseSectionEntries, 0 , dwSectionEntries * sizeof( SECTIONENTRY ) );
                    
                memset( m_textBuffer, 0 , sizeof( m_textBuffer ) );

                dwNumChars = GetPrivateProfileSection(
                                 ps->szSectionName,
                                 m_textBuffer,
                                 BUFFER_SIZE,
                                 szINF
                                 );
                if ( dwNumChars + 2 == BUFFER_SIZE ) {
                    m_dwInfGenError = FAIL_MAX_BUFFER;
                    return FALSE;
                }
                TCHAR * pch = m_textBuffer;

                while( *pch ) {
                    TCHAR *pCurPos = m_textBuffer2;
                    do
                    {
                        if ( _T(';') != pch[0] )
                        {
                            _tcscpy( pCurPos, pch );
                            pCurPos += _tcslen(pch);
                            if ( _T('\\') == *(pCurPos - 1) ) pCurPos--;
                        }
                        pch = pch + _tcslen( pch) +1 ;
                    } while ( *pch && _T('\\') == *pCurPos );
                        
                    pCurPos = _T('\0');
                    if ( _tcslen( m_textBuffer2 ) &&
                         !AddEntryToSection( ps, m_textBuffer2 ) ) {
                        bRet = FALSE;
                        break;
                    }
                }
            }
        }
            
        ps = ps->Next;
    }

    return bRet;
}

BOOL
CUpdateInf::AddEntryToSection(
    PSECTION ps,
    LPCTSTR  szEntry
    )
{
    static TCHAR *rgKeys[] = { _T("CopyFiles"),
                               _T("DelFiles"),
                               _T("AddReg"),
                               _T("DelReg"),
                               _T("AddDirId"),
                               _T("InstallFromSection") };
    TCHAR szNewEntry[MAX_PATH],
          *pNewEntry;
    BOOL bInQuote = FALSE;
    TCHAR *szPostKey;
    TCHAR *szComment;

    // Add entry to section
    ps->pseSectionEntries[ps->dwSectionEntries].szLine = new TCHAR [_tcslen(szEntry) + 1];
    if ( NULL == ps->pseSectionEntries[ps->dwSectionEntries].szLine )
    {
        m_dwInfGenError = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }
    _tcscpy(  ps->pseSectionEntries[ps->dwSectionEntries].szLine, szEntry );
    ps->pseSectionEntries[ps->dwSectionEntries].cRef = 1;

    if ( _tcslen(szEntry) <= MAX_PATH )
    {
        pNewEntry = szNewEntry;
    }
    else
    {
        pNewEntry = new TCHAR [_tcslen(szEntry) + 1];
        if ( NULL == pNewEntry )
        {
            m_dwInfGenError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    _tcscpy( pNewEntry, szEntry );

    // Remove any comments
    szComment = pNewEntry;
    while ( *szComment )
    {
        if ( _T('\"') == *szComment ) bInQuote = !bInQuote;
        if ( !bInQuote && _T(';') == *szComment ) break;
        szComment++;
    }
    if ( *szComment )
    {
        while ( szComment >= pNewEntry &&
                _istspace( *szComment ) ) { szComment--; }
        *(szComment + 1) = _T('\0');
    }

    // Find the key (if one exists)
    szPostKey = _tcschr( pNewEntry, _T('=') );

    if ( szPostKey )
    {
        *szPostKey = _T('\0');

        // If we recognize the entry type, add it to list affecting specified section
        if( _tcsicmp( ps->szSectionName , _T("DestinationDirs") ) == 0 ) {
            
            // This entry is necessary only as long as it has associations
            ps->pseSectionEntries[ps->dwSectionEntries].cRef = 0;

            AssociateEntryWithSection( &ps->pseSectionEntries[ps->dwSectionEntries], pNewEntry, FALSE );
        } else {
            DWORD iKey;
            szPostKey++;
            for ( iKey = 0; iKey < sizeof(rgKeys) / sizeof(rgKeys[0]); iKey++ )
            {
                if ( !_tcsicmp( rgKeys[iKey], pNewEntry ) )
                {
                    // The associated sections may appear in a comma-delimited list,
                    // so make sure to associate all of the entries
                    BOOL fMultiEntry = (NULL != _tcschr( szPostKey, _T(',') ));
                    TCHAR *pSection = _tcstok( szPostKey, _T(" ,") );

                    // This entry is necessary only as long as it has associations
                    ps->pseSectionEntries[ps->dwSectionEntries].cRef = 0;
                    
                    do
                    {
                        AssociateEntryWithSection( &ps->pseSectionEntries[ps->dwSectionEntries], pSection, fMultiEntry );
                    } while ( pSection = _tcstok(NULL, _T(" ,")) );
                    
                    break;
                }
            }
        }
    }
                    
    // Free up buffer if we were forced to allocate one
    if ( pNewEntry != szNewEntry ) delete [] pNewEntry;

    ps->dwSectionEntries++;
    return TRUE;
}

BOOL
CUpdateInf::AssociateEntryWithSection(
    PSECTIONENTRY pse,
    LPCTSTR       szSectionName,
    BOOL          fMultiSection
    )
{
    DWORD                   dwHash;
    PSECTION                pSection;
    PSECTIONASSOCIATIONLIST pSectionAssoc;
    PASSOCIATEDENTRIES      pAssociation;

    // Find our section to associate in the hash list
    dwHash = CalcHashFromSectionName( szSectionName );
    pSectionAssoc = m_rgNameHash[dwHash];
    while ( pSectionAssoc && _tcsicmp( szSectionName, pSectionAssoc->pSection->szSectionName ) )
    {
        pSectionAssoc = pSectionAssoc->pNext;
    }
    // If we couldn't find the section, assume it doesn't exit and mark the entry for delete
    if ( !pSectionAssoc )
    {
        if ( fMultiSection )
        {
            // Remove the section name from a multi-section
            // comma-delimited list
            RemoveSectionFromMultiEntry(pse, szSectionName);
        }
        return TRUE;
    }

    // Add new entry to section association
    pAssociation = new ASSOCIATEDENTRIES;
    if ( NULL == pAssociation )
    {
        m_dwInfGenError = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    // Update the ref count on the entry
    pse->cRef++;

    pAssociation->pse   = pse;
    pAssociation->pNext = NULL;

    pSection = pSectionAssoc->pSection;
    if ( pSection->pAssociatedEntries )
    {
        pAssociation->pNext = pSection->pAssociatedEntries;
        pSection->pAssociatedEntries = pAssociation;
    }
    else
    {
        pSection->pAssociatedEntries = pAssociation;
    }

    return TRUE;    
}

DWORD
CUpdateInf::CalcHashFromSectionName(
    LPCTSTR szSectionName
    )
{
    TCHAR szSectionNameLC[ MAX_PATH ];
    DWORD dwHash = 0L,
          dwHashExtra = 0L;
    BYTE  *pData;
    size_t bytesSectionName = sizeof( TCHAR ) * _tcslen( szSectionName );
    size_t i;

    // Dependent on sizeof(DWORD) = 4 * sizeof(BYTE) so put in a check
    // which the compiler should optimize out
    if ( sizeof(DWORD) != 4*sizeof(BYTE) ) DebugBreak();

    // convert section name to lower-case
    for ( i = 0; i < _tcslen( szSectionName ); i++ )
    {
        szSectionNameLC[i] = (_istupper(szSectionName[i])?_totlower(szSectionName[i]):szSectionName[i]);
    }
   
    pData = (PBYTE)szSectionNameLC;
    for ( i = 0; i < bytesSectionName / sizeof(DWORD); i++ )
    {
        DWORD dwTempHash = 0L;
        
        dwTempHash = pData[0] << 24 | pData[1] << 16 | pData[2] << 8 | pData[3];
#ifdef UNICODE
        dwHash ^= i%2?dwTempHash >> 8:dwTempHash;
#else
        dwHash ^= dwTempHash;
#endif
        pData += sizeof(DWORD);
    }
    // Pick up any remaining bits that don't fit into a DWORD
    for ( i = 0; i < bytesSectionName % sizeof(DWORD); i++ )
    {
        dwHashExtra <<= 8;
        dwHashExtra += pData[i];
    }

    return (dwHash ^ dwHashExtra) % HASH_BUCKETS;
}

BOOL
CUpdateInf::GetSectionListFromInF(
    LPTSTR szINF
    )
{
    BOOL bRet = TRUE;
    PSECTION    ps = NULL;
    DWORD       dwSize =0;
    LPTSTR      lpReturnedString;
    DWORD       dwResult;
    TCHAR       *pc;
    DWORD       dwHash;
    BOOL        fDuplicate;
    PSECTIONASSOCIATIONLIST pAssociationList;
    
    dwSize = GetFileSizeByName( szINF, NULL );
    
    lpReturnedString = new TCHAR [dwSize];
    
    dwResult = GetPrivateProfileString(
        NULL,        // section name
        NULL,        // key name
        _T("1"),        // default string
        lpReturnedString,  // destination buffer
        dwSize,              // size of destination buffer
        szINF
        );
    
    pc = lpReturnedString;
    
    if( dwResult > 0  ) {
        // Form the list
        while( ( bRet ) && ( _tcslen( pc ) != 0 ) ) {
            ps = new SECTION;
            
            if( ps ) {
                
                fDuplicate = FALSE;
                memset( ps, 0, sizeof( SECTION ) );
                _tcscpy( ps->szSectionName, pc );
                ps->cRef = 1;
                
                // Add section to association hash
                dwHash = CalcHashFromSectionName( ps->szSectionName );
                if ( !m_rgNameHash[dwHash] )
                {
                    m_rgNameHash[dwHash] = new SECTIONASSOCIATIONLIST;
                    if ( NULL == m_rgNameHash[dwHash] )
                    {
                        m_dwInfGenError = ERROR_NOT_ENOUGH_MEMORY;
                        bRet = FALSE;
                        break;
                    }
                    pAssociationList = m_rgNameHash[dwHash];
                }
                else
                {
                    pAssociationList = m_rgNameHash[dwHash];
                    // Check for duplicate section name
                    do
                    {
                        if ( !_tcsicmp(pAssociationList->pSection->szSectionName, ps->szSectionName) )
                        {
                            fDuplicate = TRUE;
                            break;
                        }
                    }
                    while ( pAssociationList->pNext &&
                            NULL != (pAssociationList = pAssociationList->pNext) // should always be true
                           );

                    if ( !fDuplicate )
                    {
                        pAssociationList->pNext = new SECTIONASSOCIATIONLIST;
                        if ( NULL == pAssociationList->pNext )
                        {
                            m_dwInfGenError = ERROR_NOT_ENOUGH_MEMORY;
                            bRet = FALSE;
                            break;
                        }
                        pAssociationList = pAssociationList->pNext;
                    }
                }

                if ( !fDuplicate )
                {
                    pAssociationList->pSection = ps;
                    pAssociationList->pNext = NULL;

                
                    //
                    // Add section to section list
                    //
                    if( m_sectionList == NULL ) {
    
                        m_sectionList = ps;
    
                    } else {
                        ps->Next  = m_sectionList;
                        m_sectionList = ps;
                    }
                }
                else
                {
                    // free duplicate section entry
                    delete ps;
                }

            } else{
                bRet = FALSE;
                
            }
            
            pc += _tcslen( pc )+1 ; 
        }
    } else {
        bRet = FALSE;
    }
    if( lpReturnedString != NULL ) {
        delete [] lpReturnedString;
    }

    TCHAR szDebug[50];
    short cFilled = 0;
    for ( short i = 0; i < HASH_BUCKETS; i++ ) { if ( m_rgNameHash[i] ) cFilled++; }
    _stprintf( szDebug, _T("Buckets used: %u\n"), cFilled );
    OutputDebugString( szDebug );

    return bRet;
}

DWORD
CUpdateInf::GetFileSizeByName(
                  IN  LPCTSTR pszFileName,
                  OUT PDWORD pdwFileSizeHigh
                  )
{
    DWORD  dwFileSizeLow = 0xFFFFFFFF;
    HANDLE hFile;
    
    hFile = CreateFile(
        pszFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_NO_BUFFERING,
        NULL
        );
    
    if ( hFile != INVALID_HANDLE_VALUE ) {
        
        dwFileSizeLow = GetFileSize( hFile, pdwFileSizeHigh );
        
        CloseHandle( hFile );
    }
    
    return dwFileSizeLow;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\infgen\factory.cpp ===
#include <objbase.h>
#include <mbctype.h>
#include "infgen.h"

HINSTANCE g_hMyInstance;
long g_cKeepAlive;

LONG
IncrementKeepAlive(
    void
    )
{
    return InterlockedIncrement( &g_cKeepAlive );
}

LONG
DecrementKeepAlive(
    void
    )
{
    return InterlockedDecrement( &g_cKeepAlive );
}

class CInfGeneratorFactory : public IClassFactory
{
public:
    // IUnknown
    ULONG __stdcall AddRef( void );
    ULONG __stdcall Release( void );
    HRESULT __stdcall QueryInterface( REFIID riid, void **ppv );

    // IClassFactory
    HRESULT __stdcall CreateInstance( IUnknown *pUnkOuter, REFIID riid, void **ppv );
    HRESULT __stdcall LockServer( BOOL bLock );

    CInfGeneratorFactory(): m_cRef(1) {}
    ~CInfGeneratorFactory() {}

private:
    long m_cRef;
    long m_cLocks;
};

ULONG
CInfGeneratorFactory::AddRef(
    void
    )
{
    IncrementKeepAlive();
    return InterlockedIncrement(&m_cRef);
}

ULONG
CInfGeneratorFactory::Release(
    void
    )
{
    if ( 0L == InterlockedDecrement(&m_cRef) )
    {
        delete this;
        DecrementKeepAlive();
        return 0L;
    }

    DecrementKeepAlive();
    return m_cRef;
}

HRESULT
CInfGeneratorFactory::QueryInterface(
    REFIID riid,
    void **ppv
    )
{
    *ppv = NULL;

    if ( IID_IUnknown == riid ||
         IID_IClassFactory == riid )
    {
        *ppv = (IClassFactory *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

HRESULT
CInfGeneratorFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppv
    )
{
    *ppv = NULL;

    if ( NULL != pUnkOuter )
    {
        return CLASS_E_NOAGGREGATION;
    }

    CUpdateInf *pUpdateInf = new CUpdateInf;
    if ( NULL == pUpdateInf )
        return E_OUTOFMEMORY;
    
    if ( !pUpdateInf->Init() )
    {
        delete pUpdateInf;
        return E_FAIL;
    }

    HRESULT hr = pUpdateInf->QueryInterface( riid, ppv );
    if ( S_OK != hr )
        delete pUpdateInf;
    else
        pUpdateInf->Release();

    return hr;
}

HRESULT
CInfGeneratorFactory::LockServer(
    BOOL bLock
    )
{
    if ( bLock )
    {
        IncrementKeepAlive();
        InterlockedIncrement( &m_cLocks );
    }
    else if ( 0 != m_cLocks )
    {
        InterlockedDecrement( &m_cLocks );
        DecrementKeepAlive();
    }
    else
        return E_FAIL;

    return S_OK;
}

inline long
AssignKeyValue(
    HKEY hParentKey,
    LPTSTR szKeyName,
    LPTSTR szValue,
    LPTSTR szData,
    HKEY *phNewKey
    )
{
    LONG lResult;
    DWORD dwDisposition;
    HKEY hKey;

    if ( NULL != szKeyName )
    {
        lResult = RegCreateKeyEx( hParentKey,
                                  szKeyName,
                                  (0),
                                  (0),
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKey,
                                  &dwDisposition );
        if ( ERROR_SUCCESS != lResult ) goto failure;
    }
    else
    {
        hKey = hParentKey;
    }
    
    lResult = RegSetValueEx( hKey,
                             szValue,
                             (0),
                             REG_SZ,
                             (PBYTE)szData,
                             sizeof( TCHAR ) * _tcslen( szData ) );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    if ( NULL != phNewKey )
    {
        *phNewKey = hKey;
    }
    else
    {
        RegCloseKey( hKey );
        hKey = NULL;
    }

    return ERROR_SUCCESS;

failure:
    if ( NULL != hKey )
        RegCloseKey( hKey );
    
    return lResult;
}

HRESULT
DllRegisterServer(
    void
    )
{
    LONG lResult;
    DWORD dwDisposition;
    TCHAR szMe[_MAX_PATH];
    HKEY hKeyParent = NULL,
         hKey = NULL;
    ITypeLib *pTypeLib;
    HRESULT hr;

    // Open the CLSID key
    lResult = RegCreateKeyEx( HKEY_CLASSES_ROOT,
                              _T("CLSID"),
                              (0),
                              (0),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyParent,
                              &dwDisposition );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    // Store our class ID
    lResult = AssignKeyValue( hKeyParent,
                              _T("{9cd916b9-2004-42b1-b639-572fbf647204}"),
                              NULL,
                              _T("Update INF Generator"),
                              &hKey );
    // Done with CLSID key
    RegCloseKey( hKeyParent );
    hKeyParent = NULL;

    if ( ERROR_SUCCESS != lResult ) goto failure;

    // Find out my full path
    if ( !GetModuleFileName( g_hMyInstance, szMe, _MAX_PATH ) ) goto failure;

    // Store our location
    hKeyParent = hKey;
    lResult = AssignKeyValue( hKeyParent,
                              _T("InprocServer32"),
                              NULL,
                              szMe,
                              &hKey );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    // Store our threading model
    lResult = AssignKeyValue( hKey,
                              _T("ThreadingModel"),
                              NULL,
                              _T("Apartment"),
                              NULL );
    if ( ERROR_SUCCESS != lResult ) goto failure;
    RegCloseKey( hKey );
    hKey = NULL;

    // Store our type-lib info
#ifndef UNICODE
    size_t  lenMe = strlen(szMe) + 1;
    wchar_t *wszMe = new wchar_t[lenMe];
    if ( NULL == wszMe )
    {
        return false;
    }
    if ( 0 == MultiByteToWideChar( _getmbcp(),
                                   0L,
                                   szMe,
                                   lenMe,
                                   wszMe,
                                   lenMe ) )
    {
        return false;
    }
    hr = LoadTypeLibEx( wszMe, REGKIND_REGISTER, &pTypeLib );
    delete [] wszMe;
#else
    hr = LoadTypeLibEx( szMe, REGKIND_REGISTER, &pTypeLib );
#endif
    if ( FAILED(hr) )
    {
        lResult = hr;
        goto failure;
    }
    pTypeLib->Release();

    // Now store pointer to the type-lib info
    lResult = AssignKeyValue( hKeyParent,
                              _T("TypeLib"),
                              NULL,
                              _T("{7c1b689f-3b9f-4c65-aa65-9951a5048e47}"),
                              NULL );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    // Store our ProgID value
    lResult = AssignKeyValue( hKeyParent,
                              _T("ProgID"),
                              NULL,
                              _T("InfGenerator"),
                              NULL );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    // Done with CLSID\{value} key
    RegCloseKey( hKeyParent );
    hKey = NULL;

    // *
    // Store our ProgID entry and associated values
    // *
    lResult = AssignKeyValue( HKEY_CLASSES_ROOT,
                              _T("InfGenerator"),
                              NULL,
                              _T("Update INF Generator"),
                              &hKey );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    lResult = AssignKeyValue( hKey,
                              _T("CLSID"),
                              NULL,
                              _T("{9cd916b9-2004-42b1-b639-572fbf647204}"),
                              NULL );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    lResult = AssignKeyValue( hKey,
                              _T("CurVer"),
                              NULL,
                              _T("InfGenerator.1"),
                              NULL );
    if ( ERROR_SUCCESS != lResult ) goto failure;
    
    // Done with <ProgID> key
    RegCloseKey( hKey );
    hKey = NULL;

    lResult = AssignKeyValue( HKEY_CLASSES_ROOT,
                              _T("InfGenerator.1"),
                              NULL,
                              _T("Update INF Generator"),
                              &hKey );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    lResult = AssignKeyValue( hKey,
                              _T("CLSID"),
                              NULL,
                              _T("{9cd916b9-2004-42b1-b639-572fbf647204}"),
                              NULL );
    if ( ERROR_SUCCESS != lResult ) goto failure;

    // Done with version-specific <ProgID> key
    RegCloseKey( hKey );
    hKey = NULL;
    
    return S_OK;

failure:
    if ( hKeyParent ) RegCloseKey( hKeyParent );
    if ( hKey ) RegCloseKey( hKey );
    // Undo anything we might have done
    DllUnregisterServer();
    return lResult;
}

long
DeleteKeyTree(
    HKEY hKeyParent,
    LPTSTR szKeyName
    )
{
    FILETIME ftLastWrite;
    DWORD i = 0,
          dwSizeOfKey = _MAX_PATH;
    TCHAR szSubkey[_MAX_PATH];
    LONG lResult,
         lFirstFailure = ERROR_SUCCESS;
    HKEY hKey;

    lResult = RegOpenKeyEx( hKeyParent,
                            szKeyName,
                            (0),
                            KEY_ALL_ACCESS,
                            &hKey );
    if ( ERROR_SUCCESS != lResult )
    {
        lFirstFailure = lResult;
        goto failure;
    }

    while ( ERROR_SUCCESS == (lResult = RegEnumKeyEx( hKey,
                                                      i++,
                                                      szSubkey,
                                                      &dwSizeOfKey,
                                                      (0),
                                                      NULL,
                                                      (0),
                                                      &ftLastWrite )) )
    {
        lResult = DeleteKeyTree( hKey, szSubkey );
        if ( ERROR_SUCCESS != lResult &&
             ERROR_SUCCESS != lFirstFailure )
        {
            lFirstFailure = lResult;
        }

        dwSizeOfKey = _MAX_PATH;
    }

    if ( ERROR_NO_MORE_ITEMS != lResult &&
         ERROR_SUCCESS != lFirstFailure )
    {
        lFirstFailure = lResult;
    }
    
    RegCloseKey( hKey );

failure: // Attempt to delete key regardless of previous failures

    lResult = RegDeleteKey( hKeyParent, szKeyName );
    if ( ERROR_SUCCESS != lResult &&
         ERROR_SUCCESS != lFirstFailure )
    {
        lFirstFailure = lResult;
    }

    // Check for successful completion
    return lFirstFailure;
}

HRESULT __stdcall
DllCanUnloadNow(
    void
    )
{
    if ( 0L == InterlockedCompareExchange( &g_cKeepAlive, 0L, 0L ) )
        return S_OK;
    else
        return S_FALSE;
}

HRESULT __stdcall
DllGetClassObject(
    REFCLSID clsid,
    REFIID riid,
    void **ppv
    )
{
    *ppv = NULL;
    if ( CLSID_InfGenerator != clsid )
        return CLASS_E_CLASSNOTAVAILABLE;

    CInfGeneratorFactory *pInfGeneratorFactory = new CInfGeneratorFactory;
    if ( NULL == pInfGeneratorFactory )
        return E_OUTOFMEMORY;

    HRESULT hr = pInfGeneratorFactory->QueryInterface( riid, ppv );
    pInfGeneratorFactory->Release();

    return hr;
}

HRESULT
DllUnregisterServer(
    void
    )
{
    long lResult;
    HKEY hKey;

    // Remove type-lib info
    UnRegisterTypeLib( LIBID_InfGeneratorLib, (1), (0), LANG_NEUTRAL, SYS_WIN32 );

    lResult = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                            _T("CLSID"),
                            (0),
                            KEY_ALL_ACCESS,
                            &hKey );
    if ( ERROR_SUCCESS == lResult )
    {
        // Get rid of our CLSID entry
        lResult = DeleteKeyTree( hKey, _T("{6324c2cf-aad4-4477-8388-4fdba25188d4}") );
        RegCloseKey( hKey );
    }

    // Get rid of our PROGID entry
    lResult = DeleteKeyTree( HKEY_CLASSES_ROOT, _T("InfGenerator") );
    if ( ERROR_SUCCESS != lResult )
    {
        return E_FAIL;
    }

    // And our versioned PROGID entry
    lResult = DeleteKeyTree( HKEY_CLASSES_ROOT, _T("InfGenerator.1") );
    if ( ERROR_SUCCESS != lResult )
    {
        return E_FAIL;
    }

    return S_OK;
}

BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReasonFlag,
    PVOID pvReserved
    )
{
    // Remember instance handle
    g_hMyInstance = hInstance;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ini\ini.c ===
/*
 * Utility program to dump the contents of a Windows .ini file.
 * one form to another.  Usage:
 *
 *      ini [-f FileSpec] [SectionName | SectionName.KeywordName [= Value]]
 *
 *
 */

#include "ini.h"

BOOL fRefresh;
BOOL fSummary;
BOOL fUnicode;

void
DumpIniFileA(
            char *IniFile
            )
{
    char *Sections, *Section;
    char *Keywords, *Keyword;
    char *KeyValue;

    Sections = LocalAlloc( 0, 8192 );
    if (Sections) {
        memset( Sections, 0xFF, 8192 );
    } else {
        return;
    }
    Keywords = LocalAlloc( 0, 8192 );
    if (Keywords) {
        memset( Keywords, 0xFF, 8192 );
    } else {
        LocalFree(Sections);
        return;
    }
    KeyValue = LocalAlloc( 0, 2048 );
    if (KeyValue) {
        memset( KeyValue, 0xFF, 2048 );
    } else {
        LocalFree(Keywords);
        LocalFree(Sections);
        return;
    }

    *Sections = '\0';
    if (!GetPrivateProfileStringA( NULL, NULL, NULL,
                                   Sections, 8192,
                                   IniFile
                                 )
       ) {
        printf( "*** Unable to read - rc == %d\n", GetLastError() );
    }

    Section = Sections;
    while (*Section) {
        printf( "[%s]\n", Section );
        if (!fSummary) {
            *Keywords = '\0';
            GetPrivateProfileStringA( Section, NULL, NULL,
                                      Keywords, 4096,
                                      IniFile
                                    );
            Keyword = Keywords;
            while (*Keyword) {
                GetPrivateProfileStringA( Section, Keyword, NULL,
                                          KeyValue, 2048,
                                          IniFile
                                        );
                printf( "    %s=%s\n", Keyword, KeyValue );

                while (*Keyword++) {
                }
            }
        }

        while (*Section++) {
        }
    }

    LocalFree( Sections );
    LocalFree( Keywords );
    LocalFree( KeyValue );

    return;
}

void
DumpIniFileW(
            WCHAR *IniFileW
            )
{
    WCHAR *Sections, *Section;
    WCHAR *Keywords, *Keyword;
    WCHAR *KeyValue;

    Sections = LocalAlloc( 0, 8192 );
    if (Sections) {
        memset( Sections, 0xFF, 8192 );
    } else {
        return;
    }
    Keywords = LocalAlloc( 0, 8192 );
    if (Keywords) {
        memset( Keywords, 0xFF, 8192 );
    } else {
        LocalFree(Sections);
        return;
    }
    KeyValue = LocalAlloc( 0, 2048 );
    if (KeyValue) {
        memset( KeyValue, 0xFF, 2048 );
    } else {
        LocalFree(Keywords);
        LocalFree(Sections);
        return;
    }

    *Sections = '\0';
    if (!GetPrivateProfileStringW( NULL, NULL, NULL,
                                   Sections, 8192,
                                   IniFileW
                                 )
       ) {
        wprintf( L"*** Unable to read - rc == %d\n", GetLastError() );
    }

    Section = Sections;
    while (*Section) {
        wprintf( L"[%s]\n", Section );
        if (!fSummary) {
            *Keywords = '\0';
            GetPrivateProfileStringW( Section, NULL, NULL,
                                      Keywords, 4096,
                                      IniFileW
                                    );
            Keyword = Keywords;
            while (*Keyword) {
                GetPrivateProfileStringW( Section, Keyword, NULL,
                                          KeyValue, 2048,
                                          IniFileW
                                        );
                wprintf( L"    %s=%s\n", Keyword, KeyValue );

                while (*Keyword++) {
                }
            }
        }

        while (*Section++) {
        }
    }

    LocalFree( Sections );
    LocalFree( Keywords );
    LocalFree( KeyValue );

    return;
}


void
DumpIniFileSectionA(
                   char *IniFile,
                   char *SectionName
                   )
{
    DWORD cb;
    char *SectionValue;
    char *s;

    cb = 4096;
    while (TRUE) {
        SectionValue = LocalAlloc( 0, cb );
        if (!SectionValue) {
            return;
        }
        *SectionValue = '\0';
        if (GetPrivateProfileSection( SectionName,
                                      SectionValue,
                                      cb,
                                      IniFile
                                    ) == cb-2
           ) {
            LocalFree( SectionValue );
            cb *= 2;
        } else {
            break;
        }
    }

    printf( "[%s]\n", SectionName );
    s = SectionValue;
    while (*s) {
        printf( "    %s\n", s );

        while (*s++) {
        }
    }

    LocalFree( SectionValue );
    return;
}

void
DumpIniFileSectionW(
                   WCHAR *IniFile,
                   WCHAR *SectionName
                   )
{
    DWORD cb;
    WCHAR *SectionValue;
    WCHAR *s;
    cb = 4096;
    while (TRUE) {
        SectionValue = LocalAlloc( 0, cb );
        if (!SectionValue) {
            return;
        }
        *SectionValue = L'\0';
        if (GetPrivateProfileSectionW( SectionName,
                                       SectionValue,
                                       cb,
                                       IniFile
                                     ) == cb-2
           ) {
            LocalFree( SectionValue );
            cb *= 2;
        } else {
            break;
        }
    }

    wprintf( L"[%s]\n", SectionName );
    s = SectionValue;
    while (*s) {
        wprintf( L"    %s\n", s );

        while (*s++) {
        }
    }

    LocalFree( SectionValue );
    return;
}



void
Usage( void )
{
    fputs( "usage: INI | [-f FileSpec] [-r | [SectionName | SectionName.KeywordName [ = Value]]]\n"
           "Where...\n"
           "    -f  Specifies the name of the .ini file.  WIN.INI is the default.\n"
           "    -s  Print only the sections in the .ini file\n"
           "    -u  Use the Unicode version of GetPrivateProfileString\n"
           "\n"
           "    -r  Refresh the .INI file migration information for the specified file.\n"
           "\n"
           "        blanks around = sign are required when setting the value.\n",

           stderr);
    exit( 1 );
}

char KeyValueBuffer[ 4096 ];

int __cdecl
main( argc, argv )
int argc;
char *argv[];
{
    int i, n;
    LPSTR s, IniFile, SectionName, KeywordName, KeywordValue;
    WCHAR IniFileW[_MAX_PATH];
    WCHAR SectionNameW[_MAX_PATH];
    BOOL  rc;

    ConvertAppToOem( argc, argv );
    if (argc < 1) {
        Usage();
    }

    IniFile = "win.ini";
    SectionName = NULL;
    KeywordName = NULL;
    KeywordValue = NULL;
    argc -= 1;
    argv += 1;
    while (argc--) {
        s = *argv++;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch ( tolower( *s ) ) {
                    case 'r':   fRefresh = TRUE;
                        break;

                    case 's':   fSummary = TRUE;
                        break;

                    case 'u':   fUnicode = TRUE;
                        break;

                    case 'f':   if (argc) {
                            argc -= 1;
                            IniFile = *argv++;
                            break;
                        }

                    default:    Usage();
                }
            }
        } else
            if (SectionName == NULL) {
            if (argc && !strcmp( *argv, ".")) {
                SectionName = s;
                argc -= 1;
                argv += 1;
                if (argc) {
                    if (!strcmp( *argv, "=" )) {
                        argc -= 1;
                        argv += 1;
                        KeywordName = NULL;
                        if (argc) {
                            KeywordValue = calloc( 1, 4096 );
                            s = KeywordValue;
                            while (argc) {
                                strcpy( s, *argv++ );
                                s += strlen( s ) + 1;
                                argc -= 1;
                            }
                        } else {
                            KeywordValue = (LPSTR)-1;
                        }
                    } else {
                        argc -= 1;
                        KeywordName = *argv++;
                    }
                } else {
                    KeywordName = NULL;
                }
            } else
                if (KeywordName = strchr( s, '.' )) {
                *KeywordName++ = '\0';
                SectionName = s;
            } else {
                SectionName = s;
            }
        } else
            if (!strcmp( s, "=" )) {
            if (argc) {
                argc -= 1;
                KeywordValue = *argv++;
            } else {
                KeywordValue = (LPSTR)-1;
            }
        } else {
            Usage();
        }
    }

    if (fRefresh) {
        printf( "Refreshing .INI file mapping information for %s\n", IniFile );
        WritePrivateProfileString( NULL, NULL, NULL, IniFile );
        exit( 0 );
    }

    printf( "%s contents of %s\n", KeywordValue ? "Modifying" : "Displaying", IniFile );

    MultiByteToWideChar(GetACP(), 0, IniFile, strlen(IniFile)+1, IniFileW, sizeof(IniFileW)/sizeof(WCHAR));

    if (SectionName)
        MultiByteToWideChar(GetACP(), 0, SectionName, strlen(SectionName)+1, SectionNameW, sizeof(SectionNameW)/sizeof(WCHAR));

    if (SectionName == NULL) {
        if (fUnicode)
            DumpIniFileW( IniFileW );
        else
            DumpIniFileA( IniFile );
    } else
        if (KeywordName == NULL) {
        if (fUnicode)
            DumpIniFileSectionW( IniFileW, SectionNameW );
        else
            DumpIniFileSectionA( IniFile, SectionName );

        if (KeywordValue != NULL) {
            printf( "Above application variables are being deleted" );
            if (KeywordValue != (LPSTR)-1) {
                printf( " and rewritten" );
            } else {
                KeywordValue = NULL;
            }
            if (fUnicode) {
                WCHAR KeywordNameW[4096];
                WCHAR KeywordValueW[4096];

                MultiByteToWideChar(GetACP(), 0, KeywordName, strlen(KeywordName)+1, KeywordNameW, sizeof(KeywordNameW)/sizeof(WCHAR));
                if (KeywordValue)
                    MultiByteToWideChar(GetACP(), 0, KeywordValue, strlen(KeywordValue)+1, KeywordValueW, sizeof(KeywordValueW)/sizeof(WCHAR));

                rc = WritePrivateProfileStringW( SectionNameW,
                                                 KeywordNameW,
                                                 KeywordValue ? KeywordValueW : NULL,
                                                 IniFileW
                                               );
            } else {
                rc = WritePrivateProfileStringA( SectionName,
                                                 KeywordName,
                                                 KeywordValue,
                                                 IniFile
                                               );
            }

            if (!rc) {
                printf( " *** failed, ErrorCode -== %u\n", GetLastError() );
            } else {
                printf( " [ok]\n", GetLastError() );
            }
        }
    } else {
        printf( "[%s]\n    %s == ", SectionName, KeywordName );
        if (fUnicode) {
            WCHAR KeywordNameW[4096];
            MultiByteToWideChar(GetACP(), 0, KeywordName, strlen(KeywordName)+1, KeywordNameW, sizeof(KeywordNameW)/sizeof(WCHAR));

            n = GetPrivateProfileStringW( SectionNameW,
                                         KeywordNameW,
                                         L"*** Section or keyword not found ***",
                                         (LPWSTR)KeyValueBuffer,
                                         sizeof( KeyValueBuffer ),
                                         IniFileW
                                       );
        } else {
            n = GetPrivateProfileStringA( SectionName,
                                         KeywordName,
                                         "*** Section or keyword not found ***",
                                         KeyValueBuffer,
                                         sizeof( KeyValueBuffer ),
                                         IniFile
                                       );
        }

        if (KeywordValue == NULL && n == 0 && GetLastError() != NO_ERROR) {
            printf( " (ErrorCode == %u)\n", GetLastError() );
        } else {
            if (fUnicode)
                wprintf( L"%s", KeyValueBuffer );
            else
                printf( "%s", KeyValueBuffer );
            if (KeywordValue == NULL) {
                printf( "\n" );
            } else {
                if (KeywordValue == (LPSTR)-1) {
                    printf( " (deleted)" );
                    KeywordValue = NULL;
                } else {
                    printf( " (set to %s)", KeywordValue );
                }

                if (fUnicode) {
                    WCHAR KeywordNameW[4096];
                    WCHAR KeywordValueW[4096];

                    MultiByteToWideChar(GetACP(), 0, KeywordName, strlen(KeywordName)+1, KeywordNameW, sizeof(KeywordNameW)/sizeof(WCHAR));
                    if (KeywordValue)
                        MultiByteToWideChar(GetACP(), 0, KeywordValue, strlen(KeywordValue)+1, KeywordValueW, sizeof(KeywordValueW)/sizeof(WCHAR));

                    rc = WritePrivateProfileStringW( SectionNameW,
                                                     KeywordNameW,
                                                     KeywordValue ? KeywordValueW : NULL,
                                                     IniFileW
                                                   );
                } else {
                    rc = WritePrivateProfileStringA( SectionName,
                                                     KeywordName,
                                                     KeywordValue,
                                                     IniFile
                                                   );
                }

                if (!rc) {
                    printf( " *** failed, ErrorCode -== %u", GetLastError() );
                }
                printf( "\n" );
            }
        }
    }

    return ( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ioverify\main.cxx ===
//                                          
// System level IO verification configuration utility
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: main.cxx
// author: DMihai
// created: 04/19/99
// description: command line parsing and help information
//

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>

#include <common.ver>

#include "resid.hxx"
#include "resutil.hxx"
#include "regutil.hxx"

void
DisplayHelpInformation();

//////////////////////////////////////////////////////////

extern "C" void _cdecl
wmain( int argc, TCHAR *argv[] )
{
    BOOL bResult;
    DWORD dwVerifierLevel;
    
    TCHAR strCmdLineOption[ 64 ];

    dwVerifierLevel = -1;

    //
    // look for /enable
    //
    
    bResult = GetStringFromResources(
        IDS_ENABLE_CMDLINE_OPTION,
        strCmdLineOption,
        ARRAY_LEN( strCmdLineOption ) );
    
    if( bResult && argc >= 2 && _tcsicmp( argv[ 1 ], strCmdLineOption ) == 0 )
    {
        //
        // level is hardcoded for now
        //

        dwVerifierLevel = 3;

        //
        // this will exit process
        //

        EnableSysIoVerifier(
            dwVerifierLevel );
    }

    //
    // look for /disable
    //

    bResult = GetStringFromResources(
        IDS_DISABLE_CMDLINE_OPTION,
        strCmdLineOption,
        ARRAY_LEN( strCmdLineOption ) );

    if( bResult && argc == 2 && _tcsicmp( argv[ 1 ], strCmdLineOption ) == 0 )
    {
        //
        // get the name of the kernel module
        //
        //
        // this will exit process
        //

        DisableSysIoVerifier();
    }

    //
    // look for /status
    //

    bResult = GetStringFromResources(
        IDS_STATUS_CMDLINE_OPTION,
        strCmdLineOption,
        ARRAY_LEN( strCmdLineOption ) );

    if( bResult && argc == 2 && _tcsicmp( argv[ 1 ], strCmdLineOption ) == 0 )
    {
        //
        // this will exit process
        //

        DumpSysIoVerifierStatus();
    }

    DisplayHelpInformation();
}

///////////////////////////////////////////////////////////

void
DisplayHelpInformation()
{
    PrintStringFromResources( IDS_HELP_LINE1 );

    puts( VER_LEGALCOPYRIGHT_STR );

    PrintStringFromResources( IDS_HELP_LINE3 );
    PrintStringFromResources( IDS_HELP_LINE4 );
    PrintStringFromResources( IDS_HELP_LINE5 );
    PrintStringFromResources( IDS_HELP_LINE6 );
    PrintStringFromResources( IDS_HELP_LINE7 );
    PrintStringFromResources( IDS_HELP_LINE8 );
    PrintStringFromResources( IDS_HELP_LINE9 );

    exit( EXIT_CODE_NOTHING_CHANGED );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\infgen\simpledb.cpp ===
#include <tchar.h>
#include <stddef.h>
#include <mbctype.h>
#define DBINITCONSTANTS
#include <sqloledb.h>
#undef DBINITCONSTANTS
#include <oledberr.h>
#include "simpledb.h"

//
// CSimpleDatabase
//

CSimpleDatabase::CSimpleDatabase(
    void
    ) : m_bCreated(false), m_bSession(false)
{
    HRESULT hr;

    CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

    hr = CoCreateInstance( CLSID_MSDAINITIALIZE,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IDataInitialize,
                           (PVOID *)&m_pDataInit );
    if ( !FAILED(hr) )
    {
        m_bCreated = TRUE;
    }
}

CSimpleDatabase::~CSimpleDatabase(
    void
    )
{
    if ( NULL != m_pDataInit )
    {
        m_pDataInit->Release();
    }
    if ( NULL != m_pSession )
    {
        m_pSession->Release();
    }
    CoUninitialize();
}

HRESULT
CSimpleDatabase::Connect(
    LPCTSTR szServer,
    LPCTSTR szDatabase,
    LPCTSTR szUserName,
    LPCTSTR szPassword
    )
{
    HRESULT hr;
    DBPROP props[4];
    DBPROPSET  rgProps[1];
    DWORD dwNumProps = 0;
    IDBInitialize *pDBInitialize;
    IDBProperties *pDBProps;
#ifndef UNICODE
    wchar_t *wszTemp;
    size_t  lenTemp;
#endif

    if ( !m_bCreated )
    {
        return E_HANDLE;
    }

    // If this is not the first connection, reset
    if ( m_bSession )
    {
      m_pSession->Release();
      m_pSession = NULL;
      m_bSession = FALSE;
    }

    //
    // Set the connection properties
    //
    for ( short i = 0; i < 4; i++ )
    {
        VariantInit( &props[i].vValue );
    }

    // Server
    props[0].dwPropertyID   = DBPROP_INIT_DATASOURCE;
    props[0].vValue.vt      = VT_BSTR;
#ifndef UNICODE
    lenTemp = strlen(szServer) + 1;
    wszTemp = new wchar_t[lenTemp];
    if ( NULL == wszTemp )
    {
        return E_OUTOFMEMORY;
    }
    if ( 0 == MultiByteToWideChar( _getmbcp(),
                                   0L,
                                   szServer,
                                   lenTemp,
                                   wszTemp,
                                   lenTemp ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    props[0].vValue.bstrVal = SysAllocString( wszTemp );
    delete [] wszTemp;
#else
    props[0].vValue.bstrVal = SysAllocString( szServer );
#endif
    props[0].dwOptions      = DBPROPOPTIONS_REQUIRED;
    props[0].colid          = DB_NULLID;
    dwNumProps++;

    if ( szDatabase )
    {
        // Default Database
        props[1].dwPropertyID   = DBPROP_INIT_CATALOG;
        props[1].vValue.vt      = VT_BSTR;
#ifndef UNICODE
        lenTemp = strlen(szDatabase) + 1;
        wszTemp = new wchar_t[lenTemp];
        if ( NULL == wszTemp )
        {
            return E_OUTOFMEMORY;
        }
        if ( 0 == MultiByteToWideChar( _getmbcp(),
                                       0L,
                                       szDatabase,
                                       lenTemp,
                                       wszTemp,
                                       lenTemp ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    
        props[1].vValue.bstrVal = SysAllocString( wszTemp );
        delete [] wszTemp;
#else
        props[1].vValue.bstrVal = SysAllocString( szDatabase );
#endif
        props[1].dwOptions      = DBPROPOPTIONS_REQUIRED;
        props[1].colid          = DB_NULLID;
        dwNumProps++;
    }

    if ( szUserName )
    {
        // Username
        props[2].dwPropertyID   = DBPROP_AUTH_USERID;
        props[2].vValue.vt      = VT_BSTR;
#ifndef UNICODE
        lenTemp = strlen(szUserName) + 1;
        wszTemp = new wchar_t[lenTemp];
        if ( NULL == wszTemp )
        {
            return E_OUTOFMEMORY;
        }
        if ( 0 == MultiByteToWideChar( _getmbcp(),
                                       0L,
                                       szUserName,
                                       lenTemp,
                                       wszTemp,
                                       lenTemp ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    
        props[2].vValue.bstrVal = SysAllocString( wszTemp );
        delete [] wszTemp;
#else
        props[2].vValue.bstrVal = SysAllocString( szUserName );
#endif
        props[2].dwOptions      = DBPROPOPTIONS_REQUIRED;
        props[2].colid          = DB_NULLID;
        dwNumProps++;
    
        // Password
        props[3].dwPropertyID   = DBPROP_AUTH_PASSWORD;
        props[3].vValue.vt      = VT_BSTR;
#ifndef UNICODE
        lenTemp = strlen(szPassword) + 1;
        wszTemp = new wchar_t[lenTemp];
        if ( NULL == wszTemp )
        {
            return E_OUTOFMEMORY;
        }
        if ( 0 == MultiByteToWideChar( _getmbcp(),
                                       0L,
                                       szPassword,
                                       lenTemp,
                                       wszTemp,
                                       lenTemp ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    
        props[3].vValue.bstrVal = SysAllocString( wszTemp );
        delete [] wszTemp;
#else
        props[3].vValue.bstrVal = SysAllocString( szPassword );
#endif
        props[3].dwOptions      = DBPROPOPTIONS_REQUIRED;
        props[3].colid          = DB_NULLID;
        dwNumProps++;
    }
    else
    {
        // Use Windows authentication
        props[3].dwPropertyID   = DBPROP_AUTH_INTEGRATED;
        props[3].vValue.vt      = VT_BSTR;
        props[3].vValue.bstrVal = NULL;
        props[3].dwOptions      = DBPROPOPTIONS_REQUIRED;
        props[3].colid          = DB_NULLID;
        dwNumProps++;
    }

    hr = m_pDataInit->CreateDBInstance( CLSID_SQLOLEDB,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        NULL,
                                        IID_IDBInitialize,
                                        (IUnknown **)&pDBInitialize );
    if ( FAILED(hr) ) { return hr; }
    
    hr = pDBInitialize->QueryInterface( IID_IDBProperties, (PVOID *)&pDBProps );
    if ( FAILED(hr) ) { return hr; }

    rgProps[0].guidPropertySet = DBPROPSET_DBINIT;
    rgProps[0].cProperties     = dwNumProps;
    rgProps[0].rgProperties    = props;

    hr = pDBProps->SetProperties(1, rgProps);
    pDBProps->Release();
    if ( FAILED(hr) ) { return hr; }

    hr = pDBInitialize->Initialize();
    if ( FAILED(hr) )
    {
        pDBInitialize->Release();
        return hr;
    }

    hr = EstablishSession( pDBInitialize );
    pDBInitialize->Release();

    return hr;
}

HRESULT
CSimpleDatabase::EstablishSession(
    IDBInitialize *pDBInitialize
    )
{
    HRESULT hr;
    IDBCreateSession *pCreateSession = NULL;

    hr = pDBInitialize->QueryInterface( IID_IDBCreateSession,
                                        (PVOID *)&pCreateSession );
    if ( FAILED(hr) ) { return hr; }

    hr = pCreateSession->CreateSession( NULL, IID_IDBCreateCommand, (IUnknown **)&m_pSession );
    if ( FAILED(hr) )
    {
        pCreateSession->Release();
        return hr;
    }

    pCreateSession->Release();

    m_bSession = FALSE;

    return S_OK;
}

HRESULT
CSimpleDatabase::Execute(
    LPCTSTR szCommand,
    CSimpleDBResults **ppOutResults
    )
{
    HRESULT hr;
    ICommandText *pCommandText = NULL;
    IMultipleResults *pResults = NULL;
    DBROWCOUNT cRowsAffected;

    if ( NULL != ppOutResults )
    {
        *ppOutResults = NULL;
    }
    
    hr = m_pSession->CreateCommand( NULL, IID_ICommandText, (IUnknown **)&pCommandText );
    if ( FAILED(hr) ) { return hr; }

#ifndef UNICODE
    size_t  lenTemp = strlen(szCommand) + 1;
    wchar_t *wszTemp = new wchar_t[lenTemp];
    if ( NULL == wszTemp )
    {
        return E_OUTOFMEMORY;
    }
    if ( 0 == MultiByteToWideChar( _getmbcp(),
                                   0L,
                                   szCommand,
                                   lenTemp,
                                   wszTemp,
                                   lenTemp ) )
    {
        pCommandText->Release();
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    hr = pCommandText->SetCommandText( DBGUID_DBSQL, wszTemp );
    delete [] wszTemp;

#else
    hr = pCommandText->SetCommandText( DBGUID_DBSQL, szCommand );
#endif
    if ( FAILED(hr) )
    {
        pCommandText->Release();
        return hr;
    }

    hr = pCommandText->Execute( NULL, IID_IMultipleResults, NULL, &cRowsAffected, (IUnknown **)&pResults );
    if ( FAILED(hr) )
    {
        pCommandText->Release();
        return hr;
    }

    // If the command succeeded but didn't return any results, return successfully
    if ( cRowsAffected != -1 )
    {
        return S_FALSE;
    }

    *ppOutResults = new CSimpleDBResults( pResults );
    pResults->Release();

    if ( NULL == *ppOutResults )
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//
// CSimpleDBResults
//

CSimpleDBResults::CSimpleDBResults(
    IMultipleResults *pResults
    ) : m_pResults(NULL),
        m_pCurRowset(NULL),
        m_phRow(NULL),
        m_rgColumnInfo(NULL),
        m_pColumnBuf(NULL),
        m_colInfo(NULL),
        m_numColumns(0)
{
    m_pResults = pResults;
    m_pResults->AddRef();

    NextResultSet();
}

CSimpleDBResults::~CSimpleDBResults(
    void
    )
{
    FreeRow();
    FreeRowset();
    m_pResults->Release();
}

HRESULT
CSimpleDBResults::NextResultSet(
    void
    )
{
    HRESULT hr;
    DBROWCOUNT cRowsAffected;
    IColumnsInfo *pColInfo = NULL;

    FreeRowset();

    hr = m_pResults->GetResult( NULL, 0, IID_IRowset, &cRowsAffected, (IUnknown **)&m_pCurRowset );
    if ( FAILED(hr) ) { return hr; }

    // Store column info
    hr = m_pCurRowset->QueryInterface( IID_IColumnsInfo, (PVOID *)&pColInfo );
    if ( FAILED(hr) ) { return hr; }

    hr = pColInfo->GetColumnInfo( &m_numColumns, &m_rgColumnInfo, &m_pColumnBuf );
    pColInfo->Release();
    if ( FAILED(hr) ) { return hr; }

    m_colInfo = new ColInfo[m_numColumns];
    if ( NULL == m_colInfo )
    {
        return E_OUTOFMEMORY;
    }

    memset( (PVOID)m_colInfo, 0, sizeof(ColInfo) * m_numColumns );

    return S_OK;
}

void
CSimpleDBResults::FreeRowset(
    void
    )
{
    IAccessor *pAccessor = NULL;

    if ( m_pCurRowset )
    {
        if ( FAILED(m_pCurRowset->QueryInterface( IID_IAccessor, (PVOID *)&pAccessor )) )
        {
            pAccessor = NULL;
        }
    }
    if ( NULL != m_rgColumnInfo )
    {
        CoTaskMemFree( m_rgColumnInfo );
        m_rgColumnInfo = NULL;
    }
    if ( NULL != m_pColumnBuf )
    {
        CoTaskMemFree( m_pColumnBuf );
        m_pColumnBuf = NULL;
    }
    if ( NULL != m_colInfo )
    {
        for ( DWORD i = 0; i < m_numColumns; i++ )
        {
#ifndef UNICODE
            if ( NULL != m_colInfo[i].szColumnName )
            {
                delete [] m_colInfo[i].szColumnName;
            }
#endif
            if ( pAccessor && m_colInfo[i].hAccessor )
            {
                pAccessor->ReleaseAccessor( m_colInfo[i].hAccessor, NULL );
            }
        }
        delete [] m_colInfo;
        m_colInfo = NULL;
    }

    if ( pAccessor )
    {
        pAccessor->Release();
    }

    if ( m_pCurRowset )
    {
        m_pCurRowset->Release();
    }

    m_numColumns = 0;
}

void
CSimpleDBResults::FreeRow(
    void
    )
{
    if ( NULL != m_phRow )
    {
        m_pCurRowset->ReleaseRows( 1, m_phRow, NULL, NULL, NULL );
        m_phRow = NULL;
    }
}

HRESULT
CSimpleDBResults::NextRow(
    void
    )
{
    HRESULT hr;
    DBCOUNTITEM cRowsReturned;

    FreeRow();

    hr = m_pCurRowset->GetNextRows( DB_NULL_HCHAPTER, 0, 1, &cRowsReturned, &m_phRow );
    if ( DB_S_ENDOFROWSET == hr )
    {
        return S_FALSE;
    }
    else if ( FAILED(hr) )
    {
        return hr; 
    }
    
    return S_OK;
}

HRESULT
CSimpleDBResults::GetFieldValue(
    LPCTSTR szField,
    LPTSTR  szValue,
    DWORD   dwMaxChars
    )
{
    HRESULT hr;

    DWORD col;
    IAccessor *pAccessor = NULL;
    DBBINDING rgBindings[1];
    DBBINDSTATUS rgStatus[1];
    PVOID pBuf;

    szValue[0] = _T('\0');

    // Look through column names for specified field
    for ( col = 0; col < m_numColumns; col++ )
    {
        TCHAR *szColName;
#ifndef UNICODE
        if ( NULL == m_colInfo[col].szColumnName )
        {
            size_t lenName = wcslen(m_rgColumnInfo[col].pwszName) + 1;
            m_colInfo[col].szColumnName = new char[lenName];
            if ( NULL == m_colInfo[col].szColumnName )
            {
                return E_OUTOFMEMORY;
            }

            if ( 0 == WideCharToMultiByte( CP_ACP,
                                           0L,
                                           m_rgColumnInfo[col].pwszName,
                                           lenName,
                                           m_colInfo[col].szColumnName,
                                           lenName,
                                           NULL,
                                           NULL ) ) {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
        }
        szColName = m_colInfo[col].szColumnName;
#else
        szColName = m_rgColumnInfo[col].pwszName;
#endif

        if ( !_tcsicmp( szColName, szField ) )
        {
            break;
        }
    }

    // Column is not in current rowset
    if ( col >= m_numColumns )
    {
        return S_FALSE;
    }

    if ( !m_colInfo[col].hAccessor )
    {
        memset( rgBindings, 0, sizeof(DBBINDING) );
        rgBindings[0].iOrdinal   = m_rgColumnInfo[col].iOrdinal;
        rgBindings[0].dwPart     = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
        rgBindings[0].dwFlags    = 0;
        rgBindings[0].obStatus   = offsetof(_BindResult, status);
        rgBindings[0].obLength   = offsetof(_BindResult, length);
        rgBindings[0].obValue    = offsetof(_BindResult, value);
        rgBindings[0].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
        rgBindings[0].eParamIO   = DBPARAMIO_NOTPARAM;
        rgBindings[0].bPrecision = m_rgColumnInfo[col].bPrecision;
        rgBindings[0].bScale     = m_rgColumnInfo[col].bScale;
        rgBindings[0].wType      = DBTYPE_WSTR;
        rgBindings[0].cbMaxLen   = dwMaxChars * sizeof(WCHAR);
    
        hr = m_pCurRowset->QueryInterface( IID_IAccessor, (PVOID *)&pAccessor );
        if ( FAILED(hr) ) { return hr; }
    
        hr = pAccessor->CreateAccessor( DBACCESSOR_ROWDATA,
                                        1,
                                        rgBindings,
                                        0,
                                        &m_colInfo[col].hAccessor,
                                        rgStatus );
        pAccessor->Release();
        if ( FAILED(hr) ) { return hr; }
    }

    // Setup a buffer large enough to hold max results
    pBuf = (PVOID)new BYTE[ sizeof(_BindResult) + dwMaxChars * sizeof(WCHAR) ];
    if ( NULL == pBuf )
    {
        return E_OUTOFMEMORY;
    }
    hr = m_pCurRowset->GetData( *m_phRow, m_colInfo[col].hAccessor, pBuf );
    if ( FAILED(hr) ) { return hr; }

    // Skip status and length and just get the result for now
    wchar_t *wszValue = (LPWSTR)((DWORD_PTR)pBuf + offsetof(_BindResult, value));

#ifndef UNICODE
    if ( 0 == WideCharToMultiByte( CP_ACP,
                                   0L,
                                   wszValue,
                                   -1,
                                   szValue,
                                   dwMaxChars,
                                   NULL,
                                   NULL ) ) {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

#else
    wcscpy( szValue, wszValue );
#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kbdtool\getopt.c ===
/*
        getopt.c

        modified public-domain AT&T getopt(3)
*/

#include <stdio.h>
#include <string.h>

#ifdef _POSIX_SOURCE
#       include <unistd.h>
#else
#       define STDERR_FILENO 2
#       ifdef __STDC__
                extern int write (int fildes, char * buf, unsigned nbyte);
#       else
                extern int write ();
#       endif
#endif

int opterr = 1;
int optind = 1;
int optopt;
char *optarg;

static void ERR(char **argv, char *s, char c)
{
    if (opterr) {
        fprintf(stderr, "%s%s%c\n", argv[0], s, c);
    }
}

int getopt(int argc, char **argv, char *opts)
{
    static int sp = 1, error = (int) '?';
    static char sw = '-', eos = '\0', arg = ':';
    char c, * cp;

    if (sp == 1)
        if (optind >= argc || argv[optind][0] != sw
            || argv[optind][1] == eos)
            return EOF;
        else if (strcmp(argv[optind],"--") == 0) {
            optind++;
            return EOF;
        }
    c = argv[optind][sp];
    optopt = (int) c;
    if (c == arg || (cp = strchr(opts,c)) == NULL) {
        ERR(argv,": illegal option: -",c);
        if (argv[optind][++sp] == eos) {
            optind++;
            sp = 1;
        }
        return error;
    }
    else if (*++cp == arg) {
        if (argv[optind][sp + 1] != eos)
            optarg = &argv[optind++][sp + 1];
        else if (++optind >= argc) {
            ERR(argv,": option requires an argument--",c);
            sp = 1;
            return error;
        }
        else
            optarg = argv[optind++];
        sp = 1;
    }
    else {
        if (argv[optind][++sp] == eos) {
            sp = 1;
            optind++;
        }
        optarg = NULL;
    }
    return (int)c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ioverify\resutil.cxx ===
//
// System level IO verification configuration utility
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: resutil.cxx
// author: DMihai
// created: 04/19/99
// description: resources manipulation routines
//

#include <windows.h>
#include <tchar.h>

#include "resutil.hxx"

//////////////////////////////////////////////////////////////////////

BOOL
GetStringFromResources(
    UINT uIdResource,
    TCHAR *strResult,
    int nBufferLen )
{
    UINT LoadStringResult;

    LoadStringResult = LoadString (
        GetModuleHandle (NULL),
        uIdResource,
        strResult,
        nBufferLen );

    assert_ (LoadStringResult > 0);

    return (LoadStringResult > 0);
}

//////////////////////////////////////////////////////////////////////
void
PrintStringFromResources(

    UINT uIdResource)
{
    TCHAR strStringFromResource[ 1024 ];
    BOOL bResult;

    bResult = GetStringFromResources(
        uIdResource,
        strStringFromResource,
        ARRAY_LEN( strStringFromResource ) );

    if( bResult == TRUE )
    {
        _putts( strStringFromResource );
    }
}

//////////////////////////////////////////////////////////////////////

void
__cdecl
DisplayErrorMessage(
    UINT uFormatResId,
    ... )
{
    TCHAR strMsgFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    va_start (prms, uFormatResId);

    bResult = GetStringFromResources(
        uFormatResId,
        strMsgFormat,
        ARRAY_LEN( strMsgFormat ) );

    if( bResult == TRUE )
    {
        _vtprintf ( strMsgFormat, prms);
        _tprintf ( _TEXT( "\n" ) );
    }

    va_end (prms);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ioverify\regutil.cxx ===
//                                          
// System level IO verification configuration utility
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: regutil.cxx
// author: DMihai
// created: 04/19/99
// description: registry keys manipulation routines
//

extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
}

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>

#include "ResId.hxx"
#include "ResUtil.hxx"
#include "RegUtil.hxx"

#define VRF_MAX_DRIVER_STRING_LENGTH    4196

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Registry Strings
//////////////////////////////////////////////////////////////////////

LPCTSTR RegMemoryManagementKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

LPCTSTR RegMmVerifyDriverLevelValueName =
    TEXT ("VerifyDriverLevel");

LPCTSTR RegVerifyDriversValueName =
TEXT ("VerifyDrivers");

LPCTSTR RegSessionManagerKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager");

LPCTSTR RegIOVerifyKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\I/O System");

LPCTSTR RegIOVerifySubKeyName = 
    TEXT ("I/O System");

LPCTSTR RegIOVerifyLevelValueName =
    TEXT ("IoVerifierLevel");

//////////////////////////////////////////////////////////////////////
/////////////// Forward decl for local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (
    HKEY hKey,
    LPCTSTR Name,
    DWORD * Value);

BOOL
WriteRegistryValue (
    HKEY hKey,
    LPCTSTR Name,
    DWORD Value);

BOOL
ReadRegistryString (
    HKEY hKey,
    LPCTSTR Name,
    LPTSTR Buffer,
    DWORD BufferSize );

BOOL
WriteRegistryString (
    HKEY hKey,
    LPCTSTR Name,
    LPTSTR Value);

BOOL
IsKernelVerifierEnabled( HKEY MmKey );

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Public functions
//////////////////////////////////////////////////////////////////////

void
EnableSysIoVerifier(
    DWORD dwNewVerifierLevel )
{
    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    HKEY SmKey = NULL;
    DWORD dwExitCode;
    DWORD dwCrtFlags;
    DWORD dwCrtSysVerifierLevel;
    LONG lResult;

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &MmKey);

    if (lResult != ERROR_SUCCESS) 
    {
        dwExitCode = EXIT_CODE_ERROR;

        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayErrorMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }
    }
    else
    {
        if( IsKernelVerifierEnabled( MmKey ) )
        {
            //
            // must disable kernel verifier first
            //

            dwExitCode = EXIT_CODE_ERROR;

            DisplayErrorMessage( IDS_KVERIFY_ENABLED );
        }
        else
        {
            //
            // Open the "I/O System" key
            //

            lResult = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                RegIOVerifyKeyName,
                0,
                KEY_QUERY_VALUE | KEY_WRITE,
                &IoKey);

            if( lResult != ERROR_SUCCESS )
            {
                dwExitCode = EXIT_CODE_ERROR;

                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    //
                    // access is denied
                    //

                    DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
                }
                else
                {
                    if( lResult == ERROR_FILE_NOT_FOUND ) 
                    {
                        //
                        // the "I/O System" key doesn't exist, try to create it
                        //

                        //
                        // open the "Session Manager" key
                        //

                        lResult = RegOpenKeyEx (
                            HKEY_LOCAL_MACHINE,
                            RegSessionManagerKeyName,
                            0,
                            KEY_QUERY_VALUE | KEY_WRITE,
                            &SmKey);

                        if( lResult != ERROR_SUCCESS )
                        {
                            DisplayErrorMessage( 
                                IDS_REGOPENKEYEX_FAILED,
                                RegSessionManagerKeyName,
                                (DWORD)lResult);
                        }
                        else
                        {
                            //
                            // create the "I/O System" key
                            //

                            lResult = RegCreateKeyEx(
                                SmKey,
                                RegIOVerifySubKeyName,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE | KEY_QUERY_VALUE,
                                NULL,
                                &IoKey,
                                NULL );

                            if( lResult != ERROR_SUCCESS )
                            {
                                DisplayErrorMessage( 
                                    IDS_REGCREATEKEYEX_FAILED,
                                    RegIOVerifySubKeyName,
                                    (DWORD)lResult);
                            }
                            else
                            {
                                //
                                // recover from RegOpenKeyEx failure - reset the error code
                                //

                                dwExitCode = EXIT_CODE_NOTHING_CHANGED;
                            }

                            //
                            // close the "Session Manager" key
                            //

                            lResult = RegCloseKey(
                                SmKey );
                        }
                    }
                    else
                    {
                        // 
                        // other error opening the "I/O System" key
                        //
                    
                        DisplayErrorMessage( 
                            IDS_REGOPENKEYEX_FAILED,
                            RegIOVerifyKeyName,
                            (DWORD)lResult);
                    }
                }
            }

            if( dwExitCode != EXIT_CODE_ERROR )
            {
                //
                // read "Mm\VerifyDriverLevel" value
                //

                if( ReadRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
                {
                    dwExitCode = EXIT_CODE_ERROR;
                }
                else
                {
                    if( dwCrtFlags == -1 )
                    {
                        //
                        // could not find the value
                        //
                    
                        dwCrtFlags = 0;
                    }

                    if( ( dwCrtFlags & DRIVER_VERIFIER_IO_CHECKING ) == 0 )
                    {
                        //
                        // set DRIVER_VERIFIER_IO_CHECKING bit in "Mm\VerifyDriverLevel" value
                        //

                        dwCrtFlags |= DRIVER_VERIFIER_IO_CHECKING ;

                        if( WriteRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, dwCrtFlags ) == FALSE )
                        {
                            //
                            // cannot recover from this
                            //

                            dwExitCode = EXIT_CODE_ERROR;
                        }
                        else
                        {
                            dwExitCode = EXIT_CODE_REBOOT;
                        }
                    }
                }

                if( dwExitCode != EXIT_CODE_ERROR )
                {
                    if( ReadRegistryValue( IoKey, RegIOVerifyLevelValueName, &dwCrtSysVerifierLevel ) == FALSE )
                    {
                        dwExitCode = EXIT_CODE_ERROR;
                    }
                    else
                    {
                        if( dwCrtSysVerifierLevel != dwNewVerifierLevel )
                        {
                            //
                            // set "I/O System\IoVerifierLevel" value
                            //

                            if( WriteRegistryValue( IoKey, RegIOVerifyLevelValueName, dwNewVerifierLevel ) == FALSE )
                            {
                                //
                                // cannot recover from this
                                //

                                dwExitCode = EXIT_CODE_ERROR;
                            }
                            else
                            {
                                dwExitCode = EXIT_CODE_REBOOT;
                            }
                        }
                    }
                }

                RegCloseKey (IoKey);
            }
        }

        RegCloseKey (MmKey);
    }

    if( EXIT_CODE_REBOOT == dwExitCode )
    {
        DisplayErrorMessage( IDS_MUST_REBOOT );
    }
    else
    {
        if( EXIT_CODE_NOTHING_CHANGED == dwExitCode )
        {
            DisplayErrorMessage( IDS_NOTHING_CHANGED );
        }
    }

    exit( dwExitCode );
}

///////////////////////////////////////////////////////////////////

void
DisableSysIoVerifier( void )
{
    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    DWORD dwExitCode;
    DWORD dwCrtFlags;
    LONG lResult;

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &MmKey);

    if (lResult != ERROR_SUCCESS) 
    {
        dwExitCode = EXIT_CODE_ERROR;

        if( lResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayErrorMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lResult);
        }
    }
    else
    {
        //
        // read "Mm\VerifyDriverLevel" value
        //

        if( ReadRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            if( ( dwCrtFlags != -1 ) && 
                ( ( dwCrtFlags & DRIVER_VERIFIER_IO_CHECKING ) != 0 ) )
            {
                //
                // wipe out the DRIVER_VERIFIER_IO_CHECKING flag
                //

                dwCrtFlags &= ~DRIVER_VERIFIER_IO_CHECKING;

                if( WriteRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, dwCrtFlags ) == FALSE )
                {
                    //
                    // cannot recover from this
                    //

                    dwExitCode = EXIT_CODE_ERROR;
                }
                else
                {
                    dwExitCode = EXIT_CODE_REBOOT;
                }
            }
        }

        RegCloseKey (MmKey);
    }

    if( dwExitCode != EXIT_CODE_ERROR )
    {
        //
        // open the "I/O" key
        //

        lResult = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            RegIOVerifyKeyName,
            0,
            KEY_QUERY_VALUE | KEY_WRITE,
            &IoKey);

        if (lResult != ERROR_SUCCESS) 
        {
            if( lResult != ERROR_FILE_NOT_FOUND )
            {
                dwExitCode = EXIT_CODE_ERROR;

                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
                }
                else 
                {
                    DisplayErrorMessage( 
                        IDS_REGOPENKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)lResult);
                }
            }
        }
        else
        {
            //
            // delete "I/O System\IoVerifierLevel" value
            //

            lResult = RegDeleteValue(
                IoKey,
                RegIOVerifyLevelValueName );

            if( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND )
            {
                dwExitCode = EXIT_CODE_ERROR;

                DisplayErrorMessage( 
                    IDS_REGDELETEVALUE_FAILED,
                    RegIOVerifyLevelValueName,
                    (DWORD)lResult);
            }
            
            RegCloseKey (IoKey);
        }
    }

    if( EXIT_CODE_REBOOT == dwExitCode )
    {
        DisplayErrorMessage( IDS_MUST_REBOOT );
    }
    else
    {
        if( EXIT_CODE_NOTHING_CHANGED == dwExitCode )
        {
            DisplayErrorMessage( IDS_NOTHING_CHANGED );
        }
    }

    exit( dwExitCode );
}

//////////////////////////////////////////////////

void
DumpSysIoVerifierStatus( void )
{
    HKEY MmKey = NULL;
    HKEY IoKey = NULL;
    DWORD dwExitCode;
    DWORD dwCrtFlags;
    DWORD dwCrtSysVerifLevel;
    LONG lResult;
    BOOL bMmFlagIsSet = FALSE;

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE,
        &MmKey);

    if (lResult != ERROR_SUCCESS) 
    {
        if( lResult != ERROR_FILE_NOT_FOUND )
        {
            dwExitCode = EXIT_CODE_ERROR;

            if( lResult == ERROR_ACCESS_DENIED ) 
            {
                DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
            }
            else 
            {
                DisplayErrorMessage( 
                    IDS_REGOPENKEYEX_FAILED,
                    RegMemoryManagementKeyName,
                    (DWORD)lResult);
            }
        }
    }
    else
    {
        //
        // read "Mm\VerifyDriverLevel" value
        //

        if( ReadRegistryValue( MmKey, RegMmVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            if( ( dwCrtFlags != -1 ) && 
                ( ( dwCrtFlags & DRIVER_VERIFIER_IO_CHECKING ) != 0 ) )
            {
                //
                // DRIVER_VERIFIER_IO_CHECKING is set
                //
                
                bMmFlagIsSet = TRUE;
            }
        }


        RegCloseKey (MmKey);
    }

    if( dwExitCode != EXIT_CODE_ERROR && bMmFlagIsSet )
    {
        //
        // open the "I/O" key
        //

        lResult = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            RegIOVerifyKeyName,
            0,
            KEY_QUERY_VALUE | KEY_WRITE,
            &IoKey);

        if (lResult != ERROR_SUCCESS) 
        {
            if( lResult != ERROR_FILE_NOT_FOUND )
            {
                dwExitCode = EXIT_CODE_ERROR;

                if( lResult == ERROR_ACCESS_DENIED ) 
                {
                    DisplayErrorMessage( IDS_ACCESS_IS_DENIED );
                }
                else 
                {
                    DisplayErrorMessage( 
                        IDS_REGOPENKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)lResult);
                }
            }
        }
        else
        {
            //
            // read "I/O System\IoVerifierLevel" value
            //

            if( ReadRegistryValue( IoKey, RegIOVerifyLevelValueName, &dwCrtSysVerifLevel ) == FALSE )
            {
                dwExitCode = EXIT_CODE_ERROR;
            }
            
            RegCloseKey (IoKey);
        }
    }

    if( dwExitCode != EXIT_CODE_ERROR )
    {
        if( bMmFlagIsSet && 
            ( dwCrtSysVerifLevel == 2 || dwCrtSysVerifLevel == 3 ) )
        {
            DisplayErrorMessage( 
                IDS_VERIFIER_ENABLED_FORMAT,
                dwCrtSysVerifLevel);
        }
        else
        {
            DisplayErrorMessage( 
                IDS_VERIFIER_NOT_ENABLED_FORMAT );
        }
    }

    exit( dwExitCode );
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////// Local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (

    HKEY hKey,
    LPCTSTR Name,
    DWORD * Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
    
    //
    // default value
    //

    *Value = -1;
    
    Size = sizeof( *Value );
  
    Result = RegQueryValueEx (
        hKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Value),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) 
    {
        *Value = -1;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            Result);
      
        return FALSE;
    }
    
    if (Type != REG_DWORD) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);
      
        return FALSE;
    }
    
    if (Size != sizeof *Value) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_SIZE,
            Name);
      
        return FALSE;
    }
    
    return TRUE;
}



BOOL
WriteRegistryValue (

    HKEY hKey,
    LPCTSTR Name,
    DWORD Value)
{
    LONG Result;
    
    Result = RegSetValueEx (
        hKey,
        Name,
        0,
        REG_DWORD,
        (LPBYTE)(&Value),
        sizeof Value);


    if (Result != ERROR_SUCCESS) 
    {
        DisplayErrorMessage ( 
            IDS_REGSETVALUEEX_FAILED,
            Name,
            Result);
     
        return FALSE;
    }
    
    return TRUE;
}


BOOL
ReadRegistryString (

    HKEY hKey,
    LPCTSTR Name,
    LPTSTR Buffer,
    DWORD BufferSize )
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
    
    //
    // default value
    //

    *Buffer = 0;

    Size = BufferSize;
  
    Result = RegQueryValueEx (
        hKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Buffer),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) 
    {
        *Buffer = 0;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            Result);
      
        return FALSE;
    }
    
    if (Type != REG_SZ) 
    {
        DisplayErrorMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);
      
        return FALSE;
    }
    
    return TRUE;
}


BOOL
WriteRegistryString (

    HKEY hKey,
    LPCTSTR Name,
    LPTSTR Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
   
    Result = RegSetValueEx (

        hKey,
        Name,
        0,
        REG_SZ,
        (LPBYTE)(Value),
        (_tcslen (Value) + 1) * sizeof (TCHAR));

    if (Result != ERROR_SUCCESS) 
    {
        DisplayErrorMessage ( 
            IDS_REGSETVALUEEX_FAILED,
            Name,
            Result);
      
        return FALSE;
    }
    
    return TRUE;
}

BOOL
IsKernelVerifierEnabled( HKEY MmKey )
{
    BOOL bKernelVerified;
    int nKernelModuleNameLen;
    TCHAR *pstrCrtNameMatch, *pstrSubstring, *pCrtChar;
    TCHAR strVrfDriver [VRF_MAX_DRIVER_STRING_LENGTH];
    const TCHAR strKernelModuleName[] = _T( "ntoskrnl.exe" );

    bKernelVerified = FALSE;

    if( ReadRegistryString (MmKey, RegVerifyDriversValueName, strVrfDriver, sizeof( strVrfDriver ) ) ) 
    {
        pstrSubstring = _tcsstr( strVrfDriver, strKernelModuleName );
    
        if( pstrSubstring != NULL )
        {
            // 
            // the name seems to be already there
            //

            pCrtChar = strVrfDriver;

            while( pCrtChar < pstrSubstring )
            {
                if( (*pCrtChar) != _T( ' ' ) && (*pCrtChar) != _T( '\t' ) )
                {
                    //
                    // non-blanc character before the name
                    //

                    break;
                }

                pCrtChar ++;
            }

            if( pCrtChar >= pstrSubstring )
            {
                //
                // the module name begins as the first non-blanc character
                //

                nKernelModuleNameLen = _tcsclen( strKernelModuleName );

                if( pstrSubstring[ nKernelModuleNameLen ] == (TCHAR)0    ||
                    pstrSubstring[ nKernelModuleNameLen ] == _T( ' ' )   ||
                    pstrSubstring[ nKernelModuleNameLen ] == _T( '\t' ) )
                {
                    bKernelVerified = TRUE;
                }
            }
        }
    }

    return bKernelVerified;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\job\job.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    job.c

Abstract:

    A user mode app that allows creation and management of jobs.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include "jobmgr.h"

void PrintHelp(char *Command);

DWORD TestCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD HelpCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD CreateJobCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD KillJobCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD ExecuteCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD QueryJobCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD AssignProcessCommand(PCOMMAND commandEntry, int argc, char *argv[]);
DWORD SetPriorityCommand(PCOMMAND CommandEntry,int argc, char *argv[]);

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"create", 
     "creates the specified job object", 
     "jobmgr create [-h] <job name> [process name [args ...]]\n"
        "  Creates a job object with the specified name.\n"
        "    -h - jobmgr will sleep after creating the job object until cancelled.\n"
        "    <job name> - specifies the job name.\n",
     CreateJobCommand
    },

    {"exec",
     "executes a program in the specified job object",
     "jobmgr exec <job name> <command> [args ...]\n"
        "  Executes the command in the specified job.\n"
        "    <command> - [quoted] string specifying the command any any arguments.\n",
     ExecuteCommand
    },

    {"help", 
     "help for all commands", 
     "jobmgr help [command]\n"
        "  Lists help for specified command or all commands.\n", 
     HelpCommand},

    {"assign", 
     "assigns a process to the specified job",
     "jobmgr assign <job name> <process id>\n"
        "  Associates the process with the specified job.\n",
     AssignProcessCommand
    },

    {"kill",
     "kills a job object and associated processes",
     "kill <job name>\n",
     KillJobCommand},

    {"query",
     "queries information about a job object",
     "query [-alpsu | -*] <job name>\n"
        "  a - dump accounting (basic & io) information\n"
        "  l - dump limit (basic & extended) information\n"
        "  p - dump process ID list\n"
        "  s - dump security limit information\n"
        "  u - dump UI restrictions\n"
        "  * - dump all information (cannot be specified with other options)\n"
        "  if no options are specified the process ID list will be dumped\n.",
     QueryJobCommand},

    {"setpriority",
     "Sets priority for processes within the job 0 - 5.  0 = Idle, 5 = Realtime, 2 = Normal.",
     "setpriority <job name> <priority>\n",
     SetPriorityCommand},

    {"test", 
     NULL, 
     "jobmgr test [arg]...\n", 
     TestCommand},

    {NULL, NULL, NULL}
    };

int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    char buffer[32];

    if(argc < 2) {
        printf("Usage: jobmgr <command> [parameters]\n");
        printf("possible commands: \n");
        HelpCommand(NULL, argc - 1 , argv + 1);
        printf("\n");
        return -1;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while(CommandArray[i].Name != NULL) {

        if(strcmp(argv[1], CommandArray[i].Name) == 0) {
            DWORD status;

            status = (CommandArray[i].Function)(&(CommandArray[i]), 
                                                (argc - 2), 
                                                &(argv[2]));

            if(status == -1) {
                PrintHelp(CommandArray[i].Name);
                return -1;
            } else if(status != 0) {
                DWORD length;
                PVOID buffer;

                printf("Error: command %s returned status %d\n", 
                       CommandArray[i].Name, status);

                length = FormatMessage((FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_FROM_SYSTEM |
                                        FORMAT_MESSAGE_IGNORE_INSERTS |
                                        (FORMAT_MESSAGE_MAX_WIDTH_MASK & 0)),
                                       NULL,
                                       status,
                                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                       (LPTSTR) &buffer,
                                       1,
                                       NULL);

                if(length != 0) {
                    printf("%s", buffer);
                }
            }

            break;
        }

        i++;
    }

    if(CommandArray[i].Name == NULL) {
        printf("Unknown command %s\n", argv[2]);
    }

    return 0;
}

VOID
PrintBuffer(
    IN  PUCHAR Buffer,
    IN  SIZE_T Size
    )
{
    DWORD offset = 0;

    while (Size > 0x10) {
        printf( "%08x:"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "\n",
                offset,
                *(Buffer +  0), *(Buffer +  1), *(Buffer +  2), *(Buffer +  3),
                *(Buffer +  4), *(Buffer +  5), *(Buffer +  6), *(Buffer +  7),
                *(Buffer +  8), *(Buffer +  9), *(Buffer + 10), *(Buffer + 11),
                *(Buffer + 12), *(Buffer + 13), *(Buffer + 14), *(Buffer + 15)
                );
        Size -= 0x10;
        offset += 0x10;
        Buffer += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *Buffer);
            spaceIt++;
            Buffer++;
        }
        printf("\n");

    }
    return;
}

DWORD TestCommand(PCOMMAND commandEntry, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;
    DWORD result = ERROR_SUCCESS;

    printf("Test - %d additional arguments\n", argc);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }

    if(argc >= 1) {
        result = atoi(argv[0]);
    }

    printf("returning %d\n", result);

    return result;
}

void PrintHelp(char *Command)
/*++

Routine Description:

    Prints detailed help for a particular command.

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i;

    assert(Command != NULL);

    for(i = 0; CommandArray[i].Name != NULL; i++) {
        COMMAND *entry;

        entry = &(CommandArray[i]);

        if(_stricmp(entry->Name, Command) == 0) {
            if(entry->ExtendedHelp != NULL) {
                printf("%s", entry->ExtendedHelp);
            } else {
                printf("  %s - %s\n", entry->Name, entry->Description);
            }
            return;
        }
    }

    printf("Command %s not recognized\n", Command);

    return;
}

DWORD HelpCommand(PCOMMAND commandEntry, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i = 0;

    if(argc >= 1) {

        PrintHelp(argv[0]);

    } else for(i = 0; CommandArray[i].Name != NULL; i++) {

        COMMAND *entry;

        entry = &(CommandArray[i]);

        if(entry->Description != NULL) {
            printf("  %s - %s\n", entry->Name, entry->Description);
        }
    }

    return ERROR_SUCCESS;
}


DWORD CreateJobCommand(PCOMMAND CommandEntry, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    BOOL sleep = FALSE;
    LPCTSTR jobName;

    HANDLE job;

    //
    // Get the name of the job object from the arguments.
    //

    if(argc == 0) {
        PrintHelp(CommandEntry->Name);
        return -1;
    } else if(argc == 1) {
        jobName = argv[0];
    } else {
        if((argv[0][0] == '-') && (tolower(argv[0][1] == 's'))) {
            sleep = TRUE;
        }
        jobName = argv[1];
    }

    printf("Creating job %s\n", jobName);

    job = CreateJobObject(NULL, jobName);

    if(job == NULL) {
        DWORD status = GetLastError();

        printf("Error %d occurred creating job\n", status);
        return status;
    }

    printf("Job object %s created\n", jobName);

    if(sleep) {

        printf("Sleeping...\n");
        SleepEx(INFINITE, TRUE);
        printf("process alerted - exiting\n");
    }

    //
    // Destroy the job object.
    //

    CloseHandle(job);

    return ERROR_SUCCESS;
}

ULONG PriorityTable[] =  { IDLE_PRIORITY_CLASS,
                           BELOW_NORMAL_PRIORITY_CLASS,
                           NORMAL_PRIORITY_CLASS,
                           ABOVE_NORMAL_PRIORITY_CLASS,
                           HIGH_PRIORITY_CLASS,
                           REALTIME_PRIORITY_CLASS };

DWORD
SetPriorityCommand(
    PCOMMAND CommandEntry,
    int argc, 
    char *argv[]
    )
{
    LPCTSTR jobName;
    int i;
    DWORD status;
    ULONG Priority;
    HANDLE Job;

    JOBOBJECT_BASIC_LIMIT_INFORMATION Limits;

    if(argc < 2) {
        return -1;
    }

    //
    // save the job name and push argc/argv forward.
    // 

    jobName = argv[0];
    argv += 1;
    argc -= 1;

    Priority = atoi( argv[0]);

    if (Priority > 5)  {
        printf("Priority must be 0 - 5\n");
        return ERROR_INVALID_PARAMETER;
    }
    
    //
    // Open a handle to the specified job object.
    //

    Job = OpenJobObject(JOB_OBJECT_SET_ATTRIBUTES , FALSE, jobName);

    if(Job == NULL) {
        return GetLastError();
    }

    //
    //  And set the priority limit.
    //

    memset( &Limits, 0, sizeof( Limits));

    Limits.PriorityClass = PriorityTable[ Priority];
    Limits.LimitFlags = JOB_OBJECT_LIMIT_PRIORITY_CLASS;

    if (!SetInformationJobObject( Job, 
                                  JobObjectBasicLimitInformation,
                                  (PVOID)&Limits,
                                  sizeof( Limits))) {
        return GetLastError();
    }
    
    CloseHandle(Job);
    return 0;
}


DWORD
ExecuteCommand(
    PCOMMAND CommandEntry,
    int argc, 
    char *argv[]
    )
{
    LPCTSTR jobName;

    ULONG commandLineLength = 0;
    LPTSTR commandLine = NULL;
    LPTSTR tmp;

    SECURITY_ATTRIBUTES security;
    HANDLE job;

    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;

    int i;
    DWORD status;

    if(argc < 2) {
        return -1;
    }

    //
    // save the job name and push argc/argv forward.
    // 

    jobName = argv[0];
    argv += 1;
    argc -= 1;

    //
    // Create a command line to hand to CreateProcess.  Start by counting the 
    // number of bytes necessary for the buffer.
    //

    for(i = 0; i < argc; i++) {
        commandLineLength += _tcslen(argv[i]);
        commandLineLength += 1;

        if(_tcschr(argv[i], TEXT(' ')) != NULL) {
            commandLineLength += 2;
        }
    }

    commandLineLength += 1;

    commandLine = LocalAlloc(LPTR, commandLineLength * sizeof(TCHAR));

    if(commandLine == NULL) {
        status = GetLastError();
        return status;
    }

    //
    // Now copy each argument string into the buffer.
    //

    tmp = commandLine;

    for(i = 0; i < argc; i++) {
        ULONG size;
        BOOLEAN containsSpace;

        if(_tcschr(argv[i], TEXT(' ')) != NULL) {
            containsSpace = TRUE;
            *tmp = TEXT('\"');
            tmp += 1;
        } else {
            containsSpace = FALSE;
        }

        size = _tcslen(argv[i]);
        memcpy(tmp, argv[i], size);

        if(containsSpace) {
            tmp[size] = TEXT('\"');
            tmp += 1;
        }

        tmp[size] = TEXT(' ');
        tmp += size + 1;
    }

    printf("Command Arguments are %s\n", commandLine);

    //
    // Open a handle to the specified job object.
    //

    printf("Opening job %s\n", jobName);

    security.nLength = sizeof(SECURITY_ATTRIBUTES);
    security.lpSecurityDescriptor = NULL;
    security.bInheritHandle = TRUE;

    job = CreateJobObject(&security, jobName);

    if(job == NULL) {
        status = GetLastError();
        LocalFree(commandLine);
        return status;
    }

    printf("Creating process '%s'\n", commandLine);

    GetStartupInfo(&startupInfo);

    //
    // Create the process but leave it suspended so we can assign it to the
    // job we created before it starts running.
    //

    if(!CreateProcess(NULL,
                      commandLine,
                      NULL,
                      NULL,
                      TRUE,
                      (CREATE_NEW_CONSOLE | CREATE_SUSPENDED),
                      NULL,
                      NULL,
                      &startupInfo,
                      &processInfo)) {
        status = GetLastError();
        CloseHandle(job);
        LocalFree(commandLine);
        return status;
    }

    //
    // Assign the process to the job.
    //

    printf("Assigning process %d to job %s\n", 
           processInfo.dwProcessId, jobName);

    if(!AssignProcessToJobObject(job, processInfo.hProcess)) {
        status = GetLastError();

        TerminateProcess(processInfo.hProcess, ERROR_SUCCESS);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
        CloseHandle(job);
        LocalFree(commandLine);

        return status;
    }

    //
    // Unsuspend the process.
    //

    if(ResumeThread(processInfo.hThread) == -1) {
        status = GetLastError();

        TerminateProcess(processInfo.hProcess, ERROR_SUCCESS);
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
        CloseHandle(job);
        LocalFree(commandLine);

        return status;
    }

    //
    // Close all our handles.
    //

    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);
    CloseHandle(job);
    LocalFree(commandLine);

    return ERROR_SUCCESS;
}


DWORD
KillJobCommand(
    IN PCOMMAND CommandEntry,
    IN int argc, 
    IN char* argv[]
    )
{
    HANDLE job;
    DWORD status;

    if(argc == 0) {
        return -1;
    }

    job = OpenJobObject(JOB_OBJECT_TERMINATE, FALSE, argv[0]);

    if(job == NULL) {
        return GetLastError();
    }

    TerminateJobObject(job, ERROR_PROCESS_ABORTED);

    status = GetLastError();

    CloseHandle(job);
    return status;
}


DWORD
AssignProcessCommand(
    IN PCOMMAND CommandEntry,
    IN int argc, 
    IN char* argv[]
    )
{
    HANDLE job;

    DWORD processId;
    HANDLE process;

    DWORD status = ERROR_SUCCESS;

    if(argc != 2) {
        return -1;
    }

    processId = _tcstoul(argv[1], NULL, 10);

    printf("process id %s = %d\n", argv[1], processId);

    if(processId == 0) {
        printf("Invalid process id %s\n", argv[1]);
        return -1;
    }

    //
    // Open the job first.
    //

    job = OpenJobObject(JOB_OBJECT_ASSIGN_PROCESS, FALSE, argv[0]);

    if(job == NULL) {
        return GetLastError();
    }

    //
    // Open the process now.
    //

    process = OpenProcess(PROCESS_SET_QUOTA | PROCESS_TERMINATE,
                          FALSE,
                          processId);

    if(process == NULL) {
        status = GetLastError();
        CloseHandle(job);
        return status;
    }

    //
    // Assign the process to the job.
    //

    if(!AssignProcessToJobObject(job, process)) {
        status = GetLastError();
    }

    CloseHandle(job);
    CloseHandle(process);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\job\query.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    job.c

Abstract:

    A user mode app that allows creation and management of jobs.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include "jobmgr.h"

typedef struct {
    char Option;
    JOBOBJECTINFOCLASS InfoClass;
    char *Name;
    DWORD (*Function)(HANDLE Job, JOBOBJECTINFOCLASS InfoClass);
} JOB_QUERY_OPTION, *PJOB_QUERY_OPTION;

#define MKOPTION(optChar, optClass) {optChar, optClass, #optClass, Dump##optClass}

DWORD DumpJobObjectBasicProcessIdList(HANDLE JobHandle, 
                                      JOBOBJECTINFOCLASS InfoClass);
DWORD DumpJobObjectBasicUIRestrictions(HANDLE JobHandle, 
                                      JOBOBJECTINFOCLASS InfoClass);
DWORD 
DumpJobObjectBasicAndIoAccountingInformation(
    HANDLE JobHandle, 
    JOBOBJECTINFOCLASS InfoClass
    );

DWORD 
DumpJobObjectExtendedLimitInformation(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    );

DWORD 
DumpJobObjectSecurityLimitInformation(
    HANDLE JobHandle, 
    JOBOBJECTINFOCLASS InfoClass
    );

JOB_QUERY_OPTION JobInfoClasses[] = {
    MKOPTION('a', JobObjectBasicAndIoAccountingInformation),
    MKOPTION('l', JobObjectExtendedLimitInformation),
    MKOPTION('p', JobObjectBasicProcessIdList),
    MKOPTION('s', JobObjectSecurityLimitInformation),
    MKOPTION('u', JobObjectBasicUIRestrictions),
    {'\0', 0, NULL}
};


DWORD
QueryJobCommand(
    IN PCOMMAND CommandEntry,
    IN int argc, 
    IN char* argv[]
    )
{
    TCHAR defaultOptions[] = {TEXT('p'), TEXT('\0')};
    PTSTR options;
    PTSTR jobName;

    HANDLE job;

    int i;

    BOOLEAN matchAll = FALSE;

    DWORD status;

    if(argc == 0) {
        return -1;
    }

    GetAllProcessInfo();

    if((argc > 1) && (argv[0][0] == '-')) {

        // a - accounting & io
        // l - extended limit info
        // p - process id list
        // u - basic ui restrictions
        // s - security limits

        options = &(argv[0][1]);

        argc -= 1;
        argv += 1;
    } else {
        options = defaultOptions;
    }

    if(_tcschr(options, TEXT('*')) != NULL) {
       if(_tcslen(options) != 1) {
           printf("Cannot specify '*' with other flags\n");
           return -1;
       } else {
           matchAll = TRUE;
           options = defaultOptions;
       }
    }

    jobName = argv[0];

    _tprintf("Opening job object %s\n", jobName);

    job = OpenJobObject(JOB_OBJECT_QUERY, FALSE, jobName);

    if(job == NULL) {
        return GetLastError();
    }

    for(i = 0; JobInfoClasses[i].Option != '\0'; i++) {
        LPTSTR match;

        if(!matchAll) {
            match = _tcschr(options, JobInfoClasses[i].Option);
    
            if(match == NULL) {
                continue;
            }
    
            //
            // Clear the option so we can report the invalid option flags at the 
            // end.
            //
    
            *match = ' ';
        }

        _tprintf("%s [%#x]:\n", JobInfoClasses[i].Name, 
                              JobInfoClasses[i].InfoClass);

        status = JobInfoClasses[i].Function(job, 
                                            JobInfoClasses[i].InfoClass);
        _tprintf("\n");

        if(status != ERROR_SUCCESS) {
            DWORD length;
            PVOID buffer;

            _tprintf("Error %s querying info: ",
                   CommandArray[i].Name, status);

            length = FormatMessage((FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                    FORMAT_MESSAGE_FROM_SYSTEM |
                                    FORMAT_MESSAGE_IGNORE_INSERTS |
                                    (FORMAT_MESSAGE_MAX_WIDTH_MASK & 0)),
                                   NULL,
                                   status,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   (LPTSTR) &buffer,
                                   1,
                                   NULL);

            if(length != 0) {
                _tprintf("%s", buffer);
                LocalFree(buffer);
            }
        }
    }

    if(!matchAll) {
        LPSTR header = "Option flag not understood:";
        while(options[0] != TEXT('\0')) {
            if(options[0] != TEXT(' ')) {
                _tprintf("%s %c", header, options[0]);
                header = "";
            }
            options += 1;
        }
    }

#if 0
    for(;options[0] != '\0'; options += 1) {
        int i;

        for(i = 0; JobInfoClasses[i].Option != '\0'; i++) {

            if((options[0] != TEXT('*')) && 
               (JobInfoClasses[i].Option != tolower(options[0]))) {
                continue;
            }

            _tprintf("%s [%#x]:\n", JobInfoClasses[i].Name, 
                                  JobInfoClasses[i].InfoClass);

            status = JobInfoClasses[i].Function(job, 
                                                JobInfoClasses[i].InfoClass);
            _tprintf("\n");

            if(status != ERROR_SUCCESS) {
                DWORD length;
                PVOID buffer;

                _tprintf("Error %s querying info: ",
                       CommandArray[i].Name, status);

                length = FormatMessage((FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_FROM_SYSTEM |
                                        FORMAT_MESSAGE_IGNORE_INSERTS |
                                        (FORMAT_MESSAGE_MAX_WIDTH_MASK & 0)),
                                       NULL,
                                       status,
                                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                       (LPTSTR) &buffer,
                                       1,
                                       NULL);

                if(length != 0) {
                    _tprintf("%s", buffer);
                    LocalFree(buffer);
                }
            }

            break;
        }

        if(JobInfoClasses[i].Option == '\0') {
            _tprintf("invalid option flag '%c'\n", options[0]);
        }
    }
#endif

    CloseHandle(job);
    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectBasicProcessIdList(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_BASIC_PROCESS_ID_LIST buffer;
    PJOBOBJECT_BASIC_PROCESS_ID_LIST idList = NULL;
    
    ULONG bufferSize;

    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(Job, 
                                       InfoClass, 
                                       &buffer, 
                                       sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST),
                                       NULL);
    status = GetLastError();

    if((!result) && (status != ERROR_MORE_DATA)) {
        return status;
    }

    do {
        
        if(idList != NULL) {
            buffer.NumberOfAssignedProcesses = 
                idList->NumberOfAssignedProcesses;
            LocalFree(idList);
            idList = NULL;
        }

        //
        // Calculate the actual size of the list and allocate a buffer to hold it.
        //
    
        bufferSize = sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST);
        bufferSize -= sizeof(ULONG_PTR);
        bufferSize += sizeof(ULONG_PTR) * buffer.NumberOfAssignedProcesses;
    
        assert(idList == NULL);
        idList = LocalAlloc(LPTR, bufferSize);
    
        if(idList == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        result = QueryInformationJobObject(Job,
                                           InfoClass,
                                           idList,
                                           bufferSize,
                                           NULL);

        status = GetLastError();

        if((!result) && (status != ERROR_MORE_DATA)) {
            LocalFree(idList);
            return status;
        }

    } while(idList->NumberOfAssignedProcesses > 
            idList->NumberOfProcessIdsInList);

    assert(idList->NumberOfAssignedProcesses == 
           idList->NumberOfProcessIdsInList);

    //
    // Dump the information.
    //

    _tprintf("  %d processes assigned to job:\n", 
           idList->NumberOfAssignedProcesses);

    for(i = 0; i < idList->NumberOfAssignedProcesses; i++) {
        _tprintf("%8d", idList->ProcessIdList[i]);
        PrintProcessInfo(idList->ProcessIdList[i]);
        _tprintf("\n");
    }

    LocalFree(idList);
    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectBasicUIRestrictions(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_BASIC_UI_RESTRICTIONS uiLimit;
    
    static FLAG_NAME jobUiLimitFlags[] = {
        FLAG_NAME(JOB_OBJECT_UILIMIT_HANDLES          ), //0x00000001
        FLAG_NAME(JOB_OBJECT_UILIMIT_READCLIPBOARD    ), //0x00000002
        FLAG_NAME(JOB_OBJECT_UILIMIT_WRITECLIPBOARD   ), //0x00000004
        FLAG_NAME(JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS ), //0x00000008
        FLAG_NAME(JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  ), //0x00000010
        FLAG_NAME(JOB_OBJECT_UILIMIT_GLOBALATOMS      ), //0x00000020
        FLAG_NAME(JOB_OBJECT_UILIMIT_DESKTOP          ), //0x00000040
        FLAG_NAME(JOB_OBJECT_UILIMIT_EXITWINDOWS      ), //0x00000080
        {0,0}
    };
    
    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(Job, 
                                       InfoClass, 
                                       &uiLimit, 
                                       sizeof(JOBOBJECT_BASIC_UI_RESTRICTIONS),
                                       NULL);
    status = GetLastError();

    if(!result) {
        return status;
    }

    if(uiLimit.UIRestrictionsClass == JOB_OBJECT_UILIMIT_NONE) {
        _tprintf("  Job has no UI restrictions\n");
        return ERROR_SUCCESS;
    }

    DumpFlags(2, 
              "UI Restrictions", 
              uiLimit.UIRestrictionsClass, 
              jobUiLimitFlags);

    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectBasicAndIoAccountingInformation(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION info;
    
    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(Job, 
                                       InfoClass, 
                                       &info, 
                                       sizeof(info),
                                       NULL);
    status = GetLastError();

    if(!result) {
        return status;
    }

    xprintf(2, "Basic Info\n");
    xprintf(4, "TotalUserTime: %s\n", TicksToString(info.BasicInfo.TotalUserTime));
    xprintf(4, "TotalKernelTime: %s\n", TicksToString(info.BasicInfo.TotalKernelTime));
    xprintf(4, "ThisPeriodTotalUserTime: %s\n", TicksToString(info.BasicInfo.ThisPeriodTotalUserTime));
    xprintf(4, "ThisPeriodTotalKernelTime: %s\n", TicksToString(info.BasicInfo.ThisPeriodTotalKernelTime));
    xprintf(4, "TotalPageFaultCount: %d\n", info.BasicInfo.TotalPageFaultCount);
    xprintf(4, "TotalProcesses: %d\n", info.BasicInfo.TotalProcesses);
    xprintf(4, "ActiveProcesses: %d\n", info.BasicInfo.ActiveProcesses);
    xprintf(4, "TotalTerminatedProcesses: %d\n",  info.BasicInfo.TotalTerminatedProcesses);

    xprintf(2, "I/O Info\n");

    xprintf(4, "ReadOperationCount: %I64d\n", info.IoInfo.ReadOperationCount);
    xprintf(4, "WriteOperationCount: %I64d\n", info.IoInfo.WriteOperationCount);
    xprintf(4, "OtherOperationCount: %I64d\n", info.IoInfo.OtherOperationCount);
    xprintf(4, "ReadTransferCount: %I64d\n", info.IoInfo.ReadTransferCount);
    xprintf(4, "WriteTransferCount: %I64d\n", info.IoInfo.WriteTransferCount);
    xprintf(4, "OtherTransferCount: %I64d\n", info.IoInfo.OtherTransferCount);

    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectExtendedLimitInformation(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION info;
    ULONG limits;
    
    static FLAG_NAME basicJobLimitFlags[] = {
        FLAG_NAME(JOB_OBJECT_LIMIT_WORKINGSET                 ), //0x00000001
        FLAG_NAME(JOB_OBJECT_LIMIT_PROCESS_TIME               ), //0x00000002
        FLAG_NAME(JOB_OBJECT_LIMIT_JOB_TIME                   ), //0x00000004
        FLAG_NAME(JOB_OBJECT_LIMIT_ACTIVE_PROCESS             ), //0x00000008
        FLAG_NAME(JOB_OBJECT_LIMIT_AFFINITY                   ), //0x00000010
        FLAG_NAME(JOB_OBJECT_LIMIT_PRIORITY_CLASS             ), //0x00000020
        FLAG_NAME(JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME          ), //0x00000040
        FLAG_NAME(JOB_OBJECT_LIMIT_SCHEDULING_CLASS           ), //0x00000080
        {0,0}
    };

//
// Extended Limits
//
    static FLAG_NAME extendedJobLimitFlags[] = {
        FLAG_NAME(JOB_OBJECT_LIMIT_PROCESS_MEMORY             ), //0x00000100
        FLAG_NAME(JOB_OBJECT_LIMIT_JOB_MEMORY                 ), //0x00000200
        FLAG_NAME(JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION ), //0x00000400
        FLAG_NAME(JOB_OBJECT_LIMIT_BREAKAWAY_OK               ), //0x00000800
        FLAG_NAME(JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK        ), //0x00001000
        FLAG_NAME(JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE          ), //0x00002000

        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED2                  ), //0x00004000
        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED3                  ), //0x00008000
        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED4                  ), //0x00010000
        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED5                  ), //0x00020000
        FLAG_NAME(JOB_OBJECT_LIMIT_RESERVED6                  ), //0x00040000
        {0,0}
    };

    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(Job, 
                                       InfoClass, 
                                       &info, 
                                       sizeof(info),
                                       NULL);
    status = GetLastError();

    if(!result) {
        return status;
    }

    limits = info.BasicLimitInformation.LimitFlags;

    if(TEST_FLAG(limits, JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS) == 0) {
        xprintf(2, "No basic limits on job\n");
    } else {
        DumpFlags(2, "Basic Limit Flags", limits & JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS, basicJobLimitFlags);
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_PROCESS_TIME)) {
            xprintf(4, "PerProcessUserTimeLimit: %s\n", TicksToString(info.BasicLimitInformation.PerProcessUserTimeLimit));
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_JOB_TIME)) {
            xprintf(4, "PerJobUserTimeLimit: %s\n", TicksToString(info.BasicLimitInformation.PerJobUserTimeLimit));
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_WORKINGSET)) {
            xprintf(4, "MinimumWorkingSetSize: %I64d\n", (ULONGLONG) info.BasicLimitInformation.MinimumWorkingSetSize);
            xprintf(4, "MaximumWorkingSetSize: %I64d\n", (ULONGLONG) info.BasicLimitInformation.MaximumWorkingSetSize);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_ACTIVE_PROCESS)) {
            xprintf(4, "ActiveProcessLimit: %d\n",info.BasicLimitInformation.ActiveProcessLimit);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_AFFINITY)) {
            xprintf(4, "Affinity: %#I64x\n", (ULONGLONG)info.BasicLimitInformation.Affinity);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_PRIORITY_CLASS)) {
            xprintf(4, "PriorityClass: %d\n",info.BasicLimitInformation.PriorityClass);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_SCHEDULING_CLASS)) {
            xprintf(4, "SchedulingClass: %d\n",info.BasicLimitInformation.SchedulingClass);
        }
    }

    if(TEST_FLAG(limits, JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS) == 0) {
        xprintf(2, "No extended limits on job\n");
    } else {

        DumpFlags(2, "Extended Limit Flags", limits & JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS & ~JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS, extendedJobLimitFlags);
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_PROCESS_MEMORY)) {
            xprintf(4, "ProcessMemoryLimit: %I64d\n", (ULONGLONG) info.ProcessMemoryLimit);
        }
    
        if(TEST_FLAG(limits, JOB_OBJECT_LIMIT_PROCESS_MEMORY)) {
            xprintf(4, "JobMemoryLimit: %I64d\n", (ULONGLONG) info.JobMemoryLimit);
        }
    }

    xprintf(2, "PeakProcessMemoryUsed: %I64d\n", (ULONGLONG) info.PeakProcessMemoryUsed);
    xprintf(2, "PeakJobMemoryUsed: %I64d\n", (ULONGLONG) info.PeakJobMemoryUsed);

    return ERROR_SUCCESS;
}

DWORD 
DumpJobObjectSecurityLimitInformation(
    HANDLE Job, 
    JOBOBJECTINFOCLASS InfoClass
    )
{
    JOBOBJECT_SECURITY_LIMIT_INFORMATION buffer;
    PJOBOBJECT_SECURITY_LIMIT_INFORMATION info = NULL;
    
    static FLAG_NAME jobSecurityLimitFlags[] = {
        FLAG_NAME(JOB_OBJECT_SECURITY_NO_ADMIN            ), //00000001
        FLAG_NAME(JOB_OBJECT_SECURITY_RESTRICTED_TOKEN    ), //00000002
        FLAG_NAME(JOB_OBJECT_SECURITY_ONLY_TOKEN          ), //00000004
        FLAG_NAME(JOB_OBJECT_SECURITY_FILTER_TOKENS       ), //00000008
        {0, 0}
    };

    ULONG bufferSize;

    BOOL result;
    DWORD status;

    DWORD i;

    result = QueryInformationJobObject(Job, 
                                       InfoClass, 
                                       &buffer, 
                                       sizeof(buffer),
                                       &bufferSize);
    status = GetLastError();

    if((!result) && (status != ERROR_MORE_DATA)) {
        return status;
    }

    info = LocalAlloc(LPTR, bufferSize);

    if(info == NULL) {
        return GetLastError();
    }

    result = QueryInformationJobObject(Job, InfoClass, info, bufferSize, NULL);

    if(!result) {
        status = GetLastError();
        LocalFree(info);
        return status;
    }

    if(info->SecurityLimitFlags == 0) {
        xprintf(2, "No security limitations on job\n");
    } else {
        DumpFlags(2, "SecurityLimitFlags", info->SecurityLimitFlags, jobSecurityLimitFlags);
    }

    LocalFree(info);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\job\jobmgr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    proc.h

Abstract:

    Definitions for dumping information about processes using the NT API 
    rather than the win32 API.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#ifdef DBG
#define dbg(x) x
#define HELP_ME() printf("Reached line %4d\n", __LINE__);
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__); */
#endif

#define ARGUMENT_USED(x)    (x == NULL)

#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

typedef struct {
    ULONG Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define FLAG_NAME(flag)           {flag, #flag}

typedef struct _COMMAND COMMAND, *PCOMMAND;

struct _COMMAND {
    char *Name;
    char *Description;
    char *ExtendedHelp;
    DWORD (*Function)(PCOMMAND CommandEntry, int argc, char *argv[]);
};

extern COMMAND CommandArray[];

VOID
GetAllProcessInfo(
    VOID
    );

VOID
PrintProcessInfo(
    DWORD_PTR ProcessId
    );

DWORD 
QueryJobCommand(
    PCOMMAND commandEntry, 
    int argc, 
    char *argv[]
    );


VOID
xprintf(
    ULONG  Depth,
    PTSTR Format,
    ...
    );

VOID
DumpFlags(
    ULONG Depth,
    PTSTR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    );

LPCTSTR
TicksToString(
    LARGE_INTEGER TimeInTicks
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\job\utils.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    utils.c

Abstract:

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include "jobmgr.h"

VOID
xprintf(
    ULONG  Depth,
    PTSTR Format,
    ...
    )
{
    va_list args;
    ULONG i;
    TCHAR DebugBuffer[256];

    for (i=0; i<Depth; i++) {
        _tprintf (" ");
    }

    va_start(args, Format);
    _vsntprintf(DebugBuffer, 255, Format, args);
    _tprintf (DebugBuffer);
    va_end(args);
}

VOID
DumpFlags(
    ULONG Depth,
    PTSTR Name,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    xprintf(Depth, "%s (0x%08x)%c\n", Name, Flags, Flags ? TEXT(':') : TEXT(' '));

    if(Flags == 0) {
        return;
    }

    memset(prolog, 0, sizeof(prolog));

    memset(prolog, ' ', min(6, _tcslen(Name)) * sizeof(TCHAR));
    xprintf(Depth, "%s", prolog);

    for(i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if(count != 0) {

                _tprintf(", ");

                //
                // Only print two flags per line.
                //

                if((count % 2) == 0) {
                    _tprintf("\n");
                    xprintf(Depth, "%s", prolog);
                }
            }

            _tprintf("%s", flag->Name);

            count++;
        }
    }

    _tprintf("\n");

    if((Flags & (~mask)) != 0) {
        xprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}

#define MICROSECONDS     ((ULONGLONG) 10)              // 10 nanoseconds
#define MILLISECONDS     (MICROSECONDS * 1000)
#define SECONDS          (MILLISECONDS * 1000)
#define MINUTES          (SECONDS * 60)
#define HOURS            (MINUTES * 60)
#define DAYS             (HOURS * 24)


LPCTSTR
TicksToString(
    LARGE_INTEGER TimeInTicks
    )
{
    static TCHAR ticksToStringBuffer[256] = "";
    LPTSTR buffer = ticksToStringBuffer;

    ULONGLONG t = TimeInTicks.QuadPart;
    ULONGLONG days;
    ULONGLONG hours;
    ULONGLONG minutes;
    ULONGLONG seconds;
    ULONGLONG ticks;
    
    LPTSTR comma = "";

    if(t == 0) {
        return TEXT("0 Seconds");
    }

    days = t / DAYS;
    t %= DAYS;

    hours = t / HOURS;
    t %= HOURS;

    minutes = t / MINUTES;
    t %= MINUTES;

    seconds = t / SECONDS;
    t %= SECONDS;

    ticks = t;

    buffer[0] = TEXT('\0');

    if(days) {
        _stprintf(buffer, "%I64d Days", days);
        comma = ", ";
        buffer += _tcslen(buffer);
    }

    if(hours) {
        _stprintf(buffer, "%s%I64d Hours", comma, hours);
        comma = ", ";
        buffer += _tcslen(buffer);
    }

    if(minutes) {
        _stprintf(buffer, "%s%I64d Minutes", comma, minutes);
        comma = ", ";
        buffer += _tcslen(buffer);
    }

    if(seconds | ticks) {
        _stprintf(buffer, "%s%I64d.%06I64d Seconds", comma, seconds, ticks);
    }

    return ticksToStringBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\job\proc.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    proc.c

Abstract:

    Code for dumping information about processes using the NT API rather than 
    the win32 API.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#define PROCESS_BUFFER_INCREMENT (16 * 4096)

PSYSTEM_PROCESS_INFORMATION ProcessInfo = NULL;
DWORD ProcessInfoLength;


VOID
GetAllProcessInfo(
    VOID
    )
{
    PSYSTEM_PROCESS_INFORMATION buffer;
    DWORD bufferSize = 1 * PROCESS_BUFFER_INCREMENT;

    NTSTATUS status;

    assert(ProcessInfo == NULL);

    do {
        buffer = LocalAlloc(LMEM_FIXED, bufferSize);

        if(buffer == NULL) {
            return;
        }

        status = NtQuerySystemInformation(SystemProcessInformation,
                                          buffer,
                                          bufferSize,
                                          &ProcessInfoLength);

        if(status == STATUS_INFO_LENGTH_MISMATCH) {

            LocalFree(buffer);
            bufferSize += PROCESS_BUFFER_INCREMENT;
            continue;
        }

    } while(status == STATUS_INFO_LENGTH_MISMATCH);

    if(NT_SUCCESS(status)) {
        ProcessInfo = buffer;
    }
    return;
}


VOID
PrintProcessInfo(
    DWORD_PTR ProcessId
    )
{
    PSYSTEM_PROCESS_INFORMATION info;

    if(ProcessInfo == NULL) {
        return;
    }

    info = ProcessInfo;

    do {

        if(ProcessId == (DWORD_PTR) info->UniqueProcessId) {

            printf(": %.*S", 
                   (info->ImageName.Length / 2), 
                   info->ImageName.Buffer);

            break;
        }

        info = (PSYSTEM_PROCESS_INFORMATION) (((ULONG_PTR) info) + 
                                              info->NextEntryOffset);
    } while((ULONG_PTR) info <= (ULONG_PTR) ProcessInfo + ProcessInfoLength);

    return;
}

#if 0

DWORD
QueryDirectory(
    IN PSTRING DirectoryName
    )
{
    NTSTATUS Status;
    HANDLE DirectoryHandle, LinkHandle;
    ULONG Context = 0;
    ULONG i, ReturnedLength;
    UNICODE_STRING LinkTarget;

    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING UnicodeString;

    //
    //  Perform initial setup
    //

    RtlZeroMemory( Buffer, BUFFERSIZE );

    //
    //  Open the directory for list directory access
    //

    Status = RtlAnsiStringToUnicodeString( 
                &UnicodeString,
                DirectoryName,
                TRUE
                );

    ASSERT(NT_SUCCESS(Status));

    InitializeObjectAttributes(&Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenDirectoryObject(&DirectoryHandle,
                                   DIRECTORY_QUERY,
                                   &Attributes);

    if(!NT_SUCCESS(Status)) {
        if (Status == STATUS_OBJECT_TYPE_MISMATCH) {
            printf("%Z is not a valid Object Directory Object name\n",
                    DirectoryName );
        } else {
            printf("Error %#08lx opening %Z\n", Status, DirectoryName);
        }

        return;
    }

    //
    //  Query the entire directory in one sweep
    //

    NumberOfDirEntries = 0;
    for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                          &Buffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength );
         NT_SUCCESS( Status );
         Status = NtQueryDirectoryObject( DirectoryHandle,
                                          &Buffer,
                                          BUFFERSIZE,
                                          FALSE,
                                          FALSE,
                                          &Context,
                                          &ReturnedLength ) ) {

        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status != STATUS_NO_MORE_FILES) {
                Error( Status, Status );
            }
            break;
        }

        //
        //  For every record in the buffer type out the directory information
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

        while (TRUE) {

            //
            //  Check if there is another record.  If there isn't, then get out
            //  of the loop now
            //

            if (DirInfo->Name.Length == 0) {
                break;
            }

            //
            //  Print out information about the file
            //

            if (NumberOfDirEntries >= MAX_DIR_ENTRIES) {
                printf( "OBJDIR: Too many directory entries.\n" );
                exit( 1 );
                }

            DirEntries[ NumberOfDirEntries ].Name = RtlAllocateHeap( RtlProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     DirInfo->Name.Length +
                                                                         sizeof( UNICODE_NULL )
                                                                   );
            DirEntries[ NumberOfDirEntries ].Type = RtlAllocateHeap( RtlProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     DirInfo->TypeName.Length +
                                                                         sizeof( UNICODE_NULL )
                                                                   );
            memmove( DirEntries[ NumberOfDirEntries ].Name,
                     DirInfo->Name.Buffer,
                     DirInfo->Name.Length
                   );
            memmove( DirEntries[ NumberOfDirEntries ].Type,
                     DirInfo->TypeName.Buffer,
                     DirInfo->TypeName.Length
                   );

            NumberOfDirEntries++;

            //
            //  There is another record so advance DirInfo to the next entry
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                          sizeof( OBJECT_DIRECTORY_INFORMATION ) );

        }

        RtlZeroMemory( Buffer, BUFFERSIZE );

    }


    qsort( DirEntries,
           NumberOfDirEntries,
           sizeof( DIR_ENTRY ),
           CompareDirEntry
         );
    for (i=0; i<NumberOfDirEntries; i++) {
        printf( "%-32ws ", DirEntries[ i ].Name);
        if (CompoundLineOutput) {
            printf("\n    ");
        }
        printf( "%ws", DirEntries[ i ].Type );

        if (!wcscmp( DirEntries[ i ].Type, L"SymbolicLink" )) {
            RtlInitUnicodeString( &UnicodeString, DirEntries[ i ].Name );
            InitializeObjectAttributes( &Attributes,
                                        &UnicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        DirectoryHandle,
                                        NULL );
            Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                               SYMBOLIC_LINK_QUERY,
                                               &Attributes
                                             );
            if (NT_SUCCESS( Status )) {
                LinkTarget.Buffer = LinkTargetBuffer;
                LinkTarget.Length = 0;
                LinkTarget.MaximumLength = sizeof( LinkTargetBuffer );
                Status = NtQuerySymbolicLinkObject( LinkHandle,
                                                    &LinkTarget,
                                                    NULL
                                                  );
                NtClose( LinkHandle );
                }

            if (!NT_SUCCESS( Status )) {
                printf( " - unable to query link target (Status == %09X)\n", Status );
                }
            else {
                printf( " - %wZ\n", &LinkTarget );
                }
            }
        else {
            printf( "\n" );
            }
        }

    //
    // Output final messages
    //

    if (NumberOfDirEntries == 0) {
        printf( "no entries\n" );
        }
    else
    if (NumberOfDirEntries == 1) {
        printf( "\n1 entry\n" );
        }
    else {
        printf( "\n%ld entries\n", NumberOfDirEntries );
        }

    //
    //  Now close the directory object
    //

    (VOID) NtClose( DirectoryHandle );

    //
    //  And return to our caller
    //

    return;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kbdtool\kbdtxt2c.c ===
/******************************* Module Header *******************************\
* Module Name: KBDTXT2C.C
*
* Copyright (c) 1985-2001, Microsoft Corporation
*
* History:
* 1995-03-26  a-KChang
* 1997-06-13  GregoryW  v2.00  BiDi Support
* 1997-06-19  IanJa     v2.01  Add ATTRIBUTES section
* 1998-03-04  IanJa     v3.0   Add dead key composition can be dead char too
*                              (Useful for CAN/CSA, Serge Caron @ Attachmate
*                               and a customer of Eliyas Yakub's)
* 1998-05-01  HiroYama  v3.01  -k switch to make fallback layout for win32k.sys
* 1998-05-08  IanJa     v3.02  new E1 scancodes allowed
* 1998-05-19  v-thief   v3.03  Add IA64 support. Implies that the data arrays
*                              are located in the long data section.
*                              Uses IA64 compiler specific pragmas.
*                              data_seg() is not explicit enough.
* 1998-05-20  v-thief   v3.04  For the fallback layout in win32k.sys, we are
*                              not relocating the data in long data section.
* 1998-10-29  WKwok     v3.05  Specify VER_LANGNEUTRAL in RC.
* 1998-12-03  IanJa     v3.06  Add SpeedRacer VKs, include strid.h
* 1999-01-12  IanJa     v3.07  check for dup VKs, beautify, improve VkKeyScan
* 1999-01-28  v-thief   v3.08  fixed IA64 warnings for .data section. The new
*                              IA64 compiler defaults to a "long" attribute
*                              for this known section.
* 1999-02-11  IanJa     v3.09  check for dup chars (for VkKeyScanEx's sake)
* 1999-03-25  IanJa     v3.10  no more vkoem.h (get VKs from winuser.h)
* 1999-03-31  IanJa     v3.11  comment out spurious DumpLayoutEntry() call
* 2001-06-28  Hiroyama  v3.12  fix the upper case warnings etc..
                               putting the sanity check in "-W".
\*****************************************************************************/

#include <windows.h>
#include <winuserp.h>
#include "kbdx.h"

DWORD gVersion = 3;
DWORD gSubVersion = 12;

char *KeyWord[] = { /* used by isKeyWord() */
  "KBD",            /*  0 */
  "VERSION",        /*  1 */
  "MODIFIERS",      /*  2 */
  "SHIFTSTATE",     /*  3 */
  "ATTRIBUTES",     /*  4 */
  "LAYOUT",         /*  5 */
  "DEADKEY",        /*  6 */
  "LIGATURE",       /*  7 */
  "KEYNAME",        /*  8 */
  "KEYNAME_EXT",    /*  9 */
  "KEYNAME_DEAD",   /* 10 */
  "ENDKBD",         /* 11 */
};
#define KEYWORD_KBD          0
#define KEYWORD_VERSION      1
#define KEYWORD_MODIFIERS    2
#define KEYWORD_SHIFTSTATE   3
#define KEYWORD_ATTRIBUTES   4
#define KEYWORD_LAYOUT       5
#define KEYWORD_DEADKEY      6
#define KEYWORD_LIGATURE     7
#define KEYWORD_KEYNAME      8
#define KEYWORD_KEYNAME_EXT  9
#define KEYWORD_KEYNAME_DEAD 10
#define KEYWORD_ENDKBD       11


#define NUMKEYWORD ( sizeof(KeyWord) / sizeof(char*) )

#define NOT_KEYWORD 999 /* a number bigger than NUMKEYWORD */

#define DEADKEYCODE 6   /* only DEADKEY can have multiple entries */

VKEYNAME VKName[] = {   /* used only by virtual keys other than 0-9 and A-Z */
    {VK_BACK,       "BACK"       },
    {VK_CANCEL,     "CANCEL"     },
    {VK_ESCAPE,     "ESCAPE"     },
    {VK_RETURN,     "RETURN"     },
    {VK_SPACE,      "SPACE"      },
    {VK_DECIMAL,    "DECIMAL"    },
    {VK_OEM_1,      "OEM_1"      },
    {VK_OEM_PLUS,   "OEM_PLUS"   },
    {VK_OEM_COMMA,  "OEM_COMMA"  },
    {VK_OEM_MINUS,  "OEM_MINUS"  },
    {VK_OEM_PERIOD, "OEM_PERIOD" },
    {VK_OEM_2,      "OEM_2"      },
    {VK_OEM_3,      "OEM_3"      },
    {VK_OEM_4,      "OEM_4"      },
    {VK_OEM_5,      "OEM_5"      },
    {VK_OEM_6,      "OEM_6"      },
    {VK_OEM_7,      "OEM_7"      },
    {VK_OEM_8,      "OEM_8"      },
    {VK_OEM_102,    "OEM_102"    },
    {0xC1,          "ABNT_C1"    },
    {0xC2,          "ABNT_C2"    },
    {VK_SHIFT,      "SHIFT"      },
    {VK_LSHIFT,     "LSHIFT"     },
    {VK_RSHIFT,     "RSHIFT"     },
    {VK_MENU,       "MENU"       },
    {VK_LMENU,      "LMENU"      },
    {VK_RMENU,      "RMENU"      },
    {VK_CONTROL,    "CONTROL"    },
    {VK_LCONTROL,   "LCONTROL"   },
    {VK_RCONTROL,   "RCONTROL"   },
    {VK_SEPARATOR,  "SEPARATOR"  },
    {VK_ICO_00,     "ICO_00"     },
    {VK_DELETE,     "DELETE"     },
    {VK_INSERT,     "INSERT"     },
    {VK_GROUPSHIFT, "GROUPSHIFT" },
    {VK_RGROUPSHIFT,"RGROUPSHIFT"},
};

#define NUMVKNAME ( sizeof(VKName) / sizeof(VKEYNAME) )

/*
 * Default ScanCode-VirtualKey relation
 *
 * Includes a comment string used only for E0 prefixed scancodes and
 * then only as a comment for aE0VscToVk[] entries in the output .C file
 *
 * This does not have to be ordered by scancode or virtual key code.
 * The order *does* affect VkKeyScan[Ex] - each aVkToWch*[] table is
 * ordered according to the order of the entries in this table.
 *
 *
 * Scan  VKey       comment
 * ====  =========  =======
 */
SC_VK ScVk[] = {
  {0x02, 0x31,      NULL},   /* 1          */
  {0x03, 0x32,      NULL},   /* 2          */
  {0x04, 0x33,      NULL},   /* 3          */
  {0x05, 0x34,      NULL},   /* 4          */
  {0x06, 0x35,      NULL},   /* 5          */
  {0x07, 0x36,      NULL},   /* 6          */
  {0x08, 0x37,      NULL},   /* 7          */
  {0x09, 0x38,      NULL},   /* 8          */
  {0x0a, 0x39,      NULL},   /* 9          */
  {0x0b, 0x30,      NULL},   /* 0          */
  {0x0c, 0xbd,      NULL},   /* OEM_MINUS  */
  {0x0d, 0xbb,      NULL},   /* OEM_PLUS   */
  {0x10, 0x51,      NULL},   /* Q          */
  {0x11, 0x57,      NULL},   /* W          */
  {0x12, 0x45,      NULL},   /* E          */
  {0x13, 0x52,      NULL},   /* R          */
  {0x14, 0x54,      NULL},   /* T          */
  {0x15, 0x59,      NULL},   /* Y          */
  {0x16, 0x55,      NULL},   /* U          */
  {0x17, 0x49,      NULL},   /* I          */
  {0x18, 0x4f,      NULL},   /* O          */
  {0x19, 0x50,      NULL},   /* P          */
  {0x1a, 0xdb,      NULL},   /* OEM_4      */
  {0x1b, 0xdd,      NULL},   /* OEM_6      */
  {0x1e, 0x41,      NULL},   /* A          */
  {0x1f, 0x53,      NULL},   /* S          */
  {0x20, 0x44,      NULL},   /* D          */
  {0x21, 0x46,      NULL},   /* F          */
  {0x22, 0x47,      NULL},   /* G          */
  {0x23, 0x48,      NULL},   /* H          */
  {0x24, 0x4a,      NULL},   /* J          */
  {0x25, 0x4b,      NULL},   /* K          */
  {0x26, 0x4c,      NULL},   /* L          */
  {0x27, 0xba,      NULL},   /* OEM_1      */
  {0x28, 0xde,      NULL},   /* OEM_7      */
  {0x29, 0xc0,      NULL},   /* OEM_3      */
  {0x2b, 0xdc,      NULL},   /* OEM_5      */
  {0x2c, 0x5a,      NULL},   /* Z          */
  {0x2d, 0x58,      NULL},   /* X          */
  {0x2e, 0x43,      NULL},   /* C          */
  {0x2f, 0x56,      NULL},   /* V          */
  {0x30, 0x42,      NULL},   /* B          */
  {0x31, 0x4e,      NULL},   /* N          */
  {0x32, 0x4d,      NULL},   /* M          */
  {0x33, 0xbc,      NULL},   /* OEM_COMMA  */
  {0x34, 0xbe,      NULL},   /* OEM_PERIOD */
  {0x35, 0xbf,      NULL},   /* OEM_2      */
  {0x56, 0xe2,      NULL},   /* OEM_102    */
  {0x73, 0xc1,      NULL},   /* ABNT_C1    */
  {0x7e, 0xc2,      NULL},   /* ABNT_C2    */


  // extended scancodes
  // The comment is only as a comment for aE0VscToVk[] entries
  // in the output .C file
  {0xE010, VK_MEDIA_PREV_TRACK, "Speedracer: Previous Track"   },
  {0xE019, VK_MEDIA_NEXT_TRACK, "Speedracer: Next Track"       },
  {0xE01D, VK_RCONTROL        , "RControl"                     },
  {0xE020, VK_VOLUME_MUTE     , "Speedracer: Volume Mute"      },
  {0xE021, VK_LAUNCH_APP2     , "Speedracer: Launch App 2"     },
  {0xE022, VK_MEDIA_PLAY_PAUSE, "Speedracer: Media Play/Pause" },
  {0xE024, VK_MEDIA_STOP      , "Speedracer: Media Stop"       },
  {0xE02E, VK_VOLUME_DOWN     , "Speedracer: Volume Down"      },
  {0xE030, VK_VOLUME_UP       , "Speedracer: Volume Up"        },
  {0xE032, VK_BROWSER_HOME    , "Speedracer: Browser Home"     },
  {0xE035, VK_DIVIDE          , "Numpad Divide"        },
  {0xE037, VK_SNAPSHOT        , "Snapshot"             },
  {0xE038, VK_RMENU           , "RMenu"                },
  {0xE047, VK_HOME            , "Home"                 },
  {0xE048, VK_UP              , "Up"                   },
  {0xE049, VK_PRIOR           , "Prior"                },
  {0xE04B, VK_LEFT            , "Left"                 },
  {0xE04D, VK_RIGHT           , "Right"                },
  {0xE04F, VK_END             , "End"                  },
  {0xE050, VK_DOWN            , "Down"                 },
  {0xE051, VK_NEXT            , "Next"                 },
  {0xE052, VK_INSERT          , "Insert"               },
  {0xE053, VK_DELETE          , "Delete"               },
  {0xE05B, VK_LWIN            , "Left Win"             },
  {0xE05C, VK_RWIN            , "Right Win"            },
  {0xE05D, VK_APPS            , "Application"          },

  // reserved (VKey == 0xff)
  {0xE05E,   0xff             , "Power"                },
  {0xE05F, VK_SLEEP           , "Speedracer: Sleep"    },
  {0xE060,   0xff             , "BAD SCANCODE"         }, // break would be 0xE0
  {0xE061,   0xff             , "BAD SCANCODE"         }, // break would be 0xE1

  // available for adding extended scancodes (VKey == 0x00)
  {0xE065, VK_BROWSER_SEARCH     , "Speedracer: Browser Search"       },
  {0xE066, VK_BROWSER_FAVORITES  , "Speedracer: Browser Favorites"    },
  {0xE067, VK_BROWSER_REFRESH    , "Speedracer: Browser Refresh"      },
  {0xE068, VK_BROWSER_STOP       , "Speedracer: Browser Stop"         },
  {0xE069, VK_BROWSER_FORWARD    , "Speedracer: Browser Forward"      },
  {0xE06A, VK_BROWSER_BACK       , "Speedracer: Browser Back"         },
  {0xE06B, VK_LAUNCH_APP1        , "Speedracer: Launch App 1"         },
  {0xE06C, VK_LAUNCH_MAIL        , "Speedracer: Launch Mail"          },
  {0xE06D, VK_LAUNCH_MEDIA_SELECT, "Speedracer: Launch Media Selector"},

  // These come near the end for VkKeyScan...
  {0x53,   VK_DECIMAL, NULL                  },  /* Numpad Decimal */
  {0x0e,   VK_BACK,    NULL                  },  /* Backspace      */
  {0x01,   VK_ESCAPE,  NULL                  },  /* Escape         */
  {0xE01C, VK_RETURN,  "Numpad Enter"        },
  {0x1c,   VK_RETURN,  NULL                  },  /* Enter          */
  {0x39,   VK_SPACE,   NULL                  },  /* Space          */
  {0xE046, VK_CANCEL, "Break (Ctrl + Pause)" },

  // ...but the 0xffff entries (for new scancodes) must come last
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },
  {0xffff,   0x00, NULL },

};

#define NUMSCVK ( sizeof(ScVk) / sizeof(SC_VK) )

typedef struct {
    UINT Vk;
    char *pszModBits;
} MODIFIERS, *PMODIFIERS;

MODIFIERS Modifiers[] = {
    { VK_SHIFT,    "KBDSHIFT"   },
    { VK_CONTROL,  "KBDCTRL"    },
    { VK_MENU,     "KBDALT"     },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         },
    { 0,           NULL         }
};

char* StateLabel[] = {
  "",                 /* 0          */
  "Shift",            /* 1          */
  "  Ctrl",           /* 2          */
  "S+Ctrl",           /* 3          */
  "      Alt",        /* 4:not used */
  "Shift+Alt",        /* 5:not used */
  "  Ctl+Alt",        /* 6          */
  "S+Ctl+Alt",        /* 7          */
  "      X1   ",      /* 8          */
  "S+    X1   ",      /* 9           */
  "  C+  X1   ",      /* 10          */
  "S+C+  X1   ",      /* 11          */
  "    A+X1   ",      /* 12          */
  "S+  A+X1   ",      /* 13          */
  "  C+A+X1   ",      /* 14          */
  "S+C+A+X1   ",      /* 15          */
  "         X2",      /* 16          */
  "S+       X2",      /* 17          */
  "  C+     X2",      /* 18          */
  "S+C+     X2",      /* 19          */
  "    A+   X2",      /* 20          */
  "S+  A+   X2",      /* 21          */
  "  C+A+   X2",      /* 22          */
  "S+C+A+   X2",      /* 23          */
  "      X1+X2",      /* 24          */
  "S+    X1+X2",      /* 25          */
  "  C+  X1+X2",      /* 26          */
  "S+C+  X1+X2",      /* 27          */
  "    A+X1+X2",      /* 28          */
  "S+  A+X1+X2",      /* 29          */
  "  C+A+X1+X2",      /* 30          */
  "S+C+A+X1+X2",      /* 31          */
  "            X3",   /* 32          */
  "S+          X3",   /* 33          */
  "  C+        X3",   /* 34          */
  "S+C+        X3",   /* 35          */
  "    A+      X3",   /* 36          */
  "S+  A+      X3",   /* 37          */
  "  C+A+      X3",   /* 38          */
  "S+C+A+      X3",   /* 39          */
  "      X1+   X3",   /* 40          */
  "S+    X1+   X3",   /* 41          */
  "  C+  X1+   X3",   /* 42          */
  "S+C+  X1+   X3",   /* 43          */
  "    A+X1+   X3",   /* 44          */
  "S+  A+X1+   X3",   /* 45          */
  "  C+A+X1+   X3",   /* 46          */
  "S+C+A+X1+   X3",   /* 47          */
  "         X2+X3",   /* 48          */
  "S+       X2+X3",   /* 49          */
  "  C+     X2+X3",   /* 50          */
  "S+C+     X2+X3",   /* 51          */
  "    A+   X2+X3",   /* 52          */
  "S+  A+   X2+X3",   /* 53          */
  "  C+A+   X2+X3",   /* 54          */
  "S+C+A+   X2+X3",   /* 55          */
  "      X1+X2+X3",   /* 56          */
  "S+    X1+X2+X3",   /* 57          */
  "  C+  X1+X2+X3",   /* 58          */
  "S+C+  X1+X2+X3",   /* 59          */
  "    A+X1+X2+X3",   /* 60          */
  "S+  A+X1+X2+X3",   /* 61          */
  "  C+A+X1+X2+X3",   /* 62          */
  "S+C+A+X1+X2+X3",   /* 63          */
  "unexpected",       /* 64          */
  "unexpected",       /* 65          */
};

/*************************************************************\
* forward declarations                                       *
\*************************************************************/
BOOL  NextLine(char *Buf, DWORD cchBuf, FILE *fIn);
int   SkipLines(void);
int   isKeyWord(char *s);
int   getVKNum(char *pVK);
char *getVKName(int VK, BOOL prefixVK_);
int   doKBD();
int   doMODIFIERS();
int   doSHIFTSTATE(int *nState, int aiState[]);
int   doATTRIBUTES(char *szAttrs);
int   doLAYOUT(KEYLAYOUT Layout[], int aiState[], int nState);
int   doDEADKEY(PDEADKEY *ppDeadKey);
int   doLIGATURE(PLIGATURE *ppLigature);
int   doKEYNAME(PKEYNAME *ppKeyName);
int   kbd_h(KEYLAYOUT Layout[]);
int   kbd_rc(void);
int   kbd_def(void);
char *WChName(int WC, int Zero);
VOID __cdecl Error(const char *Text, ... );
ULONG __cdecl Warning(int nLine, const char *Text, ... );
VOID  DumpLayoutEntry(PKEYLAYOUT pLayout);
BOOL  MergeState(KEYLAYOUT[], int Vk, WCHAR, WCHAR, WCHAR, int aiState[], int nState);

int   kbd_c(int        nState,
            int        aiState[],
            char *     szAttrs,
            KEYLAYOUT  Layout[],
            PDEADKEY  pDeadKey,
            PLIGATURE pLigature,
            PKEYNAME  pKeyName,
            PKEYNAME  pKeyNameExt,
            PKEYNAME  pKeyNameDead);
void PrintNameTable(FILE *pOut, PKEYNAME pKN, BOOL bDead);

/*************************************************************\
* Global variables
\*************************************************************/
BOOL  verbose = FALSE;
BOOL  fallback_driver = FALSE;
BOOL  sanity_check = FALSE;
FILE *gfpInput;
char  gBuf[LINEBUFSIZE];
int   gLineCount;
LPSTR  gpszFileName;
char  gVKeyName[WORDBUFSIZE];
char  gKBDName[MAXKBDNAME];
char  gDescription[LINEBUFSIZE];
int gID = 0;
char  gCharName[WORDBUFSIZE];

struct tm *Now;
time_t Clock;


void usage()
{
    fprintf(stderr, "Usage: KbdTool [-v] [-k] file\n");
    fprintf(stderr, "\t[-?] display this message\n");
    fprintf(stderr, "\t[-v] verbose diagnostics/warnings\n");
    fprintf(stderr, "\t[-k] builds kbd layout for embedding in the kernel\n");
    fprintf(stderr, "\t[-W] performs sanity check\n");
    exit(EXIT_FAILURE);
}

/*************************************************************\
*  Main
\*************************************************************/
int _cdecl main(int argc, char** argv)
{
    int   c;
    int   i;
    int   nKW[NUMKEYWORD];    /* keep track of KeyWord read to prevent duplicates */
    int   iKW;
    int   nState;             /* number of states */
    int   aiState[MAXSTATES];
    char  szAttrs[128] = "\0";
    int   nTotal = 0;
    int   nFailH = 0;
    int   nFailC = 0;
    int   nFailRC = 0;
    int   nFailDEF = 0;

    KEYLAYOUT  Layout[NUMSCVK];
    PDEADKEY  pDeadKey = NULL;
    PLIGATURE pLigature = NULL;
    PKEYNAME  pKeyName = NULL;
    PKEYNAME  pKeyNameExt = NULL;
    PKEYNAME  pKeyNameDead = NULL;

    printf("\nKbdTool v%d.%02d - convert keyboard text file to C file\n\n",
           gVersion, gSubVersion);

    while ((c = getopt(argc, argv, "vkW?")) != EOF) {
        switch (c) {
        case 'v':
            verbose = TRUE;
            break;
        case 'k': // means 'kernel'
            fallback_driver = TRUE;
            break;
        case 'W':   // Turn on warning
            sanity_check = TRUE;
            break;
        case '?':
        default:
            usage();
            // never reaches here
        }
    }

    if (optind == argc) {
        usage();
        // never reaches here
    }
    argv = argv + optind;

    while (*argv) {
        nTotal++;
        gpszFileName = *argv;
        if ((gfpInput = fopen(*argv, "rt")) == NULL) {
            Error("can't open for read\n");
            nFailH++;
            nFailC++;
            nFailRC++;
            nFailDEF++;
            argv++;
            continue;
        }
        printf("%-23s:\n", *argv);

        /* initialize for each input file */
        for (i = 0; i < NUMKEYWORD; i++) {
            nKW[i]=0;
        }
        gLineCount = 0;
        /**********************************/

        if ((iKW = SkipLines()) >= NUMKEYWORD) {
            fclose(gfpInput);
            Error("no keyword found\n");
            nFailH++;
            nFailC++;
            nFailRC++;
            nFailDEF++;
            continue;
        }

        while (iKW < NUMKEYWORD - 1) {
            nKW[iKW]++;
            if (iKW != DEADKEYCODE && nKW[iKW] > 1 && verbose) {
                Warning(0, "duplicate %s", KeyWord[iKW]);
            }

            switch (iKW) {
            case KEYWORD_KBD:

                iKW = doKBD();
                break;

            case KEYWORD_VERSION: // ignored for now

                iKW = SkipLines();
                break;

            case KEYWORD_MODIFIERS:

                iKW = doMODIFIERS();
                break;

            case KEYWORD_SHIFTSTATE:

                iKW = doSHIFTSTATE(&nState, aiState);
                if (nState < 2) {
                    fclose(gfpInput);
                    Error("must have at least 2 states\n");
                    nFailH++;
                    nFailC++;
                    continue;
                }
                break;

            case KEYWORD_ATTRIBUTES:
                iKW = doATTRIBUTES(szAttrs);
                break;

            case KEYWORD_LAYOUT:

                if ((iKW = doLAYOUT(Layout, aiState, nState)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                /* add layout checking later */

                break;

            case KEYWORD_DEADKEY:

                if ((iKW = doDEADKEY(&pDeadKey)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            case KEYWORD_LIGATURE:

                if ((iKW = doLIGATURE(&pLigature)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            case KEYWORD_KEYNAME:

                if ((iKW = doKEYNAME(&pKeyName)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            case KEYWORD_KEYNAME_EXT:

                if ((iKW = doKEYNAME(&pKeyNameExt)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            case KEYWORD_KEYNAME_DEAD:

                if ((iKW = doKEYNAME(&pKeyNameDead)) == -1) {
                    fclose(gfpInput);
                    return EXIT_FAILURE;
                }

                break;

            default:

                break;
            }
        }

        fclose(gfpInput);

        /* add later : checking for LAYOUT & DEADKEY */

        time(&Clock);
        Now = localtime(&Clock);

        if (!fallback_driver && kbd_h(Layout) == FAILURE) {
            nFailH++;
        }

        if (!fallback_driver && kbd_rc() != SUCCESS) {
            nFailRC++;
        }

        if (kbd_c(nState, aiState, szAttrs, Layout,
                  pDeadKey, pLigature, pKeyName, pKeyNameExt, pKeyNameDead) == FAILURE) {
            nFailC++;
        }

        if (!fallback_driver && kbd_def() != SUCCESS) {
            nFailDEF++;
        }

        printf("\n");

        argv++;
    }

    printf("\n     %13d     ->% 12d %12d %12d %12d\n",
           nTotal, nTotal - nFailH, nTotal - nFailRC,
           nTotal - nFailC, nTotal - nFailDEF);

  return EXIT_SUCCESS;
}

/*************************************************************\
* Check keyword
*  Return: 0 - 8 for valid keyword
*          9     for invalid keyword
\*************************************************************/
int isKeyWord(char *s)
{
  int i;

  for(i = 0; i < NUMKEYWORD; i++)
  {
    if(_strcmpi(KeyWord[i], s) == 0)
    {
      return i;
    }
  }

  return NOT_KEYWORD;
}

/*************************************************************\
* Skip lines till a valid keyword is available
*  Return: 0 - 8 for valid keyword
*          9     for invalid keyword
\*************************************************************/
int SkipLines()
{
  int   iKW;
  char  KW[WORDBUFSIZE];

  while (NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
    if(sscanf(gBuf, "%s", KW) == 1)
    {
      if((iKW = isKeyWord(KW)) < NUMKEYWORD)
      {
        return iKW;
      }
    }
  }

  return NUMKEYWORD;
}

/*************************************************************\
* Convert Virtual Key name to integer
*  Return : -1 if fail
\*************************************************************/
int getVKNum(char *pVK)
{
  int i, len;

  len = strlen(pVK);

  if (len < 1) {
      return -1;
  }

  if (len == 1) {
      if (*pVK >= '0' && *pVK <= '9') {
          return *pVK;
      }

      *pVK = (char)toupper(*pVK);
      if (*pVK >= 'A' && *pVK <='Z') {
          return *pVK;
      }
  } else {
      for (i = 0; i < NUMVKNAME; i++) {
          if(_strcmpi(VKName[i].pName, pVK) == 0) {
            return VKName[i].VKey;
          }
      }

      /*
       * Hey! It's unknown!  Perhaps it is a new one, in which
       * case it must be of the form 0xNN
       */
      if (pVK[0] == '0' &&
              (pVK[1] == 'x' || pVK[1] == 'X')) {
          pVK[1] = 'x';
          if (sscanf(pVK, "0x%x", &i) == 1) {
              return i;
          }
      }
  }

  return -1;
}

/*************************************************************\
* Convert VK integer to name and store it in gVKeyName
\*************************************************************/
char *getVKName(int VK, BOOL prefixVK_)
{
  int   i;
  char *s;

  s = gVKeyName;

  if((VK >= 'A' && VK <= 'Z') || (VK >= '0' && VK <= '9'))
  {
    *s++ = '\'';
    *s++ = (char)VK;
    *s++ = '\'';
    *s   = '\0';
    return gVKeyName;
  }

  if(prefixVK_)
  {
    strcpy(gVKeyName, "VK_");
  }
  else
  {
    strcpy(gVKeyName, "");
  }

  for(i = 0; i < NUMVKNAME; i++)
  {
    if(VKName[i].VKey == VK)
    {
      strcat(s, VKName[i].pName);
      return gVKeyName;
    }
  }

  strcpy(gVKeyName, "#ERROR#");
  return gVKeyName;
}

/*************************************************************\
* KBD section
*  read in gKBDName and gDescription if any
*  Return : next keyword
\*************************************************************/
int doKBD()
{
  char *p;

  *gKBDName = '\0';
  *gDescription = '\0';

  if (sscanf(gBuf, "KBD %5s \"%40[^\"]\" %d", gKBDName, gDescription, &gID) < 2)
  {
//     if (sscanf(gBuf, "KBD %5s ;%40[^\n]", gKBDName, gDescription) < 2)
//     {
        Error("unrecognized keyword");
//     }
  }

  return (SkipLines());
}

/****************************************************************************\
* MODIFIERS section [OPTIONAL]
*  Additions to the standard MODIFIERS CharModifiers section.
*  Useful now for adding RCONTROL shiftstates (eg: CAN/CSA prototype)
*  Useful in future for KBDGRPSELTAP keys that flip the kbd into an alternate
*  layout until the next character is produced (then reverts to main layout).
*
* Example of syntax is
*     MODIFIERS
*     RCONTROL    8
*     RSHIFT      KBDGRPSELTAP
* I hope to be able to extend this to allow key combos as KBDGRPSELTAP, since
* the CAN/CSA keyboard may want to have RShift+AltGr flip into the alternate
* layout (group 2 character set) in addition to just RCtrl, since some terminal
* emulators use the RCtrl key as an "Enter" key.
\****************************************************************************/
int doMODIFIERS()
{
    int  i = 3;
    int  iKW = NOT_KEYWORD;
    char achModifier[WORDBUFSIZE];
    char achModBits[LINEBUFSIZE];

    while(NextLine(gBuf, LINEBUFSIZE, gfpInput)) {
        if (sscanf(gBuf, "%s", achModifier) != 1) {
            continue;
        }

        if ((iKW = isKeyWord(achModifier)) < NUMKEYWORD) {
            break;
        }

        if (sscanf(gBuf, " %s %[^;\n]", achModifier, achModBits) < 2) {
            Warning(0, "poorly formed MODIFIER entry");
            break;
        }

        Modifiers[i].Vk = getVKNum(achModifier);
        Modifiers[i].pszModBits = _strdup(achModBits); // never freed!

        if (++i > (sizeof(Modifiers)/sizeof(Modifiers[0]))) {
            Warning(0, "Too many MODIFIER entries");
            break;
        }
    }

    return iKW;
}

/*************************************************************\
* SHIFTSTATE section
*  read number of states and each state
*  return : next keyword
\*************************************************************/
int doSHIFTSTATE(int *nState, int* aiState)
{
  int  i;
  int  iKW;
  int  iSt;
  char Tmp[WORDBUFSIZE];

  for(i = 0; i < MAXSTATES; i++)
  {
    aiState[i] = -1;
  }

  *nState = 0;
  while(NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
    if(sscanf(gBuf, "%s", Tmp) != 1)
    {
      continue;
    }

    if((iKW = isKeyWord(Tmp)) < NUMKEYWORD)
    {
      break;
    }

    if(sscanf(gBuf, " %2s[012367]", Tmp) != 1)
    {
      if (verbose) {
          Warning(0, "invalid state");
      }
      continue; /* add printf error later */
    }

    iSt = atoi(Tmp);
    for (i = 0; i < *nState; i++) {
        if (aiState[i] == iSt && verbose) {
            Warning(0, "duplicate state %d", iSt);
            break;
        }
    }

    if (*nState < MAXSTATES) {
        aiState[(*nState)++] = iSt;
    } else {
        if (verbose) {
            Warning(0, "too many states %d", *nState);
        }
    }
  }

  return iKW;
}

/****************************************************************************\
* ATTRIBUTES section [OPTIONAL]
*
* Example of syntax is
*     ATTRIBUTES
*     LRM_RLM
*     SHIFTLOCK
*     ALTGR
*
* These convert to
*   KLLF_LRM_RLM   (layout generates LRM/RLM 200E/200F with L/RShift+BackSpace)
*   KLLF_SHIFTLOCK (Capslock only turns CapsLock on, Shift turns it off)
*   KLLF_ALTGR     (this is normally inferred by number of states > 5)
*
\****************************************************************************/
char *Attribute[] = {
    "LRM_RLM"  ,
    "SHIFTLOCK",
    "ALTGR"
};

#define NUMATTR (sizeof(Attribute) / sizeof(Attribute[0]))

/*
 * Returns next key word encountered, and places in szAttr:
 *   empty string ("") or
 *   something like "KLLF_SHIFTLOCK" or "KLLF_SHIFTLOCK | KLLF_LRM_RLM"
 */
int doATTRIBUTES(char *szAttrs)
{
    int  iKW = NOT_KEYWORD;
    int i;
    char achAttribute[WORDBUFSIZE];

    szAttrs[0] = '\0';

    while (NextLine(gBuf, LINEBUFSIZE, gfpInput)) {
        if (sscanf(gBuf, "%s", achAttribute) != 1) {
            continue;
        }

        if ((iKW = isKeyWord(achAttribute)) < NUMKEYWORD) {
            break;
        }

        for (i = 0; i < NUMATTR; i++) {
            if (_strcmpi(Attribute[i], achAttribute) == 0) {
                if (szAttrs[0] != '\0') {
                    strcat(szAttrs, " | ");
                }
                strcat(szAttrs, "KLLF_");
                strcat(szAttrs, Attribute[i]);
            }
        }

        if (szAttrs[0] == '\0') {
            Warning(0, "poorly formed ATTRIBUTES entry");
            break;
        }
    }

    return iKW;
}

/**********************************************************************\
* GetCharacter
*  Scans the string in p to return a character value and type
*      syntax in p is:
*          xxxx    four hex digits, may be followed by a @ or %
*                  eg: 00e8, 00AF@, aaaa%
*          c       a character, may be followed with @ or %
*                  eg: x, ^@, %%
*          -1      not a character
*
*  return : character value (0xFFFF if badly formed)
*           type of character in pdwType
*                0             plain char (ends with neither @ nor %)
*                CHARTYPE_DEAD dead char  (ends with @)
*                CHARTYPE_LIG  ligature   (ends with %)
*                CHARTYPE_BAD  badly formed character value, exit.
*
\**********************************************************************/

#define CHARTYPE_DEAD 1
#define CHARTYPE_LIG  2
#define CHARTYPE_BAD  3

WCHAR GetCharacter(unsigned char *p, DWORD *pdwType)
{
    int Len;
    DWORD dwCh;

    *pdwType = 0;

    // if the last char is @ or % it is dead or ligature
    if (Len = strlen(p) - 1) {
        if (*(p + Len) == '@') {
            *pdwType = CHARTYPE_DEAD;
        } else if (*(p + Len) == '%') {
            *pdwType = CHARTYPE_LIG;
        }
    }

    if (Len < 2) {
        return *p;
    } else if (sscanf(p, "%4x", &dwCh) != 1) {
        if (verbose) {
            Warning(0, "LAYOUT error %s", p);
        }
        *pdwType = CHARTYPE_BAD;
        return 0;
    } else {
        return (WCHAR)dwCh;
    }
}

int WToUpper(int wch)
{
    WCHAR src[1] = { (WCHAR)wch };
    WCHAR result[1];

    if (LCMapStringW(0, LCMAP_UPPERCASE, src, 1, result, 1) == 0) {
        return L'\0';
    }

    return result[0];
}


/*************************************************************\
* LAYOUT section
*  return : next keyword
*           -1 if memory problem
\*************************************************************/
int doLAYOUT(KEYLAYOUT Layout[], int aiState[], int nState)
{
  int  i, idx, iCtrlState;
  BOOL fHasCharacters;
  int  iKW;
  int  Len;
  USHORT Scan;
  DWORD WChr;
  char Cap[MAXWCLENGTH];
  unsigned char WC[MAXSTATES][MAXWCLENGTH];
  char Tmp[WORDBUFSIZE];
  int i1, i2;
  int iScVk;

  memset(Layout, 0, NUMSCVK * sizeof(KEYLAYOUT));

  // Initialize layout entries
  for (idx = 0; idx < NUMSCVK; idx++) {
      Layout[idx].defined = FALSE;
      Layout[idx].nState = 0;
  }

  /*
   * Accumulate layout entries in the order they are read
   */
  idx = -1;
  while (NextLine(gBuf, LINEBUFSIZE, gfpInput)) {

      if (sscanf(gBuf, " %s", Tmp) != 1 || *Tmp == ';') {
          continue;
      }

      if ((iKW = isKeyWord(Tmp)) < NUMKEYWORD) {
          break;
      }

      i = sscanf(gBuf, " %x %s %s", &Scan, Tmp, Cap);
      if (i == 3) {
          fHasCharacters = TRUE;
      } else if (i == 2) {
          fHasCharacters = FALSE;
      } else {
          Error("not enough entries on line");
          return -1;
      }

      /*
       * We have found an Entry
       */
      idx++;
      if (idx >= NUMSCVK) {
          Error("ScanCode %02x - too many scancodes", Scan);
          return -1;
      }
      Layout[idx].Scan = Scan;
      Layout[idx].nLine = gLineCount;

      /*
       * Find and use the Default values for this Scan
       */
      for (iScVk = 0; iScVk < NUMSCVK; iScVk++) {
          if (ScVk[iScVk].Scan == 0xffff) {
              // We didn't find a match (the 0xffff entries come last)
              Warning(0, "defining new scancode 0x%2X, %s", Scan, Tmp);
              Layout[idx].VKey = (unsigned char)getVKNum(Tmp);
              Layout[idx].defined = TRUE;
              ScVk[iScVk].bUsed = TRUE;
              break;
          }
          if (Scan == ScVk[iScVk].Scan) {
              if (ScVk[iScVk].bUsed == TRUE) {
                  Error("Scancode %X was previously defined", Scan);
                  return -1;
              }
              if (ScVk[iScVk].VKey == 0xff) {
                  Error("Scancode %X is reserved", Scan);
                  return -1;
              }
              // Save the default VK for generating kbd*.h
              Layout[idx].VKeyDefault = ScVk[iScVk].VKey;
              Layout[idx].VKeyName    = ScVk[iScVk].VKeyName;
              Layout[idx].defined     = TRUE;
              ScVk[iScVk].bUsed       = TRUE;
              break;
          }
      }
      iScVk = 0xFFFF; // finished with iScVk for now

      if ((Layout[idx].VKey = (unsigned char)getVKNum(Tmp)) == -1) {
          if (verbose) {
              Warning(0, "invalid VK %s", Tmp);
          }
          continue;
      }

      if (fHasCharacters) {
          if(_strcmpi(Cap, "SGCAP") == 0) {
              *Cap = '2';
          }
          if(sscanf(Cap, "%1d[012]", &(Layout[idx].Cap)) != 1) {
              Error("invalid Cap %s", Cap);
              return -1;
          }
      }

      if ((Layout[idx].nState = sscanf(gBuf,
              " %*s %*s %*s %s %s %s %s %s %s %s %s",
              WC[0], WC[1], WC[2], WC[3], WC[4], WC[5], WC[6], WC[7])) < 2)
      {
          if (fHasCharacters) {
              Error("must have at least 2 characters");
              return -1;
          }
      }

      for (i = 0; i < Layout[idx].nState; i++) {
          DWORD dwCharType;

          if (_strcmpi(WC[i], "-1") == 0) {
              Layout[idx].WCh[i] = -1;
              continue;
          }

          Layout[idx].WCh[i] = GetCharacter(WC[i], &dwCharType);
          if (dwCharType == CHARTYPE_DEAD) {
              Layout[idx].DKy[i] = 1;
          } else if (dwCharType == CHARTYPE_LIG) {
              Layout[idx].LKy[i] = 1;
          } else if (dwCharType == CHARTYPE_BAD) {
              break;
          }
      }

      if (sanity_check && Layout[idx].nState > 0) {
          int nAltGr, nShiftAltGr;

          /*
           * Check that characters a-z and A-Z are on VK_A - VK_Z
           * N.b. maybe overactive warnings for the intl layouts.
           */
          if (((Layout[idx].WCh[0] >= 'a') && (Layout[idx].WCh[0] <= 'z')) ||
                  ((Layout[idx].WCh[1] >= 'A') && (Layout[idx].WCh[1] <= 'Z'))) {
              if ((Layout[idx].VKey != _toupper(Layout[idx].WCh[0])) && (Layout[idx].VKey != Layout[idx].WCh[1])) {
                  Warning(0, "VK_%s (0x%2x) does not match %c %c",
                          Tmp, Layout[idx].VKey, Layout[idx].WCh[0], Layout[idx].WCh[1]);
              }
          }

          /*
           * Check that CAPLOKALTGR is set appropriately
           */
          nAltGr = 0;
          nShiftAltGr = 0;
          for (i = 0; i < nState; i++) {
              if (aiState[i] == (KBDCTRL | KBDALT)) {
                  nAltGr = i;
              } else if (aiState[i] == (KBDCTRL | KBDALT | KBDSHIFT)) {
                  nShiftAltGr = i;
              }
          }

          /*
           * Check only if nShiftAltGr has a valid character; i.e. not zero, nor a dead key.
           */
          if (nAltGr && nShiftAltGr && Layout[idx].WCh[nShiftAltGr] && Layout[idx].WCh[nShiftAltGr] != -1) {
              if (Layout[idx].WCh[nShiftAltGr] != WToUpper(Layout[idx].WCh[nAltGr])) {
                  if (Layout[idx].Cap & CAPLOKALTGR) {
                      Warning(0, "VK_%s (0x%2x) [Shift]AltGr = [%2x],%2x should not be CAPLOKALTGR?",
                            Tmp, Layout[idx].VKey,
                            Layout[idx].WCh[nAltGr], Layout[idx].WCh[nShiftAltGr]);
                  }
              } else if (Layout[idx].WCh[nShiftAltGr] != Layout[idx].WCh[nAltGr]) {
                  /*
                   * If the character is completely same, no need for CAPLOKALTGR.
                   */
                  if ((Layout[idx].Cap & CAPLOKALTGR) == 0) {
                      Warning(0, "VK_%s (0x%2x) [Shift]AltGr = [%2x],%2x should be CAPLOKALTGR?",
                            Tmp, Layout[idx].VKey,
                            Layout[idx].WCh[nAltGr], Layout[idx].WCh[nShiftAltGr]);
                  }
              }
          }
      }


      /* SGCAP:  read the next line */
      if (Layout[idx].Cap & 0x02) {
         if((Layout[idx].pSGCAP = malloc( sizeof(KEYLAYOUT) )) == NULL)
         {
           Error("can't allocate SGCAP struct");
           return -1;
         }
         memset(Layout[idx].pSGCAP, 0, sizeof(KEYLAYOUT));

         if (NextLine(gBuf, LINEBUFSIZE, gfpInput) &&
                 (Layout[idx].pSGCAP->nState = sscanf(gBuf, " -1 -1 0 %s %s %s %s %s %s %s %s",
                         WC[0], WC[1], WC[2], WC[3], WC[4], WC[5], WC[6], WC[7])) != 0) {
             // DumpLayoutEntry(&Layout[idx]);
             for (i = 0; i < Layout[idx].pSGCAP->nState; i++) {
                 if (_strcmpi(WC[i], "-1") == 0) {
                    Layout[idx].pSGCAP->WCh[i] = -1;
                    continue;
                 }

                 if ((Len = strlen(WC[i]) - 1) > 0 && *WC[i + Len] == '@') {
                    Layout[idx].pSGCAP->DKy[i] = 1;   /* it is a dead key */
                 }

                 if (Len == 0) {
                    Layout[idx].pSGCAP->WCh[i] = *WC[i];
                 } else {
                    if (sscanf(WC[i], "%4x", &WChr) != 1) {
                        if (verbose) {
                          Warning(0, "SGCAP LAYOUT error %s", WC[i]);
                        }
                        continue;
                    } else {
                        Layout[idx].pSGCAP->WCh[i] = WChr;
                    }
                 }
             }
         } else {
             Error("invalid SGCAP");
         }
      }

      // DumpLayoutEntry(&Layout[idx]);
  }

  /*
   * Pick up any unused ScVk[] entries (defaults)
   */
  for (iScVk = 0; iScVk < NUMSCVK; iScVk++) {
      // if we reach 0xffff, we have come to the end.
      if (ScVk[iScVk].Scan == 0xffff) {
          break;
      }
      if (!ScVk[iScVk].bUsed) {
          idx++;
          if (idx >= NUMSCVK) {
              Error("ScanCode %02x - too many scancodes", ScVk[iScVk].Scan);
              return -1;
          }
          Layout[idx].Scan        = ScVk[iScVk].Scan;
          Layout[idx].VKey        = ScVk[iScVk].VKey;
          Layout[idx].VKeyDefault = ScVk[iScVk].VKey;
          Layout[idx].VKeyName    = ScVk[iScVk].VKeyName;
          Layout[idx].defined     = TRUE;
          Layout[idx].nLine       = 0;
          // DumpLayoutEntry(&Layout[idx]);
      } else {
          ScVk[iScVk].bUsed = FALSE;
      }
  }

  /*
   * Now make sure some standard Ctrl characters are present
   */
  MergeState(Layout, VK_BACK,   L'\b',  L'\b',  0x007f, aiState, nState);
  MergeState(Layout, VK_CANCEL, 0x0003, 0x0003, 0x0003, aiState, nState);
  MergeState(Layout, VK_ESCAPE, 0x001b, 0x001b, 0x001b, aiState, nState);
  MergeState(Layout, VK_RETURN, L'\r',  L'\r',  L'\n',  aiState, nState);
  MergeState(Layout, VK_SPACE,  L' ',   L' ',   L' ',   aiState, nState);

  /*
   * Check VK not duplicated
   */

  for (idx = 0; idx < NUMSCVK; idx++) {
      for (i = idx + 1; i < NUMSCVK; i++) {
          if (Layout[idx].VKey == Layout[i].VKey) {
              if (Layout[idx].VKey == 0xFF) {
                  // undefined extended and non-extended versions of the same key
                  continue;
              }
              if ((BYTE)Layout[idx].Scan == (BYTE)Layout[i].Scan) {
                  // extended and non-extended versions of the same key
                  continue;
              }
              Error("VK_%s (%02x) found at scancode %02x and %02x",
                    getVKName(Layout[idx].VKey, 0), Layout[idx].VKey, Layout[idx].Scan, Layout[i].Scan);
          }
      }
  }

  /*
   * Find duplicated characters and warn of VkKeyScanEx results
   */
  if (verbose) {
     for (i1 = 0; i1 < NUMSCVK; i1++) {
        for (i2 = i1 + 1; i2 < NUMSCVK; i2++) {
           int ich1, ich2;
           for (ich1 = 0; ich1 < Layout[i1].nState; ich1++) {
             if (Layout[i1].WCh[ich1] == -1) {
                // there may be many WCH_NONEs (padding, or empty holes)
                continue;
             }
             if (Layout[i1].WCh[ich1] < 0x20) {
                // Don't care about Ctrl chars.
                // these are usually duplicated eg: Ctrl-M == Return, etc.
                continue;
             }
             if ((Layout[i1].VKey == VK_DECIMAL) || (Layout[i2].VKey == VK_DECIMAL)) {
                // kbdtool has put VK_DECIMAL at the end just for VkKeyScanEx
                // It is usually period or comma, and we prefer to get those
                // from the main section of the keyboard.
                continue;
             }
             for (ich2 = 0; ich2 < Layout[i2].nState; ich2++) {
                if (Layout[i1].WCh[ich1] == Layout[i2].WCh[ich2]) {
                   char achVK1[40];
                   char achVK2[40];
                   strncpy(achVK1, getVKName(Layout[i1].VKey, TRUE), sizeof(achVK1));
                   strncpy(achVK2, getVKName(Layout[i2].VKey, TRUE), sizeof(achVK2));
                   Warning(Layout[i1].nLine,
                           "%04x is on %s and %s",
                           Layout[i1].WCh[ich1],
                           achVK1, achVK2);
                 }
              }
           }
        }
     }
  }

  return iKW;
}

/*************************************************************\
* DEADKEY section
*  return : next keyword
*           -1 if memory problem
\*************************************************************/
int doDEADKEY(PDEADKEY *ppDeadKey)
{
  char       Tmp[WORDBUFSIZE];
  int        iKW;
  DEADKEY   *pDeadKey;
  PDEADTRANS pDeadTrans;
  PDEADTRANS *ppDeadTrans;
  DWORD       dw;
  static PDEADKEY pLastDeadKey;
  int        iLen;
  DWORD      dwCharType;


  if (sscanf(gBuf, " DEADKEY %s", Tmp) != 1) {
      Warning(0, "missing dead key");
      return SkipLines();
  }


  /* add later : check if dw is in Layout*/

  if((pDeadKey = (DEADKEY*) malloc( sizeof(DEADKEY) )) == NULL)
  {
    Error("can't allocate DEADKEY struct");
    return -1;
  }

  pDeadKey->Dead = GetCharacter(Tmp, &dwCharType);
  if (dwCharType != 0) {
      Error("DEADKEY character value badly formed");
      return -1;
  }

  pDeadKey->pNext = NULL;
  pDeadKey->pDeadTrans = NULL;

  /*
   * Link into end of list (maintaining original order)
   */
  if (*ppDeadKey) {
      ppDeadKey = &(pLastDeadKey->pNext);
  }
  *ppDeadKey = pDeadKey;
  pLastDeadKey = pDeadKey;
  // ppDeadKey = &(pDeadKey->pNext);


  ppDeadTrans = &(pDeadKey->pDeadTrans);
  while(NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
      if (sscanf(gBuf, " %s", Tmp) != 1 || *Tmp == ';') {
          continue;
      }

      if((iKW = isKeyWord(Tmp)) < NUMKEYWORD)
      {
        break;
      }

      // get base character
      dw = GetCharacter(Tmp, &dwCharType);
      if (dwCharType != 0) {
          Error("DEADKEY %x: base character value badly formed", pDeadKey->Dead);
          return -1;
      }

      /* add later : check dw */

      if((pDeadTrans = (DEADTRANS *) malloc( sizeof(DEADTRANS) )) == NULL)
      {
        Error("can't allocate DEADTRANS struct");
        return -1;
      }
      memset(pDeadTrans, 0, sizeof(DEADTRANS));

      pDeadTrans->pNext = NULL;
      pDeadTrans->Base = dw;
      pDeadTrans->uFlags = 0;

      /*
       * Link to end of list (maintaining original order)
       */
      *ppDeadTrans = pDeadTrans;
      ppDeadTrans = &(pDeadTrans->pNext);

      if (sscanf(gBuf, " %*s %s", Tmp) != 1) {
        if (verbose) {
          Warning(0, "missing deadtrans key");
        }
        continue;
      }

      pDeadTrans->WChar = GetCharacter(Tmp, &dwCharType);
      if (dwCharType == CHARTYPE_DEAD) {
          pDeadTrans->uFlags |= 0x0001; // DKF_DEAD in oak\inc\kbd.h
      } else if (dwCharType != 0) {
          Error("DEADKEY character value badly formed");
          return -1;
      }
  }

  return iKW;
}

static int gMaxLigature = 0;

/*************************************************************\
* LIGATURE section
*  return : next keyword
*           -1 if memory problem
\*************************************************************/
int doLIGATURE(PLIGATURE *ppLigature)
{
  int  i;
  int  iKW;
  DWORD WChr;
  char Mod[MAXWCLENGTH];
  unsigned char WC[MAXLIGATURES+1][MAXWCLENGTH];
  char Tmp[WORDBUFSIZE];
  LIGATURE *pLigature;
  static PLIGATURE pLastLigature;

  while(NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
    if(sscanf(gBuf, " %s", Tmp) != 1 || *Tmp == ';')
    {
      continue;
    }

    if((iKW = isKeyWord(Tmp)) < NUMKEYWORD)
    {
      break;
    }

    if(sscanf(gBuf, " %s %s", Tmp, Mod) != 2)
    {
      if(verbose)
      {
        Warning(0, "invalid LIGATURE");
      }
      continue;
    }

    if((pLigature = (LIGATURE*) malloc( sizeof(LIGATURE) )) == NULL)
    {
      Error("can't allocate LIGATURE struct");
      return -1;
    }
    pLigature->pNext = NULL;

    if((pLigature->VKey = (unsigned char)getVKNum(Tmp)) == -1)
    {
      if(verbose)
      {
        Warning(0, "invalid VK %s", Tmp);
      }
      continue;
    }

    if(sscanf(Mod, "%1d[012367]", &(pLigature->Mod)) != 1)
    {
      if(verbose)
      {
        Warning(0, "invalid Mod %s", Mod);
      }
      continue;
    }

    /*
     * We're currently limited to MAXLIGATURES characters per
     * ligature. In order to support more characters per ligature,
     * increase this define (in kbdx.h).
     */
    if((pLigature->nCharacters = \
        sscanf(gBuf, " %*s %*s %s %s %s %s %s %s", \
          &WC[0], &WC[1], &WC[2], &WC[3], &WC[4], &WC[5])) < 2)
    {
      if(verbose)
      {
        Warning(0, "must have at least 2 characters");
      }
      continue;
    }

    if (pLigature->nCharacters > MAXLIGATURES)
    {
        if(verbose)
        {
          Warning(0, "exceeded maximum # of characters for ligature");
        }
        continue;
    }

    for(i = 0; i < pLigature->nCharacters; i++)
    {
        DWORD dwCharType;

        pLigature->WCh[i] = GetCharacter(WC[i], &dwCharType);
        if (dwCharType != 0) {
            if(verbose) {
                Warning(0, "LIGATURE error %s", WC[i]);
            }
            break;
        }
    }

    /*
     * Link into end of list (maintaining original order)
     */
    if (*ppLigature) {
        ppLigature = &(pLastLigature->pNext);
    }
    *ppLigature = pLigature;
    pLastLigature = pLigature;

    gMaxLigature = max(pLigature->nCharacters, gMaxLigature);
  }

  return iKW;
}

/*************************************************************\
* KEYNAME, KEYNAME_EXT, KEYNAME_DEAD sections
*  return : next keyword
*           -1 if memory problem
\*************************************************************/
int doKEYNAME(PKEYNAME *ppKeyName)
{
  KEYNAME *pKN;
  int      iKW;
  char     Tmp[WORDBUFSIZE];
  int      Char;
  char    *p;
  char    *q;

  *ppKeyName = NULL;

  while(NextLine(gBuf, LINEBUFSIZE, gfpInput))
  {
    if(sscanf(gBuf, " %s", Tmp) != 1 || *Tmp == ';')
    {
      continue;
    }

    if((iKW = isKeyWord(Tmp)) < NUMKEYWORD)
    {
      break;
    }

    if(sscanf(Tmp, " %4x", &Char) != 1)
    {
      if(verbose)
      {
        Warning(0, "invalid char code");
      }
      continue;
    }

    /* add later : check Scan code */

    if(sscanf(gBuf, " %*4x %s[^\n]", Tmp) != 1)
    {
      if(verbose)
      {
        Warning(0, "missing name");
      }
      continue;
    }

    p = strstr(gBuf, Tmp);
    if((q = strchr(p, '\n')) != NULL)
    {
      *q = '\0';
    }

    if((pKN = (void*) malloc( sizeof(KEYNAME) )) == NULL)
    {
      Error("can't allocate KEYNAME struct");
      return -1;
    }

    pKN->Code = Char;
    pKN->pName = _strdup(p);
    pKN->pNext = NULL;

    /*
     * Link to end of list (maintaining original order)
     */
    *ppKeyName = pKN;
    ppKeyName = &(pKN->pNext);
  }

  return iKW;
}

/*************************************************************\
*  write kbd*.rc                                             *
\*************************************************************/
int kbd_rc(void)
{
  char  OutName[FILENAMESIZE];
  char  kbdname[MAXKBDNAME];
  FILE *pOut;

  strcpy(OutName, "KBD");
  strcat(OutName, gKBDName);
  strcat(OutName, ".RC");

  strcpy(kbdname, gKBDName);
  _strlwr(kbdname);

  printf(" %12s", OutName);
  if((pOut = fopen(OutName, "wt")) == NULL)
  {
    printf(": can't open for write; ");
    return FAILURE;
  }

  fprintf(pOut,
    "#include <windows.h>\n"
    "#include <ntverp.h>\n"
    "\n"
    "#define VER_FILETYPE              VFT_DLL\n"
    "#define VER_FILESUBTYPE           VFT2_DRV_KEYBOARD\n" );

  fprintf(pOut,
    "#define VER_FILEDESCRIPTION_STR   \"%s Keyboard Layout\"\n", gDescription);

  fprintf(pOut,
    "#define VER_INTERNALNAME_STR      \"kbd%s (%d.%d)\"\n",
    kbdname, gVersion, gSubVersion);

  fprintf(pOut,
    "#define VER_ORIGINALFILENAME_STR  \"kbd%s.dll\"\n", kbdname);

  fprintf(pOut,
    "\n"
    "#define VER_LANGNEUTRAL\n"
    "#include \"common.ver\"\n");

  fclose(pOut);
  return SUCCESS;
}

/*************************************************************\
*  write kbd*.def                                            *
\*************************************************************/
int kbd_def(void)
{
  char  OutName[FILENAMESIZE];
  FILE *pOut;

  strcpy(OutName, "KBD");
  strcat(OutName, gKBDName);
  strcat(OutName, ".DEF");

  printf(" %12s", OutName);
  if((pOut = fopen(OutName, "wt")) == NULL)
  {
    printf(": can't open for write; ");
    return FAILURE;
  }

  fprintf(pOut,
    "LIBRARY KBD%s\n"
    "\n"
    "EXPORTS\n"
    "    KbdLayerDescriptor @1\n", gKBDName);

  fclose(pOut);
  return SUCCESS;
}

/*************************************************************\
*  write kbd*.h                                              *
\*************************************************************/
int kbd_h(KEYLAYOUT Layout[])
{
  char  OutName[FILENAMESIZE];
  FILE *pOut;

  int  nDiff = 0;
  int  idx;


  strcpy(OutName, "KBD");
  strcat(OutName, gKBDName);
  strcat(OutName, ".H");

  printf(" %12s ", OutName);
  if((pOut = fopen(OutName, "wt")) == NULL)
  {
    printf(": can't open for write; ");
    return FAILURE;
  }

  fprintf(pOut,"/****************************** Module Header ******************************\\\n"
               "* Module Name: %s\n*\n* keyboard layout header for %s\n"
               "*\n"
               "* Copyright (c) 1985-2001, Microsoft Corporation\n"
               "*\n"
               "* Various defines for use by keyboard input code.\n*\n* History:\n"
               "*\n"
               "* created by KBDTOOL v%d.%02d %s*\n"
               "\\***************************************************************************/\n\n"
               , OutName, gDescription, gVersion, gSubVersion, asctime(Now));

  fprintf(pOut,"/*\n"
               " * kbd type should be controlled by cl command-line argument\n"
               " */\n"
               "#define KBD_TYPE 4\n\n"
               "/*\n"
               "* Include the basis of all keyboard table values\n"
               "*/\n"
               "#include \"kbd.h\"\n"
               // "#include \"strid.h\"\n"   --- do this in v3.07
               );

  fprintf(pOut,"/***************************************************************************\\\n"
               "* The table below defines the virtual keys for various keyboard types where\n"
               "* the keyboard differ from the US keyboard.\n"
               "*\n"
               "* _EQ() : all keyboard types have the same virtual key for this scancode\n"
               "* _NE() : different virtual keys for this scancode, depending on kbd type\n"
               "*\n"
               "*     +------+ +----------+----------+----------+----------+----------+----------+\n"
               "*     | Scan | |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |    kbd   |\n"
               "*     | code | |   type 1 |   type 2 |   type 3 |   type 4 |   type 5 |   type 6 |\n"
               "\\****+-------+_+----------+----------+----------+----------+----------+----------+*/\n\n");

  for (idx = 0; idx < NUMSCVK; idx++) {
      if (Layout[idx].defined && (Layout[idx].VKey != Layout[idx].VKeyDefault))
      {
        char ch;
        switch (Layout[idx].Scan & 0xFF00) {
        case 0xE100:
            ch = 'Y';
            break;

        case 0xE000:
            ch = 'X';
            break;

        case 0x0000:
            ch = 'T';
            break;

        default:
            Error("Weird scancode value %04x: expected xx, E0xx or E1xx",
                  (Layout[idx].Scan & 0xFF00));
            return FAILURE;
        }

        fprintf(pOut,
                "#undef  %c%02X\n"
                "#define %c%02X _EQ(%43s%23s\n",
                ch, LOBYTE(Layout[idx].Scan),
                ch, LOBYTE(Layout[idx].Scan), getVKName(Layout[idx].VKey, 0), ")");
      }
  }

  fprintf(pOut,"\n");
  fclose(pOut);

  return SUCCESS;
}

/*************************************************************\
*  Convert a Unicode value to a text string
*   Zero = 0 : return 'A'; 0x????
*          1 : return  A ; \x????
*   return : ptr to gCharName where result is stored
\*************************************************************/
char *WChName(int WC, int Zero)
{
  char *s;

  if(WC == -1)
  {
    strcpy(gCharName, "WCH_NONE");
  }
  else if(WC > 0x1F && WC < 0x7F)
  {
    s = gCharName;

    if(Zero == 0)
    {
      *s++ = '\'';
    }

    if(WC == '\"' || WC == '\'' || WC == '\\')
    {
      *s++ = '\\';
    }

    *s++ = (char)WC;

    if(Zero == 0)
    {
      *s++ = '\'';
    }

    *s = '\0';
  }
  else
  {
     switch (WC) {
     case L'\r':
         strcpy(gCharName, "'\\r'");
         break;
     case L'\n':
         strcpy(gCharName, "'\\n'");
         break;
     case L'\b':
         strcpy(gCharName, "'\\b'");
         break;
     default:
         if(Zero == 0) {
           sprintf(gCharName, "0x%04x", WC);
         } else {
           sprintf(gCharName, "\\x%04x", WC);
         }
     }
  }

  return gCharName;
}

void PrintNameTable(
  FILE    *pOut,
  PKEYNAME pKN,
  BOOL bDead)
{
    char    *p;
    char    *q;
    int     k;
    char    ExtraLine[LINEBUFSIZE];

    while (pKN)
    {
      KEYNAME *pKNOld;
      p = ExtraLine;
      q = pKN->pName;

      if (strncmp(q, "IDS_", 4) == 0) {
          strcpy(p, "(LPWSTR)");
          strcat(p, q);
      } else {
          *p++ = 'L';
          if( *q != '\"' ) {
            *p++ = '\"';
          }

          while(*q)
          {
            if( *q == '\\' && ( *(q+1) == 'x' || *(q+1) == 'X' ) )
            {
              while( *q == '\\' && ( *(q+1) == 'x' || *(q+1) == 'X' ) )
              {
                for(k = 0; *q && k < 6; k++)
                {
                  *p++ = *q++;
                }
              }
              if( *q )
              {
                *p++ = '\"';
                *p++ = ' ';
                *p++ = 'L';
                *p++ = '\"';
              }
            }
            else
            {
              *p++ = *q++;
            }
          }

          if( *(p - 1) != '\"' )
          {
            *p++ = '\"';
          }
          *p++ = '\0';
      }

      if (bDead) {
          fprintf(pOut,"    L\"%s\"\t%s,\n", WChName(pKN->Code, 1), ExtraLine);
      } else {
          fprintf(pOut,"    0x%02x,    %s,\n", pKN->Code, ExtraLine);
      }

      pKNOld = pKN;
      pKN = pKN->pNext;

      /*
       * Free the memory (why bother???)
       */
      free(pKNOld->pName);
      free(pKNOld);
    }

    if (bDead) {
      fprintf(pOut,"    NULL\n");
    } else {
      fprintf(pOut,"    0   ,    NULL\n");
    }
}

/*************************************************************\
*  write kbd*.c                                              *
\*************************************************************/
int kbd_c(
  int        nState,
  int        aiState[],
  char *     szAttrs,
  KEYLAYOUT  Layout[],
  PDEADKEY   pDeadKey,
  PLIGATURE  pLigature,
  PKEYNAME   pKeyName,
  PKEYNAME   pKeyNameExt,
  PKEYNAME   pKeyNameDead)
{
  char     OutName[13];
  char     ExtraLine[LINEBUFSIZE];
  char     Tmp[WORDBUFSIZE];
  char    *p;
  char    *q;
  FILE    *pOut;
  int      MaxSt;
  int      aiSt[MAXSTATES];
  int      idx, idxSt, j, k, m;
  DWORD    dwEmptyTables = 0; // bitmask of empty VK_TO_WCHARS tables

  KEYNAME   *pKN;
  DEADTRANS *pDeadTrans;

  char *Cap[] = {
    "0",
    "CAPLOK",
    "SGCAPS",
    "CAPLOK | SGCAPS",
    "CAPLOKALTGR",
    "CAPLOK | CAPLOKALTGR"
  };

  strcpy(OutName, "KBD");
  strcat(OutName, gKBDName);
  strcat(OutName, ".C");

  printf(" %12s", OutName);

  if((pOut = fopen(OutName, "wt")) == NULL)
  {
    printf(": can't open for write\n");
    return FAILURE;
  }

  fprintf(pOut,"/***************************************************************************\\\n"
               "* Module Name: %s\n*\n* keyboard layout for %s\n"
               "*\n"
               "* Copyright (c) 1985-2001, Microsoft Corporation\n"
               "*\n"
               "* History:\n"
               "* KBDTOOL v%d.%02d - Created  %s"
               "\\***************************************************************************/\n\n",
               OutName, gDescription, gVersion, gSubVersion, asctime(Now)
          );

  if (fallback_driver) {
    fprintf(pOut, "#include \"precomp.h\"\n");
  }
  else {
    fprintf(pOut, "#include <windows.h>\n"
                  "#include \"kbd.h\"\n"
                  "#include \"kbd%s.h\"\n\n",
                  gKBDName);
  }

  if ( fallback_driver )   {

     fprintf(pOut,"#pragma data_seg(\"%s\")\n"
                  "#define ALLOC_SECTION_LDATA"
#ifdef LATER
             " const"
#endif
             "\n\n",
                   ".kbdfallback" );

  }
  else  {

     fprintf(pOut,"#if defined(_M_IA64)\n"
                  "#pragma section(\"%s\")\n"
                  "#define ALLOC_SECTION_LDATA __declspec(allocate(\"%s\"))\n"
                  "#else\n"
                  "#pragma data_seg(\"%s\")\n"
                  "#define ALLOC_SECTION_LDATA\n"
                  "#endif\n\n",
                   ".data",
                   ".data",
                   ".data");

  }

  fprintf(pOut,"/***************************************************************************\\\n"
               "* ausVK[] - Virtual Scan Code to Virtual Key conversion table for %s\n"
               "\\***************************************************************************/\n\n"
              ,gDescription);

  fprintf(pOut,"static ALLOC_SECTION_LDATA USHORT ausVK[] = {\n"
               "    T00, T01, T02, T03, T04, T05, T06, T07,\n"
               "    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,\n"
               "    T10, T11, T12, T13, T14, T15, T16, T17,\n"
               "    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,\n"
               "    T20, T21, T22, T23, T24, T25, T26, T27,\n"
               "    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,\n"
               "    T30, T31, T32, T33, T34, T35,\n\n");

  fprintf(pOut,"    /*\n"
               "     * Right-hand Shift key must have KBDEXT bit set.\n"
               "     */\n"
               "    T36 | KBDEXT,\n\n"
               "    T37 | KBDMULTIVK,               // numpad_* + Shift/Alt -> SnapShot\n\n"
               "    T38, T39, T3A, T3B, T3C, T3D, T3E,\n"
               "    T3F, T40, T41, T42, T43, T44,\n\n");

  fprintf(pOut,"    /*\n"
               "     * NumLock Key:\n"
               "     *     KBDEXT     - VK_NUMLOCK is an Extended key\n"
               "     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)\n"
               "     */\n"
               "    T45 | KBDEXT | KBDMULTIVK,\n\n"
               "    T46 | KBDMULTIVK,\n\n");

  fprintf(pOut,"    /*\n"
               "     * Number Pad keys:\n"
               "     *     KBDNUMPAD  - digits 0-9 and decimal point.\n"
               "     *     KBDSPECIAL - require special processing by Windows\n"
               "     */\n"
               "    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)\n"
               "    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),\n"
               "    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),\n"
               "    T4A,\n"
               "    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),\n"
               "    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),\n"
               "    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),\n"
               "    T4E,\n"
               "    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),\n"
               "    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),\n"
               "    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),\n"
               "    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),\n"
               "    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),\n\n");

  fprintf(pOut,"    T54, T55, T56, T57, T58, T59, T5A, T5B,\n"
               "    T5C, T5D, T5E, T5F, T60, T61, T62, T63,\n"
               "    T64, T65, T66, T67, T68, T69, T6A, T6B,\n"
               "    T6C, T6D, T6E, T6F, T70, T71, T72, T73,\n"
               "    T74, T75, T76, T77, T78, T79, T7A, T7B,\n"
               "    T7C, T7D, T7E\n\n"
               "};\n\n");

  //
  // Output E0-prefixed (extended) scancodes
  //
  fprintf(pOut,"static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {\n");
  for (idx = 0; idx < NUMSCVK; idx++) {
      // skip keys that are not E0 extended
      if ((Layout[idx].Scan & 0xFF00) != 0xE000) {
          continue;
      }
      // if not undefined (Scan 0xffff) and not reserved (VKey 0xff)
      if ((Layout[idx].Scan != 0xffff) && (Layout[idx].VKey != 0xff)) {
          fprintf(pOut,"        { 0x%02X, X%02X | KBDEXT              },  // %s\n",
                  Layout[idx].Scan & 0xFF, Layout[idx].Scan & 0xFF, Layout[idx].VKeyName);
      }
  }
  fprintf(pOut,"        { 0,      0                       }\n"
               "};\n\n");

  // Output 0xE1-prefixed scancodes
  fprintf(pOut,"static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {\n");
  for (idx = 0; idx < NUMSCVK; idx++) {
      // skip keys that are not E1 extended
      if ((Layout[idx].Scan & 0xFF00) != 0xE100) {
          continue;
      }
      // if not undefined (Scan 0xffff) and not reserved (VKey 0xff)
      if ((Layout[idx].Scan != 0xffff) && (Layout[idx].VKey != 0xff)) {
          fprintf(pOut,"        { 0x%02X, Y%02X | KBDEXT            },  // %s\n",
                  Layout[idx].Scan & 0xFF, Layout[idx].Scan & 0xFF,
                  Layout[idx].VKeyName);
      }
  }
  fprintf(pOut,"        { 0x1D, Y1D                       },  // Pause\n"
               "        { 0   ,   0                       }\n"
               "};\n\n");

  fprintf(pOut,"/***************************************************************************\\\n"
               "* aVkToBits[]  - map Virtual Keys to Modifier Bits\n"
               "*\n"
               "* See kbd.h for a full description.\n"
               "*\n"
               "* %s Keyboard has only three shifter keys:\n"
               "*     SHIFT (L & R) affects alphabnumeric keys,\n"
               "*     CTRL  (L & R) is used to generate control characters\n"
               "*     ALT   (L & R) used for generating characters by number with numpad\n"
               "\\***************************************************************************/\n"
               ,gDescription);

//  if (we get an RCONTROL, change VK_CONTROL to be VK_LCONTROL) { same for RMENU, RSHIFT?
//  }   CAN/CSA tap selection....

  fprintf(pOut,"static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {\n");
  for (idx = 0; Modifiers[idx].Vk != 0; idx++) {
      fprintf(pOut, "    { %-12s,   %-12s },\n",
              getVKName(Modifiers[idx].Vk, TRUE),
              Modifiers[idx].pszModBits);
  }
  fprintf(pOut, "    { 0           ,   0           }\n};\n\n");

  fprintf(pOut,"/***************************************************************************\\\n"
               "* aModification[]  - map character modifier bits to modification number\n"
               "*\n"
               "* See kbd.h for a full description.\n"
               "*\n"
               "\\***************************************************************************/\n\n");

  for (idxSt = 0; idxSt < MAXSTATES; idxSt++) {
      aiSt[idxSt] = -1;
  }

  MaxSt = 1;
  for (idxSt = 0; idxSt < MAXSTATES &&  aiState[idxSt] > -1; idxSt++) {
      aiSt[aiState[idxSt]] = idxSt;
      if (aiState[idxSt] > MaxSt) {
        MaxSt = aiState[idxSt];
      }
  }

  fprintf(pOut,"static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {\n"
               "    &aVkToBits[0],\n"
               "    %d,\n"
               "    {\n"
               "    //  Modification# //  Keys Pressed\n"
               "    //  ============= // =============\n"
              ,MaxSt);

  for (idxSt = 0; idxSt <= MaxSt; idxSt++) {
    int iMod;
    BOOL bNeedPlus;
    if(aiSt[idxSt] == -1) {
      fprintf(pOut,"        SHFT_INVALID, // ");
    } else if(idxSt == MaxSt) {
      fprintf(pOut,"        %d             // ", aiSt[idxSt]);
    } else {
      fprintf(pOut,"        %d,            // ", aiSt[idxSt]);
    }

    bNeedPlus = FALSE;
    for (iMod = 0; (1 << iMod) <= idxSt; iMod++) {
        if (bNeedPlus) {
            fprintf(pOut, "+ ");
            bNeedPlus = FALSE;
        }
        if ((1 << iMod) & idxSt) {
            char achModifier[50];
            strcpy(achModifier, getVKName(Modifiers[iMod].Vk, TRUE));
            for (j = 4; (j < 50) && (achModifier[j] != '\0'); j++) {
                achModifier[j] = (char)tolower(achModifier[j]);
            }
            fprintf(pOut, "%s ", &achModifier[3]);
            bNeedPlus = TRUE;
        }
    }
    fprintf(pOut, "\n");
  }

  fprintf(pOut,"     }\n"
               "};\n\n");

  fprintf(pOut,"/***************************************************************************\\\n"
               "*\n"
               "* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states\n"
               "* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states\n"
               "* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states\n");

  for (idxSt = 5; idxSt < MaxSt; idxSt++) {
      fprintf(pOut,
              "* aVkToWch%d[]  - Virtual Key to WCHAR translation for %d shift states\n",
              idxSt, idxSt);
  }

  fprintf(pOut,"*\n"
               "* Table attributes: Unordered Scan, null-terminated\n"
               "*\n"
               "* Search this table for an entry with a matching Virtual Key to find the\n"
               "* corresponding unshifted and shifted WCHAR characters.\n"
               "*\n"
               "* Special values for VirtualKey (column 1)\n"
               "*     0xff          - dead chars for the previous entry\n"
               "*     0             - terminate the list\n"
               "*\n"
               "* Special values for Attributes (column 2)\n"
               "*     CAPLOK bit    - CAPS-LOCK affect this key like SHIFT\n"
               "*\n"
               "* Special values for wch[*] (column 3 & 4)\n"
               "*     WCH_NONE      - No character\n"
               "*     WCH_DEAD      - Dead Key (diaresis) or invalid (US keyboard has none)\n"
               "*     WCH_LGTR      - Ligature (generates multiple characters)\n"
               "*\n"
               "\\***************************************************************************/\n\n");

  for (idxSt = 2; idxSt <= nState; idxSt++) {
    /*
     * Quickly check if this table would actually be empty.
     * An empty table (containing just zero terminator) is pointless.
     * Also it will go into the .bss section, which we would have to merge
     * into the .data section with a linker flag, else NT wouldn't load it
     * (bug #120244 - IanJa)
     */
    BOOL bEmpty;

    bEmpty = TRUE;
    if (idxSt == 2) {
      // Special case for TAB ADD DIVIDE MULTIPLY SUBTRACT (below)
      bEmpty = FALSE;
    } else {
      for (j = 0; j < NUMSCVK; j++) {
        if (Layout[j].nState == idxSt) {
          bEmpty = FALSE;
          break;
        }
      }
    }
    if (bEmpty) {
      fprintf(stderr, "\ntable %d is empty\n", idxSt);
      dwEmptyTables |= (1 << idxSt);
      continue;
    }

    fprintf(pOut,"static ALLOC_SECTION_LDATA VK_TO_WCHARS%d aVkToWch%d[] = {\n"
                 "//                      |         |  Shift  |"
                 ,idxSt, idxSt);

    for (j = 2; j < idxSt; j++) {
      fprintf(pOut,"%-9.9s|", StateLabel[aiState[j]]);
    }

    fprintf(pOut,"\n//                      |=========|=========|");
    for(j = 2; j < idxSt; j++) {
      fprintf(pOut,"=========|");
    }
    fprintf(pOut,"\n");

    for (j = 0; j < NUMSCVK; j++) {
      if (idxSt != Layout[j].nState) {
        continue;
      }
      fprintf(pOut,"  {%-13s,%-7s", \
              getVKName(Layout[j].VKey, 1), Cap[Layout[j].Cap]);

      *ExtraLine = '\0';

      for (k = 0; k < idxSt; k++) {
        if (pDeadKey != NULL && Layout[j].DKy[k] == 1) {
          /*
           * it is a dead key
           */
          if (*ExtraLine == '\0') {
            strcpy(ExtraLine, "  {0xff         ,0      ");
            if (Layout[j].Cap != 2) {
              /*
               * Not SGCap
               */
              for (m = 0; m < k; m++) {
                strcat(ExtraLine, ",WCH_NONE ");
              }
            } else {
              /*
               *  added for a new kbdCZ that has both SGCap and WCH_DEAD
               */
              for (m = 0; m < k; m++ ) {
                if (Layout[j].pSGCAP->WCh[m] == 0) {
                  strcat( ExtraLine, ",WCH_NONE " );
                } else {
                  sprintf( Tmp, ",%-9s", WChName( Layout[j].pSGCAP->WCh[m], 0 ) );
                  strcat( ExtraLine, Tmp );
                }
              }
            }
          }
          sprintf(Tmp,",%-9s", WChName(Layout[j].WCh[k], 0));
          strcat(ExtraLine, Tmp);
          fprintf(pOut,",WCH_DEAD ");

        } else if(Layout[j].LKy[k] == 1) {
            /*
             * it is a ligature key
             */
            if (pLigature == NULL) {
              Error("Ligature entry with no LIGATURE table");
              fclose(pOut);
              return FAILURE;
            }
            fprintf(pOut,",WCH_LGTR ");
            if (*ExtraLine != '\0') {
              strcat(ExtraLine, ",WCH_NONE ");
            }
        } else {
          fprintf(pOut,",%-9s", WChName(Layout[j].WCh[k], 0));
          if (*ExtraLine != '\0') {
            strcat(ExtraLine, ",WCH_NONE ");
          }
        }
      }

      fprintf(pOut,"},\n");

      if (*ExtraLine != '\0') {
        fprintf(pOut,"%s},\n", ExtraLine);
        continue;   /* skip if WCH_DEAD */
      }

      /*
       * skip if not SGCAP
       */
      if (Layout[j].Cap != 2) {
        continue;
      }

      if (Layout[j].pSGCAP == NULL) {
        fclose(pOut);
        Error("failed SGCAP error");
        return FAILURE;
      }

      fprintf(pOut,"  {%-13s,0      ", getVKName(Layout[j].VKey, 1));

      for (k = 0; k < Layout[j].pSGCAP->nState; k++) {
        fprintf(pOut,",%-9s", WChName(Layout[j].pSGCAP->WCh[k], 0));
      }

      fprintf(pOut,"},\n");

      free (Layout[j].pSGCAP);
    }

    /*
     * These entries appear last to make VkKeyScan[Ex] results match
     * Windows 95/98. See DRIVERS\KEYBOARD\WIN3.1\TAB4.INC (under
     * \\redrum\w98slmRO\proj\dos\src)
     */
    if (idxSt == 2) {
      fprintf(pOut,"  {VK_TAB       ,0      ,'\\t'     ,'\\t'     },\n"
                   "  {VK_ADD       ,0      ,'+'      ,'+'      },\n"
                   "  {VK_DIVIDE    ,0      ,'/'      ,'/'      },\n"
                   "  {VK_MULTIPLY  ,0      ,'*'      ,'*'      },\n"
                   "  {VK_SUBTRACT  ,0      ,'-'      ,'-'      },\n");
    }

    fprintf(pOut,"  {0            ,0      ");
    for (k = 0; k < idxSt; k++) {
      fprintf(pOut,",0        ");
    }
    fprintf(pOut,"}\n"
                 "};\n\n");
  }

  fprintf(pOut,"// Put this last so that VkKeyScan interprets number characters\n"
               "// as coming from the main section of the kbd (aVkToWch2 and\n"
               "// aVkToWch5) before considering the numpad (aVkToWch1).\n\n"
               "static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {\n"
               "    { VK_NUMPAD0   , 0      ,  '0'   },\n"
               "    { VK_NUMPAD1   , 0      ,  '1'   },\n"
               "    { VK_NUMPAD2   , 0      ,  '2'   },\n"
               "    { VK_NUMPAD3   , 0      ,  '3'   },\n"
               "    { VK_NUMPAD4   , 0      ,  '4'   },\n"
               "    { VK_NUMPAD5   , 0      ,  '5'   },\n"
               "    { VK_NUMPAD6   , 0      ,  '6'   },\n"
               "    { VK_NUMPAD7   , 0      ,  '7'   },\n"
               "    { VK_NUMPAD8   , 0      ,  '8'   },\n"
               "    { VK_NUMPAD9   , 0      ,  '9'   },\n"
               "    { 0            , 0      ,  '\\0'  }\n"
               "};\n\n");

  fprintf(pOut,"static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {\n");

  for (idxSt = 3; idxSt <= nState; idxSt++) {
    if ((dwEmptyTables & (1 << idxSt)) == 0) {
      fprintf(pOut,
              "    {  (PVK_TO_WCHARS1)aVkToWch%d, %d, sizeof(aVkToWch%d[0]) },\n",
              idxSt, idxSt, idxSt);
    }
  }
  fprintf(pOut,"    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },\n"
               "    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },\n"
               "    {                       NULL, 0, 0                    },\n"
               "};\n\n");

  fprintf(pOut,"/***************************************************************************\\\n"
               "* aKeyNames[], aKeyNamesExt[]  - Virtual Scancode to Key Name tables\n"
               "*\n"
               "* Table attributes: Ordered Scan (by scancode), null-terminated\n"
               "*\n"
               "* Only the names of Extended, NumPad, Dead and Non-Printable keys are here.\n"
               "* (Keys producing printable characters are named by that character)\n"
               "\\***************************************************************************/\n\n");

  if (pKeyName != NULL) {
    fprintf(pOut,"static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {\n");
    PrintNameTable(pOut, pKeyName, FALSE);
    fprintf(pOut,"};\n\n");
  }

  if (pKeyNameExt != NULL) {
    fprintf(pOut,"static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {\n");
    PrintNameTable(pOut, pKeyNameExt, FALSE);
    fprintf(pOut,"};\n\n");
  }

  if (pKeyNameDead != NULL) {
    if (pDeadKey == NULL) {
      fprintf(pOut,"/*** No dead key defined, dead key names ignored ! ***\\\n\n");
    }

    fprintf(pOut,"static ALLOC_SECTION_LDATA DEADKEY_LPWSTR aKeyNamesDead[] = {\n");
    PrintNameTable(pOut, pKeyNameDead, TRUE);
    fprintf(pOut,"};\n\n");

    if(pDeadKey == NULL) {
      fprintf(pOut,"\\*****************************************************/\n\n");
    }
  }

  if (pDeadKey != NULL) {
    PDEADKEY pDeadKeyTmp = pDeadKey;
    fprintf(pOut,"static ALLOC_SECTION_LDATA DEADKEY aDeadKey[] = {\n");
    while (pDeadKeyTmp != NULL) {
      PDEADKEY pDeadKeyOld;
      pDeadTrans = pDeadKeyTmp->pDeadTrans;
      while (pDeadTrans != NULL) {
        PDEADTRANS pDeadTransOld;
        fprintf(pOut,"    DEADTRANS( ");
        if (strlen(WChName(pDeadTrans->Base, 0)) == 3) {
          fprintf(pOut,"L%-6s, ", WChName(pDeadTrans->Base, 0));
        } else {
          fprintf(pOut,"%-7s, ", WChName(pDeadTrans->Base, 0));
        }

        if (strlen(WChName(pDeadKeyTmp->Dead, 0)) == 3) {
          fprintf(pOut,"L%-6s, ", WChName(pDeadKeyTmp->Dead, 0));
        } else {
          fprintf(pOut,"%-7s, ", WChName(pDeadKeyTmp->Dead, 0));
        }

        if (strlen(WChName(pDeadTrans->WChar, 0)) == 3) {
          fprintf(pOut,"L%-6s, ", WChName(pDeadTrans->WChar, 0));
        } else {
          fprintf(pOut,"%-7s, ", WChName(pDeadTrans->WChar, 0));
        }
        fprintf(pOut,"0x%04x),\n", pDeadTrans->uFlags);

        pDeadTransOld = pDeadTrans;
        pDeadTrans = pDeadTrans->pNext;
        free(pDeadTransOld);
      }
      fprintf(pOut,"\n");

      pDeadKeyOld = pDeadKeyTmp;
      pDeadKeyTmp = pDeadKeyTmp->pNext;
      free(pDeadKeyOld);
    }

    fprintf(pOut,"    0, 0\n");
    fprintf(pOut,"};\n\n");
  }

  if (pLigature != NULL) {
    PLIGATURE pLigatureTmp = pLigature;
    fprintf(pOut,"static ALLOC_SECTION_LDATA LIGATURE%d aLigature[] = {\n", gMaxLigature);
    while (pLigatureTmp != NULL) {
      PLIGATURE pLigatureOld;

      fprintf(pOut,"  {%-13s,%-7d", \
              getVKName(pLigatureTmp->VKey, 1), pLigatureTmp->Mod);

      for (k = 0; k < gMaxLigature; k++) {
         if (k < pLigatureTmp->nCharacters) {
            fprintf(pOut,",%-9s", WChName(pLigatureTmp->WCh[k], 0));
         } else {
            fprintf(pOut,",WCH_NONE ");
         }
      }
      fprintf(pOut,"},\n");

      pLigatureOld = pLigatureTmp;
      pLigatureTmp = pLigatureTmp->pNext;
      free(pLigatureOld);
    }
    fprintf(pOut,"  {%-13d,%-7d", 0, 0);
    for (k = 0; k < gMaxLigature; k++) {
       fprintf(pOut,",%-9d", 0);
    }
    fprintf(pOut,"}\n};\n\n");
  }

  if (!fallback_driver) {
    fprintf(pOut, "static ");
  }
  fprintf(pOut,"ALLOC_SECTION_LDATA KBDTABLES KbdTables%s = {\n"
               "    /*\n"
               "     * Modifier keys\n"
               "     */\n"
               "    &CharModifiers,\n\n"
               "    /*\n"
               "     * Characters tables\n"
               "     */\n"
               "    aVkToWcharTable,\n\n"
               "    /*\n"
               "     * Diacritics\n"
               "     */\n",
               fallback_driver ? "Fallback" : "");

  if (pDeadKey != NULL) {
    fprintf(pOut,"    aDeadKey,\n\n");
  } else {
    fprintf(pOut,"    NULL,\n\n");
  }

  fprintf(pOut,"    /*\n"
               "     * Names of Keys\n"
               "     */\n");

  if (pKeyName != NULL) {
    fprintf(pOut,"    aKeyNames,\n");
  } else {
    fprintf(pOut,"    NULL,\n");
  }

  if (pKeyNameExt != NULL) {
    fprintf(pOut,"    aKeyNamesExt,\n");
  } else {
    fprintf(pOut,"    NULL,\n");
  }

  if (pDeadKey != NULL && pKeyNameDead != NULL) {
    fprintf(pOut,"    aKeyNamesDead,\n\n");
  } else {
    fprintf(pOut,"    NULL,\n\n");
  }

  fprintf(pOut,"    /*\n"
               "     * Scan codes to Virtual Keys\n"
               "     */\n"
               "    ausVK,\n"
               "    sizeof(ausVK) / sizeof(ausVK[0]),\n"
               "    aE0VscToVk,\n"
               "    aE1VscToVk,\n\n"
               "    /*\n"
               "     * Locale-specific special processing\n"
               "     */\n");


  if (MaxSt > 5) {
      if (szAttrs[0] != '\0') {
          strcat(szAttrs, " | ");
      }
      strcat(szAttrs, "KLLF_ALTGR");
  } else if (szAttrs[0] == '\0') {
      strcpy(szAttrs, "0");
  }

  fprintf(pOut,"    MAKELONG(%s, KBD_VERSION),\n\n", szAttrs);

  fprintf(pOut,"    /*\n"
               "     * Ligatures\n"
               "     */\n"
               "    %d,\n", gMaxLigature);
  if (pLigature != NULL) {
    fprintf(pOut,"    sizeof(aLigature[0]),\n");
    fprintf(pOut,"    (PLIGATURE1)aLigature\n");
  } else {
    fprintf(pOut,"    0,\n");
    fprintf(pOut,"    NULL\n");
  }

  fprintf(pOut, "};\n\n");
  if (!fallback_driver) {
      fprintf(pOut,"PKBDTABLES KbdLayerDescriptor(VOID)\n"
                   "{\n"
                   "    return &KbdTables;\n"
                   "}\n");

  }
  fclose(pOut);

  return SUCCESS;
}

/*****************************************************************************\
* read next (content-containing) line from input file
* Consumes lines the are empty, or contain just comments.
*
*  Buf        - contains the new line.
*               (A nul character is inserted before any comment portion)
*  cchBuf     - provides number of characters in Buf
*  gLineCount - Incremented for each line read (including skipped lines)
*
*  Returns TRUE  - if new line is returned in Buf
*          FALSE - if end of file was reached
\*****************************************************************************/

BOOL NextLine(char *Buf, DWORD cchBuf, FILE *fIn)
{
  char *p;
  char *pComment;

  while (fgets(Buf, cchBuf, fIn) != NULL) {
    gLineCount++;
    p = Buf;

    // skip leading white spaces
    while( *p && (*p == ' ' || *p == '\t')) {
        p++;
    }

    if (*p == ';') {
       // This line is purely comment, so skip it
       continue;
    }

    if ((pComment = strstr(p, "//")) != NULL) {
       if (pComment == p) {
          // This line is purely comment, so skip it
          continue;
       }

       // separate comment portion from content-containing portion
       *pComment = '\0';

    } else {

       // remove newline at the end
       if ((p = strchr(p, '\n')) != NULL) {
           *p = '\0';
       }
    }

    // We are returning a content-containing line
    return TRUE;
  }

  // we reached the end of the file
  return FALSE;
}

VOID __cdecl Error(const char *Text, ... )
{
    char Temp[1024];
    va_list valist;

    va_start(valist, Text);
    vsprintf(Temp,Text,valist);
    printf("\n%s(%d): error : %s\n", gpszFileName, gLineCount, Temp);
    va_end(valist);

    exit(EXIT_FAILURE);
}

ULONG __cdecl Warning(int nLine, const char *Text, ... )
{
    char Temp[1024];
    va_list valist;

    if (nLine == 0) {
        nLine = gLineCount;
    }
    va_start(valist, Text);
    vsprintf(Temp,Text,valist);
    printf("%s(%d): warning : %s\n", gpszFileName, nLine, Temp);
    va_end(valist);

    return 0;
}

VOID DumpLayoutEntry(PKEYLAYOUT pLayout)
{
      printf("Scan %2x, VK %2x, VKDef %2x, Cap %d, nState %d, defined %x\n",
             pLayout->Scan,
             pLayout->VKey,
             pLayout->VKeyDefault,
             pLayout->Cap,
             pLayout->nState,
             pLayout->defined
             );
      printf("WCh[] = %x, %x, %x, %x, %x, %x, %x, %x, %x\n",
             pLayout->WCh[0], pLayout->WCh[1],
             pLayout->WCh[2], pLayout->WCh[3],
             pLayout->WCh[4], pLayout->WCh[5],
             pLayout->WCh[6], pLayout->WCh[7],
             pLayout->WCh[8]);
      printf("DKy[] = %x, %x, %x, %x, %x, %x, %x, %x, %x\n",
             pLayout->DKy[0], pLayout->DKy[1],
             pLayout->DKy[2], pLayout->DKy[3],
             pLayout->DKy[4], pLayout->DKy[5],
             pLayout->DKy[6], pLayout->DKy[7],
             pLayout->DKy[8]);
      printf("LKy[] = %x, %x, %x, %x, %x, %x, %x, %x, %x\n",
             pLayout->LKy[0], pLayout->LKy[1],
             pLayout->LKy[2], pLayout->LKy[3],
             pLayout->LKy[4], pLayout->LKy[5],
             pLayout->LKy[6], pLayout->LKy[7],
             pLayout->LKy[8]);
      printf("pSGCAP = %p\n", pLayout->pSGCAP);
      printf("VKeyName = %s\n", pLayout->VKeyName);
}


/*
 * Helper routine to make sure Backspace, Enter, Esc, Space and Cancel
 * have the right characters.
 * If they aren't defined by the input file, this is where we set their
 * default values.
 */
BOOL MergeState(
    KEYLAYOUT Layout[],
    int Vk,
    WCHAR wchUnshifted,
    WCHAR wchShifted,
    WCHAR wchCtrl,
    int aiState[],
    int nState)
{
    static int idxCtrl = -1;
    int idxSt, idx;
    PKEYLAYOUT pLayout = NULL;

    // which state is Ctrl?
    if (idxCtrl == -1) {
        for (idxSt = 0; idxSt < nState; idxSt++) {
            if (aiState[idxSt] == KBDCTRL) {
                idxCtrl = idxSt;
                break;
            }
        }
    }
    if (idxCtrl == -1) {
        Error("No Ctrl state");
    }

    // find the VK we want to merge
    for (idx = 0; idx < NUMSCVK; idx++) {
        if (Layout[idx].VKey == Vk) {
            pLayout = &Layout[idx];
            break;
        }
    }
    if (pLayout == NULL) {
        Error("No VK %2x state", Vk);
    }

    /*
     * Now merge the default values in
     */

    // printf("BEFORE ====================\n");
    // DumpLayoutEntry(pLayout);

    if (pLayout->WCh[0] == 0) {
        pLayout->WCh[0] = wchUnshifted;
    }
    if (pLayout->WCh[1] == 0) {
        pLayout->WCh[1] = wchShifted;
    }
    if (pLayout->WCh[idxCtrl] == 0) {
        pLayout->WCh[idxCtrl] = wchCtrl;
    }

    // pad empty slots with WCH_NONE
    for (idxSt = pLayout->nState; idxSt < idxCtrl; idxSt++) {
        if (pLayout->WCh[idxSt] == 0) {
            pLayout->WCh[idxSt] = -1; // WCH_NONE
        }
    }
    if (pLayout->nState <= idxCtrl) {
        pLayout->nState = idxCtrl + 1;
    }

    pLayout->defined = TRUE;

    // printf("AFTER ===================\n");
    // DumpLayoutEntry(pLayout);
    // printf("=========================\n\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kbdtool\kbdx.h ===
/****************************** Module Header ******************************\
* Module Name: kbdx.h
*
* Copyright (c) 1985-95, Microsoft Corporation
*
* History:
* 26-Mar-1995 a-KChang
\***************************************************************************/

#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <time.h>
#include <windef.h>

#define KBDSHIFT 1
#define KBDCTRL  2
#define KBDALT   4

#define CAPLOK      0x01
#define SGCAPS      0x02
#define CAPLOKALTGR 0x04

#define LINEBUFSIZE  256
#define WORDBUFSIZE   32
#define MAXWCLENGTH    8
#define MAXKBDNAME     6
#define MAXSTATES     65
#define FILENAMESIZE  13
#define FAILURE        0
#define SUCCESS        1

/*
 * max. number of characters per ligature.
 * Currently only the Arabic layouts use
 * ligatures, and they have a maximum of
 * two characters per ligatures.  This should
 * provide plenty of room for growth.
 */
#define MAXLIGATURES   5

/*
 * Statically initialized to store default ScanCode-VK relation
 * Copied into Layout[] by doLAYOUT()
 */
typedef struct {
  USHORT Scan;
  BYTE   VKey;
  char  *VKeyName;
  BOOL   bUsed;
} SC_VK;

/* virtual key name, used only by those other than 0-9 and A-Z */
typedef struct {
  int   VKey;
  char *pName;
} VKEYNAME;

/* store LAYOUT */
typedef struct _layout{
  USHORT          Scan;
  BYTE            VKey;
  BYTE            VKeyDefault;    /* VK for this Scancode as in kbd.h */
  BYTE            Cap;            /* 0; 1 = CAPLOK; 2 = SGCAP         */
  int             nState;         /* number of valid states for WCh[] */
  int             WCh[MAXSTATES];
  int             DKy[MAXSTATES]; /* is it a dead key ?               */
  int             LKy[MAXSTATES]; /* is it a ligature ?               */
  struct _layout *pSGCAP;         /* store extra struct for SGCAP     */
  char *          VKeyName;       /* Optional name for VK             */
  BOOL            defined;        /* prevent redefining               */
  int             nLine;          /* from input file line number      */
} KEYLAYOUT, *PKEYLAYOUT;

/* generic link list header */
typedef struct {
  int   Count;
  void *pBeg;
  void *pEnd;
} LISTHEAD;

/* store each DEADTRANS */
typedef struct _DeadTrans {
  DWORD               Base;
  DWORD               WChar;
  USHORT              uFlags;
  struct _DeadTrans *pNext;
} DEADTRANS, *PDEADTRANS;

/* store Key Name */
/* store each DEADKEY */
typedef struct _Dead{
  DWORD        Dead;
  PDEADTRANS   pDeadTrans;
  struct _Dead *pNext;
} DEADKEY, *PDEADKEY;

/* store LIGATURE */
typedef struct _ligature{
  struct _ligature *pNext;
  BYTE             VKey;
  BYTE             Mod;            /* Shift State                            */
  int              nCharacters;    /* number of characters for this ligature */
  int              WCh[MAXLIGATURES];
} LIGATURE, *PLIGATURE;

typedef struct _Name {
  DWORD          Code;
  char         *pName;
  struct _Name *pNext;
} KEYNAME, *PKEYNAME;


extern int getopt(int argc, char **argv, char *opts);
extern int optind;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kerntwk\dialogs.h ===
#define DPC_MAX_QUEUE_DEPTH         103
#define DPC_MIN_RATE                105
#define DPC_BEHAVIOR_DLG            100
#define IDI_KERNTWEAK               3000
#define DPC_UPDATE_REGISTRY         107
#define MM_DLG                      300
#define MM_PAGED_QUOTA              301
#define MM_NONPAGED_QUOTA           302
#define MM_PAGING_FILE_QUOTA        303
#define MM_PAGED_SIZE               304
#define MM_IO_PAGE_LOCK_LIMIT       308
#define MM_SYSTEM_PAGES             312
#define MM_LARGE_CACHE              314
#define MM_NONPAGED_SIZE            315
#define DPC_ADJUST_THRESHOLD        108
#define MM_L2_CACHE_SIZE            316
#define DPC_IDEAL_RATE              112
#define GLOBAL_FLAG_DLG             400
#define GLOBAL_FLAG_UPDATE_REGISTRY 401
#define GLOBAL_FLAG_ID              201
#define DLG_REBOOT                  2000
#define ID_FAST_REBOOT              2002
#define ID_SLOW_REBOOT              2003
#define ID_NO_REBOOT                2004
#define FS_NTFS_DISABLE_SHORTNAME   501
#define FS_FAT_WIN_31               502
#define FILESYSTEM_DLG              500
#define FS_WIN95_EXTENSIONS         503
#define WINSOCK_DLG                 200
#define WS_PRIORITY_BOOST           202
#define WS_LARGE_BUFFER_SIZE        204
#define WS_LARGE_BUFFER_COUNT       206
#define WS_MEDIUM_BUFFER_SIZE       208
#define WS_MEDIUM_BUFFER_COUNT      210
#define WS_SMALL_BUFFER_SIZE        212
#define WS_IRP_STACK_SIZE           214
#define WS_SMALL_BUFFER_COUNT       215
#define WS_FAST_SEND_DGRAM_THRESHOLD 217
#define WS_STANDARD_ADDRESS_LENGTH  219
#define WS_RECEIVE_WINDOW           221
#define WS_SEND_WINDOW              223
#define WS_BUFFER_MULTIPLIER        225
#define WS_TRANSMIT_IO_LENGTH       227
#define FS_CRITICAL_WORKERS         504
#define FS_DELAYED_WORKERS          505
#define TCPIP_DLG                   600
#define TCP_KEEP_ALIVE              601
#define TCP_KEEP_ALIVE_INTERVAL     602
#define TCP_KEEP_ALIVE_TIME         603
#define TCP_RFC1122                 604
#define TCP_WINDOW_SIZE             607
#define TCP_DEAD_GATEWAY            609
#define TCP_PMTU_DISCOVERY          610
#define TCP_DEFAULT_TTL             611
#define TCP_CONNECT_RETRANSMITS     612
#define TCP_DATA_RETRANSMITS        615
#define TCP_ARP_SOURCE_ROUTE        617
#define TCP_ARP_ETHER_SNAP          618
#define TCP_PMTUBH_DISCOVERY        619
#define TCP_FORWARD_MEMORY          620
#define TCP_IGMP_LEVEL              622
#define TCP_FORWARD_PACKETS         624
#define TCP_MAX_CONNECTIONS         626
#define TCP_DEFAULT_TOS             628
#define TCP_PMTUBH_DETECT           630
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kerntwk\makefile.inc ===
KernTwk.rc: dialogs.dlg

kerntwk.c: sockpage.h tcppage.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kerntwk\kerntwk.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kerntwk.c

Abstract:

    Kernel Tweaker program for setting various kernel parameters

Author:

    John Vert (jvert) 20-Feb-1995

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>
#include <commctrl.h>
#include "dialogs.h"
#include "stdio.h"
#include "twkeng.h"

//
// Local function prototypes
//
BOOL
SaveToRegistry(
    VOID
    );

VOID
UpdateFromRegistry(
    VOID
    );

BOOL
ApplyDpcChanges(
    BOOL fInit,
    HWND hDlg
    );

BOOL
ApplyGlobalFlagChanges(
    BOOL fInit,
    HWND hDlg
    );

//
// Knobs
//
KNOB MaximumDpcQueueDepth =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Kernel"),
    TEXT("MaximumDpcQueueDepth"),
    DPC_MAX_QUEUE_DEPTH,
    0,
    4,
    0
};

KNOB MinimumDpcRate =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Kernel"),
    TEXT("MinimumDpcRate"),
    DPC_MIN_RATE,
    0,
    3,
    0
};

KNOB AdjustDpcThreshold =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Kernel"),
    TEXT("AdjustDpcThreshold"),
    DPC_ADJUST_THRESHOLD,
    0,
    50,
    0
};

KNOB IdealDpcRate =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Kernel"),
    TEXT("IdealDpcRate"),
    DPC_IDEAL_RATE,
    0,
    50,
    0
};

KNOB DpcUpdateRegistry =
{
    NULL,
    NULL,
    NULL,
    DPC_UPDATE_REGISTRY,
    0,
    0,
    0
};

KNOB GlobalFlagUpdateRegistry =
{
    NULL,
    NULL,
    NULL,
    GLOBAL_FLAG_UPDATE_REGISTRY,
    0,
    0,
    0
};

KNOB PagedPoolQuota =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("PagedPoolQuota"),
    MM_PAGED_QUOTA,
    0,
    0,
    0
};

KNOB NonPagedPoolQuota =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("NonPagedPoolQuota"),
    MM_NONPAGED_QUOTA,
    0,
    0,
    0
};

KNOB PagingFileQuota =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("PagingFileQuota"),
    MM_PAGING_FILE_QUOTA,
    0,
    0,
    0
};

KNOB PagedPoolSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("PagedPoolSize"),
    MM_PAGED_SIZE,
    0,
    0,
    0
};

KNOB NonPagedPoolSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("NonPagedPoolSize"),
    MM_NONPAGED_SIZE,
    0,
    0,
    0
};

KNOB SystemPages =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("SystemPages"),
    MM_SYSTEM_PAGES,
    0,
    0,
    0
};

KNOB SecondLevelDataCache =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("SecondLevelDataCache"),
    MM_L2_CACHE_SIZE,
    0,
    0,
    0
};

KNOB LargeSystemCache =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"),
    TEXT("LargeSystemCache"),
    MM_LARGE_CACHE,
    0,
    0,
    0
};

KNOB NtfsDisable8dot3 =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\FileSystem"),
    TEXT("NtfsDisable8dot3NameCreation"),
    FS_NTFS_DISABLE_SHORTNAME,
    0,
    0,
    0
};

KNOB FatWin31Compatible =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\FileSystem"),
    TEXT("Win31FileSystem"),
    FS_FAT_WIN_31,
    0,
    0,
    0
};

KNOB Win95Extensions =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\FileSystem"),
    TEXT("Win95TruncatedExtensions"),
    FS_WIN95_EXTENSIONS,
    0,
    0,
    0
};

KNOB AdditionalCriticalWorkerThreads =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Executive"),
    TEXT("AdditionalCriticalWorkerThreads"),
    FS_CRITICAL_WORKERS,
    0,
    0,
    0
};

KNOB AdditionalDelayedWorkerThreads =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Executive"),
    TEXT("AdditionalDelayedWorkerThreads"),
    FS_DELAYED_WORKERS,
    0,
    0,
    0
};

#include "sockpage.h"
#include "tcppage.h"

//
// Pages
//

TWEAK_PAGE DpcPage =
{
    MAKEINTRESOURCE(DPC_BEHAVIOR_DLG),
    ApplyDpcChanges,
    {
        &MaximumDpcQueueDepth,
        &MinimumDpcRate,
        &AdjustDpcThreshold,
        &IdealDpcRate,
        &DpcUpdateRegistry,
        NULL
    }
};

TWEAK_PAGE MmPage =
{
    MAKEINTRESOURCE(MM_DLG),
    NULL,
    {
        &PagedPoolQuota,
        &NonPagedPoolQuota,
        &PagingFileQuota,
        &PagedPoolSize,
        &NonPagedPoolSize,
        &SystemPages,
        &SecondLevelDataCache,
        &LargeSystemCache,
        NULL
    }
};

TWEAK_PAGE GlobalFlagPage =
{
    MAKEINTRESOURCE(GLOBAL_FLAG_DLG),
    ApplyGlobalFlagChanges,
    {
        &GlobalFlagUpdateRegistry,
        NULL
    }
};

TWEAK_PAGE FilesystemPage =
{
    MAKEINTRESOURCE(FILESYSTEM_DLG),
    NULL,
    {
        &NtfsDisable8dot3,
        &FatWin31Compatible,
        &AdditionalCriticalWorkerThreads,
        &AdditionalDelayedWorkerThreads,
        NULL
    }
};


int
WINAPI
WinMain(
    HINSTANCE  hInstance,       // handle of current instance
    HINSTANCE  hPrevInstance,   // handle of previous instance
    LPSTR  lpszCmdLine, // address of command line
    int  nCmdShow       // show state of window
   )
{
    PTWEAK_PAGE TweakPages[] =  {
                                    &DpcPage,
                                    &MmPage,
                                    &GlobalFlagPage,
                                    &FilesystemPage,
                                    &WinsockPage,
                                    &TcpPage
                                };

    return(TweakSheet(sizeof(TweakPages)/sizeof(PTWEAK_PAGE),TweakPages));
}

BOOL
ApplyDpcChanges(
    BOOL fInit,
    HWND hDlg
    )
{
    SYSTEM_DPC_BEHAVIOR_INFORMATION DpcBehavior;
    BOOLEAN Enabled;
    NTSTATUS Status;

    if (fInit) {
        Status = NtQuerySystemInformation(SystemDpcBehaviorInformation,
                                          &DpcBehavior,
                                          sizeof(DpcBehavior),
                                          NULL);
        if (!NT_SUCCESS(Status)) {
            CHAR Buffer[128];

            sprintf(Buffer,
                    "NtQuerySystemInformation failed (%08lx)\n"
                    "You probably need a newer build.\n"
                    "Use information from the registry?",
                    Status);
            if (MessageBox(NULL,Buffer,TEXT("Horrible Disaster"),MB_YESNO) == IDYES) {
                return(FALSE);
            } else {
                ExitProcess(0);
            }
        } else {
            MaximumDpcQueueDepth.CurrentValue = DpcBehavior.DpcQueueDepth;
            MinimumDpcRate.CurrentValue = DpcBehavior.MinimumDpcRate;
            AdjustDpcThreshold.CurrentValue = DpcBehavior.AdjustDpcThreshold;
            IdealDpcRate.CurrentValue = DpcBehavior.IdealDpcRate;
        }
    } else {
        DpcBehavior.DpcQueueDepth = MaximumDpcQueueDepth.NewValue;
        DpcBehavior.MinimumDpcRate = MinimumDpcRate.NewValue;
        DpcBehavior.AdjustDpcThreshold = AdjustDpcThreshold.NewValue;
        DpcBehavior.IdealDpcRate = IdealDpcRate.NewValue;

        //
        // Attempt to enable the load driver privilege to
        // allow setting the DPC behavior.
        //
        RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE,
                           TRUE,
                           FALSE,
                           &Enabled);

        Status = NtSetSystemInformation(SystemDpcBehaviorInformation,
                                        &DpcBehavior,
                                        sizeof(DpcBehavior));

        RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE,
                           Enabled,
                           FALSE,
                           &Enabled);

        if (!NT_SUCCESS(Status)) {
            CHAR Buffer[128];

            sprintf(Buffer,
                    "NtSetSystemInformation failed, status %08lx",
                    Status);
            MessageBox(NULL,Buffer,TEXT("Oops"),MB_OK);
            return(FALSE);
        }
        if (DpcUpdateRegistry.NewValue) {
            //
            // Let the common routine update the values in the registry
            //
            return(FALSE);
        }
    }

    return(TRUE);
}

BOOL
ApplyGlobalFlagChanges(
    BOOL fInit,
    HWND hDlg
    )
{
    BOOLEAN Enabled;
    NTSTATUS Status;
    SYSTEM_FLAGS_INFORMATION SystemInformation;
    int iBit;

    if (fInit) {
        Status = NtQuerySystemInformation(SystemFlagsInformation,
                                          &SystemInformation,
                                          sizeof(SystemInformation),
                                          NULL);
        if (!NT_SUCCESS(Status)) {
            CHAR Buffer[128];

            sprintf(Buffer,
                    "NtQuerySystemInformation failed (%08lx)\n",
                    Status);
            MessageBox(NULL,Buffer,TEXT("Horrible Disaster"),MB_OK);
            ExitProcess(0);
        } else {
            for (iBit = 0; iBit < 32; iBit++) {
                CheckDlgButton(hDlg,
                               GLOBAL_FLAG_ID + iBit,
                               (SystemInformation.Flags & (1 << iBit)));
            }
        }
    } else {
        SystemInformation.Flags = 0;
        for (iBit = 0; iBit < 32; iBit++) {
            if (IsDlgButtonChecked(hDlg, GLOBAL_FLAG_ID + iBit)) {
                SystemInformation.Flags |= (1 << iBit);
            }
        }
        //
        // Attempt to enable the load driver privilege to
        // allow setting the DPC behavior.
        //
        RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                           TRUE,
                           FALSE,
                           &Enabled);
        Status = NtSetSystemInformation(SystemFlagsInformation,
                                        &SystemInformation,
                                        sizeof(SystemInformation));

        RtlAdjustPrivilege(SE_DEBUG_PRIVILEGE,
                           Enabled,
                           FALSE,
                           &Enabled);

        if (!NT_SUCCESS(Status)) {
            CHAR Buffer[128];

            sprintf(Buffer,
                    "SetSystemInformationFailed (%08lx)\nYou probably do not have debug privileges",
                    Status);
            MessageBox(NULL,Buffer,TEXT("Oops"),MB_OK);
        }
        if (GlobalFlagUpdateRegistry.NewValue) {
            HKEY Key;
            LONG Result;
            DWORD Disposition;

            //
            // Update the Value in the registry
            //
            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                               TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager"),
                               0L,
                               NULL,
                               0L,
                               KEY_SET_VALUE,
                               NULL,
                               &Key,
                               &Disposition) != ERROR_SUCCESS) {
                CHAR Buffer[128];

                sprintf(Buffer,
                        "RegCreateKey for NtGlobalFlag failed (%d)\nYou probably are Not Authorized.",
                        GetLastError());
                MessageBox(NULL,Buffer,TEXT("Oops"),MB_OK);
                return(TRUE);
            }

            RegSetValueEx(Key,
                          "GlobalFlag",
                          0,
                          REG_DWORD,
                          (LPBYTE)&SystemInformation.Flags,
                          sizeof(SystemInformation.Flags));

            SendMessage(GetParent(hDlg),
                        PSM_REBOOTSYSTEM,
                        0,
                        0);
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kerntwk\sockpage.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    flagpage.h

Abstract:

    Knob and page definitions for the winsock page

Author:

    John Vert (jvert) 24-Apr-1995

Revision History:

--*/

KNOB WinsockBufferMultiplier =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("BufferMultiplier"),
    WS_BUFFER_MULTIPLIER,
    0,
    0,
    0
};

KNOB WinsockFastSendDgramThreshold =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("FastSendDatagramThreshold"),
    WS_FAST_SEND_DGRAM_THRESHOLD,
    0,
    0,
    0
};

KNOB WinsockIrpStackSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("IrpStackSize"),
    WS_IRP_STACK_SIZE,
    0,
    0,
    0
};

KNOB WinsockLargeBuffers =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("InitialLargeBufferCount"),
    WS_LARGE_BUFFER_COUNT,
    0,
    0,
    0
};

KNOB WinsockLargeBufferSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("LargeBufferSize"),
    WS_LARGE_BUFFER_SIZE,
    0,
    0,
    0
};

KNOB WinsockMediumBuffers =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("InitialMediumBufferCount"),
    WS_MEDIUM_BUFFER_COUNT,
    0,
    0,
    0
};

KNOB WinsockMediumBufferSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("MediumBufferSize"),
    WS_MEDIUM_BUFFER_SIZE,
    0,
    0,
    0
};

KNOB WinsockPriorityBoost =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("PriorityBoost"),
    WS_PRIORITY_BOOST,
    0,
    0,
    0
};

KNOB WinsockReceiveWindow =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("DefaultReceiveWindow"),
    WS_RECEIVE_WINDOW,
    0,
    0,
    0
};

KNOB WinsockSendWindow =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("DefaultSendWindow"),
    WS_SEND_WINDOW,
    0,
    0,
    0
};

KNOB WinsockSmallBuffers =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("InitialSmallBufferCount"),
    WS_SMALL_BUFFER_COUNT,
    0,
    0,
    0
};

KNOB WinsockSmallBufferSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("SmallBufferSize"),
    WS_SMALL_BUFFER_SIZE,
    0,
    0,
    0
};


KNOB WinsockAddressLength =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("StandardAddressLength"),
    WS_STANDARD_ADDRESS_LENGTH,
    0,
    0,
    0
};

KNOB WinsockTransmitIoLength =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Afd\\Parameters"),
    TEXT("TransmitIoLength"),
    WS_TRANSMIT_IO_LENGTH,
    0,
    0,
    0
};

TWEAK_PAGE WinsockPage =
{
    MAKEINTRESOURCE(WINSOCK_DLG),
    NULL,
    {
        &WinsockBufferMultiplier,
        &WinsockFastSendDgramThreshold,
        &WinsockIrpStackSize,
        &WinsockLargeBuffers,
        &WinsockLargeBufferSize,
        &WinsockMediumBuffers,
        &WinsockMediumBufferSize,
        &WinsockPriorityBoost,
        &WinsockReceiveWindow,
        &WinsockSendWindow,
        &WinsockSmallBuffers,
        &WinsockSmallBufferSize,
        &WinsockAddressLength,
        &WinsockTransmitIoLength,
        NULL
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kverify\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kerntwk\tcppage.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    flagpage.h

Abstract:

    Knob and page definitions for the TCP/IP page

Author:

    John Vert (jvert) 24-Apr-1995

Revision History:

--*/

KNOB TcpKeepAliveInterval =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("KeepAliveInterval"),
    TCP_KEEP_ALIVE_INTERVAL,
    0,
    0,
    0
};

KNOB TcpKeepAliveTime =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("KeepAliveTime"),
    TCP_KEEP_ALIVE_TIME,
    0,
    0,
    0
};

KNOB TcpRFC1122 =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpUseRFC1122UrgentPointer"),
    TCP_RFC1122,
    0,
    0,
    0
};

KNOB TcpWindowSize =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpWindowSize"),
    TCP_WINDOW_SIZE,
    0,
    0,
    0
};

KNOB TcpDeadGateway =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("EnableDeadGWDetect"),
    TCP_DEAD_GATEWAY,
    0,
    0,
    0
};


KNOB TcpPMTUDiscovery =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("EnablePMTUDiscovery"),
    TCP_PMTU_DISCOVERY,
    0,
    0,
    0
};

KNOB TcpDefaultTTL =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("DefaultTTL"),
    TCP_DEFAULT_TTL,
    0,
    0,
    0
};

KNOB TcpConnectRetransmits =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpMaxConnectRetransmissions"),
    TCP_CONNECT_RETRANSMITS,
    0,
    0,
    0
};


KNOB TcpDataRetransmits =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpMaxDataRetransmissions"),
    TCP_DATA_RETRANSMITS,
    0,
    0,
    0
};

KNOB TcpIGMPLevel =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("IGMPLevel"),
    TCP_IGMP_LEVEL,
    0,
    0,
    0
};

KNOB TcpMaxConnections =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("TcpNumConnections"),
    TCP_MAX_CONNECTIONS,
    0,
    0,
    0
};

KNOB TcpArpSourceRoute =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("ArpAlwaysSourceRoute"),
    TCP_ARP_SOURCE_ROUTE,
    0,
    0,
    0
};

KNOB TcpArpEtherSNAP =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("ArpUseEtherSNAP"),
    TCP_ARP_ETHER_SNAP,
    0,
    0,
    0
};

KNOB TcpPMTUBHDetect =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("EnablePMTUBHDetect"),
    TCP_PMTUBH_DETECT,
    0,
    0,
    0
};

KNOB TcpForwardMemory =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("ForwardBufferMemory"),
    TCP_FORWARD_MEMORY,
    0,
    0,
    0
};

KNOB TcpForwardPackets =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("NumForwardPackets"),
    TCP_FORWARD_PACKETS,
    0,
    0,
    0
};

KNOB TcpDefaultTOS =
{
    HKEY_LOCAL_MACHINE,
    TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters"),
    TEXT("DefaultTOS"),
    TCP_DEFAULT_TOS,
    0,
    0,
    0
};

TWEAK_PAGE TcpPage =
{
    MAKEINTRESOURCE(TCPIP_DLG),
    NULL,
    {
        &TcpKeepAliveInterval,
        &TcpKeepAliveTime,
        &TcpRFC1122,
        &TcpWindowSize,
        &TcpDeadGateway,
        &TcpPMTUDiscovery,
        &TcpDefaultTTL,
        &TcpConnectRetransmits,
        &TcpDataRetransmits,
        &TcpIGMPLevel,
        &TcpMaxConnections,
        &TcpArpSourceRoute,
        &TcpArpEtherSNAP,
        &TcpPMTUBHDetect,
        &TcpForwardMemory,
        &TcpForwardPackets,
        &TcpDefaultTOS,
        NULL
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kerntwk\twkeng.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    twkeng.c

Abstract:

    UI engine for the kerntwk utility. Provides common
    registry/UI handling code to make it simple to add
    new property pages and items.

Author:

    John Vert (jvert) 10-Mar-1995

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>
#include <commctrl.h>
#include "dialogs.h"
#include "twkeng.h"

//
// Local type definitions
//

typedef enum _CONTROL_TYPE {
    Edit,
    Button,
    Unknown
} CONTROL_TYPE;



//
// Globals to this module
//

PTWEAK_PAGE CurrentPage=NULL;

//
// Prototypes for local functions
//
CONTROL_TYPE
GetControlType(
    HWND hDlg,
    ULONG ControlId
    );

VOID
InitializeKnobs(
    HWND hDlg
    );

PKNOB
FindKnobById(
    HWND hPage,
    ULONG DialogId
    );

BOOL
ProcessCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
ApplyChanges(
    HWND hDlg
    );

INT_PTR
APIENTRY
RebootDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
ApplyChanges(
    HWND hDlg
    )
{
    PTWEAK_PAGE Page;
    PKNOB Current;
    int i;

    Page = (PTWEAK_PAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    //
    // Iterate through the knobs and set their values into the controls
    //
    i = 0;
    Current = Page->Knobs[0];
    while (Current != NULL) {
        HWND hControl;
        TCHAR ClassName[100];
        BOOL Translated;

        //
        // Determine whether the control is an edit
        // control or a check box
        //
        switch (GetControlType(hDlg, Current->DialogId)) {
            case Button:

                Current->NewValue = IsDlgButtonChecked(hDlg, Current->DialogId);
                Current->Flags &= ~KNOB_NO_NEW_VALUE;
                break;

            case Edit:
                Current->NewValue = GetDlgItemInt(hDlg,
                                                  Current->DialogId,
                                                  &Translated,
                                                  FALSE);
                if (!Translated) {
                    Current->Flags |= KNOB_NO_NEW_VALUE;
                } else {
                    Current->Flags &= ~KNOB_NO_NEW_VALUE;
                }
                break;
        }
        Current = Page->Knobs[++i];
    }

    //
    // If this page has a dynamic callback, allow it to try and apply
    // its own knobs.  If there is no dynamic callback, or the callback's
    // initialization fails, get the defaults from the registry. If the
    // appropriate value does not exist, set the knob to be empty.
    //
    if ((Page->DynamicChange == NULL) ||
        (Page->DynamicChange(FALSE,hDlg) == FALSE)) {
        //
        // Attempt to update registry from the knobs
        //
        i = 0;
        Current = Page->Knobs[i];
        while (Current != NULL) {
            LONG Result;
            HKEY Key;
            DWORD Size;
            DWORD Value;
            DWORD Disposition;

            if (Current->KeyPath != NULL) {
                Result = RegCreateKeyEx(Current->RegistryRoot,
                                        Current->KeyPath,
                                        0,
                                        NULL,
                                        0,
                                        MAXIMUM_ALLOWED,
                                        NULL,
                                        &Key,
                                        &Disposition);
                if (Result == ERROR_SUCCESS) {
                    if (Current->Flags & KNOB_NO_NEW_VALUE) {
                        //
                        // Try and delete the value
                        //
                        Result = RegDeleteValue(Key, Current->ValueName);
                        RegCloseKey(Key);
                        if (Result == ERROR_SUCCESS) {
                            Current->Flags |= KNOB_NO_CURRENT_VALUE;
                        }

                    } else {
                        //
                        // Set the current value
                        //
                        Result = RegSetValueEx(Key,
                                               Current->ValueName,
                                               0,
                                               REG_DWORD,
                                               (LPBYTE)&Current->NewValue,
                                               sizeof(Current->NewValue));
                        RegCloseKey(Key);
                        if (Result == ERROR_SUCCESS) {
                            Current->CurrentValue = Current->NewValue;
                            Current->Flags &= ~KNOB_NO_CURRENT_VALUE;
                        }
                    }
                }
            } else {
                Current->CurrentValue = Current->NewValue;
                Current->Flags = 0;
            }

            Current = Page->Knobs[++i];
        }
        SendMessage(GetParent(hDlg),
                    PSM_REBOOTSYSTEM,
                    0,
                    0);
    }
    return(TRUE);
}

BOOL
ProcessCommand(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PKNOB Knob;
    ULONG DialogId;
    BOOL Translated;

    DialogId = LOWORD(wParam);
    Knob = FindKnobById(hDlg, DialogId);
    switch (GetControlType(hDlg, DialogId)) {
        case Edit:
            if (HIWORD(wParam) == EN_CHANGE) {
                if (Knob != NULL) {
                    Knob->NewValue = GetDlgItemInt(hDlg, DialogId, &Translated, FALSE);
                    if ((Knob->NewValue != Knob->CurrentValue) ||
                        (Translated && (Knob->Flags & KNOB_NO_CURRENT_VALUE)) ||
                        (!Translated && ((Knob->Flags & KNOB_NO_CURRENT_VALUE) == 0))) {
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                    }
                    if (Translated) {
                        Knob->Flags &= ~KNOB_NO_NEW_VALUE;
                    }
                } else {
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);

                }
                return(TRUE);
            }
            break;

        case Button:
            if (HIWORD(wParam) == BN_CLICKED) {
                if (Knob != NULL) {
                    Knob->NewValue = IsDlgButtonChecked(hDlg, DialogId);
                    if (Knob->NewValue != Knob->CurrentValue) {
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                    }
                } else {
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                }
                return(TRUE);
            }
            break;
    }
    return(FALSE);
}


CONTROL_TYPE
GetControlType(
    HWND hDlg,
    ULONG ControlId
    )
{
    HWND hControl;
    TCHAR ClassName[100];

    hControl = GetDlgItem(hDlg, ControlId);
    if (hControl != NULL) {
        GetClassName(hControl, ClassName, 100);
        if (_stricmp(ClassName, "BUTTON")==0) {
            return(Button);
        } else if (_stricmp(ClassName, "EDIT") == 0) {
            return(Edit);
        }
    }

    return(Unknown);

}

VOID
InitializeKnobs(
    HWND hDlg
    )

{
    PTWEAK_PAGE Page;
    PKNOB Current;
    int i;

    Page = (PTWEAK_PAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    //
    // If this page has a dynamic callback, allow it to try and initialize
    // its own knobs.  If there is no dynamic callback, or the callback's
    // initialization fails, get the defaults from the registry. If the
    // appropriate value does not exist, set the knob to be empty.
    //
    if ((Page->DynamicChange == NULL) ||
        (Page->DynamicChange(TRUE,hDlg) == FALSE)) {
        //
        // Attempt to initialize knobs from the registry.
        //
        i = 0;
        Current = Page->Knobs[0];
        while (Current != NULL) {
            LONG Result;
            HKEY Key;
            DWORD Size;
            DWORD Value;

            Result = RegOpenKeyEx(Current->RegistryRoot,
                                  Current->KeyPath,
                                  0,
                                  KEY_QUERY_VALUE,
                                  &Key);
            if (Result == ERROR_SUCCESS) {
                //
                // Query out the value we are interested in
                //
                Size = 4;
                Result = RegQueryValueEx(Key,
                                         Current->ValueName,
                                         0,
                                         NULL,
                                         (LPBYTE)&Value,
                                         &Size);
                RegCloseKey(Key);
                if (Result == ERROR_SUCCESS) {
                    Current->Flags = 0;
                    Current->CurrentValue = Value;
                }
            }

            if (Result != ERROR_SUCCESS) {
                Current->Flags |= KNOB_NO_CURRENT_VALUE;
                Current->Flags |= KNOB_NO_NEW_VALUE;
            }
            Current = Page->Knobs[++i];
        }
    }

    //
    // Iterate through the knobs and set their values into the controls
    //
    i = 0;
    Current = Page->Knobs[0];
    while (Current != NULL) {
        HWND hControl;
        TCHAR ClassName[100];

        //
        // Determine whether the control is an edit
        // control or a check box
        //
        if ((Current->Flags & KNOB_NO_CURRENT_VALUE) == 0) {
            switch (GetControlType(hDlg, Current->DialogId)) {
                case Button:
                    CheckDlgButton(hDlg,
                                   Current->DialogId,
                                   Current->CurrentValue);
                    break;

                case Edit:
                    SetDlgItemInt(hDlg,
                                  Current->DialogId,
                                  Current->CurrentValue,
                                  FALSE);
                    break;
            }
        }
        Current = Page->Knobs[++i];
    }
}

PKNOB
FindKnobById(
    HWND  hPage,
    ULONG DialogId
    )
{
    PTWEAK_PAGE Page;
    PKNOB Current;
    int i;

    Page = (PTWEAK_PAGE)GetWindowLongPtr(hPage, DWLP_USER);
    i=0;
    Current = Page->Knobs[0];
    while (Current != NULL) {
        if (Current->DialogId == DialogId) {
            break;
        }
        Current = Page->Knobs[++i];
    }
    return(Current);
}

INT_PTR
APIENTRY
PageDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR Notify;
    PTWEAK_PAGE TweakPage;

    TweakPage = (PTWEAK_PAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    switch (message) {
        case WM_INITDIALOG:

            //
            // This page is being created.
            //
            TweakPage = (PTWEAK_PAGE)((LPPROPSHEETPAGE)lParam)->lParam;

            //
            // Stash a pointer to our page
            //
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)TweakPage);

            //
            // Initialize controls.
            //

            InitializeKnobs(hDlg);
            return(TRUE);

        case WM_COMMAND:

            return(ProcessCommand(hDlg, wParam, lParam));

        case WM_NOTIFY:
            Notify = (LPNMHDR)lParam;
            switch (Notify->code) {
                case PSN_SETACTIVE:
                    CurrentPage = TweakPage;
                    break;
                case PSN_APPLY:
                    //
                    // User has chosen to apply the changes.
                    //
                    if (ApplyChanges(hDlg)) {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                        return(TRUE);
                    }
            }
    }
    return FALSE;
}

int
TweakSheet(
    DWORD PageCount,
    PTWEAK_PAGE TweakPages[]
    )

/*++

Routine Description:

    Assembles the appropriate structures for a property sheet
    and creates the sheet.

Arguments:

    PageCount - Supplies the number of pages.

    TweakPages - Supplies the pages.

Return Value:

    Return value from PropertySheet()

--*/

{
    PROPSHEETHEADER psh;
    PROPSHEETPAGE *Page;
    DWORD i;
    INT_PTR Status;

    Page = LocalAlloc(LMEM_FIXED, PageCount * sizeof(PROPSHEETPAGE));
    if (Page==NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Initialize pages.
    //
    for (i=0; i<PageCount; i++) {
        Page[i].dwSize = sizeof(PROPSHEETPAGE);
        Page[i].dwFlags = PSP_USEICONID;
        Page[i].hInstance = GetModuleHandle(NULL);
        Page[i].pszIcon = MAKEINTRESOURCE(IDI_KERNTWEAK);
        Page[i].pszTemplate = TweakPages[i]->DlgTemplate;
        Page[i].pfnDlgProc = PageDlgProc;
        Page[i].pszTitle = NULL;
        Page[i].lParam = (LPARAM)TweakPages[i];
    }

    //
    // Initialize header.
    //
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.hwndParent = NULL;
    psh.hInstance = GetModuleHandle(NULL);
    psh.pszIcon = MAKEINTRESOURCE(IDI_KERNTWEAK);
    psh.pszCaption = TEXT("Windows NT Kernel Tweaker");
    psh.nPages = PageCount;
    psh.ppsp = (LPCPROPSHEETPAGE)Page;

    CurrentPage = TweakPages[0];

    Status = PropertySheet(&psh);
    if ((Status == ID_PSREBOOTSYSTEM) ||
        (Status == ID_PSRESTARTWINDOWS)) {
        BOOLEAN Enabled;

        Status = DialogBox(GetModuleHandle(NULL), MAKEINTRESOURCE(DLG_REBOOT), NULL, RebootDlgProc);
        RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                           TRUE,
                           FALSE,
                           &Enabled);
        if (Status == ID_FAST_REBOOT) {
            ExitWindowsEx(EWX_FORCE | EWX_REBOOT, 0);
        } else if (Status == ID_SLOW_REBOOT) {
            ExitWindowsEx(EWX_REBOOT, 0);
        }
    }

    return((int)Status);
}

INT_PTR
APIENTRY
RebootDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message) {
        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) {
                switch (LOWORD(wParam)) {
                    case ID_FAST_REBOOT:
                        EndDialog(hDlg, ID_FAST_REBOOT);
                        return(1);
                    case ID_SLOW_REBOOT:
                        EndDialog(hDlg, ID_SLOW_REBOOT);
                        return(1);
                    case ID_NO_REBOOT:
                        EndDialog(hDlg, ID_NO_REBOOT);
                        return(1);
                }
            }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kverify\genutil.cxx ===
//
// Enable driver verifier support for ntoskrnl
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: genutil.cxx
// author: DMihai
// created: 04/19/99
// description: genaral purpose utility routines
//

#include <windows.h>
#include <tchar.h>

#include "resutil.hxx"
#include "genutil.hxx"

//////////////////////////////////////////////////////////////
void
__cdecl
DisplayMessage(
    UINT uFormatResId,
    ... )
{
    TCHAR strMsgFormat[ 256 ];
    BOOL bResult;
    va_list prms;

    va_start (prms, uFormatResId);

    bResult = GetStringFromResources(
        uFormatResId,
        strMsgFormat,
        ARRAY_LEN( strMsgFormat ) );

    if( bResult == TRUE )
    {
        _vtprintf ( strMsgFormat, prms);
        _tprintf ( _TEXT( "\n" ) );
    }

    va_end (prms);
}

///////////////////////////////////////////////////////////////////

//
// Function:
//
//     ConvertAnsiStringToTcharString
//
// Description:
//
//     This function converts an ANSI string to a TCHAR string,
//     that is ANSO or UNICODE.
//
//     The function is needed because the system returns the active
//     modules as ANSI strings.
//

BOOL
ConvertAnsiStringToTcharString (

    LPBYTE Source,
    ULONG SourceLength,
    LPTSTR Destination,
    ULONG DestinationLength)
{
    ULONG Index;

    for (Index = 0;
         Index < SourceLength && Index < DestinationLength - 1;
         Index++) {

        if (Source[Index] == 0) {

            break;
        }

        Destination[Index] = (TCHAR)(Source[Index]);
    }

    Destination[Index] = 0;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kverify\main.cxx ===
//                                          
// Enable driver verifier support for ntoskrnl
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: main.cxx
// author: DMihai
// created: 04/19/99
// description: command line parsing and help information
//

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>

#include <common.ver>

#include "resid.hxx"
#include "resutil.hxx"
#include "genutil.hxx"
#include "regutil.hxx"

TCHAR strKernelModuleName[] = _T( "ntoskrnl.exe" );

void
DisplayHelpInformation();

//////////////////////////////////////////////////////////

extern "C" int _cdecl
wmain( int argc, TCHAR *argv[] )
{
    BOOL bResult;
    BOOL bChangeFlags;
    BOOL bEnableKrnVerifier;
    BOOL bDisableKernelVerifier;
    BOOL bShowStatus;
    DWORD dwVerifierFlags;
    DWORD dwIoLevel;
    int nCrtCmdLineArg;
    
    TCHAR strEnableCmdLineOption[ 64 ];
    TCHAR strFlagsCmdLineOption[ 64 ];
    TCHAR strDisableCmdLineOption[ 64 ];
    TCHAR strStatusCmdLineOption[ 64 ];
    TCHAR strIoLevelCmdLineOption[ 64 ];

    bResult = 
        GetStringFromResources( IDS_ENABLE_CMDLINE_OPTION, strEnableCmdLineOption, ARRAY_LEN( strEnableCmdLineOption ) ) &&
        GetStringFromResources( IDS_FLAGS_CMDLINE_OPTION, strFlagsCmdLineOption, ARRAY_LEN( strFlagsCmdLineOption ) ) &&
        GetStringFromResources( IDS_DISABLE_CMDLINE_OPTION, strDisableCmdLineOption, ARRAY_LEN( strDisableCmdLineOption ) ) &&
        GetStringFromResources( IDS_STATUS_CMDLINE_OPTION, strStatusCmdLineOption, ARRAY_LEN( strStatusCmdLineOption ) ) &&
        GetStringFromResources( IDS_IOLEVEL_CMDLINE_OPTION, strIoLevelCmdLineOption, ARRAY_LEN( strIoLevelCmdLineOption ) );
              

    bEnableKrnVerifier = FALSE;
    bDisableKernelVerifier = FALSE;
    bChangeFlags = FALSE;
    bShowStatus = FALSE;

    dwVerifierFlags = -1;
    dwIoLevel = 1;

    for( nCrtCmdLineArg = 0; nCrtCmdLineArg < argc; nCrtCmdLineArg ++ )
    {
        //
        // look for /enable
        //
    
        if( _tcsicmp( argv[ nCrtCmdLineArg ], strEnableCmdLineOption ) == 0 )
        {
            bEnableKrnVerifier = TRUE;
        }
        else
        {
            //
            // look for /flags
            //

            if( _tcsicmp( argv[ nCrtCmdLineArg ], strFlagsCmdLineOption ) == 0 )
            {
                if( nCrtCmdLineArg + 1 < argc )
                {
                    //
                    // new value for verifier flags
                    //

                    dwVerifierFlags = _ttoi( argv[ nCrtCmdLineArg + 1 ] );

                    bChangeFlags = TRUE;
                }
                // else ignore the /flags paramater
            }
            else
            {
                //
                // look for /iolevel
                //

                if( _tcsicmp( argv[ nCrtCmdLineArg ], strIoLevelCmdLineOption ) == 0 )
                {
                    if( nCrtCmdLineArg + 1 < argc )
                    {
                        //
                        // new value for the IO verification level
                        //

                        dwIoLevel = _ttoi( argv[ nCrtCmdLineArg + 1 ] );

                        if( dwIoLevel != 2 )
                        {
                            //
                            // only levels 1 & 2 are supported
                            //

                            dwIoLevel = 1;
                        }
                    }
                    // else ignore the /iolevel paramater
                }
                else
                {
                    //
                    // look for /disable
                    //
                    
                    if( _tcsicmp( argv[ nCrtCmdLineArg ], strDisableCmdLineOption ) == 0 )
                    {
                        bDisableKernelVerifier = TRUE;
                    }
                    else
                    {
                        //
                        // look for /status
                        //

                        if( _tcsicmp( argv[ nCrtCmdLineArg ], strStatusCmdLineOption ) == 0 )
                        {
                            bShowStatus = TRUE;
                        }
                        // else -> unknown cmd line param
                    }
                }
            }
        }
    }

    if( bEnableKrnVerifier == TRUE || bChangeFlags == TRUE )
    {
        //
        // this will exit the process with the appropriate exit code
        //

        WriteVerifierKeys(
            bEnableKrnVerifier,
            dwVerifierFlags,
            dwIoLevel,
            strKernelModuleName );
    }
    else
    {
        if( bDisableKernelVerifier == TRUE )
        {
            //
            // this will exit process with the appropriate exit code
            //

            RemoveModuleNameFromRegistry( strKernelModuleName );
        }
        else
        {
            if( bShowStatus == TRUE )
            {
                //
                // this will exit process with the appropriate exit code
                //

                DumpStatusFromRegistry( strKernelModuleName );
            }
            else
            {
                DisplayHelpInformation();
            }
        }
    }

    return 0;
}

///////////////////////////////////////////////////////////

void
DisplayHelpInformation()
{
    PrintStringFromResources( IDS_HELP_LINE1 );

    puts( VER_LEGALCOPYRIGHT_STR );

    PrintStringFromResources( IDS_HELP_LINE3 );
    PrintStringFromResources( IDS_HELP_LINE4 );
    PrintStringFromResources( IDS_HELP_LINE5 );
    PrintStringFromResources( IDS_HELP_LINE6 );
    PrintStringFromResources( IDS_HELP_LINE7 );
    PrintStringFromResources( IDS_HELP_LINE8 );
    PrintStringFromResources( IDS_HELP_LINE9 );
    PrintStringFromResources( IDS_HELP_LINE10 );
    PrintStringFromResources( IDS_HELP_LINE11 );
    PrintStringFromResources( IDS_HELP_LINE12 );
    PrintStringFromResources( IDS_HELP_LINE13 );
    PrintStringFromResources( IDS_HELP_LINE14 );
    PrintStringFromResources( IDS_HELP_LINE15 );
    PrintStringFromResources( IDS_HELP_LINE16 );
    PrintStringFromResources( IDS_HELP_LINE17 );
    PrintStringFromResources( IDS_HELP_LINE18 );
    PrintStringFromResources( IDS_HELP_LINE19 );
    PrintStringFromResources( IDS_HELP_LINE20 );
    PrintStringFromResources( IDS_HELP_LINE21 );
    PrintStringFromResources( IDS_HELP_LINE22 );
    PrintStringFromResources( IDS_HELP_LINE23 );
    PrintStringFromResources( IDS_HELP_LINE24 );
    PrintStringFromResources( IDS_HELP_LINE25 );

    exit( EXIT_CODE_NOTHING_CHANGED );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kerntwk\twkeng.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    twkeng.h

Abstract:

    Header file for public interface to kerntwk registry/UI engine

Author:

    John Vert (jvert) 10-Mar-1995

Revision History:

--*/

//
// Define structure for a tweakable item (knob)
//

//
// Valid flags
//
#define KNOB_NO_CURRENT_VALUE   0x0001
#define KNOB_NO_NEW_VALUE       0x0002

typedef struct _KNOB {
    HKEY RegistryRoot;
    LPTSTR KeyPath;
    LPTSTR ValueName;
    ULONG DialogId;
    ULONG Flags;
    ULONG CurrentValue;
    ULONG NewValue;
} KNOB, *PKNOB;

//
// Define structure for a page. A page is basically an
// array of pointers to knobs.
//

typedef BOOL (*DYNAMIC_CHANGE)(
    BOOL fInit,
    HWND hDlg
    );

typedef struct _TWEAK_PAGE {
    LPCTSTR DlgTemplate;
    DYNAMIC_CHANGE DynamicChange;
    PKNOB Knobs[];
} TWEAK_PAGE, *PTWEAK_PAGE;

//
// Define interface for creating property sheet.
//
int
TweakSheet(
    DWORD PageCount,
    PTWEAK_PAGE Pages[]
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kverify\regutil.cxx ===
//                                          
// Enable driver verifier support for ntoskrnl
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: regutil.cxx
// author: DMihai
// created: 04/19/99
// description: registry keys manipulation routines
//

extern "C" {
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
}

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>

#include "ResId.hxx"
#include "RegUtil.hxx"
#include "GenUtil.hxx"

#define VRF_MAX_DRIVER_STRING_LENGTH    4196

#define LEVEL2_IO_VERIFIER_ENABLED_VALUE   3

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Registry Strings
//////////////////////////////////////////////////////////////////////

LPCTSTR RegMemoryManagementKeyName = 
TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

LPCTSTR RegVerifyDriversValueName =
TEXT ("VerifyDrivers");

LPCTSTR RegVerifyDriverLevelValueName =
TEXT ("VerifyDriverLevel");

LPCTSTR RegIOVerifyKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager\\I/O System");

LPCTSTR RegIOVerifySubKeyName = 
    TEXT ("I/O System");

LPCTSTR RegIOVerifyLevelValueName =
    TEXT ("IoVerifierLevel");

LPCTSTR RegSessionManagerKeyName = 
    TEXT ("System\\CurrentControlSet\\Control\\Session Manager");

//////////////////////////////////////////////////////////////////////
/////////////// Forward decl for local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (
    HKEY HKey,
    LPCTSTR Name,
    DWORD * Value);

BOOL
WriteRegistryValue (
    HKEY MmKey,
    LPCTSTR Name,
    DWORD Value);

BOOL
ReadMmString (
    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value);

BOOL
WriteMmString (
    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value);

//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Public functions
//////////////////////////////////////////////////////////////////////

void
WriteVerifierKeys(
    BOOL bEnableKrnVerifier,
    DWORD dwNewVerifierFlags,
    DWORD dwNewIoLevel,
    TCHAR *strKernelModuleName )
{
    HKEY MmKey = NULL;
    DWORD dwExitCode;
    DWORD dwCrtFlags;
    DWORD dwCrtIoLevel;
    BOOL bMustAppendName;
    BOOL bAlreadyInRegistry;
    LONG lOpenResult;
    int nKernelModuleNameLen;
    int nStringLen;
    TCHAR *pstrCrtNameMatch, *pstrSubstring, *pCrtChar;
    TCHAR strVrfDriver [VRF_MAX_DRIVER_STRING_LENGTH];
    TCHAR strVrfDriverNew [VRF_MAX_DRIVER_STRING_LENGTH];

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lOpenResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &MmKey);

    if (lOpenResult != ERROR_SUCCESS) 
    {
        //
        // fatal error
        //

        dwExitCode = EXIT_CODE_ERROR;

        if( lOpenResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lOpenResult);
        }
    }

    if( dwExitCode != EXIT_CODE_ERROR != 0 ) 
    {
        //
        // the IO verifier will be enabled
        //

        if( dwNewIoLevel != 2 )
        {
            //
            // only levels 1 & 2 are supported
            //

            dwNewIoLevel = 1;
        }

        //
        // get the current IO level
        //

        if( GetIoVerificationLevel( &dwCrtIoLevel ) == FALSE )
        {
            //
            // fatal error
            //

            dwExitCode = EXIT_CODE_ERROR;
        }
    }

    if( dwExitCode != EXIT_CODE_ERROR )
    {
        if( ReadRegistryValue( MmKey, RegVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            if( dwNewVerifierFlags != -1 )
            {
                //
                // have some new flags
                //

                //
                // modify the flags in registry
                //

                if( dwCrtFlags != dwNewVerifierFlags )
                {
                    if( WriteRegistryValue( MmKey, RegVerifyDriverLevelValueName, dwNewVerifierFlags ) == FALSE )
                    {
                        dwExitCode = EXIT_CODE_ERROR;
                    }
                    else
                    {
                        dwExitCode = EXIT_CODE_REBOOT;
                    }
                }

                if( dwExitCode != EXIT_CODE_ERROR )
                {
					if( ( dwNewVerifierFlags & DRIVER_VERIFIER_IO_CHECKING ) == 0 )
					{
						//
						// IO verification is not enabled - disable "level 2" value too
						//

						dwNewIoLevel = 1;
					}

                    //
                    // the IO verifier will be enabled
                    //

                    if( dwCrtIoLevel != dwNewIoLevel )
                    {
                        //
                        // need to switch the IO verification level
                        //

                        if( SwitchIoVerificationLevel( dwNewIoLevel ) == TRUE )
                        {
                            dwExitCode = EXIT_CODE_REBOOT;
                        }
                        else
                        {
                            dwExitCode = EXIT_CODE_ERROR;
                        }
                    }
                }
            }
        }

        if( dwExitCode != EXIT_CODE_ERROR && bEnableKrnVerifier )
        {
            //
            // enable verifier for the kernel
            //

            if( ReadMmString (MmKey, RegVerifyDriversValueName, strVrfDriver) == FALSE) 
            {
                dwExitCode = EXIT_CODE_ERROR;
            }
            else
            {
                bAlreadyInRegistry = IsModuleNameAlreadyInRegistry( 
                    strKernelModuleName,
                    strVrfDriver );

                if( bAlreadyInRegistry == FALSE )
                {
                    _tcscpy( strVrfDriverNew, strKernelModuleName );

                    if( strVrfDriver[ 0 ] != (TCHAR)0 )
                    {
                        if( strVrfDriver[ 0 ] != _T( ' ' ) && 
                            strVrfDriver[ 0 ] != _T( '\t' ) )
                        {
                            //
                            // add a space first
                            //

                            _tcscat( strVrfDriverNew, _T( " " ) );
                        }

                        //
                        // add the old verified drivers at the end
                        //

                        _tcscat( strVrfDriverNew, strVrfDriver );
                    }

                    //
                    // write the value
                    //

                    if (WriteMmString (MmKey, RegVerifyDriversValueName, strVrfDriverNew) == FALSE) 
                    {
                        dwExitCode = EXIT_CODE_ERROR;
                    }
                    else
                    {
                        dwExitCode = EXIT_CODE_REBOOT;
                    }
                }

            }
        }

        RegCloseKey (MmKey);
    }

    if( EXIT_CODE_REBOOT == dwExitCode )
    {
        DisplayMessage( IDS_MUST_REBOOT );
    }
    else
    {
        if( EXIT_CODE_NOTHING_CHANGED == dwExitCode )
        {
            DisplayMessage( IDS_NOTHING_CHANGED );
        }
    }

    exit( dwExitCode );
}

///////////////////////////////////////////////////////////////////

void
RemoveModuleNameFromRegistry(
    TCHAR *strKernelModuleName )
{
    HKEY MmKey = NULL;
    DWORD dwExitCode;
    LONG lOpenResult;
    int nKernelModuleNameLen;
    int nStringLen;
    int nLeftToCopy;
    TCHAR *pstrCrtNameMatch, *pstrSubstring;
    TCHAR strVrfDriver [VRF_MAX_DRIVER_STRING_LENGTH];
    TCHAR strVrfDriverNew [VRF_MAX_DRIVER_STRING_LENGTH];

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;

    //
    // Open the Mm key
    //

    lOpenResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &MmKey);

    if (lOpenResult != ERROR_SUCCESS) 
    {
        dwExitCode = EXIT_CODE_ERROR;

        if( lOpenResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lOpenResult);
        }
    }
    else
    {
        if( ReadMmString (MmKey, RegVerifyDriversValueName, strVrfDriver) == FALSE) 
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            pstrCrtNameMatch = strVrfDriver;
            
            do
            {
                pstrSubstring = _tcsstr( pstrCrtNameMatch, strKernelModuleName );

                if( pstrSubstring != NULL )
                {
                    // 
                    // the name seems to be there
                    //

                    nKernelModuleNameLen = _tcsclen( strKernelModuleName );
                    nStringLen = _tcsclen( pstrSubstring );

                    if( nStringLen > nKernelModuleNameLen &&
                        pstrSubstring[ nKernelModuleNameLen ] != _TEXT(' ') && 
                        pstrSubstring[ nKernelModuleNameLen ] != _TEXT('\t') )
                    {
                        // 
                        // this is not our name, continue searching
                        //
                    
                        pstrCrtNameMatch += nKernelModuleNameLen;
                    }
                    else
                    {
                        if( pstrSubstring != &strVrfDriver[ 0 ] && 
                            (* (pstrSubstring - 1) ) != _TEXT(' ') && 
                            (* (pstrSubstring - 1) )  != _TEXT('\t') )
                        {
                            // 
                            // this is not our name, continue searching
                            //
                    
                            pstrCrtNameMatch += min( nKernelModuleNameLen, nStringLen );
                        }
                        else
                        {
                            // 
                            // kernel's module name is in the registry
                            //
                            
                            strVrfDriverNew[0] = (TCHAR)0;
                            
                            _tcsncat( 
                                strVrfDriverNew, 
                                strVrfDriver, 
                                (size_t)(pstrSubstring - &strVrfDriver[0]) );

                            nLeftToCopy = nStringLen - nKernelModuleNameLen;
                            pstrSubstring += nKernelModuleNameLen;

                            while( nLeftToCopy > 0 )
                            {
                                if( *pstrSubstring != _TEXT( ' ' ) && 
                                    *pstrSubstring != _TEXT( '\t' ) )
                                {
                                    //
                                    // append what starts from here
                                    //

                                    _tcscat( strVrfDriverNew, pstrSubstring );
                                    
                                    break;
                                }
                                else
                                {
                                    //
                                    // skip spaces
                                    //

                                    pstrSubstring ++;
                                    nLeftToCopy --;
                                }
                            }

                            //
                            // write the new value to the registry
                            //

                            if (WriteMmString (MmKey, RegVerifyDriversValueName, strVrfDriverNew) == FALSE) 
                            {
                                dwExitCode = EXIT_CODE_ERROR;
                            }
                            else
                            {
                                dwExitCode = EXIT_CODE_REBOOT;
                            }

                            break;
                        }
                    }
                }
            }
            while( pstrSubstring != NULL );
        }

        RegCloseKey (MmKey);
    }

    if( EXIT_CODE_REBOOT == dwExitCode )
    {
        DisplayMessage( IDS_MUST_REBOOT );
    }
    else
    {
        if( EXIT_CODE_NOTHING_CHANGED == dwExitCode )
        {
            DisplayMessage( IDS_NOTHING_CHANGED );
        }
    }

    exit( dwExitCode );
}

//////////////////////////////////////////////////

void
DumpStatusFromRegistry(
    LPCTSTR strKernelModuleName )
{
    HKEY MmKey = NULL;
    DWORD dwExitCode;
    LONG lOpenResult;
    DWORD dwCrtFlags;
    DWORD dwIoLevel;
    int nKernelModuleNameLen;
    int nStringLen;
    BOOL bKernelVerified;
    BOOL bIsModuleNameRegistry;
    TCHAR *pstrCrtNameMatch, *pstrSubstring, *pCrtChar;
    TCHAR strVrfDriver [VRF_MAX_DRIVER_STRING_LENGTH];

    dwExitCode = EXIT_CODE_NOTHING_CHANGED;
    bKernelVerified = FALSE;

    //
    // Open the Mm key
    //

    lOpenResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegMemoryManagementKeyName,
        0,
        KEY_QUERY_VALUE,
        &MmKey);

    if (lOpenResult != ERROR_SUCCESS) 
    {
        dwExitCode = EXIT_CODE_ERROR;

        if( lOpenResult == ERROR_ACCESS_DENIED ) 
        {
            DisplayMessage( IDS_ACCESS_IS_DENIED );
        }
        else 
        {
            DisplayMessage( 
                IDS_REGOPENKEYEX_FAILED,
                RegMemoryManagementKeyName,
                (DWORD)lOpenResult);
        }
    }
    else
    {
        if( ReadMmString (MmKey, RegVerifyDriversValueName, strVrfDriver) == FALSE) 
        {
            dwExitCode = EXIT_CODE_ERROR;
        }
        else
        {
            bIsModuleNameRegistry = IsModuleNameAlreadyInRegistry(
                strKernelModuleName,
                strVrfDriver );

            if( bIsModuleNameRegistry == TRUE )
            {
                //
                // we have 'ntoskrnl.exe' in the registry
                //
            
                //
                // read the verification flags
                //

                if( ReadRegistryValue( MmKey, RegVerifyDriverLevelValueName, &dwCrtFlags ) == FALSE )
                {
                    dwExitCode = EXIT_CODE_ERROR;
                }
                else
                {
                    bKernelVerified = TRUE;

                    if( dwCrtFlags != -1 )
                    {
                        if( ( dwCrtFlags & DRIVER_VERIFIER_IO_CHECKING ) != 0 )
                        {
                            //
                            // the IO verification is enabled, check the IO verification level ( 1 or 2 )
                            //

                            if( GetIoVerificationLevel( &dwIoLevel ) == FALSE )
                            {
                                dwExitCode = EXIT_CODE_ERROR;
                            }
                            else
                            {
                                if( dwIoLevel != 2 )
                                {
                                    //
                                    // only levels 1 & 2 are supported 
                                    //

                                    dwIoLevel = 1;
                                }

                                DisplayMessage(
                                    IDS_VERIFIER_ENABLED_WITH_IO_FORMAT,
                                    strKernelModuleName,
                                    dwCrtFlags,
                                    dwIoLevel );
                            }
                        }
                        else
                        {
                            //
                            // the IO verification is not enabled
                            //

                            DisplayMessage(
                                IDS_VERIFIER_ENABLED_FORMAT,
                                strKernelModuleName,
                                dwCrtFlags );
                        }
                    }
                    else
                    {
                        DisplayMessage(
                            IDS_VERIFIER_ENABLED_NOFLAGS_FORMAT,
                            strKernelModuleName );
                    }
                }
            }

            if( EXIT_CODE_NOTHING_CHANGED == dwExitCode && ! bKernelVerified )
            {
                DisplayMessage(
                    IDS_VERIFIER_NOT_ENABLED_FORMAT,
                    strKernelModuleName );
            }
        }

        RegCloseKey (MmKey);
    }

    exit( dwExitCode );
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////// Local registry manipulation functions
//////////////////////////////////////////////////////////////////////

BOOL
ReadRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD * Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
    
    //
    // default value
    //

    *Value = -1;
    Size = sizeof *Value;
  
    Result = RegQueryValueEx (
        HKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Value),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) 
    {
        *Value = -1;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            (DWORD)Result);
      
        return FALSE;
    }
    
    if (Type != REG_DWORD) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);
      
        return FALSE;
    }
    
    if (Size != sizeof *Value) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_SIZE,
            Name);
      
        return FALSE;
    }
    
    return TRUE;
}


BOOL
WriteRegistryValue (

    HKEY HKey,
    LPCTSTR Name,
    DWORD Value)
{
    LONG Result;
    
    Result = RegSetValueEx (
        HKey,
        Name,
        0,
        REG_DWORD,
        (LPBYTE)(&Value),
        sizeof Value);


    if (Result != ERROR_SUCCESS) 
    {
        DisplayMessage ( 
            IDS_REGSETVALUEEX_FAILED,
            Name,
            (DWORD)Result);
     
        return FALSE;
    }
    
    return TRUE;
}


BOOL
ReadMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
    
    //
    // default value
    //

    *Value = 0;
    Size = VRF_MAX_DRIVER_STRING_LENGTH;
  
    Result = RegQueryValueEx (
        MmKey,
        Name,
        0,
        &Type,
        (LPBYTE)(Value),
        &Size);

    //
    // Deal with a value that is not defined.
    //

    if (Result == ERROR_FILE_NOT_FOUND) 
    {
        *Value = 0;
        return TRUE;
    }

    if (Result != ERROR_SUCCESS) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_FAILED,
            Name,
            (DWORD)Result);
      
        return FALSE;
    }
    
    if (Type != REG_SZ) 
    {
        DisplayMessage ( 
            IDS_REGQUERYVALUEEX_UNEXP_TYPE,
            Name);
      
        return FALSE;
    }
    
    return TRUE;
}


BOOL
WriteMmString (

    HKEY MmKey,
    LPCTSTR Name,
    LPTSTR Value)
{
    LONG Result;
    DWORD Reserved;
    DWORD Type;
    DWORD Size;
   
    Result = RegSetValueEx (

        MmKey,
        Name,
        0,
        REG_SZ,
        (LPBYTE)(Value),
        (_tcslen (Value) + 1) * sizeof (TCHAR));

    if (Result != ERROR_SUCCESS) 
    {
        DisplayMessage ( 
            IDS_REGSETVALUEEX_FAILED,
            Name,
            (DWORD)Result);
      
        return FALSE;
    }
    
    return TRUE;
}

//////////////////////////////////////////////////
BOOL
IsModuleNameAlreadyInRegistry(
    LPCTSTR strKernelModuleName,
    LPCTSTR strWholeString )
{
    BOOL bAlreadyInRegistry;
    int nKernelNameLength;
    LPCTSTR strString;
    LPCTSTR strSubstring;
    TCHAR cBefore;

    nKernelNameLength = _tcslen( strKernelModuleName );

    //
    // let's assume 'ntoskrnl.exe" is not already in the registry
    //

    bAlreadyInRegistry = FALSE;

    //
    // parse the string that's already in the registry 
    //

    strString = strWholeString;
    
    while( *strString != (TCHAR)0 )
    {
        strSubstring = _tcsstr( strString, strKernelModuleName );

        if( strSubstring != NULL )
        {
            //
            // the string from the registry includes "ntoskrnl.exe"
            //
            
            //
            // let's assume it's nothing like "xyzntoskrnl.exe", "ntoskrnl.exexyz", etc.
            //

            bAlreadyInRegistry = TRUE;

            //
            // look for a character before the current substring
            //

            if( strSubstring > strWholeString )
            {
                //
                // have at least one character before "ntoskrnl.exe" - look if it is blanc
                //
            
                cBefore = *( strSubstring - 1 );

                if( cBefore != _T( ' ' ) && cBefore != _T( '\t' ) )
                {
                    // 
                    // the character before "ntoskrnl.exe" is non-blanc -> not the name we are searching for
                    //
                    
                    bAlreadyInRegistry = FALSE;

                }
            }

            //
            // look for a character after the current substring
            //

            if( bAlreadyInRegistry == TRUE &&
                strSubstring[ nKernelNameLength ] != (TCHAR)0 &&
                strSubstring[ nKernelNameLength ] != _T( ' ' ) &&
                strSubstring[ nKernelNameLength ] != _T( '\t' ) )
            {
                //
                // have a non-blanc character after this substring -> not the name we are searching for
                //

                bAlreadyInRegistry = FALSE;
            }

            if( bAlreadyInRegistry == FALSE )
            {
                //
                // this is not a real occurence of the name we are serching for, go further on
                //

                strString = strSubstring + 1;
            }

			if( bAlreadyInRegistry == TRUE )
			{
				//
				// found it
				//

				break;
			}
        }
		else
		{
			//
			// the name is not there
			//

			break;
		}
    }

    return bAlreadyInRegistry;
}

//////////////////////////////////////////////////
BOOL
GetIoVerificationLevel( 
    DWORD *pdwIoLevel )
{
    LONG lResult;
    HKEY IoKey = NULL;
    DWORD dwCrtIoVerifLevel;
    BOOL bFatalError;

    bFatalError = FALSE;

    //
    // default value
    //

    *pdwIoLevel = 1;

    //
    // open the "I/O" key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegIOVerifyKeyName,
        0,
        KEY_QUERY_VALUE,
        &IoKey);

    if (lResult != ERROR_SUCCESS) 
    {
        //
        // cannot open the IO key
        //

        if( lResult != ERROR_FILE_NOT_FOUND )
        {
            //
            // the IO key is there, but we cannot open it
            //

            if( lResult == ERROR_ACCESS_DENIED ) 
            {
                DisplayMessage( IDS_ACCESS_IS_DENIED );
            }
            else 
            {
                DisplayMessage( 
                    IDS_REGOPENKEYEX_FAILED,
                    RegIOVerifyKeyName,
                    (DWORD)lResult);
            }

            bFatalError = TRUE;
        }
        // else - the IO key doesn't exist - use default value
    }
    else
    {
        //
        // read "I/O System\IoVerifierLevel" value
        //

        if( ReadRegistryValue( IoKey, RegIOVerifyLevelValueName, &dwCrtIoVerifLevel ) )
        {
            if( LEVEL2_IO_VERIFIER_ENABLED_VALUE == dwCrtIoVerifLevel )
            {
                //
                // we are at level 2 IO verification
                //

                *pdwIoLevel = 2;
            }
        }
        
        RegCloseKey (IoKey);
    }

    return ( ! bFatalError );
}

//////////////////////////////////////////////////
BOOL
SwitchIoVerificationLevel(
    DWORD dwNewIoLevel )
{
    BOOL bFatalError;
    LONG lResult;
    HKEY IoKey = NULL;
    HKEY SmKey = NULL;

    bFatalError = FALSE;

    //
    // Open the "I/O System" key
    //

    lResult = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        RegIOVerifyKeyName,
        0,
        KEY_QUERY_VALUE | KEY_WRITE,
        &IoKey);

    if( lResult != ERROR_SUCCESS )
    {
        if( dwNewIoLevel == 2 )
        {
            //
            // cannot open the IO key - maybe a fatal error - anyway, we will try to create it
            //

            bFatalError = TRUE;

            if( lResult == ERROR_ACCESS_DENIED ) 
            {
                //
                // access is denied - fatal error
                //

                DisplayMessage( IDS_ACCESS_IS_DENIED );
            }
            else
            {
                if( lResult == ERROR_FILE_NOT_FOUND ) 
                {
                    //
                    // the "I/O System" key doesn't exist, try to create it
                    //

                    //
                    // open the "Session Manager" key
                    //

                    lResult = RegOpenKeyEx (
                        HKEY_LOCAL_MACHINE,
                        RegSessionManagerKeyName,
                        0,
                        KEY_QUERY_VALUE | KEY_WRITE,
                        &SmKey);

                    if( lResult != ERROR_SUCCESS )
                    {
                        //
                        // cannot open the "Session Manager" key - fatal error
                        //

                        DisplayMessage( 
                            IDS_REGOPENKEYEX_FAILED,
                            RegSessionManagerKeyName,
                            (DWORD)lResult);
                    }
                    else
                    {
                        //
                        // create the "I/O System" key
                        //

                        lResult = RegCreateKeyEx(
                            SmKey,
                            RegIOVerifySubKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_QUERY_VALUE,
                            NULL,
                            &IoKey,
                            NULL );

                        if( lResult != ERROR_SUCCESS )
                        {
                            //
                            // cannot create key - fatal error
                            //

                            DisplayMessage( 
                                IDS_REGCREATEKEYEX_FAILED,
                                RegIOVerifySubKeyName,
                                (DWORD)lResult);
                        }
                        else
                        {
                            //
                            // key created - reset the error code
                            //

                            bFatalError = FALSE;
                        }

                        //
                        // close the "Session Manager" key
                        //

                        lResult = RegCloseKey(
                            SmKey );
                    }
                }
                else
                {
                    // 
                    // other error opening the "I/O System" key
                    //
        
                    DisplayMessage( 
                        IDS_REGOPENKEYEX_FAILED,
                        RegIOVerifyKeyName,
                        (DWORD)lResult);
                }
            }
        }
        else
            bFatalError = TRUE;
        //else
        //  we don't actually need the key in this case, we just want to wipe out
        //  the IO verification registry value
        //
    }
    
    if( bFatalError == FALSE )
    {
        if( dwNewIoLevel == 2 )
        {
            //
            // if we reached this point, we should have the IO key opened
            //

            //
            // enable level 2
            //

            if( WriteRegistryValue( IoKey, RegIOVerifyLevelValueName, LEVEL2_IO_VERIFIER_ENABLED_VALUE ) == FALSE )
            {
                //
                // cannot recover from this
                //

                bFatalError = TRUE;
            }
        }
        else
        {
            //
            // disable level 2
            //

            lResult = RegDeleteValue(
                IoKey,
                RegIOVerifyLevelValueName );

            if( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND )
            {
                bFatalError = TRUE;

                DisplayMessage( 
                    IDS_REGDELETEVALUE_FAILED,
                    RegIOVerifyLevelValueName,
                    (DWORD)lResult);
            }
        
            RegCloseKey (IoKey);
        }
    }

    return ( ! bFatalError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\kverify\resutil.cxx ===
//                                          
// Enable driver verifier support for ntoskrnl
// Copyright (c) Microsoft Corporation, 1999
//

//
// module: resutil.cxx
// author: DMihai
// created: 04/19/99
// description: resources manipulation routines
//

#include <windows.h>
#include <tchar.h>

#include "genutil.hxx"
#include "resutil.hxx"

//////////////////////////////////////////////////////////////////////

BOOL
GetStringFromResources( 
    UINT uIdResource,
    TCHAR *strResult,
    int nBufferLen )
{
    UINT LoadStringResult;

    LoadStringResult = LoadString (
        GetModuleHandle (NULL),
        uIdResource,
        strResult,
        nBufferLen );

    assert_ (LoadStringResult > 0);

    return (LoadStringResult > 0);
}

//////////////////////////////////////////////////////////////////////
void
PrintStringFromResources(

    UINT uIdResource)
{
    TCHAR strStringFromResource[ 1024 ];
    BOOL bResult;

    bResult = GetStringFromResources(
        uIdResource,
        strStringFromResource,
        ARRAY_LEN( strStringFromResource ) );
    
    if( bResult == TRUE ) 
    {
        _putts( strStringFromResource );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\leakyapp\leakyapp.cpp ===
// leakyapp.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "leakyapp.h"
#include "leakydlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLeakyappApp

BEGIN_MESSAGE_MAP(CLeakyappApp, CWinApp)
	//{{AFX_MSG_MAP(CLeakyappApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLeakyappApp construction

CLeakyappApp::CLeakyappApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLeakyappApp object

CLeakyappApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CLeakyappApp initialization

BOOL CLeakyappApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();
	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	CLeakyappDlg dlg;
	m_pMainWnd = &dlg;
	INT_PTR nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\leakyapp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\leakyapp\leakyapp.h ===
// leakyapp.h : main header file for the LEAKYAPP application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CLeakyappApp:
// See leakyapp.cpp for the implementation of this class
//

class CLeakyappApp : public CWinApp
{
public:
	CLeakyappApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLeakyappApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CLeakyappApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\leakyapp\leakydlg.cpp ===
// leakydlg.cpp : implementation file
//

#include "stdafx.h"
#include "leakyapp.h"
#include "leakydlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg message handlers

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	CenterWindow();
	
	// TODO: Add extra about dlg initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

/////////////////////////////////////////////////////////////////////////////
// CLeakyappDlg dialog

CLeakyappDlg::CLeakyappDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CLeakyappDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLeakyappDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_mabListHead.pNext = NULL;
	m_bRunning = FALSE;
}

void CLeakyappDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLeakyappDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CLeakyappDlg, CDialog)
	//{{AFX_MSG_MAP(CLeakyappDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(ID_FREE_MEMORY, OnFreeMemory)
	ON_BN_CLICKED(ID_START_STOP, OnStartStop)
	ON_WM_DESTROY()
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CLeakyappDlg::SetMemUsageBar() 
{
	MEMORYSTATUS	MemoryStatusData;
	LONGLONG		llInUse;
	DWORD			dwPercentUsed;

	GlobalMemoryStatus (&MemoryStatusData);

	llInUse = (LONGLONG)(MemoryStatusData.dwTotalPageFile - MemoryStatusData.dwAvailPageFile + 5 );
	llInUse *= 1000;
	llInUse /= MemoryStatusData.dwTotalPageFile;
	llInUse /= 10;

	dwPercentUsed = (DWORD)llInUse;

	SendDlgItemMessage (IDC_LEAK_PROGRESS, PBM_SETPOS, 	(WPARAM)dwPercentUsed);
}

/////////////////////////////////////////////////////////////////////////////
// CLeakyappDlg message handlers

BOOL CLeakyappDlg::OnInitDialog()
{

	CDialog::OnInitDialog();
	CenterWindow();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	SendDlgItemMessage (IDC_LEAK_PROGRESS, PBM_SETRANGE, 0, MAKELONG(0, 100));
	SendDlgItemMessage (IDC_LEAK_PROGRESS, PBM_SETSTEP, 2, 0);

	SetMemUsageBar();
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CLeakyappDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else if ((nID & 0xFFF0) == SC_CLOSE)
	{
		OnOK();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CLeakyappDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CLeakyappDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CLeakyappDlg::OnFreeMemory() 
{
	PMEMORY_ALLOC_BLOCK	pNextMab, pMab;

	pMab = m_mabListHead.pNext;

	while (pMab != NULL) {
		pNextMab = pMab->pNext;
		GlobalFree (pMab);
		pMab = pNextMab;
	}

	m_mabListHead.pNext = NULL;

	SetMemUsageBar();
}

void CLeakyappDlg::OnStartStop() 
{
	if (m_bRunning) {
		// then stop
		KillTimer (m_TimerId);
		m_bRunning = FALSE;
		SetDlgItemText (ID_START_STOP, TEXT("&Start Leaking"));
	} else {
		// not running, so start
		m_TimerId = SetTimer (LEAK_TIMER, TIME_INTERVAL, NULL);
		if (m_TimerId != 0) {
			m_bRunning = TRUE;
			SetDlgItemText (ID_START_STOP, TEXT("&Stop Leaking"));
		}
	}

	SetMemUsageBar();
}

void CLeakyappDlg::OnOK() 
{
	CDialog::OnOK();
}

void CLeakyappDlg::OnDestroy() 
{
	OnFreeMemory();

	CDialog::OnDestroy();
}

void CLeakyappDlg::OnTimer(UINT nIDEvent) 
{
	PMEMORY_ALLOC_BLOCK	pMab, pNewMab;

	pNewMab = (PMEMORY_ALLOC_BLOCK)GlobalAlloc (GPTR, ALLOCATION_SIZE);

	if (pNewMab != NULL) {
		// save this pointer 
		pNewMab->pNext = NULL;
		if (m_mabListHead.pNext == NULL) {
			// this is the first entry
			m_mabListHead.pNext = pNewMab;
		} else {
			// go to end of list
			pMab = m_mabListHead.pNext;
			while (pMab->pNext != NULL) pMab = pMab->pNext;
			pMab->pNext = pNewMab;
		}
	}

	SetMemUsageBar();

	CDialog::OnTimer(nIDEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\leakyapp\leakydlg.h ===
// leakydlg.h : header file
//
typedef struct _MEMORY_ALLOC_BLOCK {
	struct _MEMORY_ALLOC_BLOCK	*pNext;
} MEMORY_ALLOC_BLOCK, *PMEMORY_ALLOC_BLOCK;

#define ALLOCATION_SIZE		(4096*10)
#define TIME_INTERVAL		(100)
#define LEAK_TIMER			13

/////////////////////////////////////////////////////////////////////////////
// CLeakyappDlg dialog

class CLeakyappDlg : public CDialog
{
// Construction
public:
	CLeakyappDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CLeakyappDlg)
	enum { IDD = IDD_LEAKYAPP_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLeakyappDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CLeakyappDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnFreeMemory();
	afx_msg void OnStartStop();
	virtual void OnOK();
	afx_msg void OnDestroy();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void SetMemUsageBar ();

// class member variables
	MEMORY_ALLOC_BLOCK	m_mabListHead;
	BOOL				m_bRunning;
	UINT_PTR    		m_TimerId;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\leakyapp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	leakyapp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\leakyapp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by leakyapp.rc
//
#define ID_START_STOP                   2
#define ID_FREE_MEMORY                  3
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_LEAKYAPP_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_LEAK_PROGRESS               1002
#define IDC_GENERIC2                    1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\bndrel.h ===
/* SCCSID = @(#)bndrel.h        4.3 86/07/21 */
/*
*       Copyright Microsoft Corporation, 1983, 1984, 1985
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*
*  bndrel.h
*  Relocation record definitions
*/
#if OEXE

//  DOS run-time relocation record

#pragma pack(1)

typedef struct _DOSRLC
{
    WORD        ra;             // Relocation offset
    SATYPE      sa;             // Relocation segment
}
                DOSRLC;

#pragma pack()

#define CBRLE           sizeof(DOSRLC)

#if FEXEPACK

//  EXEPACKed DOS run-time relocation storage

typedef struct _FRAMERLC
{
    WORD        count;          // Number of relocation for this frame
    WORD        size;           // Size of rgRlc
    WORD FAR    *rgRlc;         // Array of packed relocation offsets
}
                FRAMERLC;

#define DEF_FRAMERLC    64

#endif

//  Not EXEPACKed DOS run-time relocation storage

typedef struct _RUNRLC
{
    WORD        count;          // Number of relocation for this overlay
    WORD        size;           // Size of rgRlc
    DOSRLC FAR  *rgRlc;         // Array of relocation addresses
}
                RUNRLC;

#define DEF_RUNRLC      128
#endif

#define LOCLOBYTE       0               /* Lo-byte (8-bit) fixup */
#define LOCOFFSET       1               /* Offset (16-bit) fixup */
#define LOCSEGMENT      2               /* Segment (16-bit) fixup */
#define LOCPTR          3               /* "Pointer" (32-bit) fixup */
#define LOCHIBYTE       4               /* Hi-byte fixup (unimplemented) */
#define LOCLOADOFFSET   5               /* Loader-resolved offset fixup */
#define LOCOFFSET32     9               /* 32-bit offset */
#define LOCPTR48        11              /* 48-bit pointer */
#define LOCLOADOFFSET32 13              /* 32-bit loader-resolved offset */
#define T0              0               /* Target method T0 (segment index) */
#define T1              1               /* Target method T1 (group index) */
#define T2              2               /* Target method T2 (extern index) */
#define F0              0               /* Frame method F0 (segment index) */
#define F1              1               /* Frame method F1 (group index) */
#define F2              2               /* Frame method F2 (extern index) */
#define F3              3               /* Frame method F3 (frame number) */
#define F4              4               /* Frame method F4 (location) */
#define F5              5               /* Frame method F5 (target) */

/*
 *  Fixup record bits
 */

#define F_BIT           0x80
#define T_BIT           0x08
#define P_BIT           0x04
#define M_BIT           0x40
#define S_BIT           0x20
#define THREAD_BIT      0x80
#define D_BIT           0x40

#define FCODETOCODE             0
#define FCODETODATA             1
#define FDATATOCODE             2
#define FDATATODATA             3
#define BREAKPOINT              0xCC    /* Op code for interrupt 3 (brkpt) */
#define CALLFARDIRECT           0x9A    /* Op code for long call */
#define CALLNEARDIRECT          0xE8    /* Op code for short call */
#define JUMPFAR                 0xEA    /* Op code for long jump */
#define JUMPNEAR                0xE9    /* Op code for short (3-byte) jump */
#define KINDSEG                 0
#define KINDGROUP               1
#define KINDEXT                 2
#define KINDLOCAT               4
#define KINDTARGET              5
#define NOP                     0x90    /* Op code for no-op */
#define PUSHCS                  0x0E    /* Op code for push CS */
#define INTERRUPT               0xCD    /* Op code for interrupt */

typedef struct _FIXINFO
{
    WORD                f_dri;          /* Data record index */
    WORD                f_loc;          /* Fixup location type */
    KINDTYPE            f_mtd;          /* Target specification method */
    WORD                f_idx;          /* Target specification index */
    DWORD               f_disp;         /* Target displacement */
    KINDTYPE            f_fmtd;         /* Frame specification method */
    WORD                f_fidx;         /* Frame specification index */
    FTYPE               f_self;         /* Self-relative boolean */
    FTYPE               f_add;          /* Additive fixup boolean */
}
                        FIXINFO;        /* Fixup information record */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\bndtrn.h ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*
*  bndtrn.h:
*
*  Constant definitions:
*/

/*
 *  Aligment types
 */

#define ALGNNIL         0               /* Unaligned LSEG */
#define ALGNABS         0               /* Absolute LSEG */
#define ALGNBYT         1               /* Byte-aligned LSEG */
#define ALGNWRD         2               /* Word-aligned LSEG */
#define ALGNDBL         5               /* Double-word aligned LSEG */
#define ALGNPAR         3               /* Paragraph-aligned LSEG */
#define ALGNPAG         4               /* Page-aligned LSEG */

/*
 *  Symbol attributes types
 */

#define ATTRNIL         0               /* Nil attribute */
#define ATTRPSN         1               /* Public segment attribute */
#define ATTRLSN         2               /* Local segment attribute */
#define ATTRPNM         3               /* Public name attribute */
#define ATTRLNM         4               /* Local name attribute */
#define ATTRFIL         5               /* File name attribute */
#define ATTRGRP         6               /* Group name attribute */
#define ATTRUND         7               /* Undefined symbol attribute */
#define ATTRSKIPLIB     8               /* Default library name to skip */
#define ATTRCOMDAT      9               /* Named data block - COMDAT */
#define ATTRALIAS       10              /* Alias name attribute */
#define ATTREXP         11              /* Exported name attribute */
#define ATTRIMP         12              /* Imported name attribute */
#define ATTRMAX         13              /* Highest attribute no. plus 1 */

/*
 *  LINK limits
 */

#define BIGBIT          2               /* Big bit in ACBP byte */
#define BNDABS          0xFE            /* Bundle of absolute entries */
#define BNDMAX          255             /* Maximum entries per bundle */
#define BNDMOV          0xFF            /* Bundle of movable entries */
#define BNDNIL          0               /* Null bundle */
#define CBELMAX         0xffff          /* Max COMDEF elem. length in bytes */
#if EXE386
#define CBMAXSEG32      (0xffffffffL)   /* Maximum 32-bit segment size under OS/2 */
#else
#define CBMAXSEG32      (1L<<LG2SEG32)  /* Maximum 32-bit segment size under DOS = 32Mb */
#endif
#if CPUVAX OR CPU68K
#define CBMAXSYMSRES    0x8000L         /* 32K resident symbol table */
#else
#define CBMAXSYMSRES    0x3000          /* 12K resident symbol table */
#endif
#define CBRLC           4               /* Bytes in old .EXE reloc record */
#if OSXENIX
#define CHPATH          '/'             /* Path delimiter */
#else
#define CHPATH          '\\'            /* Path delimiter */
#endif
#define CODE386BIT      1               /* 386 code segment in ACBP byte */
#define COMBCOM         6               /* Combine as common */
#define COMBPUB         2               /* Combine as public */
#define COMBSTK         5               /* Combine as stack */
#define CSLOTMAX        37              /* No. of buckets on dictionary page */
#define DATAMAX         1024            /* Max. bytes data in LEDATA record */
#define DFGSNMAX        128             /* Default 128 segments maximum */
#define DFINTNO         0x3F            /* Default interrupt number */
#define OVLTHUNKSIZE    6               /* Thunk size for dynamic overlays */
#define THUNKNIL        ((WORD)-1)      /* NO thunk assigned */
#if EXE386
#define DFPGALIGN       12              /* Default object page alignment shift */
#define DFOBJALIGN      16              /* Default memory object alignment shift */
#endif
#define DFSAALIGN       9               /* Default segment alignment shift */
#define EXPMAX          0xfffe          /* Max. number of exported entries */
#define EXTMAX          2048            /* Max. no. of EXTDEFs per module */
#define FHNIL           ((char) 0xFF)   /* Nil library number */
#define FSTARTADDRESS   0x40            /* Fixdat byte field mask */
#define GGRMAX          32              /* Max. no. of GRPDEFs */
#define GRMAX           32              /* Max. no. of GRPDEFs per module */
#define GRNIL           0               /* Nil group number */
#if EXE386                              /* Absolute max. no. of segments */
#define GSNMAX          (0xffdf/sizeof(RATYPE))
#else
#define GSNMAX          (0xffdf/sizeof(RATYPE))
#endif
#define HEPLEN          241             /* Entry point hash table length */
#define HTDELTA         17              /* Hash delta for htgsnosn[] */
#define IFHLIBMAX       130             /* Max. no. of libraries + 2*/
#define IMAX            1024            /* Max. of SNMAX, GRMAX, and EXTMAX */
#define INDIR           '@'             /* Indirect file char */
#define INIL            0xFFFF          /* Nil index (generic) */
#if OVERLAYS
#define IOVMAX          OSNMAX          /* Max. no. of overlays */
#else
#define IOVMAX          1               /* Max. no. of overlays */
#endif
#define IOVROOT         0               /* Root overlay number */
#define NOTIOVL         0xffff          // Overlay index not specified
#define LBUFSIZ         32768           /* Size of main I/O buffer */
#define LG2OSN          11              /* Log2 OSNMAX */
#define LG2Q            15              /* Log2 QUANTUM */
#if EXE386
#define LG2SEG32        32              /* Log2 max 32-bit seg size under OS/2 */
#else
#define LG2SEG32        25              /* Log2 max 32-bit seg size under DOS */
#endif
#define LNAMEMAX        255             /* Maximum LNAME length */
#define LXIVK           (0x10000L)      /* 64K */
#define MEGABYTE        (0x100000L)     /* 1024k = 1048576 bytes */
#define LG2PAG          9               // 2^9 = 512
#define PAGLEN          (1U << LG2PAG)
#define MASKRB          0x1FF
#define MASKTYSNCOMBINE 034
#define OSNMAX          0x800           /* Maximum number +1 of overlay segs*/
#define PARAPRVSEG      0x60            /* Paragraph-aligned private seg */
#define DWORDPRVSEG     0xa0            /* DWORD-aligned private seg */
#define PARAPUBSEG      0x68            /* Paragraph-aligned public segment */
#define DWORDPUBSEG     0xa8            /* DWORD-aligned public segment */
#define PROPNIL         (PROPTYPE)0     /* Nil pointer */
#define QUANTUM         (1U<<LG2Q)      /* Block size for lib dict., VM mgr */
#if BIGSYM
#define RBMAX           (1L<<20)        /* 1 + largest symtab pointer */
#else
#define RBMAX           LXIVK           /* 1 + largest symtab pointer */
#endif
#define RECTNIL         0               /* Nil record type */
#define RHTENIL         (RBTYPE)0       /* Nil pointer */
#define RLCMAX          4               /* Maximum no. of thread definitions  */
#define SAMAX           256             /* Max. no. of physical segments */
#define SANIL           0               /* The null file segment */
#define SEGNIL          0               /* Nil segment number */
#define SHPNTOPAR       5               /* Log(2) of page/para */
#define SNMAX           255             /* Max. no. of SEGDEFs per module */
#define SNNIL           0               /* Nil SEGDEF number */
#define SYMSCALE        4               /* Symbol table address scale factor */
#define SYMMAX          2048            /* Max. no. of symbols */
#define STKSIZ          0x2000          /* 8K stack needed */
#define TYPEFAR         0x61            /* Far communal variable */
#define TYPENEAR        0x62            /* Near communal variable */
#define TYPMAX          256             /* Max. no. of TYPDEFs */
#define TYSNABS         '\0'
#define TYSNSTACK       '\024'
#define TYSNCOMMON      '\030'
#define VFPNIL          0               /* Null hash bucket number */
#define BKTLNK          0               /* Offset of link word */
#define BKTCNT          1               /* Offset of count word */
#define BKTMAX          ((WORD) 65535)  /* Maximum number of buckets */
#define VEPNIL          0               /* Nil virtual entry point offset */
#define VNIL            0L              /* Virtual nil pointer */

/*
 *  Module flags
 */
#define FNEWOMF         0x01            /* Set if mod. has MS OMF extensions */
#define FPRETYPES       0x02            /* Set if COMMENT A0 subtype 07 was found */
#define DEF_EXETYPE_WINDOWS_MAJOR 3     /* Default version of windows */
#define DEF_EXETYPE_WINDOWS_MINOR 10


/*
 *  Segment flags
 */
#define FCODE           0x1             /* Set if the segment is a code seg */
#define FNOTEMPTY       0x2             /* Set if the segment is not empty */
#define FHUGE           0x4             /* Huge data segment attribute flag */
#define FCODE386        0x8             /* 386 code segment */

/*
 *  OMF Record types:
 */
#define BLKDEF          0x7A            /* Block definition record */
#define THEADR          0x80            /* Module header record */
#define LHEADR          0x82            /* Module header record */
#define COMENT          0x88            /* COMmENT record */
#define MODEND          0x8A            /* MODule END record */
#define EXTDEF          0x8C            /* EXTernal DEFinition record */
#define TYPDEF          0x8E            /* TYPe DEFinition record */
#define PUBDEF          0x90            /* PUBlic DEFinition record */
#define LINNUM          0x94            /* LINe NUMbers record */
#define LNAMES          0x96            /* LNAMES record */
#define SEGDEF          0x98            /* SEGment DEFinition record */
#define GRPDEF          0x9A            /* GRouP DEFinition record */
#define FIXUPP          0x9C            /* Fixup record */
#define LEDATA          0xA0            /* Logical Enumerated DATA record */
#define LIDATA          0xA2            /* Logical Iterated DATA record */
#define COMDEF          0xB0            /* COMmunal DEFinition record */
#define BAKPAT          0xB2            /* BAcKPATch record */
#define LEXTDEF         0xB4            /* Local EXTDEF */
#define LPUBDEF         0xB6            /* Local PUBDEF */
#define LCOMDEF         0xB8            /* Local COMDEF */
#define CEXTDEF         0xbc            /* COMDAT EXTDEF */
#define COMDAT          0xc2            /* COMDAT - MS OMF Extension */
#define LINSYM          0xc4            /* Line numbers for COMDAT */
#define ALIAS           0xc6            /* ALIAS record */
#define NBAKPAT         0xc8            /* BAKPAT for COMDAT */
#define LLNAMES         0xca            /* Local LNAME */
#define LIBHDR          0xF0            /* Library header record type */
#define DICHDR          0xF1            /* Dictionary header type (F1H) */
#if OMF386
#define IsBadRec(r) (r < 0x6E || r > 0xca)
#else
#define IsBadRec(r) (r < 0x6E || r > 0xca || (r & 1) != 0)
#endif

#if _MSC_VER < 700
#define __cdecl         _cdecl
#endif

/*
*  Version-specific constants
*/
#if OIAPX286
#define DFSTBIAS        0x3F            /* Default bias of seg. table ref.s */
#endif
#if LIBMSDOS
#define sbPascalLib     "\012PASCAL.LIB"
                                        /* Pascal library name as SBTYPE */
#endif
#if LIBXENIX
#define MAGICARCHIVE    0177545         /* Magic number for archive */
#define ARHEADLEN       26              /* Length of archive header */
#define ARDICTLEN       (2 + ARHEADLEN) /* Length of archive dictionary */
#define ARDICTLOC       (2 + ARDICTLEN) /* Offset of archive dictionary */

/* Note:  Fields in the following struct definition are defined as
*  byte arrays for generality.  On the DEC20, for instance, a byte,
*  and a word and a long all use 36 bits; on the 8086, the corresponding
*  numbers are 8, 16, and 32 bits.  It is a shame to have to define
*  the record in such a fashion, but since there is no "standard,"
*  that's the way it goes.
*/
typedef struct
  {
    BYTE                arName[14];     /* Archive name */
    BYTE                arDate[4];      /* Archive date */
    BYTE                arUid;          /* User I.D. */
    BYTE                arGid;          /* Group I.D. */
    BYTE                arMode[2];      /* Mode */
    BYTE                arLen[4];       /* Length of archive */
  }
                        ARHEADTYPE;     /* Archive header type */
#endif

typedef BYTE            ALIGNTYPE;
typedef WORD            AREATYPE;
typedef BYTE            ATTRTYPE;
typedef BYTE            FIXUTYPE;
typedef BYTE            FTYPE;
typedef BYTE            GRTYPE;
typedef BYTE FAR        *HTETYPE;
typedef WORD            IOVTYPE;
typedef BYTE            KINDTYPE;
typedef WORD            LNAMETYPE;      /* LNAME index */
typedef void FAR        *PROPTYPE;
#if EXE386 OR OMF386
typedef DWORD           RATYPE;
#else
typedef WORD            RATYPE;
#endif
#if NEWSYM
typedef BYTE FAR        *RBTYPE;
#else
#if BIGSYM
typedef long            RBTYPE;
#else
typedef WORD            RBTYPE;
#endif
#endif
typedef WORD            RECTTYPE;
typedef WORD            SATYPE;
typedef WORD            SEGTYPE;
typedef WORD            SNTYPE;
typedef BYTE            TYSNTYPE;
#if MSGMOD
typedef WORD            MSGTYPE;
#else
typedef char            *MSGTYPE;
#endif

typedef struct _SYMBOLUSELIST
{
        int                     cEntries;               /* # of entries on the list */
        int                     cMaxEntries;    /* max # of entries on the list */
        RBTYPE          *pEntries;
}                       SYMBOLUSELIST;

typedef struct _AHTETYPE                /* Attribute hash table entry */
{
    RBTYPE              rhteNext;       /* Virt addr of next entry */
    ATTRTYPE            attr;           /* Attribute */
    RBTYPE              rprop;          /* Virt addr of property list */
    WORD                hashval;        /* Hash value */
    BYTE                cch[1];         /* Length-prefixed symbol */
}
                        AHTETYPE;

typedef struct _APROPTYPE               /* Property sheet */
{
    RBTYPE              a_next;         /* Link to next entry */
    ATTRTYPE            a_attr;         /* Attribute */
    BYTE                a_rgb[1];       /* Rest of record */
}
                        APROPTYPE;

typedef struct _APROPEXPTYPE
{
    RBTYPE              ax_next;        /* Next item in property list */
    ATTRTYPE            ax_attr;        /* Property cell type */
    RBTYPE              ax_symdef;      /* Pointer to PUBDEF or EXTDEF */
    WORD                ax_ord;         /* Export ordinal */
    SATYPE              ax_sa;          /* Segment number */
    RATYPE              ax_ra;          /* Offset in segment */
    BYTE                ax_nameflags;   /* Resident name/no name flag */
    BYTE                ax_flags;       /* Flag byte information */
    RBTYPE              ax_NextOrd;     /* Next item in export list */
}
                        APROPEXPTYPE;   /* Exported name type */

#if OSEGEXE
/*
 *  Format of ax_nameflags - flags used internaly by linker
 *
 *      7 6 5 4 3 2 1 0 - bit no
 *              | | | |
 *              | | | +-- resident name
 *              | | +---- discard name after processing
 *              | +------ forwarder
 *              +-------- constant export
 */

#define RES_NAME        0x01
#define NO_NAME         0x02
#define FORWARDER_NAME  0x04
#define CONSTANT        0x08

#endif

typedef struct _CONTRIBUTOR
{
    struct _CONTRIBUTOR FAR *next;      /* Next on list */
    DWORD           len;                /* Size of contribution */
    DWORD           offset;             /* Offset in logical segment */
    RBTYPE          file;               /* OBJ file descriptor */
}
    CONTRIBUTOR;


typedef struct _APROPSNTYPE
{
    RBTYPE              as_next;        /* Next item in property list */
    ATTRTYPE            as_attr;        /* Attribute */
#if OSEGEXE
    BYTE                as_fExtra;      /* Extra linker ONLY flags */
#endif
    DWORD               as_cbMx;        /* Size of segment */
    DWORD               as_cbPv;        /* Size of previous segment */
    SNTYPE              as_gsn;         /* Global SEGDEF number */
    GRTYPE              as_ggr;         /* Global GRPDEF number */
#if OVERLAYS
    IOVTYPE             as_iov;         /* Segment's overlay number */
#endif
    RBTYPE              as_rCla;        /* Pointer to segment class symbol */
    WORD                as_key;         /* Segment definition key */
#if OSEGEXE
#if EXE386
    DWORD               as_flags;
#else
    WORD                as_flags;
#endif
#else
    BYTE                as_flags;
#endif
    BYTE                as_tysn;        /* Segment's combine-type */
    CONTRIBUTOR FAR     *as_CHead;      /* Head of contributing .OBJ files list */
    CONTRIBUTOR FAR     *as_CTail;      /* Tail of contributing .OBJ files list */
    RBTYPE              as_ComDat;      /* Head of list of COMDATs allocated in this segment */
    RBTYPE              as_ComDatLast;  /* Tail of list of COMDATs allocated in this segment */
}
                        APROPSNTYPE;    /* SEGDEF property cell */

#if OSEGEXE
/*
 *  Format of as_fExtra - flags used internaly by linker
 *
 *      7 6 5 4 3 2 1 0 - bit no
 *              | | | |
 *              | | | +-- segment defined in the .DEF file
 *              | | +---- mixing use16 and use32 allowed
 *              | +------ don't pad this segment for /INCREMENTAL
 *              +-------- COMDAT_SEGx created by the linker
 */

#define FROM_DEF_FILE   0x01
#define MIXED1632       0x02
#define NOPAD           0x04
#define COMDAT_SEG      0x08

#endif

typedef struct _APROPNAMETYPE
{
    RBTYPE              an_next;
    ATTRTYPE            an_attr;
    RBTYPE              an_sameMod;     // Next PUBDEF from the same obj file
    WORD                an_CVtype;      // CodeView type index
                                        // Have to be in the order as in
                                        // struct _APROPUNDEFTYPE
    GRTYPE              an_ggr;
#if NEWLIST
    RBTYPE              an_rbNxt;
#endif
    SNTYPE              an_gsn;
    RATYPE              an_ra;
#if OVERLAYS
    RATYPE              an_thunk;       // Thunk offset - used by /DYNAMIC or EXE386
#endif
#if OSEGEXE
#if EXE386
    RBTYPE              an_nextImp;     /* Next import on the list */
    DWORD               an_thunk;       /* Address of the thunk */
    DWORD               an_name;        /* Imported procedure name offset */
    DWORD               an_entry;       /* Entry name offset or ordinal */
    DWORD               an_iatEntry;    /* Value stored in the Import Address Table */
    WORD                an_module;      /* Module directory entry index */
    WORD                an_flags;       /* Flags */
#else
    WORD                an_entry;       /* Entry name offset or ordinal */
    WORD                an_module;      /* Module name offset */
    BYTE                an_flags;       /* Flags for various attributes */
#endif                                  /* also used for imod if !(an_flags&FIMPORT) */
#endif

}
                        APROPNAMETYPE;

/*
 *  Format of an_flags
 *
 *  NOTE: 16-bit version is used only by link386
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 - bit no.
 *                  | | | | | | | | | | |
 *                  | | | | | | | | | | +-- public is an import
 *                  | | | | | | | | | +---- import by ordinal
 *                  | | | | | | | | +------ public identifier is printable
 *                  | | | | | +-+-+-------- floating-point special symbol type
 *                  | | | | +-------------- secondary floating-point special symbol
 *                  | | | +---------------- unreferenced public symbol
 *                  | | +------------------ 16-bit reference to imported symbol
 *                  | +-------------------- 32-bit reference to imported symbol
 *                  +---------------------- importing DATA symbol
 */

#define FIMPORT         0x01            /* Set if the public is an import */
#define FIMPORD         0x02            /* Set if the import ib by ordinal */
#define FPRINT          0x04            /* Set if public is printable */
#define FUNREF          0x80            /* Set if public is not referenced */
#define FFPMASK         0x38            /* Floating-point symbol mask */
#define FFPSHIFT        3               /* Shift constant to get to FFPMASK */
#define FFP2ND          0x40            /* Secondary f.p. symbol (FJxRQQ) */

#if EXE386
#define REF16           0x100           // 16-bit reference to imported symbol
#define REF32           0x200           // 32-bit reference to imported symbol
#define IMPDATA         0x400           // importing DATA symbol
#endif

typedef struct _APROPIMPTYPE
{
    RBTYPE              am_next;        /* Next property cell on list */
    ATTRTYPE            am_attr;        /* Property cell type */
#if EXE386
    DWORD               am_offset;      /* Offset in imported names table */
#else
    WORD                am_offset;      /* Offset in imported names table */
#endif
    WORD                am_mod;         /* Index into Module Reference Table */
#if SYMDEB
    APROPNAMETYPE FAR   *am_public;     /* Pointer to matching public symbol */
#endif
}
                        APROPIMPTYPE;   /* Imported name record */

typedef struct _APROPCOMDAT
{
    RBTYPE      ac_next;                /* Next property cell on list */
    ATTRTYPE    ac_attr;                /* Property cell type */
    GRTYPE      ac_ggr;                 /* Global group index */
    SNTYPE      ac_gsn;                 /* Global segment index */
    RATYPE      ac_ra;                  /* Offset relative from COMDAT symbol */
    DWORD       ac_size;                /* Size of data block */
    WORD        ac_flags;               /* Low byte - COMDAT flags */
                                        /* High byte - linker exclusive flags */
#if OVERLAYS
    IOVTYPE     ac_iOvl;               /* Overlay number where comdat has to be allocated */
#endif
    BYTE        ac_selAlloc;            /* Selection/Allocation criteria */
    BYTE        ac_align;               /* COMDAT aligment if different from segment aligment */
    DWORD       ac_data;                /* Data block check sum */
    RBTYPE      ac_obj;                 /* Object file */
    long        ac_objLfa;              /* Offset in the object file */
    RBTYPE      ac_concat;              /* Concatenation data blocks */
    RBTYPE      ac_sameSeg;             /* Next COMDAT in the same segment */
    RBTYPE      ac_sameFile;            /* Next COMDAT from the same object file */
    RBTYPE      ac_order;               /* Next COMDAT on the ordered list */
    RBTYPE      ac_pubSym;              /* PUBDEF for this COMDAT */
#if TCE
        SYMBOLUSELIST   ac_uses;                        /* List of referenced functions */
        int                     ac_fAlive;                      /* The result of TCE, TRUE if this COMDAT is needed
                                                                                /* in the final memory image */
#endif
}
                APROPCOMDAT;

/*
 *  Format of ac_flags:
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 - bit no
 *         |  |  |  | | |         | | | |
 *         |  |  |  | | |         | | | +-- continuation bit
 *         |  |  |  | | |         | | +---- iterated data bit
 *         |  |  |  | | |         | +------ COMDAT symbol has local scope
 *         |  |  |  | | |         +-------- allocate in the root when doing overlays
 *         |  |  |  | | +------------------ COMDAT for ordered procedure
 *         |  |  |  | +-------------------- definition of ordered COMDAT found among .OBJ files
 *         |  |  |  +---------------------- anonymus allocation completed
 *         |  |  +------------------------- referenced COMDAT
 *         |  +---------------------------- selected copy of COMDAT
 *         +------------------------------- skip continuation records
 */

#define CONCAT_BIT      0x01
#define ITER_BIT        0x02
#define LOCAL_BIT       0x04
#define VTABLE_BIT      0x08
#define ORDER_BIT       0x10
#define DEFINED_BIT     0x20
#define ALLOCATED_BIT   0x40
#define REFERENCED_BIT  0x80
#define SELECTED_BIT    0x100
#define SKIP_BIT        0x200

/*
 *  Format of ac_selAlloc:
 *
 *      7 6 5 4 3 2 1 0 - bit no
 *      | | | | | | | |
 *      | | | | +-+-+-+-- allocation criteria
 *      +-+-+-+---------- selection criteria
 */

#define SELECTION_MASK  0xf0
#define ALLOCATION_MASK 0x0f
#define ONLY_ONCE       0x00
#define PICK_FIRST      0x10
#define SAME_SIZE       0x20
#define EXACT           0x30
#define EXPLICIT        0x00
#define CODE16          0x01
#define DATA16          0x02
#define CODE32          0x03
#define DATA32          0x04
#define ALLOC_UNKNOWN   0x05


typedef struct _APROPALIAS
{
    RBTYPE      al_next;                // Next property cell on list
    ATTRTYPE    al_attr;                // Property cell type
    RBTYPE      al_sameMod;             // Next ALIAS/PUBDEF from the same obj file
    RBTYPE      al_sym;                 // Substitute symbol
}
                APROPALIAS;

#if SYMDEB

typedef struct _CVCODE
{
    struct _CVCODE FAR  *next;          // Next code segment
    RATYPE              cb;             // Length of code segment
    SEGTYPE             seg;            // Logical segment index
    RATYPE              ra;             // Offset in the logical code segment
}
                        CVCODE;         // Code segment descriptor for CV

typedef struct _CVINFO
{
    DWORD               cv_cbTyp;       // Length of $$TYPES
    BYTE FAR            *cv_typ;        // $$TYPES
    DWORD               cv_cbSym;       // Length of $$SYMBOLS
    BYTE FAR            *cv_sym;        // $$SYMBOLS
}
                        CVINFO;

#endif

typedef struct _APROPFILETYPE
{
    RBTYPE              af_next;        /* Next in chain */
    ATTRTYPE            af_attr;        /* Attribute number */
    IOVTYPE             af_iov;         /* Overlay number */
    RBTYPE              af_FNxt;        /* Next file in list */
    long                af_lfa;         /* Starting address in file */
    RBTYPE              af_rMod;        /* Pointer to module name symbol */
    BYTE                af_flags;       /* Info about module */
#if SYMDEB
    CVINFO FAR          *af_cvInfo;     // CodeView information
    WORD                af_cCodeSeg;    // Number of code segments
    struct _CVCODE FAR  *af_Code;       // List of code segments
    struct _CVCODE FAR  *af_CodeLast;   // Tail of the list of code segments
    RBTYPE              af_publics;     // List of public symbols
    struct _CVSRC FAR   *af_Src;        // List of source lines
    struct _CVSRC FAR   *af_SrcLast;    // Tail of the list of source lines
#endif
    RBTYPE              af_ComDat;      /* First COMDAT picked from this object module */
    RBTYPE              af_ComDatLast;  /* Last on the list */
#if ILINK
    WORD                af_cont;        /* count of contributions */
    WORD                af_ientOnt;     /* first index of ENTONTTYPEs */
    WORD                af_imod;        /* module index */
#define IMODNIL         ((WORD) 0)
#endif
    char                af_ifh;         /* Library number */
#if NEWIO
    char                af_fh;          /* File handle */
#endif
}
                        APROPFILETYPE;  /* File property cell */


#if SYMDEB

typedef struct _GSNINFO
{
    SNTYPE              gsn;            // Global contribution index
    RATYPE              comdatRa;       // COMDAT offset
    DWORD               comdatSize;     // COMDAT size
    WORD                comdatAlign;    // COMDAT alignment
    WORD                fComdat;        // TRUE if COMDAT gsn
}
                        GSNINFO;

#if FALSE
typedef struct _CVIMP
{
    WORD                iMod;           /* Index to Module Reference Table */
#if EXE386
    DWORD               iName;          /* Index to Imported Name Table */
#else
    WORD                iName;          /* Index to Imported Name Table */
#endif
    char far            *address;       /* Address of import */
}
                        CVIMP;          /* Import descriptor for CV */
#endif
#endif


typedef struct _APROPGROUPTYPE
{
    RBTYPE              ag_next;        /* Next in chain */
    ATTRTYPE            ag_attr;        /* Attribute */
    BYTE                ag_ggr;         /* Global GRPDEF number */
}
                        APROPGROUPTYPE; /* GRPDEF property cell */

typedef struct _PLTYPE                  /* Property list type */
{
    struct _PLTYPE FAR  *pl_next;       /* Link to next in chain */
    RBTYPE              pl_rprop;       /* Symbol table pointer */
}
                        PLTYPE;

typedef struct _APROPUNDEFTYPE
{
    RBTYPE              au_next;        /* Next in chain */
    ATTRTYPE            au_attr;        /* Attribute */
    RBTYPE              au_sameMod;     // Next COMDEF from the same obj file
    WORD                au_CVtype;      // CodeView type index
                                        // Have to be in the same order as in
                                        // struct _APROPNAMETYPE
    ATTRTYPE            au_flags;       /* Flags */
    RBTYPE              au_Default;     /* Default resolution for weak externs */
    union
    {
        /* The union of these fields assumes that au_fFil is only used
         * for a list of references to an unresolved external.  Au_module
         * is used for COMDEFs, which are always resolved.
         */
        WORD            au_module;      /* Module index */
        PLTYPE FAR      *au_rFil;       /* List of file references */
    }                   u;
    long                au_len;         /* Length of object */
    WORD                au_cbEl;        /* Size of an element in bytes */
#if TCE
    int                 au_fAlive;         /* Set is referenced from non-COMDAT record */
#endif
}
                        APROPUNDEFTYPE; /* Undefined symbol property cell */

/*
 *  Format of au_flags
 *
 *       7 6 5 4 3 2 1 0  - bit no
 *           | | | | | |
 *           | | | | | +--- C communal
 *           | | | | +----- weak external - au_Default valid
 *           | | | +------- undecided yet
 *           | | +--------- strong external - au_Default invalid
 *           | +----------- aliased external - au_Default point to ALIAS record
 *           +------------- search library for aliased external
 */

#define COMMUNAL    0x01                /* C communal */
#define WEAKEXT     0x02                /* Weak external - use default resolution */
#define UNDECIDED   0x04                /* Undecided yet but don't throw away default resolution */
#define STRONGEXT   0x08                /* Strong external - don't use default resolution */
#define SUBSTITUTE  0x10                /* Aliased external - use au_Dafault to find ALIAS */
#define SEARCH_LIB  0x20                /* Search library for aliased external */

typedef struct _EPTYPE                  /* Entry point type */
{
    struct _EPTYPE FAR *ep_next;        /* Link to next in chain */
    WORD                ep_sa;          /* Segment containing entry point */
    DWORD               ep_ra;          /* Offset of entry point */
    WORD                ep_ord;         /* Entry Table ordinal */
}
                        EPTYPE;


#define CBHTE           (sizeof(AHTETYPE))
#define CBPROPSN        (sizeof(APROPSNTYPE))
#define CBPROPNAME      (sizeof(APROPNAMETYPE))
#define CBPROPFILE      (sizeof(APROPFILETYPE))
#define CBPROPGROUP     (sizeof(APROPGROUPTYPE))
#define CBPROPUNDEF     (sizeof(APROPUNDEFTYPE))
#define CBPROPEXP       (sizeof(APROPEXPTYPE))
#define CBPROPIMP       (sizeof(APROPIMPTYPE))
#define CBPROPCOMDAT    (sizeof(APROPCOMDAT))
#define CBPROPALIAS     (sizeof(APROPALIAS))

#define UPPER(b)        (b >= 'a' && b <= 'z'? b - 'a' + 'A': b)
                                        /* Upper casing macro */
#if OSMSDOS
#define sbDotDef        "\004.def"      /* Definitions file extension */
#define sbDotCom        "\004.com"      /* COM file extension */
#define sbDotExe        "\004.exe"      /* EXE file extension */
#define sbDotLib        "\004.lib"      /* Library file extension */
#define sbDotMap        "\004.map"      /* Map file extension */
#define sbDotObj        "\004.obj"      /* Object file extension */
#define sbDotDll        "\004.dll"      /* Dynlink file extension */
#define sbDotQlb        "\004.qlb"      /* Quick library extension */
#define sbDotDbg        "\004.dbg"      /* Cv info for .COM */
#if EXE386
#define sbFlat          "\004FLAT"      /* Pseudo-group name */
#endif
#endif
#if OSXENIX
#define sbDotDef        "\004.def"      /* Definitions file extension */
#define sbDotExe        "\004.exe"      /* EXE file extension */
#define sbDotCom        "\004.com"      /* COM file extension */
#define sbDotLib        "\004.lib"      /* Library file extension */
#define sbDotMap        "\004.map"      /* Map file extension */
#define sbDotObj        "\004.obj"      /* Object file extension */
#define sbDotDll        "\004.dll"      /* Dynlink file extension */
#define sbDotQlb        "\004.qlb"      /* Quick library extension */
#endif
#if M_WORDSWAP AND NOT M_BYTESWAP
#define CBEXEHDR        sizeof(struct exe_hdr)
#define CBLONG          sizeof(long)
#define CBNEWEXE        sizeof(struct new_exe)
#define CBNEWRLC        sizeof(struct new_rlc)
#define CBNEWSEG        sizeof(struct new_seg)
#define CBWORD          sizeof(WORD)
#else
#define CBEXEHDR        _cbexehdr
#define CBLONG          _cblong
#define CBNEWEXE        _cbnewexe
#define CBNEWRLC        _cbnewrlc
#define CBNEWSEG        _cbnewseg
#define CBWORD          _cbword
extern char             _cbexehdr[];
extern char             _cblong[];
extern char             _cbnewexe[];
extern char             _cbnewrlc[];
extern char             _cbnewseg[];
extern char             _cbword[];
#endif

/*
 * Structure to represent floating-point symbols, i.e. FIxRQQ, FJxRQQ
 * pairs.
 */
struct fpsym
{
    BYTE                *sb;            /* Primary symbol, length-prefixed */
    BYTE                *sb2;           /* Secondary symbol, length-prefixed */
};

#if ECS
extern BYTE             fLeadByte[0x80];
#define IsLeadByte(b)   ((unsigned char)(b) >= 0x80 && \
                        fLeadByte[(unsigned char)(b)-0x80])
#endif

#ifdef _MBCS
#define IsLeadByte(b)   _ismbblead(b)
#endif


#if OSEGEXE
#if EXE386
#define RELOCATION      struct le_rlc
typedef struct le_rlc   *RLCPTR;
#define IsIOPL(f)       (FALSE)         /* Check if IOPL bit set */
#define Is32BIT(f)      (TRUE)          /* Check if 32-bit segment */
#define Is16BIT(f)      (!Is32BIT(f))   /* Check if 16-bit segment */
#define IsDataFlg(f)    (((f) & OBJ_CODE) == 0)
#define IsCodeFlg(f)    (((f) & OBJ_CODE) != 0)
#define RoundTo64k(x)   (((x) + 0xffffL) & ~0xffffL)
#else
#define RELOCATION      struct new_rlc
typedef struct new_rlc FAR *RLCPTR;
#define IsIOPL(f)       (((f) & NSDPL) == (2 << SHIFTDPL))
                                        /* Check if IOPL bit set */
#define Is32BIT(f)      (((f) & NS32BIT) != 0)
                                        /* Check if 32-bit code segment */
#define IsDataFlg(x)    (((x) & NSTYPE) == NSDATA)
#define IsCodeFlg(x)    (((x) & NSTYPE) == NSCODE)
#define IsConforming(x) (((x) & NSCONFORM) != 0)
#define NonConfIOPL(x)  (!IsConforming(x) && IsIOPL(x))
#endif

#define HASH_SIZE   128
#define BUCKET_DEF  4

typedef struct _RLCBUCKET
{
    WORD        count;                  // Number of relocations in the bucket
    WORD        countMax;               // Allocated size
    RLCPTR      rgRlc;                  // Run-time relocations
}
                RLCBUCKET;

typedef struct _RLCHASH                 // Hash vector for run-time relocations
{
    WORD        count;                  // Number of relocations
    RLCBUCKET FAR *hash[HASH_SIZE];     // Hash vector
}
                RLCHASH;


# if ODOS3EXE
extern FTYPE            fNewExe;
# else
#define fNewExe         TRUE
# endif
# endif

#if NOT OSEGEXE
#define fNewExe         FALSE
#define dfData          0
#define dfCode          FCODE
#define IsCodeFlg(x)    ((x & FCODE) != 0)
#define IsDataFlg(x)    ((x & FCODE) == 0)
#endif /* NOT OSEGEXE */

/*
 * TYPEOF = macro to get basic record type of records which may have
 * a 386 extension.  Used for LEDATA, LIDATA, and FIXUPP.
 */
#if OMF386
#define TYPEOF(r)       (r&~1)
#else
#define TYPEOF(r)       r
#endif

typedef AHTETYPE FAR            *AHTEPTR;
typedef APROPTYPE FAR           *APROPPTR;
typedef APROPEXPTYPE FAR        *APROPEXPPTR;
typedef APROPSNTYPE FAR         *APROPSNPTR;
typedef APROPNAMETYPE FAR       *APROPNAMEPTR;
typedef APROPIMPTYPE FAR        *APROPIMPPTR;
typedef APROPFILETYPE FAR       *APROPFILEPTR;
typedef APROPGROUPTYPE FAR      *APROPGROUPPTR;
typedef APROPUNDEFTYPE FAR      *APROPUNDEFPTR;
typedef APROPCOMDAT FAR         *APROPCOMDATPTR;
typedef APROPALIAS FAR          *APROPALIASPTR;

#ifdef O68K
#define MAC_NONE        0               /* Not a Macintosh exe */
#define MAC_NOSWAP      1               /* Not a swappable Macintosh exe */
#define MAC_SWAP        2               /* Swappable Macintosh exe */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\hsort.c ===
/*_________________________________________________________________*
     |                                                                 |
     |  MODULE                                                         |
     |                                                                 |
     |      HSORT                                                      |
     |      (C) Copyright Microsoft Corp 1988                          |
     |      10 March 1988                                              |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Sorting functions required by linker.                      |
     |                                                                 |
     |  DEFINES                                                        |
     |                                                                 |
     |      void     AllocSortBuffer(unsigned max, int AOrder)         |
     |      RBTYPE   ExtractMin(unsigned n)                            |
     |      void     FreeSortBuffer(void)                              |
     |      void     InitSort(RBTYPE **buf, WORD *base1, WORD *lim1,   |
     |                                      WORD *base2, WORD *lim2 )  |
     |      RBTYPE   GetSymPtr(unsigned n)                             |
     |      void     Store(RBTYPE element)                             |
     |                                                                 |
     |  USES                                                           |
     |                                                                 |
     |      cmpf     global pointer to comparing function              |
     |      AREASORT area in virtual memory where sort buffer is       |
     |               extended                                          |
     |                                                                 |
     |  CHANGES                                                        |
     |                                                                 |
     |      symMac   global counter of sorted symbols                  |
     |                                                                 |
     |  MODIFICATION HISTORY                                           |
     |                                                                 |
     |      88/03/10 Wieslaw Kalkus  Initial version                   |
     |                                                                 |
     |                                                                 |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Basic type & const declarations */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */


#define VMBuffer(x)     (RBTYPE *)mapva((long)(AREASORT+((long)(x)*sizeof(RBTYPE))),FALSE)
#define SORTDEBUG       FALSE

LOCAL  WORD             LastInBuf;      /* Last element in sort buffer */
LOCAL  RBTYPE           *SortBuffer;    /* Sort buffer allocated on near heap */
LOCAL  FTYPE            fVMReclaim;     /* TRUE if VM page buffers reclaimed */
LOCAL  FTYPE            fInMemOnly;     /* TRUE if not using VM for sort buffer */
LOCAL  FTYPE            fFirstTime = (FTYPE) TRUE;
LOCAL  WORD             SortIndex = 0;
LOCAL  int              (NEAR *TestFun)(RBTYPE *arg1, RBTYPE *arg2);
LOCAL  int              (NEAR *TestFunS)(RBTYPE *arg1, RBTYPE *arg2);

/*
 *  LOCAL FUNCTION PROTOTYPES
 */


LOCAL void NEAR SiftDown(unsigned n);
LOCAL void NEAR SiftUp(unsigned n);
LOCAL int  NEAR AscendingOrder(RBTYPE *arg1, RBTYPE *arg2);
LOCAL int  NEAR DescendingOrder(RBTYPE *arg1, RBTYPE *arg2);

/*
 *  DEBUGING FUNCTIONS
 */

#if SORTDEBUG

LOCAL void NEAR DumpSortBuffer(unsigned max, int faddr);
LOCAL void NEAR DumpElement(unsigned el, int faddr);
LOCAL void NEAR CheckSortBuffer(unsigned n, unsigned max);

LOCAL void NEAR CheckSortBuffer(unsigned root, unsigned max)
{
    DWORD       c;
    RBTYPE      child[2];
    RBTYPE      parent;
    RBTYPE      *VMp;



    c = root << 1;

    if (c > (long) max)
        return;

    /* c is the left child of root */

    if (c + 1 <= (long) max)
    {
        /* c + 1 is the right child of root */

        if (c > LastInBuf)
        {                   /* Fetch element from virtual memory */
            VMp = VMBuffer(c);
            child[0] = *VMp;
            VMp = VMBuffer(c + 1);
            child[1] = *VMp;
        }
        else
        {
            child[0] = SortBuffer[c];
            if (c + 1 > LastInBuf)
            {
                VMp = VMBuffer(c + 1);
                child[1] = *VMp;
            }
            else child[1] = SortBuffer[c+1];
        }

    }
    else
    {
        /* only left child of root */

        if (c > LastInBuf)
        {                   /* Fetch element from virtual memory */
            VMp = VMBuffer(c);
            child[0] = *VMp;
        }
        else child[0] = SortBuffer[c];
    }


    if (root > LastInBuf)
    {
        VMp = VMBuffer(root);
        parent = *VMp;
    }
    else parent = SortBuffer[root];

    if (!(*TestFun)(&parent, &child[0]))
    {
        fprintf(stdout, "\r\nBAD sort buffer --> root = %u; left child = %lu \r\n", root, c);
        DumpElement(root, cmpf == FGtAddr);
        DumpElement(c, cmpf == FGtAddr);
    }

    if (c + 1 < (long) max)
    {
        if (!(*TestFun)(&parent, &child[1]))
        {
            fprintf(stdout, "\r\nBAD sort buffer --> root = %u; right child = %lu \r\n", root, c+1);
            DumpElement(root, cmpf == FGtAddr);
            DumpElement(c+1, cmpf == FGtAddr);
        }
    }
    CheckSortBuffer((unsigned) c, max);
    if (c + 1 < (long) max)
        CheckSortBuffer((unsigned) c+1, max);

    return;
}



LOCAL void NEAR DumpSortBuffer(unsigned max, int faddr)
{

    unsigned    x;

    for (x = 1; x <= max; x++)
    {
        fprintf(stdout, "SortBuffer[%u] = ", x);
        DumpElement(x, faddr);
        fprintf(stdout, " \r\n");
    }
}



LOCAL void NEAR DumpElement(unsigned el, int faddr)
{

    unsigned    i;
    RBTYPE      *VMp;
    RBTYPE      symp;
    AHTEPTR     hte;
    APROPNAMEPTR prop;
    char        name[40];
    union {
            long      vptr;             /* Virtual pointer */
            BYTE far  *fptr;            /* Far pointer     */
            struct  {
                      unsigned short  offset;
                                        /* Offset value    */
                      unsigned short  seg;
                    }                   /* Segmnet value   */
                      ptr;
          }
                        pointer;        /* Different ways to describe pointer */


    if (el > LastInBuf)
    {
        VMp = VMBuffer(el);
        symp = *VMp;
    }
    else
        symp = SortBuffer[el];


    pointer.fptr = (BYTE far *) symp;

    if(pointer.ptr.seg)                 /* If resident - segment value != 0 */
        picur = 0;                      /* Picur not valid */
    else
        pointer.fptr = (BYTE far *) mapva(AREASYMS + (pointer.vptr << SYMSCALE),FALSE);
                                    /* Fetch from virtual memory */

    if (faddr)                      /* If buffer sorted by addresses */
    {
        prop = (APROPNAMEPTR ) pointer.fptr;
        while (prop->an_attr != ATTRNIL)
        {
            pointer.fptr = (BYTE far *) prop->an_next;

            if(pointer.ptr.seg)                 /* If resident - segment value != 0 */
                picur = 0;                      /* Picur not valid */
            else
                pointer.fptr = (BYTE far *) mapva(AREASYMS + (pointer.vptr << SYMSCALE),FALSE);
                                            /* Fetch from virtual memory */
            prop = (APROPNAMEPTR ) pointer.fptr;
        }
    }

    hte = (AHTEPTR ) pointer.fptr;

    for (i = 0; i < B2W(hte->cch[0]); i++)
        name[i] = hte->cch[i+1];
    name[i] = '\0';
    fprintf(stdout, " %s ", name);
}

#endif

#if AUTOVM

/*
 *  A sorting algorithm:
 *
 *      for i := 1 to SymMax do
 *        begin
 *          { Insert element }
 *          SortBuffer[i] = pointer-to-symbol;
 *          SiftUp(i);
 *        end
 *
 *      for i := SymMax downto 2 do
 *        begin
 *          { Extract min element }
 *          Do-what-you-want-with SortBuffer[1] element;
 *          Swap(SortBuffer[1], SortBuffer[i]);
 *          SiftDown(i - 1);
 *        end
 */



    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      SiftUp                                                     |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Actual size of sorting heap.                               |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Placing an arbitrary element in SortBuffer[n] when         |
     |      SortBuffer[n-1] has a heap property will probably not      |
     |      yield the property heap(1, n) for the SortBuffer;          |
     |      establishing this property is the job of procedure SiftUp. |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


LOCAL void NEAR SiftUp(unsigned n)

{
    unsigned    i;
    unsigned    p;
    RBTYPE      child;
    RBTYPE      parent;
    RBTYPE      *VMp;


    /*
     *  Precondition: SortBuffer has property heap(1, n-1) and n > 0
     */

    i = n;

    for (;;)
    {
        /*
         * Loop invariant condition: SortBuffer has property heap(1, n)
         * except perhaps between "i" and its parent.
         */

        if (i == 1)
            return;             /* POSTCONDITION: SortBuffer HAS PROPERTY HEAP(1, N). */

        p = i >> 1;             /* p = i div 2 */

        if (i > LastInBuf)
        {                       /* Fetch element from virtual memory */
            VMp = VMBuffer(i);
            child = *VMp;
        }
        else child = SortBuffer[i];

        if (p > LastInBuf)
        {                       /* Fetch element from virtual memory */
            VMp = VMBuffer(p);
            parent = *VMp;
        }
        else parent = SortBuffer[p];

        if ((*TestFun)(&parent, &child))
            break;

        /* swap(p, i) */

        if (p > LastInBuf)
        {
            VMp = VMBuffer(p);
            *VMp = child;
            markvp();
        }
        else SortBuffer[p] = child;

        if (i > LastInBuf)
        {                       /* Fetch element from virtual memory */
            VMp = VMBuffer(i);
            *VMp = parent;
            markvp();
        }
        else SortBuffer[i] = parent;

#if SORTDEBUG
fprintf(stdout, " \r\nSIFTUP - swap ");
DumpElement(p, cmpf == FGtAddr);
fprintf(stdout, " with ");
DumpElement(i, cmpf == FGtAddr);
fprintf(stdout, " \r\n");
#endif
        i = p;
    }
    /* POSTCONDITION: SortBuffer HAS PROPERTY HEAP(1, N). */
    return;
}


    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      SiftDown                                                   |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Actual size of sorting heap.                               |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Assigning a new value to SortBuffer[1] leaves the          |
     |      SortBuffer[2 ... n] with heap property. Procedure          |
     |      SiftDown makes heap(SortBuffer[1 ... n]) true.             |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */



LOCAL void NEAR SiftDown(unsigned n)
{
    DWORD       i;
    DWORD       c;
    RBTYPE      child[2];
    RBTYPE      parent;
    RBTYPE      *VMp;


    /*
     *  Precondition: SortBuffer has property heap(2, n) and n > 0
     */

    i = 1L;

    for (;;)
    {
        /*
         * Loop invariant condition: SortBuffer has property heap(1, n)
         * except perhaps between "i" and its (0, 1 or 2) children.
         */

        c = i << 1;

        if (c > (DWORD) n)
            break;

        /* c is the left child of i */

        if (c + 1 <= (DWORD) n)
        {
            /* c + 1 is the right child of i */

            if (c > LastInBuf)
            {                   /* Fetch element from virtual memory */
                VMp = VMBuffer(c);
                child[0] = *VMp;
                VMp = VMBuffer(c + 1);
                child[1] = *VMp;
            }
            else
            {
                child[0] = SortBuffer[c];
                if (c + 1 > LastInBuf)
                {
                    VMp = VMBuffer(c + 1);
                    child[1] = *VMp;
                }
                else child[1] = SortBuffer[c+1];
            }

            if ((*TestFunS)(&child[1], &child[0]))
            {
                c++;
                child[0] = child[1];
            }
        }
        else
        {
            /* only left child of i */

            if (c > LastInBuf)
            {                   /* Fetch element from virtual memory */
                VMp = VMBuffer(c);
                child[0] = *VMp;
            }
            else child[0] = SortBuffer[c];
        }

        /* c is the least child of i */

        if (i > LastInBuf)
        {
            VMp = VMBuffer(i);
            parent = *VMp;
        }
        else parent = SortBuffer[i];

        if ((*TestFun)(&parent, &child[0]))
            break;

        /* swap(p, i) */

        if (i > LastInBuf)
        {
            VMp = VMBuffer(i);
            *VMp = child[0];
            markvp();
        }
        else SortBuffer[i] = child[0];

        if (c > LastInBuf)
        {
            VMp = VMBuffer(c);
            *VMp = parent;
            markvp();
        }
        else SortBuffer[c] = parent;

#if SORTDEBUG
fprintf(stdout, " \r\nSIFTDOWN - swap ");
DumpElement(i, cmpf == FGtAddr);
fprintf(stdout, " with ");
DumpElement(c, cmpf == FGtAddr);
fprintf(stdout, " \r\n");
#endif
        i = c;
    }

    /* POSTCONDITION: SortBuffer HAS PROPERTY HEAP(1, N). */

    return;
}

#endif

LOCAL int  NEAR AscendingOrder(RBTYPE *arg1, RBTYPE *arg2)
{
    return((*cmpf)(arg1, arg2) <= 0);
}


LOCAL int  NEAR DescendingOrder(RBTYPE *arg1, RBTYPE *arg2)
{
    return((*cmpf)(arg1, arg2) >= 0);
}

LOCAL int  NEAR AscendingOrderSharp(RBTYPE *arg1, RBTYPE *arg2)
{
    return((*cmpf)(arg1, arg2) < 0);
}


LOCAL int  NEAR DescendingOrderSharp(RBTYPE *arg1, RBTYPE *arg2)
{
    return((*cmpf)(arg1, arg2) > 0);
}


    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      ExtractMin                                                 |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Actual size of sorting heap.                               |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Get smallest element from SortBuffer and reheap if         |
     |      neccesary. Function takes into account fact that           |
     |      SortBuffer can be allocated only in "real" memory and if   |
     |      this is true, than QUICKSORT is used instead of HEAPSORT.  |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Pointer to smallest element from SortBuffer.               |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


RBTYPE NEAR     ExtractMin(unsigned n)
{

    RBTYPE      *VMp;
    RBTYPE      RetVal;


    if (fInMemOnly)
    {
        if (fFirstTime)
        {
            /* First time called - sort buffer */

            qsort(SortBuffer, symMac, sizeof(RBTYPE),
                  (int (__cdecl *)(const void *, const void *)) cmpf);
            fFirstTime = FALSE;
        }

        RetVal = SortBuffer[SortIndex++];

        if (SortIndex >= symMac)
        {
            /* Last element extracted - reset flags and counters */

            fFirstTime = (FTYPE) TRUE;
            SortIndex = 0;
        }
    }
#if AUTOVM
    else
    {
        RetVal = SortBuffer[1];

#if SORTDEBUG
fprintf(stdout, " \r\nAFTER EXTRACTING element ");
DumpElement(1, cmpf == FGtAddr);
#endif

        if (n > LastInBuf)
        {
            VMp = VMBuffer(n);
            SortBuffer[1] = *VMp;
        }
        else
            SortBuffer[1] = SortBuffer[n];

        SiftDown(n - 1);

#if SORTDEBUG
fprintf(stdout, "\r\nVerifying Sort Buffer - size = %u ", n-1);
CheckSortBuffer(1,n-1);
#endif
    }
#endif
    return(RetVal);
}



    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      Store                                                      |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Element to be put in SortBuffer                            |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Put element into SortBuffer and reheap if neccesary.       |
     |      Function takes into account fact that SortBuffer can be    |
     |      allocated only in "real" memory.                           |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */



void NEAR       Store(RBTYPE element)
{

    RBTYPE      *VMp;


#if AUTOVM
    if (fInMemOnly)
    {
        SortBuffer[symMac++] = element;
    }
    else
    {
        symMac++;
        if (symMac > LastInBuf)
        {
            VMp = VMBuffer(symMac);
            *VMp = element;
            markvp();
        }
        else
            SortBuffer[symMac] = element;

#if SORTDEBUG
fprintf(stdout, " \r\nAFTER ADDING element ");
DumpElement(symMac, cmpf == FGtAddr);
#endif

         SiftUp(symMac);

#if SORTDEBUG
fprintf(stdout, "\r\nVerifying Sort Buffer - size = %u ", symMac);
CheckSortBuffer(1,symMac);
#endif
    }
#else
    SortBuffer[symMac++] = element;
#endif
    return;
}



    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      InitSort                                                   |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Initialize global variables used by INCREMENTAL module.    |
     |      Function takes into account fact that SortBuffer can be    |
     |      allocated only in "real" memory and if this is true than   |
     |      QUICKSORT instead of HEAPSORT to sort the SortBuffer.      |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

void NEAR       InitSort(RBTYPE **buf, WORD *base1, WORD *lim1,
                                       WORD *base2, WORD *lim2 )
{

    RBTYPE      *VMp;
    RBTYPE      first, last;
    unsigned    n, lx;


    if (fInMemOnly)
    {
        /* SortBuffer allocated only in "real" memory - use QUICKSORT */

        qsort(SortBuffer, symMac, sizeof(RBTYPE),
              (int (__cdecl *)(const void *, const void *)) cmpf);
        *base1 = 0;
        *lim1  = symMac;
        *base2 = symMac + 1;
        *lim2  = symMac + 1;
    }
#if AUTOVM
    else
    {
        /* SortBuffer allocated in "real" and "virtual" memory - use HEAPSORT */

        for (n = 1, lx = symMac; lx > 2; n++, lx--)
        {
            if (lx > LastInBuf)
            {
                VMp = VMBuffer(lx);
                last = *VMp;
            }
            else
                last = SortBuffer[lx];

            first = SortBuffer[1];
            SortBuffer[1] = last;

            if (lx > LastInBuf)
            {
                *VMp = first;
                markvp();
            }
            else
                SortBuffer[lx] = first;

            SiftDown(lx - 1);
        }

        first = SortBuffer[1];
        SortBuffer[1] = SortBuffer[2];
        SortBuffer[2] = first;
        *base1 = 1;
        *lim1  = (symMac < LastInBuf) ? symMac + 1 : LastInBuf + 1;
        *base2 = *lim1;
        *lim2  = symMac + 1;
    }
#endif

    *buf   = SortBuffer;
}



#if AUTOVM

    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      GetSymPtr                                                  |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Index in SortBuffer.                                       |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Get element from "virtual" portion of SortBuffer.          |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Retrieved element.                                         |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

RBTYPE NEAR     GetSymPtr(unsigned n)
{
    RBTYPE      *VMp;
    RBTYPE      RetVal;

    VMp = VMBuffer(n);
    RetVal = *VMp;
    return(RetVal);
}

#endif

    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      AllocSortBuffer                                            |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Max number of elements to be sorted and sorting order flag.|
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Allocate space for SortBuffer and set pointer to test      |
     |      function accordingly to sorting order flag.                |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

void NEAR       AllocSortBuffer(unsigned max, int AOrder)
{

    extern short pimac;
    unsigned long        SpaceAvail;
    unsigned long        SpaceNeeded;
    unsigned long        VMBufferSize;

    /*
     *  Determine how much space is available on near heap and how much
     *  we need. Assume ascending sort order.  Set number of elements
     *  in "real" portion of SortBuffer.
     */

    SpaceNeeded = (long)(max + 1) * sizeof(RBTYPE);
    LastInBuf   = (WORD) max;
    fInMemOnly  = (FTYPE) TRUE;
    TestFun     = AscendingOrder;
    TestFunS    = AscendingOrderSharp;
#if OSMSDOS AND AUTOVM
    SpaceAvail  = _memmax();

    if (SpaceNeeded > SpaceAvail)
    {
        /*
         *  We need more than there is available - try deallocate
         *  VM page buffers
         */

        if (pimac > 8)
        {
            /* For perfomance reasons we need at least 8 page buffer */

            VMBufferSize = 8 * PAGLEN;

            /* Cleanup near heap by relaiming all virtual memory page buffers */

            FreeMem(ReclaimVM(MAXBUF * PAGLEN));
        }
        else
            VMBufferSize = 0;

        /* Check how much is now available */

        SpaceAvail = _memmax() - VMBufferSize;

        if (SpaceNeeded > SpaceAvail)
            fInMemOnly = FALSE;
            /* Sorting buffer will be split between "real" and "virtual" memory */
        else
            SpaceAvail = SpaceNeeded;

        /* Calculate how many elements can go into "real" part of SortBuffer */

        LastInBuf = (unsigned)SpaceAvail / sizeof(RBTYPE);

        /* Allocate space for SortBuffer */

        SortBuffer = (RBTYPE *) GetMem(LastInBuf * sizeof(RBTYPE));

        LastInBuf--;
        fVMReclaim = (FTYPE) TRUE;

        /*
         *  If descending sort order was requested and SortBuffer is split
         *  between "real" and "virtual" memory change test function.
         */

        if (!fInMemOnly && !AOrder)
        {
            TestFun  = DescendingOrder;
            TestFunS = DescendingOrderSharp;
        }

        return;
    }
#endif
    /* There is space available so take it. */

    SortBuffer = (RBTYPE *) GetMem((unsigned)SpaceNeeded);
    fVMReclaim = FALSE;
    return;
}



    /*_________________________________________________________________*
     |                                                                 |
     |  NAME                                                           |
     |                                                                 |
     |      FreeSortBuffer                                             |
     |                                                                 |
     |  INPUT                                                          |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |  FUNCTION                                                       |
     |                                                                 |
     |      Free space allocated for SortBuffer and if neccesary       |
     |      perform near heap cleanup by reclaiming all VM             |
     |      page buffers.                                              |
     |                                                                 |
     |  RETURNS                                                        |
     |                                                                 |
     |      Nothing.                                                   |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

void NEAR       FreeSortBuffer(void)
{
    extern short pimac, pimax;


    if (SortBuffer != NULL)
        FFREE(SortBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\extern.h ===
/*
*       Copyright Microsoft Corporation, 1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
/*
 *      EXTERN.H:  external declarations
 */


#include <malloc.h>
#include <memory.h>
#if NOT OSXENIX
#include <io.h>
#include <stdlib.h>
#endif
#include <string.h>
#include <search.h>

#ifdef _MBCS
#define _CRTVAR1
#include <mbctype.h>
#include <mbstring.h>
#define         strchr  _mbschr
#define         strrchr _mbsrchr
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200)
#define DECLSPEC_NORETURN __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif


 /****************************************************************
 *                                                               *
 *      External function declarations                           *
 *                                                               *
 ****************************************************************/


extern void             AddContribution(unsigned short gsn,
                                        unsigned short offMin,
                                        unsigned short offMac,
                                        unsigned short cbPad);
extern void             AddContributor(SNTYPE gsn,
                                       unsigned long raComdat,
                                       unsigned long size);
extern void NEAR        AddLibPath(unsigned short i);
extern void             AddLibrary(unsigned char *psbName);
extern void             AddComdatUses(APROPCOMDAT*, APROPCOMDAT*);
extern PLTYPE FAR * NEAR AddVmProp (PLTYPE FAR *list, RBTYPE rprop);
extern void NEAR        AllocateScratchSpace(void);
extern void NEAR        AllocComDat(void);
extern void NEAR        AllocSortBuffer(unsigned max, int AOrder);
extern void NEAR        AssignAddresses(void);
extern void NEAR        AssignDos3Addr(void);
extern void NEAR        AssignSegAddr(void);
extern void             AttachComdat(RBTYPE vrComdat, SNTYPE gsn);
extern void NEAR        BakPat(void);
extern void             BigEnSyms(void (*pproc)(APROPNAMEPTR papropName,
                                                RBTYPE       rhte,
                                                RBTYPE       rprop,
                                                WORD         fNewHte),
                                  ATTRTYPE attr);
#if QBLIB
extern void NEAR        BldQbSymbols(unsigned short gsnQbSym);
#endif
#if CMDMSDOS
extern void             BreakLine(unsigned char *psb,
                                  void (*pfunc)(unsigned char *psb),
                                  char sepchar);
#endif
extern void             ChkInput(void);
extern APROPSNPTR       CheckClass(APROPSNPTR apropSn, RBTYPE rhteClass);
#if OVERLAYS
extern void             CheckOvl(APROPSNPTR apropSn, WORD iovFile);
#endif
#if OEXE
extern void NEAR        Check_edata_end(SNTYPE gsnTop, SEGTYPE segTop);
extern void             CheckSegmentsMemory(void);
#if INMEM
extern void             ChkSum(WORD,BYTE FAR *,FTYPE);
#else
extern void             ChkSum(WORD,BYTE *, WORD);
#endif
#endif
#if FALSE
extern void             CheckSum (WORD cb, BYTE *pb, WORD fOdd);
#else
#define CheckSum(cb, pb, fOdd)
#endif
#if OSMSDOS
extern void             CleanupNearHeap(void);
#endif
extern void NEAR        ComDatRc1(void);
extern void NEAR        ComDatRc2(void);
extern void             CputcQC(int ch);
extern void             CputsQC(char *str);
extern void             CputcStd(int ch);
extern void             CputsStd(char *str);
#if EXE386
extern WORD NEAR        CrossingPage(RLCPTR rlcp);
#endif
extern short            CURDSK(void);
extern void             CtrlC(void);
#if SYMDEB
extern void NEAR        DoComdatDebugging(void);
extern void             DebPublic(RBTYPE rprop, WORD type);
extern void             DebMd2(void);
extern void             DeclareStdIds(void);
extern void NEAR        Define_edata_end(APROPSNPTR papropSn);
extern void             DisplayBanner(void);
extern WORD             DoDebSrc(void);
#endif
#if OSEGEXE
extern void NEAR        DoIteratedFixups(unsigned short cb,unsigned char *pb);
extern void             ProcesNTables(char *pName);
#endif
#if OSMSDOS
extern short            Dos3AllocMem(short *pcparMem);
#endif
extern void             Dos3FreeMem(short saMem);
extern void NEAR        DrivePass(void (NEAR *pProcessPass)(void));
extern void NEAR        DupErr(BYTE *sb);
extern void NEAR        EmitStub(void);
extern void             EndPack(void *prun);
extern void NEAR        EndRec(void);
extern PROPTYPE         EnterName(BYTE *,ATTRTYPE, WORD);
extern void             ErrPrefix(void);
extern RBTYPE NEAR      ExtractMin(unsigned n);
extern DECLSPEC_NORETURN  void cdecl       Fatal (MSGTYPE msg, ...);
extern unsigned char    FCHGDSK(int drive);
extern int       cdecl  FGtAddr(const RBTYPE    *rb1,
                                const RBTYPE    *rb2);
extern int       cdecl  FGtName(const RBTYPE    *rb1,
                                const RBTYPE    *rb2);
extern void             FindLib(char *sbLib);
extern void NEAR        FixBakpat(void);
extern void             FixComdatRa(void);
extern void NEAR        FixErrSub(MSGTYPE msg,
                                  RATYPE ra,
                                  WORD gsnFrame,
                                  WORD gsnTarget,
                                  RATYPE raTarget,
                                  FTYPE fErr);
extern void NEAR        FixOld(void);
extern void NEAR        FixNew(void);
#ifdef  LEGO
extern void NEAR        FixNewKeep(void);
#endif  /* LEGO */
extern void NEAR        FixOvlData(void);
extern void NEAR        FixRc2(void);
extern void             flskbd(void);
extern void cdecl       FmtPrint(char *fmt, ...);
extern unsigned char    fPathChr(char ch);
extern void NEAR        fpagcpy(char FAR *,char FAR *);
extern void             FreeHandle(void);
extern void NEAR        FreeSortBuffer(void);
extern void             FreeSymTab(void);
#if EXE386
extern void             FillInImportTable(void);
extern void             GenImportTable(void);
extern APROPSNPTR       GenSeg(unsigned char *sbName,
                               unsigned char *sbClass,
                               unsigned char ggr,
                               unsigned short fPublic);
#else
extern APROPSNPTR NEAR  GenSeg(unsigned char *sbName,
                               unsigned char *sbClass,
                               unsigned char ggr,
                               unsigned short fPublic);
#endif
extern void NEAR        GetBytes(unsigned char *pb,unsigned short n);
extern void NEAR        GetBytesNoLim(unsigned char *pb,unsigned short n);
extern char * NEAR      getdicpage(unsigned short pn);
extern WORD             GetGsnInfo(GSNINFO *pInfo);
extern AHTEPTR          GetHte(RBTYPE rprop);


#if CMDMSDOS
extern void NEAR        GetLibAll(unsigned char *sbLib);
extern void NEAR        GetLine(unsigned char *pcmdlin,char *prompt);
#endif
extern void             GetLineOff(WORD *pLine, RATYPE *pRa);
extern void NEAR        GetLocName(unsigned char *psb);
extern void             GetLocSb(BYTE *);

#if DEBUG_HEAP_ALLOCS
extern  BYTE FAR        *GETMEM(unsigned size, char* pFile, int Line);
#define GetMem(x)       GETMEM((x), __FILE__, __LINE__)
#define REALLOC(x, y)   REALLOC_((x), (y), __FILE__, __LINE__)
extern  void            *REALLOC_( void*, size_t, char* pFile, int Line);
extern  void            FreeMem(void*);
#else
extern BYTE FAR         *GetMem(unsigned size);
#define REALLOC         realloc
#define FreeMem(x)      free(x)
#endif


extern unsigned char * NEAR  GetPropName(void FAR *ahte);


#if defined(M_I386) OR defined( _WIN32 )
extern WORD             cbRec;          /* Size of object record in bytes */
extern BSTYPE           bsInput;        /* Current input file stream */
#else
extern WORD NEAR        Gets(void);
#endif
extern RBTYPE NEAR      GetSymPtr(unsigned n);
extern unsigned short   IFind(unsigned char *sb,unsigned char b);
#if SYMDEB
extern void NEAR        InitDeb1(void);
extern void             InitDbRhte(void);
extern void             InitializeWorld(void);
extern WORD NEAR        IsDebSeg(RBTYPE rhteClass, RBTYPE rhteSeg);
#endif
#if USE_REAL
extern int              IsDosxnt(void);
extern int              IsWin31(void);
#endif

extern void NEAR        InitEntTab(void);
extern void             InitP2Tabs (void);
#if QBLIB
extern void NEAR        InitQbLib(void);
#endif
extern void NEAR        InitSort(RBTYPE **buf, WORD *base1, WORD *lim1,
                                               WORD *base2, WORD *lim2 );
extern void             InitSym(void);
extern void             InitTabs(void);
extern void             initvm(void);
#if EXE386
extern void             InitVmBase(void);
#endif
extern DECLSPEC_NORETURN void NEAR        InvalidObject(void);

extern WORD NEAR        GetIndexHard(WORD imin,WORD imax);
extern WORD NEAR        GetIndex(WORD imin,WORD imax);
extern void             KillRunfile(void);
#if OEXE OR EXE386
extern void NEAR        LChkSum(unsigned short cb,unsigned char *pb);
#endif
extern DWORD NEAR       LGets(void);
extern void NEAR        LibEnv(void);
extern void NEAR        LibrarySearch(void);
extern void NEAR        LinRec2(void);
extern void NEAR        LNmRc1(WORD fLocal);
extern WORD NEAR        LookupLibSym(unsigned char *psb);
extern long NEAR        MakeHole(long cb);
extern void             MkPubSym(unsigned char *sb,
                                 unsigned char ggr,
                                 unsigned short gsn,
                                 RATYPE ra);
extern void NEAR        ModRc1(void);
#if EXE386
extern void             MoveToVm(unsigned short cb,
                                 unsigned char *obData,
                                 unsigned short seg,
                                 RATYPE ra);
#else
extern void NEAR        MoveToVm(unsigned short cb,
                                 unsigned char *obData,
                                 unsigned short seg,
                                 RATYPE ra);
#endif
#if OSEGEXE
extern unsigned short NEAR MpSaRaEto(unsigned short sa, RATYPE ra);
#endif
extern BYTE FAR * NEAR  msaNew(SEGTYPE seg);
extern BYTE FAR * NEAR  msaOld(SEGTYPE seg);
extern void             NewExport(unsigned char *sbEntry,
                                  unsigned char *sbInternal,
                                  unsigned short ordno,
                                  unsigned short flags);
#if EXE386
extern void             NewImport(unsigned char *sbEntry,
                                  unsigned long ordEntry,
                                  unsigned char *sbModule,
                                  unsigned char *sbInternal,
                                  unsigned short impFlags);
extern void NEAR        NewSeg(unsigned char *sbName,
                               unsigned char *sbClass,
                               unsigned short iOvl,
                               unsigned long flags);
#else
extern void             NewImport(unsigned char *sbEntry,
                                  unsigned short ordEntry,
                                  unsigned char *sbModule,
                                  unsigned char *sbInternal);
extern void NEAR        NewSeg(unsigned char *sbName,
                               unsigned char *sbClass,
                               unsigned short iOvl,
                               unsigned short flags);
#endif
#if OSEGEXE
extern BSTYPE           LinkOpenExe(BYTE *sbExe);
#endif
#if SYMDEB
extern void             OutDebSections(void);
#endif
extern void NEAR        OutDos3Exe(void);
extern void NEAR        OutEntTab(void);
extern void cdecl       OutError(MSGTYPE msg, ...);
extern void             OutFileCur(BSTYPE bs);
extern void NEAR        OutFixTab(SATYPE sa);
extern void             OutHeader(struct exe_hdr *prun);
#if FEXEPACK
extern void             OutPack(unsigned char *pb, unsigned cb);
extern long             Out5Pack(SATYPE sa, unsigned short *packed);
#endif
extern void             OutputIlk(void);
extern void NEAR        OutSas(void *mpsasec);
extern void NEAR        OutSegExe(void);
#if EXE386
extern void NEAR        OutExe386(void);
#endif
extern void cdecl       OutWarn (MSGTYPE msg, ...);
extern void             OutWord(unsigned short x);
#define OutVm(va,cb)    WriteExe(va, cb)
extern void NEAR        PadToPage(unsigned short align);
extern void NEAR        PatchStub(long lfahdr, long lfaseg);
extern void NEAR        pagein(REGISTER char *pb, unsigned short fpn);
extern void NEAR        pageout(REGISTER char *pb, unsigned short fpn);
extern void             ParseCmdLine(int argc,char * *argv);
extern void             ParseDeffile(void);
extern void             PeelFlags(unsigned char *psb);
extern void *           PInit(void);
extern void *           PAlloc(void *, int);
extern void             PFree(void *);
extern void             PReinit(void *);
extern void             PrintGroupOrigins(APROPNAMEPTR papropGroup,
                                          RBTYPE rhte,
                                          RBTYPE rprop,
                                          WORD fNewHte);
extern void             PrintMap(void);
#if QBLIB
extern void NEAR        PrintQbStart(void);
#endif
extern void             ProcFlag(unsigned char *psb);
extern void             ProcObject(unsigned char *psbObj);
extern void NEAR        ProcP1(void);
extern void NEAR        ProcP2(void);
extern int       cdecl  PromptQC(unsigned char *sbNew,
                                 MSGTYPE msg,
                                 int msgparm,
                                 MSGTYPE pmt,
                                 int pmtparm);
extern int       cdecl  PromptStd(unsigned char *sbNew,
                                  MSGTYPE msg,
                                  int msgparm,
                                  MSGTYPE pmt,
                                  int pmtparm);
extern PROPTYPE NEAR    PropAdd(RBTYPE  rhte,
                                unsigned char attr);
extern PROPTYPE NEAR    PropRhteLookup(RBTYPE  rhte,
                                       unsigned char attr,
                                       unsigned char fCreate);
extern RBTYPE   NEAR    RhteFromProp(APROPPTR aprop);
extern PROPTYPE NEAR    PropSymLookup(BYTE *, ATTRTYPE, WORD);
#if QBLIB
extern int       cdecl  QbCompSym(const RBTYPE *prb1,
                                  const RBTYPE *prb2);
#endif
#if USE_REAL
extern int      RelockConvMem(void);
extern void     RealMemExit(void);
extern int      MakeConvMemPageable(void);
#endif

#if AUTOVM
extern RBTYPE NEAR      RbAllocSymNode(unsigned short cb);
#else
extern RBTYPE NEAR      RbAllocSymNode(unsigned short cb);
#endif
extern char *           ReclaimVM(unsigned short cnt);
extern void             ReclaimScratchSpace(void);
extern void NEAR        RecordSegmentReference(SEGTYPE seg,
                                               RATYPE ra,
                                               SEGTYPE segDst);
extern int  NEAR        relscr(void);
extern void NEAR        ReleaseRlcMemory(void);
extern void             resetmax(void);
#if SYMDEB
extern void             SaveCode(SNTYPE gsn, DWORD cb, DWORD raInit);
#endif
#if OSEGEXE
#if EXE386
extern RATYPE NEAR      SaveFixup(SATYPE obj, DWORD page, RLCPTR rlcp);
extern void             EmitFixup(SATYPE objTarget, DWORD raTarget,
                                  WORD   locKind,   DWORD virtAddr);
#else
extern RATYPE NEAR      SaveFixup(unsigned short saLoc,
                                  RLCPTR rlcp);
#endif
#endif
extern unsigned short   SaveInput(unsigned char *psbFile,
                                  long lfa,
                                  unsigned short ifh,
                                  unsigned short iov);
extern void             SavePropSym(APROPNAMEPTR prop,
                                    RBTYPE rhte,
                                    RBTYPE rprop,
                                    WORD fNewHte);
extern WORD             SbCompare(unsigned char *ps1,
                                  unsigned char *ps2,
                                  unsigned short fncs);
extern unsigned char    SbSuffix(unsigned char *sb,
                                 unsigned char *sbSuf,
                                 unsigned short fIgnoreCase);
extern void             SbUcase(unsigned char *sb);
extern int  NEAR        SearchPathLink(char FAR *lpszPath, char *pszFile, int ifh, WORD fStripPath);
extern void             SetDosseg(void);
extern void NEAR        SetupOverlays(void);
extern BSTYPE NEAR      ShrOpenRd(char *pname);

#if NEWSYM
#if NOT NOASM AND (CPU8086 OR CPU286)
extern void             SmallEnSyms(void (*pproc)(APROPNAMEPTR papropName,
                                                  RBTYPE       rhte,
                                                  RBTYPE       rprop,
                                                  WORD         fNewHte),
                                    ATTRTYPE attr);
#endif
#endif /* NEWSYM */
#if NEWIO
extern int  NEAR        SmartOpen(char *sbInput, int ifh);
#endif
#if EXE386
extern void             SortPtrTable(void);
#endif
extern void NEAR        SortSyms(ATTRTYPE attr,
                                 void (*savf)(APROPNAMEPTR prop,
                                              RBTYPE rhte,
                                              RBTYPE rprop,
                                              WORD fNewHte),
                                 int (cdecl *scmpf)(const RBTYPE *sb1,
                                                    const RBTYPE *sb2),
                                 void (NEAR *hdrf)(ATTRTYPE attr),
                                 void (NEAR *lstf)(WORD irbMac,
                                                   ATTRTYPE attr));
extern void NEAR        Store(RBTYPE element);
#if SYMDEB OR OVERLAYS
extern unsigned char *  StripDrivePath(unsigned char *sb);
#endif
#if WIN_3
void cdecl               SysFatal (MSGTYPE msg);
#endif

extern void             StripPath(unsigned char *sb);
extern char *    cdecl  swapin(long vp,unsigned short fp);
extern void             termvm(void);
extern long NEAR        TypLen(void);
extern void             UndecorateSb (char FAR* sbSrc, char FAR* sbDst, unsigned cbDst);
extern void             UpdateComdatContrib(
#if ILINK
WORD fIlk,
#endif
WORD fMap);
extern void             UpdateFileParts(unsigned char *psbOld,
                                        unsigned char *psbUpdate);
extern void      cdecl  UserKill(void);
extern WORD NEAR        WGetsHard(void);
extern WORD NEAR        WGets(void);


#if CMDMSDOS
extern void NEAR        ValidateRunFileName(BYTE *ValidExtension,
                                            WORD ForceExtension,
                                            WORD WarnUser);
#endif
#if ( NOT defined( M_I386 ) ) AND ( NOT defined( _WIN32 ) )
extern void             WriteExe(void FAR *pb, unsigned cb);
#endif
extern void             WriteZeros(unsigned cb);
#if EXE386
extern DWORD            WriteExportTable(DWORD *expSize, DWORD timestamp);
extern DWORD            WriteImportTable(DWORD *impSize, DWORD timestamp, DWORD *mpsaLfa);
#endif
extern unsigned short   zcheck(unsigned char *pb,unsigned short cb);
extern int NEAR         yyparse(void);

/* No argument type lists */
extern char FAR         *brkctl();      /* Xenix call for new memory */
extern long NEAR        msa386(SATYPE sa);


/*
 * Version-dependent macro and function declarations.  Hide some #ifdef's
 * from the source code.
 */
#if NEWSYM
#if AUTOVM
extern BYTE FAR * NEAR  FetchSym(RBTYPE rb, WORD fDirty);
extern BYTE FAR * NEAR  FetchSym1(RBTYPE rb, WORD fDirty);
#define MARKVP()        markvp()
#else
#define FetchSym(a,b)   (a)
#define MARKVP()
#define markvp()
#endif
#if defined(M_I386) OR defined( _WIN32 )
#define GetFarSb(a)     (a)
#else
extern  char            *GetFarSb(RBTYPE psb);
#endif
#else
extern BYTE             *FetchSym(RBTYPE,FTYPE);
#define MARKVP()        markvp()
#define GetFarSb(a)     (BYTE *)(a)
#endif
#if NEWSYM
extern FTYPE NEAR       SbNewComp(BYTE *, BYTE FAR *, FTYPE);
extern void             OutSb(BSTYPE f, BYTE *pb);
#else
#define SbNewComp       SbCompare
#endif
#if ECS
extern int              GetTxtChr(BSTYPE bs);
#else
#define GetTxtChr(a)    getc(a)
#endif
#if NEWSYM AND NOT NOASM AND (CPU286 OR CPU8086)
extern void             (*pfEnSyms)(void (*pproc)(APROPNAMEPTR papropName,
                                                  RBTYPE       rhte,
                                                  RBTYPE       rprop,
                                                  WORD         fNewHte),
                                    ATTRTYPE attr);
#define EnSyms(a,b)     (*pfEnSyms)(a,b)
#else
#define EnSyms(a,b)     BigEnSyms(a,b)
#endif
#if OSMSDOS
extern FTYPE            fNoprompt;
#else
#define fNoprompt       TRUE
#endif


#if CPU8086 OR CPU286
#define FMALLOC         _fmalloc
#define FFREE           _ffree
#define FMEMSET         _fmemset
#define FREALLOC        _frealloc
#define FMEMCPY         _fmemcpy
#define FSTRLEN         _fstrlen
#define FSTRCPY         _fstrcpy
#else
#define FMALLOC         malloc
#define FFREE           free
#define FMEMSET         memset
#define FREALLOC        realloc
#define FMEMCPY         memcpy
#define FSTRLEN         strlen
#define FSTRCPY         strcpy
#endif

#if WIN_3
#define EXIT WinAppExit
extern FTYPE fSeverity; /* Severity for QW_ERROR message */
extern void ReportVersion(void );
extern void ErrorMsg( char *pszError );
extern void  __cdecl  ErrMsgWin (char *fmt);
extern void WErrorMsg( char *pszError );
extern void WinAppExit( short RetCode );
extern void ProcessWinArgs( char FAR *pszCmdLine );
extern void ParseLinkCmdStr( void );
extern void ReportProgress( char *pszStatus );
extern void SendPacket(void *pPacket);
extern void __cdecl StatMsgWin (char *fmt, int p1);
extern void StatHdrWin ( char *pszHdr );
extern void WinYield( void );
extern void CputcWin(int ch);
extern void CputsWin(char *str);
#else
#define EXIT exit
#endif



/****************************************************************
 *                                                              *
 *      External data declarations                              *
 *                                                              *
 ****************************************************************/

extern char FAR         *lpszLink;
extern char FAR         *lpszPath;
extern char FAR         *lpszTMP;
extern char FAR         *lpszLIB;
extern char FAR         *lpszQH;
extern char FAR         *lpszHELPFILES;
extern char FAR         *lpszCmdLine;
#if OSEGEXE
extern RBTYPE           procOrder;      /* Procedure order as defined in .DEF file */
#endif
extern BSTYPE           bsErr;          /* Error message file stream */
extern BSTYPE           bsInput;        /* Current input file stream */
extern BSTYPE           bsLst;          /* Listing (map) file stream */
extern BSTYPE           bsRunfile;      /* Executable file stream */
extern WORD             cbBakpat;       /* # bytes in backpatch area */
extern WORD             cbRec;          /* Size of object record in bytes */
extern WORD             cErrors;        /* Number of non-fatal errors */
extern int              (cdecl *cmpf)(const RBTYPE *sb1,
                                      const RBTYPE *sb2);
                                        /* Pointer to sorting comparator */
#if OMF386
extern FTYPE            f386;           /* True if 386 binary */
#endif
#if (OSEGEXE AND defined(LEGO)) OR EXE386
extern FTYPE            fKeepFixups;    /* TRUE if FLAT offset fixups have to be poropagated to the .EXE file */
#endif
#if EXE386
extern SNTYPE           gsnImport;      /* Global index of Import Address Table segment */
extern GRTYPE           ggrFlat;        /* Group number of pseudo-group FLAT */
extern FTYPE            fFullMap;       /* More map information */
extern FTYPE            fKeepVSize;     /* TRUE if VSIZE to be set */
#endif
extern WORD             extMac;         /* Count of EXTDEFs */
extern WORD             extMax;         /* Maximum number of EXTDEFs */
extern int              ExitCode;       /* Linker exit code */
extern FTYPE            fFullMap;       /* More map information */
extern FTYPE            fCommon;        /* True if any communal variables */
extern FTYPE            fC8IDE;                 /* True if running under C8 IDE */
extern FTYPE            fDelexe;        /* True if /DELEXECUTABLE is on */
extern FTYPE            fDrivePass;     /* True if executing DrivePass() */
extern FTYPE            fFarCallTrans;  /* True if /FARCALLTRANSLATION on */
extern FTYPE            fFarCallTransSave;
                                        /* Previous state of fFarCallTrans */
extern FTYPE            fIgnoreCase;    /* True if ignoring case */
extern FTYPE            fInOverlay;     /* True if parsing overlay spec */
extern FTYPE            fLibPass;       /* True if in library pass */
extern FTYPE            fLibraryFile;   /* True if input from library */
extern FTYPE            fListAddrOnly;  /* True if sorting by address only */
extern FTYPE            fLstFileOpen;   /* True of map file open */
extern FTYPE            fScrClosed;     /* True if scratch file closed */
extern FTYPE            fSkipFixups;    /* True if skipping COMDAT and its fixups */
extern FTYPE            fUndefinedExterns;
                                        /* True if any unresolved externals */
extern FTYPE            fExeStrSeen;    /* True if EXESTR comment seen */
extern FTYPE            fPackFunctions; /* True if elimination uncalled COMDATs */
#if TCE
extern FTYPE            fTCE;           /* True if /PACKF:MAX = Transitive Comdat Elimination */
#endif
#if USE_REAL
extern FTYPE            fUseReal;       /* True if using conv memory for paging */
extern FTYPE            fSwNoUseReal;   /* True if switch /NOUSEREAL set */
#endif

#if O68K
extern FTYPE            f68k;           /* True if target is a 68k */
extern FTYPE            fTBigEndian;    /* True if target is big-endian */
extern BYTE             iMacType;       /* Type of Macintosh exe */
#endif /* O68K */
extern GRTYPE           ggrDGroup;      /* Group number of DGROUP */
extern GRTYPE           ggrMac;         /* Count of global GRPDEFs */
extern GRTYPE           grMac;          /* Count of local GRPDEFs */
extern SNTYPE           gsnMac;         /* Count of global SEGDEFs */
extern SNTYPE           gsnMax;         /* Maximum number of SEGDEFs */
extern SNTYPE           gsnStack;       /* Glob. SEGDEF no. of STACK segment */
extern SNTYPE           gsnText;        /* Global SEGDEF for _TEXT segment */
extern WORD             ifhLibCur;      /* File index of current library */
extern WORD             ifhLibMac;      /* Count of library files */
extern long             lfaLast;        /* Last file position */
extern WORD             lnameMac;       /* Count of LNAMEs */
extern WORD             lnameMax;       /* Max count of LNAMEs */
extern unsigned char    LINKREV;        /* Release number */
extern unsigned char    LINKVER;        /* Version number */
extern WORD             modkey;         /* Module ID key */
extern SNTYPE           *mpextgsn;      /* f(EXTDEF no.) = glob. SEGDEF no. */
extern RATYPE           *mpextra;       /* f(EXTDEF no.) = symbol offset */
extern RBTYPE FAR       *mpextprop;     /* f(EXTDEF no.) = external name property */
extern SNTYPE           mpggrgsn[];     /* f(glob GRPDEF) = glob. SEGDEF no. */
extern GRTYPE           *mpgrggr;       /* f(loc. GRPDEF #) = glob. GRPDEF # */
#if FAR_SEG_TABLES
extern RATYPE  FAR      *mpgsndra;      /* f(glob SEGDEF) = segment offset */
extern BYTE    FAR      *mpgsnfCod;     /* f(glob SEGDEF) = true if code */
extern RBTYPE  FAR      *mpgsnrprop;    /* f(glob SEGDEF) = property cell */
extern SEGTYPE FAR      *mpgsnseg;      /* f(glob SEGDEF) = segment number */
extern RATYPE  FAR      *mpsegraFirst;  /* f(segment #) = offset of 1st byte */
extern SATYPE  FAR      *mpsegsa;       /* f(seg) = sa */
extern BYTE FAR * FAR   *mpsegMem;      /* f(segment) = memory image */
extern BYTE FAR * FAR   *mpsaMem;       /* f(segment) = memory image */
#else
extern RATYPE           *mpgsndra;      /* f(glob SEGDEF) = segment offset */
extern BYTE             *mpgsnfCod;     /* f(glob SEGDEF) = true if code */
extern RBTYPE           *mpgsnrprop;    /* f(glob SEGDEF) = property cell */
extern SEGTYPE          *mpgsnseg;      /* f(glob SEGDEF) = segment number */
extern RATYPE           *mpsegraFirst;  /* f(segment #) = offset of 1st byte */
extern SATYPE           *mpsegsa;       /* f(seg) = sa */
#endif
extern SNTYPE           *mpsngsn;       /* f(local SEGDEF) = global SEGDEF */
extern RBTYPE           mpifhrhte[];    /* f(lib. index) = library name */
extern long             *mpitypelen;    /* f(TYPDEF no.) = type length */
extern WORD             *mpityptyp;     /* f(TYPDEF no.) = TYPDEF no. */
extern RBTYPE FAR       *mplnamerhte;   /* f(LNAME no.) = hash table addr */
extern BYTE             *psbRun;        /* Name of run file */
extern WORD             pubMac;         /* Count of PUBDEFs */
extern APROPCOMDAT      *pActiveComdat;
extern int              QCExtDefDelta;  /* QC incremental compilation support */
extern int              QCLinNumDelta;  /* EXTDEF and LINNUM deltas */
extern WORD             symMac;         /* Number of symbols defined */
extern long             raStart;        /* Program starting address */
#if NOT NEWSYM OR AUTOVM
#if AUTOVM
extern WORD             rbMacSyms;
#else
extern RBTYPE           rbMacSyms;      /* Count of symbol table entries */
#endif
#endif
extern RECTTYPE         rect;           /* Current record type */
#if RGMI_IN_PLACE
extern BYTE             *rgmi;
extern BYTE             bufg[DATAMAX + 4];
#else
extern BYTE             rgmi[DATAMAX + 4];
#define bufg            rgmi
#endif
                                        /* Array of code or data */
extern RBTYPE           rhteBegdata;    /* "BEGDATA" */
extern RBTYPE           rhteBss;        /* "BSS" */
extern RBTYPE           rhteFirstObject;/* Name of first object file */
extern RBTYPE           rhteRunfile;    /* Name of run file */
extern RBTYPE           rhteStack;      /* "STACK" */
extern RBTYPE           rprop1stFile;   /* Property cell of 1st file */
extern RBTYPE           rprop1stOpenFile;/* Property cell of 1st open file */
extern RBTYPE           r1stFile;       /* 1st input file */
extern SBTYPE           sbModule;       /* Name of current module */
extern SEGTYPE          segCodeLast;    /* Last (highest) code segment */
extern SEGTYPE          segDataLast;    /* Last (highest) data segment */
extern SEGTYPE          segLast;        /* Last (highest) segment */
extern SEGTYPE          segStart;       /* Program starting segment */
extern WORD             snkey;          /* SEGDEF ID key */
extern SNTYPE           snMac;          /* Local count of SEGDEFs */
extern WORD             typMac;         /* Local count of TYPDEFs */
extern WORD             vcbData;        /* # bytes in data record */
extern WORD             vcln;           /* # line-no entries on line */
extern FTYPE            vfCreated;      /* True if symbol property created */
extern FTYPE            vfLineNos;      /* True if line numbers requested */
extern FTYPE            vfMap;          /* True if public symbols requeste */
extern FTYPE            vfNewOMF;       /* True if OMF extensions */
extern FTYPE            vfNoDefaultLibrarySearch;
                                        /* True if not searching def. libs. */
extern FTYPE            vfPass1;        /* True if executing Pass 1 */
extern SNTYPE           vgsnCur;        /* SEGDEF no. of current segment */
extern SNTYPE           vgsnLineNosPrev;/* Previous SEGDEF no. for linnums */
extern int              vmfd;           /* VM scratch file handle */
#if EXE386
extern DWORD            vpageCur;       /* Current object page number */
#endif
extern RATYPE           vraCur;         /* Current data record offset */
extern RECTTYPE         vrectData;      /* Type of current data record */
extern RBTYPE           vrhte;          /* Address of hash table entry */
extern RBTYPE           vrhteCODEClass; /* "CODE" */
extern RBTYPE           vrhteFile;      /* Name of current file */
extern RBTYPE           vrprop;         /* Address of property cell */
extern RBTYPE           vrpropFile;     /* Prop. cell of current file */
extern RBTYPE           vrpropTailFile; /* Prop. cell of last file */
extern SEGTYPE          vsegCur;        /* Current segment */
extern WORD             ExeStrLen;      // Length of EXE strings in buffer
extern WORD             ExeStrMax;      // Length of EXE strings buffer
extern char FAR         *ExeStrBuf;     // EXE strings buffer
#if FDEBUG
extern FTYPE            fDebug;         /* True if /INFORMATION on */
#endif
#if CMDXENIX
extern WORD             symlen;         /* Maximum symbol length */
#endif
#if OSMSDOS
extern char             bigbuf[LBUFSIZ];/* File I/O buffer */
extern FTYPE            fPauseRun;      /* True if /PAUSE */
extern BYTE             chRunFile;      /* Run file drive LETTER */
extern BYTE             chListFile;     /* List file drive NUMBER */
extern RBTYPE           rhteLstfile;    /* Name of list file */
extern BYTE             DskCur;         /* Default drive number */
#endif
#if C8_IDE
extern char             msgBuf[];       /* Message buffer */
#endif
#if LIBMSDOS
extern long             libHTAddr;      /* Offset of dictionary */
#endif
#if SYMDEB
extern FTYPE            fSkipPublics;   /* True if no public subsection */
extern FTYPE            fSymdeb;        /* True if /CODEVIEW */
extern FTYPE            fCVpack;        /* True if CV packing requested */
extern FTYPE            fTextMoved;     /* True if /DOSSEG & !/NONULLS */
extern int              NullDelta;      /* _TEXT was moved by so many bytes */
extern SEGTYPE          segDebFirst;    /* First debug segment */
extern SEGTYPE          segDebLast;     /* Last debug segment */
extern FTYPE            fDebSeg;        /* True if datarec from debug segment */
extern WORD             ObjDebTotal;    /* Total number of OBJ modules with debug info */
extern RBTYPE           rhteDebSrc;     /* Class "DEBSRC" virt addr */
extern RBTYPE           rhteDebSym;     /* Class "DEBSYM" virt addr */
extern RBTYPE           rhteDebTyp;     /* Class "DEBTYP" virt addr */
extern RBTYPE           rhteTypes;
extern RBTYPE           rhteSymbols;
extern RBTYPE           rhte0Types;
extern RBTYPE           rhte0Symbols;
#if OSEGEXE
extern WORD             cbImpSeg;       /* Size of $$IMPORTS segment */
extern SNTYPE           gsnImports;     /* $$IMPORTS global segment number */
extern char             bufExportsFileName[]; /* Name of exports file */
#endif
#endif
#if OSEGEXE
extern SNTYPE           gsnAppLoader;   /* Aplication loader global segment number */
extern RBTYPE           vpropAppLoader; /* Pointer to application loader name */
#if EXE386
extern DWORD            hdrSize;        /* Default size of .EXE header */
extern DWORD            virtBase;       /* Virtual base address of memory image */
extern DWORD            cbEntTab;       /* Count of bytes in Export Address Table */
extern DWORD            cbAuxTab;       /* Count of bytes in Auxiliary Data Table */
extern DWORD            cbNamePtr;      /* Count of bytes in Export Name Pointer Table */
extern DWORD            cbOrdinal;      /* Count of bytes in Export Ordinal Table */
extern DWORD            cbExpName;      /* Count of bytes in Export Name Table */
extern WORD             cGateSel;       /* Number of selectors required by call-gate exports */
extern DWORD            cbImports;      /* # bytes in Imported Names table */
extern DWORD            cbImportsMod;   /* # bytes in Imported Module Names table */
extern DWORD            *mpsaVMArea;    /* VM area for AREASA(sa) */
extern DWORD            *mpsaBase;      /* Base virtual address of memory object */
extern WORD             cChainBuckets;  /* Count of entry table chain buckets */
extern DWORD            cbStack;        /* Reserved size of stack in bytes */
extern DWORD            cbStackCommit;  /* Commited size of stack in bytes */
extern DWORD            cbHeap;         /* Reserved size of heap in bytes */
extern DWORD            cbHeapCommit;   /* Commited size of heap in bytes */
#else
extern WORD             cbEntTab;       /* Count of bytes in Entry Table */
extern WORD             cbImports;      /* # bytes in Imported Names table */
extern WORD             cbHeap;         /* Size of heap in bytes */
extern WORD             cbStack;        /* Size of stack in bytes */
#endif
extern WORD             cFixupBuckets;  /* Count of entry table buckets */
extern long             chksum32;       /* Long checksum */
extern WORD             cMovableEntries;/* Count of movable entries */
#if EXE386
extern DWORD            dfCode;         /* Default code segment attributes */
extern DWORD            dfData;         /* Default data segment attributes */
#else
extern WORD             dfCode;         /* Default code segment attributes */
extern WORD             dfData;         /* Default data segment attributes */
#endif
extern WORD             expMac;         /* Count of exported names */
extern FTYPE            fHeapMax;       /* True if heap size = 64k - size of DGROUP */
extern FTYPE            fRealMode;      /* True if REALMODE specified */
extern FTYPE            fStub;          /* True if DOS3 stub given */
extern FTYPE            fWarnFixup;     /* True if /WARNFIXUP */
extern BYTE             TargetOs;       /* Target operating system */
#if EXE386
extern BYTE             TargetSubsys;   /* Target operating subsystem */
extern BYTE             UserMajorVer;   /* User program version */
extern BYTE             UserMinorVer;   /* User program version */
#endif
extern BYTE             ExeMajorVer;    /* Executable major version number */
extern BYTE             ExeMinorVer;    /* Executable minor version number */
extern EPTYPE FAR * FAR *htsaraep;      /* Hash SA:RA to entry point */
extern DWORD FAR        *mpsacb;        /* f(sa) = # bytes */
#if O68K
extern DWORD            *mpsadraDP;     /* offset from start of segment to DP */
#endif
extern DWORD FAR        *mpsacbinit;    /* f(sa) = # initialized bytes */
#if EXE386
extern DWORD            *mpsacrlc;      /* f(sa) = # relocations */
extern DWORD            *mpsaflags;     /* f(sa) = segment attributes */
extern WORD             *mpextflags;    /* f(glob. EXTDEF) = flags */
#else
extern RLCHASH FAR * FAR *mpsaRlc;      /* f(sa) = relocations hash vector */
extern WORD FAR         *mpsaflags;     /* f(sa) = segment attributes */
extern BYTE FAR         *mpextflags;    /* f(glob. EXTDEF) = flags */
#endif
extern WORD             raChksum;       /* Offset for checksum */
extern RBTYPE           rhteDeffile;    /* Name of definitions file */
extern RBTYPE           rhteModule;     /* Name of module */
extern RBTYPE           rhteStub;       /* Name of DOS3 stub program */
extern WORD             fileAlign;      /* Segment alignment shift count */
#if EXE386
extern WORD             pageAlign;      /* Page alignment shift count */
extern WORD             objAlign;       /* Memory object alignment shift count */
#endif
extern SATYPE           saMac;          /* Count of physical segments */
extern WORD             vepMac;         /* Count of entry point records */
#if EXE386
extern WORD             vFlags;         /* Image flags */
extern WORD             dllFlags;       /* DLL flags */
#else
extern WORD             vFlags;         /* Program flags word */
#endif
extern BYTE             vFlagsOthers;   /* Other program flags */
#endif /* OSEGEXE */

extern FTYPE            fExePack;       /* True if /EXEPACK */
#if PCODE
extern FTYPE            fMPC;
extern FTYPE            fIgnoreMpcRun;  /* True if /PCODE:NOMPC */
#endif

#if ODOS3EXE
extern FTYPE            fBinary;        /* True if producing .COM file */
extern WORD             cparMaxAlloc;   /* Max # paragraphs to ask for */
extern WORD             csegsAbs;       /* Number of absolute segments */
extern WORD             dosExtMode;     /* DOS extender mode */
extern FTYPE            fNoGrpAssoc;    /* True if ignoring group association */
extern SEGTYPE          segResLast;     /* Number of highest resident segment */
extern WORD             vchksum;        /* DOS3 checksum word */
extern FTYPE            vfDSAlloc;      /* True if allocating DGROUP high */
#if FEXEPACK
extern FRAMERLC FAR     mpframeRlc[];   /* f(frame number) = run time relocs */
#endif
#endif /* ODOS3EXE */
#if OVERLAYS
extern FTYPE            fOverlays;      /* True if overlays specified */
extern FTYPE            fOldOverlay;    /* True if /OLDOVERLAY set */
extern FTYPE            fDynamic;       /* True if dynamic overlays */
extern SNTYPE           gsnOvlData;     /* Global SEGDEF of OVERLAY_DATA */
extern SNTYPE           gsnOverlay;     /* Global SEGDEF of OVERLAY_THUNKS */
extern SNTYPE FAR       *htgsnosn;      /* Hash(glob SEGDEF) = overlay segnum */
extern SNTYPE FAR       *mposngsn;      /* f(ovl segnum) = global SEGDEF */
extern IOVTYPE FAR      *mpsegiov;      /* f(seg number) = overlay number */
extern RUNRLC FAR       *mpiovRlc;      /* f(overlay number) = run time relocs */
extern ALIGNTYPE FAR    *mpsegalign;    /* f(seg number) = alignment type */
extern SNTYPE           osnMac;         /* Count of overlay segments */
extern BYTE             vintno;         /* Overlay interrupt number */
extern WORD             iovFile;        /* Overlay number of input file */
extern WORD             iovMac;         /* Count of overlays */
extern WORD             ovlThunkMax;    /* Number of thunks that will fit into thunk segment */
extern WORD             ovlThunkMac;    /* Current number of allocated thunks */
#else
#define iovMac          0
#endif
#if OIAPX286
extern long             absAddr;        /* Absolute program starting address */
extern FTYPE            fPack;          /* True if packing segments */
extern SATYPE           *mpstsa;        /* f(seg table number) = selector */
extern SATYPE           stBias;         /* Segment selector bias */
extern SATYPE           stDataBias;     /* Data segment selector bias */
extern SATYPE           stLast;         /* Last segment table entry */
extern WORD             stMac;          /* Count of seg table entries */
#if EXE386
extern WORD             xevmod;         /* Virtual module information */
extern RATYPE           rbaseText;      /* Text relocation factor */
extern RATYPE           rbaseData;      /* Data relocation factor */
extern FTYPE            fPageswitch;    /* True if -N given */
extern BYTE             cblkPage;       /* # 512-byte blocks in pagesize */
#endif
#endif
#if OIAPX286 OR ODOS3EXE
extern GRTYPE           *mpextggr;      /* f(EXTDEF) = global GRPDEF */
extern long FAR         *mpsegcb;       /* f(segment number) = size in bytes */
extern BYTE FAR         *mpsegFlags;    /* f(segment number) = flags */
extern char             *ompimisegDstIdata;
                                        /* pointer to LIDATA relocations */
#endif
#if DOSEXTENDER AND NOT WIN_NT
extern WORD cdecl       _fDosExt;       /* TRUE if running under DOS extender */
#endif
#if OXOUT OR OIAPX286
extern FTYPE            fIandD;         /* True if "pure" (-i) */
extern FTYPE            fLarge;         /* True if FAR data */
extern FTYPE            fLocals;        /* True if including local symbols */
extern FTYPE            fMedium;        /* True if FAR code */
extern FTYPE            fMixed;         /* True if mixed model */
extern FTYPE            fSymbol;        /* True if including symbol table */
extern WORD             xever;          /* Xenix version number */
#endif
#if WIN_3
#define fZ1 TRUE
#else
#if QCLINK
extern FTYPE            fZ1;
#endif
#endif
#if QCLINK OR Z2_ON
extern FTYPE            fZ2;
#endif
#if ILINK
extern FTYPE            fZincr;
extern FTYPE            fQCIncremental;
extern FTYPE            fIncremental;
extern WORD             imodFile;
extern WORD             locMac;         /* count of LPUBDEFs */
extern WORD             imodCur;
#endif

extern WORD             cbPadCode;      /* code padding size */
extern WORD             cbPadData;      /* data padding size */

#if OEXE
extern FTYPE            fDOSExtended;
extern FTYPE            fNoNulls;       /* True if /NONULLS given */
extern FTYPE            fPackData;      /* True if /PACKDATA given */
extern FTYPE            fPackSet;       /* True if /PACK or /NOPACK given */
extern FTYPE            fSegOrder;      /* True if special DOS seg order */
extern DWORD            packLim;        /* Code seg packing limit */
extern DWORD            DataPackLim;    /* Data seg packing limit */
#endif
#if OSEGEXE AND ODOS3EXE
extern FTYPE            fOptimizeFixups;/* True if fixups optimization possible */
extern void             (NEAR *pfProcFixup)();
#endif
                                        /* Ptr to FIXUPP processing routine */
extern RBTYPE           mpggrrhte[];    /* f(global GRPDEF) = name */
#if FAR_SEG_TABLES
extern SNTYPE FAR       *mpseggsn;      /* f(segment #) = global SEGDEF */
#else
extern SNTYPE           *mpseggsn;      /* f(segment #) = global SEGDEF */
#endif

extern FTYPE            fNoEchoLrf;     /* True if not echoing response file */
extern FTYPE            fNoBanner;      /* True if not displaing banner */
extern FTYPE            BannerOnScreen; /* True if banner displayed */

#if CMDMSDOS
extern BYTE             bSep;           /* Separator character */
extern BYTE             chMaskSpace;    /* Space mask character */
extern FTYPE            fEsc;           /* True if command line escaped */
extern FTYPE            fStuffed;       /* Put-back-character flag */
extern RBTYPE           rgLibPath[];    /* Default library paths */
extern WORD             cLibPaths;      /* Count of library paths */
extern char             CHSWITCH;       /* Switch character */
#if OSMSDOS
extern int              (cdecl *pfPrompt)(unsigned char *sbNew,
                                          MSGTYPE msg,
                                          int msgparm,
                                          MSGTYPE pmt,
                                          int pmtparm);
                                        /* Pointer to prompt routine */
#endif
#endif /* CMDMSDOS */
#if QBLIB
extern FTYPE            fQlib;          /* True if generating Quick-library */
#else
#define fQlib           FALSE
#endif
extern char             *lnknam;        /* Name of linker */
#if NEWSYM
extern long             cbSymtab;       /* # bytes in symbol table */
#endif /* NEWSYM */
extern void             (*pfCputc)(int ch);     /* Ptr to char output routine */
extern void             (*pfCputs)(char *str);  /* Ptr to string output routine */
#if NEWIO
extern RBTYPE           rbFilePrev;     /* Pointer to previous file */
extern char             mpifhfh[];      /* f(lib no.) = file handle */
#endif
#if MSGMOD AND OSMSDOS
#if defined(M_I386) OR defined( _WIN32 )
#define GetMsg(x) GET_MSG(x)
#else
extern char FAR * PASCAL __FMSG_TEXT ( unsigned );
                                        /* Get a msg from the message segment */
extern char *           GetMsg(unsigned short num);
#define __NMSG_TEXT(x)  GetMsg(x)
#endif
#endif
#if MSGMOD AND OSXENIX
#define __FMSG_TEXT     __NMSG_TEXT
#define GetMsg(x)       __NMSG_TEXT(x)
#endif
#if NOT MSGMOD
#define GetMsg(x)       (x)
#define __NMSG_TEXT(x)  (x)
#endif
#define SEV_WARNING 0
#define SEV_ERROR 1
#define SEV_NOTIFICATION 2  /* Possible sev. of QW_ERROR message */



#if NEW_LIB_SEARCH
extern void             StoreUndef(APROPNAMEPTR, RBTYPE, RBTYPE, WORD);
extern FTYPE            fStoreUndefsInLookaside;
#endif

#if RGMI_IN_PLACE
BYTE FAR *              PchSegAddress(WORD cb, SEGTYPE seg, RATYPE ra);
#endif

#if ALIGN_REC
extern BYTE             *pbRec;         // data for current record
extern char             recbuf[8192];   // record buffer...
#endif

//////////////// inline functions ////////////////////

__inline void NEAR      SkipBytes(WORD n)
{
#if ALIGN_REC
    pbRec += n;
    cbRec -= n;
#elif WIN_NT
    WORD               cbRead;
    SBTYPE             skipBuf;

    cbRec -= n;                         // Update byte count
    while (n)                           // While there are bytes to skip
    {
        cbRead = n < sizeof(SBTYPE) ? n : sizeof(SBTYPE);
        if (fread(skipBuf, 1, cbRead, bsInput) != cbRead)
            InvalidObject();
        n -= cbRead;
    }
#else
    FILE *f = bsInput;

    if ((WORD)f->_cnt >= n)
        {
        f->_cnt -= n;
        f->_ptr += n;
        }
    else if(fseek(f,(long) n,1))
        InvalidObject();
    cbRec -= n;                         /* Update byte count */
#endif
}

#if ALIGN_REC
__inline WORD NEAR      Gets(void)
{
    cbRec--;
    return *pbRec++;
}
#else
__inline WORD NEAR      Gets(void)
{
    --cbRec;
    return(getc(bsInput));
}
#endif

__inline WORD NEAR GetIndex(WORD imin,WORD imax)
{
#if ALIGN_REC
    WORD w;

    if (*pbRec & 0x80)
    {
        w = (pbRec[0] & 0x7f) << 8 | pbRec[1];
        pbRec += 2;
        cbRec -= 2;
    }
    else
    {
        w = *pbRec++;
        cbRec--;
    }

    if(w < imin || w > imax) InvalidObject();
    return w;

#else
    WORD        index;

    FILE *f = bsInput;

    if (f->_cnt && (index = *(BYTE *)f->_ptr) < 0x80)
        {
        f->_cnt--;
        f->_ptr++;
        cbRec--;
        if(index < imin || index > imax) InvalidObject();
        return(index);  /* Return a good value */
        }

    return GetIndexHard(imin, imax);
#endif
}

#if ALIGN_REC
__inline WORD NEAR      WGets(void)
{
    WORD w = getword(pbRec);
    pbRec   += sizeof(WORD);
    cbRec   -= sizeof(WORD);
    return w;
}
#else
__inline WORD NEAR      WGets(void)
{
    FILE *f = bsInput;

    // NOTE: this code will only work on a Little Endian machine
    if (f->_cnt >= sizeof(WORD))
        {
        WORD w = *(WORD *)(f->_ptr);
        f->_ptr += sizeof(WORD);
        f->_cnt -= sizeof(WORD);
        cbRec   -= sizeof(WORD);
        return w;
        }
    else
        return WGetsHard();
}
#endif

__inline WORD NEAR WSGets(void)
{
    cbRec -= 2;
    return (WORD)(getc(bsInput) | (getc(bsInput) << 8));
}

__inline int Qwrite(char *pch, int cb, FILE *f)
{
    if (f->_cnt >= cb)
    {
        memcpy(f->_ptr, pch, cb);
        f->_ptr += cb;
        f->_cnt -= cb;
        return cb;
    }

    return fwrite(pch, 1, cb, f);
}


#ifdef NEWSYM
__inline void OutSb(BSTYPE f, BYTE *pb)
{
    Qwrite(&pb[1],B2W(pb[0]),f);
}
#endif


#if defined( M_I386 ) OR defined( _WIN32 )

extern void NoRoomForExe(void);

#if DISPLAY_ON
#pragma inline_depth(0)

__inline void  WriteExe(void FAR *pb, unsigned cb)
{
    WORD i,iTotal=0,j=1;

    if (Qwrite((char *) pb, (int)cb, bsRunfile) != (int)cb)
    {
        NoRoomForExe();
    }

    if(TurnDisplayOn)
    {
        fprintf( stdout,"\r\nOutVm : %lx bytes left\r\n", cb);
        for(i=0; i<cb; i++)
        {
            if(j==1)
            {
                fprintf( stdout,"\r\n\t%04X\t",iTotal);
            }

            fprintf( stdout,"%02X ",*((char*)pb+i));
            iTotal++;
            if(++j > 16)
                j=1;

        }

    fprintf( stdout,"\r\n");
    }
}

#pragma inline_depth()

#else  // DISPLAY NOT ON

#define WriteExe(pb,cb) \
    if (Qwrite((char *)(pb),(int)(cb),bsRunfile) != (int)(cb)) NoRoomForExe()

#endif
#endif


#if ALIGN_REC

__inline void GetBytes(BYTE *pb, WORD n)
{
    if (n >= SBLEN || n > cbRec)
        InvalidObject();

    memcpy(pb, pbRec, n);
    cbRec -= n;
    pbRec += n;
}


__inline DWORD LGets()
{
    // NOTE: this code will only work on a Little-Endian machine

    DWORD dw = getdword(pbRec);
    pbRec += sizeof(dw);
    cbRec -= sizeof(dw);
    return dw;
}

__inline void GetBytesNoLim(BYTE *pb, WORD n)
{
    if (n > cbRec)
        InvalidObject();

    memcpy(pb, pbRec, n);
    pbRec += n;
    cbRec -= n;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\errors.c ===
/*** error.c - error handling functions
*
*       Copyright <C> 1989, Microsoft Corporation
*
* Purpose:
*   This module contains all error message functions and variuos
*   functions that check if errror condition has occured.
*
*   This Module contains Proprietary Information of Microsoft
*   Corporation and should be treated as Confidential.
*
* Revision History:
*
*   [WJK]  28-Jun-1990             Created
*
*************************************************************************/

#include                <minlit.h>      /* Types, constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <nmsg.h>        /* Near message strings */
#include                <extern.h>      /* External declarations */
#include                <string.h>
#if (defined(WIN_NT) OR defined(DOSX32)) AND (NOT defined( _WIN32 ))
#define i386
#endif
#include                <stdarg.h>
#if EXE386
#include                <exe386.h>
#endif
#if WIN_3
#include                <windows.h>
#endif
#if NEWIO
#include                <errno.h>       /* System error codes */
#endif

#define DEBUG_WIN FALSE
#if DEBUG_WIN
char    szDebugBuffer[80];
#define DEBUGW(parm1,parm2)\
    {\
    wsprintf(szDebugBuffer,parm1,(char far*)parm2);\
    OutputDebugString(szDebugBuffer);\
    }
#else
#define DEBUGW(parm1,parm2)
#endif


#if OSEGEXE AND NOT QCLINK
extern int              yylineno;       /* Current line in definitions file */
#else
#define yylineno        -1
#endif


#if AUTOVM
extern BYTE FAR * NEAR  FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM        FetchSym1
#else
#define FETCHSYM        FetchSym
#endif


LOCAL char              chErr = 'L';    /* Error message prefix */


/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void cdecl NEAR ErrSub(MSGTYPE msg, WORD fWarn, va_list pArgList);
LOCAL void            vFmtPrint(char *fmt, va_list pArgList);


/*** ChkInput - check input file for I/O errors
*
* Purpose:
*   Check if there were any I/O errors on input file.
*
* Input:
*   No explicit value is passed. The global input file bsInput is
*   used.
*
* Output:
*   If everything is OK function returns, otherwise it calls Fatal
*   with appropriate error message.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                        ChkInput(void)
{
    if (feof(bsInput))
        Fatal(ER_eofobj);
    else if (ferror(bsInput))
        Fatal(ER_ioerr, strerror(errno));
}

// Comment : GetMsg and __NMSG_TEXT are generated by MKMSG [jp]

/*** ErrPrefix - write error message prefix
*
* Purpose:
*   Write out error message prefix.  If we are parsinf .DEF file or reading
*   .OBJ files then the error message prefix takes form "<filename> : "
*   otherwise  this is "LINK : ".
*
* Input:
*   No explicit value is passed.
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    ErrPrefix(void)
{
    DisplayBanner();
    if (fDrivePass || yylineno > 0)
        OutFileCur(bsErr);
    else
        FmtPrint(lnknam);
    FmtPrint(" : ");
}

#pragma check_stack(on)

/*** OutFileCur - write out current input file name
*
* Purpose:
*   Write out current input file name. Used by error message functions.
*   File name is written in the following formats:
*       <filename>(nnn)
*       <filename>(<modulename>)
*       <filename>
*
* Input:
*   bs           - file to which current input file name is written
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    OutFileCur(BSTYPE bs)
{
    APROPFILEPTR        apropFile;      /* Pointer to file property cell */
    AHTEPTR             ahte;           /* Pointer symbol name */
    BSTYPE              bsTmp;          /* Temporary file pointer */
    SBTYPE              fileName;       /* File name buffer */
    SBTYPE              moduleName;     /* Object module name */
    int                 n;              /* String length counter */

#if OSEGEXE
    if (yylineno > 0)
    {
        apropFile = (APROPFILEPTR) FETCHSYM(rhteDeffile,FALSE);
        ahte = GetHte(rhteDeffile);
    }
    else
#endif
    {
        apropFile = (APROPFILEPTR ) FETCHSYM(vrpropFile,FALSE);
        ahte = GetHte(vrpropFile);
    }
    bsTmp = bsErr;
    bsErr = bs;

    // Copy file name

    n = (ahte->cch[0] < sizeof(fileName) - 1) ? ahte->cch[0] : sizeof(fileName) - 1;
    FMEMCPY((char FAR *) fileName, &ahte->cch[1], n);
    fileName[n] = '\0';
    if (yylineno > 0)
        FmtPrint("%s(%d)", fileName, yylineno);
    else if (apropFile->af_rMod)
    {
        // Get object module name

        ahte = (AHTEPTR ) FETCHSYM(apropFile->af_rMod,FALSE);
        while(ahte->attr != ATTRNIL)
            ahte = (AHTEPTR ) FETCHSYM(ahte->rhteNext,FALSE);
        n = (ahte->cch[0] < sizeof(moduleName) - 1) ? ahte->cch[0] : sizeof(moduleName) - 1;
        FMEMCPY((char FAR *) moduleName, &ahte->cch[1], n);
        moduleName[n] = '\0';
        FmtPrint("%s(%s)", fileName, moduleName);

    }
    else
        FmtPrint("%s", fileName);
    bsErr = bsTmp;
}

#pragma check_stack(off)

#if (QCLINK OR OSEGEXE) AND NOT EXE386
typedef int (cdecl FAR * FARFPTYPE)(char FAR *buf);
                                        /* Far function pointer type */
extern FARFPTYPE FAR    *pfQTab;        /* Table of addresses */
#endif

/*** vFmtPrint - print formated message
*
* Purpose:
*   Print on bsErr formated error or warning message.
*   Check for any I/O errors.
*
* Input:
*   fmt          - error message format string
*   pArgList     - pointer to variable number of parameters desrcibing error message
*   bsErr        - error file - global variable
*   bsLst        - listing file - global variable
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   I/O errors. If error detected and stdout is an error file then silently
*   exit to system with return code 4 (something must be terribly wrong
*   if stdout is not working). If we are writing to listing file and
*   error was detected then close listing file and notify user.
*
* Notes:
*   This function handles output to QC enviroment.
*
*************************************************************************/

LOCAL void              vFmtPrint(char *fmt, va_list pArgList)
{
#if WIN_3
    char        buf[512];
    vsprintf(buf, fmt, pArgList);
    ErrMsgWin(buf);
    #if DEBUG_WIN2
    OutputDebugString((char far*)"\r\nDebS: ");
    OutputDebugString((char far*)buf);
    #endif
#else

#if (QCLINK) AND NOT EXE386
    SBTYPE              buf;
    if (fZ1)
    {
        // Output via QC call-back

        vsprintf(buf, fmt, pArgList);
        (*pfQTab[0])((char far *) buf);
    }
    else
#endif
    {
        vfprintf(bsErr, fmt, pArgList);
        if (ferror(bsErr))
        {
            if (bsErr == stdout)
            {
#if USE_REAL
                RealMemExit();
#endif
                exit(4);
            }
            else if (bsErr == bsLst)
            {
                fclose(bsLst);
                fLstFileOpen = FALSE;
                bsErr = stdout;
            }
            ExitCode = 4;
            Fatal(ER_spclst);
        }
        fflush(bsErr);
    }
#endif // WIN_3
}

/*** FmtPrint - print formated message
*
* Purpose:
*   Print on bsErr formated error or warning message.
*   Check for any I/O errors.
*
* Input:
*   fmt          - error message format string
*   ...          - variable number of parameters desrcibing error message
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   I/O errors.
*
* Notes:
*   The actual job is done by the vFmtPrint.
*
*************************************************************************/

void cdecl              FmtPrint(char *fmt, ...)
{
    va_list             pArgList;


    va_start(pArgList, fmt);
    vFmtPrint(fmt, pArgList);
}


#if OSMSDOS AND NOT WIN_3
/*
 *  PromptStd : Standard prompt routine
 *
 *  Display a warning message and prompt, with optional arguments.
 *  Optionally read a response into a given buffer.  If the given
 *  buffer is null, get a yes/no response with <ENTER> being yes.
 *
 *  Returns:
 *      TRUE if yes or response read.
 *      FALSE if no.
 */
int cdecl               PromptStd (sbNew,msg,msgparm,pmt,pmtparm)
BYTE                    *sbNew;         /* Buffer for response */
MSGTYPE                 msg;            /* Error message */
int                     msgparm;        /* Message parameter */
MSGTYPE                 pmt;            /* Prompt */
int                     pmtparm;        /* Prompt parameter */
{
    register BYTE       *p;
    int                 ch;
    int                 n;

    if(msg)
        OutWarn(msg, msgparm);
    if(!pmt)
        return(TRUE);
    fprintf(stderr,GetMsg(pmt),pmtparm);
    fflush(stderr);                     /* Flush stderr */
#if CPU286
    flskbd();                           /* Flush DOS keyboard buffer */
#endif
    fflush(stdin);                      /* Flush console input */
    if(sbNew != NULL)
    {
                                        /* Read response */
        for(p = &sbNew[1], n = 0;
            (ch = fgetc(stdin)) != '\n' && ch != EOF && n < sizeof(SBTYPE); )
        {
#if CRLF
            if(ch == '\r')
                continue;
#endif
            *p++ = (BYTE) ch;
            n++;
        }
        sbNew[0] = (BYTE) n;
        return(TRUE);
    }
#if CRLF
    if(fgetc(stdin) != '\r')
        return(FALSE);
#endif
    if(fgetc(stdin) != '\n')
        return(FALSE);
    return(TRUE);
}
#endif /* OSMSDOS */

/*
 *  CputcStd : standard console character output routine.
 *      Call fputc to stdout.  Will be called through pfCputc.
 */
void                    CputcStd (ch)
int                     ch;
{
    putc(ch,stdout);
    if (ferror(stdout))
        exit(4);
}

/*
 *  CputsStd : standard console string output routine
 *      Call fputs to stdout.  Will be called through pfCputs.
 */
void                    CputsStd (str)
char                    *str;
{
    fputs(str,stdout);
    if (ferror(stdout))
    {
#if USE_REAL
        RealMemExit();
#endif
        exit(4);
    }
    fflush(stdout);
}

/*** ErrSub - write out nonfatal error message
*
* Purpose:
*   Fromat and write out nonfatal error message. If error message number
*   is equal to zero then we treat it as a prompt.
*
* Input:
*   msg          - error message number
*   fWarn        - TRUE if this warnnig
*   ...          - variable number of parameters for message
*   bsErr        - error file - global variable
*   bsLst        - listing file - global variable
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void cdecl NEAR   ErrSub(MSGTYPE msg, WORD fWarn, va_list pArgList)
{

    if (fLstFileOpen && bsErr == bsLst && vgsnLineNosPrev)
    {                                   /* If we've listed line numbers */
        NEWLINE(bsErr);                 /* Newline */
        vgsnLineNosPrev = 0;            /* Reset */
    }
    if (msg)
    {
        /* If there is any message to print */
#if WIN_3
        if(fWarn)
            fSeverity=SEV_WARNING;
        else
            fSeverity=SEV_ERROR;
#endif


#if MSGMOD AND NOT WIN_3
        if (msg >= 1000)
        {
#endif
            /* Error or warning */

            ErrPrefix();
#if MSGMOD
            FmtPrint("%s %c%04d: ",
                    fWarn ? __NMSG_TEXT(N_warning) : __NMSG_TEXT(N_error),
                    (int) chErr, msg);
#else
            FmtPrint("%s: ",fWarn ? "warning" : "error");
#endif
            vFmtPrint(GetMsg(msg), pArgList);
#if NOT WIN_3
#if QCLINK
            if (fZ1)
                FmtPrint("\n");
            else
#endif
                NEWLINE(bsErr);
#else
            FmtPrint("\r\n");
            // for the second part of the message
            fSeverity = SEV_WARNING;
#endif

            if (fDrivePass && !fWarn
#if MSGMOD
               && (msg >= 2005 && msg < 2022) || msg == 1101
#endif
               )
                FmtPrint("%s: %lx %s: %02x\r\n",
                            __NMSG_TEXT(N_pos),ftell(bsInput),
                            __NMSG_TEXT(N_rectyp),rect & 0xff);

#if MSGMOD AND NOT WIN_3
        }
        else
        {
            /* Prompt */
#if QCLINK
            if (fZ1)
                (*pfPrompt)(NULL, msg, (int) pArgList, 0, 0);
            else
            {
#endif
                vFmtPrint(GetMsg(msg), pArgList);
                NEWLINE(bsErr);
#if QCLINK
            }
#endif
        }
#endif
    }
}

/*** OutError - write out nonfatal error message
*
* Purpose:
*   Top level function called when error message has to be displayed.
*   Bumps the error counter and calls ErrSub to do the job.
*
* Input:
*   msg          - error message number
*   ...          - variable number of error parameters
*
* Output:
*   No explicit value is returned. Global error counter cErrors is
*   incremented.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void cdecl              OutError(MSGTYPE msg, ...)
{
    va_list             pArgList;

    va_start(pArgList, msg);
    ++cErrors;                      /* Increment error count */
    ErrSub(msg, FALSE, pArgList);
}

/*** OutWarn - write out warning message
*
* Purpose:
*   Top level function called when warning message has to be displayed.
*   Calls ErrSub to do the job.
*
* Input:
*   msg          - error message number
*   ...          - variable number of error parameters
*
* Output:
*   No explicit value is returned.
*   incremented.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void cdecl              OutWarn (MSGTYPE msg, ...)
{
    va_list             pArgList;
    DEBUGW("\r\nOutWarn entered",0);
    va_start(pArgList, msg);
    ErrSub(msg, TRUE, pArgList);
}

/*** KillRunFile - delete .EXE file
*
* Purpose:
*   Delete the .EXE file created by the linker.
*
* Input:
*   No explicit value is passed.
*   bsRunfile - output file handle - global variable.
*   psbRun    - output file name   - global variable.
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    KillRunfile(void)
{
    if (bsRunfile != NULL)
    {
        CloseFile(bsRunfile);
        _unlink(&psbRun[1]);
    }
}

/*** Fatal - write out fatal error message
*
* Purpose:
*   Format and write out fatal error message. Terminate linker.
*
* Input:
*   msg          - error message number
*   ...          - variable number of message parameters
*   bsLst        - listing file - global variable
*
* Output:
*   No explicit value is returned. Linker terminates.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void cdecl              Fatal (MSGTYPE msg, ...)
{
    static              WORD cInvoked =0;
    va_list             pArgList;

    va_start(pArgList, msg);            /* Get start of argument list */

    if (++cInvoked > 1) // Fatal during Fatal
    {
#if USE_REAL
        RealMemExit();
#endif
        if (ExitCode)
                EXIT(ExitCode);
        else
                EXIT(2);                        /* Program error */
    }

    /* If msg is nonzero then print a message */

    if (msg)
    {
        if (fLstFileOpen)
            fflush(bsLst);
        ErrPrefix();
#if MSGMOD
        FmtPrint("%s %c%04d: ", __NMSG_TEXT(N_fatal), chErr, msg);
#else
        FmtPrint("fatal error: ");
#endif
        vFmtPrint(GetMsg(msg), pArgList);
#if WIN_3
        fSeverity = SEV_ERROR;          // Send as error to QCwin
        FmtPrint("\r\n");
#else
        NEWLINE(stderr);
#endif
        if(fDrivePass && ftell(bsInput)
#if MSGMOD
               && msg >= 2005 && msg < 2022 || msg == 1101
#endif
               )
            FmtPrint("%s: %lx %s: %02x\r\n",
                    __NMSG_TEXT(N_pos),ftell(bsInput),
                    __NMSG_TEXT(N_rectyp),rect & 0xff);
    }
    KillRunfile();
    if (fLstFileOpen) fclose(bsLst);
#if OWNSTDIO
    FlsStdio();
#endif

    // If someone else assigned the exit code, use it.  Otherwise,
    // assume program error.

    if (ExitCode)
        EXIT(ExitCode);
    else
        EXIT(2);                        /* Program error */
}

/*** CtrlC - display Ctrl-C error message and die
*
* Purpose:
*   Do minimal work required to display error message and die.
*
* Input:
*   No explicit value is passed.
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   This function doesn't return.
*
*************************************************************************/

void                    CtrlC(void)
{
#if USE_REAL
        RealMemExit();
#endif
#ifdef OS2
    if (_osmode == OS2_MODE)
        fputs("\r\n", stdout);
#endif

#if DOSEXTENDER AND NOT WIN_NT
    if (!_fDosExt)
    {
#endif
        if (fLstFileOpen)
            fflush(bsLst);
        ErrPrefix();
        FmtPrint("%s %c%04d: %s", __NMSG_TEXT(N_fatal), chErr, ER_intrpt, GetMsg(ER_intrpt));
        KillRunfile();
        if (fLstFileOpen)
            fclose(bsLst);
#if OWNSTDIO
        FlsStdio();
#endif
        EXIT(4);
#if DOSEXTENDER AND NOT WIN_NT
    }
    else
        _exit(4);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\impexp.c ===
/*** impexp.c - Import/Export module - implementation
*
*       Copyright <C> 1992, Microsoft Corporation
*
*       This module contains proprietary information of Microsoft
*       Corporation and should be treated as confidential.
*
* Purpose:
*   Build and write segmented-executable import/export tables
*
* Revision History:
*
*       29-May-1992    Wieslaw Kalkus   Created
*
*************************************************************************/

#include                <minlit.h>
#include                <bndtrn.h>
#include                <bndrel.h>
#include                <lnkio.h>
#include                <newexe.h>
#include                <lnkmsg.h>
#include                <extern.h>
#include                <string.h>
#include                <impexp.h>

//
//  Functions operating on dynamic byte arrays
//

void                InitByteArray(DYNBYTEARRAY *pArray)
{
    pArray->byteMac = 0;
    pArray->byteMax = DEF_BYTE_ARR_SIZE;
    pArray->rgByte  = GetMem(DEF_BYTE_ARR_SIZE);
}

void                FreeByteArray(DYNBYTEARRAY *pArray)
{
    FFREE(pArray->rgByte);
    pArray->byteMac = 0;
    pArray->byteMax = 0;
}

WORD                ByteArrayPut(DYNBYTEARRAY *pArray, WORD size, BYTE *pBuf)
{
    BYTE FAR        *pTmp;
    WORD            idx;

        if ((DWORD)(pArray->byteMac) + size > 0xFFFE)
                        Fatal(ER_memovf);

    if ((WORD) (pArray->byteMac + size) >= pArray->byteMax)
    {
        // Realloc array
                if(pArray->byteMax < 0xffff/2)
                                pArray->byteMax <<= 1;
                else
                while (pArray->byteMac + size >= pArray->byteMax)
                                pArray->byteMax += (0x10000 - pArray->byteMax) / 2;
        pArray->rgByte = REALLOC(pArray->rgByte,pArray->byteMax);
        if(!pArray->rgByte)
                        Fatal(ER_memovf);
                ASSERT (pArray->byteMax > pArray->byteMac + size);
    }
    idx  = pArray->byteMac;
    pTmp = &(pArray->rgByte[idx]);
    FMEMCPY(pTmp, pBuf, size);
    pArray->byteMac += size;
    return(idx);
}

void                WriteByteArray(DYNBYTEARRAY *pArray)
{
    WriteExe(pArray->rgByte, pArray->byteMac);
}

//
//  Functions operating on dynamic word arrays
//

void                InitWordArray(DYNWORDARRAY *pArray)
{
    pArray->wordMac = 0;
    pArray->wordMax = DEF_WORD_ARR_SIZE;
    pArray->rgWord  = (WORD FAR *) GetMem(DEF_WORD_ARR_SIZE * sizeof(WORD));
}

void                FreeWordArray(DYNWORDARRAY *pArray)
{
    FFREE(pArray->rgWord);
    pArray->wordMac = 0;
    pArray->wordMax = 0;
}

WORD                WordArrayPut(DYNWORDARRAY *pArray, WORD val)
{
    WORD FAR        *pTmp;
    WORD            idx;

    if ((WORD) (pArray->wordMac + 1) >= pArray->wordMax)
    {
        // Realloc array

        pTmp = (WORD FAR *) GetMem((pArray->wordMax << 1) * sizeof(WORD));
        FMEMCPY(pTmp, pArray->rgWord, pArray->wordMac * sizeof(WORD));
        FFREE(pArray->rgWord);
        pArray->rgWord = pTmp;
        pArray->wordMax <<= 1;
    }
    idx  = pArray->wordMac;
    pArray->rgWord[idx] = val;
    pArray->wordMac++;
    return(idx);
}

void                WriteWordArray(DYNWORDARRAY *pArray)
{
    WriteExe(pArray->rgWord, pArray->wordMac*sizeof(WORD));
}

//
//  IMPORT/EXPORT tables
//

DYNBYTEARRAY        ResidentName;
DYNBYTEARRAY        NonResidentName;
DYNBYTEARRAY        ImportedName;
DYNWORDARRAY        ModuleRefTable;
DYNBYTEARRAY        EntryTable;

//
//  Functions adding names to tables
//

void                AddName(DYNBYTEARRAY *pTable, BYTE *sbName, WORD ord)
{
    WORD            cb;

    cb = sbName[0] + 1 + sizeof(WORD);
    if ((WORD)(0xFFFE - pTable->byteMac) < cb)
    {
        if (pTable == &ResidentName)
            Fatal(ER_resovf);
        else
            Fatal(ER_nresovf);
    }
    ByteArrayPut(pTable, (WORD) (sbName[0] + 1), sbName);
    ByteArrayPut(pTable, sizeof(WORD), (BYTE *) &ord);
}


WORD                AddImportedName(BYTE *sbName)
{
    if ((WORD) (0xfffe - ImportedName.byteMac) < (WORD) (sbName[0] + 1))
        Fatal(ER_inamovf);
    return(ByteArrayPut(&ImportedName, (WORD) (sbName[0] + 1), sbName));
}

//
//  Function adding entries to the Entry Table
//

WORD                AddEntry(BYTE *entry, WORD size)
{
    if ((WORD)(EntryTable.byteMax + size) < EntryTable.byteMax)
        Fatal(ER_etovf);
    return (ByteArrayPut(&EntryTable, size, entry));
}

/*
 *      This function writes either the resident or nonresident names table
 *      to a file f. If targeting Windows it also converts the names
 *      to upper case.
 */

void                 WriteNTable(DYNBYTEARRAY *pArray, FILE *f)
{
    BYTE        *p;
    WORD        *pOrd;    // points to the ordinal
    WORD        Ord;      // ordinal value
    int i;
    p = pArray->rgByte;
#if DEBUG_EXP
    for( i = 0; i<pArray->byteMac; i++)
    {
        fprintf(stdout, "\r\n%d : %d(%c)    ", i, *(p+i), *(p+i));
        fflush(stdout);
    }
#endif

    while(p[0])                 // Until names left
    {
        if(f)                   // If writing to a file
        {
            pOrd = (WORD*)(p+p[0]+1);
            Ord  = *pOrd;
#if DEBUG_EXP
            fprintf(stdout, "\r\np[0]=%d, p[1]=%d Ord = %d", p[0], p[1], Ord);
#endif
            if(Ord)             // Don't output module name/description
            {
                *pOrd = 0;
                fprintf(f, "\r\n    %s @%d", p+1, Ord);
                *pOrd = Ord;
            }
        }

   // Windows loader requires both res-and nonresident name tables in uppercase
   // If fIgnoreCase is TRUE, the names are already converted by SavExp2

        if(!fIgnoreCase && TargetOs == NE_WINDOWS)
                SbUcase(p);            //  Make upper case
        p += p[0] + sizeof(WORD) + 1;  // Advance to the next name
    }
}
/*
 *      This function converts the res- and nonresident name symbols
 *      to uppercase (when targeting Windows). On user request it also
 *      writes all the names to a text file, that can later be included
 *      in the user's .def file. This frees the user from the need of
 *      manually copying the decorated names from the .map file.
 */

void ProcesNTables( char *pName)
{
    FILE        *f = NULL;
    int         i;
#if DEBUG_EXP
    fprintf(stdout, "\r\nOutput file name : %s ", psbRun);
#endif
    if(pName[0])          // user requested export file
    {
        if(pName[0] == '.')     // use the default name
        {
            for(i=0; i< _MAX_PATH; i++)
            {
                if((pName[i] = psbRun[i]) == '.')
                {
                    pName[i+1] = '\0';
                    break;
                }
            }
            strcat(pName, "EXP");       // the default name is 'DLLNAME'.EXP
        }
#if DEBUG_EXP
        fprintf(stdout, "\r\nEXPORT FILE : %s ", pName+1);
#endif
        if((f = fopen(pName+1, WRBIN)) == NULL)
           OutError(ER_openw, pName);
    }

    WriteNTable(&ResidentName, f);
    WriteNTable(&NonResidentName, f);

    fclose(f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\config.h ===
/* %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1996
*
*       NOTE in the Languages build environment makefile copies
*            one of several .h files to config.h.  For the NT link16,
*            config.h is checked in and is modified directly.  This
*            version of config.h is a derivative of link3216.h,
*            checked in to sdktools\link16\langbase.  -- DaveHart
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                   LINKER COMPILATION CONSTANTS                *
    *                                                               *
    ****************************************************************/
/*
 * Host:        NT (any platform)
 * Output:      DOS, Segmented exe
 */

#define TRUE            (0xff)          /* Necessary for Lattice C */
#define FALSE           0               /* Normal FALSE value */

/* Part I:
*  Debugging
*/
#if !defined( DEBUG )
#define DEBUG           FALSE           /* Debugging off */
#endif
#define TRACE           FALSE           /* Trace control flow */
#define ASSRTON         FALSE           /* Asserts on regardless of DEBUG */
#define PROFILE         FALSE           /* Do not generate profile */
#define VMPROF          FALSE           /* Profile virt. memory performance */

/* Part II:
*  Compiler
*/
#define CXENIX          TRUE            /* XENIX C compiler */
#define COTHER          FALSE           /* Other C compiler */
#define CLIBSTD         TRUE            /* Standard C library */

/* Part III:
*  Output format
*/
#define ODOS3EXE        TRUE            /* DOS3 exe format */
#define OSEGEXE         TRUE            /* Segmented Executable format */
#define OIAPX286        FALSE           /* Segmented x.out format */
#define OXOUT           FALSE           /* x.out format */
#define OEXE            (ODOS3EXE || OSEGEXE)
#define EXE386          FALSE           /* 386 exe format capability */

/* Part IV:
*  Linker runtime OS
*/
#define OSXENIX         FALSE           /* Xenix */
#define OSMSDOS         TRUE            /* MSDOS */
#define DOSEXTENDER     FALSE           /* Runs under DOS extender */
#define DOSX32          TRUE
#define WIN_NT          FALSE           /* Runs under Windows NT */
#define OSPCDOS         FALSE           /* MSDOS for IBM */
#define FIXEDSTACK      TRUE            /* Fixed stack */

/* Part V:
*  Input library format
*/
#define LIBMSDOS        TRUE            /* MSDOS style libraries */
#define LIBXENIX        FALSE           /* XENIX style libraries */

/* Part VI:
*  Command line form
*/
#define CMDMSDOS        TRUE            /* MSDOS command line format */
#define CMDXENIX        FALSE           /* XENIX command line format */

/* Part VII:
*  OEM
*/
#define OEMINTEL        FALSE           /* Intel machine */
#define OEMOTHER        TRUE            /* Some other OEM */

/* Part VIII:
*  Runtime CPU
*/
#define CPU8086         FALSE           /* 8086 or 286 real mode*/
#define CPU286          FALSE           /* 286 */
#define CPU386          TRUE            /* 386 */
#define CPUVAX          FALSE           /* VAX */
#define CPU68K          FALSE           /* Motorola 68000 */
#define CPUOTHER        FALSE           /* Some other CPU */

/* Part IX:
*  Miscellaneous
*/
#define NOASM           TRUE            /* No low-level assembler routines */
#define IGNORECASE      TRUE            /* Ignore case of symbols */
#define IOMACROS        FALSE           /* Use macros for InByte and OutByte */
#define CRLF            TRUE            /* Newline: ^M^J or ^J */
#define SIGNEDBYTE      FALSE           /* Bytes are signed */
#define LOCALSYMS       FALSE           /* Local symbols enable/disable */
#define FDEBUG          TRUE            /* Runtime debugging enable/disable */
#define SYMDEB          TRUE            /* Symbolic debug support */
#define FEXEPACK        TRUE            /* Include /EXEPACK option */
#define OVERLAYS        TRUE            /* Produce DOS 3 overlays */
#define OWNSTDIO        TRUE            /* Use own stdio routines */
#define ECS             FALSE           /* Extended Character Sets support */
#define OMF386          TRUE            /* 386 OMF extensions */
#define QBLIB           TRUE            /* QuickBasic/QuickC version */
#define MSGMOD          TRUE            /* Message modularization */
#define NOREGISTER      FALSE           /* Let compiler enregister */
#define NEWSYM          TRUE            /* New symbol table allocation */
#define NEWIO           TRUE            /* New file handle management */
#define ILINK           FALSE           /* Incremental linking support */
#define QCLINK          FALSE           /* Incremental linking support in QC */
#define AUTOVM          FALSE           /* Auto switch to vm */
#define FAR_SEG_TABLES  TRUE            /* Segment tables in FAR memory */
#define PCODE           TRUE            /* Support for PCODE */
#define Z2_ON           TRUE            /* Support undocumented option /Z2 */
#define O68K            FALSE           /* Support for 68k OMF */
#define LEGO            TRUE            /* Support for /KEEPF for segmented exes */
#define C8_IDE          TRUE            /* Running under the c8 IDE */
#define NEW_LIB_SEARCH  TRUE            /* use new library search algorithm */
#define RGMI_IN_PLACE   TRUE            /* read directly into the segments */
#define TIMINGS         FALSE           /* enable /BT to show times */
#define ALIGN_REC       TRUE            /* ensure record never spans i/o buf */
#define POOL_BAKPAT     TRUE            /* use a pool to manage backpatches */
#define OUT_EXP         FALSE           /* enable /idef to write exports */
#define USE_REAL        TRUE            /* enable code to use convent. memory for paging */
#define DEBUG_HEAP_ALLOCS FALSE          /* enable internal heap checking */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\comdat.c ===
/*** comdat.c - handle COMDAT records
*
*       Copyright <C> 1990, Microsoft Corporation
*
* Purpose:
*   Process COMDAT records in various stages of linker work.
*
* Revision History:
*
*   []  06-Jun-1990     WJK      Created
*
*************************************************************************/

#include                <minlit.h>      /* Basic types and constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* More types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#if OXOUT OR OIAPX286
#include                <xenfmt.h>      /* Xenix format definitions */
#endif
#include                <extern.h>      /* External declarations */
#include                <string.h>

#if OSEGEXE
extern RLCPTR           rlcLidata;      /* Pointer to LIDATA fixup array */
extern RLCPTR           rlcCurLidata;   /* Pointer to current LIDATA fixup */
#endif

#define COMDAT_SEG_NAME "\012COMDAT_SEG"
#define COMDAT_NAME_LEN 11
#define COMDATDEBUG FALSE

#define ALLOC_TYPE(x)   ((x)&ALLOCATION_MASK)
#define SELECT_TYPE(x)  ((x)&SELECTION_MASK)
#define IsVTABLE(x)     ((x)&VTABLE_BIT)
#define IsLOCAL(x)      ((x)&LOCAL_BIT)
#define IsORDERED(x)    ((x)&ORDER_BIT)
#define IsCONCAT(x)     ((x)&CONCAT_BIT)
#define IsDEFINED(x)    ((x)&DEFINED_BIT)
#define IsALLOCATED(x)  ((x)&ALLOCATED_BIT)
#define IsITERATED(x)   ((x)&ITER_BIT)
#define IsREFERENCED(x) ((x)&REFERENCED_BIT)
#define IsSELECTED(x)   ((x)&SELECTED_BIT)
#define SkipCONCAT(x)   ((x)&SKIP_BIT)

/*
 *  Global data exported from this module
 */

FTYPE                   fSkipFixups;    // TRUE if skiping COMDAT and its fixups
FTYPE                   fFarCallTransSave;
                                        // Previous state of /FarCallTarnaslation

/*
 *  Local types
 */

typedef struct comdatRec
{
    GRTYPE      ggr;
    SNTYPE      gsn;
    RATYPE      ra;
    WORD        flags;
    WORD        attr;
    WORD        align;
    WORD        type;
    RBTYPE      name;
}
                COMDATREC;

/*
 *  Local data
 */

LOCAL SNTYPE            curGsnCode16;   // Current 16-bit code segment
LOCAL DWORD             curCodeSize16;  // Current 16-bit code segment size
LOCAL SNTYPE            curGsnData16;   // Current 16-bit data segment
LOCAL DWORD             curDataSize16;  // Current 16-bit data segment size
#if EXE386
LOCAL SNTYPE            curGsnCode32;   // Current 32-bit code segment
LOCAL DWORD             curCodeSize32;  // Current 32-bit code segment size
LOCAL SNTYPE            curGsnData32;   // Current 32-bit data segment
LOCAL DWORD             curDataSize32;  // Current 32-bit data segment size
#endif
#if OVERLAYS
LOCAL WORD              iOvlCur;        // Current overlay index
#endif
#if TCE
SYMBOLUSELIST           aEntryPoints;    // List of program entry points
#endif

extern BYTE *           ObExpandIteratedData(unsigned char *pb,
                                             unsigned short cBlocks,
                                             WORD *pSize);

/*
 *  Local function prototypes
 */

LOCAL DWORD  NEAR       DoCheckSum(void);
LOCAL void   NEAR       PickComDat(RBTYPE vrComdat, COMDATREC *omfRec, WORD fNew);
LOCAL void   NEAR       ReadComDat(COMDATREC *omfRec);
LOCAL void   NEAR       ConcatComDat(RBTYPE vrComdat, COMDATREC *omfRec);
LOCAL void   NEAR       AttachPublic(RBTYPE vrComdat, COMDATREC *omfRec);
LOCAL void   NEAR       AdjustOffsets(RBTYPE vrComdat, DWORD startOff, SNTYPE gsnAlloc);
LOCAL WORD   NEAR       SizeOfComDat(RBTYPE vrComdat, DWORD *pActual);
LOCAL RATYPE NEAR       DoAligment(RATYPE value, WORD align);
LOCAL DWORD  NEAR       DoAllocation(SNTYPE gsnAlloc, DWORD size,
                                     RBTYPE vrComdat, DWORD comdatSize);
LOCAL WORD   NEAR       NewSegment(SNTYPE *gsnPrev, DWORD *sizePrev, WORD allocKind);
LOCAL void   NEAR       AllocAnonymus(RBTYPE vrComdat);
LOCAL WORD   NEAR       SegSizeOverflow(DWORD segSize, DWORD comdatSize,
                                        WORD f16bit, WORD fCode);
#if TCE
LOCAL void      NEAR    MarkAlive( APROPCOMDAT *pC );
LOCAL void                      PerformTce( void );
void                            AddTceEntryPoint( APROPCOMDAT *pC );
#endif
#if COMDATDEBUG
void                    DisplayComdats(char *title, WORD fPhysical);
#endif

#pragma check_stack(on)

/*** DoCheckSum - calculate a check sum of a COMDAT data block
*
* Purpose:
*   The check sum is used for match exact criteria.
*
* Input:
*   No explicit value is passed. The following global data is used as
*   input to this function:
*
*   cbRec   - current record lenght; decremented by every read from
*             the OMF record, so effectivelly cbRec tells you how
*             many bytes are left in the record.
*
* Output:
*   Returns the 32-bit check sum of COMDAT data block.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        DoCheckSum(void)
{
    DWORD               result;
    DWORD               shift;


    result = 0L;
    shift  = 0;
    while (cbRec > 1)
    {
        result += ((DWORD ) Gets()) << (BYTELN * shift);
        shift = (shift + 1) & 3;
    }
    return(result);
}


/*** PickComDat - fill in the COMDAT descriptor
*
* Purpose:
*   Fill in the linkers symbol table COMDAT descriptor. This function
*   is called for new descriptors and for already entered one which
*   need to be updated - remember we have plenty of COMDAT selection criteria.
*
* Input:
*   vrComDat    - virtual pointer to symbol table entry
*   omfRec      - pointer to COMDAT OMF data
*   fNew        - TRUE if new entry in symbol table
*   mpgsnprop   - table mapping global segment index to symbol table entry
*                 This one of those friendly global variables linker is full of.
*   vrprop      - virtual pointer to symbol table entry - another global
*                 variable; it is set by call to PropSymLookup which must
*                 proceed call to  PickComDat
*   cbRec       - size of current OMF record - global variable - decremented
*                 by every read from record
*   vrpropFile  - current .OBJ file - global variable
*   lfaLast     - current offset in the .OBJ - global variable
*
* Output:
*   No explicit value is returned. As a side effect symbol table entry
*   is updated and VM page is marked dirty.
*
* Exceptions:
*   Explicit allocation, but target segment not defined - issue error and
*   return.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         PickComDat(RBTYPE vrComdat, COMDATREC *omfRec, WORD fNew)
{
    RBTYPE              vrTmp;          // Virtual pointer to COMDAT symbol table entry
    APROPCOMDATPTR      apropComdat;    // Pointer to symbol table descriptor
    APROPFILEPTR        apropFile;      // Current object module prop. cell
    WORD                cbDataExp = 0;  // Length of expanded DATA field

#if RGMI_IN_PLACE
    rgmi = bufg;        /* use temporary buffer for holding info */
#endif

    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
    if ((ALLOC_TYPE(omfRec->attr) == EXPLICIT) &&
        omfRec->gsn && (mpgsnrprop[omfRec->gsn] == VNIL))
    {
        // ERROR - explicit allocation segment not defined

        OutError(ER_comdatalloc, 1 + GetPropName(apropComdat));
        return;
    }

    // Fill in the COMDAT descriptor

    apropComdat->ac_ggr  = omfRec->ggr;
    apropComdat->ac_gsn  = omfRec->gsn;
    apropComdat->ac_ra   = omfRec->ra;

    if (IsITERATED (omfRec->flags))  // We'll need to find size of expanded block
    {
        BYTE *pb = rgmi;
        vcbData  = (WORD)(cbRec - 1);// Length of the DATA field

        GetBytesNoLim (rgmi, vcbData);
        while((pb = ObExpandIteratedData(pb,1, &cbDataExp)) < rgmi + vcbData);
        apropComdat->ac_size = cbDataExp;

    }
    else
    {
        apropComdat->ac_size = cbRec - 1;
    }

    if (fNew)
    {
        apropComdat->ac_flags = omfRec->flags;
#if OVERLAYS
        if (IsVTABLE(apropComdat->ac_flags))
            apropComdat->ac_iOvl = IOVROOT;
        else
            apropComdat->ac_iOvl = NOTIOVL;
#endif
    }
    else
        apropComdat->ac_flags |= omfRec->flags;
    apropComdat->ac_selAlloc  = (BYTE) omfRec->attr;
    apropComdat->ac_align = (BYTE) omfRec->align;
    if (ALLOC_TYPE(omfRec->attr) == EXACT)
        apropComdat->ac_data = DoCheckSum();
    else
        apropComdat->ac_data = 0L;
    apropComdat->ac_obj    = vrpropFile;
    apropComdat->ac_objLfa = lfaLast;
    if (IsORDERED(apropComdat->ac_flags))
        apropComdat->ac_flags |= DEFINED_BIT;


    if (!IsCONCAT(omfRec->flags))
    {
        if (ALLOC_TYPE(omfRec->attr) == EXPLICIT)
        {
            // Attach this COMDAT to its segment list

            AttachComdat(vrComdat, omfRec->gsn);
        }
#if OVERLAYS
        else if (fOverlays && (apropComdat->ac_iOvl == NOTIOVL))
            apropComdat->ac_iOvl = iovFile;
#endif
        // Attach this COMDAT to its file list

        apropFile = (APROPFILEPTR ) FetchSym(vrpropFile, TRUE);
        if (apropFile->af_ComDat == VNIL)
        {
            apropFile->af_ComDat = vrComdat;
            apropFile->af_ComDatLast = vrComdat;
        }
        else
        {
            vrTmp = apropFile->af_ComDatLast;
            apropFile->af_ComDatLast = vrComdat;
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, TRUE);
            apropComdat->ac_sameFile = vrComdat;
        }
    }
}

/*** ReadComDat - self-explanatory
*
* Purpose:
*   Decode the COMDAT record.
*
* Input:
*   omfRec  - pointer to COMDAT OMF record
*   bsInput - current .OBJ file - global variable
*   grMac   - current maximum number of group defined in this .OBJ module
*             global variable
*   snMac   - current maximum number of segments defined in this .OBJ
*             module - global variable
*   mpgrggr - table mapping local group index to global group index - global
*             variable
*   mpsngsn - table mapping local segment index to global segment index
*             - global variable
*
* Output:
*   Returns COMDAT symbol name, group and segment indexes, data offset
*   attributes and aligment.
*
* Exceptions:
*   Invalid .OBJ format.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         ReadComDat(COMDATREC *omfRec)
{
    SNTYPE              sn;             // Local SEGDEF no. - module scope only


    omfRec->ggr = 0;
    omfRec->gsn = 0;

    // The record header (type and length) has been already read
    // and stored in rect and cbRec - read the COMDAT attribute byte

    omfRec->flags = (WORD) Gets();
    omfRec->attr  = (WORD) Gets();
    omfRec->align = (WORD) Gets();
#if OMF386
    if(rect & 1)
        omfRec->ra = LGets();
    else
#endif
        omfRec->ra = WGets();           // Get COMDAT data offset
    omfRec->type = GetIndex(0, 0x7FFF); // Get type index
    if (ALLOC_TYPE(omfRec->attr) == EXPLICIT)
    {
        // If explicit allocation read the public base of COMDAT symbol

        omfRec->ggr = (GRTYPE) GetIndex(0, (WORD) (grMac - 1));
                                        // Get group index
        if(!(sn = GetIndex(0, (WORD) (snMac - 1))))
        {
                                        // If frame number present
            omfRec->gsn = 0;            // No global SEGDEF no.
            SkipBytes(2);               // Skip the frame number
        }
        else                            // Else if local SEGDEF no. given
        {
            if (omfRec->ggr != GRNIL)
                omfRec->ggr = mpgrggr[omfRec->ggr];   // If group specified, get global no
            omfRec->gsn = mpsngsn[sn];         // Get global SEGDEF no.
        }
    }
    omfRec->name = mplnamerhte[GetIndex(1, (WORD) (lnameMac - 1))];
                                        // Get symbol length
}


/*** ConcatComDat - append COMDAT to the list of concatenated records
*
* Purpose:
*   Concatenate COMDAT records. This function build the list of COMDAT
*   descriptors for contatenated records. Only the first descriptor
*   on the list has attribute COMDAT, which means that the head of the
*   list can be found when looking up the symbol table. The rest of the
*   elements on the list remain anonymus.
*
* Input:
*   vrComdat    - virtual pointer to the first descriptor on the list
*   omfRec      - pointer to COMDAT OMF record
*
* Output:
*   No explicit value is returned. As a side effect this function
*   adds the descriptor to the list of concatenated COMDAT records.
*
* Exceptions:
*   Different attributes in the first and concatenated records - display
*   error message and skip the concatenated record.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         ConcatComDat(RBTYPE vrComdat, COMDATREC *omfRec)
{
    APROPCOMDATPTR      apropComdatNew; // Real pointer to added COMDAT
    RBTYPE              vrComdatNew;    // Virtual pointer to added COMDAT
    APROPCOMDATPTR      apropComdat;    // Real pointer to the head of the list
    RBTYPE              vrTmp;


    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
    if (apropComdat->ac_gsn != omfRec->gsn ||
        apropComdat->ac_ggr != omfRec->ggr ||
        apropComdat->ac_selAlloc != (BYTE) omfRec->attr)
    {
        if(IsORDERED(apropComdat->ac_flags) &&
            (ALLOC_TYPE(apropComdat->ac_selAlloc) == EXPLICIT))
        {
            // Must preserve the allocation info from the .def file
            omfRec->gsn = apropComdat->ac_gsn;
            omfRec->ggr = apropComdat->ac_ggr;
            omfRec->attr = apropComdat->ac_selAlloc;
        }
        else
            OutError(ER_badconcat, 1 + GetPropName(apropComdat));
    }
    vrComdatNew = RbAllocSymNode(sizeof(APROPCOMDAT));
                                // Allocate symbol space
    apropComdatNew = (APROPCOMDATPTR ) FetchSym(vrComdatNew, TRUE);
    apropComdatNew->ac_next = NULL;
    apropComdatNew->ac_attr = ATTRNIL;
    PickComDat(vrComdatNew, omfRec, TRUE);
    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
                                // Refetch head of the list
    if (apropComdat->ac_concat == VNIL)
        apropComdat->ac_concat = vrComdatNew;
    else
    {
        // Append at the end of the list

        vrTmp = apropComdat->ac_concat;
        while (vrTmp != VNIL)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, TRUE);
            vrTmp = apropComdat->ac_concat;
        }
        apropComdat->ac_concat = vrComdatNew;
    }
}


/*** AttachPublic - add matching public symbol to the COMDAT
*
* Purpose:
*   Attaches public symbol definition to the COMDAT definition. It is
*   necessary because the fixups work only on matched EXTDEF with PUBDEF
*   not with COMDAT, so in order to correctly resolve references to COMDAT
*   symbol linker needs the PUBDEF for the same symbol, which eventually
*   will be matched with references made to the EXTDEF.
*   The public symbols for COMDAT's are created when we see new COMDAT
*   symbol or we have COMDAT introduced by ORDER statement in the .DEF
*   file.
*
* Input:
*   vrComdat    - virtual pointer to COMDAT descriptor
*   omfRec      - COMDAT record
*
* Output:
*   No explicit value is returned. As a side effect the link is created
*   between COMDAT descriptor and new PUBDEF descriptor.
*
* Exceptions:
*   COMDAT symbol matches COMDEF symbol - display error and contine
*   with COMDEF symbol converted to PUBDEF.  The .EXE will not load
*   under OS/2 or Windows, because the error bit will be set.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         AttachPublic(RBTYPE vrComdat, COMDATREC *omfRec)
{
    APROPNAMEPTR        apropName;      // Symbol table entry for public name
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    WORD                fReferenced;    // TRUE if we've seen CEXTDEF


    fReferenced = FALSE;
    apropName = (APROPNAMEPTR ) PropRhteLookup(omfRec->name, ATTRUND, FALSE);
                                        // Look for symbol among undefined
        if (apropName != PROPNIL)               // Symbol known to be undefined
        {
                fReferenced = TRUE;
#if TCE
                if(((APROPUNDEFPTR)apropName)->au_fAlive)  // was called from a non-COMDAT
                {
#if TCE_DEBUG
                        fprintf(stdout, "\r\nAlive UNDEF -> COMDAT %s ", 1+GetPropName(apropName));
#endif
                        AddTceEntryPoint((APROPCOMDAT*)vrComdat);
                }
#endif
    }
    else
        apropName = (APROPNAMEPTR ) PropAdd(omfRec->name, ATTRPNM);
                                        // Else try to create new entry
    apropName->an_attr = ATTRPNM;       // Symbol is a public name
    apropName->an_thunk = THUNKNIL;

    if (IsLOCAL(omfRec->flags))
    {
        apropName->an_flags = 0;
#if ILINK
        ++locMac;
#endif
    }
    else
    {
        apropName->an_flags = FPRINT;
        ++pubMac;
    }
#if ILINK
    apropName->an_module = imodFile;
#endif
    MARKVP();                           // Mark virtual page as changed
    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
    apropComdat->ac_pubSym = vrprop;
    if (fReferenced)
        apropComdat->ac_flags |= REFERENCED_BIT;
#if SYMDEB
    if (fSymdeb && !IsLOCAL(omfRec->flags) && !fSkipPublics)
    {
        DebPublic(vrprop, PUBDEF);
    }
#endif
}

/*** ComDatRc1 - process COMDAT record in pass 1
*
* Purpose:
*   Process COMDAT record in pass 1.  Select appropriate copy of COMDAT.
*
* Input:
*   No explicit value is passed to this function. The OMF record is
*   read from input file bsInput - global variable.
*
* Output:
*   No explicit value is returned. Valid COMDAT descriptor is entered into
*   the linker symbol table. If necessary list of COMDATs allocated in the
*   explicit segment is updated.
*
* Exceptions:
*   Explicit allocation segment not found - error message and skip the record.
*   We have public with the same name as COMDAT - error message and skip
*   the record.
*
* Notes:
*   None.
*
*************************************************************************/

void NEAR               ComDatRc1(void)
{
    COMDATREC           omfRec;         // COMDAT OMF record
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT record
    char                *sbName;        // COMDAT symbol


    ReadComDat(&omfRec);
    apropComdat = (APROPCOMDATPTR ) PropRhteLookup(omfRec.name, ATTRCOMDAT, FALSE);
                                        // Look for symbol among COMDATs
    vrComdat = vrprop;
#if TCE
        pActiveComdat = apropComdat;
#endif
    if (apropComdat != PROPNIL)
    {
        // We already know a COMDAT with this name


        if (IsORDERED(apropComdat->ac_flags) && !IsDEFINED(apropComdat->ac_flags))
        {
            if (ALLOC_TYPE(apropComdat->ac_selAlloc) == EXPLICIT)
            {
                // Preserve explicit allocation from the .def file

                omfRec.gsn  = apropComdat->ac_gsn;
                omfRec.attr = apropComdat->ac_selAlloc;
            }
            PickComDat(vrComdat, &omfRec, FALSE);
            AttachPublic(vrComdat, &omfRec);
        }
        else if (!SkipCONCAT(apropComdat->ac_flags) &&
                 IsCONCAT(omfRec.flags) &&
                 (apropComdat->ac_obj == vrpropFile))
        {
            // Append concatenation record

            ConcatComDat(vrComdat, &omfRec);
        }
        else
        {
#if TCE
                pActiveComdat = NULL;     // not needed for TCE
#endif
                apropComdat->ac_flags |= SKIP_BIT;
                sbName = 1 + GetPropName(apropComdat);
                switch (SELECT_TYPE(omfRec.attr))
                {
                case ONLY_ONCE:
                        DupErr(sbName);
                        break;

                case PICK_FIRST:
                        break;

                case SAME_SIZE:
                    if (apropComdat->ac_size != (DWORD) (cbRec - 1))
                        OutError(ER_badsize, sbName);
                    break;

                case EXACT:
                    if (apropComdat->ac_data != DoCheckSum())
                        OutError(ER_badexact, sbName);
                    break;

                default:
                    OutError(ER_badselect, sbName);
                    break;
            }
        }
    }
    else
    {
        // Check if we know a public symbol with this name
                apropComdat = (APROPCOMDATPTR ) PropRhteLookup(omfRec.name, ATTRPNM, FALSE);
                if (apropComdat != PROPNIL)
                {
                        if (!IsCONCAT(omfRec.flags))
                        {
                                sbName = 1 + GetPropName(apropComdat);
                                DupErr(sbName);         // COMDAT matches code PUBDEF
                        }                                               // Display error only for the first COMDAT
                                        // ignore concatenation records
                }
                else
                {
                        // Enter COMDAT into symbol table
                        apropComdat = (APROPCOMDATPTR ) PropAdd(omfRec.name, ATTRCOMDAT);
                        vrComdat = vrprop;
                        PickComDat(vrprop, &omfRec, TRUE);
                        AttachPublic(vrComdat, &omfRec);
#if TCE
#define ENTRIES 32
#if 0
                        fprintf(stdout, "\r\nNew COMDAT '%s' at %X; ac_uses %X, ac_usedby %X ",
                                1+GetPropName(apropComdat), apropComdat,&(apropComdat->ac_uses), &(apropComdat->ac_usedby));
                        fprintf(stdout, "\r\nNew COMDAT '%s' ",1+GetPropName(apropComdat));
#endif
                        apropComdat->ac_fAlive  = FALSE;    // Assume it is unreferenced
                        apropComdat->ac_uses.cEntries    = 0;
                        apropComdat->ac_uses.cMaxEntries = ENTRIES;
                        apropComdat->ac_uses.pEntries    = GetMem(ENTRIES * sizeof(APROPCOMDAT*));
                        pActiveComdat = apropComdat;
#endif
                }
        }
        SkipBytes((WORD) (cbRec - 1));  // Skip to check sum byte
}


/*** AdjustOffsets - adjust COMDATs offsets
*
* Purpose:
*   Adjust COMDATs offsets to reflect their position inside
*   logical segments.
*
* Input:
*   vrComdat - virtual pointer to COMDAT symbol table entry
*   startOff - starting offset in the logical segment
*   gsnAlloc - global segment index of allocation segment
*
* Output:
*   No explicit value is returned. As a side effect offsets
*   of COMDAT data block are adjusted to their final position
*   inside the logical segment. All concatenated COMDAT block
*   get proper global logical segment index.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         AdjustOffsets(RBTYPE vrComdat, DWORD startOff, SNTYPE gsnAlloc)
{
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol


    while (vrComdat != VNIL)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
                                        // Fetch COMDAT descriptor from VM
        apropComdat->ac_ra += startOff;
        apropComdat->ac_gsn = gsnAlloc;
        vrComdat = apropComdat->ac_concat;
    }
}


/*** SizeOfComDat - return the size of COMDAT data
*
* Purpose:
*   Calculate the size of COMDAT data block. Takes into account the initial
*   offset from the COMDAT symbol and concatenation records.
*
* Input:
*   vrComdat - virtual pointer to COMDAT symbol table entry
*
* Output:
*   Returns TRUE and the size of COMDAT data block in pActual, otherwise
*   function returns FALSE and pActual is invalid.
*
* Exceptions:
*   COMDAT data block greater then 64k and allocation in 16-bit segment
*   - issue error and return FALSE
*   COMDAT data block grater then 4Gb - issue error and return FALSE
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL WORD NEAR         SizeOfComDat(RBTYPE vrComdat, DWORD *pActual)
{
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    APROPSNPTR          apropSn;        // Pointer to COMDAT explicit segment
    long                raInit;         // Initial offset from COMDAT symbol
    DWORD               sizeTotal;      // Total size of data blocks
    WORD                f16bitAlloc;    // TRUE if allocation in 16-bit segment
    RBTYPE              vrTmp;


    *pActual = 0L;
    raInit   = -1L;
    sizeTotal= 0L;
    f16bitAlloc = FALSE;
    vrTmp    = vrComdat;
    while (vrTmp != VNIL)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, FALSE);
                                        // Fetch COMDAT descriptor from VM
        if (raInit == -1L)
            raInit = apropComdat->ac_ra;// Remember initial offset
        else if (apropComdat->ac_ra < sizeTotal)
            sizeTotal = apropComdat->ac_ra;
                                        // Correct size for overlaping blocks
        if (sizeTotal + apropComdat->ac_size < sizeTotal)
        {
            // Oops !!! more then 4Gb

            OutError(ER_size4Gb, 1 + GetPropName(apropComdat));
            return(FALSE);

        }
        sizeTotal += apropComdat->ac_size;
        vrTmp = apropComdat->ac_concat;
    }
    sizeTotal += raInit;
    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Refetch COMDAT descriptor from VM
    if (apropComdat->ac_gsn)
    {
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[apropComdat->ac_gsn],FALSE);
                                        // Fetch SEGDEF from virtual memory
#if NOT EXE386
        if (!Is32BIT(apropSn->as_flags))
            f16bitAlloc = TRUE;
#endif
    }
    else
        f16bitAlloc = (WORD) ((ALLOC_TYPE(apropComdat->ac_selAlloc) == CODE16) ||
                              (ALLOC_TYPE(apropComdat->ac_selAlloc) == DATA16));

    if (f16bitAlloc && sizeTotal > LXIVK)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
        OutError(ER_badsize, 1 + GetPropName(apropComdat));
        return(FALSE);
    }
    *pActual = sizeTotal;
    return(TRUE);
}


/*** DoAligment - self-explanatory
*
* Purpose:
*   Given the aligment type round the value to the specific boundary.
*
* Input:
*   value - value to align
*   align - aligment type
*
* Output:
*   Returns the aligned value.
*
* Exceptions:
*   Unknow aligment type - do nothing.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL RATYPE NEAR       DoAligment(RATYPE value, WORD align)
{
    if (align == ALGNWRD)
        value = (~0L<<1) & (value + (1<<1) - 1);
                            // Round size up to word boundary
#if OMF386
    else if (align == ALGNDBL)
        value = (~0L<<2) & (value + (1<<2) - 1);
#endif                      // Round size up to double boundary
    else if (align == ALGNPAR)
        value = (~0L<<4) & (value + (1<<4) - 1);
                            // Round size up to para. boundary
    else if (align == ALGNPAG)
        value = (~0L<<8) & (value + (1<<8) - 1);
                            // Round size up to page boundary
    return(value);
}

/*** DoAllocation - palce COMDAT inside given segment
*
* Purpose:
*   Perform actual COMDAT allocation in given segment. Adjust COMDAT
*   position according to the segment or COMDAT (if specified) aligment.
*
* Input:
*   gsnAlloc    - allocation segment global index
*   gsnSize     - current segment size
*   vrComdat    - virtual pointer to COMDAT descriptor
*   comdatSize  - comdat size
*
* Output:
*   Function returns the new segment size.  As a side effect the COMDAT
*   descriptor is updated to reflect its allocation and the matching
*   PUBDEF is entered into symbol table.
*
* Exceptions:
*   None.
*
* Notes:
*   After allocation the field ac_size is the size of the whole
*   COMDAT allocation including all concatenated records, so don't use
*   it for determinig the size of this COMDAT record..
*
*************************************************************************/

LOCAL DWORD NEAR        DoAllocation(SNTYPE gsnAlloc, DWORD size,
                                     RBTYPE vrComdat, DWORD comdatSize)
{
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    APROPSNPTR          apropSn;        // Pointer to COMDAT segment
    APROPNAMEPTR        apropName;      // Symbol table entry for public name
    WORD                comdatAlloc;    // Allocation criteria
    WORD                comdatAlign;    // COMDAT alignment
    WORD                align;          // Alignment type
    WORD                f16bitAlloc;    // TRUE if allocation in 16-bit segment
    WORD                fCode;          // TRUE if allocation in code segment
    GRTYPE              comdatGgr;      // Global group index
    RATYPE              comdatRa;       // Offset in logical segmet


    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
    if (IsALLOCATED(apropComdat->ac_flags)
#if OVERLAYS
        || (fOverlays && (apropComdat->ac_iOvl != iOvlCur))
#endif
       )
        return(size);
#if TCE
        if (fTCE && !apropComdat->ac_fAlive)
        {
#if TCE_DEBUG
                fprintf(stdout, "\r\nComdat '%s' not included due to TCE ",
                        1+GetPropName(apropComdat));
#endif
                apropComdat->ac_flags = apropComdat->ac_flags & (!REFERENCED_BIT);
                return(size);
        }
#endif
    comdatAlloc = (WORD) (ALLOC_TYPE(apropComdat->ac_selAlloc));
    comdatAlign = apropComdat->ac_align;
    comdatGgr   = apropComdat->ac_ggr;
    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnAlloc],FALSE);
    fCode = (WORD) IsCodeFlg(apropSn->as_flags);
    if (comdatAlign)
        align = comdatAlign;
    else
        align = (WORD) ((apropSn->as_tysn >> 2) & 7);

    size = DoAligment(size, align);
    if (comdatAlloc == CODE16 || comdatAlloc == DATA16)
        f16bitAlloc = TRUE;
#if NOT EXE386
    else if (!Is32BIT(apropSn->as_flags))
        f16bitAlloc = TRUE;
#endif
    else
        f16bitAlloc = FALSE;

    if (SegSizeOverflow(size, comdatSize, f16bitAlloc, fCode))
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnAlloc],FALSE);
        Fatal(ER_nospace, 1 + GetPropName(apropComdat), 1 + GetPropName(apropSn));
    }
    else
    {
        AdjustOffsets(vrComdat, size, gsnAlloc);
        size += comdatSize;
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
        comdatRa = apropComdat->ac_ra;
        apropComdat->ac_flags |= ALLOCATED_BIT;
        apropComdat->ac_size = comdatSize;
        if (apropComdat->ac_pubSym != VNIL)
        {
            apropName = (APROPNAMEPTR ) FetchSym(apropComdat->ac_pubSym, TRUE);
            apropName->an_ggr = comdatGgr;
            apropName->an_gsn = gsnAlloc;
            apropName->an_ra  = comdatRa;
        }
        else
            Fatal(ER_unalloc, 1 + GetPropName(apropComdat));
    }
    return(size);
}


/*** AllocComDat - allocate COMDATs
*
* Purpose:
*   Allocate COMDATs in the final memory image. First start with ordered
*   allocation - in .DEF file we saw the list of procedures. Next allocate
*   explicitly assinged COMDATs to specific logical segments. And finally
*   allocate the rest of COMDATs creating as many as necessary segments
*   to hold all allocations.
*
* Input:
*   No ecplicit value is passed - I love this - side effects forever.
*   In the good linker tradition of using global variables, here is the
*   list of globals used by this function:
*
*   mpgsnaprop  - table mapping global segment index to symbol table entry
*   gsnMac      - maximum global segment index
*
* Output:
*   No explicit value is returned - didn't I tell you - side effects forever.
*   So, the side effect of this function is the allocation of COMDATs in the
*   appropriate logical segments. The offset fields in the COMDAT descriptor
*   (ac_ra) now reflect the final posiotion of data block associated with the
*   COMDAT symbol inside given logical segment. The sizes of appropriate
*   segments are updated to reflect allocation of COMDATs. For every COMDAT
*   symbol there is a matching PUBDEF created by this function, so in pass2
*   linker can resolve correctly all references (via fixups to EXTDEF with
*   the COMDAT name) to COMDAT symbols.
*
* Exceptions:
*   No space in explicitly designated segment for COMDAT - print error
*   message and skip COMDAT; probably in pass2 user will see many
*   unresolved externals.
*
* Notes:
*   This function MUST be called before AssignAddresses. Otherwise there
*   will be no spcase for COMDAT allocation, because logical segments will
*   packed into physical ones.
*
*************************************************************************/

void NEAR               AllocComDat(void)
{
    SNTYPE              gsn;
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    APROPSNPTR          apropSn;        // Pointer to COMDAT explicit segment
    RATYPE              gsnSize;        // Size of explicit segment
    DWORD               comdatSize;     // COMDAT data block size
    APROPCOMDAT         comdatDsc;      // COMDAT symbol table descriptor
    APROPFILEPTR        apropFile;      // Pointer to file entry
    APROPNAMEPTR        apropName;      // Pointer to matching PUBDEF
    RBTYPE              vrFileNext;     // Virtual pointer to prop list of next file


#if COMDATDEBUG
    DisplayComdats("BEFORE allocation", FALSE);
#endif
#if TCE
        APROPCOMDATPTR      apropMain;
        // Do Transitive Comdat Elimination (TCE)
        if(fTCE)
        {
                apropMain = PropSymLookup("\5_main", ATTRCOMDAT, FALSE);
                if(apropMain)
                        AddTceEntryPoint(apropMain);
#if TCE_DEBUG
                else
                        fprintf(stdout, "\r\nUnable to find block '_main' ");
#endif
                apropMain = PropSymLookup("\7WINMAIN", ATTRCOMDAT, FALSE);
                if(apropMain)
                        AddTceEntryPoint(apropMain);
#if TCE_DEBUG
                else
                        fprintf(stdout, "\r\nUnable to find block 'WINMAIN' ");
#endif
                apropMain = PropSymLookup("\7LIBMAIN", ATTRCOMDAT, FALSE);
                if(apropMain)
                        AddTceEntryPoint(apropMain);
#if TCE_DEBUG
                else
                        fprintf(stdout, "\r\nUnable to find block 'LIBMAIN' ");
#endif
                PerformTce();
        }
#endif
    // Loop thru overlays - for non overlayed executables
    // the following loop is executed only once - iovMac = 1

#if OVERLAYS
    for (iOvlCur = 0; iOvlCur < iovMac; iOvlCur++)
    {
#endif
        // Do ordered allocation

        for (vrComdat = procOrder; vrComdat != VNIL; vrComdat = comdatDsc.ac_order)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
            comdatDsc = *apropComdat;
            if (!(comdatDsc.ac_flags & DEFINED_BIT))
            {
                OutWarn(ER_notdefcomdat, 1 + GetPropName(apropComdat));
                continue;
            }

#if OVERLAYS
            if (fOverlays && (apropComdat->ac_iOvl != NOTIOVL) &&
                (apropComdat->ac_iOvl != iOvlCur))
                continue;
#endif
            if (fPackFunctions && !IsREFERENCED(apropComdat->ac_flags))
                continue;

            if (SizeOfComDat(vrComdat, &comdatSize))
            {
                if (ALLOC_TYPE(comdatDsc.ac_selAlloc) == EXPLICIT)
                {
                    gsn = comdatDsc.ac_gsn;
                    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], FALSE);
                    gsnSize = apropSn->as_cbMx;
                    gsnSize = DoAllocation(gsn, gsnSize, vrComdat, comdatSize);
                    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], TRUE);
                    apropSn->as_cbMx = gsnSize;
                }
                else if (ALLOC_TYPE(comdatDsc.ac_selAlloc) != ALLOC_UNKNOWN)
                    AllocAnonymus(vrComdat);
            }
        }

        // Do explicit allocation

        for (gsn = 1; gsn < gsnMac; gsn++)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
                                        // Fetch SEGDEF from virtual memory
#if OVERLAYS
            if (fOverlays && apropSn->as_iov != iOvlCur)
                continue;
#endif
            if (apropSn->as_ComDat != VNIL)
            {
                gsnSize  = apropSn->as_cbMx;
                for (vrComdat = apropSn->as_ComDat;
                     vrComdat != VNIL && SizeOfComDat(vrComdat, &comdatSize);
                     vrComdat = apropComdat->ac_sameSeg)
                {
                    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);

                    if ((!fPackFunctions || IsREFERENCED(apropComdat->ac_flags)) &&
                        !IsALLOCATED(apropComdat->ac_flags))
                    {
                        gsnSize = DoAllocation(gsn, gsnSize, vrComdat, comdatSize);
                    }
                }
                apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], TRUE);
                apropSn->as_cbMx = gsnSize;
            }
        }

        // Now allocate the rest of COMDATs

        vrFileNext = rprop1stFile;      // Next file to look at is first
        while (vrFileNext != VNIL)      // Loop to process objects
        {
            apropFile = (APROPFILEPTR ) FetchSym(vrFileNext, FALSE);
                                        // Fetch table entry from VM

            vrFileNext = apropFile->af_FNxt;
                                        // Get pointer to next file
            for (vrComdat = apropFile->af_ComDat;
                 vrComdat != VNIL;
                 vrComdat = apropComdat->ac_sameFile)
            {
                apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Fetch table entry from VM
#if OVERLAYS
                if (fOverlays && (apropComdat->ac_iOvl != NOTIOVL) &&
                    (apropComdat->ac_iOvl != iOvlCur))
                    continue;
#endif
                if (!IsREFERENCED(apropComdat->ac_flags))
                {
                    // Mark matching PUBDEF as unreferenced, so it shows
                    // in the map file

                    apropName = (APROPNAMEPTR) FetchSym(apropComdat->ac_pubSym, TRUE);
                    apropName->an_flags |= FUNREF;
                }

                if ((!fPackFunctions || IsREFERENCED(apropComdat->ac_flags)) &&
                    !IsALLOCATED(apropComdat->ac_flags))
                {
                    if (ALLOC_TYPE(apropComdat->ac_selAlloc) != ALLOC_UNKNOWN)
                    {
                        AllocAnonymus(vrComdat);
                    }
                }
            }
        }

        // Close all open segments for anonymus allocation

        if (curGsnCode16)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[curGsnCode16], TRUE);
            apropSn->as_cbMx = curCodeSize16;
            curGsnCode16  = 0;
            curCodeSize16 = 0;
        }

        if (curGsnData16)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[curGsnData16], TRUE);
            apropSn->as_cbMx = curDataSize16;
            curGsnData16  = 0;
            curDataSize16 = 0;
        }
#if EXE386
        if (curGsnCode32)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[curGsnCode32], TRUE);
            apropSn->as_cbMx = curCodeSize32;
            curGsnCode32  = 0;
            curCodeSize32 = 0;
        }

        if (curGsnData32)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[curGsnData32], TRUE);
            apropSn->as_cbMx = curDataSize32;
            curGsnData32  = 0;
            curDataSize32 = 0;
        }
#endif
#if OVERLAYS
    }
#endif
#if COMDATDEBUG
    DisplayComdats("AFTER allocation", FALSE);
#endif
}

/*** NewSegment - open new COMDAT segment
*
* Purpose:
*   Open new linker defined segment. The name of the segment is created
*   according to the following template:
*
*       COMDAT_SEG<nnn>
*
*   where - <nnn> is the segment number.
*   If there was previous segment, then update its size.
*
* Input:
*   gsnPrev   - previous segment global index
*   sizePrev  - previous segment size
*   allocKind - segment type to open
*
* Output:
*   Function returns the new global segment index in gsnPrev and
*   new segment aligment;
*
* Exceptions:
*   To many logical segments - error message displayed by GenSeg
*   and abort.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL WORD NEAR         NewSegment(SNTYPE *gsnPrev, DWORD *sizePrev, WORD allocKind)
{
    static int          segNo = 1;      // Segment number
    char                segName[20];    // Segment name - no names longer then
                                        // 20 chars since we are generating them
    APROPSNPTR          apropSn;        // Pointer to COMDAT segment


    if (*gsnPrev)
    {
        // Update previous segment size

        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[*gsnPrev], TRUE);
        apropSn->as_cbMx = *sizePrev;
        *sizePrev = 0L;
    }

    // Create segment name

    strcpy(segName, COMDAT_SEG_NAME);
    _itoa(segNo, &segName[COMDAT_NAME_LEN], 10);
    segName[0] = (char) strlen(&segName[1]);
    ++segNo;

    if (allocKind == CODE16 || allocKind == CODE32)
    {
        apropSn = GenSeg(segName, "\004CODE", GRNIL, (FTYPE) TRUE);
        apropSn->as_flags = dfCode;     // Use default code flags
    }
    else
    {
        apropSn = GenSeg(segName,
                         allocKind == DATA16 ? "\010FAR_DATA" : "\004DATA",
                         GRNIL, (FTYPE) TRUE);
        apropSn->as_flags = dfData;     // Use default data flags
    }
#if OVERLAYS
    apropSn->as_iov = (IOVTYPE) NOTIOVL;
    CheckOvl(apropSn, iOvlCur);
#endif

    // Set segment aligment

#if EXE386
    apropSn->as_tysn = DWORDPUBSEG;     // DWORD
#else
    apropSn->as_tysn = PARAPUBSEG;      // Paragraph
#endif
    *gsnPrev = apropSn->as_gsn;
    apropSn->as_fExtra |= COMDAT_SEG;
    return((WORD) ((apropSn->as_tysn >> 2) & 7));
}


/*** SegSizeOverflow - check the segment size
*
* Purpose:
*   Check if the allocation of the COMDAT in a given segment will
*   overflow its size limits. The segment size limit can be changed
*   by the /PACKCODE:<nnn> or /PACKDATA:<nnn> options. If the /PACKxxxx
*   options are not used the limits are:
*
*       - 64k - 36 - for 16-bit code segments
*       - 64k      - for 16-bit data segments
*       - 4Gb      - for 32-bit code/data segments
*
* Input:
*   segSize    - segment size
*   comdatsize - COMDAT size
*   f16bit     - TRUE if 16-bit segment
*   fCode      - TRUE if code segment
*
* Output:
*   Function returns TRUE if size overflow, otherwise function
*   returns FALSE.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL WORD NEAR         SegSizeOverflow(DWORD segSize, DWORD comdatSize,
                                        WORD f16bit, WORD fCode)
{
    DWORD               limit;

    if (fCode)
    {
        if (packLim)
            limit = packLim;
        else if (f16bit)
            limit = LXIVK - 36;
        else
            limit = CBMAXSEG32;
    }
    else
    {
        if (DataPackLim)
            limit = DataPackLim;
        else if (f16bit)
            limit = LXIVK;
        else
            limit = CBMAXSEG32;
    }
    return(limit - comdatSize < segSize);
}

/*** AttachComdat - add comdat to the segment list
*
* Purpose:
*   Add comdat descriptor to the list of comdats allocated in the
*   given logical segment. Check for overlay assigment missmatch
*   and report problems.
*
* Input:
*   vrComdat - virtual pointer to the comdat descriptor
*   gsn      - global logical segment index
*
* Output:
*   No explicit value is returned. As a side effect the comdat
*   descriptor is placed on the allocation list of given segment.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    AttachComdat(RBTYPE vrComdat, SNTYPE gsn)
{
    RBTYPE              vrTmp;          // Virtual pointer to COMDAT symbol table entry
    APROPSNPTR          apropSn;        // Pointer to COMDAT segment if explicit allocation
    APROPCOMDATPTR      apropComdat;    // Pointer to symbol table descriptor



    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);

    // Attach this COMDAT to its segment list

    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], TRUE);
#if OVERLAYS
    if (fOverlays && (apropComdat->ac_iOvl != apropSn->as_iov))
    {
        if (apropComdat->ac_iOvl != NOTIOVL)
                OutWarn(ER_badcomdatovl, 1 + GetPropName(apropComdat),
                                apropComdat->ac_iOvl, apropSn->as_iov);
        apropComdat->ac_iOvl = apropSn->as_iov;
    }
#endif
    if (apropSn->as_ComDat == VNIL)
    {
        apropSn->as_ComDat = vrComdat;
        apropSn->as_ComDatLast = vrComdat;
        apropComdat->ac_sameSeg = VNIL;
    }
    else
    {
        // Because COMDATs can be attached to a given segment in the
        // .DEF file and later in the .OBJ file, we have to check
        // if a given comdat is already on the segment list

        for (vrTmp = apropSn->as_ComDat; vrTmp != VNIL;)
        {
            if (vrTmp == vrComdat)
                return;
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, FALSE);
            vrTmp = apropComdat->ac_sameSeg;
        }

        // Add new COMDAT to the segment list

        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn], TRUE);
        vrTmp = apropSn->as_ComDatLast;
        apropSn->as_ComDatLast = vrComdat;
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, TRUE);
        apropComdat->ac_sameSeg = vrComdat;
    }
}


/*** AllocAnonymus - allocate COMDATs without explicit segment
*
* Purpose:
*   Allocate COMDATs without explicit segment. Create as many as necessary
*   code/data segments to hold all COMDATs.
*
* Input:
*   vrComdat - virtual pointer to symbol table entry for COMDAT name
*
* Output:
*   No explicit value is returned. As a side effect the COMDAT symbol is
*   allocated and matching public symbol is created. If necessary
*   appropriate segment is defined.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL void NEAR         AllocAnonymus(RBTYPE vrComdat)
{
    WORD                comdatAlloc;    // Allocation type
    WORD                comdatAlign;    // COMDAT aligment
    WORD                align;
    DWORD               comdatSize;     // COMDAT data block size
    APROPCOMDATPTR      apropComdat;    // Real pointer to COMDAT descriptor
    static WORD         segAlign16;     // Aligment for 16-bit segments
#if EXE386
    static WORD         segAlign32;     // Aligment for 32-bit segments
#endif


    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
    comdatAlloc = (WORD) (ALLOC_TYPE(apropComdat->ac_selAlloc));
    comdatAlign = apropComdat->ac_align;

    if (SizeOfComDat(vrComdat, &comdatSize))
    {
        if (comdatAlign)
            align = comdatAlign;
        else
        {
#if EXE386
            if (comdatAlloc == CODE32 || comdatAlloc == DATA32)
                align = segAlign32;
            else
#endif
                align = segAlign16;
        }
        switch (comdatAlloc)
        {
            case CODE16:
                if (!curGsnCode16 ||
                    SegSizeOverflow(DoAligment(curCodeSize16, align), comdatSize, TRUE, TRUE))
                {
                    // Open new 16-bit code segment

                    segAlign16 = NewSegment(&curGsnCode16, &curCodeSize16, comdatAlloc);
                }
                curCodeSize16 = DoAllocation(curGsnCode16, curCodeSize16, vrComdat, comdatSize);
                AttachComdat(vrComdat, curGsnCode16);
                break;

            case DATA16:
                if (!curGsnData16 ||
                    SegSizeOverflow(DoAligment(curDataSize16, align), comdatSize, TRUE, FALSE))
                {
                    // Open new 16-bit data segment

                    segAlign16 = NewSegment(&curGsnData16, &curDataSize16, comdatAlloc);
                }
                curDataSize16 = DoAllocation(curGsnData16, curDataSize16, vrComdat, comdatSize);
                AttachComdat(vrComdat, curGsnData16);
                break;
#if EXE386
            case CODE32:
                if (!curGsnCode32 ||
                    SegSizeOverflow(DoAligment(curCodeSize32, align), comdatSize, FALSE, TRUE))
                {
                    // Open new 32-bit code segment

                    segAlign32 = NewSegment(&curGsnCode32, &curCodeSize32, comdatAlloc);
                }
                curCodeSize32 = DoAllocation(curGsnCode32, curCodeSize32, vrComdat, comdatSize);
                AttachComdat(vrComdat, curGsnCode32);
                break;

            case DATA32:
                if (!curGsnData32 ||
                    SegSizeOverflow(DoAligment(curDataSize32, align), comdatSize, FALSE, FALSE))
                {
                    // Open new 32-bit data segment

                    segAlign32 = NewSegment(&curGsnData32, &curDataSize32, comdatAlloc);
                }
                curDataSize32 = DoAllocation(curGsnData32, curDataSize32, vrComdat, comdatSize);
                AttachComdat(vrComdat, curGsnData32);
                break;
#endif
            default:
                OutError(ER_badalloc, 1 + GetPropName(apropComdat));
                return;
        }
    }
}


/*** FixComdatRa - shift by 16 bytes COMDATs allocated in _TEXT
*
* Purpose:
*   Follow the /DOSSEG convention for logical segment _TEXT,
*   and shift up by 16 bytes all COMDATS allocated in this segment.
*
* Input:
*   gsnText - _TEXT global segment index - global variable
*
* Output:
*   No explicit value is returned. As a side effect the offset of
*   the COMDAT allocated in _TEXT is increased by 16.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    FixComdatRa(void)
{
    APROPSNPTR          apropSn;        // Pointer to COMDAT explicit segment
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    RBTYPE              vrConcat;       // Virtual pointer to concatenated records
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RATYPE              raShift;


    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnText], FALSE);
                                // Fetch SEGDEF from virtual memory
    raShift = mpgsndra[gsnText] - mpsegraFirst[mpgsnseg[gsnText]];
    for (vrComdat = apropSn->as_ComDat; vrComdat != VNIL;)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, TRUE);
        vrComdat = apropComdat->ac_sameSeg;
        if (fPackFunctions && !IsREFERENCED(apropComdat->ac_flags))
            continue;

        apropComdat->ac_ra += raShift;

        // Search concatenation list

        for (vrConcat = apropComdat->ac_concat; vrConcat != VNIL; vrConcat = apropComdat->ac_concat)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrConcat, TRUE);
            apropComdat->ac_ra += raShift;
        }
    }
}


/*** UpdateComdatContrib - update COMDATs contributions
*
* Purpose:
*   For every file with COMDATs add contribution information to the
*   .ILK file.  Some COMDATs are allocated in named segments, some
*   in anonynus segments created by linker. The ILINK needs to know
*   how much given .OBJ file contributed to given logical segment.
*   Since the COMDAT contributions are not visible while processing
*   object files in pass one, this function is required to update
*   contribution information.  Also if /MAP:FULL i used then add
*   COMDATs contributions to the map file information
*
* Input:
*   - fIlk         - TRUE if updating ILINK information
*   - fMap         - TRUE if updating MAP file information
*   - rprop1stFile - head of .OBJ file list
*   - vrpropFile   - pointer to the current .OBJ
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   This function has to be called after pass 2, so all non-COMDAT
*   contributions are already recorded. This allows us to detect the
*   fact that named COMDAT allocation (explicit segment) has increased
*   contribution to given logical segment by the size of COMDATs.
*
*************************************************************************/

void                    UpdateComdatContrib(
#if ILINK
                                                WORD fIlk,
#endif
                                                WORD fMap)
{
    APROPFILEPTR        apropFile;      // Pointer to file entry
    RBTYPE              vrFileNext;     // Virtual pointer to prop list of next file
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    SNTYPE              gsnCur;         // Global segment index of current segment
    DWORD               sizeCur;        // Current segment size
    RATYPE              raInit;         // Initial offset of the first COMDAT
                                        // allocated in the given segment
#if ILINK
    RATYPE              raEnd;          // End offset
#endif
    vrFileNext = rprop1stFile;          // Next file to look at is first
    while (vrFileNext != VNIL)          // Loop to process objects
    {
        vrpropFile = vrFileNext;        // Make next file the current file
        apropFile = (APROPFILEPTR ) FetchSym(vrFileNext, FALSE);
                                        // Fetch table entry from VM
        vrFileNext = apropFile->af_FNxt;// Get pointer to next file
        vrComdat = apropFile->af_ComDat;
#if ILINK
        imodFile = apropFile->af_imod;
#endif
        sizeCur = 0L;
        while (vrComdat != VNIL)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Fetch table entry from VM
            vrComdat = apropComdat->ac_sameFile;
            if (fPackFunctions && !IsREFERENCED(apropComdat->ac_flags))
                continue;

            raInit = apropComdat->ac_ra;
            gsnCur = apropComdat->ac_gsn;
#if ILINK
            raEnd  = raInit + apropComdat->ac_size;
#endif
            sizeCur = apropComdat->ac_size;

            // Save information about contributions

#if ILINK
            if (fIlk)
                AddContribution(gsnCur, (WORD) raInit, (WORD) raEnd, cbPadCode);
#endif
            if (fMap)
                AddContributor(gsnCur, raInit, sizeCur);
        }
    }
}


#if SYMDEB

/*** DoComdatDebugging - notify CodeView about segments with COMDATs
*
* Purpose:
*   CodeView expects in sstModules subsection an information about code
*   segments defined in the given object module (.OBJ file).  When COMDATs
*   are present linker has no way of figuring this out in pass 1, because
*   there is no code segment definitions (all COMDATs have anonymus
*   allocation) or the code segments have size zero (explicit allocation).
*   This function is called after the COMDAT allocation is performed and
*   segments have assigned their addresses. The list of .OBJ files is
*   traversed and for each .OBJ file the list of COMDATs defined in this
*   file is examined and the appropriate code segment information is
*   stored for CodeView.
*
* Input:
*   No explicit value is passed. The following global variables are used:
*
*       rprop1stFile - head of .OBJ file list
*       vrpropFile   - pointer to the current .OBJ
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void NEAR               DoComdatDebugging(void)
{
    APROPFILEPTR        apropFile;      // Pointer to file entry
    RBTYPE              vrFileNext;     // Virtual pointer to prop list of next file
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    SNTYPE              gsnCur;         // Global segment index of current segment
    RATYPE              raInit;         // Initial offset of the first COMDAT
                                        // allocated in the given segment
    RATYPE              raEnd;          // End of contributor

    vrFileNext = rprop1stFile;          // Next file to look at is first
    while (vrFileNext != VNIL)          // Loop to process objects
    {
        vrpropFile = vrFileNext;        // Make next file the current file
        apropFile = (APROPFILEPTR ) FetchSym(vrFileNext, FALSE);
                                        // Fetch table entry from VM
        vrFileNext = apropFile->af_FNxt;// Get pointer to next file

        vrComdat = apropFile->af_ComDat;
        while (vrComdat != VNIL)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Fetch table entry from VM
            raInit = (RATYPE)-1;
            raEnd = 0;
            gsnCur = apropComdat->ac_gsn;
            while (vrComdat != VNIL && gsnCur == apropComdat->ac_gsn)
            {
                if(apropComdat->ac_ra < raInit && IsALLOCATED(apropComdat->ac_flags))
                    raInit = apropComdat->ac_ra;
                if(apropComdat->ac_ra + apropComdat->ac_size > raEnd)
                    raEnd = apropComdat->ac_ra + apropComdat->ac_size;

                vrComdat = apropComdat->ac_sameFile;
                if (vrComdat != VNIL)
                    apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
            }

            // Contribution to the new logical segment from this .OBJ file

            SaveCode(gsnCur, raEnd - raInit, raInit);
        }
    }
}

#endif

/*** ComDatRc2 - process COMDAT record in pass 2
*
* Purpose:
*   Process COMDAT record in pass 1.  Select appropriate copy of COMDAT.
*
* Input:
*   No explicit value is passed to this function. The OMF record is
*   read from input file bsInput - global variable.
*
* Output:
*   No explicit value is returned. Apropriate copy of COMDAT data block
*   is loaded into final memory image.
*
* Exceptions:
*   Unknown COMDAT name - phase error - display internal LINK error and quit
*   Unallocated COMDAT - phase error - display internal LINK error and quit
*
* Notes:
*   None.
*
*************************************************************************/

void NEAR               ComDatRc2(void)
{
    COMDATREC           omfRec;         // COMDAT OMF record
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    WORD                fRightCopy;     // TRUE if we have rigth instance of COMDAT
    RBTYPE              vrTmp;          // Temporary
    char                *sbName;        // COMDAT symbol
    AHTEPTR             ahte;           // Hash table entry

    ReadComDat(&omfRec);
    apropComdat = (APROPCOMDATPTR ) PropRhteLookup(omfRec.name, ATTRCOMDAT, FALSE);
                                        // Look for symbol among COMDATs
    ahte = (AHTEPTR) FetchSym(omfRec.name, FALSE);
    sbName = 1 + GetFarSb(ahte->cch);

    if (apropComdat == PROPNIL)
        Fatal(ER_undefcomdat, sbName);

    if (fPackFunctions && !IsREFERENCED(apropComdat->ac_flags))
    {
        SkipBytes((WORD) (cbRec - 1));  // Skip to checksum byte
        fSkipFixups = TRUE;             // Skip fixups if any
        return;
    }

    if (!IsCONCAT(omfRec.flags))
        fRightCopy = (WORD) (apropComdat->ac_obj == vrpropFile &&
                             apropComdat->ac_objLfa == lfaLast);
    else
    {
        // Search concatenation list

        vrTmp = apropComdat->ac_concat;
        fRightCopy = FALSE;
        while (vrTmp != VNIL && !fRightCopy)
        {
            apropComdat = (APROPCOMDATPTR ) FetchSym(vrTmp, TRUE);
            vrTmp = apropComdat->ac_concat;
            fRightCopy = (WORD) (apropComdat->ac_obj == vrpropFile &&
                                 apropComdat->ac_objLfa == lfaLast);
        }
    }

    if (fRightCopy)
    {
        // This is the right copy of COMDAT

        if (!apropComdat->ac_gsn)
            Fatal(ER_unalloc, sbName);

        apropComdat->ac_flags |= SELECTED_BIT;
        fSkipFixups = FALSE;            // Process fixups if any
        omfRec.gsn = apropComdat->ac_gsn;
        omfRec.ra = apropComdat->ac_ra; // Set relative address
        omfRec.flags = apropComdat->ac_flags;
        vcbData = (WORD) (cbRec - 1);   // set no. of data bytes in rec
        if (vcbData > DATAMAX)
            Fatal(ER_datarec);          // Check if record too large
#if NOT RGMI_IN_PLACE
        GetBytesNoLim(rgmi, vcbData);   // Fill the buffer
#endif
        vgsnCur = omfRec.gsn;           // Set global segment index

        fDebSeg = (FTYPE) ((fSymdeb) ? (((0x8000 & omfRec.gsn) != 0)) : FALSE);
                                        // If debug option on check for debug segs
        if (fDebSeg)
        {                               // If debug segment
            vraCur = omfRec.ra;         // Set current relative address
            vsegCur = vgsnCur = (SEGTYPE) (0x7fff & omfRec.gsn);
                                        // Set current segment
        }
        else
        {
            // If not a valid segment, don't process datarec
#if SYMDEB
            if (omfRec.gsn == 0xffff || !omfRec.gsn || mpgsnseg[omfRec.gsn] > segLast)
#else
            if (!omfRec.gsn || mpgsnseg[omfRec.gsn] > segLast)
#endif
            {
                vsegCur = SEGNIL;
                vrectData = RECTNIL;
#if RGMI_IN_PLACE
                SkipBytes(vcbData);     // must skip bytes for this record...
#endif
                return;                 // Good-bye!
            }
            vsegCur = mpgsnseg[omfRec.gsn];
                                        // Set current segment
            vraCur = mpsegraFirst[vsegCur] +  omfRec.ra;
                                        // Set current relative address
            if (IsVTABLE(apropComdat->ac_flags))
            {
                fFarCallTransSave = fFarCallTrans;
                fFarCallTrans = (FTYPE) FALSE;
            }
        }

        if (IsITERATED(omfRec.flags))
        {
#if RGMI_IN_PLACE
            rgmi = bufg;
            GetBytesNoLim(rgmi, vcbData);       // Fill the buffer
#endif

            vrectData = LIDATA;         // Simulate LIDATA
#if OSEGEXE
            if(fNewExe)
            {
                if (vcbData >= DATAMAX)
                    Fatal(ER_lidata);
                rlcLidata = (RLCPTR) &rgmi[(vcbData + 1) & ~1];
                                        // Set base of fixup array
                rlcCurLidata = rlcLidata;// Initialize pointer
                return;
            }
#endif
#if ODOS3EXE OR OIAPX286
            if(vcbData > (DATAMAX / 2))
            {
                OutError(ER_lidata);
                memset(&rgmi[vcbData],0,DATAMAX - vcbData);
            }
            else
                memset(&rgmi[vcbData],0,vcbData);
            ompimisegDstIdata = (char *) rgmi + vcbData;
#endif
        }
        else
        {
#if RGMI_IN_PLACE
            rgmi = PchSegAddress(vcbData, vsegCur, vraCur);
            GetBytesNoLim(rgmi, vcbData);       // Fill the buffer
#endif
            vrectData = LEDATA;         // Simulate LEDATA
        }
        if (rect & 1)
            vrectData++;                // Simulate 32-bit version
    }
    else
    {
        SkipBytes((WORD) (cbRec - 1));  // Skip to checksum byte
        fSkipFixups = TRUE;             // Skip fixups if any
    }
}

#if COMDATDEBUG
#include    <string.h>

/*** DisplayOne - display one COMDAT symbol table entry
*
* Purpose:
*   Debug aid. Display on standard output the contents of given
*   COMDAT symbol table entry.
*
* Input:
*   papropName - real pointer to symbol table entry
*   rhte       - hash vector entry
*   rprop      - pointer to property cell
*   fNewHte    - TRUE if new proprerty list (new entry in hash vector)
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   This function is in standard EnSyms format.
*
*************************************************************************/

LOCAL void              DisplayOne(APROPCOMDATPTR apropName, WORD fPhysical)
{
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    APROPCOMDAT         comdatDsc;      // COMDAT descriptor
    SEGTYPE             seg;


    FMEMCPY((char FAR *) &comdatDsc, apropName, sizeof(APROPCOMDAT));
    if (fPhysical)
        seg = mpgsnseg[comdatDsc.ac_gsn];
    fprintf(stdout, "%s:\r\n", 1 + GetPropName(apropName));
    fprintf(stdout, "ggr = %d; gsn = %d; ra = 0x%lx; size = %d\r\n",
                     comdatDsc.ac_ggr, comdatDsc.ac_gsn, comdatDsc.ac_ra, comdatDsc.ac_size);
    if (fPhysical)
    fprintf(stdout, "sa = 0x%x; ra = 0x%lx\r\n",
                     mpsegsa[seg], mpsegraFirst[seg] + comdatDsc.ac_ra);
    fprintf(stdout, "flags = 0x%x; selAlloc = 0x%x; align = 0x%x\r\n",
                     comdatDsc.ac_flags, comdatDsc.ac_selAlloc, comdatDsc.ac_align);
    fprintf(stdout, "data = 0x%lx; obj = 0x%lx; objLfa = 0x%lx\r\n",
                     comdatDsc.ac_data, comdatDsc.ac_obj, comdatDsc.ac_objLfa);
    fprintf(stdout, "concat = 0x%lx; sameSeg = 0x%lx pubSym = 0x%lx\r\n",
                     comdatDsc.ac_concat, comdatDsc.ac_sameSeg, comdatDsc.ac_pubSym);
    fprintf(stdout, "order = 0x%lx; iOvl = 0x%x\r\n",
                     comdatDsc.ac_order, comdatDsc.ac_iOvl);
    vrComdat = comdatDsc.ac_concat;
    while (vrComdat != VNIL)
    {
        apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
        FMEMCPY((char FAR *) &comdatDsc, apropComdat, sizeof(APROPCOMDAT));
        fprintf(stdout, "  +++ ggr = %d; gsn = %d; ra = 0x%lx; size = %d\r\n",
                         comdatDsc.ac_ggr, comdatDsc.ac_gsn, comdatDsc.ac_ra, comdatDsc.ac_size);
        if (fPhysical)
        fprintf(stdout, "      sa = 0x%x; ra = 0x%lx\r\n",
                         mpsegsa[seg], mpsegraFirst[seg] + comdatDsc.ac_ra);
        fprintf(stdout, "      flags = 0x%x; selAlloc = 0x%x; align = 0x%x\r\n",
                         comdatDsc.ac_flags, comdatDsc.ac_selAlloc, comdatDsc.ac_align);
        fprintf(stdout, "      data = 0x%lx; obj = 0x%lx; objLfa = 0x%lx\r\n",
                         comdatDsc.ac_data, comdatDsc.ac_obj, comdatDsc.ac_objLfa);
        fprintf(stdout, "      concat = 0x%lx; sameSeg = 0x%lx pubSym = 0x%lx\r\n",
                         comdatDsc.ac_concat, comdatDsc.ac_sameSeg, comdatDsc.ac_pubSym);
        fprintf(stdout, "      order = 0x%lx; iOvl = 0x%x\r\n",
                         comdatDsc.ac_order, comdatDsc.ac_iOvl);
        vrComdat = comdatDsc.ac_concat;
    }
    fprintf(stdout, "\r\n");
    fflush(stdout);
}


/*** DisplayComdats - self-expalnatory
*
* Purpose:
*   Debug aid. Enumerates all COMDAT records in the linker symbol table
*   displaying each entry.
*
* Input:
*   title - pointer to info string.
*   fPhysical - display physical addresses - allowed only if you call
*               this function after AssignAddresses.
*
* Output:
*   No explicit value is returned. COMDAT information is written to sdtout.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    DisplayComdats(char *title, WORD fPhysical)
{
    APROPFILEPTR        apropFile;      // Pointer to file entry
    RBTYPE              rbFileNext;     // Virtual pointer to prop list of next file
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor


    fprintf(stdout, "\r\nDisplayComdats: %s\r\n\r\n", title);
    rbFileNext = rprop1stFile;          // Next file to look at is first
    while (rbFileNext != VNIL)          // Loop to process objects
    {
        apropFile = (APROPFILEPTR ) FetchSym(rbFileNext, FALSE);
                                        // Fetch table entry from VM
        rbFileNext = apropFile->af_FNxt;// Get pointer to next file
        vrComdat = apropFile->af_ComDat;
        if (vrComdat != VNIL)
        {
            fprintf(stdout, "COMDATs from file: '%s'\r\n\r\n", 1+GetPropName(apropFile));
            while (vrComdat != VNIL)
            {
                apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                                        // Fetch table entry from VM
                vrComdat = apropComdat->ac_sameFile;
                DisplayOne(apropComdat, fPhysical);
            }
        }
    }
}

#endif
#if TCE
void            AddComdatUses(APROPCOMDAT *pAC, APROPCOMDAT *pUses)
{
        int i;
        SYMBOLUSELIST *pA;      // ac_uses of this comdat
        ASSERT(pAC);
        ASSERT(pUses);
        ASSERT(pAC->ac_uses.pEntries);
        ASSERT(pUses->ac_usedby.pEntries);

        // update the ac_uses list

        pA = &pAC->ac_uses;
        for(i=0; i<pA->cEntries; i++)  // eliminate duplicate entries
        {
                if((APROPCOMDAT*)pA->pEntries[i] == pUses)
                        return;
        }
        if(pA->cEntries >= pA->cMaxEntries-1)
        {
#if TCE_DEBUG
                fprintf(stdout,"\r\nReallocating ac_uses list of '%s'old size %d -> %d ",
                        1 + GetPropName(pAC), pA->cMaxEntries, pA->cMaxEntries <<1);
#endif
                pA->cMaxEntries <<= 1;
                if(!(pA->pEntries= REALLOC(pA->pEntries, pA->cMaxEntries*sizeof(RBTYPE*))))
                        Fatal(ER_memovf);
        }
        pA->pEntries[pA->cEntries++] = pUses;
#if TCE_DEBUG
        fprintf(stdout, "\r\nComdat '%s'uses '%s' ",
                1 + GetPropName(pAC), 1 + GetPropName(pUses));
#endif
}
void MarkAlive( APROPCOMDAT *pC )
{
        int i;
        SYMBOLUSELIST * pU;
        APROPCOMDAT   * pCtmp;
        RBTYPE rhte;

        pU = &pC->ac_uses;
#if TCE_DEBUG
        fprintf(stdout, "\r\nMarking alive '%s', attr %d ", 1+GetPropName(pC), pC->ac_attr);
        fprintf(stdout, "  uses %d symbols ", pU->cEntries);
        for(i=0; i<pU->cEntries; i++)
        fprintf(stdout, " '%s'",1+GetPropName(pU->pEntries[i]));
        fflush(stdout);
#endif

        pC->ac_fAlive = TRUE;
        for(i=0; i<pU->cEntries; i++)
        {
                pCtmp = (APROPCOMDATPTR)(pU->pEntries[i]);
                if(pCtmp->ac_attr != ATTRCOMDAT)
                {
                        // find the COMDAT descriptor, or abort
                        rhte = RhteFromProp((APROPPTR)pCtmp);
                        ASSERT(rhte);
                        pCtmp = PropRhteLookup(rhte, ATTRCOMDAT, FALSE);
                        if(!pCtmp)
                        {
#if TCE_DEBUG
                                fprintf(stdout, " comdat cell not found. ");
#endif
                                continue;
                        }
                        AddTceEntryPoint(pCtmp);
#if TCE_DEBUG
                        fprintf(stdout, "\r\nSwitching to COMDAT %s ", 1+GetPropName(pCtmp));
#endif
                }
                if(!pCtmp->ac_fAlive)
                {
#if TCE_DEBUG
                        fprintf(stdout, "\r\n   Recursing with '%s' ", 1+GetPropName(pCtmp));
#endif
                        MarkAlive(pCtmp);
                }
#if TCE_DEBUG
                else
                        fprintf(stdout,"\r\n       already alive: '%s' ",1+GetPropName(pCtmp));
#endif
        }
#if TCE_DEBUG
        fprintf(stdout, "\r\n Marking alive finished for '%s' ",1+GetPropName(pC));
#endif
}

void            PerformTce( void )
{
        int i;
        for(i=0; i<aEntryPoints.cEntries; i++)
                MarkAlive(aEntryPoints.pEntries[i]);
}

void            AddTceEntryPoint( APROPCOMDATPTR pC )
{
        int i;
        for(i=0; i<aEntryPoints.cEntries; i++)
        {
                if(aEntryPoints.pEntries[i] == pC)
                                return;
        }
        if(aEntryPoints.cEntries >= aEntryPoints.cMaxEntries -1)
        {
                aEntryPoints.cMaxEntries <<= 1;
                aEntryPoints.pEntries = REALLOC(aEntryPoints.pEntries, aEntryPoints.cMaxEntries * sizeof(RBTYPE*));
#if TCE_DEBUG
                fprintf(stdout,"\r\nREALLOCATING aEntryPoints List, new size is %d ", aEntryPoints.cMaxEntries);
#endif
        }
        aEntryPoints.pEntries[aEntryPoints.cEntries++] = pC;
#if TCE_DEBUG
        fprintf(stdout, "\r\nNew TCE Entry point %d : %s ",
                aEntryPoints.cEntries, 1+GetPropName(pC));
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\impexp.h ===
/*** impexp.h - Import/Export module - specification
*
*       Copyright <C> 1992, Microsoft Corporation
*
*       This module contains proprietary information of Microsoft
*       Corporation and should be treated as confidential.
*
* Purpose:
*   Build and write segmented-executable import/export tables
*
* Revision History:
*
*   29-May-1992    Wieslaw Kalkus       Created
*
*************************************************************************/

typedef struct _DYNBYTEARRAY
{
    WORD        byteMac;            // Number of bytes in the array
    WORD        byteMax;            // Allocated size
    BYTE FAR    *rgByte;            // Array of bytes
}
                DYNBYTEARRAY;

typedef struct _DYNWORDARRAY
{
    WORD        wordMac;            // Number of words in the array
    WORD        wordMax;            // Allocated size
    WORD FAR    *rgWord;            // Array of words
}
                DYNWORDARRAY;

#define DEF_BYTE_ARR_SIZE   1024
#define DEF_WORD_ARR_SIZE   512


extern DYNBYTEARRAY     ResidentName;
extern DYNBYTEARRAY     NonResidentName;
extern DYNBYTEARRAY     ImportedName;
extern DYNWORDARRAY     ModuleRefTable;
extern DYNBYTEARRAY     EntryTable;

void                    InitByteArray(DYNBYTEARRAY *pArray);
void                    FreeByteArray(DYNBYTEARRAY *pArray);
WORD                    ByteArrayPut(DYNBYTEARRAY *pArray, WORD size, BYTE *pBuf);
void                    WriteByteArray(DYNBYTEARRAY *pArray);

void                    InitWordArray(DYNWORDARRAY *pArray);
void                    FreeWordArray(DYNWORDARRAY *pArray);
WORD                    WordArrayPut(DYNWORDARRAY *pArray, WORD val);
void                    WriteWordArray(DYNWORDARRAY *pArray);

void                    AddName(DYNBYTEARRAY *pTable, BYTE *sbName, WORD ord);
WORD                    AddImportedName(BYTE *sbName);

WORD                    AddEntry(BYTE *entry, WORD size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\impliber.c ===
#include <stdio.h>

typedef struct _message {
	unsigned int	id;
	char *str;
} MESSAGE;

MESSAGE __MSGTAB[] = {
{2600, "\x45\x52\x5f\x4d\x69\x6e"}, // "ER_Min"
{2601, "\x25\x73\x20\x6d\x75\x6c\x74\x69\x70\x6c\x79\x20\x64\x65\x66\x69\x6e\x65\x64"}, // "%s multiply defined"
{2602, "\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x65\x6e\x64\x20\x6f\x66\x20\x6e\x61\x6d\x65\x20\x74\x61\x62\x6c\x65\x20\x69\x6e\x20\x44\x4c\x4c"}, // "unexpected end of name table in DLL"
{2603, "\x25\x73\x20\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x2e\x44\x4c\x4c\x20\x66\x69\x6c\x65"}, // "%s : invalid .DLL file"
{2699, "\x45\x52\x5f\x4d\x61\x78"}, // "ER_Max"
{1599, "\x45\x52\x5f\x4d\x69\x6e\x46\x61\x74\x61\x6c"}, // "ER_MinFatal"
{1600, "\x65\x72\x72\x6f\x72\x20\x77\x72\x69\x74\x69\x6e\x67\x20\x74\x6f\x20\x6f\x75\x74\x70\x75\x74\x20\x66\x69\x6c\x65\x20\x2d\x20\x25\x73"}, // "error writing to output file - %s"
{1601, "\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x2c\x20\x25\x73\x20\x68\x65\x61\x70\x20\x65\x78\x68\x61\x75\x73\x74\x65\x64"}, // "out of memory, %s heap exhausted"
{1602, "\x69\x6e\x20\x6d\x6f\x64\x75\x6c\x65\x2d\x64\x65\x66\x69\x6e\x69\x74\x69\x6f\x6e\x20\x66\x69\x6c\x65"}, // "in module-definition file"
{1603, "\x25\x73\x20\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x63\x72\x65\x61\x74\x65\x20\x66\x69\x6c\x65\x20\x2d\x20\x25\x73"}, // "%s : cannot create file - %s"
{1604, "\x25\x73\x20\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x6f\x70\x65\x6e\x20\x66\x69\x6c\x65\x20\x2d\x20\x25\x73"}, // "%s : cannot open file - %s"
{1605, "\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x6e\x65\x73\x74\x65\x64\x20\x69\x6e\x63\x6c\x75\x64\x65\x20\x66\x69\x6c\x65\x73\x20\x69\x6e\x20\x6d\x6f\x64\x75\x6c\x65\x2d\x64\x65\x66\x69\x6e\x69\x74\x69\x6f\x6e\x20\x66\x69\x6c\x65"}, // "too many nested include files in module-definition file"
{1606, "\x6d\x69\x73\x73\x69\x6e\x67\x20\x6f\x72\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x69\x6e\x63\x6c\x75\x64\x65\x20\x66\x69\x6c\x65\x20\x6e\x61\x6d\x65"}, // "missing or invalid include file name"
{1607, "\x25\x73\x20\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x65\x78\x74\x65\x6e\x73\x69\x6f\x6e\x20\x66\x6f\x72\x20\x74\x61\x72\x67\x65\x74\x20\x6c\x69\x62\x72\x61\x72\x79"}, // "%s : invalid extension for target library"
{1608, "\x6e\x6f\x20\x2e\x44\x4c\x4c\x20\x6f\x72\x20\x2e\x44\x45\x46\x20\x66\x69\x6c\x65\x20\x73\x70\x65\x63\x69\x66\x69\x65\x64"}, // "no .DLL or .DEF file specified"
{1699, "\x45\x52\x5f\x4d\x61\x78\x46\x61\x74\x61\x6c"}, // "ER_MaxFatal"
{4599, "\x45\x52\x5f\x57\x69\x6e\x57\x61\x72\x6e"}, // "ER_WinWarn"
{4600, "\x6c\x69\x6e\x65\x20\x25\x64\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x3b\x20\x74\x72\x75\x6e\x63\x61\x74\x65\x64\x20\x74\x6f\x20\x25\x64\x20\x63\x68\x61\x72\x61\x63\x74\x65\x72\x73"}, // "line %d too long; truncated to %d characters"
{4601, "\x75\x6e\x72\x65\x63\x6f\x67\x6e\x69\x7a\x65\x64\x20\x6f\x70\x74\x69\x6f\x6e\x20\x27\x25\x73\x27\x3b\x20\x6f\x70\x74\x69\x6f\x6e\x20\x69\x67\x6e\x6f\x72\x65\x64"}, // "unrecognized option '%s'; option ignored"
{4699, "\x45\x52\x5f\x4d\x61\x78\x57\x61\x72\x6e"}, // "ER_MaxWarn"
{999, "\x4d\x5f\x4d\x69\x6e\x55\x73\x61\x67\x65"}, // "M_MinUsage"
{1000, "\x55\x73\x61\x67\x65\x3a\x20\x49\x4d\x50\x4c\x49\x42\x20\x5b\x6f\x70\x74\x69\x6f\x6e\x73\x5d\x20\x3c\x6f\x75\x74\x70\x75\x74\x20\x6c\x69\x62\x72\x61\x72\x79\x3e\x20\x3c\x2e\x44\x45\x46\x2f\x2e\x44\x4c\x4c\x20\x66\x69\x6c\x65\x20\x6c\x69\x73\x74\x3e"}, // "Usage: IMPLIB [options] <output library> <.DEF/.DLL file list>"
{1001, "\x4f\x70\x74\x69\x6f\x6e\x73\x3a\x20\x2f\x3f"}, // "Options: /?"
{1002, "\x2f\x68\x65\x6c\x70"}, // "/help"
{1004, "\x2f\x6e\x6f\x69\x67\x6e\x6f\x72\x65\x63\x61\x73\x65"}, // "/noignorecase"
{1005, "\x2f\x6e\x6f\x6c\x6f\x67\x6f"}, // "/nologo"
{1006, "\x2f\x6e\x74\x64\x6c\x6c"}, // "/ntdll"
{1007, "\x65\x72\x72\x6f\x72"}, // "error"
{1008, "\x66\x61\x74\x61\x6c"}, // "fatal"
{1009, "\x52\x65\x61\x64\x69\x6e\x67\x20\x49\x6e\x70\x75\x74\x20\x46\x69\x6c\x65"}, // "Reading Input File"
{1010, "\x43\x72\x65\x61\x74\x69\x6e\x67\x20\x4f\x75\x74\x70\x75\x74\x20\x4c\x69\x62\x72\x61\x72\x79"}, // "Creating Output Library"
{1011, "\x2f\x6e\x6f\x77\x65\x70"}, // "/nowep"
{1099, "\x4d\x5f\x4d\x61\x78\x55\x73\x61\x67\x65"}, // "M_MaxUsage"
{0, NULL}
};

char * __NMSG_TEXT(
unsigned msgId
) {
        MESSAGE *pMsg = __MSGTAB;

        for (;pMsg->id; pMsg++) {
                if (pMsg->id == msgId)
                        break;
        }
        return pMsg->str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\isymfile.h ===
/*
  -- isymfile.h : from _isym.h : .sym file i/o
*/

typedef WORD    DPARA;          /* PARA relative to start of file */

/*      * STANDARD .SYM FORMAT */

/* For each symbol table (map): (MAPDEF) */
typedef struct _smm
        {
        DPARA   dparaSmmNext;   /* 16 bit ptr to next map (0 if end) */
        WORD    psLoad;         /* ignored */
        WORD    segEntry;       /* ignored */
        WORD    csyAbs;         /* count of absolute symbols */
        WORD    offRgpsmb;      /* offset to table of symbol pointers */
        WORD    cseg;           /* # of executable segments */
        DPARA   dparaSmsFirst;  /* segment symbol chain */
        BYTE    cchNameMax;     /* max symbol name */
        char    stName[1];      /* length prefixed name */
        } SMM;  /* SyMbol MAP */

#define cbSmmNoname (((SMM *)0)->stName)

/* For each segment/group within a symbol table: (SEGDEF) */
typedef struct _sms
        {
        DPARA   dparaSmsNext;   /* next segment (cyclic) */
        WORD    csy;            /* # of symbols */
        WORD    offRgpsmb;      /* offset to table of symbol pointers */
        WORD    psLoad;         /* ignored */
        WORD    psLoad0;        /* ignored */
        WORD    psLoad1;        /* ignored */
        WORD    psLoad2;        /* ignored */
        WORD    psLoad3;        /* ignored */
        DPARA   dparaLinFirst;  /* point to first line # */
        BYTE    fLoaded;        /* ignored */
        BYTE    instCur;        /* ignored */
        char    stName[1];      /* length prefixed name */
        } SMS;  /* SyMbol Segment */

#define cbSmsNoname (unsigned int) (((SMS *)0)->stName)

/*      * End of symbol table */
typedef struct _sme
        {
        DPARA   dparaEnd;       /* 0 */
        BYTE    rel, ver;       /* SYMBOL release, version */
        } SME;  /* SyMbol End */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\implib.c ===
/*
 * Created by CSD YACC (IBM PC) from "implib.y" */
# define T_FALIAS 257
# define T_KCLASS 258
# define T_KNAME 259
# define T_KLIBRARY 260
# define T_KBASE 261
# define T_KDEVICE 262
# define T_KPHYSICAL 263
# define T_KVIRTUAL 264
# define T_ID 265
# define T_NUMBER 266
# define T_KDESCRIPTION 267
# define T_KHEAPSIZE 268
# define T_KSTACKSIZE 269
# define T_KMAXVAL 270
# define T_KCODE 271
# define T_KCONSTANT 272
# define T_FDISCARDABLE 273
# define T_FNONDISCARDABLE 274
# define T_FEXEC 275
# define T_FFIXED 276
# define T_FMOVABLE 277
# define T_FSWAPPABLE 278
# define T_FSHARED 279
# define T_FMIXED 280
# define T_FNONSHARED 281
# define T_FPRELOAD 282
# define T_FINVALID 283
# define T_FLOADONCALL 284
# define T_FRESIDENT 285
# define T_FPERM 286
# define T_FCONTIG 287
# define T_FDYNAMIC 288
# define T_FNONPERM 289
# define T_KDATA 290
# define T_FNONE 291
# define T_FSINGLE 292
# define T_FMULTIPLE 293
# define T_KSEGMENTS 294
# define T_KOBJECTS 295
# define T_KSECTIONS 296
# define T_KSTUB 297
# define T_KEXPORTS 298
# define T_KEXETYPE 299
# define T_KSUBSYSTEM 300
# define T_FDOS 301
# define T_FOS2 302
# define T_FUNKNOWN 303
# define T_FWINDOWS 304
# define T_FDEV386 305
# define T_FMACINTOSH 306
# define T_FWINDOWSNT 307
# define T_FWINDOWSCHAR 308
# define T_FPOSIX 309
# define T_FNT 310
# define T_FUNIX 311
# define T_KIMPORTS 312
# define T_KNODATA 313
# define T_KOLD 314
# define T_KCONFORM 315
# define T_KNONCONFORM 316
# define T_KEXPANDDOWN 317
# define T_KNOEXPANDDOWN 318
# define T_EQ 319
# define T_AT 320
# define T_KRESIDENTNAME 321
# define T_KNONAME 322
# define T_STRING 323
# define T_DOT 324
# define T_COLON 325
# define T_COMA 326
# define T_ERROR 327
# define T_FHUGE 328
# define T_FIOPL 329
# define T_FNOIOPL 330
# define T_PROTMODE 331
# define T_FEXECREAD 332
# define T_FRDWR 333
# define T_FRDONLY 334
# define T_FINITGLOB 335
# define T_FINITINST 336
# define T_FTERMINST 337
# define T_FWINAPI 338
# define T_FWINCOMPAT 339
# define T_FNOTWINCOMPAT 340
# define T_FPRIVATE 341
# define T_FNEWFILES 342
# define T_REALMODE 343
# define T_FUNCTIONS 344
# define T_APPLOADER 345
# define T_OVL 346
# define T_KVERSION 347

# line 92
 /* SCCSID = %W% %E% */
#if _M_IX86 >= 300
#define M_I386          1
#define HOST32
#ifndef _WIN32
#define i386
#endif
#endif

#ifdef _WIN32
#ifndef HOST32
#define HOST32
#endif
#endif

#include		<basetsd.h>
#include                <stdio.h>
#include                <string.h>
#include                <malloc.h>
#include                <stdlib.h>
#include                <process.h>
#include                <stdarg.h>
#include                <io.h>
#include                "impliber.h"
#include                "verimp.h"      /* VERSION_STRING header */

#ifdef _MBCS
#define _CRTVAR1
#include <mbctype.h>
#include <mbstring.h>
#endif


#define EXE386 0
#define NOT    !
#define AND    &&
#define OR     ||
#define NEAR
#include                <newexe.h>

typedef unsigned char   BYTE;           /* Byte */
#ifdef HOST32
#define FAR
#define HUGE
#define NEAR
#define FSTRICMP    _stricmp
#define PASCAL
#else
#define FAR         far
#define HUGE        huge
#define FSTRICMP    _fstricmp
#define PASCAL      __pascal
#endif
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif
#define C8_IDE TRUE

#ifndef LOCAL
#ifndef _WIN32
#define LOCAL           static
#else
#define LOCAL
#endif
#endif
#define WRBIN           "wb"            /* Write only binary mode */
#define RDBIN           "rb"            /* Read only binary mode */
#define UPPER(c)        (((c)>='a' && (c)<='z')? (c) - 'a' + 'A': (c))
                                        /* Raise char to upper case */


#define YYS_WD(x)       (x)._wd         /* Access macro */
#define YYS_BP(x)       (x)._bp         /* Access macro */
#define SBMAX           255             /* Max. of length-prefixed string */
#define MAXDICLN        997             /* Max. no. of pages in dictionary */
#define PAGLEN          512             /* 512 bytes per page */
#define THEADR          0x80            /* THEADR record type */
#define COMENT          0x88            /* COMENT record type */
#define MODEND          0x8A            /* MODEND record type */
#define PUBDEF          0x90            /* PUBDEF record type */
#define LIBHDR          0xF0            /* Library header recod */
#define DICHDR          0xF1            /* Dictionary header record */
#define MSEXT           0xA0            /* OMF extension comment class */
#define IMPDEF          0x01            /* IMPort DEFinition record */
#define NBUCKETS        37              /* Thirty-seven buckets per page */
#define PAGEFULL        ((char)(0xFF))  /* Page full flag */
#define FREEWD          19              /* Word index of first free word */
#define WPP             (PAGLEN >> 1)   /* Number of words per page */
#define pagout(pb)      fwrite(pb,1,PAGLEN,fo)
                                        /* Write dictionary page to library */
#define INCLUDE_DIR     0xffff          /* Include directive for the lexer */
#define MAX_NEST        7
#define IO_BUF_SIZE     512

typedef struct import                   /* Import record */
{
        struct import   *i_next;        /* Link to next in list */
        char            *i_extnam;      /* Pointer to external name */
        char            *i_internal;    /* Pointer to internal name */
        unsigned short  i_ord;          /* Ordinal number */
        unsigned short  i_flags;        /* Extra flags */
}
                        IMPORT;         /* Import record */

#define I_NEXT(x)       (x).i_next
#define I_EXTNAM(x)     (x).i_extnam
#define I_INTNAM(x)     (x).i_internal
#define I_ORD(x)        (x).i_ord
#define I_FLAGS(x)      (x).i_flags


typedef unsigned char   byte;
typedef unsigned short  word;


#ifdef M68000
#define strrchr rindex
#endif

LOCAL int               fIgnorecase = 1;/* True if ignoring case - default */
LOCAL int               fBannerOnScreen;/* True if banner on screen */
LOCAL int               fFileNameExpected = 1;
LOCAL int               fNTdll;         /* If true add file name extension to module names */
LOCAL int               fIgnorewep = 0; /* True if ignoring multiple WEPs */
LOCAL FILE              *includeDisp[MAX_NEST];
                                        // Include file stack
LOCAL short             curLevel;       // Current include nesting level
                                        // Zero means main .DEF file
char                    prognam[] = "IMPLIB";
FILE                    *fi;            /* Input file */
FILE                    *fo;            /* Output file */
int                     yylineno = 1;   /* Line number */
char                    rgbid[SBMAX];   /* I.D. buffer */
char                    sbModule[SBMAX];/* Module name */
IMPORT                  *implist;       /* List of importable symbols */
IMPORT                  *lastimp;       /* Pointer to end of list */
IMPORT                  *newimps;       /* List of importable symbols */
word                    csyms;          /* Symbol count */
word                    csymsmod;       /* Per-module symbol count */
long                    cbsyms;         /* Symbol byte count */
word                    diclength;      /* Dictionary length in PAGEs */
char                    *mpdpnpag[MAXDICLN];
                                        /* Page buffer array */
char                    *defname;       /* Name of definitions file */

int                     exitCode;       /* code returned to OS */
#if C8_IDE
int                     fC8IDE = FALSE;
char                    msgBuf[_MAX_PATH];
#endif
LOCAL char              moduleEXE[] = ".exe";
LOCAL char              moduleDLL[] = ".dll";

word                    prime[] =       /* Array of primes */
{
                  2,   3,   5,   7,  11,  13,  17,  19,  23,  29,
                 31,  37,  41,  43,  47,  53,  59,  61,  67,  71,
                 73,  79,  83,  89,  97, 101, 103, 107, 109, 113,
                127, 131, 137, 139, 149, 151, 157, 163, 167, 173,
                179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
                233, 239, 241, 251, 257, 263, 269, 271, 277, 281,
                283, 293, 307, 311, 313, 317, 331, 337, 347, 349,
                353, 359, 367, 373, 379, 383, 389, 397, 401, 409,
                419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
                467, 479, 487, 491, 499, 503, 509, 521, 523, 541,
                547, 557, 563, 569, 571, 577, 587, 593, 599, 601,
                607, 613, 617, 619, 631, 641, 643, 647, 653, 659,
                661, 673, 677, 683, 691, 701, 709, 719, 727, 733,
                739, 743, 751, 757, 761, 769, 773, 787, 797, 809,
                811, 821, 823, 827, 829, 839, 853, 857, 859, 863,
                877, 881, 883, 887, 907, 911, 919, 929, 937, 941,
                947, 953, 961, 967, 971, 977, 983, 991, MAXDICLN,
                0
};

LOCAL void              MOVE(int cb, char *src, char *dst);
LOCAL void              DefaultModule(char *defaultExt);
LOCAL void              NewModule(char *sbNew, char *defaultExt);
LOCAL char              *alloc(word cb);
LOCAL void              export(char *sbEntry, char *sbInternal, word ordno, word flags);
LOCAL word              theadr(char *sbName);
LOCAL void              outimpdefs(void);
LOCAL short             symeq(char *ps1,char *ps2);
LOCAL void              initsl(void);
LOCAL word              rol(word x, word n);
LOCAL word              ror(word x, word n);
LOCAL void              hashsym(char *pf, word *pdpi, word *pdpid,word *pdpo, word *pdpod);
LOCAL void              nullfill(char *pbyte, word length);
LOCAL int               pagesearch(char *psym, char *dicpage, word *pdpo, word dpod);
LOCAL word              instsym(IMPORT *psym);
LOCAL void              nulpagout(void);
LOCAL void              writedic(void);
LOCAL int               IsPrefix(char *prefix, char *s);
LOCAL void              DisplayBanner(void);
int NEAR                yyparse(void);
LOCAL void              yyerror(char *);


char                    *keywds[] =     /* Keyword array */
{
                            "ALIAS",            (char *) T_FALIAS,
                            "APPLOADER",        (char *) T_APPLOADER,
                            "BASE",             (char *) T_KBASE,
                            "CLASS",            (char *) T_KCLASS,
                            "CODE",             (char *) T_KCODE,
                            "CONFORMING",       (char *) T_KCONFORM,
                            "CONSTANT",         (char *) T_KCONSTANT,
                            "CONTIGUOUS",       (char *) T_FCONTIG,
                            "DATA",             (char *) T_KDATA,
                            "DESCRIPTION",      (char *) T_KDESCRIPTION,
                            "DEV386",           (char *) T_FDEV386,
                            "DEVICE",           (char *) T_KDEVICE,
                            "DISCARDABLE",      (char *) T_FDISCARDABLE,
                            "DOS",              (char *) T_FDOS,
                            "DYNAMIC",          (char *) T_FDYNAMIC,
                            "EXECUTE-ONLY",     (char *) T_FEXEC,
                            "EXECUTEONLY",      (char *) T_FEXEC,
                            "EXECUTEREAD",      (char *) T_FEXECREAD,
                            "EXETYPE",          (char *) T_KEXETYPE,
                            "EXPANDDOWN",       (char *) T_KEXPANDDOWN,
                            "EXPORTS",          (char *) T_KEXPORTS,
                            "FIXED",            (char *) T_FFIXED,
                            "FUNCTIONS",        (char *) T_FUNCTIONS,
                            "HEAPSIZE",         (char *) T_KHEAPSIZE,
                            "HUGE",             (char *) T_FHUGE,
                            "IMPORTS",          (char *) T_KIMPORTS,
                            "IMPURE",           (char *) T_FNONSHARED,
                            "INCLUDE",          (char *) INCLUDE_DIR,
                            "INITGLOBAL",       (char *) T_FINITGLOB,
                            "INITINSTANCE",     (char *) T_FINITINST,
                            "INVALID",          (char *) T_FINVALID,
                            "IOPL",             (char *) T_FIOPL,
                            "LIBRARY",          (char *) T_KLIBRARY,
                            "LOADONCALL",       (char *) T_FLOADONCALL,
                            "LONGNAMES",        (char *) T_FNEWFILES,
                            "MACINTOSH",        (char *) T_FMACINTOSH,
                            "MAXVAL",           (char *) T_KMAXVAL,
                            "MIXED1632",        (char *) T_FMIXED,
                            "MOVABLE",          (char *) T_FMOVABLE,
                            "MOVEABLE",         (char *) T_FMOVABLE,
                            "MULTIPLE",         (char *) T_FMULTIPLE,
                            "NAME",             (char *) T_KNAME,
                            "NEWFILES",         (char *) T_FNEWFILES,
                            "NODATA",           (char *) T_KNODATA,
                            "NOEXPANDDOWN",     (char *) T_KNOEXPANDDOWN,
                            "NOIOPL",           (char *) T_FNOIOPL,
                            "NONAME",           (char *) T_KNONAME,
                            "NONCONFORMING",    (char *) T_KNONCONFORM,
                            "NONDISCARDABLE",   (char *) T_FNONDISCARDABLE,
                            "NONE",             (char *) T_FNONE,
                            "NONPERMANENT",     (char *) T_FNONPERM,
                            "NONSHARED",        (char *) T_FNONSHARED,
                            "NOTWINDOWCOMPAT",  (char *) T_FNOTWINCOMPAT,
                            "NT",               (char *) T_FNT,
                            "OBJECTS",          (char *) T_KOBJECTS,
                            "OLD",              (char *) T_KOLD,
                            "OS2",              (char *) T_FOS2,
                            "OVERLAY",          (char *) T_OVL,
                            "OVL",              (char *) T_OVL,
                            "PERMANENT",        (char *) T_FPERM,
                            "PHYSICAL",         (char *) T_KPHYSICAL,
                            "POSIX",            (char *) T_FPOSIX,
                            "PRELOAD",          (char *) T_FPRELOAD,
                            "PRIVATE",          (char *) T_FPRIVATE,
                            "PRIVATELIB",       (char *) T_FPRIVATE,
                            "PROTMODE",         (char *) T_PROTMODE,
                            "PURE",             (char *) T_FSHARED,
                            "READONLY",         (char *) T_FRDONLY,
                            "READWRITE",        (char *) T_FRDWR,
                            "REALMODE",         (char *) T_REALMODE,
                            "RESIDENT",         (char *) T_FRESIDENT,
                            "RESIDENTNAME",     (char *) T_KRESIDENTNAME,
                            "SECTIONS",         (char *) T_KSECTIONS,
                            "SEGMENTS",         (char *) T_KSEGMENTS,
                            "SHARED",           (char *) T_FSHARED,
                            "SINGLE",           (char *) T_FSINGLE,
                            "STACKSIZE",        (char *) T_KSTACKSIZE,
                            "STUB",             (char *) T_KSTUB,
                            "SUBSYSTEM",        (char *) T_KSUBSYSTEM,
                            "SWAPPABLE",        (char *) T_FSWAPPABLE,
                            "TERMINSTANCE",     (char *) T_FTERMINST,
                            "UNIX",             (char *) T_FUNIX,
                            "UNKNOWN",          (char *) T_FUNKNOWN,
                            "VERSION",          (char *) T_KVERSION,
                            "VIRTUAL",          (char *) T_KVIRTUAL,
                            "WINDOWAPI",        (char *) T_FWINAPI,
                            "WINDOWCOMPAT",     (char *) T_FWINCOMPAT,
                            "WINDOWS",          (char *) T_FWINDOWS,
                            "WINDOWSCHAR",      (char *) T_FWINDOWSCHAR,
                            "WINDOWSNT",        (char *) T_FWINDOWSNT,
                            NULL
};

# line 389

#define UNION 1
typedef union 
{
        word            _wd;
        char            *_bp;
} YYSTYPE;
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256

#line 798


#ifndef M_I386
extern char     * PASCAL        __FMSG_TEXT ( unsigned );
#else
#ifdef _WIN32
extern char     * PASCAL        __FMSG_TEXT ( unsigned );
#endif
#endif

/*** Error - display error message
*
* Purpose:
*   Display error message.
*
* Input:
*   errNo   - error number
*
* Output:
*   No explicit value is returned. Error message written out to stderr.
*
* Exceptions:
*   None.
*
* Notes:
*   This function takes variable number of parameters. MUST be in
*   C calling convention.
*
*************************************************************************/


LOCAL  void cdecl          Error(unsigned errNo,...)
{
    va_list         pArgList;


    if (!fBannerOnScreen)
        DisplayBanner();

    va_start(pArgList, errNo);              /* Get start of argument list */

    /* Write out standard error prefix */

        fprintf(stderr, "%s : %s IM%d: ", prognam, GET_MSG(M_error), errNo);

    /* Write out error message */

        vfprintf(stderr, GET_MSG(errNo), pArgList);
    fprintf(stderr, "\n");

    if (!exitCode)
        exitCode =     (errNo >= ER_Min      && errNo <= ER_Max)
                    || (errNo >= ER_MinFatal && errNo <= ER_MaxFatal);
}


/*** Fatal - display error message
*
* Purpose:
*   Display error message and exit to operating system.
*
* Input:
*   errNo   - error number
*
* Output:
*   No explicit value is returned. Error message written out to stderr.
*
* Exceptions:
*   None.
*
* Notes:
*   This function takes variable number of parameters. MUST be in
*   C calling convention.
*
*************************************************************************/


LOCAL  void cdecl          Fatal(unsigned errNo,...)
{
    va_list         pArgList;


    if (!fBannerOnScreen)
        DisplayBanner();

    va_start(pArgList, errNo);              /* Get start of argument list */

    /* Write out standard error prefix */

        fprintf(stderr, "%s : %s %s IM%d: ", prognam, GET_MSG(M_fatal), GET_MSG(M_error),errNo);

    /* Write out fatal error message */

        vfprintf(stderr, GET_MSG(errNo), pArgList);
    fprintf(stderr, "\n");
    exit(1);
}


/*
 *  Check if error in output file, abort if there is.
 */

void                    chkerror ()
{
    if(ferror(fo))
    {
        Fatal(ER_outfull, strerror(errno));
    }
}

LOCAL void               MOVE(int cb, char *src, char *dst)
{
    while(cb--) *dst++ = *src++;
}

LOCAL  char             *alloc(word cb)
{
    char                *cp;            /* Pointer */


    if((cp = malloc(cb)) != NULL) return(cp);
                                    /* Call malloc() to get the space */
    Fatal(ER_nomem, "far");
    return 0;
}

LOCAL  int              lookup()        /* Keyword lookup */
{
    char                **pcp;          /* Pointer to character pointer */
    int                 i;              /* Comparison value */

    for(pcp = keywds; *pcp != NULL; pcp += 2)
    {                                   /* Look through keyword table */
        if(!(i = FSTRICMP(&rgbid[1],*pcp)))
            return((int)(INT_PTR) pcp[1]);       /* If found, return token type */
        if(i < 0) break;                /* Break if we've gone too far */
    }
    return(T_ID);                       /* Just your basic identifier */
}

LOCAL int               GetChar(void)
{
    int                 c;              /* A character */

    c = getc(fi);
    if (c == EOF && curLevel > 0)
    {
        fclose(fi);
        fi = includeDisp[curLevel];
        curLevel--;
        c = GetChar();
    }
    return(c);
}



LOCAL  int             yylex()         /* Lexical analyzer */
{
    int                 c = 0;          /* A character */
    word                x;              /* Numeric token value */
    int                 state;          /* State variable */
    char                *cp;            /* Character pointer */
    char                *sz;            /* Zero-terminated string */
    static int          lastc;          /* Previous character */
    int                 fFileNameSave;

    state = 0;                          /* Assume we're not in a comment */
    for(;;)                             /* Loop to skip white space */
    {
        lastc = c;
        if((c = GetChar()) == EOF || c == '\032' || c == '\377') return(EOF);
                                        /* Get a character */
        if(c == ';') state = 1;         /* If comment, set flag */
        else if(c == '\n')              /* If end of line */
        {
                state = 0;              /* End of comment */
                if(!curLevel)
                    ++yylineno;         /* Increment line number count */
        }
        else if(state == 0 && c != ' ' && c != '\t' && c != '\r') break;
                                        /* Break on non-white space */
    }
    switch(c)                           /* Handle one-character tokens */
    {
        case '.':                       /* Name separator */
            if (fFileNameExpected)
                break;
            return(T_DOT);

        case '@':                       /* Ordinal specifier */
        /*
         * Require that whitespace precede '@' if introducing an
         * ordinal, to allow '@' in identifiers.
         */
            if(lastc == ' ' || lastc == '\t' || lastc == '\r')
                return(T_AT);
            break;

        case '=':                       /* Name assignment */
            return(T_EQ);

        case ':':
          return(T_COLON);

        case ',':
          return(T_COMA);
    }

    if(c >= '0' && c <= '9' && !fFileNameExpected)
    {                                   /* If token is a number */
        x = c - '0';                    /* Get first digit */
        c = GetChar();          /* Get next character */
        if(x == 0)                      /* If octal or hex */
        {
            if(c == 'x' || c == 'X')/* If it is an 'x' */
            {
                state = 16;             /* Base is hexadecimal */
                c = GetChar();  /* Get next character */
            }
            else state = 8;             /* Else octal */
        }
        else state = 10;                /* Else decimal */
        for(;;)
        {
            if(c >= '0' && c <= '9') c -= '0';
            else if(c >= 'A' && c <= 'F') c -= 'A' - 10;
            else if(c >= 'a' && c <= 'f') c -= 'a' - 10;
            else break;
            if(c >= state) break;
            x = x*state + c;
            c = GetChar();
        }
        ungetc(c,fi);
        YYS_WD(yylval) = x;
        return(T_NUMBER);
    }
    if(c == '\'' || c == '"')           /* If token is a string */
    {
        sz = &rgbid[1];                 /* Initialize */
        for(state = 0; state != 2;)     /* State machine loop */
        {
            if((c = GetChar()) == EOF) return(EOF);
                                        /* Check for EOF */
            if (sz >= &rgbid[sizeof(rgbid)])
            {
                Error(ER_linemax, yylineno, sizeof(rgbid)-1);
                state = 2;
            }
            switch(state)               /* Transitions */
            {
                case 0:                 /* Inside quote */
                    if(c == '\'' || c == '"') state = 1;
                                        /* Change state if quote found */
                    else *sz++ = (char) c;/* Else save character */
                    break;

                case 1:                 /* Inside quote with quote */
                    if(c == '\'' || c == '"')/* If consecutive quotes */
                    {
                        *sz++ = (char) c;/* Quote inside string */
                        state = 0;      /* Back to state 0 */
                    }
                    else state = 2;     /* Else end of string */
                    break;
            }
        }
        ungetc(c,fi);                   /* Put back last character */
        *sz = '\0';                     /* Null-terminate the string */
        rgbid[0] = (char)(sz - &rgbid[1]);
                                        /* Set length of string */
        YYS_BP(yylval) = rgbid;         /* Save ptr. to identifier */
        return(T_STRING);               /* String found */
    }
    sz = &rgbid[1];                     /* Initialize */
    for(;;)                             /* Loop to get i.d.'s */
    {
        if (fFileNameExpected)
            cp = " \t\r\n\f";
        else
            cp = " \t\r\n.=';\032";
        while(*cp && *cp != (char) c)
            ++cp;
                                        /* Check for end of identifier */
        if(*cp) break;                  /* Break if end of identifier found */
        if (sz >= &rgbid[sizeof(rgbid)])
            Fatal(ER_linemax, yylineno, sizeof(rgbid)-1);
        *sz++ = (byte) c;               /* Save the character */
        if((c = GetChar()) == EOF) break;
                                        /* Get next character */
    }
    ungetc(c,fi);                       /* Put character back */
    *sz = '\0';                         /* Null-terminate the string */
    rgbid[0] = (char)(sz - &rgbid[1]);  /* Set length of string */
    YYS_BP(yylval) = rgbid;             /* Save ptr. to identifier */

    state = lookup();                   /* Look up the identifier */
    if (state == INCLUDE_DIR)
    {
        // Process include directive

        fFileNameSave = fFileNameExpected;
        fFileNameExpected = 1;
        state = yylex();
        fFileNameExpected = fFileNameSave;
        if (state == T_ID || state == T_STRING)
        {
            if (curLevel < MAX_NEST - 1)
            {
                curLevel++;
                includeDisp[curLevel] = fi;
                fi = fopen(&rgbid[1], RDBIN);
                if (fi == NULL)
                    Fatal(ER_badopen, &rgbid[1], strerror(errno));
                return(yylex());
            }
            else
                Fatal(ER_toomanyincl);
        }
        else
            Fatal(ER_badinclname);
	
	return (0);
    }
    else
        return(state);
}

LOCAL void              yyerror(s)      /* Error routine */
char                    *s;             /* Error message */
{

    fprintf(stderr, "%s(%d) : %s %s IM%d: %s %s\n",
                         defname, yylineno, GET_MSG(M_fatal), GET_MSG(M_error),
                         ER_syntax, s, GET_MSG(ER_syntax));
    exit(1);
}


/*
 * Use the basename of the current .DEF file name as the module name.
 */

LOCAL void              DefaultModule(char *defaultExt)
{
    char                drive[_MAX_DRIVE];
    char                dir[_MAX_DIR];
    char                fname[_MAX_FNAME];
    char                ext[_MAX_EXT];


    _splitpath(defname, drive, dir, fname, ext);
    if (fNTdll)
    {
        if (ext[0] == '\0')
            _makepath(&sbModule[1], NULL, NULL, fname, defaultExt);
        else if (ext[0] == '.' && ext[1] == '\0')
            strcpy(&sbModule[1], fname);
        else
            _makepath(&sbModule[1], NULL, NULL, fname, ext);
    }
    else
        _makepath(&sbModule[1], NULL, NULL, fname, NULL);
    sbModule[0] = (unsigned char) strlen(&sbModule[1]);
}

LOCAL void              NewModule(char *sbNew, char *defaultExt)
{
    char                drive[_MAX_DRIVE];
    char                dir[_MAX_DIR];
    char                fname[_MAX_FNAME];
    char                ext[_MAX_EXT];


    sbNew[sbNew[0]+1] = '\0';
    _splitpath(&sbNew[1], drive, dir, fname, ext);
    if (fNTdll)
    {
        if (ext[0] == '\0')
            _makepath(&sbModule[1], NULL, NULL, fname, defaultExt);
        else if (ext[0] == '.' && ext[1] == '\0')
            strcpy(&sbModule[1], fname);
        else
            _makepath(&sbModule[1], NULL, NULL, fname, ext);
    }
    else
        strcpy(&sbModule[1], fname);
    sbModule[0] = (unsigned char) strlen(&sbModule[1]);
}


LOCAL void              export(char *sbEntry, char *sbInternal, word ordno, word flags)
{
    IMPORT              *imp;           /* Import definition */

    if(fIgnorewep && strcmp(sbEntry+1, "WEP") == 0)
         return;


    imp = (IMPORT *) alloc(sizeof(IMPORT));
                                        /* Allocate a cell */
    if (newimps == NULL)                /* If list empty */
        newimps = imp;                  /* Define start of list */
    else
        I_NEXT(*lastimp) = imp;         /* Append it to list */
    I_NEXT(*imp) = NULL;
    I_EXTNAM(*imp) = sbEntry;           /* Save the external name */
    I_INTNAM(*imp) = sbInternal;        /* Save the internal name */
    I_ORD(*imp) = ordno;                /* Save the ordinal number */
    I_FLAGS(*imp) = flags;              /* Save extra flags */
    lastimp = imp;                      /* Save pointer to end of list */
}

/* Output a THEADR record */

LOCAL word              theadr(char *sbName)
{
    fputc(THEADR,fo);
    fputc(sbName[0] + 2,fo);
    fputc(0,fo);
    fwrite(sbName,sizeof(char),sbName[0] + 1,fo);
    fputc(0,fo);
    chkerror();
    return(sbName[0] + 5);
}

word          modend()        /* Output a MODEND record */
{
    fwrite("\212\002\0\0\0",sizeof(char),5,fo);
                                        /* Write a MODEND record */
    chkerror();
    return(5);                          /* It is 5 bytes long */
}

LOCAL void              outimpdefs(void)/* Output import definitions */
{
    IMPORT              *imp;           /* Pointer to import record */
    word                reclen;         /* Record length */
    word                ord;            /* Ordinal number */
    long                lfa;            /* File address */
    word                tlen;           /* Length of THEADR */
    byte                impFlags;


    for (imp = newimps; imp != NULL; imp = I_NEXT(*imp))
    {                                   /* Traverse the list */
        lfa = ftell(fo);                /* Find out where we are */
        tlen = theadr(I_EXTNAM(*imp));
                                        /* Output a THEADR record */

        //    1    1   1    1     n + 1        n + 1        n + 1 or 2      1
        //  +---+----+---+-----+-----------+-----------+------------------+---+
        //  | 0 | A0 | 1 | Flg | Ext. Name | Mod. Name | Int. Name or Ord | 0 |
        //  +---+----+---+-----+-----------+-----------+------------------+---+

        reclen = 4 + sbModule[0] + 1 + I_EXTNAM(*imp)[0] + 1 + 1;
                                        /* Initialize */
        ord = I_ORD(*imp);
        if (ord != 0)
            reclen +=2;                 /* Two bytes for ordinal number */
        else if (I_INTNAM(*imp))
            reclen += I_INTNAM(*imp)[0] + 1;
                                        /* Length of internal name */
        else
            reclen++;

        I_ORD(*imp) = (word)(lfa >> 4);
                                        /* Save page number */
        ++csymsmod;                     /* Increment symbol count */
        cbsyms += (long) I_EXTNAM(*imp)[0] + 4;
                                        /* Increment symbol space count */
        fputc(COMENT,fo);               /* Comment record */
        fputc(reclen & 0xFF,fo);        /* Lo-byte of record length */
        fputc(reclen >> 8,fo);          /* Hi-byte of length */
        fputc(0,fo);                    /* Purgable, listable */
        fputc(MSEXT,fo);                /* Microsoft OMF extension class */
        fputc(IMPDEF,fo);               /* IMPort DEFinition record */
        impFlags = 0;
        if (ord != 0)
            impFlags |= 0x1;
        if (I_FLAGS(*imp) & 0x1)
            impFlags |= 0x2;
        fputc(impFlags, fo);            /* Import type (name or ordinal or constant) */
        fwrite(I_EXTNAM(*imp),sizeof(char),I_EXTNAM(*imp)[0] + 1,fo);
                                        /* Write the external name */
        fwrite(sbModule,sizeof(char),sbModule[0] + 1,fo);
                                        /* Write the module name */
        if (ord != 0)                   /* If import by ordinal */
        {
            fputc(ord & 0xFF,fo);       /* Lo-byte of ordinal */
            fputc(ord >> 8,fo);         /* Hi-byte of ordinal */
        }
        else if (I_INTNAM(*imp))
            fwrite(I_INTNAM(*imp), sizeof(char), I_INTNAM(*imp)[0] + 1, fo);
                                        /* Write internal name */
        else
            fputc(0, fo);               /* No internal name */
        fputc(0,fo);                    /* Checksum byte */
        reclen += tlen + modend() + 3;  /* Output a MODEND record */
        if(reclen &= 0xF)               /* If padding needed */
        {
            reclen = 0x10 - reclen;     /* Calculate needed padding */
            while(reclen--) fputc(0,fo);/* Pad to page boundary */
        }
        chkerror();
    }
}

/* Compare two symbols */

LOCAL  short            symeq(char *ps1,char *ps2)
{
    int                 length;         /* No. of char.s to compare */

    length = *ps1 + 1;                  /* Take length of first symbol */
    if (length != *ps2 + 1)
        return(0);                      /* Length must match */
    while(length--)                     /* While not at end of symbol */
        if (fIgnorecase)
        {
            if (UPPER(*ps1) != UPPER(*ps2))
                return(0);              /* If not equal, return zero */
            ++ps1;
            ++ps2;
        }
        else if (*ps1++ != *ps2++)
            return(0);                  /* If not equal, return zero */
    return(1);                          /* Symbols match */
}

LOCAL  word             calclen()       /* Calculate dictionary length */
{
    word                avglen;         /* Average entry length */
    word                avgentries;     /* Average no. of entries per page */
    word                minpages;       /* Min. no. of pages in dictionary */
    register word       i;              /* Index variable */

    if(!csyms) return(1);               /* One page for an empty dictionary */
    avglen = (word)(cbsyms/csyms) + 1;
                                        /* Average entry length */
    avgentries = (PAGLEN - NBUCKETS - 1)/avglen;
                                        /* Average no. of entries per page */
    minpages = (word) csyms/avgentries + 1;
                                        /* Minimum no. of pages in dict. */
    if(minpages < (i = (word) csyms/NBUCKETS + 1))
    {
        minpages = i;
    }
    else
    {
        /* Add some extra pages if there is a lot long symbol names */
        #define MAXOVERHEAD 10
        i = (word)(((avglen+5L) * minpages *4)/(3*PAGLEN)); // The more symbols the larger increase...
        if(i>MAXOVERHEAD)
            i = MAXOVERHEAD;  /* Do not add more than MAXOVERHEAD pages */
        minpages += i;
    }

                                        /* Insure enough buckets allotted */
    i = 0;                              /* Initialize index */
    do                                  /* Look through prime array */
    {
        if(minpages <= prime[i]) return(prime[i]);
                                        /* Return smallest prime >= minpages */
    }
    while(prime[i++]);                  /* Until end of table found */
    return(0);                          /* Too many symbols */
}

/* Initialize Symbol Lookup */

LOCAL void                  initsl(void)
{
    register word           i;          /* Index variable */

    diclength = calclen();              /* Calculate dictionaly length */
    for(i = 0; i < diclength; ++i) mpdpnpag[i] = NULL;
                                        /* Initialize page table */
}

LOCAL  word             ror(word x, word n)     /* Rotate right */
{
#if ODDWORDLN
    return(((x << (16 - n)) | ((x >> n) & ~(~0 << (16 - n))))
      & ~(~0 << 16));
#else
    return((x << (16 - n)) | ((x >> n) & ~(~0 << (16 - n))));
#endif
}

LOCAL  word             rol(word x, word n)     /* Rotate left */
{
#if ODDWORDLN
    return(((x << n) | ((x >> (16 - n)) & ~(~0 << n))) & ~(~0 << 16));
#else
    return((x << n) | ((x >> (16 - n)) & ~(~0 << n)));
#endif
}

LOCAL void               hashsym(char *pf, word *pdpi, word *pdpid,word *pdpo, word *pdpod)
{
    char                *pb;            /* Pointer to back of symbol */
    register word       len;            /* Length of symbol */
    register word       ch;             /* Character */

    len = *pf;                          /* Get length */
    pb = &pf[len];                      /* Get pointer to back */
    *pdpi = 0;                          /* Initialize */
    *pdpid = 0;                         /* Initialize */
    *pdpo = 0;                          /* Initialize */
    *pdpod = 0;                         /* Initialize */
    while(len--)                        /* Loop */
    {
        ch = *pf++ | 32;                /* Force char to lower case */
        *pdpi = rol(*pdpi,2) ^ ch;      /* Hash */
        *pdpod = ror(*pdpod,2) ^ ch;    /* Hash */
        ch = *pb-- | 32;                /* Force char to lower case */
        *pdpo = ror(*pdpo,2) ^ ch;      /* Hash */
        *pdpid = rol(*pdpid,2) ^ ch;    /* Hash */
    }
    *pdpi %= diclength;                 /* Calculate page index */
    if(!(*pdpid %= diclength)) *pdpid = 1;
                                        /* Calculate page index delta */
    *pdpo %= NBUCKETS;                  /* Calculate page bucket no. */
    if(!(*pdpod %= NBUCKETS)) *pdpod = 1;
                                        /* Calculate page bucket delta */
}

LOCAL void              nullfill(char *pbyte, word length)
{
    while(length--) *pbyte++ = '\0';    /* Load with nulls */
}

/*
*  Returns:
*       -1      Symbol not in dictionary
*       0               Search inconclusive
*       1               Symbol on this page
*/
LOCAL  int              pagesearch(char *psym, char *dicpage, word *pdpo, word dpod)
{
    register word       i;              /* Index variable */
    word                dpo;            /* Initial bucket number */

    dpo = *pdpo;                        /* Remember starting position */
    for(;;)                             /* Forever */
    {
        if(i = ((word) dicpage[*pdpo] & 0xFF) << 1)
        {                                               /* If bucket is not empty */
            if(symeq(psym,&dicpage[i])) /* If we've found a match */
                return(1);              /* Found */
            else                        /* Otherwise */
            {
                if((*pdpo += dpod) >= NBUCKETS) *pdpo -= NBUCKETS;
                                        /* Try next bucket */
                if(*pdpo == dpo) return(0);
                                        /* Symbol not on this page */
            }
        }
        else if(dicpage[NBUCKETS] == PAGEFULL) return(0);
                                        /* Search inconclusive */
        else return(-1);                /* Symbol not in dictionary */
    }
}

/* Install symbol in dictionary */

LOCAL word              instsym(IMPORT *psym)
{
    word                dpi;            /* Dictionary page index */
    word                dpid;           /* Dictionary page index delta */
    word                dpo;            /* Dictionary page offset */
    word                dpod;           /* Dict. page offset delta */
    word                dpii;           /* Initial dict. page index */
    register int        erc;            /* Error code */
    char                *dicpage;       /* Pointer to dictionary page */


    hashsym(I_EXTNAM(*psym),&dpi,&dpid,&dpo,&dpod);
                                        /* Hash the symbol */
    dpii = dpi;                         /* Save initial page index */
    for(;;)                             /* Forever */
    {
        if(mpdpnpag[dpi] == NULL)       /* If page unallocated */
        {
            mpdpnpag[dpi] = alloc(PAGLEN);
                                        /* Allocate a page */
            nullfill(mpdpnpag[dpi],PAGLEN);
                                        /* Fill it with nulls */
            mpdpnpag[dpi][NBUCKETS] = FREEWD;
                                        /* Initialize pointer to free space */
        }
        dicpage = mpdpnpag[dpi];        /* Set pointer to page */
        if((erc = pagesearch(I_EXTNAM(*psym),dicpage,&dpo,dpod)) > 0)
          return(1);                    /* Return 1 if symbol in table */
        if(erc == -1)                   /* If empty bucket found */
        {
            if(((I_EXTNAM(*psym)[0] + 4) >> 1) <
              WPP - ((int) dicpage[NBUCKETS] & 0xFF))
            {                           /* If enough free space on page */
                dicpage[dpo] = dicpage[NBUCKETS];
                                        /* Load bucket with pointer */
                erc = ((int) dicpage[NBUCKETS] & 0xFF) << 1;
                                        /* Get byte index to free space */
                dpi = I_EXTNAM(*psym)[0];
                                        /* Get symbol length */
                for(dpo = 0; dpo <= dpi;)
                        dicpage[erc++] = I_EXTNAM(*psym)[dpo++];
                                        /* Install the symbol text */
                dicpage[erc++] = (char)(I_ORD(*psym) & 0xFF);
                                        /* Load low-order byte */
                dicpage[erc++] = (char)(I_ORD(*psym) >> 8);
                                        /* Load high-order byte */
                if(++erc >= PAGLEN) dicpage[NBUCKETS] = PAGEFULL;
                else dicpage[NBUCKETS] = (char)(erc >> 1);
                                        /* Update free word pointer */
                return(0);              /* Mission accomplished */
            }
            else dicpage[NBUCKETS] = PAGEFULL;
                                        /* Mark page as full */
        }
        if((dpi += dpid) >= diclength) dpi -= diclength;
                                        /* Try next page */
        if(dpi == dpii) return(2);      /* Once around without finding it */
    }
}

/* Output empty dictionary page */

LOCAL void              nulpagout(void)
{
    register word       i;              /* Counter */
    char                temp[PAGLEN];   /* Page buffer */

    i = 0;                              /* Initialize */
    while(i < NBUCKETS) temp[i++] = '\0';
                                        /* Empty hash table */
    temp[i++] = FREEWD;                 /* Set free word pointer */
    while(i < PAGLEN) temp[i++] = '\0'; /* Clear rest of page */
    fwrite(temp,1,PAGLEN,fo);           /* Write empty page */
    chkerror();
}

/* Write dictionary to library */

LOCAL void              writedic(void)
{
    register IMPORT     *imp;           /* Symbol record */
    word                i;              /* Index variable */

    initsl();                           /* Initialize */
    for(imp = implist; imp != NULL; imp = I_NEXT(*imp))
    {
        if(instsym(imp))                /* If symbol already in dictionary */
            Error(ER_multdef, &I_EXTNAM(*imp)[1]);
                                        /* Issue error message */
    }
    for(i = 0; i < diclength; ++i)      /* Look through mapping table */
    {
        if(mpdpnpag[i] != NULL) pagout(mpdpnpag[i]);
                                        /* Write page if it exists */
        else nulpagout();               /* Else write an empty page */
    }
    chkerror();
}

LOCAL void              DisplayBanner(void)
{
    if (!fBannerOnScreen)
    {
        fprintf( stdout, "\nMicrosoft (R) Import Library Manager NtGroup "VERSION_STRING );
        fputs("\nCopyright (C) Microsoft Corp 1984-1996.  All rights reserved.\n\n", stdout);
        fflush(stdout);
        fBannerOnScreen = 1;
        #if C8_IDE
        if(fC8IDE)
        {   sprintf(msgBuf, "@I0\r\n");
            _write(_fileno(stderr), msgBuf, strlen(msgBuf));

            sprintf(msgBuf, "@I1Microsoft (R) Import Library Manager  "VERSION_STRING"\r\n" );
            _write(_fileno(stderr), msgBuf, strlen(msgBuf));

            sprintf(msgBuf, "@I2Copyright (C) Microsoft Corp 1984-1992. All rights reserved.\r\n");
            _write(_fileno(stderr), msgBuf, strlen(msgBuf));
        }
        #endif
    }
}

    /****************************************************************
    *                                                               *
    *  IsPrefix:                                                    *
    *                                                               *
    *  This  function  takes  as  its  arguments a  pointer  to  a  *
    *  null-terminated character string and a pointer to a  second  *
    *  null-terminated character  string.   The  function  returns  *
    *  true  if  the  first  string  is  a  prefix  of the second;  *
    *  otherwise, it returns false.                                 *
    *                                                               *
    ****************************************************************/

LOCAL int               IsPrefix(char *prefix, char *s)
{
    while(*prefix)                      /* While not at end of prefix */
    {
        if(UPPER(*prefix) != UPPER(*s)) return(0);
                                        /* Return zero if mismatch */
        ++prefix;                       /* Increment pointer */
        ++s;                            /* Increment pointer */
    }
    return(1);                          /* We have a prefix */
}


/*** ScanTable - build list of exports
*
* Purpose:
*   Scans Resident or Nonresident Name Table, Entry Table and
*   builds list of exported entries.
*
* Input:
*   pbTable     - pointer to Name Table
*   cbTable     - size of Name Table
*   fNoRes      - TRUE if non resident name table
*
* Output:
*   List of exported entries by DLL.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL void              ScanTable(word cbTable, int fNoRes)
{
    word                eno;
    char                buffer[256];
    register char       *pch;
    register byte       *pb;
    byte                *pTable;

    pb = alloc(cbTable);
    pTable  = pb;
    if (fread(pb, sizeof(char), cbTable, fi) != cbTable) {
        Error(ER_baddll);
        free(pTable);
        return;
    }
    while(cbTable != 0)
    {
        /* Get exported name length - if zero continue */

        --cbTable;
        if (!(eno = (word) *pb++ & 0xff))
            break;
        cbTable -= eno + 2;

        /* Copy name - length prefixed */

        pch = &buffer[1];
        buffer[0] = (byte) eno;
        while(eno--)
            *pch++ = *pb++;
        *pch = '\0';

        /* Get ordinal */

        eno = ((word) pb[0] & 0xff) + (((word) pb[1] & 0xff) << 8);
        pb += 2;

        /* If WEP and fIgnorewep is TRUE, ignore this symbol */

        if(fIgnorewep && strcmp(&buffer[1], "WEP") == 0)
                continue;

        if (eno != 0)
        {

            pch = alloc((word)(buffer[0] + 1));
            strncpy(pch, buffer, buffer[0] + 1);

            // If Implib is run on a DLL, it exports symbols:
            //       - by names for symbols in the resident name table
            //       - by ordinal for symbols in the non-resident name table

            export(pch, pch, (word)(fNoRes ? eno : 0), (word)0);
        }
        else if (!fNoRes)
            strncpy(sbModule, buffer, buffer[0] + 1);
                                            /* eno == 0 && !fNoRes --> module name */
    }
    if (cbTable != 0)
        Error(ER_baddll);
    free(pTable);
}



/*** ProcessDLL - extract information about exports from DLL
*
* Purpose:
*   Read in header of DLL and create list of exported entries.
*
* Input:
*   lfahdr - seek offset to segmented executable header.
*
* Output:
*   List of exported entries by DLL.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void              ProcessDLL(long lfahdr)
{
    struct new_exe      hdr;                /* .EXE header */


    if (fseek(fi, lfahdr, SEEK_SET) == -1) {
        return;
    }
    if (fread(&hdr, sizeof(char), sizeof(struct new_exe), fi) != sizeof(struct new_exe)) {
        return;
    }
    if(NE_CSEG(hdr) != 0)
    {
        /* If there are segments - read in tables */

        if (NE_MODTAB(hdr) > NE_RESTAB(hdr))
        {
            /* Process resident names table */

            if (fseek(fi, lfahdr + NE_RESTAB(hdr), SEEK_SET) == -1)
                return;
            ScanTable((word)(NE_MODTAB(hdr) - NE_RESTAB(hdr)), 0);
        }

        if (NE_CBNRESTAB(hdr) != 0)
        {
            /* Process non-resident names table */

            if (fseek(fi, (long) NE_NRESTAB(hdr), SEEK_SET) == -1)
                return;
            ScanTable(NE_CBNRESTAB(hdr), 1);
        }
    }
}

/* Print usage message */
void usage(int fShortHelp)
{
    int nRetCode;
#if NOT C8_IDE
    // in C8 implib /? == /HELP
    if (!fShortHelp)
    {
        nRetCode = spawnlp(P_WAIT, "qh", "qh", "/u implib.exe", NULL);
        fShortHelp = nRetCode<0 || nRetCode==3;
    }
    if (fShortHelp)
#endif
    {
        DisplayBanner();
        fprintf(stderr,"%s\n", GET_MSG(M_usage1));
        fprintf(stderr,"%s\n", GET_MSG(M_usage2));
        fprintf(stderr,"                 %s\n", GET_MSG(M_usage3));
//        fprintf(stderr,"                 %s\n", GET_MSG(M_usage4));
                fprintf(stderr,"                 %s\n", GET_MSG(M_usage8));
        fprintf(stderr,"                 %s\n", GET_MSG(M_usage5));
        fprintf(stderr,"                 %s\n", GET_MSG(M_usage6));
        fprintf(stderr,"                 %s\n", GET_MSG(M_usage7));
    }
    exit(0);
}


void cdecl main(int argc, char *argv[]) /* Parse the definitions file */
{
    int                 i;              /* Counter */
    long                lfadic;         /* File address of dictionary */
    int                 iArg;           /* Argument index */
    word                magic;          /* Magic number */
    struct exe_hdr      exe;            /* Old .EXE header */
    int                 fNologo;
    char drive[_MAX_DRIVE], dir[_MAX_DIR]; /* Needed for _splitpath */
    char fname[_MAX_FNAME], ext[_MAX_EXT];
    int                 fDefdllfound = 0; /* Flag will be set if the user
                                          specifies dll/def file */
    #if C8_IDE
    char                *pIDE = getenv("_MSC_IDE_FLAGS");
    #endif
    exitCode = 0;
    fNologo = 0;
    iArg = 1;
    #if C8_IDE
    if(pIDE)
    {
        if(strstr(pIDE, "FEEDBACK"))
        {
            fC8IDE = TRUE;
            #if DEBUG_IDE
            fprintf(stdout, "\r\nIDE ACTIVE - FEEDBACK is ON");
            #endif
        }
    }
    #endif

    if (argc > 1)
    {
        while (iArg < argc && (argv[iArg][0] == '-' || argv[iArg][0] == '/'))
        {
                if (argv[iArg][1] == '?')
                    usage(1);
                else if (IsPrefix(&argv[iArg][1], "help"))
                    usage(0);
                else if(IsPrefix(&argv[iArg][1], "ignorecase"))
                    fIgnorecase = 1;
                else if(IsPrefix(&argv[iArg][1], "noignorecase"))
                    fIgnorecase = 0;
                else if(IsPrefix(&argv[iArg][1], "nologo"))
                    fNologo = 1;
                else if(IsPrefix(&argv[iArg][1], "ntdll"))
                    fNTdll = 1;
                else if(IsPrefix(&argv[iArg][1], "nowep"))
                    fIgnorewep = 1;
                else
                    Error(ER_badoption, argv[iArg]);
                iArg++;
        }
    }
    else
    {
        DisplayBanner();
        exit(exitCode);                 /* All done */
    }

    if (!fNologo)
        DisplayBanner();

    _splitpath( argv[iArg], drive, dir, fname, ext );
    if(!_stricmp(ext,".DEF")||!_stricmp(ext,".DLL")) /* Ext. not allowed-bug #3*/
    {
        Fatal(ER_badtarget, ext);
    }
    #if C8_IDE
    if(fC8IDE)
    {
                sprintf(msgBuf, "@I3%s\r\n", GET_MSG(M_IDEco));
        _write(_fileno(stderr), msgBuf, strlen(msgBuf));

        sprintf(msgBuf, "@I4%s\r\n", argv[iArg]);
        _write(_fileno(stderr), msgBuf, strlen(msgBuf));
    }
    #endif


    if((fo = fopen(argv[iArg],WRBIN)) == NULL)
    {                                   /* If open fails */
        Fatal(ER_badcreate, argv[iArg], strerror(errno));
    }
    for(i = 0; i < 16; ++i) fputc(0,fo);/* Skip zeroth page for now */
    chkerror();
    implist = NULL;                     /* Initialize */
    csyms = 0;
    cbsyms = 0L;
    #if C8_IDE
    if(fC8IDE)
    {
                sprintf(msgBuf, "@I3%s\r\n", GET_MSG(M_IDEri));
        _write(_fileno(stderr), msgBuf, strlen(msgBuf));
    }
    #endif
    for(iArg++; iArg < argc; ++iArg)
    {
        if (argv[iArg][0] == '-' || argv[iArg][0] == '/')
        {
            fIgnorecase = IsPrefix(&argv[iArg][1], "ignorecase");
            iArg++;
            continue;
        }
        #if C8_IDE
        if(fC8IDE)
        {
            sprintf(msgBuf, "@I4%s\r\n",argv[iArg]);
            _write(_fileno(stderr), msgBuf, strlen(msgBuf));
        }
        #endif
        if((fi = fopen(defname = argv[iArg],RDBIN)) == NULL)
        {                               /* If open fails */
            Fatal(ER_badopen, argv[iArg], strerror(errno));
                                        /* Print error message */
        }
        fDefdllfound = 1;
        newimps = NULL;                 /* Initialize */
        lastimp = NULL;                 /* Initialize */
        csymsmod = 0;                   /* Initialize */
        fread(&exe, 1, sizeof(struct exe_hdr), fi);
                                        /* Read old .EXE header */
        if(E_MAGIC(exe) == EMAGIC)      /* If old header found */
        {
            if(E_LFARLC(exe) == sizeof(struct exe_hdr))
            {
                fseek(fi, E_LFANEW(exe), 0);
                                        /* Read magic number */
                magic  = (word) (getc(fi) & 0xff);
                magic += (word) ((getc(fi) & 0xff) << 8);
                if (magic == NEMAGIC)
                    ProcessDLL(E_LFANEW(exe));
                                        /* Scan .DLL */
                else
                {
                    Error(ER_baddll1, argv[iArg]);
                }
            }
            else
            {
                Error(ER_baddll1, argv[iArg]);
            }
        }
        else
        {
            fseek(fi, 0L, SEEK_SET);
            yyparse();                  /* Parse the definitions file */
        }
        fclose(fi);                     /* Close the definitions file */
        if(newimps != NULL)             /* If at least one new IMPDEF */
        {
            outimpdefs();               /* Output the library modules */
            I_NEXT(*lastimp) = implist; /* Concatenate lists */
            implist = newimps;          /* New head of list */
            csyms += csymsmod;          /* Increment symbol count */
        }
    }
    if (!fDefdllfound) /* No .def or .dll source was given */
        Fatal(ER_nosource);


    if(i = (int)((ftell(fo) + 4) & (PAGLEN - 1))) i = PAGLEN - i;
                                        /* Calculate padding needed */
    ++i;                                /* One for the checksum */
    fputc(DICHDR,fo);                   /* Dictionary header */
    fputc(i & 0xFF,fo);                 /* Lo-byte */
    fputc(i >> 8,fo);                   /* Hi-byte */
    while(i--) fputc(0,fo);             /* Padding */
    lfadic = ftell(fo);                 /* Get dictionary offset */
    writedic();                         /* Write the dictionary */
    fseek(fo,0L,0);                     /* Seek to header */
    fputc(LIBHDR,fo);                   /* Library header */
    fputc(13,fo);                       /* Length */
    fputc(0,fo);                        /* Length */
    fputc((int)(lfadic & 0xFF),fo);     /* Dictionary offset */
    fputc((int)((lfadic >> 8) & 0xFF),fo);
                                        /* Dictionary offset */
    fputc((int)((lfadic >> 16) & 0xFF),fo);
                                        /* Dictionary offset */
    fputc((int)(lfadic >> 24),fo);      /* Dictionary offset */
    fputc(diclength & 0xFF,fo);         /* Dictionary length */
    fputc(diclength >> 8,fo);           /* Dictionary length */
    if (fIgnorecase)                    /* Dictionary case sensivity */
        fputc(0, fo);
    else
        fputc(1, fo);
    chkerror();
    fclose(fo);                         /* Close the library */
    exit(exitCode);                     /* All done */
}
short yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
	};
# define YYNPROD 185
# define YYLAST 413
short yyact[]={

  10,  13,  14, 170,  27, 134, 135, 136, 137, 225,
 140, 143, 144, 143, 144, 149,  41, 208, 128, 189,
 167,  41, 166,  28, 185,  50,  49,  29,  30,  31,
  12,  32,  34,  35, 218, 219, 187,  48, 210, 157,
  41, 101, 205, 161, 221,  33, 215,  11, 223, 112,
 113, 114, 115, 116, 119, 217,  53,  51, 117, 118,
  54, 122, 121, 123,  15,  73, 124, 125, 126, 206,
 192, 178, 131,  46,  42,  45,  16,  36,  17,  42,
  37,  81,  82,  79,  66,  67,  71,  61,  74,  62,
  68,  63,  69,  72,  76,  77,  78,  75,  42, 102,
   4,   5, 154, 195,   6,   7, 220, 194, 181,  88,
 169,  60, 142, 133, 129, 109,  59, 106, 156,  58,
  52,   9, 164,  83,  84,  96,  97,  73, 139, 162,
  47,  99, 127,  98, 120,  55,  70,  64,  65,  86,
  80,  95,  94,  92,  93,  87,  66,  67,  71,  61,
  74,  62,  68,  63,  69,  72,  76,  77,  78,  75,
  47,  89,  90,  91, 103, 104,   8, 191, 130, 111,
  38, 108, 216, 204, 203, 105, 180, 150, 179, 153,
 100,  85,  57,  26,  25,  24,  23,  96,  97,  73,
  22,  21,  20,  19,  18, 141, 148, 176,  70,  64,
  65, 146,  87,  95,  94,  81,  82,  79,  66,  67,
  71,  61,  74,  62,  68,  63,  69,  72,  76,  77,
  78,  75, 107, 155, 158, 151, 160,  39,  43, 159,
 152, 174,  44, 138,  40, 152, 152, 132,   3,   2,
  56,   1, 224, 214, 186,   0, 168,  83,  84,   0,
 172,   0,   0,   0, 173,   0, 110,   0,   0,   0,
  70,  64,  65, 184,  80, 183,   0, 171, 145, 147,
 182,   0,   0,   0,   0, 175,   0, 177,   0, 193,
 197,   0, 196, 199,   0, 201,   0,   0,   0, 202,
 184,   0, 183,   0,   0,   0,   0, 182,   0,   0,
   0, 209,   0, 198, 211, 200, 212,   0, 213,   0,
   0,   0,   0,   0,   0, 222,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 110,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 163, 165,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 188,   0,   0,   0,   0, 190,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 207 };
short yypact[]={

-159,-1000,-267,-267,-225,-225,-187,-189,-267,-1000,
-286,-297,-266,-210,-210,-1000,-1000,-225,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000, -68,-130,-224,
-224,-224,-225,-225,-252,-241,-307,-194,-267,-1000,
-333,-1000,-1000,-1000,-325,-225,-225,-1000,-1000,-1000,
-1000,-1000,-1000,-311,-1000,-1000,-1000, -68,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-130,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-224,-1000,
-156,-1000,-1000,-224,-224,-225,-1000,-280,-225,-1000,
-280,-194,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-235,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-225,-244,-1000,
-304,-1000,-333,-339,-1000,-1000,-1000,-1000,-325,-339,
-1000,-323,-1000,-1000,-1000,-1000,-325,-1000,-325,-195,
-1000,-1000,-1000,-192,-299,-1000,-284,-225,-1000,-305,
-1000,-1000,-225,-1000,-1000,-1000,-1000,-196,-339,-158,
-1000,-339,-158,-1000,-325,-158,-325,-158,-1000,-1000,
-192,-1000,-1000,-1000,-1000,-1000,-271,-197,-1000,-249,
-1000,-1000,-1000,-158,-1000,-281,-158,-1000,-158,-1000,
-158,-1000,-1000,-226,-211,-1000,-287,-228,-228,-1000,
-218,-1000,-1000,-1000,-332,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000 };
short yypgo[]={

   0, 222, 118, 244, 243, 242, 241, 239, 166, 238,
 237, 113, 110, 107, 234, 233, 128, 232, 231, 201,
 197, 196, 195, 112, 121, 120, 194, 193, 192, 191,
 190, 186, 185, 184, 183, 182, 119, 116, 111, 181,
 139, 109, 133, 131, 180, 179, 178, 108, 176, 175,
 117, 174, 173, 172, 171, 115, 106, 169, 114, 168,
 167, 134, 132, 129, 122 };
short yyr1[]={

   0,   6,   6,   9,   6,  10,   7,  14,   7,  15,
   7,  17,   7,  18,   7,  19,   7,  20,   7,  21,
   7,  16,  16,  16,  22,  22,  23,  23,  13,  13,
  11,  11,  11,  11,  11,  12,  12,   8,   8,  24,
  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,
  24,  24,  24,  24,  24,  24,  24,  25,  25,  25,
  26,  35,  35,  36,  36,  38,  38,  38,  38,  38,
  38,  27,  39,  39,  40,  40,  40,  40,  40,  40,
  40,  41,  41,  41,  41,  28,  28,  28,  28,  28,
  28,  42,  42,  43,  44,  44,  45,  45,  47,  47,
  47,  48,  48,  46,  46,  37,  37,  37,  37,  37,
  37,  37,  37,  37,  37,  37,  37,  37,  37,  37,
  37,  37,  37,  29,  29,  49,  49,  50,   2,   2,
   3,   3,   3,   3,  51,  52,  52,  53,  53,   4,
   4,   5,   5,  30,  30,  54,  54,  55,  55,   1,
   1,  56,  56,  31,  31,  57,  57,  57,  57,  57,
  57,  57,  57,  57,  58,  58,  59,  59,  60,  60,
  34,  32,  61,  61,  61,  61,  61,  61,  33,  62,
  62,  64,  64,  63,  63 };
short yyr2[]={

   0,   2,   1,   0,   2,   0,   6,   0,   5,   0,
   6,   0,   5,   0,   6,   0,   5,   0,   6,   0,
   5,   1,   1,   0,   2,   1,   1,   1,   3,   0,
   1,   1,   1,   1,   0,   1,   0,   2,   1,   2,
   2,   2,   2,   2,   2,   1,   1,   2,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   3,   1,   1,
   2,   2,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   2,   2,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   2,   1,   2,   1,   2,
   1,   2,   1,   3,   1,   1,   2,   0,   1,   1,
   1,   2,   1,   1,   0,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   2,   1,   2,   1,   6,   2,   0,
   3,   3,   2,   0,   2,   1,   0,   1,   0,   1,
   0,   1,   0,   2,   1,   2,   1,   5,   5,   1,
   1,   1,   0,   3,   1,   1,   1,   1,   1,   1,
   1,   1,   2,   1,   3,   1,   1,   0,   1,   0,
   2,   2,   1,   1,   1,   1,   1,   1,   3,   2,
   0,   1,   1,   2,   1 };
short yychk[]={

-1000,  -6,  -7,  -9, 259, 260, 263, 264,  -8, -24,
 267, 314, 297, 268, 269, 331, 343, 345, -26, -27,
 -28, -29, -30, -31, -32, -33, -34, 271, 290, 294,
 295, 296, 298, 312, 299, 300, 344, 347,  -8,  -1,
 -14, 265, 323,  -1, -17, 262, 262, -24, 323, 323,
 291, 323, -25, 266, 270, -25,  -1, -35, -36, -37,
 -38, 279, 281, 283, 329, 330, 276, 277, 282, 284,
 328, 278, 285, 257, 280, 289, 286, 287, 288, 275,
 332, 273, 274, 315, 316, -39, -40, -37, -41, 291,
 292, 293, 273, 274, 334, 333, 317, 318, -42, -43,
 -44, 265, 323, -42, -42, -49, -50,  -1, -54, -55,
  -1, -57, 301, 302, 303, 304, 305, 310, 311, 306,
 -61, 303, 302, 304, 307, 308, 309, -62, 325, -58,
 -59, 266, -10, -11, 338, 339, 340, 341, -15, -16,
 335, -22, -23, 336, 337,  -1, -19,  -1, -21, 326,
 -36, -40, -43, -45, 258, -50,  -2, 319, -55,  -2,
 -58, 278, -63,  -1, -64,  -1, 266, 324, -11, -12,
 342, -16, -12, -23, -18, -16, -20, -16, 266, -46,
 -48, -47, -37, -38, -41, 323,  -3, 320,  -1, 324,
  -1, -60, 266, -12, -13, 261, -12, -13, -16, -13,
 -16, -13, -47, -51, -52, 313, 266,  -1, 266, -13,
 319, -13, -13, -13,  -4, 272, -53, 266, 321, 322,
 -56, 272, -56, 266,  -5, 341 };
short yydef[]={

   3,  -2,   2,   0,   7,  11,   0,   0,   1,  38,
   0,   0,   0,   0,   0,  45,  46,   0,  48,  49,
  50,  51,  52,  53,  54,  55,  56,   0,   0,  86,
  88,  90, 124, 144, 154,   0, 180, 167,   4,   5,
  34, 149, 150,   9,  23,  15,  19,  37,  39,  40,
  41,  42,  43,  58,  59,  44,  47,  60,  62,  63,
  64, 105, 106, 107, 108, 109, 110, 111, 112, 113,
 114, 115, 116, 117, 118, 119, 120, 121, 122,  65,
  66,  67,  68,  69,  70,  71,  73,  74,  75,  76,
  77,  78,  79,  80,  81,  82,  83,  84,  85,  92,
  97,  94,  95,  87,  89, 123, 126, 129, 143, 146,
 129, 167, 155, 156, 157, 158, 159, 160, 161, 163,
 171, 172, 173, 174, 175, 176, 177,   0,   0, 170,
 165, 166,  34,  36,  30,  31,  32,  33,  23,  36,
  21,  22,  25,  26,  27,  13,  23,  17,  23,   0,
  61,  72,  91, 104,   0, 125, 133,   0, 145,   0,
 153, 162, 178, 184, 179, 181, 182, 169,  36,  29,
  35,  36,  29,  24,  23,  29,  23,  29,  57,  93,
 103, 102,  98,  99, 100,  96, 136,   0, 128,   0,
 183, 164, 168,  29,   8,   0,  29,  12,  29,  16,
  29,  20, 101, 140, 138, 135, 132, 152, 152,   6,
   0,  10,  14,  18, 142, 139, 134, 137, 130, 131,
 147, 151, 148,  28, 127, 141 };
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG                          /* RRR - 10/9/85 */
#define yyprintf(a, b, c) printf(a, b, c)
#else
#define yyprintf(a, b, c)
#endif

/*      parser for yacc output  */

YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

int NEAR yyparse(void)
   {

   short yys[YYMAXDEPTH];
   short yyj, yym;
   register YYSTYPE *yypvt;
   register short yystate, *yyps, yyn;
   register YYSTYPE *yypv;
   register short *yyxi;

   yystate = 0;
   yychar = -1;
   yynerrs = 0;
   yyerrflag = 0;
   yyps= &yys[-1];
   yypv= &yyv[-1];

yystack:    /* put a state and value onto the stack */

   yyprintf( "state %d, char 0%o\n", yystate, yychar );
   if( ++yyps> &yys[YYMAXDEPTH] )
      {
      yyerror( "yacc stack overflow" );
      return(1);
      }
   *yyps = yystate;
   ++yypv;
   *yypv = yyval;
yynewstate:

   yyn = yypact[yystate];

   if( yyn<= YYFLAG ) goto yydefault; /* simple state */

   if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
   if( (yyn += (short)yychar)<0 || yyn >= YYLAST ) goto yydefault;

   if( yychk[ yyn=yyact[ yyn ] ] == yychar )
      {
      /* valid shift */
      yychar = -1;
      yyval = yylval;
      yystate = yyn;
      if( yyerrflag > 0 ) --yyerrflag;
      goto yystack;
      }
yydefault:
   /* default state action */

   if( (yyn=yydef[yystate]) == -2 )
      {
      if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
      /* look through exception table */

      for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

      for(yyxi+=2; *yyxi >= 0; yyxi+=2)
         {
         if( *yyxi == yychar ) break;
         }
      if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
      }

   if( yyn == 0 )
      {
      /* error */
      /* error ... attempt to resume parsing */

      switch( yyerrflag )
         {

      case 0:   /* brand new error */

         yyerror( "syntax error" );
         ++yynerrs;

      case 1:
      case 2: /* incompletely recovered error ... try again */

         yyerrflag = 3;

         /* find a state where "error" is a legal shift action */

         while ( yyps >= yys )
            {
            yyn = yypact[*yyps] + YYERRCODE;
            if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE )
               {
               yystate = yyact[yyn];  /* simulate a shift of "error" */
               goto yystack;
               }
            yyn = yypact[*yyps];

            /* the current yyps has no shift onn "error", pop stack */

            yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
            --yyps;
            --yypv;
            }

         /* there is no state on the stack with an error shift ... abort */

yyabort:
         return(1);


      case 3:  /* no shift yet; clobber input char */
         yyprintf( "error recovery discards char %d\n", yychar, 0 );

         if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
         yychar = -1;
         goto yynewstate;   /* try again in the same state */

         }

      }

   /* reduction by production yyn */

   yyprintf("reduce %d\n",yyn, 0);
   yyps -= yyr2[yyn];
   yypvt = yypv;
   yypv -= yyr2[yyn];
   yyval = yypv[1];
   yym=yyn;
   /* consult goto table to find next state */
   yyn = yyr1[yyn];
   yyj = yypgo[yyn] + *yyps + 1;
   if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
   switch(yym)
      {
      
case 3:
# line 409
{
                    DefaultModule(moduleEXE);
                } break;
case 5:
# line 416
{
                    fFileNameExpected = 0;
                } break;
case 6:
# line 420
{
                    NewModule(yypvt[-4]._bp, moduleEXE);
                } break;
case 7:
# line 424
{
                    fFileNameExpected = 0;
                } break;
case 8:
# line 428
{
                    DefaultModule(moduleEXE);
                } break;
case 9:
# line 432
{
                    fFileNameExpected = 0;
                } break;
case 10:
# line 436
{
                    NewModule(yypvt[-4]._bp, moduleDLL);
                } break;
case 11:
# line 440
{
                    fFileNameExpected = 0;
                } break;
case 12:
# line 444
{
                    DefaultModule(moduleDLL);
                } break;
case 13:
# line 448
{
                    fFileNameExpected = 0;
                } break;
case 14:
# line 452
{
                    NewModule(yypvt[-3]._bp, moduleDLL);
                } break;
case 15:
# line 456
{
                    fFileNameExpected = 0;
                } break;
case 16:
# line 460
{
                    DefaultModule(moduleDLL);
                } break;
case 17:
# line 464
{
                    fFileNameExpected = 0;
                } break;
case 18:
# line 468
{
                    NewModule(yypvt[-3]._bp, moduleDLL);
                } break;
case 19:
# line 472
{
                    fFileNameExpected = 0;
                } break;
case 20:
# line 476
{
                    DefaultModule(moduleDLL);
                } break;
case 21:
# line 482
{
                } break;
case 127:
# line 644
{
                    if (yypvt[-0]._wd)
                    {
                        // Skip private exports

                        free(yypvt[-5]._bp);
                        free(yypvt[-4]._bp);
                    }
                    else
                        export(yypvt[-5]._bp,yypvt[-4]._bp,yypvt[-3]._wd,yypvt[-1]._wd);
                } break;
case 128:
# line 658
{
                    yyval._bp = yypvt[-0]._bp;
                } break;
case 129:
# line 662
{
                    yyval._bp = NULL;
                } break;
case 130:
# line 668
{
                    yyval._wd = yypvt[-1]._wd;
                } break;
case 131:
# line 672
{
                    yyval._wd = yypvt[-1]._wd;
                } break;
case 132:
# line 676
{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 133:
# line 680
{
                    yyval._wd = 0;
                } break;
case 139:
# line 697
{
                    yyval._wd = 0x1;
                } break;
case 140:
# line 701
{
                    yyval._wd = 0;
                } break;
case 141:
# line 707
{
                    yyval._wd = 1;
                } break;
case 142:
# line 711
{
                    yyval._wd = 0;
                } break;
case 149:
# line 729
{
                    yyval._bp = _strdup(rgbid);
                } break;
case 150:
# line 733
{
                    yyval._bp = _strdup(rgbid);
                } break;/* End of actions */
      }
   goto yystack;  /* stack new state and value */

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\impliber.h ===
char * __NMSG_TEXT (unsigned);

#define	ER_Min		2600
#define	ER_multdef	2601
#define	ER_baddll	2602
#define	ER_baddll1	2603
#define	ER_Max		2699
#define	ER_MinFatal	1599
#define	ER_outfull	1600
#define	ER_nomem	1601
#define	ER_syntax	1602
#define	ER_badcreate	1603
#define	ER_badopen	1604
#define	ER_toomanyincl	1605
#define	ER_badinclname	1606
#define	ER_badtarget	1607
#define	ER_nosource	1608
#define	ER_MaxFatal	1699
#define	ER_MinWarn	4599
#define	ER_linemax	4600
#define	ER_badoption	4601
#define	ER_MaxWarn	4699
#define	M_MinUsage	999
#define	M_usage1	1000
#define	M_usage2	1001
#define	M_usage3	1002
#define	M_usage5	1004
#define	M_usage6	1005
#define	M_usage7	1006
#define	M_error 	1007
#define	M_fatal 	1008
#define	M_IDEri	1009
#define	M_IDEco	1010
#define	M_usage8	1011
#define	M_MaxUsage	1099

#define GET_MSG(x) __NMSG_TEXT(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\lnkio.h ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                    LINKER I/O INCLUDE FILE                    *
    *                                                               *
    ****************************************************************/

#if IOMACROS                            /* If I/O macros requested */
#define OutByte(f,b)    putc(b,f)       /* Write a byte to file f */
#else                                   /* Otherwise */
#define OutByte(f,b)    fputc(b,f)      /* Write a byte to file f */
#endif                                  /* End conditional macro definition */
#if WIN_3 OR CRLF
extern char             _eol[];         /* End-of-line sequence */
#endif
#if WIN_3
#define NEWLINE(f) ((f)==bsLst ? fputs(_eol,f) : 0)
#else
#if CRLF                                /* If newline is ^M^J */
#define NEWLINE(f)      fputs(_eol,f)   /* Newline macro */
#else                                   /* Else if newline is ^J */
#define NEWLINE(f)      OutByte(f,'\n') /* Newline macro */
#endif                                  /* End conditional macro definition */
#endif

#define RDTXT           "rt"            /* Text file */
#define RDBIN           "rb"            /* Binary file */
#define WRTXT           "wt"            /* Text file */
#define WRBIN           "wb"            /* Binary file */
#define SETRAW(f)                       /* No-op */
#if M_WORDSWAP AND NOT M_BYTESWAP
#define xread(a,b,c,d)  fread(a,b,c,d)
#else
#define xread(a,b,c,d)  sread(a,b,c,d)
#define xwrite(a,b,c,d) swrite(a,b,c,d)
#endif
#if NOT NEWSYM
#define OutSb(f,pb)     fwrite(&((BYTE *)(pb))[1],1,B2W(((BYTE *)(pb))[0]),f)
                                        /* Write out length-prefixed string */
#endif
#if CLIBSTD AND NOT OSXENIX
#include                <fcntl.h>
#include                <share.h>
#else
#define O_RDONLY        0
#define O_BINARY        0
#define SH_DENYWR       0x20
#endif

#define CloseFile(f)  { fclose(f); f = NULL; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\lnkmsg.h ===
char * __NMSG_TEXT (unsigned);

#define	ER_swambig	1001
#define	ER_swqe	1003
#define	ER_swbadnum	1004
#define	ER_swpack	1005
#define	ER_swstack	1006
#define	ER_swovl	1007
#define	ER_swseglim	1008
#define	ER_swcpar	1009
#define	ER_noobj	1020
#define	ER_nestrf	1021
#define	ER_linmax	1022
#define	ER_intrpt	1023
#define	ER_nstrpar	1024
#define	ER_nstlpar	1025
#define	ER_unmrpar	1026
#define	ER_unmlpar	1027
#define	ER_dfimport	1030
#define	ER_dfdesc	1031
#define	ER_dfname	1032
#define	ER_dflinemax	1033
#define	ER_dfnamemax	1034
#define	ER_dfsyntax	1035
#define	ER_expmax	1040
#define	ER_resovf	1041
#define	ER_nresovf	1042
#define	ER_relovf	1043
#define	ER_inamovf	1044
#define	ER_typdef	1045
#define	ER_extdef	1046
#define	ER_nammax	1047
#define	ER_segdef	1048
#define	ER_segmax	1049
#define	ER_grpdef	1050
#define	ER_grpmax	1051
#define	ER_libmax	1052
#define	ER_symovf	1053
#define	ER_seglim	1054
#define	ER_ovlmax	1056
#define	ER_datarec	1057
#define	ER_cvovf	1063
#define	ER_memovf	1064
#define	ER_ovlthunk	1065
#define	ER_ovl64k	1066
#define	ER_membad	1067
#define	ER_segsize	1070
#define	ER_txtmax	1071
#define	ER_comarea	1072
#define	ER_fsegmax	1073
#define	ER_grpovf	1074
#define	ER_etovf	1075
#define	ER_seg386	1076
#define	ER_32comarea	1077
#define	ER_filesec	1078
#define	ER_lstopn	1080
#define	ER_spcrun	1081
#define	ER_nostub	1082
#define	ER_runopn	1083
#define	ER_maktmp	1084
#define	ER_opntmp	1085
#define	ER_noscr	1086
#define	ER_eoftmp	1087
#define	ER_spclst	1088
#define	ER_opnrf	1089
#define	ER_ropnlst	1090
#define	ER_libeof	1091
#define	ER_opndf	1092
#define	ER_opnobj	1093
#define	ER_openw	1094
#define	ER_space	1095
#define	ER_eof	1096
#define	ER_ioerr	1097
#define	ER_badinclopen	1098
#define	ER_badstub	1100
#define	ER_badobj	1101
#define	ER_eofobj	1102
#define	ER_segbnd	1103
#define	ER_badlib	1104
#define	ER_incerr	1105
#define	ER_badalloc	1106
#define	ER_badselect	1107
#define	ER_badcvseg	1108
#define	ER_badlibpath	1109
#define	ER_unrcom	1113
#define	ER_undefcomdat	1114
#define	ER_swbadovl	1115
#define	ER_unalloc	1117
#define	ER_16seg32	1123
#define	ER_badiopl	1126
#define	ER_binary	1127
#define	ER_toomanyincl	1128
#define	ER_badinclname	1129
#define	ER_impent	2000
#define	ER_fixovf	2002
#define	ER_fixinter	2003
#define	ER_fixbad	2005
#define	ER_fixmax	2010
#define	ER_nearhuge	2011
#define	ER_arrmis	2012
#define	ER_lidata	2013
#define	ER_expund	2022
#define	ER_expimp	2023
#define	ER_pubdup	2024
#define	ER_symdup	2025
#define	ER_ordmul	2026
#define	ER_ordmax	2027
#define	ER_datamax	2028
#define	ER_UnresExtern	2029
#define	ER_startaddr	2030
#define	ER_stktoobig	2041
#define	ER_qlib 	2043
#define	ER_symdup1	2044
#define	ER_difcls	2045
#define	ER_shared	2046
#define	ER_iopl 	2047
#define	ER_ovlmnger	2048
#define	ER_extmnger	2049
#define	ER_32_16_bit	2050
#define	ER_callmis	2052
#define	ER_badsize	2057
#define	ER_badexact	2058
#define	ER_size4Gb	2059
#define	ER_size64k	2060
#define	ER_nospace	2061
#define	ER_badconcat	2062
#define	ER_comdatalloc	2063
#define	ER_ovlstart	2064
#define	ER_farovldptr	2066
#define	ER_fixsegd	4000
#define	ER_fixfrm	4001
#define	ER_fixfrmab	4002
#define	ER_fixinterw	4003
#define	ER_fixovfw	4004
#define	ER_alnbad	4010
#define	ER_pckval	4011
#define	ER_loadhi	4012
#define	ER_swbadnew	4013
#define	ER_swbadold	4014
#define	ER_dbgdsa	4015
#define	ER_dbgexe	4016
#define	ER_swunrecw	4017
#define	ER_badpmtype	4018
#define	ER_tinyincr	4019
#define	ER_dynexep	4087
#define	ER_segunsf	4020
#define	ER_nostack	4021
#define	ER_grpovl	4022
#define	ER_expcon	4023
#define	ER_expmul	4024
#define	ER_impcon	4025
#define	ER_impself	4026
#define	ER_impmul	4027
#define	ER_segdup	4028
#define	ER_cod2dat	4029
#define	ER_adcvt	4030
#define	ER_grpmul	4031
#define	ER_codunsf	4032
#define	ER_mixgrp32	4033
#define	ER_osnmax	4034
#define	ER_noautod	4036
#define	ER_nostartaddr	4038
#define	ER_stksize	4040
#define	ER_badpack	4050
#define	ER_comstart	4055
#define	ER_exepack	4056
#define	ER_ignostksize	4057
#define	ER_ignoalias	4058
#define	ER_farovl	4059
#define	ER_stackdb	4089
#define	ER_oldopn	4042
#define	ER_oldbad	4043
#define	ER_outputname	4045
#define	ER_libopn	4051
#define	ER_vmtmp	4053
#define	ER_fileopn	4054
#define	ER_weakredef	4067
#define	ER_stack64	4068
#define	ER_fntoolong	4069
#define	ER_pubmax	4070
#define	ER_badobjtype	4075
#define	ER_nosegdef	4076
#define	ER_notdefcomdat	4077
#define	ER_duporder	4079
#define	ER_aliasredef	4080
#define	ER_badspawn	4081
#define	ER_badsegovl	4082
#define	ER_badcomdatovl	4083
#define	ER_opnoarg	4084
#define	ER_arginvalid	4085
#define	ER_badfarcall	4088
#define	ER_UnresExtra	99
#define	P_EnterNewFileSpec	102
#define	P_ChangeDiskette	103
#define	P_tmpfilecreated	104
#define	P_dontchangedisk	105
#define	P_replace	106
#define	P_genexe	107
#define	P_stubmsg	108
#define	P_switches	109
#define	P_objprompt	110
#define	P_runfile	111
#define	P_runfile	111
#define	P_listfile	112
#define	P_libprompt	113
#define	P_defprompt	114
#define	P_1error	115
#define	P_errors	116
#define	MAP_group	117
#define	MAP_expaddr	118
#define	MAP_expexp	119
#define	MAP_expalias	120
#define	MAP_hdraddr	121
#define	MAP_hdrpubnam	122
#define	MAP_hdrlocnam	123
#define	MAP_hdrpubval	124
#define	MAP_hdrlocval	125
#define	MAP_hdrstart	126
#define	MAP_hdrlen	127
#define	MAP_hdrname	128
#define	MAP_hdrclass	129
#define	MAP_hdrseg86	130
#define	MAP_resident	131
#define	MAP_overlay	132
#define	MAP_entry	133
#define	P_QCtmpfilecreated	  134
#define	P_usage1	135
#define	P_usage2	136
#define	P_usage3	137
#define	P_stubmsgwin	139
#define	P_parsedeffile	140
#define	P_passone	141
#define	P_libsearch	142
#define	P_assignadd	143
#define	P_printmap	144
#define	P_passtwo	145
#define	P_writing1	146
#define	P_writing2	147
#define	P_writing3	148
#define	P_overlaycalls	149
#define	P_noexe	150
#define	P_lwParseDef	151
#define	P_lwPassOne	152
#define	P_lwLibraryS	153
#define	P_lwPassTwo	154
#define	P_lwMapfile	155
#define	P_lwExecutable	156
#define	P_lwAssign	157
#define	N_tgtexternal	300
#define	N_frmseg	301
#define	N_tgtseg	302
#define	N_tgtoff	303
#define	N_warning	304
#define	N_error 	305
#define	N_fatal 	306
#define	N_pos	307
#define	N_rectyp	308
#define	N_infiles	309
#define	N_version	310
#define	N_allrights	311
#define	STAT_segs	312
#define	STAT_groups	313
#define	STAT_bytes	314
#define	STAT_ovls	315

#define GET_MSG(x) __NMSG_TEXT(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\l3216msg.c ===
#include <stdio.h>

typedef struct _message {
	unsigned int	id;
	char *str;
} MESSAGE;

MESSAGE __MSGTAB[] = {
{1001, "%s : option name ambiguous"}, // "%s : option name ambiguous"
{1003, "/Q and /EXEPACK incompatible"}, // "/Q and /EXEPACK incompatible"
{1004, "%s : invalid numeric value"}, // "%s : invalid numeric value"
{1005, "%s : packing limit exceeds 64K"}, // "%s : packing limit exceeds 64K"
{1006, "%s : stack size exceeds 64K-2"}, // "%s : stack size exceeds 64K-2"
{1007, "%s : interrupt number exceeds 255"}, // "%s : interrupt number exceeds 255"
{1008, "%s : segment limit set too high"}, // "%s : segment limit set too high"
{1009, "%s : /CPARM : illegal value"}, // "%s : /CPARM : illegal value"
{1020, "no object files specified"}, // "no object files specified"
{1021, "cannot nest response files"}, // "cannot nest response files"
{1022, "response line too long"}, // "response line too long"
{1023, "terminated by user"}, // "terminated by user"
{1024, "nested right parentheses"}, // "nested right parentheses"
{1025, "nested left parentheses"}, // "nested left parentheses"
{1026, "unmatched right parenthesis"}, // "unmatched right parenthesis"
{1027, "unmatched left parenthesis"}, // "unmatched left parenthesis"
{1030, "missing internal name"}, // "missing internal name"
{1031, "module description redefined"}, // "module description redefined"
{1032, "module name redefined"}, // "module name redefined"
{1033, "input line too long; %d characters allowed"}, // "input line too long; %d characters allowed"
{1034, "name truncated to '%s'"}, // "name truncated to '%s'"
{1035, "%s in module-definition file"}, // "%s in module-definition file"
{1040, "too many exported entries"}, // "too many exported entries"
{1041, "resident names table overflow"}, // "resident names table overflow"
{1042, "nonresident names table overflow"}, // "nonresident names table overflow"
{1043, "relocation table overflow"}, // "relocation table overflow"
{1044, "imported names table overflow"}, // "imported names table overflow"
{1045, "too many TYPDEF records"}, // "too many TYPDEF records"
{1046, "too many external symbols in one module"}, // "too many external symbols in one module"
{1047, "too many group, segment, and class names in one module"}, // "too many group, segment, and class names in one module"
{1048, "too many segments in one module"}, // "too many segments in one module"
{1049, "too many segments"}, // "too many segments"
{1050, "too many groups in one module"}, // "too many groups in one module"
{1051, "too many groups"}, // "too many groups"
{1052, "too many libraries"}, // "too many libraries"
{1053, "out of memory for symbol table"}, // "out of memory for symbol table"
{1054, "requested segment limit too high"}, // "requested segment limit too high"
{1056, "too many overlays"}, // "too many overlays"
{1057, "data record too large"}, // "data record too large"
{1063, "out of memory for debugging information"}, // "out of memory for debugging information"
{1064, "out of memory"}, // "out of memory"
{1065, "too many interoverlay calls\r\nuse /DYNAMIC:<nnn>; current limit is %d"}, // "too many interoverlay calls\r\nuse /DYNAMIC:<nnn>; current limit is %d"
{1066, "size of %d overlay exceeds 64K"}, // "size of %d overlay exceeds 64K"
{1067, "system memory allocation error; reboot and relink"}, // "system memory allocation error; reboot and relink"
{1070, "%s : segment size exceeds 64K"}, // "%s : segment size exceeds 64K"
{1071, "segment _TEXT exceeds 64K-16"}, // "segment _TEXT exceeds 64K-16"
{1072, "common area longer than 65536 bytes"}, // "common area longer than 65536 bytes"
{1073, "file-segment limit exceeded"}, // "file-segment limit exceeded"
{1074, "%s : group larger than 64K bytes"}, // "%s : group larger than 64K bytes"
{1075, "entry table exceeds 64K-1"}, // "entry table exceeds 64K-1"
{1076, "%s : segment size exceeds %dMB"}, // "%s : segment size exceeds %dMB"
{1077, "common area longer than 4GB-1"}, // "common area longer than 4GB-1"
{1078, "file-segment alignment too small"}, // "file-segment alignment too small"
{1080, "cannot open list file"}, // "cannot open list file"
{1081, "cannot write to the executable file - %s"}, // "cannot write to the executable file - %s"
{1082, "%s : stub file not found"}, // "%s : stub file not found"
{1083, "%s : cannot open run file - %s"}, // "%s : cannot open run file - %s"
{1084, "cannot create temporary file"}, // "cannot create temporary file"
{1085, "cannot open temporary file - %s"}, // "cannot open temporary file - %s"
{1086, "temporary file missing"}, // "temporary file missing"
{1087, "unexpected end-of-file on temporary file"}, // "unexpected end-of-file on temporary file"
{1088, "out of space for list file"}, // "out of space for list file"
{1089, "%s : cannot open response file"}, // "%s : cannot open response file"
{1090, "cannot reopen list file"}, // "cannot reopen list file"
{1091, "unexpected end-of-file on library"}, // "unexpected end-of-file on library"
{1092, "cannot open module-definition file - %s"}, // "cannot open module-definition file - %s"
{1093, "%s : object file not found"}, // "%s : object file not found"
{1094, "%s : cannot open file for writing"}, // "%s : cannot open file for writing"
{1095, "%s : out of space for file"}, // "%s : out of space for file"
{1096, "unexpected end-of-file in response file"}, // "unexpected end-of-file in response file"
{1097, "I/O error - %s"}, // "I/O error - %s"
{1098, "cannot open include file '%s' - %s"}, // "cannot open include file '%s' - %s"
{1100, "stub .EXE file invalid"}, // "stub .EXE file invalid"
{1101, "invalid object module"}, // "invalid object module"
{1102, "unexpected end-of-file"}, // "unexpected end-of-file"
{1103, "%s : attempt to access data outside segment bounds"}, // "%s : attempt to access data outside segment bounds"
{1104, "%s : not valid library"}, // "%s : not valid library"
{1105, "invalid object due to interrupted incremental compile"}, // "invalid object due to interrupted incremental compile"
{1106, "unknown COMDAT allocation type for %s; record ignored"}, // "unknown COMDAT allocation type for %s; record ignored"
{1107, "unknown COMDAT selection type for %s; record ignored"}, // "unknown COMDAT selection type for %s; record ignored"
{1108, "invalid format of debugging information"}, // "invalid format of debugging information"
{1109, "%s : library path too long"}, // "%s : library path too long"
{1113, "unresolved COMDEF; internal error"}, // "unresolved COMDEF; internal error"
{1114, "unresolved COMDAT %s; internal error"}, // "unresolved COMDAT %s; internal error"
{1115, "%s: option incompatible with overlays"}, // "%s: option incompatible with overlays"
{1117, "unallocated COMDAT %s; internal error"}, // "unallocated COMDAT %s; internal error"
{1123, "%s : segment defined both 16- and 32-bit"}, // "%s : segment defined both 16- and 32-bit"
{1126, "conflicting pwords value"}, // "conflicting pwords value"
{1127, "far segment references not allowed with /TINY"}, // "far segment references not allowed with /TINY"
{1128, "too many nested include files in module-definition file"}, // "too many nested include files in module-definition file"
{1129, "missing or invalid include file name"}, // "missing or invalid include file name"
{2000, "imported starting address"}, // "imported starting address"
{2002, "fixup overflow at %lX in segment %s"}, // "fixup overflow at %lX in segment %s"
{2003, "near reference to far target at %lX in segment %s"}, // "near reference to far target at %lX in segment %s"
{2005, "fixup type unsupported at %lX in segment %s"}, // "fixup type unsupported at %lX in segment %s"
{2010, "too many fixups in LIDATA record"}, // "too many fixups in LIDATA record"
{2011, "%s : NEAR/HUGE conflict"}, // "%s : NEAR/HUGE conflict"
{2012, "%s : array-element size mismatch"}, // "%s : array-element size mismatch"
{2013, "LIDATA record too large"}, // "LIDATA record too large"
{2022, "%s%s: export undefined"}, // "%s%s: export undefined"
{2023, "%s (alias %s) : export imported"}, // "%s (alias %s) : export imported"
{2024, "%s : special symbol already defined"}, // "%s : special symbol already defined"
{2025, "%s : symbol defined more than once"}, // "%s : symbol defined more than once"
{2026, "entry ordinal %u, name %s : multiple definitions for same ordinal"}, // "entry ordinal %u, name %s : multiple definitions for same ordinal"
{2027, "%s : ordinal too large for export"}, // "%s : ordinal too large for export"
{2028, "automatic data segment plus heap exceed 64K"}, // "automatic data segment plus heap exceed 64K"
{2029, "'%s' : unresolved external\r\n"}, // "'%s' : unresolved external\r\n"
{2030, "starting address not code (use class 'CODE')"}, // "starting address not code (use class 'CODE')"
{2041, "stack plus data exceed 64K"}, // "stack plus data exceed 64K"
{2043, "Quick library support module missing"}, // "Quick library support module missing"
{2044, "%s : symbol multiply defined, use /NOE"}, // "%s : symbol multiply defined, use /NOE"
{2045, "%s : segment with > 1 class name not allowed with /INCR"}, // "%s : segment with > 1 class name not allowed with /INCR"
{2046, "share attribute conflict - segment %s in group %s"}, // "share attribute conflict - segment %s in group %s"
{2047, "IOPL attribute conflict - segment %s in group %s"}, // "IOPL attribute conflict - segment %s in group %s"
{2048, "Microsoft Overlay Manager module not found"}, // "Microsoft Overlay Manager module not found"
{2049, "Microsoft DOS Extender module not found"}, // "Microsoft DOS Extender module not found"
{2050, "USE16/USE32 attribute conflict - segment %s in group %s"}, // "USE16/USE32 attribute conflict - segment %s in group %s"
{2052, "'%s' : unresolved external - possible calling convention mismatch\r\n"}, // "'%s' : unresolved external - possible calling convention mismatch\r\n"
{2057, "duplicate of %s with different size found; record ignored"}, // "duplicate of %s with different size found; record ignored"
{2058, "different duplicate of %s found; record ignored"}, // "different duplicate of %s found; record ignored"
{2059, "size of data block associated with %s exceeds 4GB"}, // "size of data block associated with %s exceeds 4GB"
{2060, "size of data block associated with %s (16-bit segment) exceeds 64K"}, // "size of data block associated with %s (16-bit segment) exceeds 64K"
{2061, "no space for data block associated with %s inside %s segment"}, // "no space for data block associated with %s inside %s segment"
{2062, "continuation of COMDAT %s has conflicting attributes; record ignored"}, // "continuation of COMDAT %s has conflicting attributes; record ignored"
{2063, "%s allocated in undefined segment"}, // "%s allocated in undefined segment"
{2064, "starting address not in the root overlay"}, // "starting address not in the root overlay"
{2066, "static initialization of overlaid data not allowed"}, // "static initialization of overlaid data not allowed"
{4000, "segment displacement included near %04lX in segment %s"}, // "segment displacement included near %04lX in segment %s"
{4001, "frame-relative fixup, frame ignored near %04lX in segment %s"}, // "frame-relative fixup, frame ignored near %04lX in segment %s"
{4002, "frame-relative absolute fixup near %04lX in segment %s"}, // "frame-relative absolute fixup near %04lX in segment %s"
{4003, "intersegment self-relative fixup at %04lX in segment %s"}, // "intersegment self-relative fixup at %04lX in segment %s"
{4004, "possible fixup overflow at %lX in segment %s"}, // "possible fixup overflow at %lX in segment %s"
{4010, "invalid alignment specification"}, // "invalid alignment specification"
{4011, "/PACKC value exceeding 64K-36 unreliable"}, // "/PACKC value exceeding 64K-36 unreliable"
{4012, "/HIGH disables /EXEPACK"}, // "/HIGH disables /EXEPACK"
{4013, "%s : option ignored for segmented-executable file"}, // "%s : option ignored for segmented-executable file"
{4014, "%s : option ignored for MS-DOS executable file"}, // "%s : option ignored for MS-DOS executable file"
{4015, "/CO disables /DSALLOC"}, // "/CO disables /DSALLOC"
{4016, "/CO disables /EXEPACK"}, // "/CO disables /EXEPACK"
{4017, "/%s : unrecognized option name; option ignored"}, // "/%s : unrecognized option name; option ignored"
{4018, "missing or unrecognized application type; option %s ignored"}, // "missing or unrecognized application type; option %s ignored"
{4019, "/TINY disables /INCR"}, // "/TINY disables /INCR"
{4087, "/DYNAMIC disables /EXEPACK"}, // "/DYNAMIC disables /EXEPACK"
{4020, "%s : code-segment size exceeds 64K-36"}, // "%s : code-segment size exceeds 64K-36"
{4021, "no stack segment"}, // "no stack segment"
{4022, "%s, %s : groups overlap"}, // "%s, %s : groups overlap"
{4023, "%s(%s) : export internal name conflict"}, // "%s(%s) : export internal name conflict"
{4024, "%s : multiple definitions for export name"}, // "%s : multiple definitions for export name"
{4025, "%s.%s(%s) : import internal name conflict"}, // "%s.%s(%s) : import internal name conflict"
{4026, "%s.%s(%s) : self-imported"}, // "%s.%s(%s) : self-imported"
{4027, "%s : multiple definitions for import internal name"}, // "%s : multiple definitions for import internal name"
{4028, "%s : segment already defined"}, // "%s : segment already defined"
{4029, "%s : DGROUP segment converted to type data"}, // "%s : DGROUP segment converted to type data"
{4030, "%s : segment attributes changed to conform with\r\n  automatic data segment"}, // "%s : segment attributes changed to conform with\r\n  automatic data segment"
{4031, "%s : segment declared in more than one group"}, // "%s : segment declared in more than one group"
{4032, "%s : code-group size exceeds 64K-36"}, // "%s : code-group size exceeds 64K-36"
{4033, "first segment in mixed group %s is a USE32 segment"}, // "first segment in mixed group %s is a USE32 segment"
{4034, "more than %d overlay segments; extra put in root"}, // "more than %d overlay segments; extra put in root"
{4036, "no automatic data segment"}, // "no automatic data segment"
{4038, "program has no starting address"}, // "program has no starting address"
{4040, "stack size ignored for /TINY"}, // "stack size ignored for /TINY"
{4050, "file not suitable for /EXEPACK; relink without"}, // "file not suitable for /EXEPACK; relink without"
{4055, "start address not equal to 0x100 for /TINY"}, // "start address not equal to 0x100 for /TINY"
{4056, "/EXEPACK valid only for real-mode MS-DOS programs; ignored"}, // "/EXEPACK valid only for real-mode MS-DOS programs; ignored"
{4057, "stack specified for DLL; ignored"}, // "stack specified for DLL; ignored"
{4058, "ignoring alias for already defined symbol '%s'"}, // "ignoring alias for already defined symbol '%s'"
{4059, "far reference to overlaid segment %s changed to %s"}, // "far reference to overlaid segment %s changed to %s"
{4089, "both /STACK and STACKSIZE used; assuming %d"}, // "both /STACK and STACKSIZE used; assuming %d"
{4042, "cannot open old version"}, // "cannot open old version"
{4043, "old version not segmented executable format"}, // "old version not segmented executable format"
{4045, "name of output file is '%s'"}, // "name of output file is '%s'"
{4051, "%s : cannot find library"}, // "%s : cannot find library"
{4053, "VM.TMP : illegal file name; ignored"}, // "VM.TMP : illegal file name; ignored"
{4054, "%s : cannot find file"}, // "%s : cannot find file"
{4067, "changing default resolution for weak external '%s'\r\n	from '%s' to '%s'"}, // "changing default resolution for weak external '%s'\r\n	from '%s' to '%s'"
{4068, "ignoring stack size greater than 64K"}, // "ignoring stack size greater than 64K"
{4069, "filename truncated to '%s'"}, // "filename truncated to '%s'"
{4070, "too many public symbols for sorting"}, // "too many public symbols for sorting"
{4075, "object type conflict - assuming '%s'"}, // "object type conflict - assuming '%s'"
{4076, "no segments defined"}, // "no segments defined"
{4077, "symbol '%s' not defined; ordered allocation ignored"}, // "symbol '%s' not defined; ordered allocation ignored"
{4079, "symbol '%s' already defined for ordered allocation; duplicate ignored"}, // "symbol '%s' already defined for ordered allocation; duplicate ignored"
{4080, "changing substitute name for alias '%s'\r\n  from '%s' to '%s'"}, // "changing substitute name for alias '%s'\r\n  from '%s' to '%s'"
{4081, "cannot execute '%s %s' - %s\r\n"}, // "cannot execute '%s %s' - %s\r\n"
{4082, "changing overlay assigment for segment '%s' from %d to %d"}, // "changing overlay assigment for segment '%s' from %d to %d"
{4083, "changing overlay assigment for symbol '%s' from %d to %d"}, // "changing overlay assigment for symbol '%s' from %d to %d"
{4084, "%s : argument missing; option ignored"}, // "%s : argument missing; option ignored"
{4085, "%s : argument invalid; assuming %s"}, // "%s : argument invalid; assuming %s"
{4088, "file not suitable for /FARCALL; relink without"}, // "file not suitable for /FARCALL; relink without"
{99, "substitute symbol '%s' not found\r\n"}, // "substitute symbol '%s' not found\r\n"
{102, "Enter new file spec: "}, // "Enter new file spec: "
{103, "Change diskette in drive %c and press <ENTER>"}, // "Change diskette in drive %c and press <ENTER>"
{104, "Temporary file %s has been created."}, // "Temporary file %s has been created."
{105, "Do not change disk in drive %c:."}, // "Do not change disk in drive %c:."
{106, "Please replace original diskette in drive %c and press <ENTER>\r\n"}, // "Please replace original diskette in drive %c and press <ENTER>\r\n"
{107, "About to generate .EXE file"}, // "About to generate .EXE file"
{108, "This program cannot be run in DOS mode.\r\n$"}, // "This program cannot be run in DOS mode.\r\n$"
{109, "Valid options are:"}, // "Valid options are:"
{110, "Object Modules"}, // "Object Modules"
{111, "Run File"}, // "Run File"
{111, "Run File"}, // "Run File"
{112, "List File"}, // "List File"
{113, "Libraries"}, // "Libraries"
{114, "Definitions File"}, // "Definitions File"
{115, "\r\nThere was 1 error detected\r\n"}, // "\r\nThere was 1 error detected\r\n"
{116, "\r\nThere were %d errors detected\r\n"}, // "\r\nThere were %d errors detected\r\n"
{117, "\r\n Origin   Group\r\n"}, // "\r\n Origin   Group\r\n"
{118, "\r\n Address"}, // "\r\n Address"
{119, "Export"}, // "Export"
{120, "Alias\r\n\r\n"}, // "Alias\r\n\r\n"
{121, "\r\n  Address"}, // "\r\n  Address"
{122, "Publics by Name\r\n\r\n"}, // "Publics by Name\r\n\r\n"
{123, "Locals by Name\r\n\r\n"}, // "Locals by Name\r\n\r\n"
{124, "Publics by Value\r\n\r\n"}, // "Publics by Value\r\n\r\n"
{125, "Locals by Value\r\n\r\n"}, // "Locals by Value\r\n\r\n"
{126, "\r\n Start"}, // "\r\n Start"
{127, "Length"}, // "Length"
{128, "Name"}, // "Name"
{129, "Class\r\n"}, // "Class\r\n"
{130, "\r\n Start  Stop   Length Name"}, // "\r\n Start  Stop   Length Name"
{131, " Resident\r\n"}, // " Resident\r\n"
{132, " Overlay %XH\r\n"}, // " Overlay %XH\r\n"
{133, "\r\nProgram entry point at %04X:%04X\r\n"}, // "\r\nProgram entry point at %04X:%04X\r\n"
{  134, "  Temporary file %s has been created.\r\nDo not change disk in drive %c:."}, // "  Temporary file %s has been created.\r\nDo not change disk in drive %c:."
{135, "Usage:\r\n\r\n"}, // "Usage:\r\n\r\n"
{136, "LINK\r\nLINK @<response file>\r\n"}, // "LINK\r\nLINK @<response file>\r\n"
{137, "LINK <objs>,<exefile>,<mapfile>,<libs>,<deffile>\r\n\r\n"}, // "LINK <objs>,<exefile>,<mapfile>,<libs>,<deffile>\r\n\r\n"
{139, "This program requires Microsoft Windows.\r\n$"}, // "This program requires Microsoft Windows.\r\n$"
{140, "**** PARSING DEFINITIONS FILE ****\r\n"}, // "**** PARSING DEFINITIONS FILE ****\r\n"
{141, "**** PASS ONE ****\r\n"}, // "**** PASS ONE ****\r\n"
{142, "**** SEARCHING LIBRARIES ****\r\n"}, // "**** SEARCHING LIBRARIES ****\r\n"
{143, "**** ASSIGNING ADDRESSES ****\r\n"}, // "**** ASSIGNING ADDRESSES ****\r\n"
{144, "**** PRINTING MAP FILE ****\r\n"}, // "**** PRINTING MAP FILE ****\r\n"
{145, "**** PASS TWO ****\r\n"}, // "**** PASS TWO ****\r\n"
{146, "**** WRITING\x20"}, // "**** WRITING\x20"
{147, " - overlaid"}, // " - overlaid"
{148, " EXECUTABLE ****\r\n"}, // " EXECUTABLE ****\r\n"
{149, "**** NUMBER OF INTEROVERLAY CALLS: requested %d; generated %d ****\r\n"}, // "**** NUMBER OF INTEROVERLAY CALLS: requested %d; generated %d ****\r\n"
{150, "**** ERRORS OCCURED - NO EXECUTABLE PRODUCED ****\r\n"}, // "**** ERRORS OCCURED - NO EXECUTABLE PRODUCED ****\r\n"
{151, "Parsing Definition File"}, // "Parsing Definition File"
{152, "Pass1:\x20"}, // "Pass1:\x20"
{153, "Library Search:"}, // "Library Search:"
{154, "Pass2:\x20"}, // "Pass2:\x20"
{155, "Writing Map File"}, // "Writing Map File"
{156, "Writing Executable"}, // "Writing Executable"
{157, "Assigning Addresses"}, // "Assigning Addresses"
{300, "target external"}, // "target external"
{301, "frame segment"}, // "frame segment"
{302, "target segment"}, // "target segment"
{303, "target offset"}, // "target offset"
{304, "warning"}, // "warning"
{305, "error"}, // "error"
{306, "fatal error"}, // "fatal error"
{307, "Object file offset"}, // "Object file offset"
{308, "Record type"}, // "Record type"
{309, "in file(s)"}, // "in file(s)"
{310, "Version"}, // "Version"
{311, "All rights reserved"}, // "All rights reserved"
{312, "\r\nSegments		  %u\r\n"}, // "\r\nSegments		  %u\r\n"
{313, "Groups		      %u\r\n"}, // "Groups		      %u\r\n"
{314, "Bytes in symbol table  %ld\r\n"}, // "Bytes in symbol table  %ld\r\n"
{315, "Overlays	       %u\r\n"}, // "Overlays	       %u\r\n"
{0, NULL}
};

char * __NMSG_TEXT(
unsigned msgId
) {
        MESSAGE *pMsg = __MSGTAB;

        for (;pMsg->id; pMsg++) {
                if (pMsg->id == msgId)
                        break;
        }
        return pMsg->str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\myypars.c ===
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG                          /* RRR - 10/9/85 */
#define yyprintf(a, b, c) printf(a, b, c)
#else
#define yyprintf(a, b, c)
#endif

/*      parser for yacc output  */

YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

int NEAR yyparse(void)
   {

   short yys[YYMAXDEPTH];
   short yyj, yym;
   register YYSTYPE *yypvt;
   register short yystate, *yyps, yyn;
   register YYSTYPE *yypv;
   register short *yyxi;

   yystate = 0;
   yychar = -1;
   yynerrs = 0;
   yyerrflag = 0;
   yyps= &yys[-1];
   yypv= &yyv[-1];

yystack:    /* put a state and value onto the stack */

   yyprintf( "state %d, char 0%o\n", yystate, yychar );
   if( ++yyps> &yys[YYMAXDEPTH] )
      {
      yyerror( "yacc stack overflow" );
      return(1);
      }
   *yyps = yystate;
   ++yypv;
   *yypv = yyval;
yynewstate:

   yyn = yypact[yystate];

   if( yyn<= YYFLAG ) goto yydefault; /* simple state */

   if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
   if( (yyn += (short)yychar)<0 || yyn >= YYLAST ) goto yydefault;

   if( yychk[ yyn=yyact[ yyn ] ] == yychar )
      {
      /* valid shift */
      yychar = -1;
      yyval = yylval;
      yystate = yyn;
      if( yyerrflag > 0 ) --yyerrflag;
      goto yystack;
      }
yydefault:
   /* default state action */

   if( (yyn=yydef[yystate]) == -2 )
      {
      if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
      /* look through exception table */

      for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

      for(yyxi+=2; *yyxi >= 0; yyxi+=2)
         {
         if( *yyxi == yychar ) break;
         }
      if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
      }

   if( yyn == 0 )
      {
      /* error */
      /* error ... attempt to resume parsing */

      switch( yyerrflag )
         {

      case 0:   /* brand new error */

         yyerror( "syntax error" );
         ++yynerrs;

      case 1:
      case 2: /* incompletely recovered error ... try again */

         yyerrflag = 3;

         /* find a state where "error" is a legal shift action */

         while ( yyps >= yys )
            {
            yyn = yypact[*yyps] + YYERRCODE;
            if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE )
               {
               yystate = yyact[yyn];  /* simulate a shift of "error" */
               goto yystack;
               }
            yyn = yypact[*yyps];

            /* the current yyps has no shift onn "error", pop stack */

            yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
            --yyps;
            --yypv;
            }

         /* there is no state on the stack with an error shift ... abort */

yyabort:
         return(1);


      case 3:  /* no shift yet; clobber input char */
         yyprintf( "error recovery discards char %d\n", yychar, 0 );

         if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
         yychar = -1;
         goto yynewstate;   /* try again in the same state */

         }

      }

   /* reduction by production yyn */

   yyprintf("reduce %d\n",yyn, 0);
   yyps -= yyr2[yyn];
   yypvt = yypv;
   yypv -= yyr2[yyn];
   yyval = yypv[1];
   yym=yyn;
   /* consult goto table to find next state */
   yyn = yyr1[yyn];
   yyj = yypgo[yyn] + *yyps + 1;
   if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
   switch(yym)
      {
      $A
      }
   goto yystack;  /* stack new state and value */

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newadr.c ===
/* SCCSID = %W% %E% */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWADR.C                            *
    *                                                               *
    *   Common address-assignment routines.                         *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Reloc. type definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External function declarations */

/*
 *  FUNCTION PROTOTYPES
 */


LOCAL void      FixSymRa(APROPNAMEPTR papropName,
                         RBTYPE rhte,
                         RBTYPE rprop,
                         WORD   fNewHte);
LOCAL void      AllocateCommon(APROPNAMEPTR papropName,
                               RBTYPE rhte,
                               RBTYPE rprop,
                               WORD  fNewHte);
#if OSEGEXE AND SYMDEB AND NOT EXE386
LOCAL void      GenImports(APROPNAMEPTR papropName,
                           RBTYPE rhte,
                           RBTYPE rprop,
                           FTYPE  fNewHte);
#endif
LOCAL void NEAR AssignClasses(unsigned short (NEAR *ffun)(APROPSNPTR prop));
LOCAL WORD NEAR IsNotAbs(APROPSNPTR apropSn);
LOCAL WORD NEAR IsCode(APROPSNPTR prop);
LOCAL WORD NEAR IsNotDGroup(APROPSNPTR prop);
LOCAL WORD NEAR IsBegdata(APROPSNPTR prop);
LOCAL WORD NEAR IsNotBssStack(APROPSNPTR prop);
LOCAL WORD NEAR IsNotStack(APROPSNPTR prop);


#if QBLIB
extern RBTYPE           rhteFarData;    /* "FARDATA" class name */
extern RBTYPE           rhteFarBss;     /* "FARBSS" class name */
extern SEGTYPE          segFD1st, segFDLast;
extern SEGTYPE          segFB1st, segFBLast;
#endif

#define IsAbsTysn(tysn) ((tysn & ~(BIGBIT | CODE386BIT)) == TYSNABS)

SNTYPE                  gsnText;        /* Global SEGDEF for _TEXT */

/* Local variables */
LOCAL long              cbCommon;       /* Count of bytes in COMMON */
LOCAL long              cbFar;          /* Count of bytes in far common */
LOCAL GRTYPE            ggrCommon;      /* Global group no. for common */
LOCAL SNTYPE            gsnCommon;      /* Global SEGDEF for common */
LOCAL SNTYPE            gsnFar;         /* Far common SEGDEF number */
LOCAL FTYPE             fNoEdata = (FTYPE) TRUE;
LOCAL FTYPE             fNoEnd   = (FTYPE) TRUE;


#if SYMDEB
LOCAL int NEAR          IsDebug(APROPSNPTR propSn);

    /************************************************************
    *                                                           *
    *  Returns true if segment definition record is a debug     *
    *  segment:  private and a recognized class.                *
    *                                                           *
    ************************************************************/

LOCAL int NEAR          IsDebug(APROPSNPTR propSn)
{
    return (fSymdeb && propSn->as_attr == ATTRLSN &&
        (propSn->as_rCla == rhteDebTyp ||
        propSn->as_rCla == rhteDebSym || propSn->as_rCla == rhteDebSrc));
}
#else
#define IsDebug(a)      FALSE
#endif

AHTEPTR                 GetHte(rprop)   /* Get hash table entry */
RBTYPE                  rprop;          /* Property cell address */
{
    REGISTER AHTEPTR    ahte;           /* Hash table entry pointer */

    ahte = (AHTEPTR ) FetchSym(rprop,FALSE);
                                        /* Fetch property cell */
    /* While not at hash table entry, get next cell in chain */
    while(ahte->attr != ATTRNIL)
        ahte = (AHTEPTR ) FetchSym(ahte->rhteNext,FALSE);
    return(ahte);                       /* Return ptr to hash table entry */
}


    /****************************************************************
    *                                                               *
    *  FixSymRa:                                                    *
    *                                                               *
    *  Fix symbol offset.   Called by EnSyms.                       *
    *                                                               *
    ****************************************************************/

LOCAL void              FixSymRa (papropName,rhte,rprop,fNewHte)
APROPNAMEPTR            papropName;     /* Symbol property cell */
RBTYPE                  rhte;           /* Hash table virt address */
RBTYPE                  rprop;          /* Symbol virt address */
WORD                    fNewHte;
{
    SNTYPE              gsn;
#if O68K
    SATYPE              sa;
#endif /* O68K */

    if(!(gsn = papropName->an_gsn)) return;
    papropName->an_ra += mpgsndra[gsn];

#if O68K
    if (iMacType != MAC_NONE && IsDataFlg(mpsaflags[sa =
      mpsegsa[mpgsnseg[gsn]]]))
        papropName->an_ra += mpsadraDP[sa];
#endif /* O68K */

    MARKVP();
}

    /****************************************************************
    *                                                               *
    *  GenSeg:                                                      *
    *                                                               *
    *  Generate a segment definition.                               *
    *                                                               *
    ****************************************************************/

#if EXE386
APROPSNPTR              GenSeg(sbName,sbClass,ggr,fPublic)
#else
APROPSNPTR NEAR         GenSeg(sbName,sbClass,ggr,fPublic)
#endif
BYTE                    *sbName;        /* Segment name */
BYTE                    *sbClass;       /* Class name */
GRTYPE                  ggr;            /* Global GRPDEF number */
WORD                    fPublic;        /* True if public segment */
{
    APROPSNPTR          apropSn;        /* Pointer to SEGDEF */
    RBTYPE              rhteClass;      /* Class name virt addr */

    PropSymLookup(sbClass, ATTRNIL, TRUE);/* Insert class name in hash table */
    rhteClass = vrhte;                  /* Save class name virt addr */
    if(fPublic)                         /* If public segment */
    {
        apropSn = (APROPSNPTR ) PropSymLookup(sbName, ATTRPSN, TRUE);
                                        /* Create segment */
        if(!vfCreated) return(apropSn); /* If it existed, return pointer */
#if EXE386
        apropSn->as_tysn = DWORDPUBSEG; /* Segment is public */
#else
        apropSn->as_tysn = PARAPUBSEG;  /* Segment is public */
#endif
    }
    else                                /* Else if private segment */
    {
        PropSymLookup(sbName, ATTRNIL, TRUE);
                                        /* Look up name */
        apropSn = (APROPSNPTR ) PropAdd(vrhte,ATTRLSN);
                                        /* Segment is local */
#if EXE386
        apropSn->as_tysn = DWORDPRVSEG; /* Segment is private */
#else
        apropSn->as_tysn = PARAPRVSEG;  /* Segment is private */
#endif
    }
    if(gsnMac >= gsnMax) Fatal(ER_segmax);
                                        /* Check for table overflow */
    apropSn->as_rCla = rhteClass;       /* Save segment's class */
    mpgsnrprop[gsnMac] = vrprop;        /* Save property cell address */
    apropSn->as_gsn = gsnMac++;         /* Give it a global SEGDEF number */
    apropSn->as_ggr = ggr;              /* Give specified group association */
    return(apropSn);                    /* Return global SEGDEF */
}


#if FALSE AND OSEGEXE AND SYMDEB AND NOT EXE386
/* Postponed CV not ready yet */

/*** GenImports - fill in $$IMPORTS segment for CV
*
* Purpose:
*   Build $$IMPORTS segment for CV. This segment enables symbolic information
*   in CV for dyncalls.  The $$IMPORTS segment contains sequence of entries
*   in the following format:
*
*             16-bit   16-bit        32-bit
*           +--------+--------+-----------------+
*           | iMod   | iName  | far address     |
*           +--------+--------+-----------------+
*
*   Where:
*           - iMod      - index to Module Reference Table in .EXE
*           - iName     - index to Imported Names Table in .EXE (32-bit for 386)
*           - address   - import's address fixed up by loader
*
* Input:
*   This function is called by EnSyms, so it takes standard set of arguments.
*   papropName          - pointer to import property cell
*   rprop               - virtual address of property cell
*   rhte                - virt address of hash table entry
*   fNewHte             - TRUE if name has been written
*
* Output:
*   No explicit value is returned. Segment data is created and run-time
*   fiuxps.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL void              GenImports(papropName,rhte,rprop,fNewHte)
APROPNAMEPTR            papropName;
RBTYPE                  rhte;
RBTYPE                  rprop;
FTYPE                   fNewHte;
{
    static WORD         raImpSeg = 0;
    APROPIMPPTR         lpImport;
    APROPNAMEPTR        lpPublic;
    CVIMP               cvImp;
    RELOCATION          r;              /* Relocation item */


    lpImport = (APROPIMPPTR) papropName;
    if (lpImport->am_mod)
        return;                         /* Skip module name */

    /* Build CV import descriptor and save it in $$IMPORTS segment */

    cvImp.iName = lpImport->am_offset;  /* Save index to Imported Name Table */
    cvImp.address = (char far *) 0L;
    lpPublic = (APROPNAMEPTR) FetchSym((RBTYPE)lpImport->am_public, FALSE);
    cvImp.iMod = lpPublic->an_module;   /* Save index to Module Reference Table */
    vgsnCur = gsnImports;
    MoveToVm(sizeof(CVIMP), (BYTE *) &cvImp, mpgsnseg[gsnImports], raImpSeg);

    /* Emit run-time fixup for import, so loader will fill in addrss field */

#if EXE386
    R32_SOFF(r) = (WORD) ((raImpSeg + 6) % OBJPAGELEN);
#else
    NR_SOFF(r) = (WORD) raImpSeg + 4;
#endif
    NR_STYPE(r) = (BYTE) NRSPTR;        /* Save fixup type - 16:16 pointer */
    NR_FLAGS(r) = (lpPublic->an_flags & FIMPORD) ? NRRORD : NRRNAM;
#if EXE386
    R32_MODORD(r) = lpPublic->an_module;/* Get module specification */
    if (NR_FLAGS(r) & NRRNAM)           /* Get entry specification */
    {
        if (cbImports < LXIVK)
            R32_PROCOFF16(r) = (WORD) lpPublic->an_entry;
                                        /* 16-bit offset */
        else
        {                               /* 32-bit offset */
            R32_PROCOFF32(r) = lpPublic->an_entry;
            NR_FLAGS(r) |= NR32BITOFF;
        }
    }
    else
        R32_PROCORD(r) = (WORD) lpPublic->an_entry;
    SaveFixup(mpsegsa[mpgsnseg[gsnImports]], ((raImpSeg + 6) >> pageAlign) + 1, &r);
#else
    NR_MOD(r) = lpPublic->an_module;    /* Get module specification */
    NR_PROC(r) = lpPublic->an_entry;    /* Get entry specification */
    SaveFixup(mpsegsa[mpgsnseg[gsnImports]],&r);
#endif
    raImpSeg += sizeof(CVIMP);
}
#endif


    /****************************************************************
    *                                                               *
    *  AllocateCommon:                                              *
    *                                                               *
    *  Allocate space for C common variables.  Called by EnSyms.    *
    *                                                               *
    ****************************************************************/
LOCAL void              AllocateCommon(papropName,rhte,rprop,fNewHte)
APROPNAMEPTR            papropName;
RBTYPE                  rhte;
RBTYPE                  rprop;
WORD                    fNewHte;
{
    APROPUNDEFPTR       papropUndef;    /* Pointer to undefined symbol */
    APROPSNPTR          apropSn;        /* SEGDEF pointer */
    long                len;            /* Length of common variable */
    WORD                cbElem;         /* Bytes per element */
    long                cbSeg;          /* Number of bytes per segment */


    papropUndef = (APROPUNDEFPTR ) papropName;
                                        /* Recast pointer */
    if (papropUndef->au_flags & COMMUNAL)/* If symbol is defined common */
    {
        len = papropUndef->au_len;      /* Get object's length */
        cbElem = papropUndef->au_cbEl;  /* Get number of bytes per element */
        papropName->an_attr = ATTRPNM;  /* Give it the public attribute */
        papropName->an_flags = FPRINT;  /* Symbol is printable */
#if ILINK
        papropName->an_module = 0;      /* Special "module" for communals */
#endif
        MARKVP();                       /* Mark virtual page as dirty */
        ++pubMac;                       /* Increment count of public symbols */
        if(!cbElem)                     /* If near variable */
        {
#if OMF386
            if (f386)                   /* DWORD-align objects >= len 4 */
            {
                if(len >= 4 && cbCommon + 3 > cbCommon)
                    cbCommon = (cbCommon + 3) & ~3L;
            }
            else
#endif
            if(!(len & 1)) cbCommon = (cbCommon + 1) & ~1L;
                                        /* Word-align even-lengthed objects */
            papropName->an_ra = (RATYPE) cbCommon;
                                        /* Assign an offset */
            papropName->an_gsn = gsnCommon;
                                        /* Assign to c_common segment */
            papropName->an_ggr = ggrCommon;
                                        /* Set up group association */
#if OMF386
            if(f386)
            {
                if(cbCommon + len < cbCommon) Fatal(ER_32comarea);
                else cbCommon += len;
            } else
#endif
            if((cbCommon += len) > LXIVK) Fatal(ER_comarea);
                                        /* Fatal if too much common */
        }
        else if ((len *= cbElem) < LXIVK)
        {                               /* Else if object not "huge" */
            if (cbFar + len > LXIVK)    /* If new segment needed */
            {
                if (gsnFar != SNNIL)    /* If there is an "old" segment */
                {
                    apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnFar],TRUE);
                                        /* Get old SEGDEF */
                    apropSn->as_cbMx = cbFar;
                                        /* Save old length */
                }
                apropSn = GenSeg((BYTE *) "\007FAR_BSS",
                                 (BYTE *) "\007FAR_BSS", GRNIL, FALSE);
                                        /* Generate one */
                apropSn->as_flags = dfData;
                                        /* Use default data flags */
#if EXE386
                apropSn->as_flags &= ~OBJ_INITDATA;
                                        // Clear initialized data bit
                apropSn->as_flags |= OBJ_UNINITDATA;
                                        // Set uninitialized data bit
#endif
#if O68K
                if(f68k)
                    apropSn->as_flags |= NS32BIT;
                                        // 32-bit data
#endif
                gsnFar = apropSn->as_gsn;
                                        /* Get global SEGDEF number */
                cbFar = 0L;             /* Initialize size */
                papropName = (APROPNAMEPTR ) FetchSym(rprop,TRUE);
                                        /* Refetch */
            }
            if (!(len & 1))
                cbFar = (cbFar + 1) & ~1L;
                                        /* Word-align even-lengthed objects */
            papropName->an_ra = (RATYPE) cbFar;
                                        /* Assign an offset */
            papropName->an_gsn = gsnFar;/* Assign to far segment */
            papropName->an_ggr = GRNIL; /* No group association */
            cbFar += len;               /* Update length */
        }
        else                            /* Else if "huge" object */
        {
            cbSeg = (LXIVK / cbElem)*cbElem;
                                        /* Calculate bytes per seg */
            papropName->an_ra = LXIVK - cbSeg;
                                        /* Assign offset so last element in
                                           first seg. not split */
            papropName->an_gsn = gsnMac;/* Assign to segment */
            papropName->an_ggr = GRNIL; /* No group association */
            while(len)                  /* While bytes remain */
            {
                if(cbSeg > len) cbSeg = len;
                                        /* Clamp segment length to len */
                apropSn = GenSeg((BYTE *) "\010HUGE_BSS",
                                 (BYTE *) "\010HUGE_BSS",GRNIL,FALSE);
                                        /* Create segment */
                apropSn->as_cbMx = len > LXIVK ? LXIVK : len;
                                        /* Set segment size */
                apropSn->as_flags = dfData;
                                        /* Use default data flags */
#if EXE386
                apropSn->as_flags &= ~OBJ_INITDATA;
                                        // Clear initialized data bit
                apropSn->as_flags |= OBJ_UNINITDATA;
                                        // Set uninitialized data bit
#endif
#if O68K
                if(f68k)
                    apropSn->as_flags |= NS32BIT;
                                        // 32-bit data
#endif
                len -= cbSeg;           /* Decrement length */
            }
        }
    }
}

    /****************************************************************
    *                                                               *
    *  AssignClasses:                                               *
    *                                                               *
    *  Assign  the ordering  of all segments  in all classes  that  *
    *  pass the given test function.                                *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         AssignClasses(WORD (NEAR *ffun)(APROPSNPTR prop))
{
    REGISTER SNTYPE     gsn;            /* Index */
    REGISTER APROPSNPTR apropSn;        /* Segment definition pointer */
    SNTYPE              gsnFirst;       /* Index of first segment in class */
    RBTYPE              rhteClass;      /* Class name */

    for(gsnFirst = 1; gsnFirst < gsnMac; ++gsnFirst)
    {                                   /* Loop through the segments */
        rhteClass = RHTENIL;            /* Initialize */
        for(gsn = gsnFirst; gsn < gsnMac; ++gsn)
        {                               /* Loop to examine segment records */
            if(mpgsnseg[gsn] != SEGNIL) continue;
                                        /* Skip assigned segments */
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
                                        /* Fetch SEGDEF from virt. mem. */
            if(rhteClass == RHTENIL) rhteClass = apropSn->as_rCla;
                                        /* Get class if we don't have one */
            if(apropSn->as_rCla == rhteClass &&
              (ffun == ((WORD (NEAR *)(APROPSNPTR)) 0) || (*ffun)(apropSn)))
            {                           /* If class member found */
                mpgsnseg[gsn] = ++segLast;
                                        /* Save ordering number */
#if QBLIB
                if(fQlib)
                {
                    if(rhteClass == rhteFarData && segFD1st == SEGNIL)
                        segFD1st = segLast;
                    else if(rhteClass == rhteFarBss && segFB1st == SEGNIL)
                        segFB1st = segLast;
                }
#endif
                mpseggsn[segLast] = gsn;// Map the other way
                if(IsCodeFlg(apropSn->as_flags))
                {
#if OSEGEXE AND ODOS3EXE
                    /* Set FCODE here for 3.x segments.  FNOTEMPTY later */
                    if(!fNewExe)
                        mpsegFlags[segLast] = FCODE;
#endif
                    segCodeLast = segLast;
                                        /* Remember last code segment */
                }
                else if(IsDataFlg(apropSn->as_flags))
                    segDataLast = segLast;
                                        /* Remember last data segment */
#if NOT OSEGEXE
                mpsegFlags[segLast] = apropSn->as_flags;
#endif
            }
        }
#if QBLIB
        if(fQlib)
        {
            if(rhteClass == rhteFarData && segFD1st != SEGNIL)
                segFDLast = segLast;
            else if(rhteClass == rhteFarBss && segFB1st != SEGNIL)
                segFBLast = segLast;
        }
#endif
    }
}

#if OEXE
    /****************************************************************
    *                                                               *
    *  MkPubSym:                                                    *
    *                                                               *
    *  Adds a  public  symbol  record  with  the  given parameters  *
    *  to the symbol table.  Used for things like "$$MAIN".         *
    *                                                               *
    ****************************************************************/

void                    MkPubSym(sb,ggr,gsn,ra)
BYTE                    *sb;            /* Length-prefixed symbol name */
GRTYPE                  ggr;            /* Global GRPDEF number */
SNTYPE                  gsn;            /* Global SEGDEF number */
RATYPE                  ra;             /* Segment offset */
{
    APROPNAMEPTR        apropName;      /* Public name pointer */

    if(PropSymLookup(sb,ATTRPNM,FALSE) != PROPNIL)
    {                                   /* If symbol already defined */
        OutError(ER_pubdup,sb + 1);
        return;                         /* And return */
    }
    /* If not undefined, create as public */
    if((apropName = (APROPNAMEPTR )
      PropSymLookup(sb,ATTRUND,FALSE)) == PROPNIL)
        apropName = (APROPNAMEPTR ) PropSymLookup(sb,ATTRPNM,TRUE);
    apropName->an_attr = ATTRPNM;       /* Public symbol */
    apropName->an_gsn = gsn;            /* Save segment definition number */
    apropName->an_ra = ra;              /* Starts at 4th byte of segment */
    apropName->an_ggr = ggr;            /* Save group definition number */
    ++pubMac;                           /* Increment public count */
    apropName->an_flags = FPRINT;       /* Public is printable */
    MARKVP();                           /* Page has changed */
#if SYMDEB
    if (fSymdeb)                        /* If ISLAND support on */
        DebPublic(vrprop, PUBDEF);
                                        /* Make a PUBLICS entry */
#endif
#if ILINK
    if (fIncremental)
        apropName->an_module = imodFile;
#endif
}
#endif /* OEXE */

LOCAL WORD NEAR         IsNotAbs(apropSn)
APROPSNPTR              apropSn;        /* Pointer to segment record */
{
    return(!IsDebug(apropSn) && !IsAbsTysn(apropSn->as_tysn));
                                        /* Return true if not absolute segment */
}

#if EXE386
LOCAL WORD NEAR         IsImportData(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_gsn == gsnImport);  /* Return true if import data segment */
}
#endif

LOCAL WORD NEAR         IsCode(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(IsCodeFlg(prop->as_flags) && !IsAbsTysn(prop->as_tysn));
                                        /* Return true if code segment */
}

#if OEXE
LOCAL WORD NEAR         IsNotDGroup(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_ggr != ggrDGroup && !IsDebug(prop) &&
            !IsAbsTysn(prop->as_tysn));
                                        /* True if segment not in DGROUP */
}

LOCAL WORD NEAR         IsBegdata(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_rCla == rhteBegdata && !IsAbsTysn(prop->as_tysn));
                                        /* True if segment class BEGDATA */
}

LOCAL WORD NEAR         IsNotBssStack(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_rCla != rhteBss && prop->as_rCla != rhteStack &&
      !IsDebug(prop) && !IsAbsTysn(prop->as_tysn));
                                        /* True if neither BSS nor STACK */
}

LOCAL WORD NEAR         IsNotStack(prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_rCla != rhteStack && !IsDebug(prop) &&
        !IsAbsTysn(prop->as_tysn));     /* True if not class STACK */
}
#endif /* OEXE */

#if INMEM
WORD                    saExe = FALSE;

void                    SetInMem ()
{
    WORD                cparExe;
    WORD                cparSave;

    if(fOverlays || fSymdeb)
        return;
    cparExe = mpsegsa[segLast] +
        ((mpsegraFirst[segLast] + mpsegcb[segLast] + 0xf) >> 4);
    cparSave = cparExe;
    if(!(saExe = Dos3AllocMem(&cparExe)))
        return;
    if(cparExe != cparSave)
    {
        Dos3FreeMem(saExe);
        saExe = 0;
        return;
    }
    Dos3ClrMem(saExe,cparExe);
}
#endif /* INMEM */

    /****************************************************************
    *                                                               *
    *  AssignAddresses:                                             *
    *                                                               *
    *  This  function  scans  the  set  of  segments, given  their  *
    *  ordering, and assigns segment registers and addresses.       *
    *                                                               *
    ****************************************************************/

void NEAR               AssignAddresses()
{
    APROPSNPTR          apropSn;        /* Ptr to a segment record */
#if FDEBUG
    SNTYPE              gsn;            /* Current global segment number */
    long                dbsize;         /* Length of segment */
    RBTYPE              rbClass;        /* Pointer to segment class */
#endif
    BSTYPE              bsTmp;
#if QBLIB
    SNTYPE              gsnQbSym;       /* gsn of SYMBOL segment for .QLB */
#endif
#if OSEGEXE
    extern FTYPE        fNoNulls;       /* True if not inserting 16 nulls */
#else
#define fNoNulls        FALSE
#endif


    // Set up stack allocation

    if (gsnStack != SNNIL)              /* If stack segment exists */
    {
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnStack],TRUE);
                                        /* Fetch segment definition */
#if OEXE
        apropSn->as_tysn = (BYTE) ((apropSn->as_tysn & 0x1F) | (ALGNPAR << 5));
                                        /* Force paragraph alignment */
#if EXE386
        if (!cbStack)
            cbStack = apropSn->as_cbMx;
        cbStack = (cbStack + 3) & ~3;   /* Must be even number of bytes */
        apropSn->as_cbMx = cbStack;
#else
        if (!cbStack)
            cbStack = (WORD) apropSn->as_cbMx;
        cbStack = (cbStack + 1) & ~1;   /* Must be even number of bytes */
        apropSn->as_cbMx = (DWORD) cbStack;
#endif                                  /* Save size of stack segment */
#else
        /* Force size to 0  for Xenix executables */
        apropSn->as_cbMx = 0L;
#endif
    }
#if OEXE
#if OSEGEXE
    else if(cbStack == 0 &&
#if O68K
            iMacType == MAC_NONE &&
#endif
#if EXE386
            IsAPLIPROG(vFlags))
#else
            !(vFlags & NENOTP) && !fBinary)
#endif
#else
    else if(cbStack == 0 && !fBinary)
#endif
    {                                   /* Else if no stack and not library */
#if 0
        /* Issue warning message */
        if(fLstFileOpen && bsLst != stderr)
        {
            bsTmp = bsErr;
            bsErr = bsLst;
            OutWarn(ER_nostack);
            bsErr = bsTmp;
        }
        OutWarn(ER_nostack);
#endif
    }
#endif
    if(fCommon)                         /* If there are communal variables */
    {
        apropSn = GenSeg((BYTE *) "\010c_common",
                         (BYTE *) "\003BSS",ggrDGroup,TRUE);
                                        /* Generate communal variable seg */
        if(vfCreated) apropSn->as_flags = dfData;
                                        /* Use default data flags */
        gsnCommon = apropSn->as_gsn;    /* Save common segment number */
        ggrCommon = apropSn->as_ggr;    /* Save common group number */
        cbCommon = apropSn->as_cbMx;    /* Initialize size of common */
        gsnFar = SNNIL;                 /* No far BSS yet */
#if NOT EXE386
#if OMF386
        if(f386)
        {
            cbFar = ~0L;
            apropSn->as_flags |= FCODE386;
        }
        else
#endif
#if O68K
        if(f68k)
        {
            cbFar = LXIVK + 1;          /* Force creation of far BSS segment */
            apropSn->as_flags |= NS32BIT;
        }
        else
#endif
#endif
            cbFar = LXIVK + 1;          /* Force creation of far BSS segment */
        DEBUGVALUE(cbCommon);           /* Debug info */
        EnSyms(AllocateCommon,ATTRUND);
                                        /* Assign common variables */
                                        /* Don't use SmallEnEnsyms - symbol */
                                        /* table may grow while in EnSyms */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnCommon],TRUE);
        apropSn->as_cbMx = cbCommon;    /* Save segment size */
        if(gsnFar != SNNIL)             /* If far BSS created */
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnFar],TRUE);
            apropSn->as_cbMx = cbFar;   /* Save segment size */
        }
    }
#if FALSE AND OSEGEXE AND SYMDEB AND NOT EXE386
    if (fSymdeb && fNewExe && cImpMods)
    {
        apropSn = GenSeg("\011$$IMPORTS", "\010FAR_DATA", GRNIL, FALSE);
                                        /* Support for dyncalls for CV */
        gsnImports = apropSn->as_gsn;
        apropSn->as_flags = dfData;     /* Use default data flags */
        apropSn->as_cbMx = cbImpSeg;    /* Save segment size */
    }
#endif
#if EXE386
    GenImportTable();
#endif

    /* Initialize segment-based tables for pass 2 */

    InitP2Tabs();
#if OVERLAYS
    if(fOverlays) SetupOverlays();
#endif
#if OEXE
    /*
     * If /DOSSEG is enabled and /NONULLSDOSSEG is not enabled, look for
     * segment _TEXT.  If found, increase size by 16 in preparation for
     * reserving first 16 addresses for the sake of signal().
     */
    if(fSegOrder && !fNoNulls)
    {
        apropSn = (APROPSNPTR ) PropSymLookup((BYTE *) "\005_TEXT",ATTRPSN,FALSE);
                                        /* Look for public segment _TEXT */
        if(apropSn != PROPNIL)          /* If it exists */
        {
            gsnText = apropSn->as_gsn;  /* Save the segment index */
            if ((apropSn->as_tysn)>>5 == ALGNPAG)
                NullDelta = 256;
#if EXE386
            if (apropSn->as_cbMx > CBMAXSEG32 - NullDelta)
                Fatal(ER_txtmax);
            else
                apropSn->as_cbMx += NullDelta;
#else
            if((apropSn->as_cbMx += NullDelta) > LXIVK)
                Fatal(ER_txtmax);
#endif
            fTextMoved = TRUE;
                                        /* Bump the size up */
            MARKVP();                   /* Page has changed */
        }
    }
#endif
#if FDEBUG
    if(fDebug && fLstFileOpen)          /* If debugging on */
    {
        /* Dump segments and lengths */
        for(gsn = 1; gsn < gsnMac; ++gsn)
        {
            apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],FALSE);
            dbsize = apropSn->as_cbMx;
            rbClass = apropSn->as_rCla;
            FmtPrint("%3d segment \"%s\"",gsn,1 + GetPropName(apropSn));
            FmtPrint(" class \"%s\" length %lxH bytes\r\n",
                        1 + GetPropName(FetchSym(rbClass,FALSE)),dbsize);
        }
    }
#endif
#if OSEGEXE
    if (gsnAppLoader)
    {
        // Make sure that aplication loder gets its own segment

        mpgsnseg[gsnAppLoader] = ++segLast;
        mpseggsn[segLast] = gsnAppLoader;
    }
#endif
#if OEXE
    if (fSegOrder)                      /* If forcing segment ordering */
    {
        AssignClasses(IsCode);          /* Code first,... */
#if EXE386
        AssignClasses(IsImportData);    /* ...then import data */
#endif
        AssignClasses(IsNotDGroup);     /* ...then non-DGROUP,... */
        AssignClasses(IsBegdata);       /* ...then class BEGDATA,... */
        AssignClasses(IsNotBssStack);   /* ...then all but BSS and STACK,... */
        AssignClasses(IsNotStack);      /* ...then all but class STACK */
    }
#endif
#if OXOUT OR OIAPX286
    if(fIandD)                          /* If separate code and data */
        AssignClasses(IsCode);          /* Assign ordering to code */
#endif
    AssignClasses(IsNotAbs);            /* Assign order to segments */
#if QBLIB
    /* If building QB userlib, generate the symbol segment last */
    if(fQlib)
    {
        gsnQbSym = GenSeg("\006SYMBOL", "", GRNIL, FALSE)->as_gsn;
        mpgsnseg[gsnQbSym] = ++segLast;
    }
#endif
#if NOT EXE386
    if (fBinary && cbStack && mpgsnseg[gsnStack] == 1)
    {
        /*
         * In .COM file first segment is a stack and it has non zero
         * size. We warn user about making his stack segment size
         * equal zero.
         */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnStack],TRUE);
        apropSn->as_cbMx = 0L;
        OutWarn(ER_stksize);

    }
#endif

    /* Assign addresses according to which format exe is being produced */

#if OIAPX286
    AssignXenAddr();
#endif

#if OSEGEXE AND ODOS3EXE

    if (fNewExe)
        AssignSegAddr();
    else
        AssignDos3Addr();

#else

#if OSEGEXE
    AssignSegAddr();
#endif

#if ODOS3EXE
    AssignDos3Addr();
#endif

#endif

    // Remember index for first debug segment

    segDebFirst = segLast +
#if ODOS3EXE
                  csegsAbs +
#endif
                  (SEGTYPE) 1;
#if OEXE

    // If /DOSSEG enabled and segment _TEXT found, initialize offset
    // of _TEXT to 16 to reserve addresses 0-15. WARNING: gsnText must
    // be initialized to SNNIL.

    if (gsnText != SNNIL)
    {
        mpgsndra[gsnText] += NullDelta;

        // If no program starting address, initialize it to 0:NullDelta

        if (segStart == SEGNIL && !raStart && !mpsegsa[mpgsnseg[gsnText]])
            raStart = NullDelta;

        // If /DOSSEG enabled and segment _TEXT found, initialize offset
        // of _TEXT to NulDelta to reserve addresses 0-NullDelta-1.
        // This was done after the COMDAT's were allocated so the offsets
        // of COMDAT's allocated in _TEXT segment are off by NullDelta bytes.
        // Here we adjust them, so the data block associated with COMDAT
        // is placed in the right spot in the memory image.  The matching
        // public symbol will be shifted by the call to EnSyms(FixSymRa, ATTRPNM).

        FixComdatRa();
    }
#endif
    EnSyms(FixSymRa, ATTRPNM);
#if LOCALSYMS
    if (fLocals)
        EnSyms(FixSymRa, ATTRLNM);
#endif
#if INMEM
    SetInMem();
#endif

    // Allocate memory blocks for the final program's memory image

    if (fNewExe)
    {
        // Segmented-executable

        mpsaMem = (BYTE FAR * FAR *) GetMem(saMac * sizeof(BYTE FAR *));
    }
    else
    {
        // DOS executable

        mpsegMem = (BYTE FAR * FAR *) GetMem((segLast + 1) * sizeof(BYTE FAR *));
    }

#if OVERLAYS
    if (fOverlays && gsnOvlData != SNNIL)
        FixOvlData();                    // Initialize overlay data tables
#endif
#if QBLIB
    if(fQlib) BldQbSymbols(gsnQbSym);   /* Build QB SYMBOL segment */
#endif
}



/*** Define_edata_end - define special C run-time symbols
*
* Purpose:
*   Define special symbols _edata and _end used by the C run-time.
*   These symbols are defined as follows:
*
*       The DGROUP layout
*
*           +------------+
*           |            |
*           |            |
*           |            |
*           | Near Heap  |
*           |            |
*           |            |
*           +------------+
*           |            |
*           |            |
*           |  STACK     |
*           |            |
*           |            |
*           +------------+ <-- _end
*           |            |
*           |  _BSS      |
*           |            |
*           +------------+ <-- _edata
*           |            |
*           |  _CONST    |
*           |            |
*           +------------+
*           |            |
*           |  _DATA     |
*           |            |
*           +------------+
*
* Input:
*   papropSn    - pointer to segment descriptor
*
* Output:
*   None.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


void NEAR               Define_edata_end(APROPSNPTR papropSn)
{
    APROPNAMEPTR        apropName;      // Public name pointer
    SNTYPE              gsn;            // Global segment number


    // Symbols were defined by SwDosseg(), now adjust addresses.

    if (papropSn->as_tysn != TYSNABS && papropSn->as_ggr == ggrDGroup)
    {
        // This is not absolute segment and it belong to DGROUP

        gsn = papropSn->as_gsn;
        if (fNoEdata && papropSn->as_rCla == rhteBss)
        {
            fNoEdata = FALSE;
            apropName = (APROPNAMEPTR )
                        PropSymLookup((BYTE *) "\006_edata",ATTRPNM,FALSE);
                                        // Fetch symbol
            apropName->an_gsn = gsn;    // Save segment definition number
            apropName->an_ggr = ggrDGroup;
                                        // Save group definition number
            MARKVP();                   // Page has changed
        }
        else if (fNoEnd && papropSn->as_rCla == rhteStack)
        {
            fNoEnd = FALSE;
            apropName = (APROPNAMEPTR )
                        PropSymLookup((BYTE *) "\004_end",ATTRPNM,FALSE);
                                        // Fetch symbol
            apropName->an_gsn = gsn;    // Save segment definition number
            apropName->an_ggr = ggrDGroup;
                                        // Save group definition number
            MARKVP();                   // Page has changed
        }
    }
}



/*** Check_edata_end - check the definiton of special C run-time symbols
*
* Purpose:
*   Check the definition of special symbols _edata and _end used
*   by the C run-time.
*
* Input:
*   None.
*
* Output:
*   None.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


void NEAR               Check_edata_end(SNTYPE gsnTop, SEGTYPE segTop)
{
    APROPNAMEPTR        apropName;      // Public name pointer
    APROPNAMEPTR        apropName1;     // Public name pointer


    // Check if both symbols are defined properly

    if (fNoEdata)
    {
        // No class 'BSS' segment defined;
        // make _edata point to end of 'DATA' segments

        apropName = (APROPNAMEPTR )
                    PropSymLookup((BYTE *) "\006_edata",ATTRPNM,FALSE);
                                        // Fetch symbol
        if (fNoEnd)
        {
            // No class 'STACK' segment defined;
            // set _edata to end of DGROUP

            if (fNewExe)
            {
                apropName->an_gsn = mpggrgsn[ggrDGroup];
                                        // Save segment definition number
                apropName->an_ggr = ggrDGroup;
                                        // Save group definition number
                apropName->an_ra  = mpsacb[mpsegsa[mpgsnseg[apropName->an_gsn]]];
                                        // Save 'DATA' segments size
            }
#if NOT EXE386
            else
            {
                apropName->an_gsn = gsnTop;
                apropName->an_ggr = ggrDGroup;
                apropName->an_ra  = mpsegcb[segTop];
            }
#endif
        }
        else
        {
            // set _edata to _end

            apropName1 = (APROPNAMEPTR )
                         PropSymLookup((BYTE *) "\004_end",ATTRPNM,FALSE);
                                        // Fetch symbol
            apropName->an_gsn = apropName1->an_gsn;
                                        // Save segment definition number
            apropName->an_ggr = apropName1->an_ggr;
                                        // Save group definition number
            apropName->an_ra  = apropName1->an_ra;
                                        // Save 'DATA' segments size
        }
        MARKVP();                       // Page has changed
    }

    if (fNoEnd)
    {
        // No class 'STACK' segment defined;
        // make _end point to end of 'BSS' or 'DATA' segments

        apropName = (APROPNAMEPTR )
                    PropSymLookup((BYTE *) "\004_end",ATTRPNM,FALSE);
                                        // Fetch symbol
        if (fNewExe)
        {
            apropName->an_gsn = mpggrgsn[ggrDGroup];
                                        // Save segment definition number
            apropName->an_ggr = ggrDGroup;
                                        // Save group definition number
            apropName->an_ra  = mpsacb[mpsegsa[mpgsnseg[apropName->an_gsn]]];
                                        // Save 'BSS' segments size
        }
#if NOT EXE386
        else
        {
            apropName->an_gsn = gsnTop;
            apropName->an_ggr = ggrDGroup;
            apropName->an_ra  = mpsegcb[segTop];
        }
#endif
        MARKVP();                       // Page has changed
    }

    // Make __end and __edata the same as _end and _edata

    apropName  = (APROPNAMEPTR ) PropSymLookup((BYTE *) "\006_edata",ATTRPNM,FALSE);
    apropName1 = (APROPNAMEPTR ) PropSymLookup((BYTE *) "\007__edata",ATTRPNM,TRUE);
    apropName1->an_gsn = apropName->an_gsn;
    apropName1->an_ggr = apropName->an_ggr;
    apropName1->an_ra  = apropName->an_ra;

    apropName  = (APROPNAMEPTR ) PropSymLookup((BYTE *) "\004_end",ATTRPNM,FALSE);
    apropName1 = (APROPNAMEPTR ) PropSymLookup((BYTE *) "\005__end",ATTRPNM,TRUE);
    apropName1->an_gsn = apropName->an_gsn;
    apropName1->an_ggr = apropName->an_ggr;
    apropName1->an_ra  = apropName->an_ra;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newdeb.h ===
/* SCCSID = @(#)newdeb.h        4.1 86/03/11 */
/*
*       Copyright Microsoft Corporation 1985
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*
*  newdeb.h:    File format for symbolic debug information.
*/

#if CVVERSION == 0
typedef struct                  /* Section Table */
{
    long        d_lfaMod;       /* File offset of MODULES */
    long        d_lfaPub;       /* File offset of PUBLICS */
    long        d_lfaTyp;       /* File offset of TYPES */
    long        d_lfaSym;       /* File offset of SMBOLS */
    long        d_lfaSrc;       /* File offset of SRCLINES */
    char        d_ver;          /* Version number */
    char        d_flags;        /* Flags */
}                       SECTABTYPE;
#define CBDEBHDRTYPE    22

typedef struct                  /* Module Entry */
{
    struct
    {
        short   sa;             /* Code seg base */
        short   ra;             /* Offset in code seg */
        short   cb;
    } dm_code;
    long        dm_raPub;           /* offset in PUBLICS */
    long        dm_raTyp;           /* offset in TYPES */
    long        dm_raSym;           /* offset in SYMBOLS */
    long        dm_raSrc;           /* offset in SRCLINES */
    short       dm_cbPub;           /* length in PUBLICS */
    short       dm_cbTyp;           /* length in TYPES */
    short       dm_cbSym;           /* length in SYMBOLS */
    short       dm_cbSrc;           /* length in SCRLINES */
}                       DEBMODTYPE;

#define CBDEBMODTYPE    30

typedef struct debPub           /* PUBLICS entry */
{
    short       dp_ra;          /* Segment offset */
    short       dp_sa;          /* Segment address */
    short       dp_type;        /* Type index */
}                       DEBPUBTYPE;

#define CBDEBPUBTYPE    6
#endif

#if CVVERSION > 0

// New CV EXE format structures and definitions
// Valid for CV 2.0 and 3.0

struct sstModules
{
    unsigned short      segCode;
    unsigned short      raCode;
    unsigned short      cbCode;
    unsigned short      iov;
    unsigned short      ilib;
    unsigned short      flags;
};

#define CBSSTMODULES    (sizeof(sstModules))

// CV 4.0 sstModule format - object file description

#pragma pack(1)

typedef struct sstmod4
{
    unsigned short      ovlNo;      // Overlay number this module was allocated in
    unsigned short      iLib;       // Index to sstLibraries if this module was linked from library
    unsigned short      cSeg;       // Number of physical code segments this module contributes to
    char                style[2];   // Debugging style for this module
}
                        SSTMOD4;
typedef struct codeinfo
{
    unsigned short      seg;        // Logical segment of the contribution
    unsigned short      pad;        // Padding to maintain aligment
    unsigned long       off;        // Offset in the logical segment where the this contribution starts
    unsigned long       cbOnt;      // Size of the contribution in bytes
}
                        CODEINFO;

// Subsection types

#define SSTMODULES      0x101
#define SSTPUBLICS      0x102
#define SSTTYPES        0x103
#define SSTSYMBOLS      0x104
#define SSTSRCLINES     0x105
#define SSTNSRCLINES    0x109       // New format - first implemented in link 5.05
#define SSTLIBRARIES    0x106
#define SSTIMPORTS      0x107

// New subsection types introduced in CV 4.0

#define SSTMODULES4     0x120
#define SSTTYPES4       0x121
#define SSTPUBLICS4     0x122
#define SSTPUBLICSYM    0x123
#define SSTSYMBOLS4     0x124
#define SSTALIGNSYM     0x125
#define SSTSRCLNSEG     0x126
#define SSTSRCMODULE    0x127
#define SSTLIBRARIES4   0x128
#define SSTGLOBALSYM    0x129
#define SSTGLOBALPUB    0x12a
#define SSTGLOBALTYPES  0x12b
#define SSTMPC          0x12c
#define SSTSEGMAP       0x12d
#define SSTSEGNAME      0x12e
#define SSTPRETYPES     0x12f

// Subsection directory header - intorduced in CV 4.0

typedef struct dnthdr
{
    unsigned short      cbDirHeader;// Size of the header
    unsigned short      cbDirEntry; // Size of directory entry
    unsigned long       cDir;       // Number of directory entries
    long                lfoDirNext; // Offset from lfoBase of the next directory
    unsigned long       flags;      // Flags describing directory and subsection tables
}
                        DNTHDR;

typedef struct dnt                  // SubDirectory entry type
{
    short               sst;        // Subsection type
    short               iMod;       // Module index number
    long                lfo;        // LFO of start of section
    long                cb;         // Size of section in bytes (for CV 3.0
                                    // this was short)
}
                        DNT;

typedef struct pubinfo16
{
    unsigned short      len;        // Length of record, excluding the length field
    unsigned short      idx;        // Type of symbol
    unsigned short      off;        // Symbol offset
    unsigned short      seg;        // Symbol segment
    unsigned short      type;       // CodeView type index
}
                        PUB16;

typedef struct pubinfo32
{
    unsigned short      len;        // Length of record, excluding the length field
    unsigned short      idx;        // Type of symbol
    unsigned long       off;        // Symbol offset
    unsigned short      seg;        // Symbol segment
    unsigned short      type;       // CodeView type index
}
                        PUB32;

#define S_PUB16         0x103
#define S_PUB32         0x203
#define T_ABS           0x001

typedef struct
{
    union
    {
        struct
        {
            unsigned short  fRead   :1;
            unsigned short  fWrite  :1;
            unsigned short  fExecute:1;
            unsigned short  f32Bit  :1;
            unsigned short  res1    :4;
            unsigned short  fSel    :1;
            unsigned short  fAbs    :1;
            unsigned short  res2    :2;
            unsigned short  fGroup  :1;
            unsigned short  res3    :3;
        };
        struct
        {
            unsigned short  segAttr :8;
            unsigned short  saAttr  :4;
            unsigned short  misc    :4;
        };
    };
}
                        SEGFLG;


typedef struct seginfo
{
    SEGFLG              flags;      // Segment attributes
    unsigned short      ovlNbr;     // Overlay number
    unsigned short      ggr;        // Group index
    unsigned short      sa;         // Physical segment index
    unsigned short      isegName;   // Index to segment name
    unsigned short      iclassName; // Index to segment class name
    unsigned long       phyOff;     // Starting offset inside physical segment
    unsigned long       cbSeg;      // Logical segment size
}
                        SEGINFO;

#define CVLINEMAX       64

typedef struct _CVSRC
{
    struct _CVSRC FAR   *next;      // Next source file descriptor
    BYTE FAR            *fname;     // Source file name
    WORD                cLines;     // Number of source lines from this file
    WORD                cSegs;      // Number of code segemtns this source file contributes to
    struct _CVGSN FAR   *pGsnFirst; // Code segment list
    struct _CVGSN FAR   *pGsnLast;  // Tail of the code segment list
}
                        CVSRC;

typedef struct _CVGSN
{
    struct _CVGSN FAR   *next;      // Next segment
    struct _CVGSN FAR   *prev;      // Previous segment
    WORD                seg;        // Logical segment index
    WORD                cLines;     // Number of source lines in this code segment
    WORD                flags;      // Flags
    DWORD               raStart;    // Starting logical offset of the contribution
    DWORD               raEnd;      // Ending logical offset of the contribution
    struct _CVLINE FAR  *pLineFirst;// List of offset/line pairs
    struct _CVLINE FAR  *pLineLast; // Tail of the offset/line pairs list
}
                        CVGSN;

/*
 *  Format flags
 *
 *  15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *                                      |
 *                                      +--- Fake segment for explicitly allocated COMDATs
 */

#define SPLIT_GSN       0x1

typedef struct _CVLINE
{
    struct _CVLINE FAR  *next;      // Next bucket
    WORD                cPair;      // Number of offset/line pairs in this bucket
    DWORD               rgOff[CVLINEMAX];
    WORD                rgLn[CVLINEMAX];
}
                        CVLINE;

#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\minlit.h ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*
*  minlit.h
*/
#include                <config.h>      /* Specifies conditional consts */

#if _M_IX86 >= 300
#define M_I386          1
#endif

#if OSMSDOS
#define M_WORDSWAP      TRUE
#endif
#define AND             &&              /* Logical AND */
#define OR              ||              /* Logical OR */
#define NOT             !               /* Logical NOT */
#if OSXENIX
#define NEAR
#define UNALIGNED
#else
#if defined(M_I386) OR defined(_WIN32)
#define NEAR
#if defined( _X86_ )
#define UNALIGNED
#else
#define UNALIGNED       __unaligned
#endif
#if defined(_M_IX86) OR defined(_WIN32)
#define PASCAL
#else
#define PASCAL          pascal
#endif
#else
#if defined(M_I86LM)
#define NEAR
#define UNALIGNED
#else
#define NEAR            near
#define UNALIGNED
#endif
#define PASCAL          pascal
#endif
#endif

/*
 *  Choose proper stdio.h
 */

#if OSXENIX OR NOT OWNSTDIO
#include                <stdio.h>       /* Standard I/O */
#else
#include                "stdio20.h"     /* DOS 2.0 standard I/O definitions */
#endif
#if OSMSDOS
#undef  stderr
#define stderr          stdout          /* Errors to stdout on DOS */
#endif

#if PROFILE OR defined( _WIN32 )        /* If generating profile or building NTGroup version */
#define LOCAL                           /* No local procedures */
#else                                   /* Else if not generating profile */
#define LOCAL           static          /* Permit local procedures */
#endif                                  /* End conditional definition */


#define _VALUE(a)       fprintf(stderr,"v = %lx\r\n",(long) a)
#if DEBUG OR ASSRTON
#define ASSERT(c)       if(!(c)) { fprintf(stderr,"!(%s)\r\n","c"); }
#else
#define ASSERT(c)
#endif
#if DEBUG OR TRACE
#define _TRACE()
#define _ENTER(f)       fprintf(stderr,"Entering \"%s\"\r\n","f")
#define ENTER(f)        { _ENTER(f); _TRACE(); }
#define _LEAVE(f,v)     { _VALUE(v); fprintf(stderr,"Leaving \"%s\"\r\n","f"); }
#define LEAVE(f,v)      { _TRACE(); _LEAVE(f,v); }
#else
#define ENTER(f)
#define LEAVE(f,v)
#endif
#if DEBUG
#define DEBUGVALUE(v)   _VALUE(v)
#define DEBUGMSG(m)     fprintf(stderr,"%s\r\n",m)
#define DEBUGSB(sb)     { OutSb(stderr,sb); NEWLINE(stderr); fflush(stderr); }
#define RETURN(x)       { DEBUGVALUE(x); return(x); }
#else
#define DEBUGVALUE(v)
#define DEBUGMSG(m)
#define DEBUGSB(sb)
#define RETURN(x)       return(x)
#endif
#if SIGNEDBYTE
#define B2W(x)          ((WORD)(x) & 0377)
                                        /* Signed 8-bit to unsigned 16-bit */
#define B2L(x)          ((long)(x) & 0377)
                                        /* Signed 8-bit to unsigned 32-bit */
#else
#define B2W(x)          ((WORD)(x))     /* Unsigned 8-bit to unsigned 16-bit */
#define B2L(x)          ((long)(x))     /* Unsigned 8-bit to unsigned 32-bit */
#endif
#if ODDWORDLN                           /* If machine word length not 16 */
#define LO16BITS(x)     ((WORD)((x) & ~(~0 << WORDLN)))
                                        /* Macro to take low 16 bits of word */
#else                                   /* Else if normal word length */
#define LO16BITS(x)     ((WORD)(x))     /* No-op */
#endif                                  /* End macro definition */

#define BYTELN          8               /* 8 bits per byte */
#define WORDLN          16              /* 16 bits per word */
#define SBLEN           256             /* Max string length */

typedef unsigned long   DWORD;          /* 32-bit unsigned integer */
typedef unsigned short  WORD;           /* 16-bit unsigned integer */
typedef unsigned char   BYTE;           /* 8-bit unsigned integer */
typedef unsigned int    UINT;           /* 16 or 32 bit integer */
typedef FILE            *BSTYPE;        /* Byte stream (same as file handle) */
typedef long            LFATYPE;        /* File offset */
typedef BYTE            SBTYPE[SBLEN];  /* Character string type */

#if M_BYTESWAP
extern WORD             getword();      /* Get word given a char pointer */
extern DWORD            getdword(char *cp);/* Get dword given a char pointer */
#else
#define getword(x)      ( * ( (WORD UNALIGNED *) (x) ) )
#define getdword(x)     ( * ( (DWORD UNALIGNED *) (x) ) )
#define highWord(x)     ( * ( ( (WORD UNALIGNED *) (x) ) + 1 ) )
#endif

#if NOREGISTER
#define REGISTER
#else
#define REGISTER                register
#endif
#if NEWSYM AND (CPU8086 OR CPU286) AND NOT CPU386
#define FAR             far
#else
#define FAR
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newcmd.c ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                        NEWCMD.C                               *
    *                                                               *
    *   Support routines for command prompter.                      *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* The same */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External function declarations */

/*
 *  FUNCTION PROTOTYPES
 */

LOCAL int  NEAR GetInputByte(char *prompt);
LOCAL BYTE NEAR GetStreamByte(char *prompt);
LOCAL void NEAR SetUpCommandLine(int argc, char **argv);
LOCAL void NEAR FinishCommandLine(void);
#if AUTOVM
BYTE FAR * NEAR     FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM    FetchSym1
#else
#define FETCHSYM    FetchSym
#endif

#if OSMSDOS
char                    *stackbuf;
#endif
LOCAL FTYPE             fMoreCommandLine;
                                        /* More command line flag */
LOCAL FTYPE             fMoreIndirectFile;
                                        /* More-input-from-file flag */
LOCAL BSTYPE            bsIndir;        /* File handle for indirect file */
LOCAL FTYPE             fEscNext;
LOCAL FTYPE             fNewLine = (FTYPE) TRUE;/* New command line */
LOCAL FTYPE             fStuffed;       /* Put-back-character flag */
LOCAL BYTE              bStuffed;       /* The character put back */
LOCAL BYTE              bSepLast;       /* Last separator character */
                                        /* Char to replace spaces with */
LOCAL FTYPE             fRedirect;      /* True iff stdin not a device */
LOCAL WORD              fQuotted;       /* TRUE if inside " ... " */
LOCAL char              *pszRespFile;   /* Pointer to responce file name */
LOCAL char              MaskedChar;

#if TRUE
#define SETCASE(c)      (c)             /* Leave as is */
#else
#define SETCASE(c)      UPPER(c)        /* Force to upper case */
#endif

#if WIN_3
extern char far *fpszLinkCmdLine;
#endif

#if AUTOVM

   /*
    *   HACK ALERT !!!!!!!!!!!!
    *
    *   This function is repeated here becouse of mixed medium model.
    *   This the same code as in NEWSYM.c but maked here LOCAL. This
    *   allows near calls to this function in all segments, otherwise
    *   function must be called as far.
    */

extern short picur;

    /****************************************************************
    *                                                               *
    *  FetchSym:                                                    *
    *                                                               *
    *  This function  fetches a symbol from the symbol table given  *
    *  its virtual address.  The symbol  may either be resident or  *
    *  in virtual memory.                                           *
    *                                                               *
    ****************************************************************/

BYTE FAR * NEAR         FetchSym1(rb,fDirty)
RBTYPE                  rb;             /* Virtual address */
WORD                    fDirty;         /* Dirty page flag */
{
    union {
            long      vptr;             /* Virtual pointer */
            BYTE FAR  *fptr;            /* Far pointer     */
            struct  {
                      unsigned short  offset;
                                        /* Offset value    */
                      unsigned short  seg;
                    }                   /* Segmnet value   */
                      ptr;
          }
                        pointer;        /* Different ways to describe pointer */

    pointer.fptr = rb;

    if(pointer.ptr.seg)                 /* If resident - segment value != 0 */
    {
        picur = 0;                      /* Picur not valid */
        return(pointer.fptr);           /* Return pointer */
    }
    pointer.fptr = (BYTE FAR *) mapva(AREASYMS + (pointer.vptr << SYMSCALE),fDirty);
                                        /* Fetch from virtual memory */
    return(pointer.fptr);
}
#endif

 // Strip path from file spec - leave drive letter and filename

void                    StripPath(BYTE *sb)
{
    char        Drive[_MAX_DRIVE];
    char        Dir[_MAX_DIR];
    char        Name[_MAX_FNAME];
    char        Ext[_MAX_EXT];

    /* Decompose filename into four components */

    sb[sb[0]+1] = '\0';
    _splitpath(sb+1, Drive, Dir, Name, Ext);

    /* Create modified path name */

    _makepath(sb+1, Drive, NULL, Name, Ext);
    sb[0] = (BYTE) strlen(sb+1);
}



    /****************************************************************
    *                                                               *
    *  SetUpCommandLine:                                            *
    *                                                               *
    *  This function initializes the command line parser.           *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         SetUpCommandLine(int argc,char **argv)
{
    fMoreCommandLine = (FTYPE) ((argc - 1) != 0 ? TRUE : FALSE);
                                        /* If command line not empty */
    if (!_isatty(fileno(stdin)))         /* Determine if stdin is a device */
        fRedirect = (FTYPE) TRUE;
}

    /****************************************************************
    *                                                               *
    *  FinishCommandLine:                                           *
    *                                                               *
    *  This  function  takes  no  arguments.  If command input has  *
    *  been  coming from  a file, then  this function  closes that  *
    *  file; otherwise, it has  no effect.  It does  not  return a  *
    *  meaningful value.                                            *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR FinishCommandLine(void) /* Close indirect file */
{
    fflush(stdout);                     /* Force to screen */
    if(fMoreIndirectFile)               /* If command input from file */
    {
        fMoreIndirectFile = FALSE;      /* No more indirect file */
        fclose(bsIndir);                /* Close indirect file */
    }
}

#if ECS
/*
 *  GetTxtChr : get the next character from a text file stream
 *
 *      This routine handles mixed DBCS and ASCII characters as
 *      follows:
 *
 *      1.  The second byte of a DBCS character is returned in a
 *      word with the high byte set to the lead byte of the character.
 *      Thus the return value can be used in comparisions with
 *      ASCII constants without being mistakenly matched.
 *
 *      2.  A DBCS space character (0x8140) is returned as two
 *      ASCII spaces (0x20).  I.e. return a space the 1st and 2nd
 *      times we're called.
 *
 *      3.  ASCII characters and lead bytes of DBCS characters
 *      are returned in the low byte of a word with the high byte
 *      set to 0.
 */

int                     GetTxtChr (bs)
BSTYPE                  bs;
{
    static int          chBuf = -1;     /* Character buffer */
    int                 next;           /* The next byte */
    int                 next2;          /* The one after that */

    /* -1 in chBuf means it doesn't contain a valid character */

    /* If we're not in the middle of a double-byte character,
     * get the next byte and process it.
     */
    if(chBuf == -1)
    {
        next = getc(bs);
        /* If this byte is a lead byte, get the following byte
         * and store both as a word in chBuf.
         */
        if(IsLeadByte(next))
        {
            next2 = getc(bs);
            chBuf = (next << 8) | next2;
            /* If the pair matches a DBCS space, set the return value
             * to ASCII space.
             */
            if(chBuf == 0x8140)
                next = 0x20;
        }
    }
    /* Else we're in the middle of a double-byte character.  */
    else
    {
        /* If this is the 2nd byte of a DBCS space, set the return
         * value to ASCII space.
         */
        if(chBuf == 0x8140)
            next = 0x20;
        /* Else set the return value to the whole DBCS character */
        else
            next = chBuf;
        /* Reset the character buffer */
        chBuf = -1;
    }
    /* Return the next character */
    return(next);
}
#endif
    /****************************************************************
    *                                                               *
    *  GetInputByte:                                                *
    *                                                               *
    *  This  function  takes  as  its  input a pointer to an asciz  *
    *  string with  which to  prompt the  user when  more input is  *
    *  necessary.  The  function  returns  a  byte  of  input.  It  *
    *  checks to make sure the byte is a printable ascii character  *
    *  or a carriage return (^M).                                   *
    *                                                               *
    ****************************************************************/

LOCAL int NEAR          GetInputByte(prompt)
char                    *prompt;        /* Pointer to prompt text */
{
    REGISTER unsigned   b;              /* Input byte */
#if ECS || defined(_MBCS)
    static FTYPE        fInDBC;         /* True iff in double-byte char */
#endif

    if(fMoreIndirectFile)               /* If input from file */
    {
        for(;;)                         /* Forever */
        {
            b = GetTxtChr(bsIndir);     /* Read a byte */
            if(b == EOF || b == 032) break;
                                        /* Break on end of file */
            if(fNewLine)                /* If at start of line */
            {
                if (prompt && !fNoEchoLrf)
                    (*pfCputs)(prompt); /* Prompt the user */
                fNewLine = FALSE;       /* Not at beginning anymore */
            }
            if (prompt && !fNoEchoLrf)
            {
#if CRLF
                /* Allow both ^J and ^M^J to terminate input lines. */

                if(b == '\r') continue;
                if(b == '\n') (*pfCputc)('\r');
#endif
                (*pfCputc)(SETCASE(b)); /* Output byte */
            }
            if(b == ';' && !fNoEchoLrf) NEWLINE(stdout);
                                        /* Follow escape by newline */
            else if(b == '\n') fNewLine = (FTYPE) TRUE;
                                        /* Look for new line */
            else if (b == '\t') b = ' ';
                                        /* Translate tabs to spaces */
            if(b == '\n' || b >= ' ') return(SETCASE(b));
                                        /* Return if valid char. */
        }
        FinishCommandLine();            /* Close indirect file */
    }
    if(fStuffed)                        /* If a byte saved */
    {
        fStuffed = FALSE;               /* Now we're unstuffed */
        return(bStuffed);               /* Return the stuffed byte */
    }
    if(fMoreCommandLine)                /* If more command line */
    {
        for(;;)                         /* Forever */
        {
            if (*lpszCmdLine == '\0')   /* If at end of command line */
            {
                fMoreCommandLine = FALSE;
                                        /* No more command line */
                fNewLine = (FTYPE) TRUE;/* New command line */
                return('\n');           /* Return '\n' */
            }
            b = (WORD) (*lpszCmdLine++);/* Get next character */
            if (b == '\\' && *lpszCmdLine == '"')
            {                           /* Skip escaped double quotes */
                lpszCmdLine++;
                if (*lpszCmdLine == '\0')
                {
                    fMoreCommandLine = FALSE;
                                         /* No more command line */
                    fNewLine = (FTYPE) TRUE;
                                         /* New command line */
                    fQuotted = FALSE;
                    return('\n');        /* Return '\n' */
                }
                else
                    b = (WORD) (*lpszCmdLine++);
            }
#if ECS || defined(_MBCS)
            /* If this is a trailing byte of a DBCS char, set the high
             * byte of b to nonzero, so b won't be confused with an ASCII
             * constant.
             */
            if (fInDBC)
            {
                b |= 0x100;
                fInDBC = FALSE;
            }
            else
                fInDBC = (FTYPE) IsLeadByte(b);
#endif
            if (b >= ' ') return(SETCASE(b));
                                        /* Return if valid char. */
        }
    }
    for(;;)                             /* Forever */
    {
        if(fNewLine)                    /* If at start of line */
        {
            if(prompt && ((!fRedirect && !fNoprompt) || (!fEsc && fNoprompt)))
                                        /* If prompt and input from CON */
                (*pfCputs)(prompt);     /* Prompt the user */
            fNewLine = FALSE;           /* Not at beginning anymore */
        }
        b = GetTxtChr(stdin);           /* Read a byte from terminal */
        if(b == EOF) b = ';';           /* Treat EOF like escape */
        else if (b == '\t') b = ' ';    /* Treat tab like space */
        if(b == '\n') fNewLine = (FTYPE) TRUE;  /* New line */
        if(b == '\n' || b >= ' ') return(SETCASE(b));
                                        /* Return if character is valid */
    }
}

    /****************************************************************
    *                                                               *
    *  GetStreamByte:                                               *
    *                                                               *
    *  This function  takes as its input a  pointer to a string of  *
    *  text  with  which  to  prompt  the user, if  necessary.  It  *
    *  returns a byte of command input, and opens an indirect file  *
    *  to do so if necessary.                                       *
    *                                                               *
    ****************************************************************/

LOCAL BYTE NEAR         GetStreamByte(prompt)
char                    *prompt;        /* Pointer to text of prompt */
{
    REGISTER WORD       ich;            /* Index variable */
    SBTYPE              filnam;         /* File name buffer */
    WORD                b;              /* A byte */
#if OSMSDOS
    extern char         *stackbuf;
#endif

    if (((b = (WORD)GetInputByte(prompt)) == INDIR) && !fQuotted)
    {                                   /* If user specifies indirect file */
        if (fMoreIndirectFile) Fatal(ER_nestrf);
                                        /* Check for nesting */
        DEBUGMSG("Getting response file name");
                                        /* Debug message */
        ich = 0;                        /* Initialize index */
        while(ich < SBLEN - 1)          /* Loop to get file name */
        {
            b = (WORD)GetInputByte((char *) 0);
                                        /* Read in a byte */
            fQuotted = fQuotted ? b != '"' : b == '"';
            if ((!fQuotted && (b == ',' || b == '+' || b == ';' || b == ' ')) ||
                 b == CHSWITCH || b < ' ') break;
                                        /* Exit loop on non-name char. */
            if (b != '"')
                filnam[ich++] = (char) b;
                                        /* Store in file name */
        }
        if(b > ' ')                     /* If legal input character */
        {
            fStuffed = (FTYPE) TRUE;    /* Set flag */
            bStuffed = (BYTE) b;        /* Save character */
        }
        filnam[ich] = '\0';             /* Null-terminate file name */
        pszRespFile = _strdup(filnam);   /* Duplicate file name */
        DEBUGMSG(filnam);               /* Debug message */
        if((bsIndir = fopen(filnam,RDTXT)) == NULL)
            Fatal(ER_opnrf,filnam);
#if OSMSDOS
        setvbuf(bsIndir,stackbuf,_IOFBF,512);
#endif
        fMoreIndirectFile = (FTYPE) TRUE;/* Take input from file now */
        b = (WORD)GetInputByte(prompt);       /* Read a byte */
        DEBUGVALUE(b);                  /* Debug info */
    }
    return((BYTE) b);                   /* Return a byte */
}

    /****************************************************************
    *                                                               *
    *  GetLine:                                                     *
    *                                                               *
    *  This  function  takes  as  its  arguments  the address of a  *
    *  buffer in  which  to  return a line  of  command text and a  *
    *  pointer to a  string  with  which  to  prompt  the user, if  *
    *  necessary.  In addition  to  reading  a line, this function  *
    *  will  set  the  global  flag  fEsc  to  true  if  the  next  *
    *  character to be read is a semicolon.  The function does not  *
    *  return a meaningful value.                                   *
    *                                                               *
    ****************************************************************/

void NEAR               GetLine(pcmdlin,prompt)      /* Get a command line */
BYTE                    *pcmdlin;       /* Pointer to destination string */
char                    *prompt;        /* Pointer to text of prompt string */
{
    REGISTER WORD       ich;            /* Index */
    WORD                ich1;           /* Index */
    WORD                ich2;           /* Index */
    BYTE                b;              /* A byte of input */
    WORD                fFirstTime;     /* Boolean */

    fFirstTime = (FTYPE) TRUE;                  /* Assume it is our first time */
    bSepLast = bSep;                    /* Save last separator */
    if(fEscNext)                        /* If escape character next */
    {
        pcmdlin[0] = '\0';              /* No command line */
        fEsc = (FTYPE) TRUE;            /* Set global flag */
        return;                         /* That's all for now */
    }
    for(;;)                             /* Forever */
    {
        fQuotted = FALSE;
        ich = 0;                        /* Initialize index */
        while(ich < SBLEN - 1)          /* While room in buffer */
        {
            b = GetStreamByte(prompt);  /* Get a byte */
            fQuotted = fQuotted ? b != '"' : b == '"';
            if (b == '\n' || (!fQuotted && (b == ',' || b == ';')))
            {
                if (b == ';')
                    fMoreCommandLine = FALSE;
                break;                  /* Leave loop on end of line */
            }
            if (!(b == ' ' && ich == 0))/* Store if not a leading space */
            {
                if (!fQuotted)
                {
                    if (b == '+')
                    {
                        if (!MaskedChar)
                            MaskedChar = b;
                        b = chMaskSpace;
                    }
                    if (b == ' ' && !MaskedChar)
                        MaskedChar = b;
                }
                pcmdlin[++ich] = b;
            }
        }
        /*
         * If ich==SBLEN-1, last char cannot have been a line terminator
         * and buffer is full.  If next input char is a line terminator,
         * OK, else error.
         */
        if(ich == SBLEN - 1 && (b = GetStreamByte(prompt)) != '\n' &&
                b != ',' && b != ';')
        {
            fflush(stdout);
            Fatal(ER_linmax);
        }
        while(ich)                      /* Loop to trim trailing spaces */
        {
            if(pcmdlin[ich] != ' ') break;
                                        /* Break on non-space */
            --ich;                      /* Decrement count */
        }
        ich1 = 0;                       /* Initialize */
        ich2 = 0;                       /* Initialize */
        while(ich2 < ich)               /* Loop to remove or replace spaces */
        {
            ++ich2;
            if (pcmdlin[ich2] == '"')
            {
                // Start of quotted file name

                while (ich2 < ich && pcmdlin[++ich2] != '"')
                    pcmdlin[++ich1] = pcmdlin[ich2];
            }
            else if (pcmdlin[ich2] != ' ' || chMaskSpace != 0 || fQuotted)
            {                           /* If not space or replacing spaces */
                ++ich1;
                if(!fQuotted && pcmdlin[ich2] == ' ') pcmdlin[ich1] = chMaskSpace;
                                        /* Replace space if replacing */
                else pcmdlin[ich1] = pcmdlin[ich2];
                                        /* Else copy the non-space */
            }
        }
        pcmdlin[0] = (BYTE) ich1;       /* Set the length */
        bSep = b;                       /* Save the separator */
        if (ich ||
            !fFirstTime ||
            !((bSepLast == ',' && bSep == '\n') ||
            (bSepLast == '\n' && bSep == ',')))
            break;                      /* Exit the loop */
        fFirstTime = FALSE;             /* No the first time */
        bSepLast = ',';                 /* Comma is the field separator */
    }
    fEscNext = (FTYPE) (b == ';');      /* Set flag */
    fEsc = (FTYPE) (!ich && fEscNext);  /* Set flag */
}





    /****************************************************************
    *                                                               *
    *  ParseCmdLine:                                                *
    *                                                               *
    *  This function takes no  arguments and returns no meaningful  *
    *  value.  It parses the command line.                          *
    *                                                               *
    ****************************************************************/

void                    ParseCmdLine(argc,argv)
                                        /* Parse the command line */
int                     argc;           /* Count of arguments */
char                    **argv;         /* Argument vector */
{
    SBTYPE              sbFile;         /* File name */
    SBTYPE              sbPrompt;       /* Prompt text */
    SBTYPE              rgb;            /* Command line buffer */
    FTYPE               fMoreInput;     /* More input flag */
    FTYPE               fFirstTime;
    AHTEPTR             pahte;  /* Pointer to hash table entry */
    FTYPE               fNoList;        /* True if no list file */
    BYTE                *p;
    WORD                i;
#if OSMSDOS
    char                buf[512];       /* File buffer */
    extern char         *stackbuf;

    stackbuf = buf;
#endif
#if WIN_3
    lpszCmdLine = fpszLinkCmdLine;
#endif

    SetUpCommandLine(argc,argv);        /* Initialize command line */
    chMaskSpace = 0x1f;
    bsLst = stdout;                     /* Assume listing to console */
    fLstFileOpen = (FTYPE) TRUE;        /* So Fatal will flush it */
    fFirstTime = fMoreCommandLine;
    do                                  /* Do while more input */
    {
        fMoreInput = FALSE;             /* Assume no more input */
        if (fFirstTime)
            GetLine(rgb, NULL);
        else
            GetLine(rgb, strcat(strcpy(sbPrompt,GetMsg(P_objprompt)), " [.obj]: "));
                                        /* Get a line of command text */
        if(!rgb[0]) break;              /* Break if length 0 */
        if(rgb[B2W(rgb[0])] == chMaskSpace)     /* If last char is chMaskSpace */
        {
            fMoreInput = (FTYPE) TRUE;  /* More to come */
            --rgb[0];                   /* Decrement the length */
        }
        BreakLine(rgb,ProcObject,chMaskSpace);  /* Apply ProcObject() to line */
#if CMDMSDOS
        if (fFirstTime && !fNoBanner)
            DisplayBanner();            /* Display signon banner */
#endif
        if (fFirstTime && !fNoEchoLrf)
        {
            if (fMoreInput || (fMoreIndirectFile && fFirstTime))
            {
                (*pfCputs)(strcat(strcpy(sbPrompt,GetMsg(P_objprompt)), " [.obj]: "));
                                        /* Prompt the user */
                rgb[B2W(rgb[0]) + 2] = '\0';
                if (fMoreIndirectFile)
                {
                    if (!fMoreInput && !fNewLine && !fEscNext)
                        rgb[B2W(rgb[0]) + 1] = ',';
                    else if (!fMoreInput && fNewLine)
                        rgb[B2W(rgb[0]) + 1] = ' ';
                    else if (rgb[B2W(rgb[0]) + 1] == chMaskSpace)
                        rgb[B2W(rgb[0]) + 1] = '+';
                }
                else if (rgb[B2W(rgb[0]) + 1] == chMaskSpace)
                    rgb[B2W(rgb[0]) + 1] = '+';

                for (i = 1; i <= rgb[0]; i++)
                    if (rgb[i] == chMaskSpace)
                        rgb[i] = MaskedChar;
                (*pfCputs)(&rgb[1]);    /* And display his response */
                if (fMoreInput || fNewLine || fEscNext)
                    if (!fNoEchoLrf)
                        NEWLINE(stdout);
            }
        }
        fFirstTime = FALSE;
    }
    while(fMoreInput);                  /* End of loop */
#if OVERLAYS
    if(fInOverlay) Fatal(ER_unmlpar);
                                        /* Check for parenthesis error
                                        *  See ProcObject() to find out
                                        *  what is going on here.
                                        */
#endif
    chMaskSpace = 0;                    /* Remove spaces */
    if(rhteFirstObject == RHTENIL) Fatal(ER_noobj);
                                        /* There must be some objects */
#if OEXE
    pahte = (AHTEPTR ) FETCHSYM(rhteFirstObject,FALSE);
                                        /* Fetch name of first object */
    memcpy(sbFile,GetFarSb(pahte->cch),B2W(pahte->cch[0]) + 1);
                                        /* Copy name of first object */
#if ODOS3EXE
    if(fQlib)
        UpdateFileParts(sbFile,sbDotQlb);
    else if (fBinary)
        UpdateFileParts(sbFile,sbDotCom);/* Force extension to .COM */
    else
#endif
        UpdateFileParts(sbFile,sbDotExe);/* Force extension to .EXE */
#endif
#if OIAPX286
    memcpy(sbFile,"\005a.out",6);       /* a.out is default for Xenix */
#endif
#if OSMSDOS
    if(sbFile[2] == ':') sbFile[1] = (BYTE) (DskCur + 'a');
                                        /* Get drive letter of default drive */
    StripPath(sbFile);                  /* Strip off path specification */
#endif
    bufg[0] = 0;
    if(!fEsc)                           /* If command not escaped */
    {
        strcat(strcpy(sbPrompt, GetMsg(P_runfile)), " [");
        sbFile[1 + sbFile[0]] = '\0';
                                        /* Build run file prompt */
                                        /* Prompt for run file */
        GetLine(bufg, strcat(strcat(sbPrompt, &sbFile[1]), "]: "));
        PeelFlags(bufg);                /* Peel flags */
        if (B2W(bufg[0]))
            memcpy(sbFile,bufg,B2W(bufg[0]) + 1);
                                        /* Store user responce */
        else
        {
            // Store only base name without extension

            sbFile[0] -= 4;
        }
    }
    EnterName(sbFile,ATTRNIL,TRUE);     /* Create hash tab entry for name */
    rhteRunfile = vrhte;                /* Save hash table address */
#if OSMSDOS
    if (sbFile[0] >= 2 && sbFile[2] == ':')
        chRunFile = sbFile[1];          /* If disk specified, use it */
    else
        chRunFile = (BYTE) (DskCur + 'a');/* Else use current disk */
#endif
    fNoList = (FTYPE) (!vfMap && !vfLineNos);   /* Set default flag value */
#if OSMSDOS
    memcpy(sbFile,"\002a:",3);          /* Start with a drive spec */
#else
    sbFile[0] = '\0';                   /* Null name */
#endif
    pahte = (AHTEPTR ) FETCHSYM(vrhte,FALSE);
                                        /* Fetch run file name */
    UpdateFileParts(sbFile,GetFarSb(pahte->cch)); /* Use .EXE file name... */
    UpdateFileParts(sbFile,sbDotMap);   /* ...with .MAP extension */
#if OSMSDOS
    sbFile[1] = (BYTE) (DskCur + 'a');  /* Default to default drive */
    StripPath(sbFile);                  /* Strip off path specification */
#endif
    fNoList = (FTYPE) (!vfMap && !vfLineNos);   /* No list if not /M and not /LI */
    if(!fEsc)                           /* If argument not defaulted */
    {
        if(bSep == ',') fNoList = FALSE;/* There will be a list file */
        if(fNoList)                     /* If no list file yet */
        {
#if OSMSDOS
            memcpy(sbFile,"\007nul.map",8);
                                        /* Default null list name */
#endif
#if OSXENIX
            memcpy(sbFile,"\007nul.map",8);
                                        /* Default null list name */
#endif
        }
        strcat(strcpy(sbPrompt, GetMsg(P_listfile)), " [");
        sbFile[1 + sbFile[0]] = '\0';
        GetLine(rgb, strcat(strcat(sbPrompt, &sbFile[1]), "]: "));
                                        /* Get map file name */
        PeelFlags(rgb);                 /* Process any flags */
        if(rgb[0])                      /* If name given */
        {
            fNoList = FALSE;            /* There will (maybe) be a list file */
            UpdateFileParts(sbFile,rgb);
        }
    }
    chMaskSpace = 0x1f;                 /* Change spaces to chMaskSpaces */
    if(!fEsc)                           /* If argument not defaulted */
    {
        strcat(strcpy(sbPrompt,GetMsg(P_libprompt)), " [.lib]: ");
        do                              /* Loop to get library names */
        {
            fMoreInput = FALSE;         /* Assume no more input */
            GetLine(rgb, sbPrompt);
            if(fEsc || !rgb[0]) break;  /* Exit loop if no more input */
            if(rgb[B2W(rgb[0])] == chMaskSpace) /* If more to come */
            {
                fMoreInput = (FTYPE) TRUE;      /* Set flag to true */
                --rgb[0];               /* Decrement length */
            }
            BreakLine(rgb,AddLibrary,chMaskSpace);
                                        /* Apply AddLibrary() to lib name(s) */
        }
        while(fMoreInput);              /* End of loop */
    }
#if OSEGEXE AND NOT QCLINK
    chMaskSpace = 0;                    /* Remove spaces */
    rhteDeffile = RHTENIL;              /* Assume no definitions file */
    if(!fEsc)                           /* If argument not defaulted */
    {
#if OSMSDOS
        GetLine(rgb, strcat(strcpy(sbPrompt,GetMsg(P_defprompt)), " [nul.def]: "));
                                        /* Get def file name */
        memcpy(sbPrompt,"\007nul.def",8); /* Default null definition file name */
#endif
#if OSXENIX
        GetLine(rgb, strcat(strcpy(sbPrompt,GetMsg(P_defprompt)), " [nul.def]: "));
                                        /* Get def file name */
        memcpy(sbPrompt,"\007nul.def",8); /* Default null definition file name */
#endif
        PeelFlags(rgb);                 /* Process any flags */
        if(rgb[0])                      /* If a name was given */
        {
            UpdateFileParts(sbPrompt,rgb);
                                        /* Get file name */
            memcpy(rgb,sbPrompt,B2W(sbPrompt[0]) + 1);
                                        /* Copy name */
            UpdateFileParts(rgb,"\003NUL");
                                        /* Replace name with null name */
            if(!SbCompare(sbPrompt,rgb,TRUE))
            {                           /* If name not null */
                EnterName(sbPrompt,ATTRNIL,TRUE);
                                        /* Create hash tab entry for name */
                rhteDeffile = vrhte;    /* Save hash table address */
            }
        }
    }
#endif /* OSEGEXE */
    FinishCommandLine();                /* Close indirect file (if any) */
    fLstFileOpen = FALSE;
#if OSMSDOS
    rhteLstfile = RHTENIL;              /* Assume no list file */
#endif
    if(!fNoList)                        /* If a listing wanted */
    {
        memcpy(sbPrompt,sbFile,B2W(sbFile[0]) + 1);
                                        /* Copy full file name */
        UpdateFileParts(sbPrompt,"\003NUL");
                                        /* Change name only */
        if(!SbCompare(sbFile,sbPrompt,TRUE))
        {                               /* If name given not null device */
            UpdateFileParts(sbPrompt,"\003CON");
                                        /* Change name only */
            if(!SbCompare(sbFile,sbPrompt,TRUE))
            {                           /* If list file not console */
                sbFile[B2W(++sbFile[0])] = '\0';
                                        /* Null-terminate name */
                if((bsLst = fopen(&sbFile[1],WRBIN)) == NULL)
                  Fatal(ER_lstopn);     /* Open listing file */
#if OSMSDOS
#ifdef M_I386
                if((p = GetMem(512)) != NULL)
#else
                if((p = malloc(512)) != NULL)
#endif
                    setvbuf(bsLst,p,_IOFBF,512);
                EnterName(sbFile,ATTRNIL,TRUE);
                                        /* Create hash tab entry for name */
                rhteLstfile = vrhte;    /* Save hash table address */
#endif
            }
            else bsLst = stdout;        /* Else list to console */
#if OSMSDOS
            if(bsLst == stdout) chListFile = (unsigned char) '\377';
                                        /* List file is console */
            else if(_isatty(fileno(bsLst))) chListFile = (unsigned char) '\377';
                                        /* List file is some device */
            else if(sbFile[2] == ':')   /* Else if drive spec given */
                chListFile = (BYTE) (sbFile[1] - 'a');
                                        /* Save floppy drive number */
            else chListFile = DskCur; /* Else list file on current floppy */
#endif
            fLstFileOpen = (FTYPE) TRUE;/* We have a list file */
        }
    }
#if FALSE AND OSMSDOS AND OWNSTDIO
    /* If wer're using our own stdio, set stdout to unbuffered if it
     * goes to console.
     *  CAN'T do this because we now use standard fprintf. Only
     *  stdio is custom made.
     */
    if(_isatty(fileno(stdout)))
    {
        fflush(stdout);
        stdout->_flag |= _IONBF;
    }
#endif
#if QCLINK OR Z2_ON
    if (fZ2 && pszRespFile != NULL)
        _unlink(pszRespFile);
    if (pszRespFile != NULL)
        FFREE(pszRespFile);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newdeb.c ===
/*
*       Copyright Microsoft Corporation 1985-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

    /****************************************************************
    *                                                               *
    *                           NEWDEB.C                            *
    *                                                               *
    *  Symbolic debugging support.                                  *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Basic types and constants */
#include                <bndtrn.h>      /* More types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker input/output */
#if OIAPX286
#include                <xenfmt.h>      /* Xenix executable format defs. */
#endif
#if OEXE
#include                <newexe.h>      /* Segmented executable format */
#endif
#if EXE386
#include                <exe386.h>
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External function declarations */
#ifndef CVVERSION
#if OIAPX286
#define CVVERSION       0               /* Assume new CV exe format */
#else
#define CVVERSION       1               /* Assume new CV exe format */
#endif
#endif
#if (CPU8086 OR CPU286)
#define TFAR            far
#else
#define TFAR
#endif
#include                <newdeb.h>      /* Symbolic debug types */
extern              SEGTYPE  segAdjCom; /* Segment moved by 0x100 in .com programs */
#if AUTOVM
BYTE FAR * NEAR     FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM    FetchSym1
#define PROPSYMLOOKUP EnterName
#else
#define FETCHSYM    FetchSym
#define PROPSYMLOOKUP EnterName
#endif

#define CVDEBUG  FALSE
#define SRCDEBUG FALSE

#define DNT_START       64
#define Round2Dword(x)  (((x) + 3L) & ~3L)

typedef struct raPair
{
    DWORD   raStart;
    DWORD   raEnd;
}
            RAPAIR;

/*
 *  FUNCTION PROTOTYPES
 */

LOCAL WORD NEAR         IsDebTyp(APROPSNPTR prop);
LOCAL WORD NEAR         IsDebSym(APROPSNPTR prop);
LOCAL int  NEAR         OutLibSec(void);
void NEAR               GetName(AHTEPTR ahte, BYTE *pBuf);
LOCAL DWORD NEAR        OutSrcModule(CVSRC FAR *pSrcLines);
LOCAL void NEAR         PutDnt(DNT *pDnt);
LOCAL WORD NEAR         HasCVinfo(APROPFILEPTR apropFile);
LOCAL void NEAR         OutModules(void);
LOCAL void NEAR         Pad2Dword(void);
#if CVDEBUG
LOCAL void NEAR         DumpDNT(DNT *pDnt);
#endif

extern long             lfaBase;        /* Base address */
extern int              fSameComdat;    /* Set if LINSYM to the same COMDAT */

/*
 *  CodeView signature - if changes notify the developers of the
 *  following programs:
 *                      - QuickC
 *                      - Resource Compiler - Windows and PM
 *                      - CodeView and its utilities
 */
char                    szSignature[4] = "NB05";

RBTYPE                  rhteDebSrc;     /* Class "DEBSRC" virt addr */
RBTYPE                  rhteDebSym;     /* Class "DEBSYM" virt addr */
RBTYPE                  rhteDebTyp;     /* Class "DEBTYP" virt addr */
RBTYPE                  rhteTypes;
RBTYPE                  rhteSymbols;
RBTYPE                  rhte0Types;
RBTYPE                  rhte0Symbols;
LOCAL SBTYPE            sbLastModule;   /* Name of THEADR last observed */
#if NOT CVVERSION
LOCAL long              lfaDebHdr;      /* Position of section table */
LOCAL long              lfaSegMod;
#endif
LOCAL WORD              dntMax;         // DNT table size
LOCAL WORD              dntMac;         // Count of DNT entries in table
LOCAL DNT FAR           *rgDnt;         // Table of DNT entries
LOCAL DWORD FAR         *fileBase;      // Table of offsets to source file info
LOCAL RAPAIR FAR        *raSeg;         // Table of physical starting and ending offsets
                                        // of the contribution to the logical segments
LOCAL WORD FAR          *segNo;         // Table of physical segment indicies
LOCAL WORD              cMac;           // Current number of elements in the above tables

#ifdef CVPACK_MONDO
#define CVPACK_SHARED 1
#define REVERSE_MODULE_ORDER_FOR_CVPACK 1
#else
#define CVPACK_SHARED 0
#define REVERSE_MODULE_ORDER_FOR_CVPACK 0
#endif

//these macros help to make the source not so cluttered with #ifdefs...

#if CVPACK_SHARED

#define IF_NOT_CVPACK_SHARED(x)
#define WriteCopy(x,y) WriteSave(TRUE, x, y)
#define WriteNocopy(x,y) WriteSave(FALSE, x, y)
#define FTELL_BSRUNFILE() lposCur
#define LINK_TRACE(x)


// cvpack might read parts of the header more than once, we use this
// constant to ensure that at least CB_HEADER_SAVE bytes are always
// available to be re-read by cvpack

#define CB_HEADER_SAVE  128

void WriteSave(FTYPE fCopy, void *pv, UINT cb);
void WriteFlushSignature(void);
void WriteFlushAll(void);

// cvpack cached blocks...

typedef struct _BL
    {
    long        lpos;       // position of this block in the file
    BYTE *      pb;         // pointer to bytes in this block
    } BL;

#define iblNil (-1)

static long lposCur;        // current position in the file
static long lposMac;        // size of the file
static long iblLim;         // number of blocks used
static long iblCur;         // current block we are reading
static long iblMac;         // number of blocks allocated
static long cbRealBytes;    // number of bytes actually written to the file
static int  ichCur;         // index within the current block
static int  cbCur;          // number of bytes left in the current block

static BL *rgbl;            // array of buffered write blocks

// number of bytes in a particular block

__inline int CbIbl(int ibl)
{
    // compute the difference between this block and the next block
    // unless this is the last block then use lposMac

    if (ibl == iblLim - 1)
        return lposMac - rgbl[ibl].lpos;
    else
        return rgbl[ibl+1].lpos - rgbl[ibl].lpos;
}

#define C_BL_INIT 256
#else
#define IF_NOT_CVPACK_SHARED(x) x
#define WriteCopy(x,y) WriteExe(x,y)
#define WriteNocopy(x,y) WriteExe(x,y)
#define FTELL_BSRUNFILE() ftell(bsRunfile)
#define LINK_TRACE(x)
#endif

#if CVDEBUG
LOCAL void NEAR         DumpDNT(DNT *pDnt)
{
    if (pDnt == NULL)
        return;

    fprintf(stdout, "iMod = %d(0x%x)", pDnt->iMod, pDnt->iMod);
    switch (pDnt->sst)
    {
        case SSTMODULES:
        case SSTMODULES4:
            fprintf(stdout, "    SSTMODULES:     ");
            break;

        case SSTTYPES:
        case SSTTYPES4:
            fprintf(stdout, "    SSTYPES:        ");
            break;

        case SSTPUBLICS:
        case SSTPUBLICS4:
            fprintf(stdout, "    SSTPUBLICS:     ");
            break;

        case SSTPUBLICSYM:
            fprintf(stdout, "    SSTPUBLICSYM:   ");
            break;

        case SSTSYMBOLS:
        case SSTSYMBOLS4:
            fprintf(stdout, "    SSTSYMBOLS:     ");
            break;

        case SSTALIGNSYM:
            fprintf(stdout, "    SSTALIGNSYM:    ");
            break;

        case SSTSRCLINES:
        case SSTNSRCLINES:
        case SSTSRCLNSEG:
            fprintf(stdout, "    SSTSRCLINES:    ");
            break;

        case SSTSRCMODULE:
            fprintf(stdout, "    SSTSRCMODULE:   ");
            break;

        case SSTLIBRARIES:
        case SSTLIBRARIES4:
            fprintf(stdout, "    SSTLIBRARIES:   ");
            break;

        case SSTGLOBALSYM:
            fprintf(stdout, "    SSTGLOBALSYM:   ");
            break;

        case SSTGLOBALPUB:
            fprintf(stdout, "    SSTGLOBALPUB:   ");
            break;

        case SSTGLOBALTYPES:
            fprintf(stdout, "    SSTGLOBALTYPES: ");
            break;

        case SSTMPC:
            fprintf(stdout, "    SSTMPC:         ");
            break;

        case SSTSEGMAP:
            fprintf(stdout, "    SSTSEGMAP:      ");
            break;

        case SSTSEGNAME:
            fprintf(stdout, "    SSTSEGNAME:     ");
            break;

        case SSTIMPORTS:
            fprintf(stdout, "    SSTIMPORTS:     ");
            break;

        default:
            fprintf(stdout, "    UNKNOWN !?!:    ");
            break;
    }
    fprintf(stdout, "file offset 0x%lx; size 0x%x\r\n",
                     lfaBase+pDnt->lfo, pDnt->cb);
}
#endif

#if SRCDEBUG
LOCAL void NEAR         DumpSrcLines(DWORD vLines)
{
    CVSRC               cvSrc;
    CVGSN               cvGsn;
    CVLINE              cvLine;
    DWORD               curSrc;
    DWORD               curGsn;
    DWORD               curLine;
    SBTYPE              fileName;
    DWORD               i;
    WORD                j;


    fprintf(stdout, "\r\nList at %lx\r\n\r\n", vLines);
    for (curSrc = vLines; curSrc != 0L; curSrc = cvSrc.vpNext)
    {
        memcpy(&cvSrc, mapva(curSrc, FALSE), sizeof(CVSRC));
        memcpy(fileName, mapva(cvSrc.vpFileName, FALSE), cvSrc.cbName);
        fileName[cvSrc.cbName] = '\0';
        fprintf(stdout, "'%s' --> code segments: %lu; source lines: %lu\r\n", fileName, cvSrc.cSegs, cvSrc.cLines);

        for (curGsn = cvSrc.vpGsnFirst; curGsn != 0L; curGsn = cvGsn.vpNext)
        {
            memcpy(&cvGsn, mapva(curGsn, FALSE), sizeof(CVGSN));
            fprintf(stdout, "    Logical segment %d; source lines: %d; start: %lx; end: %lx\r\n", cvGsn.seg, cvGsn.cLines, cvGsn.raStart, cvGsn.raEnd);

            for (curLine = cvGsn.vpLineFirst, i = 1L; curLine != 0L; curLine = cvLine.vpNext)
            {
                memcpy(&cvLine, mapva(curLine, FALSE), sizeof(CVLINE));
                for (j = 0; j < cvLine.cPair; j++, i++)
                    fprintf(stdout, "        %8lu: %u:%lx\r\n", i, cvLine.rgLn[j], cvLine.rgOff[j]);
            }
        }
    }
}
#endif


    /****************************************************************
    *                                                               *
    *  Initialize variables for symbolic debug processing.          *
    *  Pass 1.                                                      *
    *                                                               *
    ****************************************************************/

void NEAR InitDeb1 (void)
{
#if ODOS3EXE
    if (vfDSAlloc)
    {
        OutWarn(ER_dbgdsa);
        vfDSAlloc = FALSE;
    }
#endif
#if FEXEPACK
    if (fExePack)
    {
        OutWarn(ER_dbgexe);
        fExePack = FALSE;
    }
#endif
}

void  InitDbRhte ()
{
    PROPSYMLOOKUP((BYTE *) "\006DEBTYP", ATTRNIL, TRUE);
    rhteDebTyp = vrhte;
    PROPSYMLOOKUP((BYTE *) "\006DEBSYM", ATTRNIL, TRUE);
    rhteDebSym = vrhte;
    PROPSYMLOOKUP((BYTE *) "\006 TYPES", ATTRNIL, TRUE);
    rhte0Types = vrhte;
    PROPSYMLOOKUP((BYTE *) "\010 SYMBOLS", ATTRNIL, TRUE);
    rhte0Symbols = vrhte;
    PROPSYMLOOKUP((BYTE *) "\007$$TYPES", ATTRNIL, TRUE);
    rhteTypes = vrhte;
    PROPSYMLOOKUP((BYTE *) "\011$$SYMBOLS", ATTRNIL, TRUE);
    rhteSymbols = vrhte;
 }


LOCAL void NEAR         Pad2Dword(void)
{
    WORD                cb;             // Number of bytes to write
    static DWORD        dwZero;

    // Calculate needed padding

    cb = (WORD)(sizeof(DWORD)-((WORD) FTELL_BSRUNFILE() % sizeof(DWORD)));

    if (cb != sizeof(DWORD))
        WriteCopy(&dwZero, cb);
}

/*** GetName - get symbol associated with given property cell
*
* Purpose:
*   Find the symbol which has given property.
*
* Input:
*   - ahte - pointer to property cell
*   - pBuf - pointer to ASCII buffer
*
* Output:
*   No explicit value is passed. If symbol is found the it is
*   copied into buffer
*
* Exceptions:
*   None.
*
* Notes:
*   This functional duplicate of GetPropName, but we want to
*   call both function as near.
*
*************************************************************************/

void NEAR               GetName(AHTEPTR ahte, BYTE *pBuf)
{
    while(ahte->attr != ATTRNIL)
        ahte = (AHTEPTR ) FETCHSYM(ahte->rhteNext, FALSE);
    FMEMCPY((char FAR *) pBuf, ahte->cch, B2W(ahte->cch[0]) + 1);
    if (B2W(pBuf[0]) < SBLEN)
        pBuf[pBuf[0] + 1] = '\0';
    else
        pBuf[pBuf[0]] = '\0';
}

/*** DebPublic - prepare symbols for debugger
*
* Purpose:
*   When the /CODEVIEW option is used then all PUBDEFs and COMDEFs
*   defined in a given object file are linked into one list. This
*   function adds one symbol to the list and updates the combined
*   size of symbols
*
* Input:
*   vrprop - virtual pointer to symbol descriptor
*   rt     - OMF record type
*
* Output:
*   No explicit value is returned.
*   Side effects:
*       - symbol is attached to the module symbol list
*
* Exceptions:
*   None.
*
* Notes:
*   Symbols are placed on the list in reverse order of their apperance
*   in the object file.
*
*************************************************************************/


void                    DebPublic(RBTYPE vrprop, WORD rt)
{
    APROPFILEPTR        apropFile;      // Pointer to file entry
    APROPNAMEPTR        apropName;      // Real pointer to PUBDEF descriptor
    APROPUNDEFPTR       apropUndef;     // Real pointer to COMDEF descriptor
    APROPALIASPTR       apropAlias;     // Real pointer to ALIAS descriptor
    RBTYPE              symNext;        // Virtual pointer to the next symbol


    // Update the appropriate field in the current file symtab entry

    apropFile = ((APROPFILEPTR ) FETCHSYM(vrpropFile, TRUE));
    symNext = apropFile->af_publics;
    apropFile->af_publics = vrprop;
    apropName = (APROPNAMEPTR) FETCHSYM(vrprop, TRUE);
    if (TYPEOF(rt) == PUBDEF)
        apropName->an_sameMod = symNext;
    else if (TYPEOF(rt) == COMDEF)
    {
        apropUndef = (APROPUNDEFPTR) apropName;
        apropUndef->au_sameMod = symNext;
    }
    else if (TYPEOF(rt) == ALIAS)
    {
        apropAlias = (APROPALIASPTR) apropName;
        apropAlias->al_sameMod = symNext;
    }
}


LOCAL WORD NEAR         IsDebTyp (prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_attr == ATTRLSN && prop->as_rCla == rhteDebTyp);
}

LOCAL WORD NEAR         IsDebSym (prop)
APROPSNPTR              prop;           /* Pointer to segment record */
{
    return(prop->as_attr == ATTRLSN && prop->as_rCla == rhteDebSym);
}


/*** DoDebSrc - store source line information
*
* Purpose:
*   Stores source line information from object file.
*
* Input:
*   No explicit value is passed.
*
*   Global variables:
*       - vaCVMac   - virtual pointer to the free space in the CV info buffer
*
* Output:
*   Returns TRUE if the cv info has been stored in the VM ,or FALSE otherwise.
*   Side effects:
*       - source line information is stored in the VM
*
* Exceptions:
*   More than 32Mb of CV information - dispaly error and quit
*
* Notes:
*   None.
*
*************************************************************************/

#pragma check_stack(on)

WORD                    DoDebSrc(void)
{
    WORD                cbRecSav;       // LINNUM record size
    APROPFILEPTR        apropFile;      // Current object file property cell
    static SATYPE       prevGsn = 0;    // GSN of previous LINNUM record
    GSNINFO             gsnInfo;        // GSN info for this LINNUM
    static CVSRC FAR    *pCurSrc;       // Pointer to the current file source info
    CVGSN FAR           *pCurGsn;       // Pointer to the current code segment descriptor
    CVGSN FAR           *pcvGsn;        // Real pointer to the code segment descriptor
    CVLINE FAR          *pCurLine;      // Pointer to the current offset/line pair bucket
    RATYPE              ra;             // Offset
    WORD                line;           // Line number
    RATYPE              raPrev;         // Offset of the previous line
    WORD                fChangeInSource;
    WORD                fComdatSplit;
    DWORD               gsnStart;       // Start of this gsn
    APROPSNPTR          apropSn;
    WORD                align;
    WORD                threshold;
#if !defined( M_I386 ) && !defined( _WIN32 )
    SBTYPE              nameBuf;
#endif


    cbRecSav = cbRec;
    if (!GetGsnInfo(&gsnInfo))
        return(FALSE);

    // If LINNUM record is empty, don't do anything

    if (cbRec == 1)
        return(FALSE);

    apropFile = (APROPFILEPTR ) FETCHSYM(vrpropFile, TRUE);

    // If there is a new source file allocate new CVSRC structure
    // and link it to the current object file descriptor

    fChangeInSource = (WORD) (apropFile->af_Src == 0 || !SbCompare(sbModule, sbLastModule,TRUE));

    if (fChangeInSource)
    {
#if CVDEBUG
        sbModule[sbModule[0]+1]='\0';
        sbLastModule[sbLastModule[0]+1]='\0';
        fprintf(stdout, "Change in source file; from '%s' to '%s'\r\n", &sbLastModule[1], &sbModule[1]);
#endif
        // Search the list of CVSRC structures for this object
        // file and find out if we heave already seen this source file

        for (pCurSrc = apropFile->af_Src; pCurSrc;)
        {
#if defined(M_I386) || defined( _WIN32 )
            if (SbCompare(sbModule, pCurSrc->fname, TRUE))
#else
            FMEMCPY((char FAR *) nameBuf, pCurSrc->fname, pCurSrc->fname[0] + 1);
            if (SbCompare(sbModule, nameBuf, TRUE))
#endif
                break;
            else
                pCurSrc = pCurSrc->next;
        }

        if (pCurSrc == NULL)
        {
            // New source file

            pCurSrc = (CVSRC FAR *) GetMem(sizeof(CVSRC));
            pCurSrc->fname = GetMem(sbModule[0] + 1);
            FMEMCPY(pCurSrc->fname, (char FAR *) sbModule, sbModule[0] + 1);

            if (apropFile->af_Src == NULL)
                apropFile->af_Src = pCurSrc;
            else
                apropFile->af_SrcLast->next = pCurSrc;

            apropFile->af_SrcLast = pCurSrc;
        }
        else
        {
            // We have already seen this source file
        }
        memcpy(sbLastModule, sbModule, B2W(sbModule[0]) + 1);
    }
    else
    {
        // Use descriptor set last time we changed source files
    }

    //  Allocate the new CVGSN structure if any of the following is true
    //
    //  - this is first batch of source lines
    //  - there is a change in GSNs
    //  - there is a change in source file
    //  - we have source lines for explicitly allocated COMDAT
    //  In this last case we assume that the begin portion of a
    //  given logical segment (gsn) has been filled with contributions
    //  from many object files. Because COMDATs are allocated after all
    //  the object files are read, then adding source
    //  lines of COMDAT to the source lines of preceeding LEDATA records
    //  will mask the contributions from other object files, as the picture
    //  below shows:
    //
    //          +-------------+<--+
    //          |             |   |
    //          | LEDATA from |   |
    //          |   a.obj     |   |
    //          |             |   |
    //          +-------------+   |
    //          |             |   | Without splitting into fake CVGSN
    //          | LEDATA from |   \ the source line for a.obj will
    //          |   b.obj     |   / hide the LEDATA contribution from b.obj
    //          |             |   |
    //          +-------------+   |
    //          |             |   |
    //          | COMDAT from |   |
    //          |   a.obj     |   |
    //          |             |   |
    //          +-------------+<--+
    //          |             |
    //          | COMDAT from |
    //          |   b.obj     |
    //          |             |
    //          +-------------+
    //
    //  This will be unnecessary only if COMDAT from a.obj immediately
    //  follows LEDATA from a.obj

    fComdatSplit = FALSE;
    pCurGsn = pCurSrc->pGsnLast;
    if (pCurGsn)
    {
        // Assume we will be using the current CVGSN

        if (gsnInfo.fComdat)
        {
            // Source lines from LINSYM - Calculate the threshold

            apropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsnInfo.gsn], FALSE);
            if (gsnInfo.comdatAlign)
                align = gsnInfo.comdatAlign;
            else
                align = (WORD) ((apropSn->as_tysn >> 2) & 7);

            threshold = 1;
            switch (align)
            {
                case ALGNWRD:
                    threshold = 2;
                    break;
#if OMF386
                case ALGNDBL:
                    threshold = 4;
                    break;
#endif
                case ALGNPAR:
                    threshold = 16;
                    break;

                case ALGNPAG:
                    threshold = 256;
                    break;
            }

            // Check if we have to split CVGSN for this COMDAT

            fComdatSplit =  !fSameComdat &&
                            !(apropSn->as_fExtra & COMDAT_SEG) &&
                            (gsnInfo.comdatRa - pCurGsn->raEnd > threshold);

        }
        else
        {
            // Source lines from LINNUM

            if (pCurGsn->flags & SPLIT_GSN)
            {
                // The LINNUM record following the LINSYM record that
                // caused CVGSN split - we have to move back on CVGSN
                // list until we find first CVGSN not marked as SPLIT_GSN

                for (pcvGsn = pCurGsn->prev; pcvGsn != (CVGSN FAR *) pCurSrc;)
                {
                    if (!(pcvGsn->flags & SPLIT_GSN))
                        break;
                    else
                        pcvGsn = pcvGsn->prev;
                }

                if (pcvGsn == (CVGSN FAR *) pCurSrc)
                {
                    // There are only SPLIT_GSN on the list - make new CVGSN

                    prevGsn = 0;
                }
                else
                {
                    // Use the first non SPLIT_GSN CVGSN as current one

                    pCurGsn = pcvGsn;
                }
            }
        }
    }

    if ((prevGsn == 0)                               ||
        (mpgsnseg[gsnInfo.gsn] != mpgsnseg[prevGsn]) ||
        fChangeInSource                              ||
        fComdatSplit)
    {
        // Make new CVGSN
        // Remember LOGICAL segment

        pCurGsn = (CVGSN FAR *) GetMem(sizeof(CVGSN));
        pCurGsn->seg = mpgsnseg[gsnInfo.gsn];

        // The start and end offset will be derived from line number/offset pairs

        pCurGsn->raStart = 0xffffffff;
        if (fComdatSplit)
            pCurGsn->flags |= SPLIT_GSN;
        if (pCurSrc->pGsnFirst == NULL)
        {
            pCurSrc->pGsnFirst = pCurGsn;
            pCurGsn->prev      = (CVGSN FAR *) pCurSrc;
        }
        else
        {
            pCurSrc->pGsnLast->next = pCurGsn;
            pCurGsn->prev = pCurSrc->pGsnLast;
        }
        pCurSrc->pGsnLast = pCurGsn;
        pCurSrc->cSegs++;
#if CVDEBUG
        sbModule[sbModule[0]+1] = '\0';
        fprintf(stdout, "New code segment in '%s'; prevGsn = %x; newGsn = %x %s\r\n", &sbModule[1], prevGsn, gsnInfo.gsn, fComdatSplit ? "COMDAT split" : "");
#endif
        prevGsn = gsnInfo.gsn;
    }

    // Get the offset/line bucket

    if (pCurGsn->pLineFirst == NULL)
    {
        pCurLine = (CVLINE FAR *) GetMem(sizeof(CVLINE));
        pCurGsn->pLineFirst = pCurLine;
        pCurGsn->pLineLast  = pCurLine;
    }
    else
        pCurLine = pCurGsn->pLineLast;

    // Fill in offset/line bucket

    if (gsnInfo.fComdat)
        gsnStart = gsnInfo.comdatRa;
    else
        gsnStart = mpgsndra[gsnInfo.gsn] - mpsegraFirst[pCurGsn->seg];

    raPrev = 0xffff;
    while (cbRec > 1)                   // While not at checksum
    {
        GetLineOff(&line, &ra);

        ra += gsnStart;

        // We have to eliminate line pairs with same ra (for MASM 5.1)

        if(ra == raPrev)
            continue;
        raPrev = ra;

        // Remember the smallest LOGICAL offset for source line

        if (ra < pCurGsn->raStart)
            pCurGsn->raStart = ra;

        if (line != 0)
        {
            if (pCurLine->cPair >= CVLINEMAX)
            {
                pCurLine->next = (CVLINE FAR *) GetMem(sizeof(CVLINE));
                pCurLine = pCurLine->next;
                pCurGsn->pLineLast = pCurLine;
            }

            pCurLine->rgOff[pCurLine->cPair] = ra;
            pCurLine->rgLn[pCurLine->cPair]  = line;
            pCurLine->cPair++;
            pCurSrc->cLines++;
            pCurGsn->cLines++;
        }
    }

    // Remember last line LOGICAL offset

    pCurGsn->raEnd = ra;
#if CVDEBUG
    fprintf(stdout, "New source lines for the 0x%x logical code segment; lines %d\r\n    start offset %x:%lx  end offset %x:%lx; physical address of logical segment %x:%lx\r\n",
                pCurGsn->seg, pCurGsn->cLines, pCurGsn->seg, pCurGsn->raStart, pCurGsn->seg, pCurGsn->raEnd, mpsegsa[pCurGsn->seg], mpsegraFirst[pCurGsn->seg]);
#endif

    // If /LINENUMBERS and list file open, back up

    if (vfLineNos && fLstFileOpen)
    {
#if ALIGN_REC
        pbRec += (cbRec - cbRecSav);
#else
        fseek(bsInput, (long)cbRec - cbRecSav, 1);
#endif
        cbRec = cbRecSav;
    }
    return(TRUE);
}

#pragma check_stack(off)

/*** CheckTables - check space in table used by OutSrcModule
*
* Purpose:
*   While building the new source module subsection linker needs
*   to store a lot of information about given source file. Since
*   we can't predict how many source files were compiled to obtain
*   this object module or to how many logical segments this object
*   module contributes code we have to dynamically resize appropriate
*   tables.
*
* Input:
*   cFiles  - number of source files compiled to produce
*             this object module
*   cSegs   - number of logical segments this object module
*             contributes to.
*
* Output:
*   No explicit value is returned. As a side effect the following
*   tables are allocated or reallocated:
*
*   fileBase - table of offsets to source file info
*   raSeg    - table of physical starting and ending offsets
*              of the contribution to the logical segments
*   segNo    - table of physical segment indicies
*
* Exceptions:
*   Memory allocation problems - fatal error and exit.
*
* Notes:
*   When we reallocated the tables we don't have to copy
*   their old content, because it was used in the previous
*   object module.
*
*************************************************************************/

LOCAL void NEAR         CheckTables(WORD cFiles, WORD cSegs)
{
    WORD                cCur;

    cCur = (WORD) (cFiles < cSegs ? cSegs : cFiles);
    if (cCur > cMac)
    {
        // We have to reallocate tables or allocate for the first time

        if (fileBase)
            FFREE(fileBase);
        if (raSeg)
            FFREE(raSeg);
        if (segNo)
            FFREE(segNo);

        fileBase = (DWORD FAR *)  GetMem(cCur*sizeof(DWORD));
        raSeg    = (RAPAIR FAR *) GetMem(cCur*sizeof(RAPAIR));
        segNo    = (WORD FAR *)   GetMem(cCur*sizeof(WORD));
        cMac = cCur;
    }
}


/*** OutSrcModule - write CV source module
*
* Purpose:
*   Create the CV 4.00 format source module descrbing the source line
*   number to addressing mapping information for one object file
*
* Input:
*   - pSrcLines - the list of source file information blocks
*
* Output:
*   Total size of the subsection in bytes.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL DWORD NEAR        OutSrcModule(CVSRC FAR *pSrcLines)
{
    CVSRC FAR           *pCurSrc;       // Pointer to current source file
    CVGSN FAR           *pCurGsn;       // Pointer to current code segment
    CVLINE FAR          *pLine;         // Pointer to source line bucket
    WORD                cFiles;         // Number of source files
    WORD                cSegs;          // Number of code segments
    WORD                xFile;
    WORD                xSeg;
    DWORD               sizeTotal;      // Size of source subsection
    DWORD               srcLnBase;
    WORD                counts[2];
    CVLINE FAR          *pTmp;


#if SRCDEBUG
    DumpSrcLines(vaLines);
#endif

    // Count total number of source files, total number of code segments

    for (pCurSrc = pSrcLines, cFiles = 0, cSegs = 0; pCurSrc; cFiles++, pCurSrc = pCurSrc->next)
        cSegs += pCurSrc->cSegs;

    CheckTables(cFiles, cSegs);
    sizeTotal = (DWORD) (2*sizeof(WORD) + cFiles*sizeof(DWORD) +
                         cSegs*(sizeof(raSeg[0]) + sizeof(WORD)));
    sizeTotal = Round2Dword(sizeTotal);

    // Make second pass througth the source files and fill in
    // source module header

    for (pCurSrc = pSrcLines, xFile = 0, xSeg = 0; xFile < cFiles && pCurSrc; xFile++, pCurSrc = pCurSrc->next)
    {
        fileBase[xFile] = sizeTotal;

        // Add the size of this source file information:
        //
        // Source file header:
        //
        //  +------+------+------------+--------------+------+-------------+
        //  | WORD | WORD | cSeg*DWORD | 2*cSeg*DWORD | BYTE | cbName*BYTE |
        //  +------+------+------------+--------------+------+-------------+
        //

        sizeTotal += (2*sizeof(WORD) +
                      pCurSrc->cSegs*(sizeof(DWORD) + sizeof(raSeg[0])) +
                      sizeof(BYTE) + pCurSrc->fname[0]);

        // Pad to DWORD boundary

        sizeTotal = Round2Dword(sizeTotal);

        // Walk code segment list

        for (pCurGsn = pCurSrc->pGsnFirst; pCurGsn; pCurGsn = pCurGsn->next, xSeg++)
        {
            raSeg[xSeg].raStart = pCurGsn->raStart;
            raSeg[xSeg].raEnd   = pCurGsn->raEnd;
            segNo[xSeg]         = pCurGsn->seg;

            // Add size of the offset/line table
            //
            //  +------+------+-------------+------------+
            //  | WORD | WORD | cLine*DWORD | cLine*WORD |
            //  +------+------+-------------+------------+

            sizeTotal += (2*sizeof(WORD) +
                          pCurGsn->cLines*(sizeof(DWORD) + sizeof(WORD)));

            // Pad to DWORD boundary

            sizeTotal = Round2Dword(sizeTotal);
        }
    }

    // Write source module header

    counts[0] = cFiles;
    counts[1] = cSegs;
    WriteCopy(counts, sizeof(counts));
    WriteCopy(fileBase, cFiles*sizeof(DWORD));
    WriteCopy(raSeg, cSegs*sizeof(RAPAIR));
    WriteCopy(segNo, cSegs*sizeof(WORD));

    // Pad to DWORD boundary

    Pad2Dword();

    // Make third pass througth the source files and fill in
    // the source file header and write offset/line pairs

    for (pCurSrc = pSrcLines, srcLnBase = fileBase[0]; pCurSrc != NULL;
         pCurSrc = pCurSrc->next, xFile++)
    {
        // Add the size of source file header:
        //
        //  +------+------+------------+--------------+------+-------------+
        //  | WORD | WORD | cSeg*DWORD | 2*cSeg*DWORD | BYTE | cbName*BYTE |
        //  +------+------+------------+--------------+------+-------------+
        //

        srcLnBase += (2*sizeof(WORD) +
                      pCurSrc->cSegs*(sizeof(DWORD) + sizeof(raSeg[0])) +
                      sizeof(BYTE) + pCurSrc->fname[0]);

        // Round to DWORD boundary

        srcLnBase = Round2Dword(srcLnBase);

        // Walk code segment list and store base offsets for source
        // line offset/line pairs and record start/stop offsets of
        // code segments

        for (xSeg = 0, pCurGsn = pCurSrc->pGsnFirst; pCurGsn != NULL;
             pCurGsn = pCurGsn->next, xSeg++)
        {
            fileBase[xSeg] = srcLnBase;
            srcLnBase += (2*sizeof(WORD) +
                          pCurGsn->cLines*(sizeof(DWORD) + sizeof(WORD)));

            // Round to DWORD boundary

            srcLnBase = Round2Dword(srcLnBase);
            raSeg[xSeg].raStart = pCurGsn->raStart;
            raSeg[xSeg].raEnd   = pCurGsn->raEnd;
        }

        // Write source file header

        counts[0] = (WORD) pCurSrc->cSegs;
        counts[1] = 0;
        WriteCopy(counts, sizeof(counts));
        WriteCopy(fileBase, pCurSrc->cSegs*sizeof(DWORD));
        WriteCopy(raSeg, pCurSrc->cSegs*sizeof(RAPAIR));
        WriteCopy(pCurSrc->fname, pCurSrc->fname[0] + 1);

        // Pad to DWORD boundary

        Pad2Dword();

        // Walk code segment list and write offsets/line pairs

        for (pCurGsn = pCurSrc->pGsnFirst; pCurGsn != NULL; pCurGsn = pCurGsn->next)
        {
            // Write segment index and number of offset/line pairs

            counts[0] = pCurGsn->seg;
            counts[1] = pCurGsn->cLines;
            WriteCopy(counts, sizeof(counts));

            // Write offsets

            for (pLine = pCurGsn->pLineFirst; pLine != NULL; pLine = pLine->next)
                WriteCopy(&(pLine->rgOff), pLine->cPair * sizeof(DWORD));

            // Write line numbers

            for (pLine = pCurGsn->pLineFirst; pLine != NULL; pLine = pLine->next)
                WriteCopy(&(pLine->rgLn), pLine->cPair * sizeof(WORD));

            // Pad to DWORD boundary

            Pad2Dword();

            // Free memory

            for (pLine = pCurGsn->pLineFirst; pLine != NULL;)
            {
                pTmp = pLine->next;
                FFREE(pLine);
                pLine = pTmp;
            }
        }
    }
    return(sizeTotal);
}


/*** SaveCode - save code segment information in MODULES entry
*
* Purpose:
*   For every module (.OBJ file) save the information about code segments
*   this module contributes to.  COMDATs are threated as contibutions to
*   the logical segment, so each gets its entry in the CVCODE list attached
*   to the given .OBJ file (module).
*
* Input:
*   gsn     - global segment index of logical segment to which this module
*             contributes
*   cb      - size (in bytes) of contribution
*   raInit  - offset of the contribution inside the logical segment; this
*             nonzero only for COMDATs.
*
* Output:
*   No explicit value is returned. The list of CVCODE attached to the
*   .OBJ file (module) is updated.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void                    SaveCode(SNTYPE gsn, DWORD cb, DWORD raInit)
{
    CVCODE FAR          *pSegCur;       // Pointer to the current code segment
    APROPFILEPTR        apropFile;

    apropFile = (APROPFILEPTR) vrpropFile;

    // Save code segment if module has CV info

    pSegCur = (CVCODE FAR *) GetMem(sizeof(CVCODE));

    // Store LOGICAL segment, offset and size of the contribution

    pSegCur->seg = mpgsnseg[gsn];
    if (raInit != 0xffffffffL)
        pSegCur->ra = raInit;
    else
        pSegCur->ra = mpgsndra[gsn] - mpsegraFirst[mpgsnseg[gsn]];
    pSegCur->cb = cb;

    // Add to the CV code list

    if (apropFile->af_Code == NULL)
        apropFile->af_Code = pSegCur;
    else
        apropFile->af_CodeLast->next = pSegCur;
    apropFile->af_CodeLast = pSegCur;
    apropFile->af_cCodeSeg++;
}

    /****************************************************************
    *                                                               *
    *  DO SYMBOLIC DEBUG STUFF FOR MODULE JUST PROCESSED.           *
    *  Pass 2.                                                      *
    *                                                               *
    ****************************************************************/

void                    DebMd2(void)
{
    APROPFILEPTR        apropFile;

    sbLastModule[0] = 0;                /* Force recognition of new THEADR  */
    apropFile = (APROPFILEPTR) vrpropFile;
    if (apropFile->af_cvInfo)
        ++segDebLast;
}

/*** PutDnt - store subsection directory entry in the table
*
* Purpose:
*   Copy current subsection directory to the DNT table. If no more
*   room in the table reallocate table doubling its size.
*
* Input:
*   - pDnt    - pointer to the current directory entry
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         PutDnt(DNT *pDnt)
{
    WORD                newSize;
    if (dntMac >= dntMax)
    {
        if(dntMax)
        {
            newSize = dntMax << 1;
#if defined(M_I386) || defined( _WIN32 )
            rgDnt = (DNT *) REALLOC(rgDnt, newSize * sizeof(DNT));
#else
            rgDnt = (DNT FAR *) _frealloc(rgDnt, newSize * sizeof(DNT));
#endif
        }
        else
        {
            newSize = DNT_START;
            rgDnt = (DNT*) GetMem ( newSize * sizeof(DNT) );
        }
        if (rgDnt == NULL)
            Fatal(ER_memovf);
        dntMax = newSize;
    }



    rgDnt[dntMac] = *pDnt;
    dntMac++;
#if CVDEBUG
    DumpDNT(pDnt);
#endif
}

#pragma check_stack(on)

/*** OutModule - write out module subsection
*
* Purpose:
*   Write into the executable file the module subsections for all
*   object files compiled with CV information. Only CV 4.0 format.
*
* Input:
*   - apropFile - pointer to the current object file descriptor
*
* Output:
*   No explicit value is retuned.
*   Side effects:
*       - module subsections in executable file
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        OutModule(APROPFILEPTR apropFile)
{
    SBTYPE              sbName;
    SSTMOD4             module;
    CVCODE FAR          *pSegCur;
    CODEINFO            codeOnt;
    WORD                cOnt;


    module.ovlNo = (WORD) apropFile->af_iov;
    module.iLib  = (WORD) (apropFile->af_ifh + 1);
    module.cSeg  = apropFile->af_cCodeSeg;
    module.style[0] = 'C';
    module.style[1] = 'V';

    // Get file name or library module name

    if (apropFile->af_ifh != FHNIL && apropFile->af_rMod != RHTENIL)
        GetName((AHTEPTR) apropFile->af_rMod, sbName);
    else
        GetName((AHTEPTR) apropFile, sbName);

#if CVDEBUG
    sbName[sbName[0]+1] = '\0';
    fprintf(stdout, "\r\nCV info for %s\r\n", &sbName[1]);
#endif

    // Write sstModule header followed by the list of code contributions

    WriteCopy(&module, sizeof(SSTMOD4));
    pSegCur = apropFile->af_Code;
    codeOnt.pad = 0;
    for (cOnt = 0; cOnt < module.cSeg && pSegCur; cOnt++, pSegCur = pSegCur->next)
    {
        codeOnt.seg   = pSegCur->seg;
        codeOnt.off   = pSegCur->ra;
        codeOnt.cbOnt = pSegCur->cb;
        WriteCopy(&codeOnt, sizeof(CODEINFO));
#if CVDEBUG
        fprintf(stdout, "    Logical segment %d; offset 0x%lx; size 0x%lx\r\n",
                             codeOnt.seg, codeOnt.off, codeOnt.cbOnt);
#endif
    }

    // Write object file name

    WriteCopy(sbName, B2W(sbName[0]) + 1);
    return(sizeof(SSTMOD4) + B2W(sbName[0]) + 1 + module.cSeg * sizeof(CODEINFO));
}


/*** OutPublics - write sstPublics subsection
*
* Purpose:
*   Write sstPublics subsection of the CV information. The subsection
*   conforms to the new CV 4.0 format.
*
* Input:
*   - firstPub - virtual pointer to the list of public symbols defined
*                in a given object module
*
* Output:
*   Total size of the subsection in bytes.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        OutPublics(RBTYPE firstPub)
{
    PUB16               pub16;          // CV public descriptor - 16-bit
    PUB32               pub32;          // CV public descriptor - 32-bit
    APROPNAMEPTR        apropPub;       // Real pointer to public descriptor
    APROPSNPTR          apropSn;        // Real pointer to segment descriptor
    RBTYPE              curPub;         // Virtual pointer to the current public symbol
    WORD                f32Bit;         // TRUE if public defined in 32-bit segment
    DWORD               sizeTotal;      // Total size of subsection
    SNTYPE              seg;            // Symbol base
    RATYPE              ra;             // Symbol offset
    WORD                CVtype;         // CV info type index
    SBTYPE              sbName;         // Public symbol
    char                *pPub;
    WORD                len;


    // Initialize

    curPub    = firstPub;
    pub16.idx = S_PUB16;
    pub32.idx = S_PUB32;
    sizeTotal = 1L;
    WriteCopy(&sizeTotal, sizeof(DWORD));// sstPublicSym signature
    sizeTotal = sizeof(DWORD);
    while (curPub != 0L)
    {
        f32Bit = FALSE;
        apropPub = (APROPNAMEPTR) FETCHSYM(curPub, FALSE);
        curPub   = apropPub->an_sameMod;
        if (apropPub->an_attr == ATTRALIAS)
            apropPub = (APROPNAMEPTR) FETCHSYM(((APROPALIASPTR) apropPub)->al_sym, FALSE);

        if (apropPub->an_attr != ATTRPNM)
            continue;

        ra = apropPub->an_ra;
        if (apropPub->an_gsn)           // If not absolute symbol
        {
            seg    = mpgsnseg[apropPub->an_gsn];
            // If this is a .com program and the segment is the one
            // moved by 0x100, adjust accordingly the SegMap entry
            if(seg == segAdjCom)
            {
#if FALSE
                GetName((AHTEPTR) apropPub, sbName);
                sbName[sbName[0]+1] = '\0';
                fprintf(stdout, "\r\nCorrecting public %s : %lx -> %lx", sbName+1, ra, ra+0x100);
                fflush(stdout);
#endif
                ra += 0x100;
            }

            CVtype = 0;                 // Should be this apropPub->an_CVtype
                                        // but cvpack can't handle it.
#if O68K
            if (iMacType == MAC_NONE)
#endif
                ra -= mpsegraFirst[seg];
#if CVDEBUG
            GetName((AHTEPTR) apropPub, sbName);
            sbName[sbName[0]+1] = '\0';
            fprintf(stdout, "'%s' --> logical address %2x:%lx; physical address %2x:%lx\r\n",
                             &sbName[1], seg, ra, mpsegsa[seg], apropPub->an_ra);
#endif
            apropSn = (APROPSNPTR) FETCHSYM(mpgsnrprop[apropPub->an_gsn], FALSE);
#if EXE386
            f32Bit = TRUE;
#else
            f32Bit = (WORD) Is32BIT(apropSn->as_flags);
#endif
        }
        else
        {
            seg = 0;                    // Else no base
            CVtype = T_ABS;             // CV absolute symbol type
            f32Bit = (WORD) (ra > LXIVK);
        }

        GetName((AHTEPTR) apropPub, sbName);

        if (f32Bit)
        {
            pub32.len  = (WORD) (sizeof(PUB32) + B2W(sbName[0]) + 1 - sizeof(WORD));
            pub32.off  = ra;
            pub32.seg  = seg;
            pub32.type = CVtype;
            pPub       = (char *) &pub32;
            len        = sizeof(PUB32);
        }
        else
        {
            pub16.len  = (WORD) (sizeof(PUB16) + B2W(sbName[0]) + 1 - sizeof(WORD));
            pub16.off  = (WORD) ra;
            pub16.seg  = seg;
            pub16.type = CVtype;
            pPub       = (char *) &pub16;
            len        = sizeof(PUB16);
        }
        WriteCopy(pPub, len);

        // Output length-prefixed name

        WriteCopy(sbName, sbName[0] + 1);
        sizeTotal += (len + B2W(sbName[0]) + 1);
    }
    return(sizeTotal);
}

/*** OutSegMap - write segment map
*
* Purpose:
*   This subsection was introduced in CV 4.0. This subsection
*   maps the logical segments to physical segments. It also gives
*   the names and sizes of each logical segment.
*
* Input:
*   No explicit value is passed.
*   Global variables:
*   - mpsegsa   - table mapping logical segment number to its physical
*                 segment number or address
*   - mpsaflags - table mapping physicla segment index to its flags
*   - mpseggsn  - table mapping the logical segment index to its global
*                 segment index
*   - mpgsnprop - table mapping global segment index to its symbol table
*                 descriptor
*   - mpggrgsn  - table mapping global group index to global segment index
*   - mpggrrhte - table mapping global group index to group name
*
* Output:
*   Function returns the size of segment map.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        OutSegMap(void)
{
    SEGTYPE             seg;            // Logical segment index
    APROPSNPTR          apropSn;        // Real pointer to logical segment descriptor
    SATYPE              sa;             // Physical segment index
    WORD                iName;          // Index to free space in segment name table
    DWORD               sizeTotal;      // Total size of the subsection
    SEGINFO             segInfo;        // CV segment descriptor
    SBTYPE              segName;        // Segment name
    AHTEPTR             ahte;           // Real pointer to symbol table hash table
    RBTYPE              vpClass;        // Virtual pointer to class descriptor
    GRTYPE              ggr;            // Global group index
    SATYPE              saDGroup;       // DGroup's sa
    WORD                counts[2];

    iName = 0;
    counts[0] = (WORD) (segLast + ggrMac - 1);
    counts[1] = (WORD) segLast;
    WriteCopy(counts, sizeof(counts));
    sizeTotal = sizeof(counts);

    saDGroup = mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]];

    // Write all logical segments

    for (seg = 1; seg <= segLast; ++seg)// For all logical segments
    {
        memset(&segInfo, 0, sizeof(SEGINFO));

        if (fNewExe)
            segInfo.flags.fSel = TRUE;

        sa = mpsegsa[seg];

        if (fNewExe)
        {
#if EXE386
            segInfo.flags.f32Bit = TRUE;
#else
            segInfo.flags.f32Bit = (WORD) (Is32BIT(mpsaflags[sa]));
#endif

            if (IsDataFlg(mpsaflags[sa]))
            {
                segInfo.flags.fRead = TRUE;
#if EXE386
                if (IsWRITEABLE(mpsaflags[sa]))
#else
                if (!(mpsaflags[sa] & NSEXRD))
#endif
                    segInfo.flags.fWrite = TRUE;
            }
            else
            {
                segInfo.flags.fExecute = TRUE;

#if EXE386
                if (IsREADABLE(mpsaflags[sa]))
#else
                if (!(mpsaflags[sa] & NSEXRD))
#endif
                    segInfo.flags.fRead = TRUE;
            }
        }
        else
        {
            if (mpsegFlags[seg] & FCODE)
            {
                segInfo.flags.fRead    = TRUE;
                segInfo.flags.fExecute = TRUE;
            }
            else
            {
                segInfo.flags.fRead    = TRUE;
                segInfo.flags.fWrite   = TRUE;
            }
        }

        // Look up segment definition

        apropSn = (APROPSNPTR) FETCHSYM(mpgsnrprop[mpseggsn[seg]], FALSE);
        vpClass = apropSn->as_rCla;
#if OVERLAYS
        if (!fNewExe)
            segInfo.ovlNbr = apropSn->as_iov;
#endif
        // if segment doesn't belong to any group it's ggr is 0
        if (apropSn->as_ggr != GRNIL)
            segInfo.ggr = (WORD) (apropSn->as_ggr + segLast - 1);

        // If segment is a DGROUP member, write DGROUP normalized address

        if(apropSn->as_ggr == ggrDGroup)
        {
            segInfo.sa     = saDGroup;
            segInfo.phyOff = mpsegraFirst[seg] + ((sa - saDGroup) << 4);
        }
        else
        {
            segInfo.sa     = sa;
            segInfo.phyOff = mpsegraFirst[seg];
        }
        // If this is a .com program and the segment is the one moved by 0x100
        // write all the publics at the original addresses, because the offset
        // adjustment will be made in the SegMap table
        if(seg == segAdjCom)
        {
            segInfo.phyOff -= 0x100;
        }
        segInfo.cbSeg    = apropSn->as_cbMx;
        GetName((AHTEPTR) apropSn, segName);
        if (segName[0] != '\0')
        {
            segInfo.isegName = iName;
            iName += (WORD) (B2W(segName[0]) + 1);
        }
        else
            segInfo.isegName = 0xffff;
        ahte = (AHTEPTR) FETCHSYM(vpClass, FALSE);
        if (ahte->cch[0] != 0)
        {
            segInfo.iclassName = iName;
            iName += (WORD) (B2W(ahte->cch[0]) + 1);
        }
        else
            segInfo.iclassName = 0xffff;
        WriteCopy(&segInfo, sizeof(SEGINFO));
        sizeTotal += sizeof(SEGINFO);
    }

    // Write all groups

    for (ggr = 1; ggr < ggrMac; ggr++)
    {
        memset(&segInfo, 0, sizeof(SEGINFO));

        segInfo.flags.fGroup = TRUE;

        if (fNewExe)
            segInfo.flags.fSel = TRUE;

        segInfo.sa  = mpsegsa[mpgsnseg[mpggrgsn[ggr]]];

        if (fNewExe)
            segInfo.cbSeg = mpsacb[segInfo.sa];
        else
        {
            segInfo.cbSeg = 0L;
            if (mpggrgsn[ggr] != SNNIL)
            {
                // If group has members

                for (seg = 1; seg <= segLast; seg++)
                {
                    apropSn = (APROPSNPTR) FETCHSYM(mpgsnrprop[mpseggsn[seg]], FALSE);
                    if (apropSn->as_ggr == ggr)
                    {
                        segInfo.cbSeg += apropSn->as_cbMx;
#if OVERLAYS
                        segInfo.ovlNbr = apropSn->as_iov;
#endif
                    }
                }
            }
        }
        segInfo.isegName = iName;
        ahte = (AHTEPTR) FETCHSYM(mpggrrhte[ggr], FALSE);
        iName += (WORD) (B2W(ahte->cch[0]) + 1);
        segInfo.iclassName = 0xffff;
        WriteCopy(&segInfo, sizeof(SEGINFO));
        sizeTotal += sizeof(SEGINFO);
    }
    return(sizeTotal);
}

/*** OutSegNames - write segment name table
*
* Purpose:
*   This subsection was introduced in CV 4.0.
*   The segment name subsection contains all of the logical segment,
*   class and group names. Each name is a zero terminated ASCII string.
*
* Input:
*   No explicit value is passed.
*   Global variables:
*   - mpseggsn  - table mapping the logical segment index to its global
*                 segment index
*   - mpgsnprop - table mapping global segment index to its symbol table
*                 descriptor
*   - mpggrrhte - table mapping global group index to group name
*
* Output:
*   Function returns the size of segment name table.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL DWORD NEAR        OutSegNames(void)
{
    SEGTYPE             seg;            // Logical segment index
    APROPSNPTR          apropSn;        // Real pointer to logical segment descriptor
    DWORD               sizeTotal;      // Size of the segment name table
    SBTYPE              name;           // A name
    RBTYPE              vpClass;        // Virtual pointer to class descriptor
    GRTYPE              ggr;            // Global group index



    sizeTotal = 0L;

    // Write names of all logical segments

    for (seg = 1; seg <= segLast; ++seg)
    {
        // Look up segment definition

        apropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[mpseggsn[seg]], FALSE);
        vpClass = apropSn->as_rCla;
        GetName((AHTEPTR) apropSn, name);
        WriteCopy(&name[1], B2W(name[0]) + 1);
        sizeTotal += (B2W(name[0]) + 1);
        GetName((AHTEPTR ) FETCHSYM(vpClass, FALSE), name);
        WriteCopy(&name[1], B2W(name[0]) + 1);
        sizeTotal += (B2W(name[0]) + 1);
    }

    // Write names of all groups

    for (ggr = 1; ggr < ggrMac; ggr++)
    {
        GetName((AHTEPTR ) FETCHSYM(mpggrrhte[ggr], FALSE), name);
        WriteCopy(&name[1], B2W(name[0]) + 1);
        sizeTotal += (B2W(name[0]) + 1);
    }
    return(sizeTotal);
}

/*** OutSst - write subsections
*
* Purpose:
*   For every object file with CV information write its sstModule,
*   sstTypes, sstPublics, sstSymbols and sstSrcModule.
*   Build subsection directory.
*
* Input:
*   No explicit value is passed.
*   Global variables used:
*       - rprop1stFile - virtual pointer to the first object file descriptor
*
* Output:
*   No explicit value is returned.
*   Side effects:
*       - subsections in the executable file
*       - subsection directory in the VM
*
* Exceptions:
*   I/O errors - display error message and quit
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         OutSst(void)
{
    APROPFILEPTR        apropFile;      // Real pointer to file entry
    RBTYPE              rbFileNext;     // Virtual pointer the next file descriptor
    struct dnt          dntCur;         // Current subsection directory entry
    CVINFO FAR          *pCvInfo;       // Pointer to the CV info descriptor

#if CVPACK_SHARED
#if REVERSE_MODULE_ORDER_FOR_CVPACK
 
    RBTYPE              rbFileCur;
    RBTYPE              rbFileLast;

    // reverse module list in place
    // I've been waiting all my life to actually *need* this code... [rm]

    // this will cause us to write the modules tables in REVERSE order
    // (this gives better swapping behaviour in the cvpack phase
    // because the modules cvpack will visit first will be the ones that
    // are still resident...

    rbFileCur  = rprop1stFile;
    rbFileLast = NULL;
    while (rbFileCur != NULL)
    {
        apropFile  = (APROPFILEPTR ) FETCHSYM(rbFileCur, TRUE);
        rbFileNext = apropFile->af_FNxt;// Get pointer to next file
        apropFile->af_FNxt = rbFileLast;
        rbFileLast = rbFileCur;
        rbFileCur  = rbFileNext;
    }
    rprop1stFile = rbFileLast;
#endif

#endif

    rbFileNext = rprop1stFile;
    dntCur.iMod = 1;
    while (rbFileNext != NULL)          // For every module
    {
        apropFile = (APROPFILEPTR ) FETCHSYM(rbFileNext, TRUE);
        rbFileNext = apropFile->af_FNxt;// Get pointer to next file

        // Skip this module if no debug info for it

        if (!apropFile->af_cvInfo && !apropFile->af_publics && !apropFile->af_Src)
            continue;

        pCvInfo = apropFile->af_cvInfo;

        // sstModules

        dntCur.sst  = SSTMODULES4;
        dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
        dntCur.cb   = OutModule(apropFile);
        PutDnt(&dntCur);

        // sstTypes

        if (pCvInfo && pCvInfo->cv_cbTyp > 0L)
        {
            Pad2Dword();
            if (apropFile->af_flags & FPRETYPES)
                dntCur.sst = SSTPRETYPES;
            else
                dntCur.sst = SSTTYPES4;
            dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
            dntCur.cb   = pCvInfo->cv_cbTyp;
            WriteNocopy(pCvInfo->cv_typ, pCvInfo->cv_cbTyp);
            IF_NOT_CVPACK_SHARED(FFREE(pCvInfo->cv_typ));
            PutDnt(&dntCur);
        }

        // sstPublics

        if (apropFile->af_publics && !fSkipPublics)
        {
            Pad2Dword();
            dntCur.sst  = SSTPUBLICSYM;
            dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
            dntCur.cb   = OutPublics(apropFile->af_publics);
            PutDnt(&dntCur);
        }

        // sstSymbols

        if (pCvInfo && pCvInfo->cv_cbSym > 0L)
        {
            Pad2Dword();
            dntCur.sst  = SSTSYMBOLS4;
            dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
            dntCur.cb   = pCvInfo->cv_cbSym;
            WriteNocopy(pCvInfo->cv_sym, pCvInfo->cv_cbSym);
            IF_NOT_CVPACK_SHARED(FFREE(pCvInfo->cv_sym));
            PutDnt(&dntCur);
        }

        // sstSrcModule

        if (apropFile->af_Src)
        {
            Pad2Dword();
            dntCur.sst  = SSTSRCMODULE;
            dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
            dntCur.cb   = OutSrcModule(apropFile->af_Src);
            PutDnt(&dntCur);
        }

        dntCur.iMod++;
    }

    // sstLibraries

    Pad2Dword();
    dntCur.sst  = SSTLIBRARIES4;
    dntCur.iMod = (short) 0xffff;
    dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
    dntCur.cb   = OutLibSec();
    PutDnt(&dntCur);

    // sstSegMap

    Pad2Dword();
    dntCur.sst  = SSTSEGMAP;
    dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
    dntCur.cb   = OutSegMap();
    PutDnt(&dntCur);

    // sstSegNames

    Pad2Dword();
    dntCur.sst  = SSTSEGNAME;
    dntCur.lfo  = FTELL_BSRUNFILE() - lfaBase;
    dntCur.cb   = OutSegNames();
    PutDnt(&dntCur);
    FFREE(fileBase);
    FFREE(raSeg);
    FFREE(segNo);
}

#pragma check_stack(off)

/*
 *  OutLibSec : Output sstLibraries subsection to bsRunfile
 *
 *      Path prefix is stripped from library name.
 *      If no libraries, don't output anything.
 *
 *      Parameters:  none
 *      Returns:  Number of bytes in Libraries subsection
 */
LOCAL int NEAR          OutLibSec ()
{
    WORD                ifh;
    AHTEPTR             ahte;
    int                 cb = 0;
    BYTE                *pb;

    if (ifhLibMac == 0)
        return(0);

    // Libraries subsection consists of a list of library
    // names which will be indexed by library numbers in the
    // sstModules.  Those indexes are 1-based.

    // cb == 0, use it to write a single byte
    WriteCopy(&cb, 1);          // 0th entry is null for now
    
    cb++;
    for (ifh = 0; ifh < ifhLibMac; ifh++)
    {
        if (mpifhrhte[ifh] != RHTENIL)
        {
            ahte = (AHTEPTR) FETCHSYM(mpifhrhte[ifh],FALSE);
#if OSXENIX
            pb = GetFarSb(ahte->cch);
#else
            pb = StripDrivePath(GetFarSb(ahte->cch));
#endif
        }
        else
            pb = "";
        WriteCopy(pb, pb[0] + 1);
        cb += 1 + B2W(pb[0]);
    }
    return(cb);
}

/*** OutDntDir - write subsection directory
*
* Purpose:
*   Write subsection directory
*
* Input:
*   No explicit value is passed.
*   Global variables:
*       - dntPageMac - number of VM pages with DNTs
*
* Output:
*   Function returns the size of the directory in bytes.
*
* Exceptions:
*   I/O problems - display error message and quit
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL DWORD NEAR        OutDntDir(void)
{
    DNTHDR              hdr;            // Directory header


    hdr.cbDirHeader = sizeof(DNTHDR);
    hdr.cbDirEntry  = sizeof(DNT);
    hdr.cDir        = dntMac;
    hdr.lfoDirNext  = 0L;
    hdr.flags       = 0L;

    // Write header

    WriteCopy(&hdr, sizeof(DNTHDR));

    // Write directory

    WriteCopy((char FAR *) rgDnt, dntMac * sizeof(DNT));
    FFREE(rgDnt);
    return(sizeof(DNTHDR) + dntMac * sizeof(DNT));
}

/*** OutDebSection - allow debugging
*
* Purpose:
*   Append to the executable file the CV information. ONLY CV 4.00
*   format supported.
*
* Input:
*   No explicit value is passed.
*   Global variables:
*       - too many to list
*
* Output:
*   No explicit value is returned.
*   Side effects:
*       - what do you think ??
*
* Exceptions:
*   I/O problems - display error message and quit
*
* Notes:
*   None.
*
*************************************************************************/


void                    OutDebSections(void)
{
    long                lfaDir;         // File address of Directory
    DWORD               dirSize;        // Directory size
    long                tmp;


#if CVPACK_SHARED
    long *              plfoDir;        // pointer to directory data

    fseek(bsRunfile, 0L, 2);            // Go to end of file
    lfaBase = ftell(bsRunfile);         // Remember base address
    lposCur = lfaBase;                  // set current position...

    WriteCopy(szSignature, sizeof(szSignature)); // Signature dword
    WriteCopy(&tmp, sizeof(tmp));       // Skip lfoDir field
    plfoDir = (long *)rgbl[iblLim-1].pb;// remember address of lfoDir

    OutSst();                           // Output subsections

    lfaDir = lposCur;                   // Remember where directory starts

    *plfoDir = lfaDir - lfaBase;        // fix up lfoDir field

    dirSize = OutDntDir();              // Output subsection directory
    WriteCopy(szSignature, sizeof(szSignature));
                                        // Signature dword
    tmp = (lfaDir + dirSize + 2*sizeof(DWORD)) - lfaBase;
    WriteCopy(&tmp, sizeof(long));      // Distance from EOF to base

    // write out the bits that cvpack won't overwrite...

    if (fCVpack)
        WriteFlushSignature();
    else
        WriteFlushAll();

    cbRealBytes = ftell(bsRunfile);     // # of real bytes actually written
    lposMac = lposCur;
    iblCur  = iblNil;
#else
    fseek(bsRunfile, 0L, 2);            // Go to end of file
    lfaBase = FTELL_BSRUNFILE();        // Remember base address
    WriteExe(szSignature, sizeof(szSignature));
                                        // Signature dword
    fseek(bsRunfile,4L,1);              // Skip lfoDir field
    OutSst();                           // Output subsections
    lfaDir = FTELL_BSRUNFILE();         // Remember where directory starts
    fseek(bsRunfile, lfaBase + 4, 0);   // Go to lfoDir field
    tmp = lfaDir - lfaBase;
    WriteExe(&tmp, sizeof(long));       // Fix it up
    fseek(bsRunfile, lfaDir, 0);        // Go back to directory
    dirSize = OutDntDir();              // Output subsection directory
    WriteExe(szSignature, sizeof(szSignature));
                                        // Signature dword
    tmp = (lfaDir + dirSize + 2*sizeof(DWORD)) - lfaBase;
    WriteExe(&tmp, sizeof(long));       // Distance from EOF to base
    fseek(bsRunfile, 0L, 2);            // Seek to EOF just in case
#endif
}

#if CVPACK_SHARED

//
// write data to cvpack memory cache area
//

void
WriteSave(FTYPE fCopy, void *pb, UINT cb)
{
    if (!rgbl)
    {
        rgbl    = (BL *)GetMem(sizeof(BL) * C_BL_INIT);
        iblMac  = C_BL_INIT;
        iblLim  = 0;
    }

    // if this memory isn't going to stay around, then copy it
    if (fCopy)
    {
        void *pbT = (void *)GetMem(cb);
        memcpy(pbT, pb, cb);
        pb = pbT;
    }

    if (iblLim == iblMac)
    {
        BL *rgblT;

        rgblT   = (BL *)GetMem(sizeof(BL) * iblMac * 2);
        memcpy(rgblT, rgbl, sizeof(BL) * iblMac);
        iblMac  *= 2;
        FFREE(rgbl);
        rgbl = rgblT;
    }

    rgbl[iblLim].lpos = lposCur;
    rgbl[iblLim].pb   = pb;
    iblLim++;
    lposCur += cb;
}

// we want to write a few of the blocks because cvpack won't rewrite the
// first bit... [rm]

void WriteFlushSignature()
{
    int ibl, cb;

    // we know that the signature and offset are written in two pieces...
    // if this changes we need to change the magic '2' below [rm]

    for (ibl = 0; ibl < 2; ibl++)
    {
        cb = rgbl[ibl+1].lpos - rgbl[ibl].lpos;
        WriteExe(rgbl[ibl].pb, cb);
    }
}

void WriteFlushAll()
{
    int ibl, cb;

    for (ibl = 0; ibl < iblLim - 1; ibl++)
    {
        cb = rgbl[ibl+1].lpos - rgbl[ibl].lpos;
        WriteExe(rgbl[ibl].pb, cb);
    }

    cb = lposCur - rgbl[ibl].lpos;
    WriteExe(rgbl[ibl].pb, cb);
}

// the following are the various callback functions needed to support
// the cvpack library when we are attempting to not write out the
// unpacked types and symbols

#include <io.h>

extern int printf(char *,...);

int  __cdecl
link_chsize (int fh, long size)
{
    LINK_TRACE(printf("chsize(%06d, %08ld)\n", fh, size));

    // we must keep track of the new size so that we will correctly
    // process lseeks that are relative to the end of the file

    lposMac = size;

    return(_chsize(fh,size));
}


int  __cdecl
link_close (int x)
{
    LINK_TRACE(printf("close (%06d)\n", x));

    return(_close(x));
}

void __cdecl
link_exit (int x)
{
    LINK_TRACE(printf("exit  (%06d)\n", x));
#if USE_REAL
    RealMemExit();
#endif
    exit(x);
}

long __cdecl
link_lseek (int fh, long lpos, int mode)
{
    int ibl;

    LINK_TRACE(printf("lseek (%d, %08ld, %2d)\n", fh, lpos, mode));

    // if we have no cache blocks, just forward the request...
    // this will happen on a /CvpackOnly invocation

    if (rgbl == NULL)
        return _lseek(fh, lpos, mode);

    // adjust lpos so that we are always doing an absolute seek

    if (mode == 1)
        lpos = lposCur + lpos;
    else if (mode == 2)
        lpos = lposMac + lpos;

    // check for a bogus seek

    if (lpos > lposMac || lpos < 0)
    {
        // this used to be an internal error... but cvpack sometimes does
        // try to seek beyond the end of the file when it is trying to
        // distinguish a PE exe from an unsegmented DOS exe
        // instead of panicing, we just return failure

        return(-1);
    }

    // if we are in the midst of reading a block, then free that block
    // cvpack never reads the same data twice

    if (iblCur != iblNil)
    {
        // first check if we're in the header -- we might come back to that...
        if (rgbl[iblCur].lpos > cbRealBytes + CB_HEADER_SAVE)
        {
            long lposCurMin, lposCurMac;

            // check for a seek that is within the current bucket
            // in case we're skipping within the current block

            lposCurMin = rgbl[iblCur].lpos;

            if (iblCur < iblLim)
                lposCurMac = rgbl[iblCur+1].lpos;
            else
                lposCurMac = lposMac;

            if (lpos < lposCurMin || lpos >= lposCurMac)
            {
                FFREE(rgbl[iblCur].pb);
                rgbl[iblCur].pb = NULL;
            }
        }

    }

    // if this seek is not in the debug area of the .exe use the real lseek

    if (lpos < cbRealBytes)
    {
        iblCur = iblNil;
        lposCur = lpos;
        return(_lseek(fh,lpos,0));
    }

    // see if we are searching forward (the normal case)
    // if we are, search from the current block, otherwise search from
    // the start (linear search but OK because cvpack doesn't
    // jump around much, it just uses lseek to skip a few bytes here and
    // there)

    if (lpos > lposCur && iblCur != iblNil)
        ibl = iblCur;
    else
        ibl = 0;

    // set the current position

    lposCur = lpos;

    // loop through the buffered writes looking for the requested position

    for (; ibl < iblLim - 1; ibl++)
    {
        if (lpos >= rgbl[ibl].lpos && lpos < rgbl[ibl+1].lpos)
            break;      // found bucket
    }

    // set the bucket number, offset within the bucket, and number of bytes
    // left in the bucket

    iblCur  = ibl;
    ichCur  = lpos - rgbl[ibl].lpos;
    cbCur   = CbIbl(ibl) - ichCur;

    // check to make sure we haven't seeked back to a buffer that we already
    // freed...

    ASSERT(rgbl[iblCur].pb != NULL);

    // make sure we get the boundary case... if cvpack is requesting to go to
    // the end of the data that we have written then we MUST seek because
    // cvpack might be about to write out the packed stuff...

    if (lposCur == cbRealBytes)
        _lseek(fh, lpos, 0);

    // we set up the current position earlier... return it now

    return(lposCur);
}


int  __cdecl
link_open (const char * x, int y)
{
    LINK_TRACE(printf("open  (%s, %06d)\n", x, y));

    // setup the static variables to a safe state
    // the current position is the start of file and there is no buffer
    // active (iblCur = iblNil)

    iblCur = iblNil;
    lposCur = 0;

    return(_open(x,y));
}

int  __cdecl
link_read (int fh, char *pch, unsigned int cb)
{
    int cbRem;

    LINK_TRACE(printf("read  (%d, %06u)\n", fh, cb));

    if (rgbl == NULL)
        return _read(fh, pch, cb);

    // special case zero byte read, not really necessary but
    // avoids any potential problems with trying to setup empty
    // buffers etc. -- it should just fall out anyways but
    // just to be safe [rm]

    if (cb == 0)
        return 0;

    // if there is no buffer active, then just forward the read
    // note that if we are invoked with /CvpackOnly this test will
    // always succeed

    if (iblCur == iblNil)
    {
        if (lposCur + ((long)(unsigned long)cb) < cbRealBytes)
        {
            lposCur += cb;
            return(_read(fh,pch,cb));
        }
        else
        {
            int cbReal = cbRealBytes - lposCur;

            if (_read(fh, pch, cbReal) != cbReal)
                return -1;

            if (link_lseek(fh, cbRealBytes, 0) != cbRealBytes)
                return -1;

            // set the number of bytes remaining to be read in

            cbRem = cb - cbReal;
            pch  += cb - cbReal;
        }
    }
    else
    {
        // set the number of bytes remaining to be read in
        cbRem = cb;
    }

    while (cbRem)
    {
        // check if the number of bytes we need to read is less than
        // the number left in the current buffer

        if (cbRem <= cbCur)
        {
            // we can read all the remaining bytes from the current buffer
            // so do it.  Copy bytes and adjust the number of bytes left
            // in this buffer, the index into the buffer, and the current
            // position in the file

            memcpy(pch, rgbl[iblCur].pb+ichCur, cbRem);
            cbCur   -= cbRem;
            ichCur  += cbRem;
            lposCur += cbRem;

#ifdef DUMP_CVPACK_BYTES
            {
            int i;
            for (i=0;i<cb;i++)
                {
                if ((i&15) == 0)
                        printf("%04x: ", i);
                printf("%02x ", pch[i]);
                if ((i&15)==15)
                    printf("\n");
                }
            }
            if ((i&15))
                printf("\n");
#endif
            return cb;
        }
        else
        {
            // in this case, the read is bigger than the current buffer
            // we'll be reading the whole buffer and then moving to the
            // next buffer

        
            // first read in the rest of this buffer

            memcpy(pch, rgbl[iblCur].pb+ichCur, cbCur);

            // adjust the number of bytes remaining and the current file
            // position...

            pch     += cbCur;
            cbRem   -= cbCur;
            lposCur += cbCur;

            // we won't be coming back to this buffer, so return it to the
            // system and mark it as freed

            // first check if we're in the header -- we might come back to that
            if (rgbl[iblCur].lpos > cbRealBytes + CB_HEADER_SAVE)
            {
                FFREE(rgbl[iblCur].pb);
                rgbl[iblCur].pb = NULL;
            }

            // move forward to the next bucket, if there are no more buckets
            // then this is an ERROR -- we'll be returning the number of
            // bytes that we managed to read

            iblCur++;
            if (iblCur == iblLim)
            {
                iblCur = iblNil;
                break;
            }

            // check to make sure that we are not reading data that
            // we've already freed (yipe!)

            ASSERT(rgbl[iblCur].pb != NULL);

            // check to make sure that the current position agrees with
            // the position that this buffer is supposed to occur at

            ASSERT(lposCur == rgbl[iblCur].lpos);

            // ok, everything is safe now, set the index into the current
            // buffer and the number of bytes left in the buffer, then
            // run the loop again until we've read in all the bytes we need

            ichCur  = 0;
            cbCur   = CbIbl(iblCur);
        }
    }

    // return the number of bytes we actually read
    return cb - cbRem;
}

long __cdecl
link_tell (int x)
{
    LINK_TRACE(printf("tell  (%06d)\n", x));

    if (iblCur != iblNil)
        return(lposCur);

    return(_tell(x));
}


int  __cdecl
link_write (int x, const void * y, unsigned int z)
{
    LINK_TRACE(printf("write (%06d,%08lx,%06u)\n", x, y, z));

    return(_write(x,y,z));
}

#ifdef CVPACK_DEBUG_HELPER
void dumpstate()
{
    printf("lposCur= %d\n", lposCur);
    printf("iblCur = %d\n", iblCur);
    printf("ichCur = %d\n", ichCur);
    printf("cbReal = %d\n", cbRealBytes);
    printf("lposMac= %d\n", lposMac);
}
#endif

#else
#ifdef CVPACK_MONDO

#include <io.h>

int  __cdecl
link_chsize (int x, long y)
{
    return(_chsize(x,y));
}

int  __cdecl
link_close (int x)
{
    return(_close(x));
}

void __cdecl
link_exit (int x)
{
#if USE_REAL
    RealMemExit();
#endif
    exit(x);
}

long __cdecl
link_lseek (int x, long y, int  z)
{
    return(_lseek(x,y,z));
}


int  __cdecl
link_open (const char *x, int y)
{
    return(_open(x,y));
}

int  __cdecl
link_read (int x, void *y, unsigned int z)
{
    return(_read(x,y,z));
}

long __cdecl
link_tell (int x)
{
    return(_tell(x));
}


int  __cdecl
link_write (int x, const void * y, unsigned int z)
{
    return(_write(x,y,z));
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newdef.c ===
/*
 * Created by CSD YACC (IBM PC) from "newdef.y" */
# define T_FALIAS 257
# define T_KCLASS 258
# define T_KNAME 259
# define T_KLIBRARY 260
# define T_KBASE 261
# define T_KDEVICE 262
# define T_KPHYSICAL 263
# define T_KVIRTUAL 264
# define T_ID 265
# define T_NUMBER 266
# define T_KDESCRIPTION 267
# define T_KHEAPSIZE 268
# define T_KSTACKSIZE 269
# define T_KMAXVAL 270
# define T_KCODE 271
# define T_KCONSTANT 272
# define T_FDISCARDABLE 273
# define T_FNONDISCARDABLE 274
# define T_FEXEC 275
# define T_FFIXED 276
# define T_FMOVABLE 277
# define T_FSWAPPABLE 278
# define T_FSHARED 279
# define T_FMIXED 280
# define T_FNONSHARED 281
# define T_FPRELOAD 282
# define T_FINVALID 283
# define T_FLOADONCALL 284
# define T_FRESIDENT 285
# define T_FPERM 286
# define T_FCONTIG 287
# define T_FDYNAMIC 288
# define T_FNONPERM 289
# define T_KDATA 290
# define T_FNONE 291
# define T_FSINGLE 292
# define T_FMULTIPLE 293
# define T_KSEGMENTS 294
# define T_KOBJECTS 295
# define T_KSECTIONS 296
# define T_KSTUB 297
# define T_KEXPORTS 298
# define T_KEXETYPE 299
# define T_KSUBSYSTEM 300
# define T_FDOS 301
# define T_FOS2 302
# define T_FUNKNOWN 303
# define T_FWINDOWS 304
# define T_FDEV386 305
# define T_FMACINTOSH 306
# define T_FWINDOWSNT 307
# define T_FWINDOWSCHAR 308
# define T_FPOSIX 309
# define T_FNT 310
# define T_FUNIX 311
# define T_KIMPORTS 312
# define T_KNODATA 313
# define T_KOLD 314
# define T_KCONFORM 315
# define T_KNONCONFORM 316
# define T_KEXPANDDOWN 317
# define T_KNOEXPANDDOWN 318
# define T_EQ 319
# define T_AT 320
# define T_KRESIDENTNAME 321
# define T_KNONAME 322
# define T_STRING 323
# define T_DOT 324
# define T_COLON 325
# define T_COMA 326
# define T_ERROR 327
# define T_FHUGE 328
# define T_FIOPL 329
# define T_FNOIOPL 330
# define T_PROTMODE 331
# define T_FEXECREAD 332
# define T_FRDWR 333
# define T_FRDONLY 334
# define T_FINITGLOB 335
# define T_FINITINST 336
# define T_FTERMINST 337
# define T_FWINAPI 338
# define T_FWINCOMPAT 339
# define T_FNOTWINCOMPAT 340
# define T_FPRIVATE 341
# define T_FNEWFILES 342
# define T_REALMODE 343
# define T_FUNCTIONS 344
# define T_APPLOADER 345
# define T_OVL 346
# define T_KVERSION 347

# line 83
 /* SCCSID = %W% %E% */
#include                <minlit.h>
#include                <bndtrn.h>
#include                <bndrel.h>
#include                <lnkio.h>
#include                <newexe.h>
#if EXE386
#include                <exe386.h>
#endif
#include                <lnkmsg.h>
#include                <extern.h>
#include                <string.h>
#include                <impexp.h>

#define YYS_WD(x)       (x)._wd         /* Access macro */
#define YYS_BP(x)       (x)._bp         /* Access macro */
#define INCLUDE_DIR     0xffff          /* Include directive for the lexer */
#define MAX_NEST        7
#define IO_BUF_SIZE     512

/*
 *  FUNCTION PROTOTYPES
 */



LOCAL int  NEAR lookup(void);
LOCAL int  NEAR yylex(void);
LOCAL void NEAR yyerror(char *str);
LOCAL void NEAR ProcNamTab(long lfa,unsigned short cb,unsigned short fres);
LOCAL void NEAR NewProc(char *szName);
#if NOT EXE386
LOCAL void NEAR SetExpOrds(void);
#endif
LOCAL void NEAR NewDescription(unsigned char *sbDesc);
LOCAL APROPIMPPTR NEAR GetImport(unsigned char *sb);
#if EXE386
LOCAL void NEAR NewModule(unsigned char *sbModnam, unsigned char *defaultExt);
LOCAL void NEAR DefaultModule(unsigned char *defaultExt);
#else
LOCAL void NEAR NewModule(unsigned char *sbModnam);
LOCAL void NEAR DefaultModule(void);
#endif
#if AUTOVM
BYTE FAR * NEAR     FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM    FetchSym1
#define PROPSYMLOOKUP EnterName
#else
#define FETCHSYM    FetchSym
#define PROPSYMLOOKUP EnterName
#endif


int                     yylineno = -1;  /* Line number */
LOCAL FTYPE             fFileNameExpected;
LOCAL FTYPE             fMixed;
LOCAL FTYPE             fNoExeVer;
LOCAL FTYPE             fHeapSize;
LOCAL BYTE              *sbOldver;      /* Old version of the .EXE */
LOCAL FTYPE             vfAutodata;
LOCAL FTYPE             vfShrattr;
LOCAL BYTE              cDigits;
#if EXE386
LOCAL DWORD             offmask;        /* Seg flag bits to turn off */
LOCAL BYTE              fUserVersion = 0;
LOCAL WORD              expOtherFlags = 0;
LOCAL BYTE              moduleEXE[] = "\007A:\\.exe";
LOCAL BYTE              moduleDLL[] = "\007A:\\.dll";
#else
LOCAL WORD              offmask;        /* Seg flag bits to turn off */
#endif
#if OVERLAYS
LOCAL WORD              iOvl = NOTIOVL; // Overlay assigned to functions
#endif
LOCAL char              *szSegName;     // Segment assigned to functions
LOCAL WORD              nameFlags;      /* Flags associated with exported name */
LOCAL BSTYPE            includeDisp[MAX_NEST];
                                        // Include file stack
LOCAL short             curLevel;       // Current include nesting level
                                        // Zero means main .DEF file
LOCAL char              *keywds[] =     /* Keyword array */
                        {
                            "ALIAS",            (char *) T_FALIAS,
                            "APPLOADER",        (char *) T_APPLOADER,
                            "BASE",             (char *) T_KBASE,
                            "CLASS",            (char *) T_KCLASS,
                            "CODE",             (char *) T_KCODE,
                            "CONFORMING",       (char *) T_KCONFORM,
                            "CONSTANT",         (char *) T_KCONSTANT,
                            "CONTIGUOUS",       (char *) T_FCONTIG,
                            "DATA",             (char *) T_KDATA,
                            "DESCRIPTION",      (char *) T_KDESCRIPTION,
                            "DEV386",           (char *) T_FDEV386,
                            "DEVICE",           (char *) T_KDEVICE,
                            "DISCARDABLE",      (char *) T_FDISCARDABLE,
                            "DOS",              (char *) T_FDOS,
                            "DYNAMIC",          (char *) T_FDYNAMIC,
                            "EXECUTE-ONLY",     (char *) T_FEXEC,
                            "EXECUTEONLY",      (char *) T_FEXEC,
                            "EXECUTEREAD",      (char *) T_FEXECREAD,
                            "EXETYPE",          (char *) T_KEXETYPE,
                            "EXPANDDOWN",       (char *) T_KEXPANDDOWN,
                            "EXPORTS",          (char *) T_KEXPORTS,
                            "FIXED",            (char *) T_FFIXED,
                            "FUNCTIONS",        (char *) T_FUNCTIONS,
                            "HEAPSIZE",         (char *) T_KHEAPSIZE,
                            "HUGE",             (char *) T_FHUGE,
                            "IMPORTS",          (char *) T_KIMPORTS,
                            "IMPURE",           (char *) T_FNONSHARED,
                            "INCLUDE",          (char *) INCLUDE_DIR,
                            "INITGLOBAL",       (char *) T_FINITGLOB,
                            "INITINSTANCE",     (char *) T_FINITINST,
                            "INVALID",          (char *) T_FINVALID,
                            "IOPL",             (char *) T_FIOPL,
                            "LIBRARY",          (char *) T_KLIBRARY,
                            "LOADONCALL",       (char *) T_FLOADONCALL,
                            "LONGNAMES",        (char *) T_FNEWFILES,
                            "MACINTOSH",        (char *) T_FMACINTOSH,
                            "MAXVAL",           (char *) T_KMAXVAL,
                            "MIXED1632",        (char *) T_FMIXED,
                            "MOVABLE",          (char *) T_FMOVABLE,
                            "MOVEABLE",         (char *) T_FMOVABLE,
                            "MULTIPLE",         (char *) T_FMULTIPLE,
                            "NAME",             (char *) T_KNAME,
                            "NEWFILES",         (char *) T_FNEWFILES,
                            "NODATA",           (char *) T_KNODATA,
                            "NOEXPANDDOWN",     (char *) T_KNOEXPANDDOWN,
                            "NOIOPL",           (char *) T_FNOIOPL,
                            "NONAME",           (char *) T_KNONAME,
                            "NONCONFORMING",    (char *) T_KNONCONFORM,
                            "NONDISCARDABLE",   (char *) T_FNONDISCARDABLE,
                            "NONE",             (char *) T_FNONE,
                            "NONPERMANENT",     (char *) T_FNONPERM,
                            "NONSHARED",        (char *) T_FNONSHARED,
                            "NOTWINDOWCOMPAT",  (char *) T_FNOTWINCOMPAT,
                            "NT",               (char *) T_FNT,
                            "OBJECTS",          (char *) T_KOBJECTS,
                            "OLD",              (char *) T_KOLD,
                            "OS2",              (char *) T_FOS2,
                            "OVERLAY",          (char *) T_OVL,
                            "OVL",              (char *) T_OVL,
                            "PERMANENT",        (char *) T_FPERM,
                            "PHYSICAL",         (char *) T_KPHYSICAL,
                            "POSIX",            (char *) T_FPOSIX,
                            "PRELOAD",          (char *) T_FPRELOAD,
                            "PRIVATE",          (char *) T_FPRIVATE,
                            "PRIVATELIB",       (char *) T_FPRIVATE,
                            "PROTMODE",         (char *) T_PROTMODE,
                            "PURE",             (char *) T_FSHARED,
                            "READONLY",         (char *) T_FRDONLY,
                            "READWRITE",        (char *) T_FRDWR,
                            "REALMODE",         (char *) T_REALMODE,
                            "RESIDENT",         (char *) T_FRESIDENT,
                            "RESIDENTNAME",     (char *) T_KRESIDENTNAME,
                            "SECTIONS",         (char *) T_KSECTIONS,
                            "SEGMENTS",         (char *) T_KSEGMENTS,
                            "SHARED",           (char *) T_FSHARED,
                            "SINGLE",           (char *) T_FSINGLE,
                            "STACKSIZE",        (char *) T_KSTACKSIZE,
                            "STUB",             (char *) T_KSTUB,
                            "SUBSYSTEM",        (char *) T_KSUBSYSTEM,
                            "SWAPPABLE",        (char *) T_FSWAPPABLE,
                            "TERMINSTANCE",     (char *) T_FTERMINST,
                            "UNIX",             (char *) T_FUNIX,
                            "UNKNOWN",          (char *) T_FUNKNOWN,
                            "VERSION",          (char *) T_KVERSION,
                            "VIRTUAL",          (char *) T_KVIRTUAL,
                            "WINDOWAPI",        (char *) T_FWINAPI,
                            "WINDOWCOMPAT",     (char *) T_FWINCOMPAT,
                            "WINDOWS",          (char *) T_FWINDOWS,
                            "WINDOWSCHAR",      (char *) T_FWINDOWSCHAR,
                            "WINDOWSNT",        (char *) T_FWINDOWSNT,
                            NULL
                        };

# line 259

#define UNION 1
typedef union
{
#if EXE386
    DWORD               _wd;
#else
    WORD                _wd;
#endif
    BYTE                *_bp;
} YYSTYPE;
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256

#line 1256


LOCAL int NEAR          GetChar(void)
{
    int                 c;              /* A character */

    c = GetTxtChr(bsInput);
    if ((c == EOF || c == CTRL_Z) && curLevel > 0)
    {
        free(bsInput->_base);
        fclose(bsInput);
        bsInput = includeDisp[curLevel];
        curLevel--;
        c = GetChar();
    }
    return(c);
}

LOCAL int NEAR          lookup()        /* Keyword lookup */
{
    char                **pcp;          /* Pointer to character pointer */
    int                 i;              /* Comparison value */

    for(pcp = keywds; *pcp != NULL; pcp += 2)
    {                                   /* Look through keyword table */
                                        /* If found, return token type */
        if(!(i = _stricmp(&bufg[1],*pcp)))
        {
            YYS_WD(yylval) = 0;
            return((int) (__int64) pcp[1]);
        }
        if(i < 0) break;                /* Break if we've gone too far */
    }
    return(T_ID);                       /* Just your basic identifier */
}

LOCAL int NEAR          yylex()         /* Lexical analyzer */
{
    int                 c;              /* A character */
    int                 StrBegChr;      /* What kind of quotte found at the begin of string */
#if EXE386
    DWORD               x;              /* Numeric token value */
#else
    WORD                x;              /* Numeric token value */
#endif
    int                 state;          /* State variable */
    BYTE                *cp;            /* Character pointer */
    BYTE                *sz;            /* Zero-terminated string */
    static int          lastc = 0;      /* Previous character */
    char                *fileBuf;
    FTYPE               fFileNameSave;
    static int          NameLineNo;


    state = 0;                          /* Assume we're not in a comment */
    c = '\0';

    /* Loop to skip white space */

    for(;;)
    {
        lastc = c;
        if (((c = GetChar()) == EOF) || c == '\032' || c == '\377')
          return(EOF);                  /* Get a character */
        if (c == ';')
            state = TRUE;               /* If comment, set flag */
        else if(c == '\n')              /* If end of line */
        {
            state = FALSE;              /* End of comment */
            if(!curLevel)
                ++yylineno;             /* Increment line number count */
        }
        else if (state == FALSE && c != ' ' && c != '\t' && c != '\r')
            break;                      /* Break on non-white space */
    }

    /* Handle one-character tokens */

    switch(c)
    {
        case '.':                       /* Name separator */
          if (fFileNameExpected)
            break;
          return(T_DOT);

        case '@':                       /* Ordinal specifier */
        /*
         * Require that whitespace precede '@' if introducing an
         * ordinal, to allow '@' in identifiers.
         */
          if (lastc == ' ' || lastc == '\t' || lastc == '\r')
                return(T_AT);
          break;

        case '=':                       /* Name assignment */
          return(T_EQ);

        case ':':
          return(T_COLON);

        case ',':
          return(T_COMA);
    }

    /* See if token is a number */

    if (c >= '0' && c <= '9' && !fFileNameExpected)
    {                                   /* If token is a number */
        x = c - '0';                    /* Get first digit */
        c = GetChar();                  /* Get next character */
        if(x == 0)                      /* If octal or hex */
        {
            if(c == 'x' || c == 'X')    /* If it is an 'x' */
            {
                state = 16;             /* Base is hexadecimal */
                c = GetChar(); /* Get next character */
            }
            else state = 8;             /* Else octal */
            cDigits = 0;
        }
        else
        {
            state = 10;                 /* Else decimal */
            cDigits = 1;
        }
        for(;;)
        {
            if(c >= '0' && c <= '9' && c < (state + '0')) c -= '0';
            else if(state == 16 && c >= 'A' && c <= 'F') c -= 'A' - 10;
            else if(state == 16 && c >= 'a' && c <= 'f') c -= 'a' - 10;
            else break;
            cDigits++;
            x = x*state + c;
            c = (BYTE) GetChar();
        }
        ungetc(c,bsInput);
        YYS_WD(yylval) = x;
        return(T_NUMBER);
    }

    /* See if token is a string */

    if (c == '\'' || c == '"')          /* If token is a string */
    {
        StrBegChr = c;
        sz = &bufg[1];                  /* Initialize */
        for(state = 0; state != 2;)     /* State machine loop */
        {
            if ((c = GetChar()) == EOF)
                return(EOF);            /* Check for EOF */
            if (sz >= &bufg[sizeof(bufg)])
                Fatal(ER_dflinemax, sizeof(bufg));

            switch(state)               /* Transitions */
            {
                case 0:                 /* Inside quote */
                  if ((c == '\'' || c == '"') && c == StrBegChr)
                    state = 1;          /* Change state if quote found */
                  else
                    *sz++ = (BYTE) c;   /* Else save character */
                  break;

                case 1:                 /* Inside quote with quote */
                  if ((c == '\'' || c == '"'))
                  {                     /* If consecutive quotes */
                      *sz++ = (BYTE) c; /* Quote inside string */
                      state = 0;        /* Back to state 0 */
                  }
                  else
                    state = 2;          /* Else end of string */
                  break;
            }
        }
        ungetc(c,bsInput);              /* Put back last character */
        *sz = '\0';                     /* Null-terminate the string */
        x = (WORD)(sz - &bufg[1]);
        if (x >= SBLEN)                 /* Set length of string */
        {
            bufg[0] = 0xff;
            bufg[0x100] = '\0';
            OutWarn(ER_dfnamemax, &bufg[1]);
        }
        else
            bufg[0] = (BYTE) x;
        YYS_BP(yylval) = bufg;          /* Save ptr. to identifier */
        return(T_STRING);               /* String found */
    }

    /* Assume we have identifier */

    sz = &bufg[1];                      /* Initialize */
    if (fFileNameExpected && NameLineNo && NameLineNo != yylineno)
    {
        NameLineNo = 0;                 /* To avoid interference with INCLUDE */
        fFileNameExpected = FALSE;
    }
    for(;;)                             /* Loop to get i.d.'s */
    {
        if (fFileNameExpected)
            cp = " \t\r\n\f";
        else
            cp = " \t\r\n:.=';\032";
        while (*cp && *cp != (BYTE) c)
            ++cp;                       /* Check for end of identifier */
        if(*cp) break;                  /* Break if end of identifier found */
        if (sz >= &bufg[sizeof(bufg)])
            Fatal(ER_dflinemax, sizeof(bufg));
        *sz++ = (BYTE) c;               /* Save the character */
        if ((c = GetChar()) == EOF)
            break;                      /* Get next character */
    }
    ungetc(c,bsInput);                  /* Put character back */
    *sz = '\0';                         /* Null-terminate the string */
    x = (WORD)(sz - &bufg[1]);
    if (x >= SBLEN)                     /* Set length of string */
    {
        bufg[0] = 0xff;
        bufg[0x100] = '\0';
        OutWarn(ER_dfnamemax, &bufg[1]);
    }
    else
        bufg[0] = (BYTE) x;
    YYS_BP(yylval) = bufg;              /* Save ptr. to identifier */
    state = lookup();

    if (state == T_KNAME || state == T_KLIBRARY)
    {
        fFileNameExpected = TRUE;
        NameLineNo = yylineno;
    }

    if (state == INCLUDE_DIR)
    {
        // Process include directive

        fFileNameSave = fFileNameExpected;
        fFileNameExpected = (FTYPE) TRUE;
        state = yylex();
        fFileNameExpected = fFileNameSave;
        if (state == T_ID || state == T_STRING)
        {
            if (curLevel < MAX_NEST - 1)
            {
                curLevel++;
                includeDisp[curLevel] = bsInput;

                // Because LINK uses customized version of stdio
                // for every file we have not only open the file
                // but also allocate i/o buffer.

                bsInput = fopen(&bufg[1], RDBIN);
                if (bsInput == NULL)
                    Fatal(ER_badinclopen, &bufg[1], strerror(errno));
                fileBuf = GetMem(IO_BUF_SIZE);
#if OSMSDOS
                setvbuf(bsInput, fileBuf, _IOFBF, IO_BUF_SIZE);
#endif
                return(yylex());
            }
            else
                Fatal(ER_toomanyincl);
        }
        else
            Fatal(ER_badinclname);
    }
    else
        return(state);
}

LOCAL void NEAR         yyerror(str)
char                    *str;
{
    Fatal(ER_dfsyntax, str);
}

#if NOT EXE386
/*** AppLoader - define aplication specific loader
*
* Purpose:
*   Define application specific loader. Feature available only under
*   Windows.  Linker will create logical segment LOADER_<name> where
*   <name> is specified in APPLOADER statement. The LOADER_<name>
*   segment forms separate physical segment, which is placed by the linker
*   as the first segment in the .EXE file.  Whithin the loader segment,
*   the linker will create an EXTDEF of the name <name>.
*
* Input:
*   - sbName - pointer to lenght prefixed loader name
*
* Output:
*   No explicit value is returned. As a side effect the SEGDEF and
*   EXTDEF definitions are entered into linker symbol table.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         AppLoader(char *sbName)
{
    APROPSNPTR          apropSn;
    APROPUNDEFPTR       apropUndef;
    SBTYPE              segName;
    WORD                strLen;


    // Create loader segment name

    strcpy(&segName[1], "LOADER_");
    strcat(&segName[1], &sbName[1]);
    strLen = (WORD)strlen(&segName[1]);
    if (strLen >= SBLEN)
    {
        segName[0] = SBLEN - 1;
        segName[SBLEN] = '\0';
        OutWarn(ER_dfnamemax, &segName[1]);
    }
    else
        segName[0] = (BYTE) strLen;

    // Define loader logical segment and remember its GSN

    apropSn = GenSeg(segName, "\004CODE", GRNIL, (FTYPE) TRUE);
    gsnAppLoader = apropSn->as_gsn;
    apropSn->as_flags = dfCode | NSMOVE | NSPRELOAD;
    MARKVP();

    // Define EXTDEF

    apropUndef = (APROPUNDEFPTR ) PROPSYMLOOKUP(sbName, ATTRUND, TRUE);
    vpropAppLoader = vrprop;
    apropUndef->au_flags |= STRONGEXT;
    apropUndef->au_len = -1L;
    MARKVP();
    free(sbName);
}
#endif

/*** NewProc - fill in the COMDAT descriptor for ordered procedure
*
* Purpose:
*   Fill in the linkers symbol table COMDAT descriptor. This function
*   is called for new descriptors generated by FUNCTIONS list in the .DEF
*   file.  All COMDAT descriptors entered by this function form one
*   list linked via ac_order field. The head of this list is global
*   variable procOrder;
*
* Input:
*   szName    - pointer to procedure name
*   iOvl      - overlay number - global variable
*   szSegName - segment name - global variable
*
* Output:
*   No explicit value is returned. As a side effect symbol table entry
*   is updated.
*
* Exceptions:
*   Procedure already known - warning
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         NewProc(char *szName)
{
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT symbol table entry
    APROPCOMDATPTR      apropComdat;    // Real pointer to COMDAT symbol table descriptor
    static RBTYPE       lastProc;       // Last procedure on the list
    APROPSNPTR          apropSn;


    apropComdat = (APROPCOMDATPTR ) PROPSYMLOOKUP(szName, ATTRCOMDAT, FALSE);
    if ((apropComdat != NULL) && (apropComdat->ac_flags & ORDER_BIT))
        OutWarn(ER_duporder, &szName[1]);
    else
    {
        apropComdat = (APROPCOMDATPTR ) PROPSYMLOOKUP(szName, ATTRCOMDAT, TRUE);
        vrComdat = vrprop;

        // Fill in the COMDAT descriptor

        apropComdat->ac_flags = ORDER_BIT;
#if OVERLAYS
        apropComdat->ac_iOvl = iOvl;

        // Set the maximum overlay index

        if (iOvl != NOTIOVL)
        {
            fOverlays = (FTYPE) TRUE;
            fNewExe   = FALSE;
            if (iOvl >= iovMac)
                iovMac = iOvl + 1;
        }
#endif

        if (szSegName != NULL)
        {
            apropSn = GenSeg(szSegName, "\004CODE", GRNIL, (FTYPE) TRUE);
            apropSn->as_flags = dfCode;

            // Allocate COMDAT in the segment

            apropComdat->ac_gsn = apropSn->as_gsn;
            apropComdat->ac_selAlloc = PICK_FIRST | EXPLICIT;
            AttachComdat(vrComdat, apropSn->as_gsn);
        }
        else
            apropComdat->ac_selAlloc = ALLOC_UNKNOWN;

        MARKVP();                       // Page has been changed

        // Attach this COMDAT to the ordered procedure list

        if (procOrder == VNIL)
            procOrder = vrComdat;
        else
        {
            apropComdat = (APROPCOMDATPTR ) FETCHSYM(lastProc, TRUE);
            apropComdat->ac_order = vrComdat;
        }
        lastProc = vrComdat;
    }
    free(szName);
}


LOCAL void NEAR         ProcNamTab(lfa,cb,fres)
long                    lfa;            /* Table starting address */
WORD                    cb;             /* Length of table */
WORD                    fres;           /* Resident name flag */
{
    SBTYPE              sbExport;       /* Exported symbol name */
    WORD                ordExport;      /* Export ordinal */
    APROPEXPPTR        exp;           /* Export symbol table entry */

    fseek(bsInput,lfa,0);               /* Seek to start of table */
    for(cbRec = cb; cbRec != 0; )       /* Loop through table */
    {
        sbExport[0] = (BYTE) getc(bsInput);/* Get length of name */
        fread(&sbExport[1], sizeof(char), B2W(sbExport[0]), bsInput);
                                        /* Get export name */
        ordExport = getc(bsInput) | (getc(bsInput) << BYTELN);
        if (ordExport == 0) continue;
                                        /* Skip if no ordinal assigned */
        exp = (APROPEXPPTR ) PROPSYMLOOKUP(sbExport, ATTREXP, FALSE);
                                        /* Look the export up */
        if(exp == PROPNIL || exp->ax_ord != 0) continue;
                                        /* Must exist and be unassigned */
        exp->ax_ord = ordExport;        /* Assign ordinal */
        if (fres)
            exp->ax_nameflags |= RES_NAME;
                                        /* Set flag if from resident table */
        MARKVP();                       /* Page has been changed */
    }
}


#if NOT EXE386
LOCAL void NEAR         SetExpOrds(void)/* Set export ordinals */
{
    struct exe_hdr      ehdr;           /* Old .EXE header */
    struct new_exe      hdr;            /* New .EXE header */
    long                lfahdr;         /* File offset of header */

    if((bsInput = LinkOpenExe(sbOldver)) == NULL)
    {                                   /* If old version can't be opened */
        /* Error message and return */
        OutWarn(ER_oldopn);
        return;
    }
    SETRAW(bsInput);                    /* Dec 20 hack */
    xread(&ehdr,CBEXEHDR,1,bsInput);    /* Read old header */
    if(E_MAGIC(ehdr) == EMAGIC)         /* If old header found */
    {
        if(E_LFARLC(ehdr) != sizeof(struct exe_hdr))
        {                               /* If no new .EXE in this file */
            /* Error message and return */
            OutWarn(ER_oldbad);
            return;
        }
        lfahdr = E_LFANEW(ehdr);        /* Get file address of new header */
    }
    else lfahdr = 0L;                   /* Else no old header */
    fseek(bsInput,lfahdr,0);            /* Seek to new header */
    xread(&hdr,CBNEWEXE,1,bsInput);     /* Read the header */
    if(NE_MAGIC(hdr) == NEMAGIC)        /* If correct magic number */
    {
        ProcNamTab(lfahdr+NE_RESTAB(hdr),(WORD)(NE_MODTAB(hdr) - NE_RESTAB(hdr)),(WORD)TRUE);
                                        /* Process Resident Name table */
        ProcNamTab(NE_NRESTAB(hdr),NE_CBNRESTAB(hdr),FALSE);
                                        /* Process Non-resident Name table */
    }
    else OutWarn(ER_oldbad);
    fclose(bsInput);                    /* Close old file */
}
#endif


LOCAL void NEAR         NewDescription(BYTE *sbDesc)
{
#if NOT EXE386
    if (NonResidentName.byteMac > 3)
        Fatal(ER_dfdesc);               /* Should be first time */
    AddName(&NonResidentName, sbDesc, 0);
                                        /* Description 1st in non-res table */
#endif
}

#if EXE386
LOCAL void NEAR         NewModule(BYTE *sbModnam, BYTE *defaultExt)
#else
LOCAL void NEAR         NewModule(BYTE *sbModnam)
#endif
{
    WORD                length;         /* Length of symbol */
#if EXE386
    SBTYPE              sbModule;
    BYTE                *pName;
#endif

    if(rhteModule != RHTENIL) Fatal(ER_dfname);
                                        /* Check for redefinition */
    PROPSYMLOOKUP(sbModnam, ATTRNIL, TRUE);
                                        /* Create hash table entry */
    rhteModule = vrhte;                 /* Save virtual hash table address */
#if EXE386
    memcpy(sbModule, sbModnam, sbModnam[0] + 1);
    if (sbModule[sbModule[0]] == '.')
    {
        sbModule[sbModule[0]] = '\0';
        length = sbModule[0];
        pName = &sbModule[1];
    }
    else
    {
        UpdateFileParts(sbModule, defaultExt);
        length = sbModule[0] - 2;
        pName = &sbModule[4];
    }
    if (TargetOs == NE_WINDOWS)
        SbUcase(sbModule);              /* Make upper case */
    vmmove(length, pName, AREAEXPNAME, TRUE);
                                        /* Module name 1st in Export Name Table */
    cbExpName = length;
#else
    if (TargetOs == NE_WINDOWS)
        SbUcase(sbModnam);              /* Make upper case */
    AddName(&ResidentName, sbModnam, 0);/* Module name 1st in resident table */
#endif
    fFileNameExpected = (FTYPE) FALSE;
}

void                    NewExport(sbEntry,sbInternal,ordno,flags)
BYTE                    *sbEntry;       /* Entry name */
BYTE                    *sbInternal;    /* Internal name */
WORD                    ordno;          /* Ordinal number */
WORD                    flags;          /* Flag byte */
{
    APROPEXPPTR         export;         /* Export record */
    APROPUNDEFPTR       undef;          /* Undefined symbol */
    APROPNAMEPTR        PubName;        /* Defined name */
    BYTE                *sb;            /* Internal name */
    BYTE                ParWrds;        /* # of parameter words */
    RBTYPE              rbSymdef;       /* Virtual addr of symbol definition */
#if EXE386
    RBTYPE              vExport;        /* Virtual pointer to export descriptor */
    APROPNAMEPTR        public;         /* Matching public symbol */
#endif

#if DEBUG
    fprintf(stdout,"\r\nEXPORT: ");
    OutSb(stdout,sbEntry);
    NEWLINE(stdout);
    if(sbInternal != NULL)
    {
        fprintf(stdout,"INTERNAL NAME:  ");
        OutSb(stdout,sbInternal);
        NEWLINE(stdout);
    }
    fprintf(stdout, " ordno %u, flags %u ", (unsigned)ordno, (unsigned)flags);
    fflush(stdout);
#endif
    sb = (sbInternal != NULL)? sbInternal: sbEntry;
                                        /* Get pointer to internal name */
    PubName = (APROPNAMEPTR ) PROPSYMLOOKUP(sb, ATTRPNM, FALSE);
#if NOT EXE386
    if(PubName != PROPNIL && !fDrivePass)
        /* If internal name already exists as a public symbol
         * and we are parsing definition file, issue
         * export internal name conflict warning.
         */
        OutWarn(ER_expcon,sbEntry+1,sb+1);
    else                                /* Else if no conflict */
    {
#endif
        if (PubName == PROPNIL)         /* If no matching name exists */
            undef = (APROPUNDEFPTR ) PROPSYMLOOKUP(sb,ATTRUND, TRUE);
                                        /* Make undefined symbol entry */
#if TCE
#if TCE_DEBUG
                fprintf(stdout, "\r\nNewExport adds UNDEF %s ", 1+GetPropName(undef));
#endif
                undef->au_fAlive = TRUE;    /* all exports are potential entry points */
#endif
            rbSymdef = vrprop;          /* Save virtual address */
            if (PubName == PROPNIL)     /* If this is a new symbol */
                undef->au_len = -1L;    /* Make no type assumptions */
            export = (APROPEXPPTR ) PROPSYMLOOKUP(sbEntry,ATTREXP, TRUE);
                                        /* Create export record */
#if EXE386
            vExport = vrprop;
#endif
            if(vfCreated)               /* If this is a new entry */
            {
                export->ax_symdef = rbSymdef;
                                        /* Save virt addr of symbol def */
                export->ax_ord = ordno;
                                        /* Save ordinal number */
                if (nameFlags & RES_NAME)
                    export->ax_nameflags |= RES_NAME;
                                        /* Remember if resident */
                else if (nameFlags & NO_NAME)
                    export->ax_nameflags |= NO_NAME;
                                        /* Remember to discard name */
                export->ax_flags = (BYTE) flags;
                                        /* Save flags */
                ++expMac;               /* One more exported symbol */
            }
            else
            {
                if (!fDrivePass)        /* Else if parsing definition file */
                                        /* multiple definitions */
                    OutWarn(ER_expmul,sbEntry + 1);
                                        /* Output error message */
                else
                {                       /* We were called for EXPDEF object */
                                        /* record, so we merge information  */
                    ParWrds = (BYTE) (export->ax_flags & 0xf8);
                    if (ParWrds && (ParWrds != (BYTE) (flags & 0xf8)))
                        Fatal(ER_badiopl);
                                        /* If the iopl_parmwords field in the */
                                        /* .DEF file is not 0 and does not match */
                                        /* value in the EXPDEF exactly issue error */
                    else if (!ParWrds)
                    {                   /* Else set value from EXPDEF record */
                        ParWrds = (BYTE) (flags & 0xf8);
                        export->ax_flags |= ParWrds;
                    }
                }
            }
#if EXE386
            if (PubName != NULL)
            {
                if (expOtherFlags & 0x1)
                {
                    export->ax_nameflags |= CONSTANT;
                    expOtherFlags = 0;
                }
            }
#endif

#if NOT EXE386
    }
#endif
    if(!(flags & 0x8000))
    {
        free(sbEntry);                  /* Free space */
        if(sbInternal != NULL) free(sbInternal);
    }
                                        /* Free space */
    nameFlags = 0;
}


LOCAL APROPIMPPTR NEAR  GetImport(sb)   /* Get name in Imported Names Table */
BYTE                    *sb;            /* Length-prefixed names */
{
    APROPIMPPTR         import;         /* Pointer to imported name */
#if EXE386
    DWORD               cbTemp;         /* Temporary value */
#else
    WORD                cbTemp;         /* Temporary value */
#endif
    RBTYPE              rprop;          /* Property cell virtual address */


    import = (APROPIMPPTR ) PROPSYMLOOKUP(sb,ATTRIMP, TRUE);
                                        /* Look up module name */
    if(vfCreated)                       /* If no offset assigned yet */
    {
        rprop = vrprop;                 /* Save the virtual address */
        /*
         * WARNING:  We must store name in virtual memory now, otherwise
         * if an EXTDEF was seen first, fIgnoreCase is false, and the
         * cases do not match between the imported name and the EXTDEF,
         * then the name will not go in the table exactly as given.
         */
        import = (APROPIMPPTR) FETCHSYM(rprop,TRUE);
                                        /* Retrieve from symbol table */
        import->am_offset = AddImportedName(sb);
                                        /* Save offset */
    }
    return(import);                     /* Return offset in table */
}

#if NOT EXE386
void                    NewImport(sbEntry,ordEntry,sbModule,sbInternal)
BYTE                    *sbEntry;       /* Entry point name */
WORD                    ordEntry;       /* Entry point ordinal */
BYTE                    *sbModule;      /* Module name */
BYTE                    *sbInternal;    /* Internal name */
{
    APROPNAMEPTR        public;        /* Public symbol */
    APROPIMPPTR         import;        /* Imported symbol */
    BYTE                *sb;            /* Symbol pointer */
    WORD                module;         /* Module name offset */
    FTYPE               flags;          /* Import flags */
    WORD                modoff;         /* module name offset */
    WORD                entry;          /* Entry name offset */
    BYTE                *cp;            /* Char pointer */
    RBTYPE              rpropundef;     /* Address of undefined symbol */
    char                buf[32];        /* Buffer for error sgring */

#if DEBUG
    fprintf(stderr,"\r\nIMPORT: ");
    OutSb(stderr,sbModule);
    fputc('.',stderr);
    if(!ordEntry)
    {
        OutSb(stderr,sbEntry);
    }
    else fprintf(stderr,"%u",ordEntry);
    if(sbInternal != sbEntry)
    {
        fprintf(stderr," ALIAS: ");
        OutSb(stderr,sbInternal);
    }
    fprintf(stdout," ordEntry %u ", (unsigned)ordEntry);
    fflush(stdout);
#endif
    if((public = (APROPNAMEPTR ) PROPSYMLOOKUP(sbInternal, ATTRUND, FALSE)) !=
            PROPNIL && !fDrivePass)     /* If internal names conflict */
    {
        if(sbEntry != NULL)
            sb = sbEntry;
        else
        {
            sprintf(buf + 1,"%u",ordEntry);
            sb = buf;
        }
        OutWarn(ER_impcon,sbModule + 1,sb + 1,sbInternal + 1);
    }
    else                                /* Else if no conflicts */
    {
        rpropundef = vrprop;            /* Save virtual address of extern */
        flags = FIMPORT;                /* We have an imported symbol */
        if (TargetOs == NE_WINDOWS)
            SbUcase(sbModule);          /* Force module name to upper case */
        import = GetImport(sbModule);   /* Get pointer to import record */
        if((module = import->am_mod) == 0)
        {
            // If not in Module Reference Table

            import->am_mod = WordArrayPut(&ModuleRefTable, import->am_offset) + 1;
                                        /* Save offset of name in table */
            module = import->am_mod;

        }

        if(vrhte == rhteModule)         /* If importing from this module */
        {
            if(sbEntry != NULL)
                sb = sbEntry;
            else
            {
                sprintf(buf+1,"%u",ordEntry);
                sb = buf;
            }
            if (TargetOs == NE_OS2)
                OutWarn(ER_impself,sbModule + 1,sb + 1,sbInternal + 1);
            else
                OutError(ER_impself,sbModule + 1,sb + 1,sbInternal + 1);
        }

        if(sbEntry == NULL)         /* If entry by ordinal */
        {
            flags |= FIMPORD;       /* Set flag bit */
            entry = ordEntry;       /* Get ordinal number */
        }
        else                        /* Else if import by name */
        {
            if(fIgnoreCase) SbUcase(sbEntry);
                                    /* Upper case the name if flag set */
            import = GetImport(sbEntry);
            entry = import->am_offset;
                                    /* Get offset of name in table */
        }
        if(public == PROPNIL)       /* If no undefined symbol */
        {
            public = (APROPNAMEPTR )
              PROPSYMLOOKUP(sbInternal,ATTRPNM, TRUE);
                                    /* Make a public symbol */
            if(!vfCreated)          /* If not new */
                /* Output error message */
                OutWarn(ER_impmul,sbInternal + 1);
            else ++pubMac;          /* Else increment public count */
        }
        else                        /* Else if symbol is undefined */
        {
            public = (APROPNAMEPTR ) FETCHSYM(rpropundef,TRUE);
                                    /* Look up external symbol */
            ++pubMac;               /* Increment public symbol count */
        }
        flags |= FPRINT;            /* Symbol is printable */
        public->an_attr = ATTRPNM;  /* This is a public symbol */
        public->an_gsn = SNNIL;     /* Not a segment member */
        public->an_ra = 0;          /* No known offset */
        public->an_ggr = GRNIL;     /* Not a group member */
        public->an_flags = flags;   /* Set flags */
        public->an_entry = entry;   /* Save entry specification */
        public->an_module = module; /* Save Module Reference Table index */
#if SYMDEB AND FALSE
        if (fSymdeb)                /* If debugger support on */
        {
            if (flags & FIMPORD)
                import = GetImport(sbInternal);
            else                    /* Add internal name to Imported Name Table */
                import = GetImport(sbEntry);
            import->am_public = public;
                                    /* Remember public symbol */
            if (cbImpSeg < LXIVK-1)
                cbImpSeg += sizeof(CVIMP);

        }
#endif
    }
}
#endif

#if OVERLAYS
extern void NEAR        GetName(AHTEPTR ahte, BYTE *pBuf);
#endif

/*** NewSeg - new segment definition
*
* Purpose:
*   Create new segment definition based on the module definition
*   file segment description. Check for duplicate definitions and
*   overlay index inconsistency between attached COMDATs (if any)
*   and segment itself.
*
* Input:
*   sbName  - segment name
*   sbClass - segment class
*   iOvl    - segment overlay index
*   flags   - segment attributes
*
* Output:
*   No explicit value is returned. The segment descriptor in
*   symbol table is created or updated.
*
* Exceptions:
*   Multiple segment definitions - warning and continue
*   Change in overlay index      - warning and continue
*
* Notes:
*   None.
*
*************************************************************************/

void NEAR               NewSeg(BYTE *sbName, BYTE *sbClass, WORD iOvl,
#if EXE386
                               DWORD flags)
#else
                               WORD flags)
#endif
{
    APROPSNPTR          apropSn;        // Pointer to segment descriptor
#if OVERLAYS
    RBTYPE              vrComdat;       // Virtual pointer to COMDAT descriptor
    APROPCOMDATPTR      apropComdat;    // Symbol table entry for COMDAT symbol
    SBTYPE              sbComdat;       // Name buffer
#endif

    // Set segment attributes based on the class

    if (SbSuffix(sbClass,"\004CODE",TRUE))
        flags |= dfCode & ~offmask;
    else
        flags |= dfData & ~offmask;
#if O68K
    if (f68k)
        flags |= NS32BIT;
#endif
#if OVERLAYS
    if (iOvl != NOTIOVL)
    {
        fOverlays = (FTYPE) TRUE;
        fNewExe   = FALSE;
        if (iOvl >= iovMac)             // Set the maximum overlay index
            iovMac = iOvl + 1;
    }
#endif

    // Generate new segment definition

    apropSn = GenSeg(sbName, sbClass, GRNIL, (FTYPE) TRUE);
    if (vfCreated)
    {
        apropSn->as_flags = (WORD) flags;
                                        // Save flags
        mpgsndra[apropSn->as_gsn] = 0;  // Initialize
#if OVERLAYS
        apropSn->as_iov = iOvl;         // Save overlay index
        if (fOverlays)
            CheckOvl(apropSn, iOvl);
#endif
        apropSn->as_fExtra |= (BYTE) FROM_DEF_FILE;
                                        // Remember defined in def file
        if (fMixed)
        {
            apropSn->as_fExtra |= (BYTE) MIXED1632;
            fMixed = (FTYPE) FALSE;
        }
    }
    else
    {
        apropSn = CheckClass(apropSn, apropSn->as_rCla);
                                        // Check if previous definition had the same class
        OutWarn(ER_segdup,sbName + 1);  // Warn about multiple definition
#if OVERLAYS
        if (fOverlays && apropSn->as_iov != iOvl)
        {
            if (apropSn->as_iov != NOTIOVL)
                OutWarn(ER_badsegovl, 1 + GetPropName(apropSn), apropSn->as_iov, iOvl);
            apropSn->as_iov = iOvl;     // Save new overlay index
            CheckOvl(apropSn, iOvl);

            // Check if segment has any COMDATs and if it has
            // then check theirs overlay numbers

            for (vrComdat = apropSn->as_ComDat;
                 vrComdat != VNIL;
                 vrComdat = apropComdat->ac_sameSeg)
            {
                apropComdat = (APROPCOMDATPTR ) FetchSym(vrComdat, FALSE);
                if (apropComdat->ac_iOvl != NOTIOVL && apropComdat->ac_iOvl != iOvl)
                {
                    GetName((AHTEPTR) apropComdat, sbComdat);
                    OutWarn(ER_badcomdatovl, &sbComdat[1], apropComdat->ac_iOvl, iOvl);
                }
                apropComdat->ac_iOvl = iOvl;
            }
        }
#endif
    }

    free(sbClass);                      // Free class name
    free(sbName);                       // Free segment name
    offmask = 0;

    // Unless packing limit already set, disable default code packing

    if (!fPackSet)
    {
        fPackSet = (FTYPE) TRUE;        // Remember packLim was set
        packLim = 0L;
    }
}

/*
 * Assign module name to be default, which is run file name.
 *
 * SIDE EFFECTS
 *      Assigns rhteModule
 */

#if EXE386
LOCAL void NEAR         DefaultModule (unsigned char *defaultExt)
#else
LOCAL void NEAR         DefaultModule (void)
#endif
{
    SBTYPE              sbModname;      /* Module name */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
#if OSXENIX
    int                 i;
#endif

    ahte = (AHTEPTR ) FETCHSYM(rhteRunfile,FALSE);
                                        /* Get executable file name */
#if OSMSDOS
    memcpy(sbModname,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Copy file name */
#if EXE386
    NewModule(sbModname, defaultExt);   /* Use run file name as module name */
#else
    UpdateFileParts(sbModname,"\005A:\\.X");
                                        /* Force path, ext with known length */
    sbModname[0] -= 2;                  /* Remove extension from name */
    sbModname[3] = (BYTE) (sbModname[0] - 3);
                                        /* Remove path and drive from name */
    NewModule(&sbModname[3]);           /* Use run file name as module name */
#endif
#endif
#if OSXENIX
    for(i = B2W(ahte->cch[0]); i > 0 && ahte->cch[i] != '/'; i--)
    sbModname[0] = B2W(ahte->cch[0]) - i;
    memcpy(sbModname+1,&GetFarSb(ahte->cch)[i+1],B2W(sbModname[0]));
    for(i = B2W(ahte->cch[0]); i > 1 && sbModname[i] != '.'; i--);
    if(i > 1)
        sbModname[0] = i - 1;
    NewModule(sbModname);               /* Use run file name as module name */
#endif
}


void                    ParseDeffile(void)
{
    SBTYPE              sbDeffile;      /* Definitions file name */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
#if OSMSDOS
    char                buf[512];       /* File buffer */
#endif

    if(rhteDeffile == RHTENIL)          /* If no definitions file */
#if EXE386
        DefaultModule(moduleEXE);
#else
        DefaultModule();
#endif
    else                                /* Else if there is a file to parse */
    {
#if ODOS3EXE
        fNewExe = (FTYPE) TRUE;         /* Def file forces new-format exe */
#endif
        ahte = (AHTEPTR ) FETCHSYM(rhteDeffile,FALSE);
                                        /* Fetch file name */
        memcpy(sbDeffile,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Copy file name */
        sbDeffile[B2W(sbDeffile[0]) + 1] = '\0';
                                        /* Null-terminate the name */
        if((bsInput = fopen(&sbDeffile[1],RDTXT)) == NULL)
        {                               /* If open fails */
            Fatal(ER_opndf, &sbDeffile[1]);/* Fatal error */
        }
#if OSMSDOS
        setvbuf(bsInput,buf,_IOFBF,sizeof(buf));
#endif
        includeDisp[0] = bsInput;       // Initialize include stack
        sbOldver = NULL;                /* Assume no old version */
        yylineno = 1;
        fFileNameExpected = (FTYPE) FALSE;

        // HACK ALERT !!!
        // Don't allocate to much page buffers

        yyparse();                      /* Parse the definitions file */
        yylineno = -1;
        fclose(bsInput);                /* Close the definitions file */
#if NOT EXE386
        if(sbOldver != NULL)            /* If old version given */
        {
            SetExpOrds();               /* Use old version to set ordinals */
            free(sbOldver);             /* Release the space */
        }
#endif
    }
#if OSMSDOS


#endif /* OSMSDOS */
#if NOT EXE386
    if (NonResidentName.byteMac == 0)
    {
        ahte = (AHTEPTR ) FETCHSYM(rhteRunfile,FALSE);
                                        /* Get executable file name */
        memcpy(sbDeffile,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Copy file name */
#if OSXENIX
        SbUcase(sbDeffile);             /* For identical executables */
#endif
        if ((vFlags & NENOTP) && TargetOs == NE_OS2)
            UpdateFileParts(sbDeffile, sbDotDll);
        else
            UpdateFileParts(sbDeffile, sbDotExe);
        NewDescription(sbDeffile);      /* Use run file name as description */
    }
#endif
}
short yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
	};
# define YYNPROD 183
# define YYLAST 408
short yyact[]={

  10,  13,  14, 176,  27,  49,  53,  54, 129, 226,
 174,  50,  43,  44,  45,  46,  53,  54, 203, 161,
 190,  41, 209,  28, 181,  60, 177,  29,  30,  31,
  12,  32,  34,  35, 220, 221, 179,  59,  58, 192,
  41,  41, 189,  41,  41,  33, 148,  11, 206, 152,
 153, 154, 155, 156, 159, 183, 223,  61, 157, 158,
 217, 121, 119, 122,  15,  81, 120, 123, 124, 138,
   4,   5, 219, 139,   6,   7,  16,  36,  17,  42,
  37,  89,  90,  87,  74,  75,  79,  69,  82,  70,
  76,  71,  77,  80,  84,  85,  86,  83,  42,  42,
 215,  42,  42, 213, 212, 207, 196, 164,  56,  55,
  49,  53,  54, 167, 145, 222,  50,  43,  44,  45,
  46,  68,  96,  91,  92, 104, 105,  81, 199, 185,
 162,  67, 147, 166, 107,  48,  78,  72,  73, 115,
  88, 103, 102, 100, 101, 128,  74,  75,  79,  69,
  82,  70,  76,  71,  77,  80,  84,  85,  86,  83,
  95,  97,  98,  99,  94, 112,  66, 137,   8, 187,
 106,  52,  38, 184, 160, 125, 118, 126, 151, 117,
 114, 218, 225, 130, 216, 111,  40, 104, 105,  81,
  26, 134, 136,  25, 131,  24,  23,  22,  78,  72,
  73, 109, 110, 103, 102,  89,  90,  87,  74,  75,
  79,  69,  82,  70,  76,  71,  77,  80,  84,  85,
  86,  83, 108, 132,   9,  95, 127,  39,  47,  21,
  20, 140, 141,  57,  19,  18,  63,  62,  51,   3,
  64, 143,   2,   1, 143, 143, 175,  91,  92, 150,
 211, 163, 198, 197, 149, 113, 116, 205, 142, 178,
  78,  72,  73,  57,  88, 169, 204,  93, 171, 170,
 173, 172,  65, 165, 144,   0, 168, 146, 133, 135,
   0,   0, 182,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0, 201, 202, 191,
   0,   0, 193,   0, 194,   0, 195, 200,   0,   0,
   0,   0,   0,   0, 210,   0,   0,   0,   0,   0,
 201, 202,   0,   0,   0, 224,   0, 214,   0,   0,
 200,   0,   0,   0, 113,   0,   0, 116,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 180,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 186, 188,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 208,   0,   0, 186 };
short yypact[]={

-189,-1000,-267,-267,-221,-225,-153,-154,-267,-1000,
-285,-286,-266,-1000,-1000,-1000,-1000,-222,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000, -68,-130,-222,
-222,-222,-222,-222,-1000,-241,-1000,-1000,-267,-326,
-334,-1000,-1000,-1000,-1000,-1000,-1000,-330,-334,-1000,
-1000,-320,-1000,-1000,-1000,-225,-225,-1000,-1000,-1000,
-1000,-1000,-197,-197,-1000, -68,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-130,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-222,-1000,-144,-222,
-222,-222,-1000,-273,-222,-1000,-273,-252,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-306,-159,-334,-148,-1000,
-334,-148,-1000,-330,-148,-330,-148,-1000,-316,-1000,
-1000,-1000,-1000,-1000,-343,-297,-1000,-284,-222,-1000,
-300,-159,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-223,
-222,-224,-1000,-304,-1000,-148,-1000,-280,-148,-1000,
-148,-1000,-148,-1000,-160,-192,-307,-1000,-265,-161,
-1000,-244,-1000,-1000,-222,-1000,-1000,-1000,-1000,-1000,
-162,-1000,-163,-1000,-1000,-1000,-1000,-1000,-192,-1000,
-1000,-1000,-1000,-166,-212,-194,-1000,-287,-216,-216,
-1000,-1000,-1000,-1000,-1000,-1000,-332,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000 };
short yypgo[]={

   0, 222, 132, 274, 272, 166, 267, 164, 266, 259,
 257, 253, 128, 252, 131, 122, 121, 251, 250, 246,
 115, 243, 242, 168, 239, 186, 145, 133, 135, 238,
 171, 224, 237, 167, 236, 235, 234, 230, 229, 197,
 196, 195, 193, 190, 170, 134, 185, 165, 184, 182,
 181, 180, 139, 179, 178, 130, 177, 176, 175, 174,
 173, 169, 129 };
short yyr1[]={

   0,  21,  21,  24,  21,  22,  22,  22,  22,  22,
  22,  22,  22,  28,  28,  28,  28,  29,  29,  30,
  30,  27,  27,  25,  25,  25,  25,  25,  26,  26,
  23,  23,  31,  31,  31,  31,  32,  31,  34,  31,
  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,
  31,  31,  33,  33,  33,  35,   4,   4,   5,   5,
  16,  16,  16,  16,  16,  16,  36,   6,   6,   7,
   7,   7,   7,   7,   7,   7,  15,  15,  15,  15,
  37,  37,  37,  37,  37,  37,  44,  44,  45,   3,
   3,  19,  19,  12,  12,  12,  13,  13,  11,  11,
  14,  14,  14,  14,  14,  14,  14,  14,  14,  14,
  14,  14,  14,  14,  14,  14,  14,  14,  38,  38,
  46,  46,  47,   2,   2,   9,   9,   9,   9,   8,
  10,  10,  50,  50,  48,  48,  49,  49,  39,  39,
  51,  51,  52,  52,   1,   1,  20,  20,  53,  40,
  54,  54,  54,  54,  54,  54,  54,  54,  54,  55,
  55,  17,  17,  18,  18,  56,  43,  41,  57,  57,
  57,  57,  57,  57,  58,  42,  59,  59,  61,  61,
  60,  60,  62 };
short yyr2[]={

   0,   2,   1,   0,   2,   5,   4,   5,   4,   5,
   4,   5,   4,   1,   1,   1,   0,   2,   1,   1,
   1,   3,   0,   1,   1,   1,   1,   0,   1,   0,
   2,   1,   2,   2,   2,   2,   0,   3,   0,   3,
   1,   1,   2,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   3,   1,   1,   2,   2,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   2,   2,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   2,   1,   2,   1,   2,   1,   2,   1,   4,   2,
   0,   3,   0,   1,   1,   1,   2,   1,   1,   0,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   2,   1,
   2,   1,   6,   2,   0,   3,   3,   2,   0,   2,
   1,   0,   1,   0,   1,   0,   1,   0,   2,   1,
   2,   1,   5,   5,   1,   1,   1,   0,   0,   4,
   1,   1,   1,   1,   1,   1,   1,   2,   1,   3,
   1,   1,   0,   1,   0,   0,   3,   2,   1,   1,
   1,   1,   1,   1,   0,   4,   2,   0,   1,   1,
   2,   1,   1 };
short yychk[]={

-1000, -21, -22, -24, 259, 260, 263, 264, -23, -31,
 267, 314, 297, 268, 269, 331, 343, 345, -35, -36,
 -37, -38, -39, -40, -41, -42, -43, 271, 290, 294,
 295, 296, 298, 312, 299, 300, 344, 347, -23,  -1,
 -25, 265, 323, 338, 339, 340, 341,  -1, -28, 335,
 341, -29, -30, 336, 337, 262, 262, -31, 323, 323,
 291, 323, -32, -34,  -1,  -4,  -5, -14, -16, 279,
 281, 283, 329, 330, 276, 277, 282, 284, 328, 278,
 285, 257, 280, 289, 286, 287, 288, 275, 332, 273,
 274, 315, 316,  -6,  -7, -14, -15, 291, 292, 293,
 273, 274, 334, 333, 317, 318, -44, -45,  -1, -44,
 -44, -46, -47,  -1, -51, -52,  -1, -53, -57, 303,
 307, 302, 304, 308, 309, -58, -56, -25, -26, 342,
 -28, -26, -30,  -1, -28,  -1, -28, -33, 266, 270,
 -33,  -5,  -7, -45,  -3, 258, -47,  -2, 319, -52,
  -2, -54, 301, 302, 303, 304, 305, 310, 311, 306,
 -59, 325, -55, -17, 266, -26, -27, 261, -26, -27,
 -28, -27, -28, -27, 326, -19, 346, 323,  -9, 320,
  -1, 324, -55, 278, -60, -62,  -1, -61,  -1, 266,
 324, -27, 319, -27, -27, -27, 266, -11, -13, -12,
 -14, -16, -15, 325,  -8, -10, 313, 266,  -1, 266,
 -62, -18, 266, 266, -12, 266, -48, 272, -50, 266,
 321, 322, -20, 272, -20, -49, 341 };
short yydef[]={

   3,  -2,   2,   0,  27,  16,   0,   0,   1,  31,
   0,   0,   0,  36,  38,  40,  41,   0,  43,  44,
  45,  46,  47,  48,  49,  50,  51,   0,   0,  81,
  83,  85, 119, 139, 148,   0, 174, 165,   4,  27,
  29, 144, 145,  23,  24,  25,  26,  16,  29,  13,
  14,  15,  18,  19,  20,  16,  16,  30,  32,  33,
  34,  35,   0,   0,  42,  55,  57,  58,  59, 100,
 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
 111, 112, 113, 114, 115, 116, 117,  60,  61,  62,
  63,  64,  65,  66,  68,  69,  70,  71,  72,  73,
  74,  75,  76,  77,  78,  79,  80,  87,  90,  82,
  84, 118, 121, 124, 138, 141, 124,   0, 167, 168,
 169, 170, 171, 172, 173, 177, 162,  29,  22,  28,
  29,  22,  17,  16,  22,  16,  22,  37,  53,  54,
  39,  56,  67,  86,  92,   0, 120, 128,   0, 140,
   0, 162, 150, 151, 152, 153, 154, 155, 156, 158,
   0,   0, 166, 160, 161,  22,   6,   0,  22,   8,
  22,  10,  22,  12,   0,  99,   0,  89, 131,   0,
 123,   0, 149, 157, 175, 181, 182, 176, 178, 179,
 164,   5,   0,   7,   9,  11,  52,  88,  98,  97,
  93,  94,  95,   0, 135, 133, 130, 127, 147, 147,
 180, 159, 163,  21,  96,  91, 137, 134, 129, 132,
 125, 126, 142, 146, 143, 122, 136 };
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

#ifdef YYDEBUG                          /* RRR - 10/9/85 */
#define yyprintf(a, b, c) printf(a, b, c)
#else
#define yyprintf(a, b, c)
#endif

/*      parser for yacc output  */

YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

int NEAR yyparse(void)
   {

   short yys[YYMAXDEPTH];
   short yyj, yym;
   register YYSTYPE *yypvt;
   register short yystate, *yyps, yyn;
   register YYSTYPE *yypv;
   register short *yyxi;

   yystate = 0;
   yychar = -1;
   yynerrs = 0;
   yyerrflag = 0;
   yyps= &yys[-1];
   yypv= &yyv[-1];

yystack:    /* put a state and value onto the stack */

   yyprintf( "state %d, char 0%o\n", yystate, yychar );
   if( ++yyps> &yys[YYMAXDEPTH] )
      {
      yyerror( "yacc stack overflow" );
      return(1);
      }
   *yyps = yystate;
   ++yypv;
   *yypv = yyval;
yynewstate:

   yyn = yypact[yystate];

   if( yyn<= YYFLAG ) goto yydefault; /* simple state */

   if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
   if( (yyn += (short)yychar)<0 || yyn >= YYLAST ) goto yydefault;

   if( yychk[ yyn=yyact[ yyn ] ] == yychar )
      {
      /* valid shift */
      yychar = -1;
      yyval = yylval;
      yystate = yyn;
      if( yyerrflag > 0 ) --yyerrflag;
      goto yystack;
      }
yydefault:
   /* default state action */

   if( (yyn=yydef[yystate]) == -2 )
      {
      if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
      /* look through exception table */

      for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

      for(yyxi+=2; *yyxi >= 0; yyxi+=2)
         {
         if( *yyxi == yychar ) break;
         }
      if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
      }

   if( yyn == 0 )
      {
      /* error */
      /* error ... attempt to resume parsing */

      switch( yyerrflag )
         {

      case 0:   /* brand new error */

         yyerror( "syntax error" );
         ++yynerrs;

      case 1:
      case 2: /* incompletely recovered error ... try again */

         yyerrflag = 3;

         /* find a state where "error" is a legal shift action */

         while ( yyps >= yys )
            {
            yyn = yypact[*yyps] + YYERRCODE;
            if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE )
               {
               yystate = yyact[yyn];  /* simulate a shift of "error" */
               goto yystack;
               }
            yyn = yypact[*yyps];

            /* the current yyps has no shift onn "error", pop stack */

            yyprintf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
            --yyps;
            --yypv;
            }

         /* there is no state on the stack with an error shift ... abort */

yyabort:
         return(1);


      case 3:  /* no shift yet; clobber input char */
         yyprintf( "error recovery discards char %d\n", yychar, 0 );

         if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
         yychar = -1;
         goto yynewstate;   /* try again in the same state */

         }

      }

   /* reduction by production yyn */

   yyprintf("reduce %d\n",yyn, 0);
   yyps -= yyr2[yyn];
   yypvt = yypv;
   yypv -= yyr2[yyn];
   yyval = yypv[1];
   yym=yyn;
   /* consult goto table to find next state */
   yyn = yyr1[yyn];
   yyj = yypgo[yyn] + *yyps + 1;
   if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
   switch(yym)
      {

case 3:
# line 298
{
#if EXE386
                    DefaultModule(moduleEXE);
#else
                    DefaultModule();
#endif
                } break;
case 5:
# line 309
{
#if EXE386
                    NewModule(yypvt[-3]._bp, moduleEXE);
#else
                    NewModule(yypvt[-3]._bp);
#endif
                } break;
case 6:
# line 317
{
#if EXE386
                    DefaultModule(moduleEXE);
#else
                    DefaultModule();
#endif
                } break;
case 7:
# line 325
{
#if EXE386
                    SetDLL(vFlags);
                    NewModule(yypvt[-3]._bp, moduleDLL);
#else
                    vFlags = NENOTP | (vFlags & ~NEINST) | NESOLO;
                    dfData |= NSSHARED;
                    NewModule(yypvt[-3]._bp);
#endif
                } break;
case 8:
# line 336
{
#if EXE386
                    SetDLL(vFlags);
                    DefaultModule(moduleDLL);
#else
                    vFlags = NENOTP | (vFlags & ~NEINST) | NESOLO;
                    dfData |= NSSHARED;
                    DefaultModule();
#endif
                } break;
case 9:
# line 347
{
#if EXE386
                    SetDLL(vFlags);
                    NewModule(yypvt[-2]._bp, moduleDLL);
#endif
                } break;
case 10:
# line 354
{
#if EXE386
                    SetDLL(vFlags);
                    DefaultModule(moduleDLL);
#endif
                } break;
case 11:
# line 361
{
#if EXE386
                    SetDLL(vFlags);
                    NewModule(yypvt[-2]._bp, moduleDLL);
#endif
                } break;
case 12:
# line 368
{
#if EXE386
                    SetDLL(vFlags);
                    DefaultModule(moduleDLL);
#endif
                } break;
case 13:
# line 377
{
#if EXE386
                    dllFlags &= ~E32_PROCINIT;
#else
                    vFlags &= ~NEPPLI;
#endif
                } break;
case 14:
# line 385
{
                    vFlags |= NEPRIVLIB;
                } break;
case 19:
# line 397
{
#if EXE386
                    SetINSTINIT(dllFlags);
#else
                    vFlags |= NEPPLI;
#endif
                } break;
case 20:
# line 405
{
#if EXE386
                    SetINSTTERM(dllFlags);
#endif
                } break;
case 21:
# line 413
{
#if EXE386
                    virtBase = yypvt[-0]._wd;
                    virtBase = RoundTo64k(virtBase);
#endif
                } break;
case 22:
# line 420
{
                } break;
case 23:
# line 425
{
#if EXE386
                    SetGUI(TargetSubsys);
#else
                    vFlags |= NEWINAPI;
#endif
                } break;
case 24:
# line 433
{
#if EXE386
                    SetGUICOMPAT(TargetSubsys);
#else
                    vFlags |= NEWINCOMPAT;
#endif
                } break;
case 25:
# line 441
{
#if EXE386
                    SetNOTGUI(TargetSubsys);
#else
                    vFlags |= NENOTWINCOMPAT;
#endif

                } break;
case 26:
# line 450
{
                    vFlags |= NEPRIVLIB;
                } break;
case 27:
# line 454
{
                } break;
case 28:
# line 458
{
#if NOT EXE386
                    vFlagsOthers |= NENEWFILES;
#endif
                } break;
case 29:
# line 464
{
                } break;
case 32:
# line 472
{
                    NewDescription(yypvt[-0]._bp);
                } break;
case 33:
# line 476
{
                    if(sbOldver == NULL) sbOldver = _strdup(bufg);
                } break;
case 34:
# line 480
{
                    if(rhteStub == RHTENIL) fStub = (FTYPE) FALSE;
                } break;
case 35:
# line 484
{
                    if(fStub && rhteStub == RHTENIL)
                    {
                        PROPSYMLOOKUP(yypvt[-0]._bp,ATTRNIL, TRUE);
                        rhteStub = vrhte;
                    }
                } break;
case 36:
# line 492
{
                    fHeapSize = (FTYPE) TRUE;
                } break;
case 38:
# line 497
{
                    fHeapSize = (FTYPE) FALSE;
                } break;
case 40:
# line 502
{
#if NOT EXE386
                    vFlags |= NEPROT;
#endif
                } break;
case 41:
# line 508
{
                    fRealMode = (FTYPE) TRUE;
                    vFlags &= ~NEPROT;
                } break;
case 42:
# line 513
{
#if NOT EXE386
                    AppLoader(yypvt[-0]._bp);
#endif
                } break;
case 52:
# line 530
{
                    if (fHeapSize)
                    {
                        cbHeap = yypvt[-2]._wd;
#if EXE386
                        cbHeapCommit = yypvt[-0]._wd;
#endif
                    }
                    else
                    {
                        if(cbStack)
                            OutWarn(ER_stackdb, yypvt[-2]._wd);
                        cbStack = yypvt[-2]._wd;
#if EXE386
                        cbStackCommit = yypvt[-0]._wd;
#endif
                    }
                } break;
case 53:
# line 549
{
                    if (fHeapSize)
                    {
                        cbHeap = yypvt[-0]._wd;
#if EXE386
                        cbHeapCommit = cbHeap;
#endif
                    }
                    else
                    {
                        if(cbStack)
                            OutWarn(ER_stackdb, yypvt[-0]._wd);
                        cbStack = yypvt[-0]._wd;
#if EXE386
                        cbStackCommit = cbStack;
#endif
                    }
                } break;
case 54:
# line 568
{
                    if (fHeapSize)
                        fHeapMax = (FTYPE) TRUE;
                } break;
case 55:
# line 575
{
                    // Set dfCode to specified flags; for any unspecified attributes
                    // use the defaults.        Then reset offmask.

                    dfCode = yypvt[-0]._wd | (dfCode & ~offmask);
                    offmask = 0;
                    vfShrattr = (FTYPE) FALSE;  /* Reset for DATA */
                } break;
case 56:
# line 585
{
                    yyval._wd |= yypvt[-0]._wd;
                } break;
case 60:
# line 594
{
#if EXE386
                    yyval._wd = OBJ_EXEC;
#else
                    yyval._wd = NSEXRD;
#endif
                } break;
case 62:
# line 603
{
#if EXE386
                    offmask |= OBJ_RESIDENT;
#else
                    yyval._wd = NSDISCARD | NSMOVE;
#endif
                } break;
case 63:
# line 611
{
#if EXE386
#else
                    offmask |= NSDISCARD;
#endif
                } break;
case 64:
# line 618
{
#if EXE386
#else
                    yyval._wd = NSCONFORM;
#endif
                } break;
case 65:
# line 625
{
#if EXE386
#else
                    offmask |= NSCONFORM;
#endif
                } break;
case 66:
# line 633
{
                    // Set dfData to specified flags; for any unspecified
                    // attribute use the defaults.  Then reset offmask.

#if EXE386
                    dfData = (yypvt[-0]._wd | (dfData & ~offmask));
#else
                    dfData = yypvt[-0]._wd | (dfData & ~offmask);
#endif
                    offmask = 0;

#if NOT EXE386
                    if (vfShrattr && !vfAutodata)
                    {
                        // If share-attribute and no autodata attribute, share-
                        // attribute controls autodata.

                        if (yypvt[-0]._wd & NSSHARED)
                            vFlags = (vFlags & ~NEINST) | NESOLO;
                        else
                            vFlags = (vFlags & ~NESOLO) | NEINST;
                    }
                    else if(!vfShrattr)
                    {
                        // Else if no share-attribute, autodata attribute
                        // controls share-attribute.

                        if (vFlags & NESOLO)
                            dfData |= NSSHARED;
                        else if(vFlags & NEINST)
                            dfData &= ~NSSHARED;
                    }
#endif
                } break;
case 67:
# line 669
{
                    yyval._wd |= yypvt[-0]._wd;
                } break;
case 71:
# line 677
{
#if NOT EXE386
                    vFlags &= ~(NESOLO | NEINST);
#endif
                } break;
case 72:
# line 683
{
#if NOT EXE386
                    vFlags = (vFlags & ~NEINST) | NESOLO;
#endif
                    vfAutodata = (FTYPE) TRUE;
                } break;
case 73:
# line 690
{
#if NOT EXE386
                    vFlags = (vFlags & ~NESOLO) | NEINST;
#endif
                    vfAutodata = (FTYPE) TRUE;
                } break;
case 74:
# line 697
{
#if NOT EXE386
                    // This ONLY for compatibility with JDA IBM LINK
                    yyval._wd = NSDISCARD | NSMOVE;
#endif
                } break;
case 75:
# line 704
{
#if NOT EXE386
                    // This ONLY for compatibility with JDA IBM LINK
                    offmask |= NSDISCARD;
#endif
                } break;
case 76:
# line 712
{
#if EXE386
                    yyval._wd = OBJ_READ;
                    offmask |= OBJ_WRITE;
#else
                    yyval._wd = NSEXRD;
#endif
                } break;
case 78:
# line 722
{
#if FALSE AND NOT EXE386
                    yyval._wd = NSEXPDOWN;
#endif
                } break;
case 79:
# line 728
{
#if FALSE AND NOT EXE386
                    offmask |= NSEXPDOWN;
#endif
                } break;
case 88:
# line 746
{
                    NewSeg(yypvt[-3]._bp, yypvt[-2]._bp, yypvt[-1]._wd, yypvt[-0]._wd);
                } break;
case 89:
# line 751
{
                    yyval._bp = _strdup(yypvt[-0]._bp);
                } break;
case 90:
# line 755
{
                    yyval._bp = _strdup("\004CODE");
                } break;
case 91:
# line 760
{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 92:
# line 764
{
#if OVERLAYS
                    yyval._wd = NOTIOVL;
#endif
                } break;
case 96:
# line 776
{
                    yyval._wd |= yypvt[-0]._wd;
                } break;
case 98:
# line 782
{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 99:
# line 786
{
                    yyval._wd = 0;
                } break;
case 100:
# line 791
{
#if EXE386
                    yyval._wd = OBJ_SHARED;
#else
                    yyval._wd = NSSHARED;
#endif
                    vfShrattr = (FTYPE) TRUE;
                } break;
case 101:
# line 800
{
                    vfShrattr = (FTYPE) TRUE;
#if EXE386
                    offmask |= OBJ_SHARED;
#else
                    offmask |= NSSHARED;
#endif
                } break;
case 102:
# line 809
{
#if EXE386
#endif
                } break;
case 103:
# line 814
{
#if EXE386
#else
                    yyval._wd = (2 << SHIFTDPL) | NSMOVE;
                    offmask |= NSDPL;
#endif
                } break;
case 104:
# line 822
{
#if EXE386
#else
                    yyval._wd = (3 << SHIFTDPL);
#endif
                } break;
case 105:
# line 829
{
#if NOT EXE386
                    offmask |= NSMOVE | NSDISCARD;
#endif
                } break;
case 106:
# line 835
{
#if NOT EXE386
                    yyval._wd = NSMOVE;
#endif
                } break;
case 107:
# line 841
{
#if NOT EXE386
                    yyval._wd = NSPRELOAD;
#endif
                } break;
case 108:
# line 847
{
#if NOT EXE386
                    offmask |= NSPRELOAD;
#endif
                } break;
case 109:
# line 853
{
                } break;
case 110:
# line 856
{
                } break;
case 111:
# line 859
{
                } break;
case 112:
# line 862
{
                } break;
case 113:
# line 865
{
                } break;
case 114:
# line 868
{
                } break;
case 115:
# line 871
{
                } break;
case 116:
# line 874
{
                } break;
case 117:
# line 877
{
                } break;
case 122:
# line 887
{
                    NewExport(yypvt[-5]._bp,yypvt[-4]._bp,yypvt[-3]._wd,yypvt[-2]._wd);
                } break;
case 123:
# line 892
{
                    yyval._bp = yypvt[-0]._bp;
                } break;
case 124:
# line 896
{
                    yyval._bp = NULL;
                } break;
case 125:
# line 901
{
                    yyval._wd = yypvt[-1]._wd;
                    nameFlags |= RES_NAME;
                } break;
case 126:
# line 906
{
                    yyval._wd = yypvt[-1]._wd;
                    nameFlags |= NO_NAME;
                } break;
case 127:
# line 911
{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 128:
# line 915
{
                    yyval._wd = 0;
                } break;
case 129:
# line 920
{
                    yyval._wd = yypvt[-1]._wd | 1;
                } break;
case 130:
# line 925
{
                    /* return 0 */
                } break;
case 131:
# line 929
{
                    yyval._wd = 2;
                } break;
case 132:
# line 934
{
                } break;
case 133:
# line 937
{
                } break;
case 134:
# line 941
{
#if EXE386
                    expOtherFlags |= 0x1;
#endif
                } break;
case 135:
# line 947
{
                } break;
case 142:
# line 969
{
                    if(yypvt[-3]._bp != NULL)
                    {
#if EXE386
                        NewImport(yypvt[-1]._bp,0,yypvt[-3]._bp,yypvt[-4]._bp,yypvt[-0]._wd);
#else
                        NewImport(yypvt[-1]._bp,0,yypvt[-3]._bp,yypvt[-4]._bp);
#endif
                        free(yypvt[-3]._bp);
                    }
                    else
#if EXE386
                        NewImport(yypvt[-1]._bp,0,yypvt[-4]._bp,yypvt[-1]._bp,yypvt[-0]._wd);
#else
                        NewImport(yypvt[-1]._bp,0,yypvt[-4]._bp,yypvt[-1]._bp);
#endif
                    free(yypvt[-4]._bp);
                    free(yypvt[-1]._bp);
                } break;
case 143:
# line 989
{
                    if (yypvt[-3]._bp == NULL)
                        Fatal(ER_dfimport);
#if EXE386
                    NewImport(NULL,yypvt[-1]._wd,yypvt[-3]._bp,yypvt[-4]._bp,yypvt[-0]._wd);
#else
                    NewImport(NULL,yypvt[-1]._wd,yypvt[-3]._bp,yypvt[-4]._bp);
#endif
                    free(yypvt[-4]._bp);
                    free(yypvt[-3]._bp);
                } break;
case 144:
# line 1003
{
                    yyval._bp = _strdup(bufg);
                } break;
case 145:
# line 1007
{
                    yyval._bp = _strdup(bufg);
                } break;
case 146:
# line 1013
{
                    yyval._wd = 1;
                } break;
case 147:
# line 1017
{
                    yyval._wd = 0;
                } break;
case 148:
# line 1023
{
#if EXE386
                    fUserVersion = (FTYPE) FALSE;
#endif
                } break;
case 150:
# line 1032
{
                    TargetOs = NE_DOS;
#if ODOS3EXE
                    fNewExe  = FALSE;
#endif
                } break;
case 151:
# line 1039
{
                    TargetOs = NE_OS2;
                } break;
case 152:
# line 1043
{
                    TargetOs = NE_UNKNOWN;
                } break;
case 153:
# line 1047
{
#if EXE386
                    TargetSubsys = E32_SSWINGUI;
#endif
                    TargetOs = NE_WINDOWS;// PROTMODE is default for WINDOWS
                    fRealMode = (FTYPE) FALSE;
#if NOT EXE386
                    vFlags |= NEPROT;
#endif
                } break;
case 154:
# line 1058
{
                    TargetOs = NE_DEV386;
                } break;
case 155:
# line 1062
{
#if EXE386
                    TargetSubsys = E32_SSWINGUI;
#endif
                } break;
case 156:
# line 1068
{
#if EXE386
                    TargetSubsys = E32_SSPOSIXCHAR;
#endif
                } break;
case 157:
# line 1074
{
#if O68K
                    iMacType = MAC_SWAP;
                    f68k = fTBigEndian = fNewExe = (FTYPE) TRUE;

                    /* If we are packing code to the default value, change the
                    default. */
                    if (fPackSet && packLim == LXIVK - 36)
                        packLim = LXIVK / 2;
#endif
                } break;
case 158:
# line 1086
{
#if O68K
                    iMacType = MAC_NOSWAP;
                    f68k = fTBigEndian = fNewExe = (FTYPE) TRUE;

                    /* If we are packing code to the default value, change the
                    default. */
                    if (fPackSet && packLim == LXIVK - 36)
                        packLim = LXIVK / 2;
#endif
                } break;
case 159:
# line 1100
{
#if EXE386
                    if (fUserVersion)
                    {
                        UserMajorVer = (BYTE) yypvt[-2]._wd;
                        UserMinorVer = (BYTE) yypvt[-0]._wd;
                    }
                    else
#endif
                    {
                        ExeMajorVer = (BYTE) yypvt[-2]._wd;
                        ExeMinorVer = (BYTE) yypvt[-0]._wd;
                    }
                } break;
case 160:
# line 1115
{
#if EXE386
                    if (fUserVersion)
                    {
                        UserMajorVer = (BYTE) yypvt[-0]._wd;
                        UserMinorVer = 0;
                    }
                    else
#endif
                    {
                        ExeMajorVer = (BYTE) yypvt[-0]._wd;
                        if(fNoExeVer)
                           ExeMinorVer = DEF_EXETYPE_WINDOWS_MINOR;
                        else
                           ExeMinorVer = 0;
                    }
                } break;
case 161:
# line 1135
{
                    yyval._wd = yypvt[-0]._wd;
                } break;
case 162:
# line 1139
{
                    yyval._wd = ExeMajorVer;
                    fNoExeVer = TRUE;
                } break;
case 163:
# line 1146
{
                    if (cDigits >= 2)
                        yyval._wd = yypvt[-0]._wd;
                    else
                        yyval._wd = 10 * yypvt[-0]._wd;
                } break;
case 164:
# line 1153
{
                    yyval._wd = ExeMinorVer;
                } break;
case 165:
# line 1159
{
#if EXE386
                    fUserVersion = (FTYPE) TRUE;
#endif
                } break;
case 168:
# line 1171
{
#if EXE386
                    TargetSubsys = E32_SSUNKNOWN;
#endif
                } break;
case 169:
# line 1177
{
#if EXE386
                    TargetSubsys = E32_SSNATIVE;
#endif
                } break;
case 170:
# line 1183
{
#if EXE386
                    TargetSubsys = E32_SSOS2CHAR;
#endif
                } break;
case 171:
# line 1189
{
#if EXE386
                    TargetSubsys = E32_SSWINGUI;
#endif
                } break;
case 172:
# line 1195
{
#if EXE386
                    TargetSubsys = E32_SSWINCHAR;
#endif
                } break;
case 173:
# line 1201
{
#if EXE386
                    TargetSubsys = E32_SSPOSIXCHAR;
#endif
                } break;
case 174:
# line 1210
{
                    if (szSegName != NULL)
                    {
                        free(szSegName);
                        szSegName = NULL;
                    }
#if OVERLAYS
                    iOvl = NOTIOVL;
#endif
                } break;
case 178:
# line 1228
{
                    if (szSegName == NULL)
                        szSegName = yypvt[-0]._bp;
#if OVERLAYS
                    iOvl = NOTIOVL;
#endif
                } break;
case 179:
# line 1236
{
#if OVERLAYS
                    iOvl = yypvt[-0]._wd;
                    fOverlays = (FTYPE) TRUE;
                    fNewExe   = FALSE;
                    TargetOs  = NE_DOS;
#endif
                } break;
case 182:
# line 1251
{
                    NewProc(yypvt[-0]._bp);
                } break;/* End of actions */
      }
   goto yystack;  /* stack new state and value */

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newexe.h ===
/* SCCSID = @(#)newexe.h        4.6 86/09/10 */
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984-1987
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 *      85/10/03        Reuben Borman   Removed segment discard priority
 *      85/10/11        Vic Heller      Added PIF header fields
 *      86/03/10        Reuben Borman   Changes for DOS 5.0
 *      86/09/02        Reuben Borman   NSPURE ==> NSSHARED
 *      87/05/04        Reuben Borman   Added ne_cres and NSCONFORM
 *      87/07/08        Reuben Borman   Added NEAPPTYPE definitions
 *      87/10/28        Wieslaw Kalkus  Added ne_exetyp
 *      89/03/23        Wieslaw Kalkus  Added ne_flagsothers for OS/2 1.2
 */



    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |  DOS3 .EXE FILE HEADER DEFINITION                               |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */


#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x000d          /* No. of reserved words (OLD) */
#define ERES2WDS        0x000A          /* No. of reserved words in e_res2 */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */
#define EKNOWEAS        0x0001          /* e_flags - program understands EAs */
#define EDOSEXTENDED    0x0002          /* e_flags - program runs under DOS extender */
#define EPCODE          0x0004          /* e_flags - memory image constructed from PCODE */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned long       e_sym_tab;      /* offset of symbol table file */
    unsigned short      e_flags;        /* old exe header flags  */
    unsigned short      e_res;          /* Reserved words */
    unsigned short      e_oemid;        /* OEM identifier (for e_oeminfo) */
    unsigned short      e_oeminfo;      /* OEM information; e_oemid specific */
    unsigned short      e_res2[ERES2WDS];/* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_SYM_TAB(x)    (x).e_sym_tab
#define E_FLAGS(x)      (x).e_flags
#define E_RES(x)        (x).e_res
#define E_OEMID(x)      (x).e_oemid
#define E_OEMINFO(x)    (x).e_oeminfo
#define E_RES2(x)       (x).e_res2
#define E_LFANEW(x)     (x).e_lfanew


    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |  OS/2 & WINDOWS .EXE FILE HEADER DEFINITION - 286 version       |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0               /* No bytes reserved after Windows 3.0 changes */
#define NECRC           8               /* Offset into new header of NE_CRC */

struct new_exe                          /* New .EXE header */
  {
    unsigned short      ne_magic;       /* Magic number NE_MAGIC */
    unsigned char       ne_ver;         /* Version number */
    unsigned char       ne_rev;         /* Revision number */
    unsigned short      ne_enttab;      /* Offset of Entry Table */
    unsigned short      ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short      ne_flags;       /* Flag word */
    unsigned short      ne_autodata;    /* Automatic data segment number */
    unsigned short      ne_heap;        /* Initial heap allocation */
    unsigned short      ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short      ne_cseg;        /* Count of file segments */
    unsigned short      ne_cmod;        /* Entries in Module Reference Table */
    unsigned short      ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short      ne_segtab;      /* Offset of Segment Table */
    unsigned short      ne_rsrctab;     /* Offset of Resource Table */
    unsigned short      ne_restab;      /* Offset of resident name table */
    unsigned short      ne_modtab;      /* Offset of Module Reference Table */
    unsigned short      ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short      ne_cmovent;     /* Count of movable entries */
    unsigned short      ne_align;       /* Segment alignment shift count */
    unsigned short      ne_cres;        /* Count of resource entries */
    unsigned char       ne_exetyp;      /* Target operating system */
    unsigned char       ne_flagsothers; /* Other .EXE flags */
    unsigned short      ne_pretthunks;  /* Windows 3.0 - offset to return thunks */
    unsigned short      ne_psegrefbytes;/* Windows 3.0 - offset to segment ref. bytes */
    unsigned short      ne_swaparea;    /* Windows 3.0 - minimum code swap size */
    unsigned short      ne_expver;      /* Windows 3.0 - expected windows version number */
  };

#define NE_MAGIC(x)         (x).ne_magic
#define NE_VER(x)           (x).ne_ver
#define NE_REV(x)           (x).ne_rev
#define NE_ENTTAB(x)        (x).ne_enttab
#define NE_CBENTTAB(x)      (x).ne_cbenttab
#define NE_CRC(x)           (x).ne_crc
#define NE_FLAGS(x)         (x).ne_flags
#define NE_AUTODATA(x)      (x).ne_autodata
#define NE_HEAP(x)          (x).ne_heap
#define NE_STACK(x)         (x).ne_stack
#define NE_CSIP(x)          (x).ne_csip
#define NE_SSSP(x)          (x).ne_sssp
#define NE_CSEG(x)          (x).ne_cseg
#define NE_CMOD(x)          (x).ne_cmod
#define NE_CBNRESTAB(x)     (x).ne_cbnrestab
#define NE_SEGTAB(x)        (x).ne_segtab
#define NE_RSRCTAB(x)       (x).ne_rsrctab
#define NE_RESTAB(x)        (x).ne_restab
#define NE_MODTAB(x)        (x).ne_modtab
#define NE_IMPTAB(x)        (x).ne_imptab
#define NE_NRESTAB(x)       (x).ne_nrestab
#define NE_CMOVENT(x)       (x).ne_cmovent
#define NE_ALIGN(x)         (x).ne_align
#define NE_CRES(x)          (x).ne_cres
#define NE_RES(x)           (x).ne_res
#define NE_EXETYP(x)        (x).ne_exetyp
#define NE_FLAGSOTHERS(x)   (x).ne_flagsothers
#define NE_PRETTHUNKS(x)    (x).ne_pretthunks
#define NE_PSEGREFBYTES(x)  (x).ne_psegrefbytes
#define NE_SWAPAREA(x)      (x).ne_swaparea
#define NE_EXPVER(x)        (x).ne_expver


#define NE_USAGE(x)     (WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)   (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)


/*
 *  Target operating systems
 */

#define NE_UNKNOWN      0x0             /* Unknown (any "new-format" OS) */
#define NE_OS2          0x1             /* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS      0x2             /* Microsoft Windows */
#define NE_DOS          0x3             /* Microsoft MS-DOS */
#define NE_DEV386       0x4             /* Microsoft Windows 386 */

/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   x                                  Unused
 *    e                                 Errors in image
 *     x                                Unused
 *      b                               Bound Family/API
 *       ttt                            Application type
 *          f                           Floating-point instructions
 *           3                          386 instructions
 *            2                         286 instructions
 *             0                        8086 instructions
 *              P                       Protected mode only
 *               p                      Per-process library initialization
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NEPRIVLIB       0x4000          /* A one customer Windows 3.0 library */
#define NEIERR          0x2000          /* Errors in image */
#define NEBOUND         0x0800          /* Bound Family/API */
#define NEAPPLOADER     0x0800          /* Aplication specific loader - valid only for Windows */
#define NEAPPTYP        0x0700          /* Application type mask */
#define NENOTWINCOMPAT  0x0100          /* Not compatible with P.M. Windowing */
#define NEWINCOMPAT     0x0200          /* Compatible with P.M. Windowing */
#define NEWINAPI        0x0300          /* Uses P.M. Windowing API */
#define NEFLTP          0x0080          /* Floating-point instructions */
#define NEI386          0x0040          /* 386 instructions */
#define NEI286          0x0020          /* 286 instructions */
#define NEI086          0x0010          /* 8086 instructions */
#define NEPROT          0x0008          /* Runs in protected mode only */
#define NEPPLI          0x0004          /* Per-Process Library Initialization */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

/*
 *  Format of NE_FLAGSOTHERS(x):
 *
 *      7 6 5 4 3 2 1 0  - bit no
 *            | | | | |
 *            | | | | +---------------- Support for EAs and Long filenames
 *            | | | +------------------ Reserved for Win30
 *            | | +-------------------- Reserved for Win30
 *            | +---------------------- Reserved for Win30
 *            +------------------------ Memory image constructed from PCODE
 */

#define NENEWFILES      0x01            /* os/2 app understands eas and longnames */
#define NEINFONT        0x02            /* 2.x app gets proportional font */
#define NEINPROT        0x04            /* 2.x app runs in 3.x prot mode  */
#define NEGANGLOAD      0x08            /* Reserved for Win 3.0 */
#define NEHASPCODE      0x10            /* .EXE contains PCODE module */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc


/*
 *  Format of NS_FLAGS(x)
 *
 *  Flag word has the following format:
 *
 *      15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *          |  |  |  |  | | | | | | | | | | |
 *          |  |  |  |  | | | | | | | | +-+-+--- Segment type DATA/CODE
 *          |  |  |  |  | | | | | | | +--------- Iterated segment
 *          |  |  |  |  | | | | | | +----------- Movable segment
 *          |  |  |  |  | | | | | +------------- Segment can be shared
 *          |  |  |  |  | | | | +--------------- Preload segment
 *          |  |  |  |  | | | +----------------- Execute/read-only for code/data segment
 *          |  |  |  |  | | +------------------- Segment has relocations
 *          |  |  |  |  | +--------------------- Code conforming/Data is expand down
 *          |  |  |  +--+----------------------- I/O privilege level
 *          |  |  +----------------------------- Discardable segment
 *          |  +-------------------------------- 32-bit code segment
 *          +----------------------------------- Huge segment/GDT allocation requested
 *
 */

#define NSTYPE          0x0007          /* Segment type mask */

#if !EXE386
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSSHARED        0x0020          /* Shared segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSCONFORM       0x0200          /* Conforming segment */
#define NSEXPDOWN       0x0200          /* Data segment is expand down */
#define NSDPL           0x0C00          /* I/O privilege level (286 DPL bits) */
#define SHIFTDPL        10              /* Left shift count for SEGDPL field */
#define NSDISCARD       0x1000          /* Segment is discardable */
#define NS32BIT         0x2000          /* 32-bit code segment */
#define NSHUGE          0x4000          /* Huge memory segment, length of
                                         * segment and minimum allocation
                                         * size are in segment sector units
                                         */
#define NSGDT           0x8000          /* GDT allocation requested */

#define NSPURE          NSSHARED        /* For compatibility */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

#define NSLOADED    0x0004      /* ns_sector field contains memory addr */
#endif


struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

#pragma pack(1)


struct new_rlc                          /* Relocation item */
  {
    unsigned char       nr_stype;       /* Source type */
    unsigned char       nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            unsigned char  nr_segno;    /* Target segment number */
            unsigned char  nr_res;      /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
        struct
          {
            unsigned short nr_ostype;   /* OSFIXUP type */
            unsigned short nr_osres;    /* reserved */
          }             nr_osfix;       /* Operating system fixup */
      }                 nr_union;       /* Union */
  };

#pragma pack()


#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc
#define NR_OSTYPE(x)    (x).nr_union.nr_osfix.nr_ostype
#define NR_OSRES(x)     (x).nr_union.nr_osfix.nr_osres



/*
 *  Format of NR_STYPE(x) and R32_STYPE(x):
 *
 *       7 6 5 4 3 2 1 0  - bit no
 *               | | | |
 *               +-+-+-+--- source type
 *
 */

#define NRSTYP          0x0f            /* Source type mask */
#define NRSBYT          0x00            /* lo byte (8-bits)*/
#define NRSSEG          0x02            /* 16-bit segment (16-bits) */
#define NRSPTR          0x03            /* 16:16 pointer (32-bits) */
#define NRSOFF          0x05            /* 16-bit offset (16-bits) */
#define NRPTR48         0x06            /* 16:32 pointer (48-bits) */
#define NROFF32         0x07            /* 32-bit offset (32-bits) */
#define NRSOFF32        0x08            /* 32-bit self-relative offset (32-bits) */


/*
 *  Format of NR_FLAGS(x) and R32_FLAGS(x):
 *
 *       7 6 5 4 3 2 1 0  - bit no
 *                 | | |
 *                 | +-+--- Reference type
 *                 +------- Additive fixup
 */

#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define NRROSF          0x03            /* Operating system fixup */


#if !EXE386

/* Resource type or name string */
struct rsrc_string
    {
    unsigned char rs_len;            /* number of bytes in string */
    unsigned char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0xF000      /* Discard priority level for resource */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align


#endif /* !EXE386 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newent.c ===
/*
 *  TITLE
 *              newent.c
 *              Pete Stewart
 *              (C) Copyright Microsoft Corp 1984-1989
 *              1  October 1984
 *
 *  DESCRIPTION
 *              This file contains routines for the DOS 4.0 linker
 *              that manage per-segment entry point information.
 *
 *              It also contains routines that manage per-segment
 *              relocation information.
 *
 *  Modifications:
 *
 *      09-Feb-1989 RB  Fix Insert().
 */

#include                <minlit.h>      /* Basic type definitions */
#include                <bndtrn.h>      /* Constants and compound types */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE format data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE format data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <impexp.h>

#define hashra(ra)      (WORD) ((ra) % HEPLEN)
                                        /* Function to hash offset */
#if NOT EXE386
#define hashrlc(r)      (((NR_SEGNO(*r) << NR_STYPE(*r)) + NR_ENTRY(*r)) & HASH_SIZE - 1)
                                        /* Hash relocation item */
#define EOC             ((RATYPE) 0xFFFF)
                                        /* End-of-chain marker */
#endif

#define IsInSet(x)      ((pOrdinalSet[(x) >> 3] & BitMask[(x) & 0x07]) != 0)
#define NotInSet(x)     ((pOrdinalSet[(x) >> 3] & BitMask[(x) & 0x07]) == 0)
#define SetBit(x)       (pOrdinalSet[(x) >> 3] |= BitMask[(x) & 0x07])
#define MaxIndex        8192
#define ET_END          0xffff

/*
 *  FUNCTION PROTOTYPES
 */


LOCAL void           NEAR NewBundle(unsigned short type);
LOCAL WORD           NEAR MatchRlc(RLCPTR rlcp0,
                                   RLCPTR rlcp1);
#if NOT QCLINK
LOCAL void           NEAR NewEntry(unsigned short sa,
                                   RATYPE ra,
                                   unsigned char flags,
                                   unsigned short hi,
                                   unsigned short ord);
LOCAL void                SavExp1(APROPNAMEPTR apropexp,
                                  RBTYPE rhte,
                                  RBTYPE rprop,
                                  WORD fNewHte);
LOCAL void                SavExp2(APROPNAMEPTR apropexp,
                                  RBTYPE rhte,
                                  RBTYPE rprop,
                                  WORD fNewHte);
LOCAL WORD           NEAR BuildList(WORD NewOrd, RBTYPE NewProp);
LOCAL WORD           NEAR FindFreeRange(void);
LOCAL WORD           NEAR Insert(RBTYPE NewProp);
#endif


/*
 *  LOCAL DATA
 */

#if NOT QCLINK
#pragma pack(1)

typedef struct _BUNDLE
{
    BYTE        count;
    BYTE        type;
}
                BUNDLE;

#pragma pack()

LOCAL WORD              ceCurBnd;       /* No. of entries in current bundle */
LOCAL WORD              offCurBnd;      /* Offset of current bundle header */
LOCAL WORD              tyCurBnd;       /* Type of current bundle */

LOCAL WORD              ordMac;         /* Highest entry ordinal number */
LOCAL BYTE              *pOrdinalSet;
#if EXE386
LOCAL APROPEXPPTR       pExport;        /* Pointer to export property cell */
#endif
LOCAL struct {
               WORD ord;                /* Current available ordinal */
               WORD count;              /* Number of free ordinals in range */
             }
                        FreeRange;

LOCAL BYTE              BitMask[] = {   /* Bit mask used in set operations */
                                      0x01,
                                      0x02,
                                      0x04,
                                      0x08,
                                      0x10,
                                      0x20,
                                      0x40,
                                      0x80 };

LOCAL WORD              MinOrd = 0;     /* Min ordinal number see so far */
LOCAL WORD              MaxOrd = 0;     /* Max ordinal number see so far */
      RBTYPE            pMinOrd = NULL; /* Pointer to property cell with MinOrd */
LOCAL RBTYPE            pMaxOrd = NULL; /* Pointer to property cell with MaxOrd */
LOCAL RBTYPE            pStart;

#ifndef UNPOOLED_RELOCS
LOCAL void *            pPoolRlc;       /* memory pool for relocations */
#endif



#if NOT EXE386
LOCAL void NEAR         NewBundle(type) /* Make a new bundle */
WORD                    type;           /* Type of new bundle */
{
    BUNDLE FAR          *pBnd;          /* Ptr to start of bundle or entry */
    BUNDLE              bnd;

    if (EntryTable.byteMac != 0)
    {
        // If there is a previous bundle patch the count filed

        pBnd = (BUNDLE FAR *) &(EntryTable.rgByte[offCurBnd]);
        pBnd->count = (BYTE) ceCurBnd;
    }

    bnd.count = 0;
    bnd.type  = (BYTE) type;
    offCurBnd = AddEntry((BYTE *) &bnd, sizeof(BUNDLE));
    ceCurBnd  = 0;
    tyCurBnd  = type;

    if (type == ET_END)
        EntryTable.byteMac--;
}
#endif


    /****************************************************************
    *                                                               *
    * NAME: NewEntry                                                *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function  makes  an  entry  in  the Entry Table for a  *
    *   given file segment  number, offset, and flag set.  It also  *
    *   makes  an  entry  in  the  entry address hash table on the  *
    *   given  hash  chain  for  the  new entry point.  N.B.: this  *
    *   function assumes the static  variable ordMac is set to the  *
    *   desired ordinal value for the entry being added.            *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   SATYPE          sa              File segment number         *
    *   RATYPE          ra              Offset                      *
    *   FTYPE           flags           Entry point flags           *
    *   WORD            hi              Hash table index            *
    *   WORD            ord             New ordinal                 *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   WORD                            Offset in Entry Table       *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Maintains  a hash table hashing file  segment/offset pairs  *
    *   to  entry  table offsets.  Builds  in virtual  memory  the  *
    *   Entry Table.  Updates the  following variables:             *
    *                                                               *
    *   WORD            offCurBnd       Offset of start of current  *
    *                                   bundle of entries.          *
    *   WORD            ceCurBnd        Count  of  entries in cur-  *
    *                                   rent bundle.                *
    *   WORD            tyCurBnd        Type of current bundle.     *
    *   WORD            cbEntTab        Size  of  Entry  Table  in  *
    *                                   bytes.                      *
    *                                                               *
    *   NOTE: THIS FUNCTION CALLS THE VIRTUAL MEMORY MANAGER.       *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         NewEntry(sa,ra,flags,hi,ord)
SATYPE                  sa;             /* File segment number */
RATYPE                  ra;             /* Segment offset */
FTYPE                   flags;          /* Entry point flags */
WORD                    hi;             /* Hash table index */
WORD                    ord;            /* New ordinal */
{
    EPTYPE FAR          *ep;            /* Entry point node */
#if NOT EXE386
    WORD                tyEntry;        /* Entry type */
    WORD                cbEntry;        /* Length of entry in bytes */
    BYTE                entry[6];       /* The entry itself - NE version */
#endif
#if EXE386
    static WORD         prevEntryOrd;   // Previous export ordinal
    DWORD               eatEntry;       /* The entry itself - LE version */
#endif

#if NOT EXE386
    if(sa == SANIL)                 /* If absolute symbol */
        tyEntry = BNDABS;           /* use fake segment # */
    else if (TargetOs == NE_OS2)
        tyEntry = NonConfIOPL(mpsaflags[sa]) ? BNDMOV: sa;
    else
        tyEntry = (mpsaflags[sa] & NSMOVE)? BNDMOV: sa;
                                    /* Get the entry type */
    /* If not library, or realmode and not solo data, clear local data bit. */
    if(!(vFlags & NENOTP) || (!(vFlags & NEPROT) && !(vFlags & NESOLO)))
        flags &= ~2;
    entry[0] = (BYTE) flags;        /* Set the entry flags */
    if(tyEntry == BNDMOV            /* If entry is in movable segment */
#if O68K
        && iMacType == MAC_NONE
#endif
    )
    {
        ++cMovableEntries;          /* Increment movable entries count */
        cbEntry = 6;                /* Entry is six bytes long */
        entry[1] = 0xCD;            /* INT... */
        entry[2] = 0x3F;            /* ...3FH */
        entry[3] = (BYTE) sa;       /* File segment number */
        entry[4] = (BYTE) ra;       /* Lo-byte of offset */
        entry[5] = (BYTE)(ra >> BYTELN);/* Hi-byte of offset */
    }
    else                            /* Else if fixed entry */
    {
        cbEntry = 3;                /* Entry is three bytes long */
        entry[1] = (BYTE) ra;       /* Lo-byte of offset */
        entry[2] = (BYTE)(ra >> BYTELN);/* Hi-byte of offset */
    }
#endif

#if EXE386
    /*
     *  This function creates one entry in the Export Address Table.
     *  The EAT table is stored in linker's VM in area AREAEAT. The
     *  global variable cbEntTab always points to free space in the
     *  AREAEAT.
     */


    eatEntry = 0L;
    if ((prevEntryOrd != 0) && (ord > prevEntryOrd + 1))
    {
        // Write unused entries in the Export Address Table

        for (; prevEntryOrd < ord - 1; prevEntryOrd++)
        {
            if (cbEntTab + sizeof(DWORD) > MEGABYTE)
                Fatal(ER_eatovf, MEGABYTE);
            vmmove(sizeof(DWORD), &eatEntry, (long)(AREAEAT + cbEntTab), TRUE);
            cbEntTab += sizeof(DWORD);
        }
    }
    prevEntryOrd = ord;

    // FLAT address

    eatEntry = mpsaBase[sa] + ra;

    /* Check for Entry Table overflow */

    if (cbEntTab + sizeof(DWORD) > MEGABYTE)
        Fatal(ER_eatovf, MEGABYTE);
#endif

    /*  Insert the new entry */

#if NOT EXE386
    if (tyCurBnd != tyEntry || ceCurBnd == BNDMAX)
        NewBundle(tyEntry);         /* Make a new bundle if needed */

    ++ceCurBnd;                     /* Increment counter */
#endif

    /* Save entry in virtual memory */

#if EXE386
    vmmove(sizeof(DWORD), &eatEntry, (long)(AREAEAT + cbEntTab), TRUE);
#else
    AddEntry(entry, cbEntry);
#endif
    ep = (EPTYPE FAR *) GetMem(sizeof(EPTYPE));
    ep->ep_next = htsaraep[hi];         /* Link old chain to new node */
    ep->ep_sa = sa;                     /* Save the file segment number */
    ep->ep_ra = ra;                     /* Save offset */
    ep->ep_ord = ord;                   /* Save Entry Table ordinal */
    htsaraep[hi] = ep;                  /* Make new node head of chain */
}

    /****************************************************************
    *                                                               *
    * NAME: MpSaRaEto                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  returns  an  Entry Table  ordinal  given a  *
    *   file segment  number (sa) for  a segment and an  offset in  *
    *   that segment.                                               *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   SATYPE          sa              File segment number         *
    *   RATYPE          ra              Offset                      *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   WORD                            Entry Table ordinal         *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Calls NewEntry().  Increments ordMac.                       *
    *                                                               *
    *   NOTE: THIS FUNCTION CALLS THE VIRTUAL MEMORY MANAGER.       *
    *                                                               *
    ****************************************************************/

WORD NEAR               MpSaRaEto(sa,ra)
SATYPE                  sa;             /* File segment number */
RATYPE                  ra;             /* Segment offset */
{
    WORD                hi;             /* Hash table index */
    EPTYPE FAR          *ep;            /* Entry point node */

    hi = hashra(ra);                    /* Hash the offset */
    for (ep = htsaraep[hi]; ep != NULL; ep = ep->ep_next)
    {                                   /* Loop through hash chain */
        if (ep->ep_sa == sa && ep->ep_ra == ra)
            return(ep->ep_ord);
                                        /* If match found, return number */
    }

    // At this point, we know a new entry must be created.

    NewEntry(sa, ra, 0, hi, ++ordMac);  /* Add a new entry */
    return(ordMac);                     /* Return Entry Table ordinal */
}


    /****************************************************************
    *                                                               *
    * NAME: BuildList                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  links the property cells of  exports  with  *
    *   preassigned ordinals into list.   Global pointers  pMinOrd  *
    *   and pMaxOrd points to the begin and end of this list.  The  *
    *   preassigned ordinals are stored in the set pointed by  the  *
    *   global pointer pOrdinalSet.                                 *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   WORD            NewOrd          New preassigned ordinal     *
    *   RBTYPE          NewProp         Addr of property cell       *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   TRUE if ordinal seen for the first time, otherwise FALSE.   *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Changes pMinOrd and pMaxOrd pointers, sets bits in ordinal  *
    *   set and sets MinOrd, MaxOrd seen so far.                    *
    *                                                               *
    ****************************************************************/


LOCAL WORD NEAR     BuildList(WORD NewOrd, RBTYPE NewProp)

{
    RBTYPE          pTemp;              /* Temporary pointer to property cell */
    APROPEXPPTR     pExpCurr;           /* Export record pointer */
    APROPEXPPTR     pExpPrev;           /* Export record pointer */


    if (!MinOrd && !MaxOrd)
    {                                   /* First time call */
        MinOrd = MaxOrd = NewOrd;
        pMinOrd = pMaxOrd = NewProp;
        SetBit(NewOrd);
        return TRUE;
    }

    if (IsInSet(NewOrd))
        return FALSE;                   /* Ordinal all ready used */

    SetBit(NewOrd);                     /* Set bit in ordinal set */

    if (NewOrd > MaxOrd)
    {                                   /* Add new at the list end */
        pExpCurr = (APROPEXPPTR ) FetchSym(pMaxOrd,TRUE);
        pExpCurr->ax_NextOrd = NewProp;
        MARKVP();
        pMaxOrd = NewProp;
        MaxOrd = NewOrd;
        pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
        pExpCurr->ax_NextOrd = NULL;
        MARKVP();
    }
    else if (NewOrd < MinOrd)
    {                                   /* Add new at list begin */
        pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
        pExpCurr->ax_NextOrd = pMinOrd;
        MARKVP();
        pMinOrd = NewProp;
        MinOrd = NewOrd;
    }
    else
    {                                   /* Add new in the middle of list */
        pTemp = pMinOrd;
        do
        {
            pExpPrev = (APROPEXPPTR ) FetchSym(pTemp,TRUE);
            pExpCurr = (APROPEXPPTR ) FetchSym(pExpPrev->ax_NextOrd,TRUE);
            if (NewOrd < pExpCurr->ax_ord)
            {
                pTemp = pExpPrev->ax_NextOrd;
                pExpPrev->ax_NextOrd = NewProp;
                MARKVP();
                pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
                pExpCurr->ax_NextOrd = pTemp;
                MARKVP();
                break;
            }
            pTemp = pExpPrev->ax_NextOrd;
        } while (pTemp);
    }
    if(NewOrd > ordMac) ordMac = NewOrd;      /* Remember largest ordinal */
    return TRUE;
}


    /****************************************************************
    *                                                               *
    * NAME: FindFreeRange                                           *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  finds in the ordinal  set  first available  *
    *   free  range of ordinals.                                    *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   TRUE if free range found, otherwise FALSE.                  *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Changes FreeRange descriptor by setting first free ordinal  *
    *   and the lenght of range.                                    *
    *                                                               *
    ****************************************************************/



LOCAL WORD NEAR     FindFreeRange(void)

{
    int             ByteIndex;
    int             BitIndex;


    ByteIndex = FreeRange.ord >> 3;
    BitIndex  = FreeRange.ord &  0x07;

    while ((pOrdinalSet[ByteIndex] & BitMask[BitIndex]) &&
            ByteIndex < MaxIndex)
    {                                   /* Skip all used ordinals */
        FreeRange.ord++;
        BitIndex = (BitIndex + 1) & 0x07;
        if (!BitIndex)
            ByteIndex++;
    }

    if (ByteIndex < MaxIndex)
    {
        if (FreeRange.ord > MaxOrd)
        {
            FreeRange.count = 0xffff - MaxOrd;
            return TRUE;
        }

        do
        {                               /* Count all unused ordinals */
            FreeRange.count++;
            BitIndex = (BitIndex + 1) & 0x07;
            if (!BitIndex)
                ByteIndex++;
        } while (!(pOrdinalSet[ByteIndex] & BitMask[BitIndex]) &&
                 ByteIndex < MaxIndex);
        return TRUE;
    }
    return FALSE;
}



    /****************************************************************
    *                                                               *
    * NAME: Insert                                                  *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  inserts into the exports list new property  *
    *   cell without preassigned ordinal. It assigns new ordinal.   *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   RBTYPE          NewProp        New property cell to insert  *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   New assigned ordinal.                                       *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Changes FreeRange descriptor and MaxOrd assigned so far.    *
    *                                                               *
    ****************************************************************/



LOCAL WORD NEAR     Insert(RBTYPE NewProp)

{
    APROPEXPPTR     pExpCurr;           /* Export record pointer */
    APROPEXPPTR     pExpPrev;           /* Export record pointer */
    WORD            NewOrd;
    RBTYPE          pTemp, rbPrev, rbCur;
    /*
     * On entry, pStart points to the place in the export list where
     * NewProp should be inserted.  If NULL, the list is empty.
     */
    if (!FreeRange.count)
    {
        /* No more space left in current free range; find the next one.  */
        if (!FindFreeRange())
            Fatal(ER_expmax);
        /*
         * Update pStart (the insertion point) by walking down the list and
         * finding the first element whose ordinal is greater than the new
         * ordinal, or the end of the list if none is found.
         */
        rbPrev = RHTENIL;
        for (rbCur = pStart; rbCur != RHTENIL; rbCur = pExpCurr->ax_NextOrd)
        {
            pExpCurr = (APROPEXPPTR) FetchSym(rbCur, FALSE);
            if (pExpCurr->ax_ord > FreeRange.ord)
                break;
            rbPrev = rbCur;
        }
        /* Set pStart to the insertion point.  */
        pStart = rbPrev;
    }

    /* Insert new property cell */

    NewOrd = FreeRange.ord++;
    FreeRange.count--;
    SetBit(NewOrd);
    pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
    pExpCurr->ax_ord = NewOrd;
    MARKVP();
    if (pStart != NULL)
    {
        // We're not inserting at head of list.  Append new cell to previous
        // cell.
        pExpPrev = (APROPEXPPTR ) FetchSym(pStart,TRUE);
        pTemp = pExpPrev->ax_NextOrd;
        pExpPrev->ax_NextOrd = NewProp;
        MARKVP();
    }
    else
    {
        // We're inserting at head of list.  Set head list pointer to new
        // cell.
        pTemp = pMinOrd;
        pMinOrd = NewProp;
    }
    /*
     * Set the next pointer to the following element in the list.
     */
    pExpCurr = (APROPEXPPTR ) FetchSym(NewProp,TRUE);
    pExpCurr->ax_NextOrd = pTemp;
    MARKVP();
    /*
     * Update MaxOrd and pStart.
     */
    if (NewOrd > MaxOrd)
        MaxOrd++;
    pStart = NewProp;
    return NewOrd;
}





    /****************************************************************
    *                                                               *
    * NAME: SavExp1                                                 *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This  function  places  the virtual addresses  of property  *
    *   cells for  exports with  preassigned ordinals into a table  *
    *   which will later  be used to  create the first part of the  *
    *   entry  table.  It also  verifies  the validity of  the ex-  *
    *   ports.                                                      *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   APROPEXPPTR     apropexp        Export record pointer       *
    *   RBTYPE          rhte            Addr of hash table entry    *
    *   RBTYPE          rprop           Address of export record    *
    *   FTYPE           fNewHte         New hash table entry flag   *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Entries  are  made  in  a  table on the stack to which the  *
    *   local  static  variable  prb  points.  The global variable  *
    *   ordMac  is set  to the highest  ordinal value found.  Pro-  *
    *   perty cells  for exports  are updated to contain  the file  *
    *   segment number and offset of the entry point.               *
    *                                                               *
    *   NOTE: THIS FUNCTION CALLS THE VIRTUAL MEMORY MANAGER.       *
    *                                                               *
    ****************************************************************/

LOCAL void              SavExp1(APROPNAMEPTR apropexp,
                                RBTYPE       rhte,
                                RBTYPE       rprop,
                                WORD         fNewHte)
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    LOCAL  APROPNAMEPTR apropnam;       /* Public definition record pointer */
    LOCAL  APROPPTR     aprop;          /* temp. pointer */
    WORD                ord;            /* Entry ordinal */
    SATYPE              sa;             /* File segment number */
    RATYPE              ra;             /* Offset in segment */
    WORD                fStartSeen=0;   /* Have we seen the start of the list */
    APROPEXPPTR         pExport;
    char                *p;

    ASSERT(fNewHte);                    /* Only once per customer */
    pExport = (APROPEXPPTR ) apropexp;
    if((ord = pExport->ax_ord) >= EXPMAX)
    {                                   /* If ordinal too big */
        pExport->ax_ord = 0;            /* Treat as unspecified */
        ord = 0;
        MARKVP();                       /* Page has changed */
        /* Issue error message */
        ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
        OutError(ER_ordmax,1 + GetFarSb(ahte->cch));
    }
    apropnam = (APROPNAMEPTR ) FetchSym(pExport->ax_symdef,FALSE);
                                        /* Fetch the public symbol def. */


    for (aprop = (APROPPTR) apropnam; aprop->a_attr != ATTRPNM;)
    {

       if(aprop->a_attr == ATTRALIAS)      /* If an alias */
       {
            aprop = (APROPPTR) FetchSym(
                    ((APROPALIASPTR)aprop)->al_sym, FALSE );
            if (aprop->a_attr == ATTRPNM)  /* The substitute is a public-OK */
                break;
       }

       aprop = (APROPPTR) FetchSym (aprop->a_next, FALSE);
       if (aprop->a_next == NULL && aprop->a_attr == ATTRNIL) /* Beginning of list */
       {
            aprop = (APROPPTR) FetchSym ( ((AHTEPTR)aprop)->rprop, FALSE);
            fStartSeen ++;
       }

       if ((aprop != (APROPPTR) apropnam) && (fStartSeen<2))
            continue;        /* Find an ALIAS or the starting point */

       /* Issue error message */
       if(SbCompare(GetPropName(FetchSym(rhte,FALSE)), GetPropName(FetchSym(pExport->ax_symdef,FALSE)), 0))
       {
            /* skip the (alias %s) part */
            OutError(ER_expund,1 + GetPropName(FetchSym(rhte,FALSE)), " ");
       }
       else
       {
            if(p = GetMem(SBLEN + 20))
                sprintf(p, " (alias %s) ", 1 + GetPropName(FetchSym(pExport->ax_symdef,FALSE)));
            OutError(ER_expund,1 + GetPropName(FetchSym(rhte,FALSE)),p);
            if(p) FreeMem(p);
       }
       /* Flag export as undefined */
       pExport = (APROPEXPPTR ) FetchSym(rprop,TRUE);
       pExport->ax_symdef = RHTENIL;
       return;
    }

    apropnam = (APROPNAMEPTR) aprop;
    sa = mpsegsa[mpgsnseg[apropnam->an_gsn]];
                                        /* Get the file segment number */
    ra = apropnam->an_ra;               /* Get the offset in the segment */
#if NOT EXE386
    if(apropnam->an_flags & FIMPORT)    /* If public is an import */
    {
        /* Issue error message */
        OutError(ER_expimp,1 + GetPropName(FetchSym(rhte,FALSE)),
            1 + GetPropName(FetchSym(pExport->ax_symdef,FALSE)));
        /* Flag export as undefined */
        pExport = (APROPEXPPTR ) FetchSym(rprop,TRUE);
        pExport->ax_symdef = RHTENIL;
        return;
    }
    if (!IsIOPL(mpsaflags[sa]))         /* If not I/O privileg segment */
      pExport->ax_flags &= 0x07;        /* force parameter words to 0  */
#endif
    pExport = (APROPEXPPTR ) FetchSym(rprop,TRUE);
                                        /* Fetch the export property cell */
    pExport->ax_sa = sa;                /* Set the file segment number */
    pExport->ax_ra = ra;                /* Set the offset in the segment */
    MARKVP();
    if(ord == 0) return;                /* Skip unspecified ordinals for now */
    if(!BuildList(ord, rprop))          /* If ordinal conflict found */
    {
        /*
         * Issue error message for ordinal conflict
         */
        OutError(ER_ordmul,ord,1 + GetPropName(FetchSym(rhte,FALSE)));
        return;
    }
}

    /****************************************************************
    *                                                               *
    * NAME: SavExp2                                                 *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function  enters  those  exports  without preassigned  *
    *   ordinal  numbers into the  table to which  prb refers.  It  *
    *   also builds the resident and non-resident name tables.      *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   APROPEXPPTR     apropexp        Export record pointer       *
    *   RBTYPE          rhte            Addr of hash table entry    *
    *   RBTYPE          rprop           Address of export record    *
    *   FTYPE           fNewHte         New hash table entry flag   *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   Entries are  made in a table in  virtual memory.  A global  *
    *   variable is set to contain the highest ordinal value seen.  *
    *                                                               *
    *   NOTE: THIS FUNCTION CALLS THE VIRTUAL MEMORY MANAGER.       *
    *                                                               *
    ****************************************************************/

LOCAL void              SavExp2(APROPNAMEPTR apropexp,
                                RBTYPE       rhte,
                                RBTYPE       rprop,
                                WORD         fNewHte)
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    APROPNAMEPTR        apropnam;       /* Public definition record pointer */
    WORD                ord;            /* Ordinal number */
    WORD                cb;             /* # of bytes in name table entry */
    SATYPE              sa;             /* File segment number */
    FTYPE               fResNam;        /* True if name is resident */
    FTYPE               fNoName;        /* True if discard name */
    APROPEXPPTR         pExport;
    SBTYPE              sbName;


    pExport = (APROPEXPPTR ) apropexp;
    if (pExport->ax_symdef == RHTENIL) return;
                                        /* Skip undefined exports */
    apropnam = (APROPNAMEPTR ) FetchSym(pExport->ax_symdef,FALSE);
                                        /* Fetch the public symbol def. */
    sa = mpsegsa[mpgsnseg[apropnam->an_gsn]];
                                        /* Get the file segment number */
#if NOT EXE386
    if (!IsIOPL(mpsaflags[sa]))         /* If not I/O privileg segment */
      pExport->ax_flags &= 0x07;        /* force parameter words to 0  */
#endif
    if ((ord = pExport->ax_ord) == 0)   /* If unassigned export found */
    {
        ord = Insert(rprop);            /* Add new export to the list */
        fResNam = (FTYPE) TRUE;         /* Name is resident */
    }
    else
        fResNam = (FTYPE) ((pExport->ax_nameflags & RES_NAME) != 0);
                                        /* Else set resident name flag */
    fNoName = (FTYPE) ((pExport->ax_nameflags & NO_NAME) != 0);
    ahte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Get external name */
    cb = B2W(ahte->cch[0]) + 1;         /* Number of bytes incl. length byte */
#if EXE386
    /*
     * For linear-executable build the Export Name Pointers Table and
     * Export Name Table. For linear-executable all exported names
     * are put in one Exported Name Table; there is no distiction
     * between resident and non-resident tables. We still support
     * the NONAME keyword by removing the exported name
     * from the Export Name Table.
     */

    if (!fNoName)
    {
        if (cb > sizeof(sbName) - sizeof(BYTE))
            cb = sizeof(sbName) - sizeof(BYTE);
        memcpy(sbName, GetFarSb(ahte->cch), cb + 1);
                                        /* Copy the name to local buffer */
        if (fIgnoreCase)
            SbUcase(sbName);            /* Make upper case if ignoring case */

        // Store the pointer to the name; for now it is an offset from
        // the begin of Export Name Table (be sure that name doesn't
        // cross VM page boundary). Later when the size of the
        // Export Directory Table plus the size of Export Address Table
        // becomes known we update the entries in the Export Name Pointer
        // Table to become a relative virtual address from the Export
        // Directory Table.

        if ((cbExpName & (PAGLEN - 1)) + cb > PAGLEN)
            cbExpName = (cbExpName + PAGLEN - 1) & ~(PAGLEN - 1);

        vmmove(sizeof(DWORD), &cbExpName, AREANAMEPTR + cbNamePtr, TRUE);
        cbNamePtr += sizeof(DWORD);
        if (cbNamePtr > NAMEPTRSIZE)
            Fatal(ER_nameptrovf, NAMEPTRSIZE);

        // Store exported name

        vmmove(cb, &sbName[1], AREAEXPNAME + cbExpName, TRUE);
        cbExpName += cb;
        if (cbExpName > EXPNAMESIZE)
            Fatal(ER_expnameovf, EXPNAMESIZE);
    }
#else
    /* Add exported name to segmented-executable name tables */

    if (fResNam || !fNoName)
    {
        if (cb > sizeof(sbName) - sizeof(BYTE))
            cb = sizeof(sbName) - sizeof(BYTE);
        memcpy(sbName, GetFarSb(ahte->cch), cb + 1);
                                        /* Copy the name to local buffer */
        if (fIgnoreCase
#if NOT OUT_EXP
                || TargetOs == NE_WINDOWS
#endif
            )
            SbUcase(sbName);            /* Make upper case if ignoring case */

        AddName(fResNam ? &ResidentName : &NonResidentName,
                sbName, ord);
    }
#endif
}

#pragma check_stack(on)

void NEAR               InitEntTab()
{
    BYTE                OrdinalSet[MaxIndex];
                                        /* Ordinal numbers set */
#if NOT EXE386
    APROPEXPPTR         exp;            /* Pointer to export property cell */
#endif
    WORD                i;              /* Index */

    tyCurBnd = 0xFFFF;                  /* Won't match any legal types */
    ceCurBnd = 0;                       /* No entries yet */
    offCurBnd = 0;                      /* First bundle at beginning */
    ordMac = 0;                         /* Assume no exported entries */
    pOrdinalSet = OrdinalSet;           /* Set global pointer */
    memset(OrdinalSet,0,MaxIndex*sizeof(BYTE));
                                        /* Initialize set to empty */
    EnSyms(SavExp1,ATTREXP);            /* Enumerate exports with ordinals */
    FreeRange.ord = 1;                  /* Initialize free range of ordinals */
    FreeRange.count = 0;
    pStart = pMinOrd;
    EnSyms(SavExp2,ATTREXP);            /* Enumerate exports without ordinals */
    if (MaxOrd > ordMac)
        ordMac = MaxOrd;
    pStart = pMinOrd;
    for(i = 1; i <= ordMac && pStart != NULL; ++i)
    {                                   /* Loop to start Entry Table */
#if EXE386
        pExport = (APROPEXPPTR ) FetchSym(pStart,FALSE);
                                        /* Fetch symbol from virtual memory */
        pStart = pExport->ax_NextOrd;   /* Go down on list */
        NewEntry(pExport->ax_sa, pExport->ax_ra, pExport->ax_flags,
                 hashra(pExport->ax_ra), pExport->ax_ord);
#else
        if(NotInSet(i))                 /* If a hole found */
        {
            if (tyCurBnd != BNDNIL || ceCurBnd == BNDMAX)
                NewBundle(BNDNIL);
                                        /* Make a new bundle if needed */
            ++ceCurBnd;                 /* Increment counter */
            continue;                   /* Next iteration */
        }
        exp = (APROPEXPPTR ) FetchSym(pStart,FALSE);
                                        /* Fetch symbol from virtual memory */
        pStart = exp->ax_NextOrd;       /* Go down on list */
        NewEntry(exp->ax_sa,exp->ax_ra,exp->ax_flags,hashra(exp->ax_ra),i);
#endif
                                        /* Create Entry Table entry */
    }
#if EXE386
    SortPtrTable();
    pExport = NULL;
#endif
}

#pragma check_stack(off)


#if NOT EXE386

    /****************************************************************
    *                                                               *
    * NAME: OutEntTab                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function  writes  the  Entry  Table to the executable  *
    *   file.  First it writes an  empty bundle to mark the end of  *
    *   the table.                                                  *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   None                                                        *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   A table  is written  to the  file specified  by the global  *
    *   file  pointer, bsRunfile.  This  function  calls  OutVm(),  *
    *   which CALLS THE VIRTUAL MEMORY MANAGER.                     *
    *                                                               *
    ****************************************************************/

void NEAR   OutEntTab()
{
    NewBundle(ET_END);                        /* Append an empty bundle */
    WriteByteArray(&EntryTable);              /* Write the table */
}
#endif

#endif /* NOT QCLINK */

#if NOT EXE386


    /****************************************************************
    *                                                               *
    * NAME: MatchRlc                                                *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function compares two  relocation records and returns  *
    *   TRUE if they match.  Two records are said to match if they  *
    *   agree on the fixup type and the target specification.  The  *
    *   location being fixed up does not have to match.             *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   struct new_rlc    *rlcp0        Ptr to relocation record    *
    *   struct new_rlc    *rlcp1        Ptr to relocation record    *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   FTYPE                                                       *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   None.                                                       *
    *                                                               *
    ****************************************************************/

LOCAL WORD NEAR         MatchRlc(rlcp0,rlcp1)
RLCPTR                  rlcp0;  /* Ptr to struct new_rlc record */
RLCPTR                  rlcp1;  /* Ptr to struct new_rlc record */
{

    if(NR_STYPE(*rlcp0) != NR_STYPE(*rlcp1) ||
       NR_FLAGS(*rlcp0) != NR_FLAGS(*rlcp1)) return(FALSE);
                                        /* Check flags and type */
    if((NR_FLAGS(*rlcp0) & NRRTYP) == NRRINT)
    {                                   /* If internal reference */
        return((NR_SEGNO(*rlcp0) == NR_SEGNO(*rlcp1)) &&
               (NR_ENTRY(*rlcp0) == NR_ENTRY(*rlcp1)));
                                        /* Check internal references */
    }
    return((NR_MOD(*rlcp0) == NR_MOD(*rlcp1)) &&
           (NR_PROC(*rlcp0) == NR_PROC(*rlcp1)));
                                        /* Check imports */
}



    /****************************************************************
    *                                                               *
    * NAME: SaveFixup                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function saves a fixup record for emission later.  In  *
    *   addition, if the fixup is not additive, it builds chains.   *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   SATYPE            saLoc         Segment of location to fix  *
    *   relocation        *rlcp         Ptr to relocation record    *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   RATYPE                                                      *
    *   Returns  the previous head  of the fixup chain  so that it  *
    *   can be stuffed  into the location  being fixed up.  If the  *
    *   fixup is additive, however, it always returns EOC.          *
    *                                                               *
    ****************************************************************/

RATYPE NEAR             SaveFixup(SATYPE saLoc, RLCPTR rlcp)
{
    WORD                hi;             // Hash index
    RLCHASH FAR         *pHt;           // Hash table
    RLCBUCKET FAR       *pBucket;       // Relocation bucket
    WORD                fi;             // fixup bucket index
    RLCPTR              pRlc;           // Pointer to relocation record
    WORD                tmp;
    RATYPE              ra;
    void FAR            *pTmp;

#ifndef UNPOOLED_RELOCS
    if (pPoolRlc == NULL)
        pPoolRlc = PInit();
#endif

    if (mpsaRlc[saLoc] == NULL)
    {
        // Allocate hash vector for physical segment saLoc

#ifndef UNPOOLED_RELOCS
        mpsaRlc[saLoc] = (RLCHASH FAR *) PAlloc(pPoolRlc, sizeof(RLCHASH));
#else
        mpsaRlc[saLoc] = (RLCHASH FAR *) GetMem(sizeof(RLCHASH));
#endif
    }
    pHt = mpsaRlc[saLoc];
    tmp = hashrlc(rlcp);
    hi  = (WORD) tmp;
    pBucket = pHt->hash[hi];

#if FALSE
if (saLoc == 2 && hi == 8)
{
fprintf(stdout, "Storing fixup for segment: %d\r\n", saLoc);
fprintf(stdout, "   Source offset: %x; type: %x\r\n", NR_SOFF(*rlcp), NR_STYPE(*rlcp));
fprintf(stdout, "   Hash index: %d\r\n", hi);
}
#endif
    if (pBucket && !(NR_FLAGS(*rlcp) & NRADD))
    {
        // For non-additive fixups search the bucket for
        // matching relocation records

        for(fi = 0; fi < pBucket->count; fi++)
        {
            pRlc = &(pBucket->rgRlc[fi]);
            if (MatchRlc(pRlc, rlcp))
            {
                // Relocation records match - chain them

                ra = (WORD) NR_SOFF(*pRlc);
                                        // Save previous head of chain
                NR_SOFF(*pRlc) = NR_SOFF(*rlcp);
                                        // Insert new head of chain
#if FALSE
if (saLoc == 2 && hi == 8)
fprintf(stdout, "   Match found with fixup @%x\r\n", ra);
#endif
                return(ra);             // Return previous head of chain
            }
        }
    }

    // At this point, we know we have to add a new entry
    // to the bucket we are examining.

    pHt->count++;                       // Increment count of fixups per segment

#if FALSE
if (saLoc == 2 && hi == 8)
fprintf(stdout, "   New entry; Count: %d\r\n", pHt->count);
#endif
    // Check space in the bucket

    if (pBucket == NULL)
    {
        // Allocate new fixup bucket

#ifndef UNPOOLED_RELOCS
        pBucket = (RLCBUCKET FAR *) PAlloc(pPoolRlc, sizeof(RLCBUCKET));
        pBucket->rgRlc = (RLCPTR) PAlloc(pPoolRlc, BUCKET_DEF * sizeof(RELOCATION));
#else
        pBucket = (RLCBUCKET FAR *) GetMem(sizeof(RLCBUCKET));
        pBucket->rgRlc = (RLCPTR) GetMem(BUCKET_DEF * sizeof(RELOCATION));
#endif
        pBucket->countMax = BUCKET_DEF;
        pHt->hash[hi] = pBucket;
    }
    else if (pBucket->count >= pBucket->countMax)
    {
        // Realloc fixup bucket

#ifndef UNPOOLED_RELOCS
        // REVIEW: for now we just throw away the old memory, we'll free
        // REVIEW: it later, we do this infrequently anyways...

        pTmp = PAlloc(pPoolRlc, (pBucket->countMax << 1) * sizeof(RELOCATION));
        FMEMCPY(pTmp, pBucket->rgRlc, pBucket->countMax * sizeof(RELOCATION));
        // FFREE(pBucket->rgRlc);  NOT MUCH MEMORY WASTED HERE
#else
        pTmp = GetMem((pBucket->countMax << 1) * sizeof(RELOCATION));
        FMEMCPY(pTmp, pBucket->rgRlc, pBucket->countMax * sizeof(RELOCATION));
        FFREE(pBucket->rgRlc);
#endif
        pBucket->rgRlc = pTmp;
        pBucket->countMax <<= 1;
    }

    // Add new relocation record at the end of bucket

    NR_RES(*rlcp) = '\0';               // Zero the reserved field
    pBucket->rgRlc[pBucket->count] = *rlcp;
    ++pBucket->count;                   // Increment count of fixups
    return(EOC);                        // Return end-of-chain marker
}

    /****************************************************************
    *                                                               *
    * NAME: OutFixTab                                               *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This fuction writes the load-time relocation (fixup) table  *
    *   for a given file segment to the execuatble file.            *
    *                                                               *
    * ARGUMENTS:                                                    *
    *                                                               *
    *   SATYPE          sa              File segment number         *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   A table  is written  to the  file specified  by the global  *
    *   file  pointer, bsRunfile.                                   *
    *                                                               *
    ****************************************************************/

void NEAR               OutFixTab(SATYPE sa)
{
    WORD                hi;             // Hash table index
    RLCHASH FAR         *pHt;
    RLCBUCKET FAR       *pBucket;



    pHt = mpsaRlc[sa];
    WriteExe(&(pHt->count), CBWORD);    // Write the number of relocations
    for (hi = 0; hi < HASH_SIZE; hi++)
    {
        pBucket = pHt->hash[hi];
        if (pBucket != NULL)
        {
            WriteExe(pBucket->rgRlc, pBucket->count * sizeof(RELOCATION));
#ifdef UNPOOLED_RELOCS
            FFREE(pBucket->rgRlc);
#endif
        }
    }
#ifdef UNPOOLED_RELOCS
    FFREE(pHt);
#endif
}

    /****************************************************************
    *                                                               *
    * NAME: ReleaseRlcMemory                                        *
    *                                                               *
    * DESCRIPTION:                                                  *
    *                                                               *
    *   This function releases the pool(s) of memory that held the  *
    *   segment relocations                                         *
    *                                                               *
    * RETURNS:                                                      *
    *                                                               *
    *   Nothing.                                                    *
    *                                                               *
    * SIDE EFFECTS:                                                 *
    *                                                               *
    *   pPoolRlc is set to NULL so that we will fail if we should   *
    *   ever try to allocate more relocations after this point      *
    *                                                               *
    ****************************************************************/

void NEAR               ReleaseRlcMemory()
{
#ifndef UNPOOLED_RELOCS
    // free all the memory associated with the saved relocation
    if (pPoolRlc) {
        PFree(pPoolRlc);
        pPoolRlc = NULL;
        }
#endif
}

#endif /* NOT EXE386 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newflg.c ===
/*
*       Copyright Microsoft Corporation, 1983-1989
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                     FLAG PROCESSOR MODULE                     *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#if OIAPX286
#include                <xenfmt.h>      /* x.out definitions */
#endif
#include                <extern.h>      /* External declarations */
#include                <newexe.h>      /* DOS & 286 .EXE format structure def.s */
#if EXE386
#include                <exe386.h>      /* 386 .EXE format structure def.s */
#endif
#include                <process.h>

extern FTYPE            fNoExtDic;      /* Not searching extended dictionary */

LOCAL BYTE              *osbSwitch;     /* Switch pointer */
LOCAL MSGTYPE           SwitchErr;      /* Switch error number */

/*
 *  FUNCTION PROTOTYPES
 */

#if TIMINGS
LOCAL void NEAR SwShowTiming(void);
#endif // TIMINGS
#if PCODE
LOCAL void NEAR SwPCode(void);
#endif
LOCAL void NEAR SwAlign(void);
LOCAL void NEAR SwBatch(void);
#if ODOS3EXE
LOCAL void NEAR SwBinary(void);
#endif
LOCAL void NEAR SwCase(void);
LOCAL void NEAR SwCParMax(void);
LOCAL void NEAR SwDelexe(void);
LOCAL void NEAR SwDosExtend(void);
LOCAL void NEAR SwDosseg(void);
LOCAL void NEAR SwDSAlloc(void);
LOCAL void NEAR SwDynamic(void);
LOCAL void NEAR SwIdef(void);
LOCAL void NEAR SwOldOvl(void);
LOCAL void NEAR SwExePack(void);
LOCAL void NEAR SwFarCall(void);
#if EXE386
LOCAL void NEAR SwHeader(void);
#endif
#if NOT WIN_3
LOCAL void NEAR SwHelp(void);
LOCAL void NEAR SwShortHelp(void);
#endif
LOCAL void NEAR SwHigh(void);
#if ILINK
LOCAL void NEAR SwIncremental(void);
#endif
LOCAL void NEAR SwInfo(void);
LOCAL void NEAR SwIntNo(void);
#if (OSEGEXE AND defined(LEGO)) OR EXE386
LOCAL void NEAR SwKeepFixups(void);
#endif
#if EXE386
LOCAL void NEAR SwKeepVSize(void);
#endif
LOCAL void NEAR SwLineNos(void);
LOCAL void NEAR SwMap(void);
#if O68K
LOCAL void NEAR SwMac(void);
#endif /* O68K */
#if WIN_NT
LOCAL void NEAR SwMemAlign(void);
#endif
#if NOT EXE386
LOCAL void NEAR SwNewFiles(void);
#endif
LOCAL void NEAR SwNoDefLib(void);
LOCAL void NEAR SwNoExtDic(void);
LOCAL void NEAR SwNoFarCall(void);
LOCAL void NEAR SwNoGrp(void);
LOCAL void NEAR SwNologo();
LOCAL void NEAR SwNonulls(void);
LOCAL void NEAR SwNoPack(void);
LOCAL void NEAR SwNoUseReal(void);
LOCAL void NEAR SwPack(void);
LOCAL void NEAR SwPackData(void);
LOCAL void NEAR SwPackFunctions(void);
LOCAL void NEAR SwNoPackFunctions(void);
LOCAL void NEAR SwPadCode(void);
LOCAL void NEAR SwPadData(void);
LOCAL void NEAR SwPause(void);
LOCAL void NEAR SwPmType(void);
LOCAL void NEAR SwQuicklib(void);
LOCAL void NEAR SwSegments(void);
LOCAL void NEAR SwStack(void);
LOCAL void NEAR SwSymdeb(void);
LOCAL void NEAR SwWarnFixup(void);
#if DOSEXTENDER
LOCAL void NEAR SwRunReal(void);
#endif
#if QCLINK
LOCAL void NEAR SwZ1(void);
#endif
#if QCLINK OR Z2_ON
LOCAL void NEAR SwZ2 (void);
#endif
#if QCLINK
LOCAL void NEAR SwZincr(void);
#endif
LOCAL int  NEAR ParseNo(unsigned long *pResult);
LOCAL int  NEAR ParseStr(char *pResult);
LOCAL void NEAR BadFlag(unsigned char *psb, MSGTYPE errnum);
LOCAL int  NEAR FPrefix(unsigned char *psb1,unsigned char *psb2);




/*
 *  ParseNo :  Parse switch number
 *
 *  Return value:
 *      1       result stored in pointer
 *      0       no switch given
 *      -1      error
 */
LOCAL int NEAR          ParseNo(pResult)
unsigned long           *pResult;
{
    REGISTER char       *s;             /* String pointer */
    REGISTER WORD       ch;             /* A character */
    WORD                strlen;         /* String length */
    WORD                base = 10;      /* Base to read constant in */
    DWORD               oldval;

    oldval = *pResult = 0L;             /* Initialize */
    strlen = IFind(osbSwitch,':');      /* Look for a colon in the string */
    if(strlen != INIL && strlen < (WORD) (B2W(osbSwitch[0]) - 1))
    {                                   /* If switch form valid */
        s = &osbSwitch[strlen + 2];
                                        /* Set pointer past colon */
        strlen = B2W(osbSwitch[0]) - strlen - 1;
                                        /* Get length of string left */
        if(*s == '0')                   /* If string starts with 0 */
        {
            if(strlen > 1 && ((WORD) s[1] & 0137) == 'X')
            {                           /* If string starts with "0x" */
                base = 16;              /* Change base to hexadecimal */
                ++s;                    /* Skip over "0" */
                --strlen;               /* Decrement length */
            }
            else base = 8;              /* Else change to octal */
            ++s;                        /* Skip "0" (or "x") */
            --strlen;                   /* Decrement length */
        }
        while(strlen--)                 /* While not at end of string */
        {
            ch = B2W(*s++);             /* Get character */
            if(ch >= '0' && ch <= '9') ch -= (WORD) '0';
                                        /* Remove offset */
            else if(ch >= 'A' && ch < 'A' + base - 10) ch -= (WORD) 'A' - 10;
                                        /* Remove offset */
            else if(ch >= 'a' && ch < 'a' + base - 10) ch -= (WORD) 'a' - 10;
                                        /* Remove offset */
            else                        /* Invalid character */
            {
                SwitchErr = ER_swbadnum;
                return(-1);             /* Error */
            }
            if((*pResult *= base) < oldval)
            {
                SwitchErr = ER_swbadnum;
                return(-1);             /* Error */
            }
            *pResult += ch;
            oldval = *pResult;
        }
        return(1);                      /* Number is present */
    }
    else return(0);                     /* No number present */
}

/*
 *  ParseStr :  Parse switch string
 *
 *  Return value:
 *      1       result stored in string
 *      0       no switch string given
 */

LOCAL int NEAR          ParseStr(pResult)
char                    *pResult;       /* Length prefixed result */
{
    REGISTER char       *s;             /* String pointer */
    WORD                strlen;         /* String length */

    *pResult = '\0';                    /* Initialize */
    strlen = IFind(osbSwitch,':');      /* Look for a colon in the string */
    if(strlen != INIL && strlen < (WORD) (B2W(osbSwitch[0]) - 1))
    {                                   /* If switch form valid */
        s = &osbSwitch[strlen + 2];
                                        /* Set pointer past colon */
        strlen = B2W(osbSwitch[0]) - strlen - 1;
                                        /* Get length of string left */
        *pResult++ = (char) strlen;     /* Store length */

        while(strlen--)                 /* While not at end of string */
        {
            *pResult++ = (char) (*s++); /* Get character */
        }
        return(1);                      /* String is present */
    }
    else return(0);                     /* No stringr present */
}


#if PCODE
LOCAL void NEAR              SwPCode(void)
{

    SBTYPE              SwString;

    fNewExe = (FTYPE) TRUE;
    fMPC = (FTYPE) TRUE;

    if (ParseStr(SwString))
    {
        if(SwString[1] == 'n' || SwString[1] == 'N') // /PCODE:NOMPC
        {
            fIgnoreMpcRun = (FTYPE) TRUE;
            fMPC = (FTYPE) FALSE;
        }
    }
}
#endif
/***************************************************************/
/* Options common to all versions regardless of output format */

LOCAL void NEAR              SwCase()
{
    fIgnoreCase = (FTYPE) ~IGNORECASE;       /* Toggle default case sensitivity */
}

LOCAL void NEAR              SwLineNos()     /* Line numbers requested */
{
    vfLineNos = (FTYPE) TRUE;                /* Set flag */
}

#if LOCALSYMS
LOCAL void NEAR              SwLocals()      /* Local symbols requested */
{
    fLocals = (FTYPE) TRUE;                  /* Set flag */
}
#endif

#pragma check_stack(on)

LOCAL void NEAR              SwMap()         /* Link map requested */
{
    SBTYPE              SwString;
    int                 rc;

    vfMap = (FTYPE) TRUE;                    // Set flag
    if ((rc = ParseStr(SwString)) <= 0)      // Done if no num or error
        return;

    // The optional parameter following /MAP was originally intended
    // to tell the linker how much to space to allocate for sorting
    // more public symbols than the stack-based limit.  Since we now
    // dyamically allocate as much space as possible for sorting,
    // the parameter is no longer necessary and its value is ignored.
    // However, the side effect of suppressing the "sorted by name"
    // list is retained.

    if (SwString[1] == 'A' || SwString[1] == 'a')
        fListAddrOnly = (FTYPE) TRUE;        // /MAP:ADDRESS

    else if (SwString[1] == 'F' || SwString[1] == 'f')
        fFullMap = (FTYPE) TRUE;             // /MAP:FULL or /MAP:full
}


LOCAL void NEAR              SwNoDefLib()    /* Do not search default library */
{
    SBTYPE              SwString;
    SBTYPE              LibName;


    if (ParseStr(SwString))
    {
        vfNoDefaultLibrarySearch = FALSE;
                                        /* Clear flag - selective library search */
        strcpy(LibName, sbDotLib);
        UpdateFileParts(LibName, SwString);
        EnterName(LibName,ATTRSKIPLIB,TRUE);
    }
    else vfNoDefaultLibrarySearch = (FTYPE) TRUE;
                                        /* Set flag */
}

#pragma check_stack(off)

LOCAL void NEAR              SwNologo()
{
    // if fNoprompt is already set then either
    // a) /BATCH was specified, in which case /NOLOGO is redundant
    // b) BATCH was in _MSC_IDE_FLAGS in which case fNoEchoLrf has not been
    //    set, and we want to suppress echoing of the response file
    //    (see CAVIAR 2378 [rm])

    if (fNoprompt)
        fNoEchoLrf = TRUE;                   /* Do not echo response file */

    fNoBanner = TRUE;                        /* Do not display banner */
}

LOCAL void NEAR              SwBatch()       /* Do not prompt for files */
{
    fNoEchoLrf = (FTYPE) TRUE;               /* Do not echo response file */
    fNoprompt = (FTYPE) TRUE;                /* Do not prompt */
    fPauseRun = FALSE;                       /* Disable /PAUSE */
    fNoBanner = (FTYPE) TRUE;                /* Do not display banner */
}

#if ODOS3EXE
LOCAL void NEAR              SwBinary()      /* Produce .COM file */
{
    fBinary = (FTYPE) TRUE;
    SwNonulls();                             /* No nulls */
    fFarCallTrans = (FTYPE) TRUE;            /* Far call translation */
    packLim = LXIVK - 36;                    /* Default limit is 64K - 36 */
    fPackSet = (FTYPE) TRUE;                 /* Remember packLim was set */
}
#endif

#if SYMDEB
LOCAL void NEAR              SwSymdeb()      /* Symbolic debugging */
{
    SBTYPE              SwString;


    fSymdeb = (FTYPE) TRUE;
    if (ParseStr(SwString))
    {
        fCVpack =  (FTYPE) (SwString[1] == 'c' || SwString[1] == 'C');
    }
}
#endif

#if PERFORMANCE
LOCAL void NEAR              SwVMPerf()      /* Report on VM performance */
{
    fPerformance = (FTYPE) TRUE;                /* Set flag */
}
#endif

#if OSMSDOS
LOCAL void NEAR              SwPause()       /* Pause before writing executable */
{
    fPauseRun = (FTYPE) TRUE;                /* Set flag */
    fNoprompt = FALSE;                       /* Disable /NOPROMPT */
}
#endif

LOCAL void NEAR              SwStack()       /* Set stack segment size */
{
    unsigned long       num;
    int                 rc;

    if((rc = ParseNo(&num)) < 0)        /* Quit if error */
        return;
#if EXE386
    if(!rc || num > CBMAXSEG32 - 4L)
#else
    if(!rc || num > LXIVK - 2L)
#endif
        SwitchErr = ER_swstack;
    else
#if EXE386
        cbStack = num;
#else
        cbStack = (WORD) num;
#endif
}

LOCAL void NEAR              SwSegments()    /* Set maximum number of segments */
{
    unsigned long       nsegs;          /* Number of segments */
    int                 rc;

    if((rc = ParseNo(&nsegs)) <= 0)     /* Quit if error or no argument */
        return;
    if(nsegs > (long) GSNMAX)
        SwitchErr = ER_swseglim;
    else
    {
        if ((nsegs + 3L) > GSNMAX)
            gsnMax = GSNMAX;
        else
            gsnMax = (SNTYPE) nsegs;            /* Else set limit */
    }
}

#if EXE386
LOCAL void NEAR              SwMemAlign(void)/* Set memory object alignment factor */
{
    long                align;          /* Alignment size in bytes */
    int                 rc;

    if ((rc = ParseNo(&align)) < 0)     /* Quit if error */
        return;
    if (rc && align  >= 1)
    {                                   /* If value in legal range */
        for (objAlign = 32; objAlign != 0; --objAlign)
        {                               /* Loop to find log of align */
            if ((1L << objAlign) & align)
                break;                  /* Break when high bit found */
        }
        if ((1L << objAlign) == align)
            return;                     /* Align must be power of two */
    }
    OutWarn(ER_alnbad);                 /* Output warning message */
    objAlign = DFOBJALIGN;              /* Use default value */
}
#endif

#if NOT EXE386
LOCAL void NEAR              SwNewFiles(void)
{
    vFlagsOthers |= NENEWFILES;         /* Set flag */
}
#endif

#if FDEBUG
LOCAL void NEAR              SwInfo()        /* Turn on runtime debugging */
{
    fDebug = (FTYPE) TRUE;                   /* Set flag */
}
#endif

#if LIBMSDOS
LOCAL void NEAR              SwNoExtDic()    /* Don't search extended dictionary */
{
    fNoExtDic = (FTYPE) TRUE;
}
#endif

/***************************************************************/
/* Options for segmented executable format.  */

#if OSEGEXE
LOCAL void NEAR              SwAlign()       /* Set segment alignment factor */
{
    long                align;          /* Alignment size in byutes */
    int                 rc;

    if((rc = ParseNo(&align)) < 0)      /* Quit if error */
        return;
    if(rc && align  >= 1 && align <= 32768L)
    {                                   /* If value in legal range */
        for(fileAlign = 16; fileAlign != 0; --fileAlign)
        {                               /* Loop to find log of align */
            if((1L << fileAlign) & align) break;
                                        /* Break when high bit found */
        }
        if((1L << fileAlign) == align) return;
                                        /* Align must be power of two */
    }
    OutWarn(ER_alnbad);                 /* Output warning message */
    fileAlign = DFSAALIGN;              /* Use default value */
}
#pragma check_stack(on)
#if OUT_EXP
LOCAL void NEAR SwIdef(void)            /* Dump exports to a text file */
{
    SBTYPE              SwString;
    int                 rc;

    if ((rc = ParseStr(SwString)) <= 0)      // Done if no string or error
    {
        bufExportsFileName[0] = '.';         // Use the default file name
        return;
    }
    strcpy(bufExportsFileName, SwString);
}
#endif
#if NOT EXE386
LOCAL void NEAR              SwPmType() /* /PMTYPE:<type> */
{
    SBTYPE                   SwString;


    if (ParseStr(SwString))
    {
        if (FPrefix("\002PM", SwString))
            vFlags |= NEWINAPI;
        else if (FPrefix("\003VIO", SwString))
            vFlags |= NEWINCOMPAT;
        else if (FPrefix("\005NOVIO", SwString))
            vFlags |= NENOTWINCOMPAT;
        else
            OutWarn(ER_badpmtype, &osbSwitch[1]);
    }
    else
        OutWarn(ER_badpmtype, &osbSwitch[1]);
}
#endif

#pragma check_stack(off)

LOCAL void NEAR              SwWarnFixup()
{
    fWarnFixup = (FTYPE) TRUE;
}

#if O68K
LOCAL void NEAR              SwMac()         /* Target is a Macintosh */
{
    SBTYPE                   SwString;

    f68k = fTBigEndian = fNewExe = (FTYPE) TRUE;
    iMacType = (BYTE) (ParseStr(SwString) && FPrefix("\011SWAPPABLE", SwString)
      ? MAC_SWAP : MAC_NOSWAP);

    /* If we are packing code to the default value, change the default. */
    if (fPackSet && packLim == LXIVK - 36)
        packLim = LXIVK / 2;
}
#endif /* O68K */
#endif /* OSEGEXE */

/***************************************************************/
/* Options shared by DOS3 and segmented exe formats.  */

#if OEXE
   /*
    *   HACK ALERT !!!!!!!!!!!!!!!
    *   Function SetDosseg is used to hide local call to SwDosseg().
    *   This function is called from ComRc1 (in NEWTP1.C).
    *
    */
void                          SetDosseg(void)
{
    SwDosseg();
}


LOCAL void NEAR               SwDosseg()      /* DOS Segment ordering switch given */
{
    static FTYPE FirstTimeCalled = (FTYPE) TRUE;     /*  If true create symbols _edata */
                                                                                /*      and _end */

    fSegOrder = (FTYPE) TRUE;                /* Set switch */
    if (FirstTimeCalled && vfPass1)
    {
        MkPubSym((BYTE *) "\006_edata",0,0,(RATYPE)0);
        MkPubSym((BYTE *) "\007__edata",0,0,(RATYPE)0);
        MkPubSym((BYTE *) "\004_end",0,0,(RATYPE)0);
        MkPubSym((BYTE *) "\005__end",0,0,(RATYPE)0);
        FirstTimeCalled = FALSE;
#if ODOS3EXE
        if (cparMaxAlloc == 0)
            cparMaxAlloc = 0xFFFF;           /* Turn off /HIGH */
        vfDSAlloc = FALSE;                   /* Turn off DS Allocation */
#endif
    }
}

#if ODOS3EXE
LOCAL void NEAR              SwDosExtend(void)
{
    long                     mode;      // Extender mode
    int                      rc;

    if ((rc = ParseNo(&mode)) < 0)      // Quit if error
        return;

    if (rc)
        dosExtMode = (WORD) mode;
    fDOSExtended = (FTYPE) TRUE;
}
#endif

#if TIMINGS
LOCAL void NEAR              SwShowTiming(void)
{
    extern int fShowTiming;

    fShowTiming = TRUE;
}
#endif // TIMINGS
#if USE_REAL
LOCAL void NEAR             SwNoUseReal(void)
{
    fSwNoUseReal = TRUE;
}
#endif
#if FEXEPACK
LOCAL void NEAR              SwExePack()     /* Set exepack switch */
{
#if QBLIB
    /* If /QUICKLIB given, issue fatal error.  */
    if(fQlib)
        Fatal(ER_swqe);
#endif
#if ODOS3EXE
    if (cparMaxAlloc == 0)
        OutWarn(ER_loadhi);
    else
#endif
        fExePack = (FTYPE) TRUE;
}
#endif


LOCAL void NEAR              SwNonulls ()
{
    extern FTYPE        fNoNulls;

    /*
     * /NONULLSDOSSEG:  just like /DOSSEG except do not insert
     * 16 null bytes in _TEXT.
     */
    SwDosseg();
    fNoNulls = (FTYPE) TRUE;
}


LOCAL void NEAR              SwNoFarCall()   /* Disable far call optimization */
{
    fFarCallTrans = FALSE;
}

void NEAR               SwNoPack()      /* Disable code packing */
{
    fPackSet = (FTYPE) TRUE;            /* Remember packLim was set */
    packLim = 0L;
}

LOCAL void NEAR         SwPack()        /* Pack code segments */
{
    int                 rc;

    fPackSet = (FTYPE) TRUE;            /* Remember packLim was set */
    if((rc = ParseNo(&packLim)) < 0)    /* Quit if error */
        return;
    if(!rc)
#if EXE386
        packLim = CBMAXSEG32;           /* Default limit is 4Gb */
#else
#if O68K
        packLim = iMacType != MAC_NONE ? LXIVK / 2 : LXIVK - 36;
                                        /* Default limit is 32K or 64K - 36 */
#else
        packLim = LXIVK - 36;           /* Default limit is 64K - 36 */
#endif
    else if(packLim > LXIVK)            /* If limit set too high */
        SwitchErr = ER_swpack;
    else if(packLim > LXIVK - 36)
        OutWarn(ER_pckval);
#endif
}

LOCAL void NEAR         SwPackData()    /* Pack data segments */
{
    int                 rc;

    fPackData = (FTYPE) TRUE;
    if((rc = ParseNo(&DataPackLim)) < 0)/* Quit if error */
        return;
    if(!rc)
#if EXE386
        DataPackLim = CBMAXSEG32;       /* Default limit is 4Gb  */
#else
        DataPackLim = LXIVK;            /* Default limit is 64K  */
    else if(DataPackLim >  LXIVK)       /* If limit set too high */
        SwitchErr = ER_swpack;
#endif
}

LOCAL void NEAR         SwNoPackFunctions()// DO NOT eliminate uncalled COMDATs
{
    fPackFunctions = (FTYPE) FALSE;
}

LOCAL void NEAR         SwPackFunctions()// DO eliminate uncalled COMDATs
{
#if TCE
        SBTYPE  SwString;
        int             rc;
#endif
        fPackFunctions = (FTYPE) TRUE;
#if TCE
        if ((rc = ParseStr(SwString)) <= 0)      // Done if no num or error
                return;
        if (SwString[1] == 'M' || SwString[1] == 'm')
        {
                fTCE = (FTYPE) TRUE;         // /PACKF:MAX = perform TCE
                fprintf(stdout, "\r\nTCE is active. ");
        }
#endif
}


LOCAL void NEAR              SwFarCall()     /* Enable far call optimization */
{
    fFarCallTrans = (FTYPE) TRUE;
}
#endif /* OEXE */

#if DOSEXTENDER
LOCAL void NEAR SwRunReal(void)
{
    OutWarn(ER_rnotfirst);
}
#endif

/***************************************************************/
/* Options for DOS3 exe format.  */

#if ODOS3EXE
LOCAL void NEAR              SwDSAlloc()     /* DS allocation requested */
{
    if(!fSegOrder) vfDSAlloc = (FTYPE) TRUE; /* Set flag if not overridden */
}

#if OVERLAYS
LOCAL void NEAR              SwDynamic(void)
{
    unsigned long       cThunks;
    int                 rc;

    if ((rc = ParseNo(&cThunks)) < 0)
        return;                         /* Bad argument */
    fDynamic = (FTYPE) TRUE;
    fFarCallTrans = (FTYPE) TRUE;
    fPackSet = (FTYPE) TRUE;
    packLim = LXIVK - 36;               /* Default limit is 64K - 36 */
    if (!rc)
        cThunks = 256;
    else if (cThunks > LXIVK / OVLTHUNKSIZE)
    {
        char buf[17];
        cThunks = LXIVK / OVLTHUNKSIZE;
        OutWarn(ER_arginvalid, "DYNAMIC", _itoa((WORD)cThunks, buf, 10));

    }


    ovlThunkMax = (WORD) cThunks;
}

LOCAL void NEAR             SwOldOvl(void)
{
    fOldOverlay = (FTYPE) TRUE;
    fDynamic = (FTYPE) FALSE;
}

#endif


LOCAL void NEAR              SwHigh()        /* Load high */
{
    if(!fSegOrder)
    {
#if FEXEPACK
        if (fExePack == (FTYPE) TRUE)
        {
            OutWarn(ER_loadhi);
            fExePack = FALSE;
        }
#endif
        cparMaxAlloc = 0;               /* Dirty trick! */
    }
}

#if OVERLAYS
LOCAL void NEAR              SwIntNo()
{
    unsigned long       intno;
    int                 rc;

    if((rc = ParseNo(&intno)) < 0)      /* Quit if error */
        return;
    if(rc == 0 || intno > 255)          /* If no number or num exceeds 255 */
        SwitchErr = ER_swovl;
    else vintno = (BYTE) intno;         /* Else store interrupt number */
}
#endif

LOCAL void NEAR              SwCParMax()
{
    unsigned long       cparmax;
    int                 rc;

    if((rc = ParseNo(&cparmax)) < 0)    /* Quit if error */
        return;
    if(rc == 0 || cparmax > 0xffffL)    /* If no number or num exceeds ffff */
        SwitchErr = ER_swcpar;
    else cparMaxAlloc = (WORD) cparmax; /* Else store cparMaxAlloc */
}

LOCAL void NEAR              SwNoGrp()
{
    fNoGrpAssoc = (FTYPE) TRUE;             /* Don't associate publics w/ groups */
}
#endif /* ODOS3EXE */

/***************************************************************/
/* Options for ILINK-version */

#if ILINK
LOCAL void NEAR              SwIncremental() /* Incremental linking support */
{
    //fIncremental = (FTYPE) !fZincr;
    fIncremental = (FTYPE) FALSE; //INCR support dropped in 5.30.30
}
#endif

LOCAL void NEAR              SwPadCode()     /* Code padding */
{
    long                num;
    int                 rc;

    if((rc = ParseNo(&num)) < 0)
        return;
    /* PADCODE:xxx option specifies code padding size */
    if(rc)
    {
        if(num < 0 || num > 0x8000)
            SwitchErr = ER_swbadnum;
        else cbPadCode = (WORD) num;
    }
}

LOCAL void NEAR              SwPadData()     /* Data padding */
{
    long                num;
    int                 rc;

    if((rc = ParseNo(&num)) < 0)
        return;
    /* PADDATA:xxx option specifies data padding size */
    if(rc)
    {
        if(num < 0 || num > 0x8000)
            SwitchErr = ER_swbadnum;
        else cbPadData = (WORD) num;
    }
}

/***************************************************************/
/* Switches for segmented x.out format */

#if OIAPX286
LOCAL void NEAR              SwAbsolute ()
{
    if(!cbStack)
        ParseNo(&absAddr);
}

LOCAL void NEAR              SwNoPack()      /* Disable code packing */
{
    fPack = FALSE;
}

LOCAL void NEAR              SwTextbias ()
{
    long                num;

    if(ParseNo(&num) > 0)
        stBias = num;
}

LOCAL void NEAR              SwDatabias ()
{
    long                num;

    if(ParseNo(&num) > 0)
        stDataBias = num;
}

LOCAL void NEAR              SwPagesize ()
{
    long                num;

    if(ParseNo(&num) > 0)
        cblkPage = num >> 9;
}

LOCAL void NEAR              SwTextrbase ()
{
    long                num;

    if(ParseNo(&num) > 0)
        rbaseText = num;
}

LOCAL void NEAR              SwDatarbase ()
{
    long                num;

    if(ParseNo(&num) > 0)
        rbaseData = num;
}

LOCAL void NEAR              SwVmod ()
{
    long                num;

    if(ParseNo(&num) <= 0)
        return;
    switch(num)
    {
        case 0:
            xevmod = XE_VMOD;
            break;
        case 1:
            xevmod = XE_EXEC | XE_VMOD;
            break;
        default:
            SwitchErr = ER_swbadnum;
    }
}
#endif /* OIAPX286 */
#if OXOUT OR OIAPX286
LOCAL void NEAR              SwNosymbols ()
{
    fSymbol = FALSE;
}

LOCAL void NEAR              SwMixed ()
{
    fMixed = (FTYPE) TRUE;
}

LOCAL void NEAR              SwLarge ()
{
    fLarge = (FTYPE) TRUE;
    SwMedium();
}

LOCAL void NEAR              SwMedium()
{
    fMedium = (FTYPE) TRUE;         /* Medium model */
    fIandD = (FTYPE) TRUE;          /* Separate code and data */
}

LOCAL void NEAR              SwPure()
{
    fIandD = (FTYPE) TRUE;          /* Separate code and data */
}
#endif /* OXOUT OR OIAPX286 */

/* Options for linker profiling */
#if LNKPROF
char fP1stop = FALSE;       /* Stop after pass 1 */
LOCAL void NEAR              SwPass1()
{
    fP1stop = (FTYPE) TRUE;
}
#endif /* LNKPROF */

/* Special options */
#if QBLIB
LOCAL void NEAR              SwQuicklib()    /* Create a QB userlibrary */
{
#if FEXEPACK
    /* If /EXEPACK given, issue fatal error.  */
    if(fExePack)
        Fatal(ER_swqe);
#endif
    fQlib = (FTYPE) TRUE;
    SwDosseg();                         /* /QUICKLIB forces /DOSSEG */
    fNoExtDic = (FTYPE) TRUE;           /* /QUICKLIB forces /NOEXTDICTIONARY */
}
#endif

#if (QCLINK) AND NOT EXE386
typedef int (cdecl far * FARFPTYPE)(int, ...);/* Far function pointer type */
extern FARFPTYPE far    *pfQTab;        /* Table of addresses */

#pragma check_stack(on)

/*
 *  PromptQC : output a prompt to the QC prompt routine
 *
 *  Call pfQTab[1] with parameters described below.
 *  Returns:
 *      always TRUE
 *
 * QCPrompt : display a message with a prompt
 *
 * void far             QCPrompt (type, msg1, msg2, msg3, pResponse)
 * short                        type;           /* type of message, as follows:
 *                              0 = undefined
 *                              1 = edit field required (e.g. file name)
 *                              2 = wait for some action
 *                              all other values undefined
 *      Any of the following fields may be NULL:
 * char far             *msg1;          /* 1st message (error)
 * char far             *msg2;          /* 2nd message (file name)
 * char far             *msg3;          /* 3rd message (prompt text)
 * char far             *pResponse;     /* Pointer to buffer in which to
 *                                       * store response.
 */
int      cdecl          PromptQC (sbNew,msg,msgparm,pmt,pmtparm)
BYTE                    *sbNew;         /* Buffer for response */
MSGTYPE                 msg;            /* Error message */
int                     msgparm;        /* Message parameter */
MSGTYPE                 pmt;            /* Prompt */
int                     pmtparm;        /* Prompt parameter */
{
    int                 type;
    SBTYPE              message;
    SBTYPE              prompt;

    if(sbNew != NULL)
        type = 1;
    else
        type = 2;
    sprintf(message,GetMsg(msg),msgparm);
    sprintf(prompt,GetMsg(pmt),pmtparm);
    /* Return value of 1 means interrupt. */
    if((*pfQTab[1])(type,(char far *) message,0L,(char far *)prompt,
            (char far *) sbNew) == 1)
        UserKill();
    return(TRUE);
}

#pragma check_stack(off)

/*
 *  CputcQC : console character output routine for QC
 */
void                    CputcQC (ch)
int                     ch;
{
}

/*
 *  CputsQC : console string output routine for QC
 */
void                    CputsQC (str)
char                    *str;
{
}


/*
 *  SwZ1 : process /Z1:address
 *
 *  /Z1 is a special undocumented switch for QC.  It contains
 *  the address of a table of routines to use for console I/O.
 */

LOCAL void NEAR              SwZ1 (void) /* Get address for message I/O */
{
    long                num;
    extern FARFPTYPE far
                        *pfQTab;        /* Table of addresses */

    if(ParseNo(&num) <= 0)
        return;
    pfQTab = (FARFPTYPE far *) num;
    pfPrompt = PromptQC;
    fNoprompt = FALSE;                  /* Disable /NOPROMPT */
    fNoBanner = (FTYPE) TRUE;
    pfCputc = CputcQC;
    pfCputs = CputsQC;
    fZ1 = (FTYPE) TRUE;
}
/*
 *  /Zincr is a special undocumented switch for QC.  It is required
 *  for "ILINK-breaking" errors. If ILINK encounters one of these errors,
 *  it ivokes the linker w /ZINCR which override /INCR.
 */

LOCAL void NEAR              SwZincr(void)
{
    fZincr = (FTYPE) TRUE;
}
#endif

#if Z2_ON OR (QCLINK AND NOT EXE386)
/*
 *  SwZ2 : process /Z2
 *
 *  /Z2 is another special undocumented switch for QC.
 *  It causes deletion of responce file passed to the linker.
 */

LOCAL void NEAR              SwZ2 (void)
{
    fZ2 = (FTYPE) TRUE;
}

#endif


/* Structure for table of linker options */
struct option
{
    char        *sbSwitch;              /* length-prefixed switch string */
#ifdef M68000
    int         (*proc)();              /* pointer to switch function */
#else
    void   (NEAR *proc)();              /* pointer to switch function */
#endif
};


/* Table of linker options */
LOCAL struct option     switchTab[] =
{
#if NOT WIN_3
    { "\01?",                   SwShortHelp },
#endif
#if OIAPX286
    { "\017ABSOLUTEADDRESS",    SwAbsolute },
#endif
#if OSEGEXE AND NOT QCLINK
    { "\011ALIGNMENT",          SwAlign },
#endif
    { "\005BATCH",              SwBatch },
#if LNKPROF
    { "\007BUFSIZE",            SwBufsize },
#endif
#if SYMDEB
    { "\010CODEVIEW",           SwSymdeb },
#endif
#if ODOS3EXE
    { "\014CPARMAXALLOC",       SwCParMax },
#endif
#if OIAPX286
    { "\010DATABIAS",           SwDatabias },
    { "\011DATARBASE",          SwDatarbase },
#endif

#if ODOS3EXE
    { "\013DOSEXTENDER",        SwDosExtend },
#endif
#if OEXE
    { "\006DOSSEG",             SwDosseg },
#endif
#if ODOS3EXE
    { "\012DSALLOCATE",         SwDSAlloc },
#if OVERLAYS
    { "\007DYNAMIC",            SwDynamic },
#endif
#endif
#if FEXEPACK
    { "\007EXEPACK",            SwExePack },
#endif
#if OEXE
    { "\022FARCALLTRANSLATION", SwFarCall },
#endif
#if EXE386
    { "\006HEADER",             SwHeader },
#endif
#if NOT WIN_3
    { "\004HELP",
#if C8_IDE
                                SwShortHelp },
#else
                                SwHelp },
#endif
#endif
#if ODOS3EXE
    { "\004HIGH",               SwHigh },
#endif
#if NOT IGNORECASE
    { "\012IGNORECASE",         SwCase },
#endif
#if EXE386
    { "\016IMAGEALIGNMENT",     SwMemAlign },
#endif
#if ILINK AND NOT IBM_LINK
    { "\013INCREMENTAL",        SwIncremental },
#endif
#if FDEBUG
    { "\013INFORMATION",        SwInfo },
#endif
#if OSEGEXE AND OUT_EXP
    { "\004IDEF",                  SwIdef },
#endif
#if (OSEGEXE AND defined(LEGO)) OR EXE386
    { "\012KEEPFIXUPS",         SwKeepFixups },
#endif
#if EXE386
    { "\012KEEPVSIZE",          SwKeepVSize },
#endif
#if OIAPX286
    { "\005LARGE",              SwLarge },
#endif
    { "\013LINENUMBERS",        SwLineNos },
#if LOCALSYMS
    { "\014LOCALSYMBOLS",       SwLocals },
#endif
#if O68K
    { "\011MACINTOSH",          SwMac },
#endif /* O68K */
    { "\003MAP",                SwMap },
#if OXOUT OR OIAPX286
    { "\006MEDIUM",             SwMedium },
    { "\005MIXED",              SwMixed },
#endif
#if NOT EXE386
    { "\010KNOWEAS",            SwNewFiles },
#endif
    { "\026NODEFAULTLIBRARYSEARCH",
                                SwNoDefLib },
#if LIBMSDOS
    { "\017NOEXTDICTIONARY",    SwNoExtDic },
#endif
#if OEXE
    { "\024NOFARCALLTRANSLATION",
                                SwNoFarCall },
#endif
#if ODOS3EXE
    { "\022NOGROUPASSOCIATION", SwNoGrp },
#endif
#if IGNORECASE
    { "\014NOIGNORECASE",       SwCase },
#endif
#if TIMINGS
    { "\002BT",                 SwShowTiming },
#endif // TIMINGS
    { "\006NOLOGO",             SwNologo },
    { "\015NONULLSDOSSEG",      SwNonulls },
    { "\012NOPACKCODE",         SwNoPack },
    { "\017NOPACKFUNCTIONS",    SwNoPackFunctions },
#if OXOUT OR OIAPX286
    { "\011NOSYMBOLS",          SwNosymbols },
#endif
#if USE_REAL
    { "\011NOFREEMEM",          SwNoUseReal },
#endif
#if OVERLAYS
    { "\012OLDOVERLAY",         SwOldOvl },
#endif
    { "\007ONERROR",            SwDelexe },
#if OVERLAYS
    { "\020OVERLAYINTERRUPT",   SwIntNo },
#endif
    { "\010PACKCODE",           SwPack },
    { "\010PACKDATA",           SwPackData },
    { "\015PACKFUNCTIONS",      SwPackFunctions },
#if ILINK AND NOT IBM_LINK
    { "\007PADCODE",            SwPadCode },
    { "\007PADDATA",            SwPadData },
#endif
#if OIAPX286
    { "\010PAGESIZE",           SwPagesize },
#endif
#if OSMSDOS
    { "\005PAUSE",              SwPause },
#endif
#if LNKPROF
    { "\005PASS1",              SwPass1 },
#endif
#if PCODE
    { "\005PCODE",              SwPCode },
#endif
#if OSEGEXE AND NOT (QCLINK OR EXE386)
    { "\006PMTYPE",             SwPmType },
#endif
#if OXOUT OR OIAPX286
    { "\004PURE",               SwPure },
#endif
#if QBLIB
    { "\014QUICKLIBRARY",       SwQuicklib },
#endif
#if DOSEXTENDER AND NOT WIN_NT
    { "\001r",                  SwRunReal },
#endif
    { "\010SEGMENTS",           SwSegments },
    { "\005STACK",              SwStack },
#if OIAPX286
    { "010TEXTBIAS",            SwTextbias },
    { "\011TEXTRBASE",          SwTextrbase },
#endif
#if ODOS3EXE
    { "\004TINY",               SwBinary },
#endif
#if PERFORMANCE
    { "\030VIRTUALMEMORYPERFORMANCE",
                                SwVMPerf },
#endif
#if OIAPX286
    { "\004VMOD",               SwVmod },
#endif
#if OSEGEXE AND NOT QCLINK
    { "\011WARNFIXUP",          SwWarnFixup },
#endif
#if OSEGEXE AND NOT EXE386 AND QCLINK
    { "\002Z1",                 SwZ1 },
#endif
#if Z2_ON OR QCLINK
    { "\002Z2",                 SwZ2 },
#endif
#if QCLINK
    { "\005ZINCR",              SwZincr },
#endif
    { NULL, 0}
};

#if QCLINK
#define SWSTOP  &switchTab[(sizeof(switchTab)/sizeof(struct option)) - 5]
#else
#if EXE386
#define SWSTOP  &switchTab[(sizeof(switchTab)/sizeof(struct option)) - 2]
#else
#define SWSTOP  &switchTab[(sizeof(switchTab)/sizeof(struct option)) - 2]
#endif
#endif

#define FIELDLENGTH     28
#if NOT WIN_3
LOCAL void NEAR              SwShortHelp()   /* Print valid switches */
{
    struct option       *pTab;          /* Option table pointer */
    int                 toggle = 1;
    int                 n;


#if CMDMSDOS
    /* Maybe display banner here, in case /NOLOGO seen first.  */

    DisplayBanner();
#endif
    fputs(GetMsg(P_usage1),stdout);
    fputs(GetMsg(P_usage2),stdout);
    fputs(GetMsg(P_usage3),stdout);
    fputs(GetMsg(P_switches),stdout);
    NEWLINE(stdout);
    for(pTab = switchTab; pTab < SWSTOP; ++pTab)
    {
        // Don't display undocumented swiches

        if (pTab->proc == &SwNewFiles)
        {
            continue;
        }
        if (pTab->proc == &SwDosExtend)
        {
            continue;
        }
#ifdef  LEGO
#if OSEGEXE
        if (pTab->proc == &SwKeepFixups)
            continue;
#endif
#endif  /* LEGO */

        fputs("  /",stdout);
        fwrite(&pTab->sbSwitch[1],1,B2W(pTab->sbSwitch[0]),stdout);
        /* Output switches in two columns */
        if(toggle ^= 1)
            NEWLINE(stdout);
        else for(n = FIELDLENGTH - B2W(pTab->sbSwitch[0]); n > 0; --n)
            fputc(' ',stdout);
    }
    NEWLINE(stdout);
    fflush(stdout);
#if USE_REAL
    RealMemExit();
#endif
    exit(0);
}
#endif

LOCAL void NEAR             SwDelexe()  // Supress .EXE generation if errors occur
{
    SBTYPE              SwString;
    int                 rc;

    vfMap = (FTYPE) TRUE;                    // Set flag
    if ((rc = ParseStr(SwString)) == 0)      // NOEXE not present
    {
        OutWarn(ER_opnoarg, "ONERROR");
        return;
    }


    if (SwString[1] == 'N' || SwString[1] == 'n')
    {
        fDelexe = TRUE;                      // ONERROR:NOEXE
    }
    else
    {                                        // ONERROR:????
        OutWarn(ER_opnoarg, "ONERROR");
        return;
    }
}

#if (OSEGEXE AND defined(LEGO)) OR EXE386

LOCAL void NEAR             SwKeepFixups(void)
{
    fKeepFixups = (FTYPE) TRUE;
}

#endif

#if EXE386

LOCAL void NEAR             SwHeader()  // Set executable header size
{
    int                     rc;
    DWORD                   newSize;

    if ((rc = ParseNo(&newSize)) < 0)   // Quit if error
        return;
    if (rc)
        hdrSize = ((newSize << 10) + 0xffffL) & ~0xffffL;
}

LOCAL void NEAR             SwKeepVSize(void)
{
    fKeepVSize = (FTYPE) TRUE;
}

#endif

#if NOT WIN_3

LOCAL void NEAR             SwHelp()   /* Print valid switches */
{
    intptr_t                exitCode;
    char                    *pszPath;
    char                    *pszQH;
    char                    *pszHELPFILES;
    char FAR                *lpch;
    char                    *pch;
    int                     len;


    // Try to use QuickHelp - this is tricky; We have stubbed the
    // C run-time environment setup, so spawnlp has no way of
    // searching the path. Here we first add the path to C run-time
    // environemt table and then invoke spawnlp.


    if (lpszPath)
    {
        // Recreate C run-time PATH variable

        len = FSTRLEN(lpszPath);
        if ((pszPath = calloc(len + 6, sizeof(char))) != NULL)
        {
            strcpy(pszPath, "PATH=");
            for (lpch = lpszPath, pch = pszPath + 5; len > 0; len--)
                *pch++ = *lpch++;
            _putenv(pszPath);
        }
    }
    if (lpszQH)
    {
        // Recreate C run-time QH variable

        len = FSTRLEN(lpszQH);
        if ((pszQH = calloc(len + 4, sizeof(char))) != NULL)
        {
            strcpy(pszQH, "QH=");
            for (lpch = lpszQH, pch = pszQH + 3; len > 0; len--)
                *pch++ = *lpch++;
            _putenv(pszQH);
        }
    }
    if (lpszHELPFILES)
    {
        // Recreate C run-time HELPFILES variable

        len = FSTRLEN(lpszHELPFILES);
        if ((pszHELPFILES = calloc(len + 12, sizeof(char))) != NULL)
        {
            strcpy(pszHELPFILES, "HELPFILES=");
            for (lpch = lpszHELPFILES, pch = pszHELPFILES + 10; len > 0; len--)
                *pch++ = *lpch++;
            _putenv(pszHELPFILES);
        }
    }
#if USE_REAL
    RealMemExit();
#endif
    exitCode = _spawnlp(P_WAIT, "QH.EXE", "qh", "/u link.exe", NULL);
    if (exitCode < 0 || exitCode == 3)
        SwShortHelp();
    exit(0);
}
#endif

    /****************************************************************
    *                                                               *
    *  BadFlag:                                                     *
    *                                                               *
    *  This function takes as its  argument a pointer to a length-  *
    *  prefixed  string  containing an  invalid  switch.  It  goes  *
    *  through the customary contortions of dying with grace.       *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         BadFlag(psb,errnum)
BYTE                    *psb;           /* Pointer to the bad switch */
MSGTYPE                 errnum;         /* Error number */
{
    psb[B2W(psb[0]) + 1] = '\0';        /* Null-terminate it */
    Fatal(errnum,psb + 1);
}

    /****************************************************************
    *                                                               *
    *  FPrefix:                                                     *
    *                                                               *
    *  This  function  takes  as  its  arguments  two  pointers to  *
    *  length-prefixed strings.  It returns  true if the second is  *
    *  a prefix of the first.                                       *
    *                                                               *
    ****************************************************************/

LOCAL int NEAR          FPrefix(psb1,psb2)
BYTE                    *psb1;          /* Pointer to first string */
BYTE                    *psb2;          /* Pointer to second string */
{
    REGISTER WORD       len;            /* Length of string 2 */

    if((len = B2W(psb2[0])) > B2W(psb1[0])) return(FALSE);
                                        /* String 2 cannot be longer */
    while(len)                          /* Compare the strings */
    {
        if(UPPER(psb2[len]) != UPPER(psb1[len])) return(FALSE);
                                        /* Check for mismatch */
        --len;                          /* Decrement index */
    }
    return(TRUE);                       /* 2 is a prefix of 1 */
}

    /****************************************************************
    *                                                               *
    *  ProcFlag:                                                    *
    *                                                               *
    *  This  function  takes  as  its  argument  a length-prefixed  *
    *  string containing a single '/-type' flag.  It processes it,  *
    *  but does not return a meaningful value.                      *
    *                                                               *
    ****************************************************************/

void                    ProcFlag(psb)   /* Process a flag */
BYTE                    *psb;           /* Pointer to flag string */
{
    struct option       *pTab;          /* Pointer to option table */
    struct option       *pTabMatch;     /* Pointer to matching entry */
    WORD                ich3;           /* Index */
    WORD                ich4;           /* Index */

    pTabMatch = NULL;                   /* Not found */
    if((ich3 = IFind(psb,':')) == INIL)
      ich3 = B2W(psb[0]);               /* Get index to colon */
    ich4 = B2W(psb[0]);                 /* Save the original length */
    psb[0] = (BYTE) ich3;               /* Set new length */
    for(pTab = switchTab; pTab->sbSwitch; pTab++)
    {                                   /* Loop thru switch table */
        if(FPrefix(pTab->sbSwitch,psb))
        {                               /* If we've identified the switch */
            if(pTabMatch)               /* If there was a previous match */
                BadFlag(psb,ER_swambig);/* Ambiguous switch */
            pTabMatch = pTab;           /* Save the match */
        }
    }
    if(!pTabMatch)                      /* If no match found */
    {
        psb[psb[0]+1] = '\0';
        OutWarn(ER_swunrecw,&psb[1]);   /* Unrecognized switch */
        return;
    }
    psb[0] = (BYTE) ich4;               /* Restore original length */
    osbSwitch = psb;                    /* Pass the switch implicitly */
    SwitchErr = 0;                      /* Assume no error */
    (*pTabMatch->proc)();               /* Invoke the processing procedure */
    if(SwitchErr) BadFlag(psb,SwitchErr);       /* Check for errors */
}

#pragma check_stack(on)

    /****************************************************************
    *                                                               *
    *  PeelFlags:                                                   *
    *                                                               *
    *  This function takes as its  argument a pointer to a length-  *
    *  prefixed string of bytes.  It "peels/processes all '/-type'  *
    *  switches."  It does not return a meaningful value.           *
    *                                                               *
    ****************************************************************/

void                    PeelFlags(psb)  /* Peel/process flags */
BYTE                    *psb;           /* Pointer to a byte string */
{
    REGISTER WORD       ich;            /* Index */
    SBTYPE              sbFlags;        /* The flags */

    if((ich = IFind(psb,CHSWITCH)) != INIL)
    {                                 /* If a switch found */
        memcpy(&sbFlags[1],&psb[ich + 2],B2W(psb[0]) - ich - 1);
                                        /* Move flags to flag buffer */
        sbFlags[0] = (BYTE) ((psb[0]) - ich - 1);
                                        /* Set the length of flags */
        while(psb[ich] == ' ' && ich) --ich;
                                        /* Delete trailing spaces */
        psb[0] = (BYTE) ich;            /* Reset length of input line */
        ich = sbFlags[0];
        while((sbFlags[ich] == ' ' ||
               sbFlags[ich] == ';' ||
               sbFlags[ich] == ','   ) && ich) --ich;
                                        /* Delete unwanted characters */
        sbFlags[0] = (BYTE) ich;
        BreakLine(sbFlags,ProcFlag,CHSWITCH);
                                        /* Process the switch */
    }
}

#pragma check_stack(off)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newini.c ===
/* %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                   LINKER INITIALIZATION                       *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* More of the same */
#include                <bndrel.h>      /* More of the same */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE format definitions */
#if EXE386
#include                <exe386.h>      /* 386 .EXE format definitions */
#endif
#include                <signal.h>      /* Signal definitions */
#if QCLINK
#include                <stdlib.h>
#endif
#include                <lnkmsg.h>      /* Error messages */
#if OSMSDOS AND NOT (WIN_NT OR DOSEXTENDER OR DOSX32) AND NOT WIN_3
#define INCL_BASE
#define INCL_DOSMISC
#include                <os2.h>         /* OS/2 system calls */
#if defined(M_I86LM)
#undef NEAR
#define NEAR
#endif
#endif
#include                <extern.h>      /* External declarations */
#include                <impexp.h>
#include                <direct.h>
#if defined(DOSX32) OR defined(WIN_NT)
extern char FAR * _stdcall GetCommandLineA(void);
#endif


/*
 *  FUNCTION PROTOTYPES
 */


LOCAL void NEAR InitLeadByte(void);
LOCAL void NEAR SetupEnv(void);
LOCAL int  NEAR IsPrefix(BYTE *pszPrefix, BYTE *pszString);
#if TCE
extern SYMBOLUSELIST           aEntryPoints;    // List of program entry points
#endif

#if ECS

/*
 *  InitLeadByte
 *
 *  Initialize lead byte table structures.
 *  Returns no meaningful value.
 */

LOCAL void NEAR         InitLeadByte ()
{
    struct lbrange
    {
        unsigned char   low;            /* minimum */
        unsigned char   high;           /* maximum */
    };
    static struct lbrange lbtab[5] = { { 0, 0 } };
    struct lbrange      *ptab;
    WORD                i;              /* index */
    COUNTRYCODE         cc;             /* country code */

    cc.country = cc.codepage = 0;
    if (DosGetDBCSEv(sizeof(lbtab), &cc, (char FAR *)lbtab))
        return;

    // For each range, set corresponding entries in fLeadByte

    for (ptab = lbtab; ptab->low || ptab->high; ptab++)
        if (ptab->low >= 0x80)
            for (i = ptab->low; i <= ptab->high; i++)
                fLeadByte[i-0x80] = (FTYPE) TRUE;
                                        // Mark inclusive range true
}
#endif /* ECS */

#if NOT (WIN_NT OR DOSX32)
/*** _setenvp - stub for C run-time
*
* Purpose:
*   Call stub instead of real function, we don't want C run-time to
*   setup enviroment.
*
* Input:
*   None;
*
* Output:
*   None;
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void cdecl              _setenvp(void)
{
    return;
}

/*** IsPrefix - self-explanatory
*
* Purpose:
*   Check if one string is a prefix of another.
*
* Input:
*   pszPrefix - pointer to prefix string
*   pszString - the string
*
* Output:
*   The function returns TRUE if the first string is a prefix of the
*   second; otherwise it returns FALSE.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL int NEAR          IsPrefix(BYTE *pszPrefix, BYTE *pszString)
{
    while(*pszPrefix)                   // While not at end of prefix
    {
        if (*pszPrefix != *pszString) return(FALSE);
                                        // Return zero if mismatch
        ++pszPrefix;                    // Increment pointer
        ++pszString;                    // Increment pointer
    }
    return(TRUE);                       // We have a prefix
}
#endif


/*** SetupEnv - set up pointer to linker evironment variables
*
* Purpose:
*   Every byte in the DGROUP is to valuable to waste it to hold
*   information available elswere in the memory linker is not using
*   C run-time GETENV function, which accesses copy of the entire
*   environemt in the DGROUP placed there by the startup code.
*   Insted this function scans enviroment and set up pointers to
*   appropriate strings. Because initially enviroment is in the FAR
*   memory no space in DGROUP is used.
*
* Input:
*   No explicit parameters are passed.
*
* Output:
*   Four global pointer set to appropriate enviroment strings
*
*   lpszLink - the LINK
*   lpszPath - the PATH
*   lpszTMP  - the TMP
*   lpszLIB  - the LIB
*   lpszQH   - the QH for QuickHelp
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         SetupEnv(void)
{
#if WIN_NT OR DOSX32
#if C8_IDE
    char * pIDE = getenv("_MSC_IDE_FLAGS");

    if(pIDE)
    {
        if(strstr(pIDE, "FEEDBACK"))
        {
            fC8IDE = TRUE;
#if DEBUG_IDE
            fprintf(stdout, "\r\nIDE ACTIVE - FEEDBACK is ON");
#endif
        }
        if(strstr(pIDE, "BATCH"))
        {
            // NOTE: The link response file will still be echoed in this case!
            // NOTE: this is different than if you specify /BATCH on the
            // NOTE: command line -- also, the banner is still displayed
            // NOTE: this is intentional as the IDE wants to BATCH to cause
            // NOTE: the linker not to prompt, but it does want the banner
            // NOTE: and response file echoed unless /NOLOGO is also specified
            // NOTE: see CAVIAR 2378 [rm]

            fNoprompt = (FTYPE) TRUE;
            fPauseRun = FALSE;                       /* Disable /PAUSE */
#if DEBUG_IDE
            fprintf(stdout, "\r\nIDE ACTIVE - BATCH is ON");
#endif
        }
        if(strstr(pIDE, "NOLOGO"))
        {
            fNoBanner = (FTYPE) TRUE;
#if DEBUG_IDE
            fprintf(stdout, "\r\nIDE ACTIVE - LOGO is OFF");
#endif
        }


    }
#if DEBUG_IDE
    else
        fprintf(stdout, "\r\nIDE NOT ACTIVE");
    fflush(stdout);
#endif

#endif // C8_IDE

    lpszPath = getenv("PATH");
    lpszLink = getenv("LINK");
    lpszTMP  = getenv("TMP");
    lpszLIB  = getenv("LIB");
    lpszQH   = getenv("QH");
    lpszHELPFILES = getenv("HELPFILES");
    lpszCmdLine = GetCommandLineA();
    while (*lpszCmdLine != ' ')
        lpszCmdLine++;
#else
    WORD                selEnv;
    WORD                cmdOffset;
    register WORD       offMac;
    char FAR            *lpszEnv;
    char FAR            *lpch;
    SBTYPE              buf;
    register WORD       ich;
    WORD                fEOS;



#if QCLINK OR CPU8086 OR DOSEXTENDER
    // Get the segment address of the environment block
    // and set the command line offset to infinity. We
    // stop scanning environment block at NULL string.

    lpszEnv = (char FAR *)
    (((long) _psp << 16)
     + 0x2c);
    selEnv  = *((WORD FAR *) lpszEnv);
    lpszCmdLine = (char FAR *)(((long) _psp << 16) + 0x80);
    lpszCmdLine[lpszCmdLine[0] + 1] = '\0';
    lpszCmdLine++;
    cmdOffset = 0xffff;
#else
    if (DosGetEnv((unsigned FAR *) &selEnv, (unsigned FAR *) &cmdOffset))
        return;
#endif

    lpszEnv = (char FAR *)((long) selEnv << 16);
#if NOT (QCLINK OR CPU8086 OR DOSEXTENDER)
    lpszCmdLine = lpszEnv + cmdOffset;

    // Skip LINK

    lpszCmdLine += _fstrlen(lpszCmdLine) + 1;
#endif

    // Skip leading spaces in command line

    while (*lpszCmdLine == ' ')
        lpszCmdLine++;

    lpch = lpszEnv;
    for (offMac = 0; offMac < cmdOffset && *lpszEnv; )
    {
        // Copy the enviroment variable string into near buffer

        ich = 0;
        while (*lpch && ich < sizeof(buf) - 1)
            buf[ich++] = *lpch++;

        if (*lpch == '\0')
        {

            // Skip over terminating zero

            lpch++;
            fEOS = TRUE;
        }
        else
            fEOS = FALSE;

        buf[ich] = '\0';

        // Check what it is and setup appropriate pointer

        if (lpszPath == NULL && IsPrefix((BYTE *) "PATH=", buf))
            lpszPath = lpszEnv + 5;
        else if (lpszLink == NULL && IsPrefix((BYTE *) "LINK=", buf))
            lpszLink = lpszEnv + 5;
        else if (lpszTMP == NULL && IsPrefix((BYTE *) "TMP=", buf))
            lpszTMP = lpszEnv + 4;
        else if (lpszLIB == NULL && IsPrefix((BYTE *) "LIB=", buf))
            lpszLIB = lpszEnv + 4;
        else if (lpszQH == NULL && IsPrefix((BYTE *) "QH=", buf))
            lpszQH = lpszEnv + 3;
        else if (lpszHELPFILES == NULL && IsPrefix((BYTE *) "HELPFILES=", buf))
            lpszHELPFILES = lpszEnv + 10;

        // If everything setup don't bother to look father

        if (lpszPath && lpszLink && lpszTMP && lpszLIB && lpszQH && lpszHELPFILES)
            break;

        // Update enviroment pointer and offset in enviroment segment

        offMac += ich;
        if (!fEOS)
        {
            // Oops ! - enviroment variable longer then buffer
            // skip to its end

            while (*lpch && offMac < cmdOffset)
            {
                lpch++;
                offMac++;
            }

            // Skip over terminating zero

            lpch++;
            offMac++;
        }
        lpszEnv = lpch;
    }
#endif
}

#if FALSE

/*** Dos3SetMaxFH - set max file handle count for DOS
*
* Purpose:
*   Sets the maximum number of files that may be opened
*   simultaneously using handles by the linker.
*
* Input:
*   cFH      - number of desired handles
*
* Output:
*   No explicit value is returned.
*
* Exceptions:
*   None.
*
* Notes:
*   This function uses the int 21h function 67h which available on
*   DOS 3.3 and higher. The function fails if the requested number of
*   handles is greater then 20 and there is not sufficient free memory
*   in the system to allocate a new block to hold the enlarged table.
*
*   If the number of handles requested is larger the available
*   entries in the system's global table for file handles (controlled
*   by the FILES entry in CONFIG.SYS), no error is returned.
*   However, a subsequent attempt to open a file or create a new
*   file will fail if all entries in the system's global file table
*   are in use, even if the requesting process has not used up all
*   of its own handles
*
*   We don't check for error, because we can't do much about it.
*   Linker will try to run with what is available.
*
*************************************************************************/

LOCAL void NEAR         Dos3SetMaxFH(WORD cFH)
{
    if ((_osmajor >= 3) && (_osminor >= 30))
    {
        _asm
        {
            mov ax, 0x6700
            mov bx, cFH
            int 0x21
        }
    }
}
#endif

    /****************************************************************
    *                                                               *
    *  InitializeWorld:                                             *
    *                                                               *
    *  This function takes no  arguments and returns no meaningful  *
    *  value.   It  sets  up  virtual  memory,  the  symbol  table  *
    *  Handlers, and it initializes segment structures.             *
    *                                                               *
    ****************************************************************/

void                    InitializeWorld(void)
{
#if OSMSDOS
    BYTE                buf[512];       /* Temporary buffer */
    char FAR            *lpch;          /* Temporary pointer */
    int                 i;              /* Temporary index */
#endif

#if NOT (FIXEDSTACK OR CPU386)
    InitStack();                        /* Initialize stack */
#endif
#if OSMSDOS
    DskCur = (BYTE) (_getdrive() - 1);  /* Get current (default) disk drive */
#if FALSE
    if(!isatty(fileno(stderr)))         /* No prompts if output not console */
        fNoprompt = TRUE;
#endif
#if CRLF
    /* Default mode of stdout, stdin, stderr is text, change to binary.  */
    _setmode(fileno(stdout),O_BINARY);
    if(stderr != stdout)
        _setmode(fileno(stderr),O_BINARY);
    _setmode(fileno(stdin),O_BINARY);
#endif
#endif
    InitSym();                          /* Initialize symbol table handler */
    DeclareStdIds();

    // Install CTRL-C handler

#if OSMSDOS AND NOT WIN_NT
    signal(SIGINT, (void (__cdecl *)(int)) UserKill);
#endif /* OSMSDOS */

#if OSXENIX
    if(signal(SIGINT,UserKill) == SIG_IGN) signal(SIGINT,SIG_IGN);
                                        /* Trap user interrupts */
    if(signal(SIGHUP,UserKill) == SIG_IGN) signal(SIGHUP,SIG_IGN);
                                        /* Trap hangup signal */
    if(signal(SIGTERM,UserKill) == SIG_IGN) signal(SIGTERM,SIG_IGN);
                                        /* Trap software termination */
#endif

#if SYMDEB
    InitDbRhte();
#endif

#if ECS
    InitLeadByte();                     /* Initialize lead byte table */
#endif

#if OSMSDOS
    // Initialize LINK environment.
    // Do it yourself to save the memory.

    SetupEnv();

    /* Process switches from LINK environment variable */

    if (lpszLink != NULL)
    {
        lpch = lpszLink;

        /* Skip leading whitespace.  */

        while(*lpch == ' ' || *lpch == '\t')
            lpch++;
        if(*lpch++ == CHSWITCH)
        {
            // If string begins with switchr
            // Copy string to buf, removing whitespace

            for (i = 1; *lpch && i < sizeof(buf); lpch++)
                if (*lpch != ' ' && *lpch != '\t')
                    buf[i++] = *lpch;
            buf[0] = (BYTE) (i - 1);    /* Set the length of buf */
            if(buf[0])                  /* If any switches, process them */
                BreakLine(buf,ProcFlag,CHSWITCH);
        }
    }
#endif
#if CPU286
    if (_osmode == OS2_MODE)
    {
        DosSetMaxFH(128);               /* This is the same as _NFILE in crt0dat.asm */
        DosError(EXCEPTION_DISABLE);
    }
#if FALSE
    else
        Dos3SetMaxFH(40);
#endif
#endif
#if FALSE AND CPU8086
    Dos3SetMaxFH(40);
#endif

    // Initialize import/export tables

    InitByteArray(&ResidentName);
    InitByteArray(&NonResidentName);
    InitByteArray(&ImportedName);
    ImportedName.byteMac++;     // Ensure non-zero offsets to imported names
    InitWordArray(&ModuleRefTable);
    InitByteArray(&EntryTable);
#if TCE
    aEntryPoints.cMaxEntries = 64;
    aEntryPoints.pEntries = (RBTYPE*)GetMem(aEntryPoints.cMaxEntries * sizeof(RBTYPE*));
#endif
}

#if (OSXENIX OR OSMSDOS OR OSPCDOS) AND NOT WIN_NT
    /****************************************************************
    *                                                               *
    *  UserKill:                                                    *
    *                                                               *
    *  Clean up if linker killed by user.                           *
    *                                                               *
    ****************************************************************/

void cdecl       UserKill()
{
    signal(SIGINT, SIG_IGN);            /* Disallow ctrl-c during handler */
    CtrlC();
}
#endif


/*
 *  InitTabs:
 *
 *  Initialize tables required in Pass 1.
 */


void                    InitTabs(void)
{
#if NOT FAR_SEG_TABLES
    char                *tabs;          /* Pointer to table space */
    unsigned            cbtabs;
#endif


    /* Initialize the following tables:
    *
    *       NAME            TYPE
    *       ----            ----
    *       mpsegraFirst    RATYPE
    *       mpgsnfCod       FTYPE
    *       mpgsndra        RATYPE
    *       mpgsnrprop      RBTYPE
    *       mplnamerhte     RBTYPE
    */

#if FAR_SEG_TABLES
    mplnamerhte = (RBTYPE FAR *) GetMem(lnameMax * sizeof(RBTYPE));
    mpsegraFirst = (RATYPE FAR *) GetMem(gsnMax * sizeof(RATYPE));
    mpgsnfCod = (FTYPE FAR *) mpsegraFirst; /* Use same space twice */
    mpgsndra = (RATYPE FAR *) GetMem(gsnMax * sizeof(RATYPE));
    mpgsnrprop = (RBTYPE FAR *) GetMem(gsnMax * sizeof(RBTYPE));
#else
    mplnamerhte = (RBTYPE *) malloc(lnameMax * sizeof(RBTYPE));
    if (mplnamerhte == NULL)
        Fatal(ER_seglim);

    memset(mplnamerhte, 0, lnameMax * sizeof(RATYPE));

    cbtabs = gsnMax * (sizeof(RATYPE) + sizeof(RATYPE) + sizeof(RBTYPE));
    if((tabs = malloc(cbtabs)) == NULL)
        Fatal(ER_seglim);
    memset(tabs,0,cbtabs);              /* Clear everything */
    mpsegraFirst = (RATYPE *) tabs;     /* Initialize base */
    mpgsnfCod = (FTYPE *) mpsegraFirst; /* Use same space twice */
    mpgsndra = (RATYPE *) &mpsegraFirst[gsnMax];
    mpgsnrprop = (RBTYPE *) &mpgsndra[gsnMax];
#endif
}

/*
 *  InitP2Tabs:
 *
 *  Initialize tables not needed until Pass 2.
 */

void                    InitP2Tabs (void)
{
    char FAR            *tabs;          /* Pointer to table space */
    unsigned            cbtabs;         /* Size of table space */
    unsigned            TabSize;


    TabSize = gsnMac + iovMac + 1;

   /* Tables required regardless of exe format generated:
    *       mpsegsa         SATYPE
    *       mpgsnseg        SEGTYPE
    */

#if FAR_SEG_TABLES
    cbtabs = 0;
    mpsegsa  = (SATYPE FAR *)  GetMem(TabSize * sizeof(SATYPE));
    mpgsnseg = (SEGTYPE FAR *) GetMem(TabSize * sizeof(SEGTYPE));
    mpseggsn = (SNTYPE FAR *) GetMem(TabSize * sizeof(SNTYPE));
#else
    cbtabs = TabSize * (sizeof(RATYPE) + sizeof(SATYPE));
#endif

   /* Tables required according to exe format generated:
    *
    *    DOS 3:
    *       mpsegcb[TabSize]     long
    *       mpsegFlags[TabSize]  FTYPE
    *       mpsegalign[TabSize]  ALIGNTYPE
    *       mpsegiov[TabSize]    IOVTYPE
    *       mpiovRlc[iovMac]     RUNRLC
    *    Seg. exe:
    *       mpsacb[SAMAX]       long
    *       mpsadraDP[SAMAX]    long; for O68K
    *       mpsacbinit[SAMAX]   long
    *       mpsaRlc[SAMAX]      HASHRLC FAR *
    *       mpsaflags[SAMAX]    WORD; DWORD for EXE386
    *       htsaraep[HEPLEN]    EPTYPE FAR *
    *   X.out:
    *       mpsegcb[TabSize]     long
    *       mpsegFlags[TabSize]  FTYPE
    *       mpstsa[TabSize]      SATYPE
    */
#if EXE386
    if(fNewExe)
        cbtabs += (SAMAX*(sizeof(long)+sizeof(long)+sizeof(DWORD)+
          sizeof(DWORD))) + (HEPLEN * sizeof(WORD));
    else
#else
    if(fNewExe)
#if O68K
        cbtabs += (SAMAX*(sizeof(long)+sizeof(long)+sizeof(long)+sizeof(WORD)+
          sizeof(WORD))) + (HEPLEN * sizeof(WORD));
#else
        cbtabs += (SAMAX*(sizeof(long)+sizeof(long)+sizeof(RLCHASH FAR *) +
          sizeof(WORD))) + (HEPLEN * sizeof(EPTYPE FAR *));
#endif
    else
#endif
#if OEXE
        cbtabs += TabSize * (sizeof(long) + sizeof(FTYPE) + sizeof(ALIGNTYPE));
#else
        cbtabs += TabSize * (sizeof(long) + sizeof(FTYPE) + sizeof(SATYPE));
#endif


    cbtabs += sizeof(WORD);
    tabs = GetMem(cbtabs);
#if NOT FAR_SEG_TABLES
    mpgsnseg = (SEGTYPE *)tabs;
    mpsegsa = (SATYPE *)&mpgsnseg[TabSize];
    tabs = (char *)&mpsegsa[TabSize];
#endif
#if OSEGEXE
    if(fNewExe)
    {
        mpsacb = (DWORD FAR *) tabs;
#if O68K
        mpsadraDP = (long *)&mpsacb[SAMAX];
        mpsacbinit = (long *)&mpsadraDP[SAMAX];
#else
        mpsacbinit = (DWORD FAR *)&mpsacb[SAMAX];
#endif
#if EXE386
        mpsacrlc = (DWORD *)&mpsacbinit[SAMAX];
        mpsaflags = (DWORD *)&mpsacrlc[SAMAX];
#else
        mpsaRlc = (RLCHASH FAR * FAR *) &mpsacbinit[SAMAX];
        mpsaflags = (WORD FAR *) &mpsaRlc[SAMAX];
#endif
        htsaraep = (EPTYPE FAR * FAR *)&mpsaflags[SAMAX];
    }
    else
#endif
    {
#if ODOS3EXE OR OIAPX286
    mpsegcb = (long FAR *) tabs;
    mpsegFlags = (FTYPE FAR *)&mpsegcb[TabSize];
#if OEXE
    mpsegalign = (ALIGNTYPE FAR *)&mpsegFlags[TabSize];
#if OVERLAYS
    cbtabs = iovMac * sizeof(RUNRLC) + TabSize * sizeof(IOVTYPE) +
             (sizeof(DWORD) - 1);  // leave room to align mpiovRlc
    mpsegiov = (IOVTYPE FAR*) GetMem(cbtabs);

    // align mpiovRlc on a DWORD, the alignment needed by struct _RUNRLC

    mpiovRlc = (RUNRLC FAR*) ( ( (__int64)&mpsegiov[TabSize] +
                                 (sizeof(DWORD) - 1)
                               ) & ~(sizeof(DWORD) - 1)
                             );
#endif
#endif
#if OIAPX286
    mpstsa = (SATYPE *)&mpsegFlags[TabSize];
#endif
#endif /* ODOS3EXE OR OIAPX286 */
    }
    /* Attempt to allocate space for mpextprop. */
    cbtabs = extMax * sizeof(RBTYPE);
    mpextprop = (RBTYPE FAR *) GetMem(cbtabs);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newlib.c ===
/* SCCSID = %W% %E% */
/*
*      Copyright Microsoft Corporation, 1983-1987
*
*      This Module contains Proprietary Information of Microsoft
*      Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                 LIBRARY PROCESSING ROUTINES                   *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <stdlib.h>
#if OSMSDOS
#include                <dos.h>         /* DOS interface definitions */
#if CPU286
#define INCL_BASE
#include                <os2.h>         /* OS/2 interface definitions */
#if defined(M_I86LM)
#undef NEAR
#define NEAR
#endif
#endif
#endif

#define DICHDR          0xF1            /* Dictionary header type (F1H) */

#if OSXENIX
#define ShrOpenRd(f)    fopen(f,RDBIN)
#endif
#if NEWIO
#include                <errno.h>       /* System error codes */
#endif

#define PNSORTMAX       512             /* Maximum # modules can be sorted */

typedef struct _edmt                    /* Extended Dictionary Module Table */
{
    WORD                page;
    WORD                list;
}
                        edmt;

LOCAL FTYPE             fUndefHit;      /* found this undef in the library */
LOCAL FTYPE             fFileExtracted; /* Took file from library flag */
LOCAL FTYPE             fUndefsSeen;    /* True if externals seen in library */
LOCAL WORD              ipnMac;         /* Count of page numbers in sort table */
LOCAL WORD              *pnSort;        /* Sort table for library page numbers */
                                        /* f(ifh) = pointer to dictionary */
LOCAL WORD              mpifhcpnHash[IFHLIBMAX];
                                        /* f(ifh) = # pages in hash table */
LOCAL BYTE              mpifhAlign[IFHLIBMAX];
                                        /* f(ifh) = lib alignment factor */
LOCAL RBTYPE            vrpNewList;     /* List of unprocessed files */
LOCAL FTYPE             vfLibOpen;      /* Library open flag */
#if M_BYTESWAP OR defined( _WIN32 )
#define getfarword      getword         /* This assumes no far data */
#else
#define getfarword(x)   (((WORD FAR *)(x))[0])
#endif

/*
 *  INTERFACE WITH ASSEMBLY LANGUAGE FUNCTION
 */

WORD                    libAlign;       /* Library alignment factor */
WORD                    libcpnHash;     /* Length of hash table in pages */
BYTE FAR                *mpifhDict[IFHLIBMAX];

/*
 *  FUNCTION PROTOTYPES
 */

LOCAL unsigned char NEAR OpenLibrary(unsigned char *sbLib);
LOCAL void NEAR FreeDictionary(void);
#if CPU8086 OR CPU286
LOCAL WORD NEAR readfar(int fh, char FAR *buf,int n);
#endif
LOCAL void NEAR GetDictionary(void);
LOCAL WORD NEAR GetLib(void);
LOCAL void ProcessAnUndef(APROPNAMEPTR papropUndef,
                          RBTYPE       rhte,
                          RBTYPE       rprop,
                          WORD         fNewHte);
LOCAL int  cdecl FGtNum(const WORD *pn1, const WORD *pn2);
LOCAL void NEAR LookMod(edmt *modtab,unsigned short iMod);
LOCAL void NEAR LookPage(edmt *modtab,unsigned short cMod,unsigned short page);
LOCAL void NEAR ProcExtDic(char *pExtDic);
LOCAL char * NEAR GetExtDic(void);

#if NEW_LIB_SEARCH

/// undef lookaside list

typedef struct tag_UND
{
    struct tag_UND *    pNext;
    APROPNAMEPTR        papropUndef;
    DWORD               dwLibMask;
    RBTYPE              rhte;

} UND;

#define C_UNDS_POOL 128

typedef struct tag_UNDPOOL
{
        struct tag_UNDPOOL *pNext;
        UND             und[C_UNDS_POOL];
} UNDPOOL;


// pool storage management variables

UNDPOOL *pundpoolCur;
UNDPOOL *pundpoolHead;
int     iundPool = C_UNDS_POOL;
UND *   pundFree;
UND *   pundListHead;

#define FUndefsLeft() (pundListHead != NULL)

void StoreUndef(APROPNAMEPTR, RBTYPE, RBTYPE, WORD);

#else
#define FUndefsLeft() (fUndefsSeen)
#endif

FTYPE   fStoreUndefsInLookaside = FALSE;

/////


#if NOASM
LOCAL WORD NEAR         rolw(WORD x, WORD n)    /* Rotate word left */
{
    return(LO16BITS((x << n) | ((x >> (WORDLN - n)) & ~(~0 << n))));
}

LOCAL WORD NEAR         rorw(WORD x, WORD n)    /* Rotate word right */
{
    return(LO16BITS((x << (WORDLN - n)) | ((x >> n) & ~(~0 << (WORDLN - n)))));
}
#endif

#if OSMSDOS
BSTYPE NEAR             ShrOpenRd(pname)
char                    *pname;         /* Name of file (null-terminated) */
{
    int                 fh;             /* File handle */


#if NEWIO
    if(mpifhfh[ifhLibCur])
    {
        fh = mpifhfh[ifhLibCur];
        /* If dictionary not allocated, seek to beginning since we're
         * somewhere else now.
         */
        if(!mpifhDict[ifhLibCur])
            _lseek(fh,0L,0);
    }
    else
        fh = SmartOpen(pname,ifhLibCur);
    if(fh > 0)
    {
        fflush(bsInput);
        bsInput->_file = (char) fh;
        return(bsInput);
    }
    else
        return(NULL);
#else
    if((fh = _sopen(pname,O_RDONLY | O_BINARY,SH_DENYWR)) < 0)
        return(NULL);
    return(fdopen(fh,RDBIN));
#endif
}
#endif /* OSMSDOS */

#pragma check_stack(on)

    /****************************************************************
    *                                                               *
    *  OpenLibrary:                                                 *
    *                                                               *
    *  This function takes as its  arguments a pointer to the text  *
    *  of the name of the library to open, a count of the bytes in  *
    *  that name, an index  into a global table in  which to place  *
    *  the file handle for the opened library.  It returns TRUE if  *
    *  it succeeds, FALSE if  it  fails  to  open the file; and it  *
    *  dies gracefully if the file is not a valid library.      *
    *                                                               *
    ****************************************************************/

LOCAL FTYPE NEAR        OpenLibrary(sbLib)
BYTE                    *sbLib;         /* Library name */
{
    SBTYPE              libnam;         /* Library name */
    WORD                reclen;         /* Library header record length */
    BSTYPE              bsLib;          /* File stream pointer for library */

    memcpy(libnam,&sbLib[1],B2W(sbLib[0]));
                                        /* Copy library name */
    libnam[B2W(sbLib[0])] = '\0';       /* Null-terminate name */
    /* WARNING:  do not assign bsInput to NULL if open fails, it
     * screws up NEWIO.
     */
    if((bsLib = ShrOpenRd(libnam)) != NULL)
    {                                   /* If open successful */
        bsInput = bsLib;
        /* If dictionary already allocated, no need to do anything */
        if(mpifhDict[ifhLibCur])
            return((FTYPE) TRUE);
#if OSMSDOS
        /* Reduce buffer size.  We can avoid calling setvbuf() because
         * everything is set up properly at this point.
         */
#if OWNSTDIO
        bsInput->_bsize = 512;
#else
        setvbuf(bsInput, bsInput->_base, _IOFBF, 512);
#endif
#endif
        if(getc(bsInput) == LIBHDR)             /* If we have a library */
        {
            reclen = (WORD) (3 + WSGets());
                                        /* Get record length */
            for(libAlign = 15; libAlign &&
              !(reclen & (1 << libAlign)); --libAlign);
                                        /* Calculate alignment factor */
            mpifhAlign[ifhLibCur] = (BYTE) libAlign;
            if(libAlign >= 4 && reclen == (WORD) (1 << libAlign))
            {                           /* Check legality of alignment */
                libHTAddr = (long) WSGets();
                libHTAddr += (long) WSGets() << WORDLN;
                                        /* Get the offset of the hash table */
                if (libHTAddr <= 0L)
                    Fatal(ER_badlib,libnam);
                if ((mpifhcpnHash[ifhLibCur] = WSGets()) <= 0)
                                        /* Get size of hash table in pages */
                    Fatal(ER_badlib,libnam);
#if OSMSDOS
                /* Restore big buffer size.  Avoid calling setvbuf().  */
#if OWNSTDIO
                bsInput->_bsize = LBUFSIZ;
#else
                setvbuf(bsInput, bsInput->_base, _IOFBF, LBUFSIZ);
#endif
#endif
                return((FTYPE) TRUE);   /* Success */
            }
        }
        Fatal(ER_badlib,libnam);
    }
    return(FALSE);                      /* Failure */
}

#pragma check_stack(off)


/*
 *      LookupLibSym:   look up a symbol in library dictionary
 *
 *      The minimum page size is 16, so we can return paragraph offsets.
 *      This is a win because offsets are stored as paragraphs in the
 *      sorting table anyway.  Also, the majority of libraries have page
 *      size of 16.
 *
 *      Parameters:
 *              char    *psb    - pointer to length-prefixed string
 *      Returns:
 *              Long paragraph offset to location of module which defines
 *              the symbol, or 0L if not found.
 */
#if NOASM
LOCAL WORD NEAR         LookupLibSym(psb)
BYTE                    *psb;           /* Symbol to look up */
{
    WORD                i1;             /* First hash value */
    WORD                d1;             /* First hash delta */
    WORD                i2;             /* Second hash value */
    WORD                d2;             /* Second hash delta */
    WORD                pn;             /* Page number */
    WORD                dpn;            /* Page number delta */
    WORD                pslot;          /* Page slot */
    WORD                dpslot;         /* Page slot delta */
    WORD                ipn;            /* Initial page number */
    BYTE FAR            *hpg;
#if NOASM
    WORD                ch1;            /* Character */
    WORD                ch2;            /* Character */
    char                *pc1;           /* Character pointer */
    char                *pc2;           /* Character pointer */
    WORD                length;         /* Symbol length */
#endif

#if LIBDEBUG
    OutSb(stderr,psb);
    fprintf(stderr," is wanted; dictionary is %d pages\r\n",libcpnHash);
#endif
#if NOASM
    length = B2W(psb[0]);               /* Get symbol length */
    pc1 = (char *) psb;                 /* Initialize */
    pc2 = (char *) &psb[B2W(psb[0])];   /* Initialize */
    i1 = 0;                             /* Initialize */
    d1 = 0;                             /* Initialize */
    i2 = 0;                             /* Initialize */
    d2 = 0;                             /* Initialize */
    while(length--)                     /* Hashing loop */
    {
        ch1 = (WORD) (B2W(*pc1++) | 040);/* Force to lower case */
        ch2 = (WORD) (B2W(*pc2--) | 040);/* Force to lower case */
        i1 = (WORD) (rolw(i1,2) ^ ch1); /* Hash */
        d1 = (WORD) (rolw(d1,2) ^ ch2); /* Hash */
        i2 = (WORD) (rorw(i2,2) ^ ch2); /* Hash */
        d2 = (WORD) (rorw(d2,2) ^ ch1); /* Hash */
    }
#else
    i1 = libhash(psb,&d1,&i2,&d2);      /* Hash */
#endif
    pn = (WORD) (i1 % libcpnHash);      /* Calculate page number index */
    if(!(dpn = (WORD) (d1 % libcpnHash))) dpn = 1;
                                        /* Calculate page number delta */
    pslot = (WORD) (i2 % CSLOTMAX);     /* Calculate page slot index */
    if(!(dpslot = (WORD) (d2 % CSLOTMAX))) dpslot = 1;
                                        /* Calculate page slot delta */
#if LIBDEBUG
    fprintf(stderr,"page index %d, delta %d, bucket index %d, delta %d\r\n",
      pn,dpn,pslot,dpslot);
#endif
    ipn = pn;                           /* Remember initial page number */
    for(;;)                             /* Search loop */
    {
#if LIBDEBUG
        fprintf(stderr,"Page %d:\r\n",pn);
#endif
        // Get pointer to the dictionary page

        hpg = mpifhDict[ifhLibCur] + (pn << LG2PAG);

        for(i2 = 0; i2 < CSLOTMAX; ++i2)/* Loop to check slots */
        {
#if LIBDEBUG
            fprintf(stderr,"Bucket %d %sempty, page %sfull\r\n",
              pslot,hpg[pslot]? "not ": "",
              B2W(hpg[CSLOTMAX]) == 0xFF? "": "not ");
#endif
            if(!(i1 = (WORD) (B2W(hpg[pslot]) << 1)))
            {                           /* If slot is empty */
                if(B2W(hpg[CSLOTMAX]) == 0xFF) break;
                                        /* If page is full, break */
                return(0);              /* Search failed */
            }
#if LIBDEBUG
            fprintf(stderr,"  Comparing ");
            OutSb(stderr,psb);
            fprintf(stderr," to ");
            OutSb(stderr,&hpg[i1]);
            fprintf(stderr," %signoring case\r\n",fIgnoreCase? "": "not ");
#endif
            if(psb[0] == hpg[i1] && SbNewComp(psb,&hpg[i1],fIgnoreCase))
            {                           /* If symbols match */
#if LIBDEBUG
                fprintf(stderr,"Match found in slot %d\r\n",i2 >> 1);
#endif
                i1 += (WORD) (B2W(hpg[i1]) + 1); /* Skip over name */
                i1 = getfarword(&hpg[i1]);
                                        /* Get page number of module */
                return(i1);             /* Return page number of module */
            }
            if((pslot += dpslot) >= CSLOTMAX) pslot -= CSLOTMAX;
                                        /* Try next slot */
        }
        if((pn += dpn) >= libcpnHash) pn -= libcpnHash;
                                        /* Try next page */
        if (ipn == pn) return(0);       /* Once around without finding it */
    }
}
#endif /*NOASM*/
/*
 *  FreeDictionary : free space allocated for dictionaries
 */
LOCAL void NEAR         FreeDictionary ()
{
    WORD                i;

    for (i = 0; i < ifhLibMac; ++i)
        if (mpifhDict[i])
            FFREE(mpifhDict[i]);
}

#if CPU8086 OR CPU286
/*
 *  readfar : read() with a far buffer
 *
 *  Emulate read() except use a far buffer.  Call the system
 *  directly.
 *
 *  Returns:
 *      0 if error, else number of bytes read.
 */
LOCAL WORD NEAR         readfar (fh, buf, n)
int                     fh;             /* File handle */
char FAR                *buf;           /* Buffer to store bytes in */
int                     n;              /* # bytes to read */
{
#if OSMSDOS
    unsigned            bytesread;      /* Number of bytes read */

#if CPU8086
    if (_dos_read(fh, buf, n, &bytesread))
        return(0);
    return(bytesread);
#else

    if(DosRead(fh,buf,n,(unsigned FAR *) &bytesread))
        return(0);
    return(bytesread);
#endif
#endif /* OSMSDOS */
#if OSXENIX
    char                mybuf[PAGLEN];
    int                 cppage;
    char                *p;

    while(n > 0)
    {
        cppage = n > PAGLEN ? PAGLEN : n;
        if(read(fh,mybuf,cppage) != cppage)
            return(0);
        n -= cppage;
        for(p = mybuf; p < mybuf[cppage]; *buf++ = *p++);
    }
#endif
}
#endif

LOCAL void NEAR         GetDictionary ()
{
    unsigned            cb;


#if CPU8086 OR CPU286
    // If there is more than 128 pages in dictionary return,
    // because the dictionary is bigger than 64k

    if (libcpnHash >= 128)
        return;
#endif

    cb = libcpnHash << LG2PAG;
    mpifhDict[ifhLibCur] = GetMem(cb);

    // Go to the dictionary and read it in a single call

#if defined(M_I386) || defined( _WIN32 )
    fseek(bsInput, libHTAddr, 0);
    if (fread(mpifhDict[ifhLibCur], 1, cb, bsInput) != (int) cb)
        Fatal(ER_badlib,1 + GetPropName(FetchSym(mpifhrhte[ifhLibCur],FALSE)));
#else
    _lseek(fileno(bsInput), libHTAddr, 0);
    if (readfar(fileno(bsInput), mpifhDict[ifhLibCur], cb) != cb)
        Fatal(ER_badlib,1 + GetPropName(FetchSym(mpifhrhte[ifhLibCur],FALSE)));
#endif
}

#pragma check_stack(on)

LOCAL WORD NEAR         GetLib(void)    /* Open the next library in list */
{
    AHTEPTR             pahteLib;       /* Pointer to library name */
#if OSMSDOS
    SBTYPE              sbLib;          /* Library name */
    SBTYPE              sbNew;          /* New parts to library name */
#endif

    if(mpifhrhte[ifhLibCur] == RHTENIL) /* If this library is to be skipped */
    {
        return(FALSE);                  /* No library opened */
    }
    for(;;)                             /* Loop to open library */
    {
        pahteLib = (AHTEPTR ) FetchSym(mpifhrhte[ifhLibCur],FALSE);
                                        /* Get name from hash table */
        if(OpenLibrary(GetFarSb(pahteLib->cch))) break;
                                        /* Break if lib opened okay */
        if(fNoprompt)
            Fatal(ER_libopn,1 + GetFarSb(pahteLib->cch));
        else
        {
            sbLib[0] = '\0';            /* No string yet */
            UpdateFileParts(sbLib,GetFarSb(pahteLib->cch));
            (*pfPrompt)(sbNew,ER_libopn,        /* Prompt for new filespec */
                            (int) (__int64) (1 + GetFarSb(pahteLib->cch)),
                            P_EnterNewFileSpec, 0);
        }
        if(fNoprompt || !sbNew[0])
        {
            mpifhrhte[ifhLibCur] = RHTENIL;
                                        /* Do not bother next time */
            return(FALSE);              /* Unsuccessful */
        }
#if OSMSDOS
        UpdateFileParts(sbLib,sbNew);   /* Update file name with new parts */
        PropSymLookup(sbLib,ATTRFIL,TRUE);
                                        /* Add library to symbol table */
        mpifhrhte[ifhLibCur] = vrhte;   /* Save virtual address */
        AddLibPath(ifhLibCur);          /* Add default path spec, maybe */
#endif
    }
    vfLibOpen = (FTYPE) TRUE;           /* A library is open */
    libcpnHash = mpifhcpnHash[ifhLibCur];
    libAlign = mpifhAlign[ifhLibCur];
    if (mpifhDict[ifhLibCur] == NULL)   /* If dictionary not allocated, do it */
        GetDictionary();
    return(TRUE);                       /* Success */
}

#pragma check_stack(off)

    /****************************************************************
    *                                                               *
    *  ProcessAnUndef:                                              *
    *                                                               *
    *  This  function  takes  as  its  arguments two pointers, two  *
    *  RBTYPEs, and  a flag.  It  does  not  return  a  meaningful  *
    *  value.   Most  of  the  parameters  to  this  function  are  *
    *  dummies; this function's address  is passed as a parameter,  *
    *  and  its  parameter  list  must  match  those  of  all  the  *
    *  functions whose  addresses can be passed  as a parameter to  *
    *  the  same  function  to  which  ProcessAnUndef's address is  *
    *  passed. Called by EnSyms.                                    *
    *                                                               *
    ****************************************************************/

LOCAL void              ProcessAnUndef(APROPNAMEPTR papropUndef,
                                       RBTYPE       rhte,
                                       RBTYPE       rprop__NotUsed__,
                                       WORD         fNewHte__NotUsed__)
{
    AHTEPTR             pahte;          /* Pointer to hash table entry */
    WORD                pn;             /* Library page number */
    APROPUNDEFPTR       pUndef;
    ATTRTYPE            attr;
#if NOT NEWSYM
    SBTYPE              sb;             /* Undefined symbol */
#endif

    fUndefHit = FALSE;

    pUndef = (APROPUNDEFPTR ) papropUndef;

    attr = pUndef->au_flags;

    // don't pull out any "weak" externs or unused aliased externals
    if (((attr & WEAKEXT)    && !(attr & UNDECIDED)) ||
        ((attr & SUBSTITUTE) && !(attr & SEARCH_LIB)))
        {
        fUndefHit = TRUE;       // this item is effectively resolved...
        return;
        }

    fUndefsSeen = (FTYPE) TRUE;         /* Set flag */
    if(!mpifhDict[ifhLibCur] && !vfLibOpen)
        return;                         /* Return if unable to get library */

    pahte = (AHTEPTR ) FetchSym(rhte,FALSE);
                                        /* Fetch name from symbol table */
#if NOT NEWSYM
    memcpy(sb,pahte->cch,B2W(pahte->cch[0]) + 1);
                                        /* Copy name */
#endif
#if LIBDEBUG
    fprintf(stdout,"Looking for '%s' - ", 1+GetFarSb(pahte->cch));
    fflush(stdout);
#endif
#if NEWSYM
    if(pn = LookupLibSym(GetFarSb(pahte->cch)))
#else
    if(pn = LookupLibSym(sb))          /* If symbol defined in this library */
#endif
    {
        fUndefHit = TRUE;
#if LIBDEBUG
        fprintf(stdout,"Symbol found at page %xH\r\n", pn);
        fflush(stdout);
#endif
       /* We now try to stuff the page number (pn) into a table that will
        * be sorted later.
        */
        if (ipnMac < PNSORTMAX)
        {
            pnSort[ipnMac++] = pn;
            return;
        }
        /*
         * No room to save the file offset so save file directly.
         */
        pahte = (AHTEPTR ) FetchSym(mpifhrhte[ifhLibCur],FALSE);
        /*
         * If SaveInput returns 0, then module was seen before.  Means
         * that dictionary says symbol is defined in this module but
         * for some reason, such as IMPDEF, the definition wasn't
         * accepted.  In this case, we return.
         */
        if(!SaveInput(GetFarSb(pahte->cch), (long)pn << libAlign, ifhLibCur, 0))
            return;
        /*
         * If first module extracted, save start of file list.
         */
        if(!fFileExtracted)
        {
            vrpNewList = vrpropTailFile;
            fFileExtracted = (FTYPE) TRUE;
        }
    }
#if LIBDEBUG
    else
    {
        fprintf(stdout, "Symbol NOT found\r\n");        /* Debug message */
        fflush(stdout);
    }
#endif
}

#if NEW_LIB_SEARCH

void StoreUndef(APROPNAMEPTR papropUndef, RBTYPE rhte,
                      RBTYPE rprop, WORD fNewHte)
{
    UND *               pund;
    APROPUNDEFPTR       pUndef;
    ATTRTYPE            attr;

    pUndef = (APROPUNDEFPTR ) papropUndef;

    attr = pUndef->au_flags;

    // don't pull out any "weak" externs or unused aliased externals
    if (((attr & WEAKEXT)    && !(attr & UNDECIDED)) ||
        ((attr & SUBSTITUTE) && !(attr & SEARCH_LIB)))
        return;

#ifdef LIBDEBUG
    {
    AHTEPTR pahte;
    pahte = (AHTEPTR) FetchSym(rhte,FALSE);
    fprintf(stdout,"Adding '%s'\r\n", 1+GetFarSb(pahte->cch));
    fflush(stdout);
    }
#endif

    if (pundFree)  // check free list
    {
        pund = pundFree;
        pundFree = pundFree->pNext;
    }
    else if (iundPool < C_UNDS_POOL)    // check pool
    {
        pund = &pundpoolCur->und[iundPool];
        iundPool++;
    }
    else
    {
        // allocate new pool...

        pundpoolCur = (UNDPOOL *)GetMem(sizeof(UNDPOOL));

        pundpoolCur->pNext = pundpoolHead;
        pundpoolHead       = pundpoolCur;
        pund               = &pundpoolCur->und[0];
        iundPool           = 1;         // entry zero is already used up
    }

    pund->dwLibMask   = 0;
    pund->pNext       = pundListHead;
    pund->papropUndef = papropUndef;
    pund->rhte        = rhte;
    pundListHead      = pund;
}

#endif

/*
 * Greater-than comparator to be used by Sort routine.
 */

LOCAL int cdecl FGtNum(const WORD *pn1, const WORD *pn2)
{
    if (*pn1 < *pn2)
        return(-1);
    if (*pn1 > *pn2)
        return(1);
    return(0);
}

/************************************************************************
 *                      Extended Dictionary
 *
 *      The extended dictionary occurs at the end of the regular dictionary
 *      and contains a first-level dependency tree for all the modules
 *      in the library.
 ************************************************************************/

#define LIBEXD          0xf2            /* Library EXtended Dictionary */




    /****************************************************************
    *                                                               *
    *  Extended Dictionary Format:                                  *
    *                                                               *
    *                                                               *
    *    BYTE       =0xF2 Extended Dictionary header                *
    *    WORD       length of extended dictionary in bytes          *
    *               excluding 1st 3 bytes                           *
    *                                                               *
    *  Start of ext. dictionary:                                    *
    *                                                               *
    *    WORD       number of modules in library = N                *
    *                                                               *
    *  Module table, indexed by module number, with N + 1 fixed-    *
    *  length entries:                                              *
    *                                                               *
    *    WORD       module page number                              *
    *    WORD       offset from start of ext. dictionary to list    *
    *               of required modules                             *
    *                                                               *
    *  Last entry is null.                                          *
    *                                                               *
    *  Module dependency lists, N variable-length lists:            *
    *                                                               *
    *    WORD       list length (number of required modules)        *
    *    WORD       module index, 0-based; this is index to module  *
    *    . . .      table at the begin of ext. dictionary.          *
    *    . . .                                                      *
    *                                                               *
    *                                                               *
    ****************************************************************/

#pragma loop_opt(on)

/*
 *      LookMod : look up a module by index in the extended dictionary
 *
 *      Get the list of modules required by the given module.  If not
 *      already marked, save index in sorting table (which will be
 *      converted to page number later) and mark the entry in the
 *      module table as seen by setting the low bit of the list offset.
 *
 *      Parameters:
 *              modtab: Pointer to module table
 *              iMod:   Index into table, 0-based
 */

LOCAL void NEAR         LookMod (edmt *modtab, WORD iMod)
{
    WORD                *pw;            /* Pointer to list of indexes */
    WORD                n;              /* List counter */

    /*
     * Get the pointer to the list.  Mask off low bit since it is used
     * as a marker.
     */
    pw = (WORD *) ((char *) modtab + (modtab[iMod].list & ~1));
    /*
     * For every entry in the list, if the corresponding entry in the
     * module table is not marked, save the index in pnSort and mark
     * the entry in the module table.
     */
    for(n = *pw++; n--; pw++)
    {
        if(!(modtab[*pw].list & 1))
        {
            /*
             * Check for table overflow.
             */
            if(ipnMac == PNSORTMAX)
                return;
            pnSort[ipnMac++] = *pw;
            modtab[*pw].list |= 1;
        }
    }
}

/*
 *      LookPage : Look up a module in the module table by page number
 *
 *      Use binary search.  If page is found, call LookMod() on the
 *      matching entry.
 *
 *      Parameters:
 *              modtab: Pointer to module table
 *              cMod:   Number of entries in table
 *              page:   Page number
 *      ASSUMES:
 *              The highest entry in the table has a page number of 0xffff.
 */

LOCAL void NEAR         LookPage (edmt *modtab, WORD cMod, WORD page)
{
    WORD                mid;            /* Current mid point */
    WORD                lo, hi;         /* Current low and high points */

    lo = 0;                             /* Table is 0-based.  */
    hi = (WORD) (cMod - 1);
    while(lo <= hi)
    {
        if(modtab[mid = (WORD) ((lo + hi) >> 1)].page == page)
        {
            modtab[mid].list |= 1;
            LookMod(modtab,mid);
            return;
        }
        else if(modtab[mid].page < page)
            lo = (WORD) (mid + 1);
        else
            hi = (WORD) (mid - 1);
    }
}
#pragma loop_opt(off)

/*
 *      ProcExtDic : Process Extended Dictionary
 *
 *      Store in pnSort all the secondary modules required by
 *      the modules obtained from the regular dictionary lookup.
 *
 *      Parameters:
 *              pExtDic:        Pointer to extended dictionary
 */

LOCAL void NEAR         ProcExtDic (pExtDic)
char                    *pExtDic;
{
    WORD                *p;
    WORD                *pEnd;
    WORD                cMod;
    edmt                *modtab;

    cMod = getword(pExtDic);
    modtab = (edmt *) (pExtDic + 2);

    /* For the binary search algorithm, we make an artifical last entry
     * with a page # at least as high as anything else.
     */

    modtab[cMod].page = 0xffff;

    /* Process by page numbers */

    for(p = pnSort, pEnd = &pnSort[ipnMac]; p < pEnd; ++p)
        LookPage(modtab, cMod, *p);

    /* Now pnSort from pEnd to lfaSort[ipnMac] contains module
     * index numbers.  Process by index number and convert to page.
     */

    for( ; p < &pnSort[ipnMac]; ++p)
    {
        LookMod(modtab,*p);
        *p = modtab[*p].page;
    }
}

/*
 *  GetExtDic - Get Extended Dictionary
 */

LOCAL char * NEAR       GetExtDic ()
{
    char                *p;
    int                 length;

    if(!vfLibOpen)
        if(!GetLib())
            return(NULL);
    /* WARNING:  we must just have read dictionary for this to work,
     * otherwise an fseek() is required here.
     */
    if (!mpifhDict[ifhLibCur])
    {
        fflush(bsInput);
        fseek(bsInput, libHTAddr + (libcpnHash << LG2PAG), 0);
    }
    if(getc(bsInput) != LIBEXD)
        return(NULL);
    if((p = GetMem(length = WSGets())) != NULL)
        if(fread(p,1,length,bsInput) != length)
        {
            FreeMem(p);
            p = NULL;
        }
    return(p);
}


char            *pExtDic = NULL;        /* Pointer to extended dictionary */

    /****************************************************************
    *                                                               *
    *  LibrarySearch:                                               *
    *                                                               *
    *  This  function  takes  no arguments.  It searches  all open  *
    *  libraries  to  resolve  undefined  externals.  It does  not  *
    *  return a meaningful value.                                   *
    *                                                               *
    ****************************************************************/

void NEAR               LibrarySearch(void)
{
    RBTYPE              vrpTmpFileFirst;
    WORD                ifhLibMacInit;  /* Initial number of libs to search */
    FTYPE               searchMore;     /* Search continue flag */
    WORD                bufpnSort[PNSORTMAX];
                                        /* Actual space for pnSort */
    SBTYPE              sbLibname;      /* Name of current library */
    AHTEPTR             pahte;          /* Pointer to hash table entry */
    REGISTER WORD       i;
    FTYPE               fLibPass1 = (FTYPE) TRUE;
                                        /* True if on 1st pass thru libs */
    FTYPE               *fUsedInPass1;  /* True if lib used in 1st pass thru libs */
    FTYPE               fFirstTime;     /* True if lib seen for the first time */
    extern FTYPE        fNoExtDic;      /* True if /NOEXTDICTIONARY */

#if NEW_LIB_SEARCH
    UND *pund;                          /* pointer in undef lookaside list */
    UND *pundPrev;                      /* pointer to previous undef entry */
    UND *pundNext;                      /* pointer to next undef entry */
#endif


    fUndefsSeen = (FTYPE) TRUE;         /* There are undefined externals */
    vfLibOpen = FALSE;                  /* No libraries open yet */
    pnSort = bufpnSort;                 /* Initialize sort table pointer */
    ifhLibMacInit = ifhLibMac;
    fUsedInPass1 = (FTYPE *) GetMem(ifhLibMac * sizeof(FTYPE));
    if (fUsedInPass1 != NULL)
        memset(fUsedInPass1, TRUE, ifhLibMac);


#if NEW_LIB_SEARCH
    // build up the the lookaside list

    EnSyms(StoreUndef,ATTRUND);

    fStoreUndefsInLookaside = TRUE;
#endif

    do                                  /* Loop to search libraries */
    {
        searchMore = FALSE;             /* Assume on final pass */
        for(ifhLibCur = 0; ifhLibCur < ifhLibMac && FUndefsLeft(); ++ifhLibCur)
        {                               /* While undefs and libraries */
#if NEW_LIB_SEARCH
            DWORD libMask = (1<<ifhLibCur);

            if (pundListHead->dwLibMask & libMask)
                continue;       // no need to search this library
                                // the first item in the list has already
                                // been searched...
#endif

            if(!GetLib())
                continue;

            /*
             * If this is first pass through the libraries and /NOEXT was
             * not given, try to get the extended dictionary.  We assume that
             * if there is one then only one library pass is needed.
             */
            if(fLibPass1 && !fNoExtDic)
                pExtDic = GetExtDic();
            else
                pExtDic = NULL;
            /* If no extended dictionary, reduce buffer size because more
             * seeking will be done.  This will affect remaining libraries
             * in search; we don't care about mixed extended and non-
             * extended libraries.
             */
            if(!pExtDic)
                setvbuf(bsInput,bsInput->_base,_IOFBF,1024);
            pahte = (AHTEPTR ) FetchSym(mpifhrhte[ifhLibCur],FALSE);
                                        /* Get library name */
            memcpy(sbLibname,GetFarSb(pahte->cch),B2W(pahte->cch[0])+1);
#if WIN_3 OR C8_IDE
            sbLibname[B2W(*sbLibname)+1] = '\0';
#endif
#if WIN_3
            StatMsgWin( "%s\r\n", sbLibname+1);
#endif
#if C8_IDE
            if(fC8IDE)
            {
                sprintf(msgBuf, "@I4%s\r\n", sbLibname+1);
                _write(fileno(stderr), msgBuf, strlen(msgBuf));
            }
#endif
            fFirstTime = (FTYPE) TRUE;
            while(FUndefsLeft())        /* While there are undefs seen */
            {
                fFileExtracted = FALSE; /* Assume we won't take anything */
                fUndefsSeen = FALSE;    /* Assume no more undefs */
                ipnMac = 0;             /* Initialize sort table count */

#if NOT NEW_LIB_SEARCH
                EnSyms(ProcessAnUndef,ATTRUND);
#else

                pund = pundListHead;
                pundPrev = NULL;

                while (pund)
                {
                    if (pund->dwLibMask & libMask)
                    {
                        break;  // since items are added to the head,
                                // as soon as we find one item that has
                                // already been searched, the rest have
                                // also already been searched...

                        // pundPrev = pund;
                        // pund  = pund->pNext;
                        // continue;
                    }

                    pundNext = pund->pNext;

                    if (pund->papropUndef->an_attr == ATTRUND)
                        ProcessAnUndef(pund->papropUndef, pund->rhte, 0, 0);
                    else
                        fUndefHit = TRUE; // no longer undefined -- remove

                    if (fUndefHit)
                    {
                        // remove this item from the undef list...
                        if (pundPrev)
                            pundPrev->pNext = pundNext;
                        else
                            pundListHead = pundNext;

                        pund->pNext =  pundFree;
                        pundFree    =  pund;

                    }
                    else
                    {
                        pund->dwLibMask |= libMask;
                        pundPrev = pund;
                    }

                    pund = pundNext;
                }
#endif

                /* Try to resolve references */
                /* If no modules obtained, exit loop.  */

                if(!ipnMac)
                {
#if NEWIO
                    if (fLibPass1)
                    {
                        /*
                         * If this library is seen for the first time in
                         * the first pass thru libraries and we don't
                         * pull out any modules from it, then close this
                         * library, because there are big chances this
                         * library is not needed.
                         */

                        if (fFirstTime)
                        {
                            _close(mpifhfh[ifhLibCur]);
                            mpifhfh[ifhLibCur] = 0;
                            /*
                             * Mark it also as not used in pass 1
                             * so, we can closed it also in the
                             * next passes thru libs.
                             */
                            if (fUsedInPass1)
                                fUsedInPass1[ifhLibCur] = FALSE;
                        }
                    }
                    else if (fUsedInPass1 && !fUsedInPass1[ifhLibCur])
                    {
                        /*
                         * In pass "n" thru libs close libraries
                         * not used in pass 1.
                         */
                        _close(mpifhfh[ifhLibCur]);
                        mpifhfh[ifhLibCur] = 0;
                    }
#endif
                    break;
                }
                fFirstTime = FALSE;     /* No longer first time seen */
                /* If extended dictionary present, process it.  */
                if(pExtDic)
                    ProcExtDic(pExtDic);
                /* Sort modules by page offset.  */
                qsort(pnSort, ipnMac, sizeof(WORD),
                      (int (__cdecl *)(const void *, const void *)) FGtNum);
                /*
                 * Save each module represented in the table.
                 */
                for (i = 0; i < ipnMac; i++)
                {
                /*
                 * If SaveInput returns 0, the module was already seen.  See
                 * above comment in ProcessAnUndef().
                 */
                    if(!SaveInput(sbLibname, (long)pnSort[i] << libAlign, ifhLibCur, 0))
                        continue;
                    if(!fFileExtracted) /* If no files extracted yet */
                    {
                        vrpNewList = vrpropTailFile;
                                        /* Save start of file list */
                        fFileExtracted = (FTYPE) TRUE;
                                        /* We have extracted a file */
                    }
                }
                if(!fFileExtracted)
                    break;              /* If we didn't take anything, break */
                /* Library might not be open because we may have searched
                 * an already-loaded dictionary.  If necessary, re-open
                 * library.
                 */
                if(!vfLibOpen)
                    GetLib();
                searchMore = (FTYPE) TRUE;      /* Otherwise it's worth another pass */
                vrpTmpFileFirst = rprop1stFile;
                                        /* Save head of module list */
                rprop1stFile = vrpNewList;
                                        /* Put new modules at head of list */
                fLibPass = (FTYPE) TRUE;        /* Processing object from library */
                DrivePass(ProcP1);      /* Do pass 1 on object from library */
                fLibPass = FALSE;       /* No longer processing lib. object */
                rprop1stFile = vrpTmpFileFirst;
                                        /* Restore original head of list */
                if (fUsedInPass1 && ifhLibMacInit < ifhLibMac)
                {
                    /* DrivePass added more libraries to search */
                    /* Reallocate fUsedInPass1                */

                    FTYPE   *p;         /* Temporary pointer */

                    p = (FTYPE *) GetMem(ifhLibMac * sizeof(FTYPE));
                    if (p == NULL)
                    {
                        FFREE(fUsedInPass1);
                        fUsedInPass1 = NULL;
                    }
                    else
                    {
                        memset(p, TRUE, ifhLibMac);
                        memcpy(p, fUsedInPass1, ifhLibMacInit);
                        FFREE(fUsedInPass1);
                        fUsedInPass1 = p;
                    }
                    ifhLibMacInit = ifhLibMac;
                }
            }
            /* Free space for extended dictionary if present */
            if(pExtDic)
                FFREE(pExtDic);
            if(vfLibOpen)
            {
#if NOT NEWIO
                fclose(bsInput);        /* Close the library */
#endif
                vfLibOpen = FALSE;      /* No library open */
            }
        }
        /* No longer on 1st pass thru libraries.  */
        fLibPass1 = FALSE;
    }
    while(searchMore && FUndefsLeft()); /* Do until search done */
    FreeMem(fUsedInPass1);
    FreeDictionary();                   /* Free dictionary space */
    /*
     * Restore large buffer size in case it was reduced.
     */
    setvbuf(bsInput,bsInput->_base,_IOFBF,LBUFSIZ);

#if NEW_LIB_SEARCH

    fStoreUndefsInLookaside = FALSE;

    while (pundpoolHead)
    {
        pundpoolCur = pundpoolHead->pNext;
        FFREE(pundpoolHead);
        pundpoolHead = pundpoolCur;
    }

#endif
}

#if CMDMSDOS
/*
 *  GetLibAll:
 *
 *  Process all the modules in a given library in Pass 1.
 *  Create property cells for them and insert into the file list.
 */

void NEAR               GetLibAll(sbLib)
BYTE                    *sbLib;
{
    WORD                ifh;            /* (fake) library index */
    long                lfa;            /* Current file offset */
    IOVTYPE             iov;            /* Overlay number */
    RBTYPE              rbFileNext;     /* Pointer to next file property */
    RBTYPE              rbFileNew;      /* Pointer to new file property */
    APROPFILEPTR        apropFile, apropFilePrev;
    BYTE                *sbInput;       /* Asciiz filename */
    int                 fh;             /* File handle */

    fDrivePass = FALSE;
    sbInput = sbLib + 1;
    /* Get the ifh, iov, and pointer to the next file from the current
     * file pointer.
     */
    apropFile = (APROPFILEPTR ) FetchSym(vrpropFile,TRUE);
    ifh = apropFile->af_ifh;
    iov = apropFile->af_iov;
    rbFileNext = apropFile->af_FNxt;
#if NEWIO
    fh = SmartOpen(sbInput,ifh);
    if (fh <= 0 && lpszLIB != NULL)
        fh = SearchPathLink(lpszLIB, sbInput, ifh, TRUE);

    if (fh > 0)
    {
        fflush(bsInput);
        bsInput->_file = (char) fh;
    }
    else
        Fatal(ER_fileopn,sbInput);

#else
    if((bsInput = fopen(sbInput,RDBIN)) == NULL)
        Fatal(ER_fileopn,sbInput);
#endif
    if(getc(bsInput) != LIBHDR)         /* Check for valid record type */
        Fatal(ER_badlib,sbInput);
    cbRec = (WORD) (3 + WSGets());      /* Get record length */
    for(libAlign = 15; libAlign && !(cbRec & (1 << libAlign)); --libAlign);
                                        /* Calculate alignment factor */
    fDrivePass = (FTYPE) TRUE;
    /* Reset current file's lfa from 0 to offset of 1st module */
    apropFile->af_lfa = lfa = 1L << libAlign;
    /* Go to the first module */
    fseek(bsInput,lfa,0);
    /* Process the library as follows:  Process the current module.
     * Go to the next module; if it starts with DICHDR then we're
     * done.  Else, create a new file property cell for the next
     * module, insert it in the file list, and go to start of loop.
     */

    rect = (WORD) getc(bsInput);
    while (rect != DICHDR)
    {
        ungetc(rect, bsInput);
        lfaLast = apropFile->af_lfa = ftell(bsInput);
        ProcP1();
        while (TYPEOF(rect) != MODEND)
        {
            rect = (WORD) getc(bsInput);
            fseek(bsInput, (cbRec = WSGets()), 1);
        }

        do
        {
            rect = (WORD) getc(bsInput);
        }
        while (rect != THEADR && rect != DICHDR && rect != EOF);
        if (rect == DICHDR)
        {
            if (rbFileNext == RHTENIL)
                vrpropTailFile = vrpropFile;
#if NOT NEWIO
            fclose(bsInput);
#else
            rbFilePrev = vrpropFile;
#endif
            return;
        }
        if (rect == EOF)
            Fatal(ER_libeof);

        // Make a new file property cell

        apropFile = (APROPFILEPTR ) PropAdd(vrhteFile, ATTRFIL);
        rbFileNew = vrprop;
#if ILINK
        apropFile->af_imod = ++imodCur; // allocate a module number
        apropFile->af_cont = 0;
        apropFile->af_ientOnt = 0;
#endif
        apropFile->af_rMod = 0;
        apropFile->af_ifh = (char) ifh;
        apropFile->af_iov = (IOVTYPE) iov;
        apropFile->af_FNxt = rbFileNext;
#if SYMDEB
        apropFile->af_publics = NULL;
        apropFile->af_Src = NULL;
        apropFile->af_SrcLast = NULL;
        apropFile->af_cvInfo = NULL;
#endif
        apropFile->af_ComDat = 0L;
        apropFile->af_ComDatLast = 0L;
        MARKVP();

        // Get the just-processed property file cell

        apropFilePrev = (APROPFILEPTR ) FetchSym(vrpropFile,TRUE);
        apropFilePrev->af_FNxt = rbFileNew;
        vrpropFile = rbFileNew;
    };

    // Remove an empty Lib from the chain of files

    if (vrpropFile == rprop1stFile)
    {
        // If the empty lib is first on list

        rprop1stFile = rbFileNext;
    }
    else
    {
#if NEWIO
        apropFilePrev = (APROPFILEPTR)FetchSym(rbFilePrev, TRUE);
        apropFilePrev->af_FNxt = apropFile->af_FNxt;
#endif
    }
#if NEWIO
    if (rbFileNext == RHTENIL)
        vrpropTailFile = rbFilePrev; // In case we removed the last file
    _close(fileno(bsInput));
    rbFilePrev = vrpropFile;
#endif
}
#endif /*CMDMSDOS*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newfix.c ===
/*
 *  TITLE
 *              newfix.c
 *              Pete Stewart
 *              (C) Copyright Microsoft Corp 1984-89
 *              12 October 1984
 *
 *  DESCRIPTION
 *              This file contains routines for the linker that
 *              read and interpret fixup records during the second
 *              pass of the linking process.
 *
 */
#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Basic types and constants */
#include                <bndrel.h>      /* Relocation definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE format structure def.s */
#if EXE386
#include                <exe386.h>      /* 386 .EXE format structure def.s */
#include                <fixup386.h>    /* Linker internal fixup representation */
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <nmsg.h>        /* Near message strings */

#define RelocWarn(a,b,c,d,e)    FixErrSub(a,b,c,d,e,(FTYPE)FALSE)
#define RelocErr(a,b,c,d,e)     FixErrSub(a,b,c,d,e,(FTYPE)TRUE)
#define FixupOverflow(a,b,c,d)  RelocErr(ER_fixovf,a,b,c,d)
#define IsSELECTED(x)   ((x)&SELECTED_BIT)



__inline void addword(BYTE *pdata, WORD w)
// add a word to the word at location pdata... enforce little endian add
// even if linker hosted on a big endian machine
{
    w += pdata[0] + (pdata[1]<<BYTELN);
    pdata[0] = (BYTE)w;
    pdata[1] = (BYTE)(w>>BYTELN);
}


#if defined( _WIN32 )
#define fixword(x,y)  ((*(WORD UNALIGNED *)(x)) = (WORD)(y))
#define fixdword(x,y) ((*(DWORD UNALIGNED *)(x)) = (DWORD)(y))
#else
#if M_I386
#define fixword(x,y)  ((*(WORD *)(x)) = (WORD)(y))
#define fixdword(x,y) ((*(DWORD *)(x)) = (DWORD)(y))
#else
#define fixword(x,y)  ((x)[0]) = (BYTE)(y); \
                      ((x)[1]) = (BYTE)((y) >> BYTELN);

#define fixdword(x,y) ((x)[0]) = (BYTE)(y); \
                      ((x)[1]) = (BYTE)((y) >> BYTELN); \
                      ((x)[2]) = (BYTE)((y) >> (BYTELN*2)); \
                      ((x)[3]) = (BYTE)((y) >> (BYTELN*3));
#endif // NOT M_I386
#endif // NOT _WIN32

#if OSEGEXE
extern RLCPTR           rlcLidata;      /* Pointer to LIDATA fixup array */
extern RLCPTR           rlcCurLidata;   /* Pointer to current LIDATA fixup */
# if ODOS3EXE OR defined(LEGO)
#define DoFixup         (*pfProcFixup)
# else
#if EXE386
#define DoFixup         Fix386
#else
#define DoFixup         FixNew
#endif
# endif
#else
#define DoFixup         FixOld
#endif
#if NOT ODOS3EXE
#define fNoGrpAssoc     FALSE
#endif
WORD                    mpthdidx[RLCMAX];       /* f(thread) = tgt index */
KINDTYPE                mpthdmtd[RLCMAX];       /* f(thread) = tgt method */
LOCAL WORD              mpthdfidx[RLCMAX];      /* f(thread) = frm index */
LOCAL KINDTYPE          mpthdfmtd[RLCMAX];      /* f(thread) = frm method */
FIXINFO                 fi;                     /* Fixup information record */
#if EXE386
LOCAL RATYPE            objraCur;               /* Current offset in object */
#endif

#if POOL_BAKPAT
LOCAL  void *           poolBakpat;
#endif


/*
 *  FUNCTION PROTOTYPES
 */


LOCAL void           NEAR GetFixdat(void);
LOCAL unsigned char  NEAR GetFixup(void);
#if OSEGEXE
LOCAL void           NEAR SaveLiRel(RLCPTR pr);
LOCAL RATYPE         NEAR FinishRlc(RLCPTR r,
                                    unsigned short sa,
                                    RATYPE ra);
#if NOT EXE386
#if O68K
LOCAL WORD           NEAR GetFixupWord(BYTE *);
LOCAL DWORD          NEAR GetFixupDword(BYTE *);
#else /* NOT O68K */
#define GetFixupWord    getword
#define GetFixupDword   getdword
#endif /* NOT O68K */
#endif /* NOT EXE386 */
#endif /* OSEGEXE */

LOCAL unsigned char  NEAR lastbyte(unsigned char *pdata,
                                   RATYPE ra,
                                   unsigned char optest,
                                   unsigned char opnew);
LOCAL void           NEAR Getgsn(unsigned char kind,
                                 unsigned short idx,
                                 unsigned short *pgsn,
                                 RATYPE *pra);
LOCAL unsigned char  NEAR TransFAR(unsigned char *pdata,
                                   RATYPE ra,
                                   RATYPE raTarget);
LOCAL void           NEAR StartAddrOld(void);
LOCAL unsigned short NEAR Mpgsnosn(unsigned short gsn);
LOCAL void           NEAR GetFrameTarget(unsigned short *pgsnFrame,
                                         unsigned short *pgsnTarget,
                                         RATYPE *praTarget);
#if EXE386
LOCAL void           NEAR Fix386();
#endif
#if ODOS3EXE
LOCAL WORD           NEAR InOneGroup(WORD gsnTarget, WORD gsnFrame);
#endif
LOCAL WORD           NEAR CallGateRequired(SATYPE saTarget);
extern void          AddTceEntryPoint( APROPCOMDAT *pC );


/*
 *  GetFixdat:
 *
 *  Process the FIXDAT byte of a FIXUPP record.
 */

LOCAL void NEAR GetFixdat()
{
    REGISTER WORD       fixdat;         /* The FIXDAT byte */
    WORD                i;              /* Temporary index */


    fixdat = Gets();                    /* Get FIXDAT byte */
    i = (WORD) ((fixdat >> 4) & 7);     /* Get frame info */
    if (fixdat & F_BIT)                 /* If frame thread-specified */
    {
        i &= 3;                         /* Threads numbered from 0 to 3 */
        fi.f_fmtd = mpthdfmtd[i];       /* Get method */
        fi.f_fidx = mpthdfidx[i];       /* Get index */
    }
    else                                /* Else if frame explicit */
    {
        fi.f_fmtd = (KINDTYPE) i;       /* Save frame method */
        switch(i)                       /* Switch on frame method */
        {
            case F0:                    /* Index to get */
              fi.f_fidx = GetIndex(1, (WORD) (snMac - 1));
              break;

            case F1:
              fi.f_fidx = GetIndex(1, (WORD) (grMac - 1));
              break;

            case F2:
              fi.f_fidx = (WORD) (GetIndex(1, EXTMAX) + QCExtDefDelta);
              if (fi.f_fidx >= extMac)
                InvalidObject();
              break;

            case F3:                    /* Frame number to punt */
              WGets();
              break;

            case F4:                    /* Nothing to get */
            case F5:
              break;

            default:                    /* Invalid object */
              InvalidObject();
        }
    }
    i = (WORD) (fixdat & 3);            /* Get target info */
    if (fixdat & T_BIT)                 /* If target given by thread */
    {
        fi.f_mtd = mpthdmtd[i]; /* Get method */
        fi.f_idx = mpthdidx[i]; /* Get index */
    }
    else                                /* Else if target explicit */
    {
        fi.f_mtd = (KINDTYPE ) i;       /* Save the method */
        ASSERT(fi.f_mtd != 3);  /* Unimplemented method */
        fi.f_idx = GetIndex(1, EXTMAX); /* Get the index */
        if (fi.f_mtd == 2)
        {
            fi.f_idx += (WORD) QCExtDefDelta;
            if (fi.f_idx >= extMac)
                InvalidObject();
        }
    }
#if OMF386
    if(rect&1)
        fi.f_disp = (fixdat & P_BIT) ? 0L : LGets();
    else
#endif
        fi.f_disp = (DWORD) ((fixdat & P_BIT) ? 0 : WGets());
                                        /* Get displacement, if any */
}


/*
 *  GetFixup:
 *
 *  Read and interpret a fixup record, storing the information in
 *  a buffer.
 *  Returns TRUE if fixup, FALSE if thread definition.
 */

LOCAL FTYPE NEAR GetFixup()
{
    REGISTER WORD       key;            /* Key byte */
    WORD                cbData;         /* End point */

    key = Gets();                       /* Get key byte */
    if(!(key & THREAD_BIT))             /* If thread definition */
    {
        fi.f_mtd  = (KINDTYPE ) ((key >> 2) & 7);
                                        /* Get the thread method */
        ASSERT(fi.f_mtd  != 3); /* Unimplemented */
        /*
         * If target thread, take modulo 4 of method.  Primary/secondary
         * not specified by thread.
         */
        if(!(key & D_BIT))
            fi.f_mtd &= 3;
        switch(fi.f_mtd)                /* Switch on the thread method */
        {
            case 0:                     /* Thread specifies an index */
              fi.f_idx = GetIndex(1, (WORD) (snMac - 1));
              break;

            case 1:
              fi.f_idx = GetIndex(1, (WORD) (grMac - 1));
              break;

            case 2:
              fi.f_idx = (WORD) (GetIndex(1, EXTMAX) + QCExtDefDelta);
                                        /* Get index */
              if (fi.f_idx >= extMac)
                InvalidObject();
              break;

            case 3:                     /* Frame number (unimplemented) */
              WGets();                  /* Skip the frame number */
              break;

            case 4:                     /* No thread datum */
            case 5:
              break;

            default:                    /* Error */
              InvalidObject();          /* Die gracefully */
        }
        if(!(key & D_BIT))              /* If we have a target thread */
        {
            key &= 3;                   /* Get thread number */
            mpthdmtd[key] = fi.f_mtd; /* Get method */
            mpthdidx[key] = fi.f_idx; /* Get index */
        }
        else                            /* If we have a frame thread */
        {
            key &= 3;                   /* Get thread number */
            mpthdfmtd[key] = fi.f_mtd;/* Get method */
            mpthdfidx[key] = fi.f_idx;/* Get index */
        }
        return((FTYPE) FALSE);          /* Not a fixup */
    }
    /*
     * At this point, we know we have a fixup to perform.
     */

    /* Get fixup location type */
#if EXE386
    fi.f_loc = (WORD) ((key >> 2) & NRSTYP);
#else
#if OMF386
    if(rect & 1)
        fi.f_loc = (key >> 2) & NRSTYP;
    else
#endif
        fi.f_loc = (key >> 2) & 7;
#endif

    fi.f_self = (FTYPE) ((key & M_BIT)? FALSE: TRUE);
                                        /* Get fixup mode */
    fi.f_dri = (WORD) (((key & 3) << 8) + Gets());
                                        /* Get data record index */
    cbData = vcbData;
    /* Check if location goes beyond end of data record. */
    switch(fi.f_loc)
    {
        case LOCOFFSET:
        case LOCLOADOFFSET:
        case LOCSEGMENT:
            --cbData;
            break;
        case LOCPTR:
#if OMF386
        case LOCOFFSET32:
        case LOCLOADOFFSET32:
#endif
            cbData -= 3;
            break;
#if OMF386
        case LOCPTR48:
            cbData -= 5;
            break;
#endif
    }
    if(fi.f_dri >= cbData)
        Fatal(ER_badobj);

    GetFixdat();                        /* Process FIXDAT byte */
#if TCE
    if(!vfPass1)
#endif
        fi.f_add = !!*(WORD UNALIGNED *)(rgmi + fi.f_dri);
                                        /* Check if fixup is additive */
    return((FTYPE ) TRUE);              /* This is a fixup */
}


    /****************************************************************
    *                                                               *
    *  FixErrSub:                                                   *
    *                                                               *
    *  Report a fixup error.                                        *
    *                                                               *
    ****************************************************************/

void NEAR               FixErrSub(msg,ra,gsnFrame,gsnTarget,raTarget,fErr)
MSGTYPE                 msg;            /* Error message */
RATYPE                  ra;             /* Relative addr of error */
SNTYPE                  gsnFrame;
SNTYPE                  gsnTarget;
RATYPE                  raTarget;
FTYPE                   fErr;           /* True if increment err cnt */
{
    BYTE                *sb;            /* Pointer to name */
#if EXE386
    char                *kind;
#endif

    if (fDebSeg)
        return;                         // Ignore warnings/errors for CV info
    for(;;)                             /* Loop to give message */
    {
        sb = 1 + GetFarSb(GetHte(mpgsnrprop[vgsnCur])->cch);
#if EXE386
        if(fErr)
            OutError(msg,ra - mpsegraFirst[mpgsnseg[vgsnCur]],sb);
        else
            OutWarn(msg,ra - mpsegraFirst[mpgsnseg[vgsnCur]],sb);

        switch(fi.f_loc)
        {
            case LOCSEGMENT:
                kind = "Selector";
                break;
            case LOCPTR:
                kind = "16:16 pointer";
                break;
            case LOCPTR48:
                kind = "16:32 pointer";
                break;
            default:
                kind = "";
                break;
        }
        if(fi.f_mtd == KINDEXT && mpextprop && mpextprop[fi.f_idx])
            FmtPrint(" %s '%s'\r\n",__NMSG_TEXT(N_tgtexternal),
                    1 + GetPropName(FetchSym(mpextprop[fi.f_idx],FALSE)));
        else if (gsnTarget)
        {                               /* Output frame, target info */
            FmtPrint(" %s: %s %s, %s %lx\r\n", kind,
                __NMSG_TEXT(N_tgtseg),
                1 + GetPropName(FetchSym(mpgsnrprop[gsnTarget],FALSE)),
                __NMSG_TEXT(N_tgtoff), (RATYPE) raTarget);
        }
#else
        if(fErr)
            OutError(msg,ra - mpgsndra[vgsnCur],sb);
        else
            OutWarn(msg,ra - mpgsndra[vgsnCur],sb);

        if(fi.f_mtd == KINDEXT && mpextprop && mpextprop[fi.f_idx])
            FmtPrint(" %s '%s'\r\n",__NMSG_TEXT(N_tgtexternal),
                    1 + GetPropName(FetchSym(mpextprop[fi.f_idx],FALSE)));
        else if(gsnFrame && gsnTarget)
        {                               /* Output frame, target info */
            FmtPrint(" %s %s", __NMSG_TEXT(N_frmseg),
                1 + GetPropName(FetchSym(mpgsnrprop[gsnFrame], FALSE)));
            FmtPrint(", %s %s", __NMSG_TEXT(N_tgtseg),
                1 + GetPropName(FetchSym(mpgsnrprop[gsnTarget], FALSE)));
            FmtPrint(", %s %lX\r\n",
                __NMSG_TEXT(N_tgtoff), (RATYPE) raTarget);
        }
#endif
        if(!fLstFileOpen || bsErr == bsLst) break;
                                        /* Exit loop */
        bsErr = bsLst;                  /* Insure loop exit */
    }
    if (fLstFileOpen && fErr)
        cErrors--;                      // We called OutError twice for one error
    bsErr = stderr;
}


#if OSEGEXE
/*
 * SaveLiRel : Save an LIDATA relocation record
 */
LOCAL void NEAR         SaveLiRel (pr)
RLCPTR                  pr;             /* Generic relocation record */
{

#if EXE386
    LE_SOFF(*pr) = (WORD) (objraCur - vraCur);
#else
    NR_SOFF(*pr) -= (WORD) vraCur;      /* Save offset within LIDATA record */
#endif

    if((char *) rlcCurLidata > (char *) &rgmi[DATAMAX - sizeof(RELOCATION)])
    {                                   /* If too many fixups */
        OutError(ER_fixmax);
                                        /* Output error message */
        return;                         /* Try next fixup */
    }
    FMEMCPY(rlcCurLidata++, pr, sizeof(RELOCATION));
                                        /* Copy relocation into buffer */
}


/*      HERE ARE THE RULES USED BY LINKER TO GENERATE ENTRY POINTS:
 *
 * +----+-------------+-------------+-------------+-------------+-------------+
 * |    \             |             |             |             |             |
 * |     \ referenced |     data    |     code    | code ring 2 | code ring 2 |
 * |entry \   from    |   any ring  |    ring 3   |nonconforming| conforming  |
 * |point  \          |             |             |             |             |
 * |target  \---------+-------------+-------------+-------------+-------------+
 * |                  |             |             |             |             |
 * |data              |  no entry   |  no entry   |  no entry   |  no entry   |
 * |nonexported       |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |                  |             |             |             |             |
 * |data              | fixed entry | fixed entry | fixed entry | fixed entry |
 * |exported          |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |                  |             |             |             |             |
 * |code ring 3       |  no entry(1)|  no entry(1)|   invalid   |   invalid   |
 * |nonexported       |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |                  |             |             |             |             |
 * |code ring 3       | fixed entry | fixed entry |   invalid   |   invalid   |
 * |exported          |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |code ring 2       |             |             |             |             |
 * |nonconforming     |movable entry|movable entry|  no entry(1)|movable entry|
 * |nonexported       |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |code ring 2       |             |             |             |             |
 * |nonconforming     |movable entry|movable entry| fixed entry |movable entry|
 * |exported          |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |code ring 2       |             |             |             |             |
 * |conforming        |  no entry(1)|  no entry(1)|  no entry(1)|  no entry(1)|
 * |nonexported       |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 * |code ring 2       |             |             |             |             |
 * |conforming        | fixed entry | fixed entry | fixed entry | fixed entry |
 * |exported          |             |             |             |             |
 * |------------------+-------------+-------------+-------------+-------------+
 *
 *   (1) If the entry point requires windows compatable prolog editing then
 *       this entry point must be defined as a "fixed entry".
 *
 *
 *   Forget about the note, (1), for now.  I don't think it applies with
 *   PROTMODE.
 *   Ring 2 means IOPL, ring 3 means NOIOPL.
 *   To simplify the code we are taking advantage of segment attributes.
 *   I.e.  force all the following segments to FIXED:
 *       data
 *       code ring 3
 *       code ring 2, conforming
 *   force to MOVABLE:
 *       code ring 2, nonconforming
 *   Then just use the segment attribute to determine what type of entry
 *   to generate.  There are clearly two exceptions that you must check
 *   for:
 *   - code ring 2 nonconforming nonexported, referenced by code ring 2 nonconforming
 *   - code ring 2 nonconforming exported, referenced by code ring 2 nonconforming
 *
 */



#if NOT QCLINK
/*** CallGateRequired - check if call gate required
*
* Purpose:
*   Check if call gate is required for given target segment.
*
* Input:
*   saTarget    - fixup target segment (memory object)
*
* Output:
*   Returns TRUE if call gate required, othrewise FALSE.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/


LOCAL WORD  NEAR        CallGateRequired(SATYPE saTarget)
{
#if EXE386
    return(FALSE);
#else
    register WORD       flags;


    flags = mpsaflags[saTarget];
    if ((vFlags & NEPROT) || TargetOs == NE_OS2)
    {
        // If the target entry point segment is NONCONFORMING IOPL CODE 16-bit
        // and current segment is a different type, generate a callgate

        return(IsCodeFlg(flags)   &&
               NonConfIOPL(flags) &&
               mpsaflags[mpsegsa[vsegCur]] != flags);
    }
    else
    {
        // If target segment is non-absolute and movable, generate
        // a movable-type fixup and a corresponding entry table entry:

        return(flags & NSMOVE);
    }
#endif
}
#endif



/*
 *  FinishRlc:
 *
 *  Finish processing a relocation for a segmented-exe.
 */

LOCAL RATYPE NEAR       FinishRlc(r,sa,ra)
RLCPTR                  r;              /* Relocation record to finish */
SATYPE                  sa;             /* Target file segment number */
RATYPE                  ra;             /* Target offset */
{
    if (!sa || sa >= saMac)
        return(ra);                     /* Something is wrong */
#if NOT EXE386
#if NOT QCLINK
    if (CallGateRequired(sa))
    {
        NR_SEGNO(*r) = BNDMOV;          /* Reference is to movable segment */
        NR_ENTRY(*r) = MpSaRaEto(sa,ra);/* Save Entry Table ordinal */
    }
    else
    {
        NR_SEGNO(*r) = (BYTE) sa;       /* Reference is to fixed segment */
        if (
#ifdef  LEGO
#if OSEGEXE
            !fKeepFixups &&
#endif
#endif  /* LEGO */
            ((NR_STYPE(*r) & NRSTYP) == NRSSEG))
            NR_ENTRY(*r) = (WORD) 0;    /* For non call-gate base fixups force offset to zero */
        else
        {
#if O68K
            if (iMacType != MAC_NONE && IsDataFlg(mpsaflags[sa]))
                NR_ENTRY(*r) = (WORD) (ra - mpsadraDP[sa]);
                                        /* Save offset into fixed segment */
            else
#endif /* O68K */
                NR_ENTRY(*r) = (WORD) ra;
                                        /* Save offset into fixed segment */
        }
    }
#else
    NR_SEGNO(*r) = (BYTE) sa;           /* Reference is to fixed segment */
    NR_ENTRY(*r) = (WORD) ra;           /* Save offset into fixed segment */
#endif
#else
    if (sa == SANIL)
    {
        RelocWarn(ER_badfixflat,objraCur,SNNIL,0,ra);
                                        /* Oops ! - Flat relative refernce */
        return((RATYPE)0);              /* OS doesn't know object number zero */
    }

    LE_OBJNO(*r) = sa;                  /* Target object number */
    if (CallGateRequired(sa))
    {
        NR_FLAGS(*r) |= NRRENT;
        LE_IATORD(*r) = MpSaRaEto(sa,ra);
                                        /* Save Entry Table ordinal */
    }
    else
    {
        /* Target is internal reference */

        if ((NR_STYPE(*r) & NRSTYP) == NRSSEG)
            ra = 0L;                    /* For non call-gate base fixups force offset to zero */
    }
    LE_TOFF(*r) = ra;                   /* Target offset */
#endif

    if(TYPEOF(vrectData) == LIDATA)     /* If we have an LIDATA record */
    {
        SaveLiRel(r);                   /* Save LIDATA relocation record */
        return(0);                      /* Nothing to add */
    }
#if EXE386
    return(SaveFixup(mpsegsa[vsegCur],vpageCur,r));
#else
    return(SaveFixup(mpsegsa[vsegCur],r));
                                        /* Save fixup, return chain */
#endif
}
#endif /* OSEGEXE */


/*
 *  lastbyte:
 *
 *  If the last byte before the current byte matches
 *  optest, then replace it with opnew and return TRUE;
 *  otherwise, return FALSE.
 */
LOCAL FTYPE NEAR        lastbyte(pdata,ra,optest,opnew)
BYTE                    *pdata;         /* Pointer into data record */
RATYPE                  ra;             /* Offset in current segment */
BYTE                    optest;         /* Op code to test against */
BYTE                    opnew;          /* New op code */
{
    BYTE FAR            *pb;            /* Byte pointer */

    if(pdata > rgmi)                    /* If needed byte in buffer */
    {
        if(pdata[-1] != optest) return(FALSE);
                                        /* Test fails if bytes differ */
        pdata[-1] = opnew;              /* Replace the op code */
        return((FTYPE) TRUE);                   /* Test succeeds */
    }
    if(ra == 0) return(FALSE);          /* Test fails if no byte to test */
    if(fNewExe)
        pb = mpsaMem[mpsegsa[vsegCur]] + ra - 1;    /* Map in the desired byte */
    else
        pb = mpsegMem[vsegCur] + ra - 1;        /* Map in the desired byte */

    if(*pb != optest) return(FALSE);    /* Test fails if bytes differ */
    *pb = opnew;                        /* Replace the op code */
    markvp();                           /* Page has changed */
    return((FTYPE) TRUE);               /* Test succeeds */
}


#if OSEGEXE
/*
 *  DoIteratedFixups:
 *
 *  Process fixups on an LIDATA record for a segmented-exe.
 */


void NEAR               DoIteratedFixups(cb,pb)
WORD                    cb;             /* Byte count */
BYTE                    *pb;            /* Byte pointer */
{
    RATYPE              raChain;        /* Fixup chain */
    RATYPE              raMin;          /* Starting record offset */
    RATYPE              raMax;          /* Ending record offset */
    RLCPTR              r;              /* Relocation record */
    WORD                j;              /* Index */
    DWORD               SrcOff;


    if(rlcCurLidata == rlcLidata) return;
                                        /* Nothing to do if no fixups */
    raMin = (RATYPE)(pb - rgmi);        /* Offset of start of data in record */
    raMax = raMin + cb - 1;             /* Offset of end of data in record */
    r = rlcLidata;
    while (r < rlcCurLidata)
    {                                   /* Do for all fixups in array */
#if EXE386
        SrcOff = LE_SOFF(*r);
#else
        SrcOff = (DWORD) NR_SOFF(*r);
#endif
        if(SrcOff >= (DWORD) raMin && SrcOff <= (DWORD) raMax)
        {                               /* If fixup lies in range of data */
            j = (WORD) (SrcOff - (DWORD) raMin);
                                        /* Get index off pb */
                                        /* Calculate offset in segment */
#if EXE386
            LE_SOFF(*r)= (WORD) ((vraCur + j) % (1 << pageAlign));
            vpageCur = ((vraCur + j) >> pageAlign) + 1;
            raChain = SaveFixup(mpsegsa[vsegCur], vpageCur, r);
                                        /* Save the fixup reference */
#else
            NR_SOFF(*r) = (WORD) (vraCur + j);
            raChain = SaveFixup(mpsegsa[vsegCur],r);
                                        /* Save the fixup reference */
            if(!(NR_FLAGS(*r) & NRADD))
            {                   /* If not additive */
                pb[j] = (BYTE) raChain;
                                        /* Set low byte of chain */
                pb[j + 1] = (BYTE)(raChain >> BYTELN);
                                        /* Set high byte of chain */
            }
#endif
                                        /* Restore offset in record */
#if EXE386
            LE_SOFF(*r)= (WORD) ((raMin + j) % (1 << pageAlign));
#else
            NR_SOFF(*r) = (WORD) (raMin + j);
#endif
        }
        ((RLCPTR ) r)++;
    }
}
#endif /* OSEGEXE */


/*
 *  Getgsn:
 *
 *  Obtain segment number and offset for the given fixup method and index.
 *  Return values are stored in pointers.
 */

LOCAL void NEAR         Getgsn(kind,idx,pgsn,pra)
KINDTYPE                kind;           /* Kind of index */
WORD                    idx;            /* The index */
SEGTYPE                 *pgsn;          /* gsn (ref) */
RATYPE                  *pra;           /* ra (ref) */
{
#if O68K
    SATYPE              sa;
#endif /* O68K */

    switch(kind)                        /* Decide what to do */
    {
        case KINDSEG:                   /* Segment index */
#if FALSE
          if(idx >= snMac) InvalidObject();
                                        /* Make sure index not too big */
#endif
          *pgsn = mpsngsn[idx];         /* Get gsn */
          *pra = mpgsndra[*pgsn];       /* Get ra */
#if O68K
          if (iMacType != MAC_NONE && IsDataFlg(mpsaflags[sa =
            mpsegsa[mpgsnseg[*pgsn]]]))
              *pra += mpsadraDP[sa];    /* Get data ra */
#endif /* O68K */
          break;

        case KINDGROUP:                 /* Group index */
#if FALSE
          if(idx >= grMac) InvalidObject();
                                        /* Make sure index not too big */
#endif
          *pgsn = mpggrgsn[mpgrggr[idx]];
                                        /* Get gsn */
          *pra = mpgsndra[*pgsn];       /* Get ra */
#if O68K
          if (iMacType != MAC_NONE && IsDataFlg(mpsaflags[sa =
            mpsegsa[mpgsnseg[*pgsn]]]))
              *pra += mpsadraDP[sa];    /* Get data ra */
#endif /* O68K */
          break;

        case KINDEXT:                   /* External index */
#if FALSE
          if(idx >= extMac) InvalidObject();
                                        /* Make sure index not too big */
#endif
          *pgsn = mpextgsn[idx];        /* Get gsn */
          *pra = mpextra[idx];          /* Get ra */
          break;

        default:                        /* All other kinds */
          *pgsn = SEGNIL;               /* No gsn */
          *pra = 0;                     /* No ra */
          break;
    }

    // If this is $$SYMBOLS segment then return logical offset
    // NOT physical offset

    if (fDebSeg) {
#if O68K
        if (iMacType == MAC_NONE)
#endif
            *pra -= mpsegraFirst[mpgsnseg[*pgsn]];
    }
}



/*
 *  TransFAR : Possibly translate an intra-segment FAR call or jump
 *
 *      If the given location looks like a FAR call or jump,
 *      translate it and return TRUE.  Otherwise, do nothing and
 *      return FALSE.
 */
LOCAL FTYPE NEAR        TransFAR (pdata, ra, raTarget)
BYTE                    *pdata;         /* Pointer to fixup location */
RATYPE                  ra;             /* Offset in current segment */
RATYPE                  raTarget;       /* Target offset */
{
#if O68K
    if (f68k)
        return FALSE;
#else
    static RATYPE       raPrev;
    static SATYPE       saPrev;     /* Location of the previous fixup */

    if(raPrev + 4 == ra && saPrev == mpsegsa[vsegCur])
    {
        if(!fOverlays)
            Fatal(ER_badfarcall);           /* A far jump and/or ptr table present */
        else
            return(FALSE);                  /* The user can't turn off /FARC in an overlaid .exe */
    }
    else
    {
        raPrev = ra;
        saPrev = mpsegsa[vsegCur];
    }

    if(lastbyte(pdata,ra,CALLFARDIRECT,NOP))
    {                                   /* If fixing up long call direct */
        *pdata++ = PUSHCS;              /* Push CS */
        *pdata++ = CALLNEARDIRECT;
                                        /* Short call */
        raTarget -= ra + 4;             /* Make offset self-relative */

        fixword(pdata, raTarget);       /* store fixed up value */

        return((FTYPE) TRUE);           /* All done */
    }
    else if(lastbyte(pdata,ra,JUMPFAR,JUMPNEAR))
    {                                   /* If long jump direct */
        raTarget -= ra + 2;             /* Make offset self-relative */

        fixword(pdata, raTarget);       /* store fixed up value */
        pdata += 2;

        *pdata++ = NOP;                 /* Change base to NOPs */
        *pdata = NOP;
        return((FTYPE) TRUE);           /* All done */
    }
    return(FALSE);
#endif /* !O68K */
}


#if EXE386
/*
 *  Fix386:
 *
 *  Procss a fixup for a linear-format exe.
 */
LOCAL void NEAR         Fix386()
{
    REGISTER BYTE       *pdata;         /* Pointer into data record */
    RATYPE              ra;             /* Offset of location being fixed up */
    SNTYPE              gsnTarget;      /* Target segment definition number */
    SNTYPE              gsnFrame;       /* Frame segment definition number */
    SEGTYPE             segTarget;      /* Target segment order number */
    SATYPE              saTarget;       /* Target file segment number */
    SATYPE              saFrame;        /* Frame file segment number */
    RATYPE              raTarget;       /* Target offset */
    RATYPE              vBase;          /* Target virtual base address - FLAT relative */
    long                vDist;          /* Virtual distance between objects */
    RATYPE              raTmp;          /* Temporary */
    WORD                dsa;            /* Difference in sa's */
    DWORD               dummy;
    RELOCATION          r;              /* Relocation item */
    WORD                locType;        /* Type of location to be fixed up */
    WORD                fFlatRelative;  /* TRUE if frame of pseudo group FLAT */
    APROPSNPTR          apropSnSrc;     /* Ptr to a segment record */
    DWORD               srcFlags;        /* Source segment flags */
    APROPNAMEPTR        apropName;      /* Ptr to import */
    DWORD               align;



    if (vgsnCur < gsnMac)
    {
        // Get source flags - only non-debug segments

        apropSnSrc = (APROPSNPTR ) FetchSym(mpgsnrprop[vgsnCur], FALSE);
        srcFlags = apropSnSrc->as_flags;
    }

    // Check for floating-point fixups here

    if(fi.f_mtd == T2 &&
       ((mpextflags[fi.f_idx] & FFPMASK) || (mpextflags[fi.f_idx] & FFP2ND)))
        return;                         /* Ignore f.p. fixups */

    align = (1L << pageAlign) - 1;
    memset(&r, 0, sizeof(struct le_rlc));
    ra = vraCur + fi.f_dri;             /* Get offset of fixup */
    objraCur = ra;
    vpageCur = (ra >> pageAlign) + 1;   /* Set object page number */
    LE_SOFF(r) = (WORD) (ra & align);
    NR_STYPE(r) = (BYTE) fi.f_loc;      /* Save fixup type */
#if FALSE
if (vpageCur == 1 && mpsegsa[vsegCur] == 1)
fprintf(stdout, "Processing fixup: type %02x; source offset %lx (page %x offset %x)\r\n",
                 fi.f_loc, ra, vpageCur, LE_SOFF(r));
#endif
    pdata = &rgmi[fi.f_dri];            /* Set pointer to fixup location */
    locType = (WORD) (fi.f_loc & NRSRCMASK);
                                        /* Get location type */
    Getgsn(fi.f_mtd, fi.f_idx, &gsnTarget, &raTarget);

    // Check if frame of pseudo group FLAT

    if (ggrFlat)
    {
        // FLAT pseudo group defined

        if (fi.f_fmtd == KINDGROUP)
            fFlatRelative = (WORD) (mpgrggr[fi.f_fidx] == ggrFlat);
        else if (fi.f_fmtd == KINDTARGET && fi.f_mtd == KINDGROUP)
            fFlatRelative = (WORD) (mpgrggr[fi.f_idx] == ggrFlat);
        else
            fFlatRelative = FALSE;
    }
    else
        fFlatRelative = FALSE;

    if (fFlatRelative &&
        fi.f_mtd == KINDGROUP &&
        mpgrggr[fi.f_idx] == ggrFlat)
        RelocWarn(ER_badfixflat,objraCur,SNNIL, gsnTarget, raTarget);
                                        // Pseudo group FLAT is an illegal fixup target
    segTarget = mpgsnseg[gsnTarget];    // Get target object
    saTarget = mpsegsa[segTarget];      // Get target object number

    // Check for imports here. Depending on reference kind or place
    // of the reference generate the run-time relocation or treat
    // it as internal reference via thunk.  The following cases
    // generate run-time relocation:
    //
    //      - 16:16 pointer
    //      - 16:16 gate pointer
    //
    // The 0:32 FLAT offset references are threated as internal references
    // and the thunk address for given import is used as target address
    // of fixup. Thunk does indirect jump via entry in Import Address
    // Table which is processed by the loader.

    if (fi.f_mtd == T2 && (mpextflags[fi.f_idx] & FIMPORT))
    {
        // If target is dynamic link

        if (fDebSeg)
        {
            /* Import in $$SYMBOLS */

            if (fi.f_loc == LOCSEGMENT)
            {
                fixword(pdata, 0);      /* Install fake segment selector */
            }
            return;
        }
        else
        {
            // Emit run-time relocation if reference to imported symbol is:
            //
            //      - it is NOT self-relative 32-bit FLAT offset
            //      - it is NOT 32-bit FLAT offset
            //      - there is no thunk allocated for this import (importing DATA)
            //
            // The self-relative 32-bit FLAT offset and 32-bit FLAT offset
            // fixups have their target address redirected to the Thunk Table
            // entry for a given imported symbol and treated as internal fixup.

            apropName = (APROPNAMEPTR) FetchSym(mpextprop[fi.f_idx], TRUE);
            if ((apropName->an_flags & IMPDATA) || (locType != LOCOFFSET32))
            {
                switch (locType)
                {
                    case LOCLOBYTE:     // Lo-byte (8-bit) fixup
                    case LOCSEGMENT:    // Segment (16-bit) fixup
                    case LOCPTR:        // "Pointer" (32-bit) fixup
                    case LOCLOADOFFSET: // Loader-resolved offset fixup
                    case LOCPTR48:      // 48-bit pointer
                    case LOCOFFSET:     // Offset (16-bit) fixup
                        OutError(ER_badfixpure32, 1 + GetPropName(mpextprop[fi.f_idx]));
                        break;

                    case LOCOFFSET32:   // Offset (32-bit) fixup
                        break;
                }

                // Get index to the Import Address Table

                LE_OBJNO(r) = (WORD) (mpsegsa[mpgsnseg[gsnImport]]);
                LE_IDTIDX(r) = (WORD) (apropName->an_module - 1);
                                        // Get Import Module Directory index
                LE_IATORD(r) = (WORD) apropName->an_entry;
                                        // Use FLAT entry
                                        /* If we have an LIDATA record */
                if (TYPEOF(vrectData) == LIDATA)
                    SaveLiRel(&r);      /* Copy relocation into buffer */
                else
                    raTarget = SaveFixup(mpsegsa[vsegCur],vpageCur, &r);
                                        /* Record reference */
                return;                 /* Next fixup item */
            }
        }
    }

    // Internal reference (non-import) or reference to import thunk

    // It is assumed that we're always fixing up relative to the
    // physical segment or group, not the logical segment.  So the
    // offset of the frame segment is not taken into account.

    if (fi.f_fmtd == KINDLOCAT)
    {
        gsnFrame = vgsnCur;
    }

    else if (fi.f_fmtd == KINDTARGET)
    {
        gsnFrame = gsnTarget;
    }

    else
    {
        Getgsn((KINDTYPE) fi.f_fmtd, fi.f_fidx, &gsnFrame, &dummy);
    }

    // The original LINK4 behavior was to fix up relative
    // to the physical segment.  At one point it was changed
    // to subtract the displacement of the target segment (from
    // its physical segment) from the target value, if loc. type =
    // offset and frame and tgt. method = T0.  This was no good
    // and the change was repealed.  The /WARNFIXUP switch warns
    // about fixups which may be affected.

    if (fWarnFixup && fi.f_fmtd == KINDSEG && locType == LOCOFFSET
        && mpsegraFirst[mpgsnseg[gsnFrame]])
        RelocWarn(ER_fixsegd,ra,gsnFrame,gsnTarget,raTarget);
    if (fFlatRelative)
    {
        saFrame = 1;                    // Pseudo-group FLAT has frame of first object
        gsnFrame = 0;
    }
    else
        saFrame = mpsegsa[mpgsnseg[gsnFrame]];
                                        // Get frame's object number
    vBase = virtBase + mpsaBase[saTarget];
                                        // Get TARGET object virtual base address
    if (gsnTarget == SNNIL)             // If no target info
    {
        if (locType == LOCPTR)          // If "pointer" (4 byte) fixup
        {
            lastbyte(pdata,ra,CALLFARDIRECT,BREAKPOINT);
                                        // Replace long call w/ breakpoint
            return;
        }
        if (locType == LOCSEGMENT) return;
                                        // Next fixup if "base" fixup
        if (locType == LOCLOADOFFSET)
            locType = LOCOFFSET;        // Treat as regular offset
    }
    else
    {
        if (fi.f_self)          // If self-relative fixup
        {
            if (saTarget != mpsegsa[vsegCur])
            {
                if (locType == LOCOFFSET)
                    RelocErr(ER_fixinter,ra,gsnFrame,gsnTarget,raTarget);
                                        // 16-bit must be in same segment
                if (fFlatRelative)
                {
                    // If crossing object boundry include in raTarget
                    // virtual distance between objects.
                    //
                    // mpsaBase[mpsegsa[vsegCur]] --> ---+------------------+
                    //                                 ^ |                  |
                    //                                 | |                  |
                    //                                ra | mpsegsa[vsegCur] |
                    //                                 | |                  |
                    //                                 V |                  |
                    //                                ---+------------------+---
                    //                                   |                  | ^
                    //                                   .                  . |
                    //                                   .                  . |
                    //                                   .                  . |
                    //                                   |                  | vDist
                    //                                   +------------------+ |
                    //                                                        |
                    //                                                        V
                    //         masaBase[saTarget] --> ---+------------------+---
                    //                                 ^ |                  |
                    //                                 | |                  |
                    //                          raTarget |    saTarget      |
                    //                                 | |                  |
                    //                                 V |                  |
                    //                                ---+------------------+
                    //                                   |                  |
                    //                                   .                  .
                    //                                   .                  .
                    //                                   .                  .
                    //                                   |                  |
                    //                                   +------------------+
                    //

                    vDist = (long) (mpsaBase[saTarget] - (mpsaBase[mpsegsa[vsegCur]] + ra));
                    raTarget += vDist;
                }
            }
            else
                raTarget -= ra;

            if (locType == LOCOFFSET)
                raTarget -= sizeof(WORD);
            else if (locType == LOCOFFSET32 || locType == LOCLOADOFFSET32)
                raTarget -= sizeof(DWORD);
            else
                raTarget -= sizeof(BYTE);
        }
        else if (saFrame != saTarget && !fFlatRelative)
        {                               /* If frame, target segs differ */
                                        /* and not FLAT frame */
            if (mpgsnseg[gsnFrame] <= segLast || segTarget <= segLast)
            {                           /* If either is non-absolute */
                RelocWarn(ER_fixfrm,ra,gsnFrame,gsnTarget,raTarget);
                saFrame = saTarget;     /* assume target seg */
            }
            else
            {
                RelocWarn(ER_fixfrmab,ra,gsnFrame,gsnTarget,raTarget);
                dsa = (WORD) (saTarget - saFrame);
                raTmp = raTarget + ((dsa & 0xfff) << 4);
                if(dsa >= 0x1000 || raTmp < raTarget)
                {
                    raTarget += fi.f_disp;
#if OMF386
                    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
                        raTarget += getdword(pdata);
                    else
#endif
                        raTarget += getword(pdata);
                    FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
                }
                raTarget = raTmp;
                segTarget = mpgsnseg[gsnFrame];
                                        /* Make target seg that of frame */
                saTarget = mpsegsa[segTarget];
            }                           /* Reset saTarget */
        }
    }
    raTmp = raTarget;
    raTarget += fi.f_disp;
    if (locType >= LOCOFFSET32)
        if (rect & 1)
            raTarget += getdword(pdata);
        else
        {
            RelocWarn(ER_fixtyp,ra,gsnFrame,gsnTarget,raTarget);
            return;
        }
    else
        raTarget += getword(pdata);

    if (saTarget && fFlatRelative && !fi.f_self)
        raTarget += vBase;

    LE_FIXDAT(r) = raTarget;
    if (saTarget && fFlatRelative && !fDebSeg)
    {
         // The FLAT-relative offset fixups need to be propagated into
         // the .EXE file in the following cases:
         //
         //     - for .EXE's  - by user request
         //     - for .DLL's  - only FLAT-relative offset fixups

        if ((fKeepFixups || !IsAPLIPROG(vFlags)) &&
            (locType == LOCOFFSET32 || locType == LOCLOADOFFSET32))
        {
            if (!fi.f_self)
            {
                FinishRlc(&r, saTarget, raTarget - vBase);
                                        /* Don't pass virtual offsets */
            }
#if FALSE
        // Self-relative offset fixups crossing memory object
        // boudry are not longer propagated to the exe for PE images

            else if ((mpsegsa[vsegCur] != saTarget) && fKeepFixups)
            {
                FinishRlc(&r, saTarget, raTarget - vDist + sizeof(DWORD));
                                        /* Don't pass virtual offsets */
            }
#endif
        }
        else if (locType == LOCOFFSET)
        {
            if (!fi.f_self)
                RelocWarn(ER_badfix16off,ra,gsnFrame,gsnTarget,raTarget);
            else if (raTarget > LXIVK)
                FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
                                   /* For 16:16 alias raTarget must be <= 64k */
        }
    }

    switch(locType)                     /* Switch on fixup type */
    {
        case LOCLOBYTE:                 /* 8-bit "lobyte" fixup */
          raTarget = raTmp + B2W(pdata[0]) + fi.f_disp;
          pdata[0] = (BYTE) raTarget;
          if (raTarget >= 0x100 && fi.f_self)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCHIBYTE:                 /* 8-bit "hibyte" fixup */
          raTarget = raTmp + fi.f_disp;
          pdata[0] = (BYTE) (B2W(pdata[0]) + (raTarget >> 8));
          break;

        case LOCLOADOFFSET:             /* Loader-resolved offset fixup */
        case LOCOFFSET:                 /* 16-bit "offset" fixup */
          fixword(pdata, raTarget);
          break;

        case LOCLOADOFFSET32:           /* 32-bit "offset" fixup */
        case LOCOFFSET32:               /* 32-bit "offset" fixup */

          fixword(pdata, raTarget);     /* Perform low word fixup */
          pdata += 2;
          raTarget >>= 16;              /* Get high word */

          fixword(pdata, raTarget);     /* Perform fixup */
          break;

        case LOCSEGMENT:                /* 16-bit "base" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {
              if (fDebSeg)
              {
                // For debug segments use logical segment number (seg)
                // instead of physical segment number (sa)

                saTarget = segTarget;
              }
              else
                saTarget += getword(pdata);
                                        /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCPTR48:                  /* 48-bit "pointer" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {

              fixword(pdata, raTarget); /* Store offset portion */
              pdata += 2;
              raTarget >>= WORDLN;      /* Get high word */

              fixword(pdata, raTarget); /* Store offset portion */
              pdata += 2;

              if (fDebSeg)
              {
                // For debug segments use logical segment number (seg)
                // instead of physical segment number (sa)

                saTarget = segTarget;
              }
              else
                saTarget += getword(pdata); /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCPTR:                    /* 32-bit "pointer" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {
              fixword(pdata, raTarget); /* Store offset portion */
              pdata += 2;

              saTarget += getword(pdata);
                                        /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          if (fFlatRelative)
              RelocWarn(ER_badfix16ptr, ra, gsnFrame, gsnTarget, raTarget);
          else
              RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;

        default:                        /* Unsupported fixup type */
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;
    }
}
#endif /* EXE386 */



#if OSEGEXE AND NOT EXE386
/*
 *  FixNew:
 *
 *  Procss a fixup for a new-format exe.
 */
void NEAR               FixNew ()
{
    REGISTER BYTE       *pdata;         /* Pointer into data record */
    RATYPE              ra;             /* Offset of location being fixed up */
    SNTYPE              gsnTarget;      /* Target segment definition number */
    SNTYPE              gsnFrame;       /* Frame segment definition number */
    SEGTYPE             segTarget;      /* Target segment order number */
    SATYPE              saTarget;       /* Target file segment number */
    SEGTYPE             segFrame;       /* Frame segment order number */
    SATYPE              saFrame;        /* Frame file segment number */
    RATYPE              raTarget;       /* Target offset */
    RATYPE              raTmp;          /* Temporary */
    WORD                dsa;            /* Difference in sa's */
    RATYPE              dummy;
    RELOCATION          r;              /* Relocation item */


    memset(&r, 0, sizeof(RELOCATION));
    ra = vraCur + (RATYPE) fi.f_dri;    /* Get offset of fixup */

    /* Save location in record */

    NR_SOFF(r) = (WORD) ra;

    NR_STYPE(r) = (BYTE) fi.f_loc;      /* Save fixup type */
    NR_FLAGS(r) = (BYTE) (fi.f_add? NRADD: 0);

    if(fi.f_mtd == T2 && (mpextflags[fi.f_idx] & FFPMASK)
#if ILINK
       && !fQCIncremental               // For real-mode incremental
                                        // floating-point fixups are
                                        // treated as normal symbol fixups
#endif
      )
    {                                   /* If floating-point fixup */
        if (vFlags & NEPROT && TargetOs == NE_OS2)
            return;                     /* If protected mode only, ignore */
        NR_FLAGS(r) = NRROSF | NRADD;
        NR_STYPE(r) = LOCLOADOFFSET;/* No 3-byte type, so we lie */
        NR_OSTYPE(r) = (mpextflags[fi.f_idx] >> FFPSHIFT) & 7;
                                    /* Type # = ordinal in table */
        NR_OSRES(r) = 0;            /* Clear reserved word */
        SaveFixup(mpsegsa[vsegCur],&r);
        return;
    }
    if(fi.f_mtd == T2 && (mpextflags[fi.f_idx] & FFP2ND))
        return;                         /* Ignore secondary f.p. fixups */

    pdata = &rgmi[fi.f_dri];            /* Set pointer to fixup location */
    /*
     * Check for imports here.
     */
    if(fi.f_mtd == T2 && (mpextflags[fi.f_idx] & FIMPORT))
    {                                   /* If target is dynamic link */
        if (fDebSeg)
        {
            /* Import in $$SYMBOLS */

            if (fi.f_loc == LOCSEGMENT)
            {
                fixword(pdata, 0);      /* Install fake segment selector */
            }
            return;
        }
        /*
         * Check for invalid import fixup types:  self-rel, HIBYTE.
         */
        if(fi.f_self)
        {
            RelocErr(ER_fixinter,ra,SNNIL,SNNIL,0L);
            return;
        }
        else if(fi.f_loc == LOCHIBYTE)
        {
            RelocErr(ER_fixbad,ra,SNNIL,SNNIL,0L);
            return;
        }
        else if(fi.f_loc == LOCOFFSET)/* Convert offset to runtime offset */
            NR_STYPE(r) = LOCLOADOFFSET;
        NR_FLAGS(r) |= (mpextflags[fi.f_idx] & FIMPORD)? NRRORD: NRRNAM;
                                        /* Set flag */
        if(fi.f_disp || fi.f_loc == LOCLOBYTE) NR_FLAGS(r) |= NRADD;
                                        /* Additive if non-zero displacement
                                           or lobyte */
#if M_BYTESWAP
        NR_SEGNO(r) = (BYTE) mpextgsn[fi.f_idx];
        NR_RES(r) = (BYTE)(mpextgsn[fi.f_idx] >> BYTELN);
#else
        NR_MOD(r) = mpextgsn[fi.f_idx];
#endif
                                        /* Get module specification */
        NR_PROC(r) = (WORD) mpextra[fi.f_idx];
                                        /* Get entry specification */
        if(TYPEOF(vrectData) == LIDATA) /* If we have an LIDATA record */
        {
            SaveLiRel(&r);              /* Copy relocation into buffer */
            raTarget = 0;               /* Not chained yet */
        }
        else raTarget = SaveFixup(mpsegsa[vsegCur],&r);
                                        /* Record reference */
        if(NR_FLAGS(r) & NRADD) raTarget = fi.f_disp;
                                        /* If additive, install displacement */
        if(fi.f_loc == LOCLOBYTE)
        {
            *pdata++ += (BYTE)(raTarget & 0xFF);
        }
#if O68K
        else if (fTBigEndian)
        {
            *pdata++ += (BYTE)((raTarget >> BYTELN) & 0xFF);
            *pdata += (BYTE)(raTarget & 0xFF);
        }
#endif /* O68K */
        else
        {
            addword((BYTE *)pdata, (WORD)raTarget);
        }
        return;                         /* Next fixup item */
    }
    NR_FLAGS(r) |= NRRINT;              /* Internal reference (non-import) */
    Getgsn(fi.f_mtd, fi.f_idx, &gsnTarget, &raTarget);

    /*
     * It is assumed that we're always fixing up relative to the
     * physical segment or group, not the logical segment.  So the
     * offset of the frame segment is not taken into account.
     */

    if (fi.f_fmtd == KINDLOCAT)
    {
        gsnFrame = vgsnCur;
    }

    else if (fi.f_fmtd == KINDTARGET)
    {
        gsnFrame = gsnTarget;
    }

    else
    {
        Getgsn(fi.f_fmtd, fi.f_fidx, &gsnFrame, &dummy);
    }

    segTarget = mpgsnseg[gsnTarget];    /* Get target segment */
    saTarget = mpsegsa[segTarget];      /* Get target file segment number */
    segFrame = mpgsnseg[gsnFrame];      /* Get frame segment */
    saFrame = mpsegsa[segFrame];        /* Get frame's file segment number */

    /*
     * The original LINK4 behavior was to fix up relative
     * to the physical segment.  At one point it was changed
     * to subtract the displacement of the target segment (from
     * its physical segment) from the target value, if loc. type =
     * offset and frame and tgt. method = T0.  This was no good
     * and the change was repealed.  The /WARNFIXUP switch warns
     * about fixups which may be affected.
     */
    if(fWarnFixup && fi.f_fmtd == KINDSEG && fi.f_loc == LOCOFFSET
       && mpsegraFirst[segFrame])
        RelocWarn(ER_fixsegd,ra,gsnFrame,gsnTarget,raTarget);

#if O68K
    /* 68k code does not permit segment fixups of any kind. */
    if (f68k && !fDebSeg && ((1 << fi.f_loc) & ((1 << LOCSEGMENT) |
      (1 << LOCPTR) | (1 << LOCPTR48))) != 0)
    {
        RelocErr(ER_fixbad, ra, gsnFrame, gsnTarget, raTarget + fi.f_disp);
        return;
    }
#endif /* O68K */

    if(gsnTarget == SNNIL)              /* If no target info */
    {
        if(fi.f_loc == LOCPTR)  /* If "pointer" (4 byte) fixup */
        {
            lastbyte(pdata,ra,CALLFARDIRECT,BREAKPOINT);
                                        /* Replace long call w/ breakpoint */
            return;
        }
        if(fi.f_loc == LOCSEGMENT) return;
                                        /* Next fixup if "base" fixup */
        if(fi.f_loc == LOCLOADOFFSET)
            fi.f_loc = LOCOFFSET;       /* Treat as regular offset */
    }
    else
    {
        if(fi.f_self)           /* If self-relative fixup */
        {
#if O68K
            if (iMacType != MAC_NONE)
            {
                switch (fi.f_loc)
                {
                case LOCOFFSET:
                    if (saTarget != mpsegsa[vsegCur])
                    {
                        NR_STYPE(r) = (BYTE)((NR_STYPE(r) & ~NRSTYP) | NRSOFF);
                        fi.f_loc = LOCLOADOFFSET;
                    }
                    else raTarget -= ra;
                    break;

                case LOCOFFSET32:
                    if (saTarget != mpsegsa[vsegCur])
                        fi.f_loc = LOCLOADOFFSET32;
                    else raTarget -= ra - 2;
                    break;
                }
            }
            else
#endif /* O68K */
            {
                if (saTarget != mpsegsa[vsegCur])
                    RelocErr(ER_fixinter,ra,gsnFrame,gsnTarget,raTarget);
                                        /* Must be in same segment */
                if(fi.f_loc == LOCOFFSET)
                  raTarget = raTarget - ra - 2;
#if OMF386
                else if(fi.f_loc == LOCOFFSET32)
                  raTarget = raTarget - ra - 4;
#endif
                else raTarget = raTarget - ra - 1;
            }
        }
        else if (saFrame != saTarget)
        {                               /* If frame, target segs differ */
            if (segFrame <= segLast || segTarget <= segLast)
            {                           /* If either is non-absolute */
                RelocWarn(ER_fixfrm, ra, gsnFrame, gsnTarget, raTarget);
            }
            else
            {
                RelocWarn(ER_fixfrmab,ra,gsnFrame,gsnTarget,raTarget);
                dsa = saTarget - saFrame;
                raTmp = raTarget + ((dsa & 0xfff) << 4);
                if(dsa >= 0x1000 || raTmp < raTarget)
                {
                    raTarget += fi.f_disp;
#if OMF386
                    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
                        raTarget += GetFixupDword(pdata);
                    else
#endif
                        raTarget += GetFixupWord(pdata);
                    FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
                }

                raTarget = raTmp;
            }

            segTarget = segFrame;       /* Make target seg that of frame */
            saTarget = saFrame;         /* Reset saTarget */
        }
    }

    raTmp = raTarget;
    raTarget += fi.f_disp;

#if OMF386
    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
        raTarget += GetFixupDword(pdata);
    else
#endif
        raTarget += GetFixupWord(pdata);

    switch(fi.f_loc)                    /* Switch on fixup type */
    {
        case LOCLOBYTE:                 /* 8-bit "lobyte" fixup */
          raTarget = raTmp + B2W(pdata[0]) + fi.f_disp;
          pdata[0] = (BYTE) raTarget;
          if(raTarget >= 0x100 && fi.f_self)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCHIBYTE:                 /* 8-bit "hibyte" fixup */
          raTarget = raTmp + fi.f_disp;
          pdata[0] = (BYTE) (B2W(pdata[0]) + (raTarget >> 8));
          break;

        case LOCLOADOFFSET:             /* Loader-resolved offset fixup */
          NR_FLAGS(r) &= ~NRADD;        /* Not additive */
          if ((TargetOs == NE_WINDOWS && !(vFlags & NEPROT))
#if O68K
            || iMacType != MAC_NONE
#endif /* O68K */
            )
             raTarget = FinishRlc(&r, saTarget, raTarget);
                                        /* Finish relocation record */
#if O68K
          if (fTBigEndian)
          {
            *pdata++ = (BYTE)((raTarget >> BYTELN) & 0xFF);
            *pdata = (BYTE)(raTarget & 0xFF);
          }
          else
#endif /* O68K */
          {
            fixword(pdata, raTarget);
          }
                                        /* Install old head of chain */
          break;

        case LOCOFFSET:                 /* 16-bit "offset" fixup */
#if O68K
          /* For 68K, LOCOFFSET is a signed 16-bit offset fixup. */
          if (f68k &&
            (raTarget & ~0x7FFF) != 0 && (raTarget & ~0x7FFF) != ~0x7FFF)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
#endif /* O68K */
#if O68K
          if (fTBigEndian)
          {
            *pdata++ = (BYTE)((raTarget >> BYTELN) & 0xFF);
            *pdata = (BYTE)(raTarget & 0xFF);
          }
          else
#endif /* O68K */
          {
            fixword(pdata, raTarget);
          }
                                        /* Install old head of chain */
          break;

#if OMF386
        case LOCLOADOFFSET32:           /* 32-bit "offset" fixup */
          if(!(rect & 1)) break;        /* Not 386 extension */
          NR_FLAGS(r) &= ~NRADD;        /* Not additive */
          NR_STYPE(r) = (BYTE) ((NR_STYPE(r) & ~NRSTYP) | NROFF32);
          raTarget = FinishRlc(&r,saTarget,raTarget);
                                        /* Finish relocation record */
        case LOCOFFSET32:               /* 32-bit "offset" fixup */
#if O68K
          if (fTBigEndian)
          {
            *pdata++ = (BYTE)((raTarget >> (BYTELN + WORDLN)) & 0xFF);
            *pdata++ = (BYTE)((raTarget >> WORDLN) & 0xFF);
            *pdata++ = (BYTE)((raTarget >> BYTELN) & 0xFF);
            *pdata = (BYTE)(raTarget & 0xFF);
          }
          else
#endif /* O68K */
          {
            fixdword(pdata, raTarget);
          }
                                        /* Perform fixup */
          break;
#endif /* OMF386 */

        case LOCSEGMENT:                /* 16-bit "base" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {
              if (fDebSeg)
              {
                // For debug segments use logical segment number (seg)
                // instead of physical segment number (sa)

                saTarget = segTarget;
              }
              else
                saTarget += getword(pdata);
                                        /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          /*
           * Treat the displacment as an ordinal increment to saTarget,
           * for huge model. It would seem logical to include the primary
           * displacment, f_disp, but MASM has a quirk:  an instruction of
           * the form "mov ax,ASEGMENT" generates a fixup with f_disp equal
           * to the length of the segment even though "mov ax,seg
           * ASEGMENT" causes f_disp to be 0!  So for compatibility we
           * ignore f_disp.
           * Then force the fixup to non-additive since the secondary
           * displacement has been added to saTarget.
           */
          if((saTarget += getword(pdata)) >= saMac)
              FixupOverflow(ra,gsnFrame,gsnTarget,0L);
          NR_FLAGS(r) &= ~NRADD;
#if FALSE
          /*
           *  Too early to decide here. We don't know if a
           *  base fixup will require call-gate and if it
           *  does then we need the actual offset in call-gate.
           *
           *  Forcing the offset to zero for base fixups:
           *  PRO's
           *  1. Fewer fixup records in the .EXE.
           *  2. No more than n dummy entries in the
           *     Entry Table for a program of n segments
           *     in the WORST case.
           *  CON's
           *  1. Approximately n dummy entries in the
           *     Entry Table for a program of n segments
           *     in the AVERAGE case.
           */
          raTarget = FinishRlc(&r,saTarget,0L);
                                        /* Finish relocation record */
#else
          /*
           *  Leaving the offset alone for base fixups:
           *  PRO's
           *  1. No more than 1 or 2 dummy entries in the
           *     Entry Table for a program of n segments
           *     in the AVERAGE case.
           *  CON's
           *  1. More fixup records in the .EXE.
           *  2. Number of dummy entries in the Entry Table
           *     only bounded by the maximum allowable size
           *     of the Entry Table in the WORST CASE.
           */
          raTarget = FinishRlc(&r,saTarget,raTarget);
                                        /* Finish relocation record */
#endif
          fixword(pdata, raTarget);
                                        /* Install old head of chain */
          break;

#if OMF386
        case LOCPTR48:                  /* 48-bit "pointer" fixup */
          if(!(rect & 1)) break;        /* Not 386 extension */
          NR_STYPE(r) = (BYTE) ((NR_STYPE(r) & ~NRSTYP) | NRPTR48);
          fixword(pdata, raTarget);
          pdata += 2;
          raTarget >>= 16;              /* Get high word, fall through ... */
#endif

        case LOCPTR:                    /* 32-bit "pointer" fixup */
#if SYMDEB
          if(segTarget > segLast || fDebSeg)
#else
          if(segTarget > segLast)       /* If target segment absolute */
#endif
          {
              fixword(pdata, raTarget);
              pdata += 2;
                                        /* Store offset portion */
              if (fDebSeg)
              {
                // For debug segments use logical segment number (seg)
                // instead of physical segment number (sa)

                saTarget = segTarget;
              }
              else
                saTarget += getword(pdata);
                                        /* Calculate base address */

              fixword(pdata, saTarget); /* Store base address */
              break;                    /* Done */
          }
          if(fFarCallTrans && saTarget == mpsegsa[vsegCur]
            && (mpsaflags[saTarget] & NSTYPE) == NSCODE)
          {                             /* If intrasegment fixup */
              if(TransFAR(pdata,ra,raTarget))
                  break;
          }
          /*
           * Treat the high word at the location as an increment to the
           * target segment index.  Check for overflow and clear the high
           * word at the location.  Force fixup to be non-additive because
           * the secondary displacement has already been added to raTarget.
           */
          if((saTarget += getword(pdata + 2)) >= saMac)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
          pdata[2] = pdata[3] = 0;
          NR_FLAGS(r) &= ~NRADD;
#if NOT QCLINK
          if (fOptimizeFixups)
          {
              // Check if pointer fixup (16:16 or 16:32) can be split into
              // linker resolved offset fixup (16 or 32 bit) and loader
              // resolved base (selector) fixup.

              if (!CallGateRequired(saTarget))
              {
                  fixword(pdata, raTarget);     /* Store offset portion */
                  pdata += 2;

                  NR_STYPE(r) = (BYTE) LOCSEGMENT;
                  if (fi.f_loc == LOCPTR48)
                      NR_SOFF(r) += 4;
                  else
                      NR_SOFF(r) += 2;

                  raTarget = 0L;
              }

          }
#endif
          raTarget = FinishRlc(&r,saTarget,raTarget);
                                    /* Finish relocation record */
          fixword(pdata, raTarget);
                                    /* Install old head of chain */
          break;

        default:                        /* Unsupported fixup type */
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;
    }
}


#ifdef  LEGO

/*
 *  FixNewKeep:
 *
 *  Process a fixup for a new-format exe.
 */

void NEAR FixNewKeep()
{
    BYTE                *pdata;         /* Pointer into data record */
    RATYPE              ra;             /* Offset of location being fixed up */
    SNTYPE              gsnTarget;      /* Target segment definition number */
    SNTYPE              gsnFrame;       /* Frame segment definition number */
    SEGTYPE             segTarget;      /* Target segment order number */
    SATYPE              saTarget;       /* Target file segment number */
    SEGTYPE             segFrame;       /* Frame segment order number */
    SATYPE              saFrame;        /* Frame file segment number */
    RATYPE              raTarget;       /* Target offset */
    RATYPE              raTmp;          /* Temporary */
    WORD                dsa;            /* Difference in sa's */
    RATYPE              dummy;
    RELOCATION          r;              /* Relocation item */

    memset(&r, 0, sizeof(RELOCATION));
    ra = vraCur + (RATYPE) fi.f_dri;    /* Get offset of fixup */

    /* Save location in record */

    NR_SOFF(r) = (WORD) ra;

    NR_STYPE(r) = (BYTE) fi.f_loc;      /* Save fixup type */
    NR_FLAGS(r) = (BYTE) (fi.f_add ? NRADD : 0);

    pdata = &rgmi[fi.f_dri];            /* Set pointer to fixup location */

    if (fi.f_mtd == T2)
    {
        /* The target is an external symbol */

        if (mpextflags[fi.f_idx] & FFPMASK)
        {
            /* This is a floating point fixup */

            if (TargetOs == NE_OS2)
            {
                /* Floating point fixups are ignored in prot mode OS/2 */

                return;
            }

            /* Emit an OS fixup.  The loader will deal with these. */

            NR_STYPE(r) = LOCLOADOFFSET;
            NR_FLAGS(r) = NRROSF | NRADD;
            NR_OSTYPE(r) = (mpextflags[fi.f_idx] >> FFPSHIFT) & 7;
            NR_OSRES(r) = 0;

            SaveFixup(mpsegsa[vsegCur], &r);
            return;
        }

        if (mpextflags[fi.f_idx] & FFP2ND)
        {
            /* This is a secondary floating point fixup. */
            /* These are always ignored. */

            return;
        }

        /*
         * Check for imports here.
         */

        if (mpextflags[fi.f_idx] & FIMPORT)
        {                               /* If target is dynamic link */
            if (fDebSeg)
            {
                /* Import in $$SYMBOLS */

                if (fi.f_loc == LOCSEGMENT)
                {
                    *pdata++ = 0;       /* Install fake segment selector */
                    *pdata++ = 0;
                }
                return;
            }

            /*
             * Check for invalid import fixup types:  self-rel, HIBYTE.
             */

            if (fi.f_self)
            {
                RelocErr(ER_fixinter, ra, SNNIL, SNNIL, 0L);
                return;
            }

            if (fi.f_loc == LOCHIBYTE)
            {
                RelocErr(ER_fixbad, ra, SNNIL, SNNIL, 0L);
                return;
            }

            /* Convert offset to runtime offset */

            if (fi.f_loc == LOCOFFSET)
                NR_STYPE(r) = LOCLOADOFFSET;

            NR_FLAGS(r) |= (mpextflags[fi.f_idx] & FIMPORD) ? NRRORD : NRRNAM;

            if (fi.f_disp || fi.f_loc == LOCLOBYTE)
                NR_FLAGS(r) |= NRADD;   /* Additive if non-zero displacement
                                           or lobyte */

#if     M_BYTESWAP
            NR_SEGNO(r) = (BYTE) mpextgsn[fi.f_idx];
            NR_RES(r) = (BYTE)(mpextgsn[fi.f_idx] >> BYTELN);
#else
            NR_MOD(r) = mpextgsn[fi.f_idx];
#endif
                                        /* Get module specification */
            NR_PROC(r) = (WORD) mpextra[fi.f_idx];
                                        /* Get entry specification */

            if (TYPEOF(vrectData) == LIDATA)/* If we have an LIDATA record */
            {
                SaveLiRel(&r);          /* Copy relocation into buffer */
                raTarget = 0;           /* Not chained yet */
            }
            else
            {
                raTarget = SaveFixup(mpsegsa[vsegCur], &r);
            }
                                        /* Record reference */

            if (NR_FLAGS(r) & NRADD)    /* If additive, install displacement */
                raTarget = fi.f_disp;

            if (fi.f_loc == LOCLOBYTE)
            {
                *pdata++ += (BYTE)(raTarget & 0xFF);
            }
            else
            {
                addword((BYTE *)pdata, (WORD)raTarget);
            }

            return;                     /* Next fixup item */
        }
    }

    NR_FLAGS(r) |= NRRINT;              /* Internal reference (non-import) */
    Getgsn(fi.f_mtd, fi.f_idx, &gsnTarget, &raTarget);

    /*
     * It is assumed that we're always fixing up relative to the
     * physical segment or group, not the logical segment.  So the
     * offset of the frame segment is not taken into account.
     */

    if (fi.f_fmtd == KINDLOCAT)
    {
        gsnFrame = vgsnCur;
    }

    else if (fi.f_fmtd == KINDTARGET)
    {
        gsnFrame = gsnTarget;
    }

    else
    {
        Getgsn(fi.f_fmtd, fi.f_fidx, &gsnFrame, &dummy);
    }

    segTarget = mpgsnseg[gsnTarget];    /* Get target segment */
    saTarget = mpsegsa[segTarget];      /* Get target file segment number */
    segFrame = mpgsnseg[gsnFrame];      /* Get frame segment */
    saFrame = mpsegsa[segFrame];        /* Get frame's file segment number */

    /*
     * The original LINK4 behavior was to fix up relative
     * to the physical segment.  At one point it was changed
     * to subtract the displacement of the target segment (from
     * its physical segment) from the target value, if loc. type =
     * offset and frame and tgt. method = T0.  This was no good
     * and the change was repealed.  The /WARNFIXUP switch warns
     * about fixups which may be affected.
     */

    if (fWarnFixup &&
        (fi.f_fmtd == KINDSEG) &&
        (fi.f_loc == LOCOFFSET) &&
        mpsegraFirst[segFrame])
        RelocWarn(ER_fixsegd, ra, gsnFrame, gsnTarget, raTarget);

    if (gsnTarget == SNNIL)             /* If no target info */
    {
        if (fi.f_loc == LOCPTR) /* If "pointer" (4 byte) fixup */
        {
            lastbyte(pdata, ra, CALLFARDIRECT, BREAKPOINT);
                                        /* Replace long call w/ breakpoint */
            return;
        }

        if (fi.f_loc == LOCSEGMENT)     /* Next fixup if "base" fixup */
            return;

        if (fi.f_loc == LOCLOADOFFSET)
            fi.f_loc = LOCOFFSET;       /* Treat as regular offset */
    }
    else
    {
        if (fi.f_self)          /* If self-relative fixup */
        {
            if (saTarget != mpsegsa[vsegCur])
            {
                RelocErr(ER_fixinter, ra, gsnFrame, gsnTarget, raTarget);
                return;
            }

            /* Must be in same segment */

            if (fi.f_loc == LOCOFFSET)
                raTarget -= ra + sizeof(WORD);
#if     OMF386
            else if (fi.f_loc == LOCOFFSET32)
                raTarget -= ra + sizeof(DWORD);
#endif  /* OMF386 */
            else
                raTarget -= ra + sizeof(BYTE);
        }

        else if (saFrame != saTarget)
        {
            /* If frame, target segs differ */

            if (segFrame <= segLast || segTarget <= segLast)
            {
                /* If either is non-absolute */

                RelocWarn(ER_fixfrm, ra, gsnFrame, gsnTarget, raTarget);
            }

            else
            {
                RelocWarn(ER_fixfrmab, ra, gsnFrame, gsnTarget, raTarget);
                dsa = saTarget - saFrame;
                raTmp = raTarget + ((dsa & 0xfff) << 4);

                if (dsa >= 0x1000 || raTmp < raTarget)
                {
                    raTarget += fi.f_disp;
#if     OMF386
                    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
                        raTarget += GetFixupDword(pdata);
                    else
#endif  /* OMF386 */
                        raTarget += GetFixupWord(pdata);

                    FixupOverflow(ra, gsnFrame, gsnTarget, raTarget);
                }

                raTarget = raTmp;
            }

            segTarget = segFrame;       /* Make target seg that of frame */
            saTarget = saFrame;         /* Reset saTarget */
        }
    }

    raTmp = raTarget;
    raTarget += fi.f_disp;

    if (fDebSeg || fi.f_self)
    {
        /* If fKeepFixups is TRUE, the value stored at the fixed up */
        /* location is not added to the target address.  The fixup will */
        /* be emitted as an additive fixup and the loader will add in */
        /* the bias.

        /* If the fixup is being applied to a debug segment, the offset is */
        /* added because these fixups aren't handled by the loader.  In */
        /* other words, they can not be kept. */

        /* If the fixup is being applied is self-relative, the offset is */
        /* added because the loaded doesn't handle self-relative fixups. */
        /* While the fixed up word would have the correct value, the target */
        /* of the fixup would be artifical. */

#if     OMF386
        if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
            raTarget += GetFixupDword(pdata);
        else
#endif  /* OMF386 */
            raTarget += GetFixupWord(pdata);
    }

    switch (fi.f_loc)           /* Switch on fixup type */
    {
        case LOCLOBYTE:                 /* 8-bit "lobyte" fixup */
            raTarget = raTmp + B2W(pdata[0]) + fi.f_disp;
            pdata[0] = (BYTE) raTarget;

            if (raTarget >= 0x100 && fi.f_self)
                FixupOverflow(ra, gsnFrame, gsnTarget, raTarget);
            break;

        case LOCHIBYTE:                 /* 8-bit "hibyte" fixup */
            raTarget = raTmp + fi.f_disp;
            pdata[0] = (BYTE) (B2W(pdata[0]) + (raTarget >> 8));
            break;

        case LOCLOADOFFSET:             /* Loader-resolved offset fixup */
            /* There are no LOCLOADOFFSET fixups that are */
            /* self-relative or applied to debug segments. */

            /* Force non-external fixups to be additive. The C */
            /* compiler may emit a BAKPAT to a fixed up word. If the */
            /* fixup is chained the BAKPAT will corrupt the chain. */
            /* This does not occur when the target is external. We */
            /* special case this so that the number of fixups is */
            /* reduced. */

            if (fi.f_mtd != T2)
                NR_FLAGS(r) |= NRADD;

            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixword(pdata, raTarget);
            break;

        case LOCOFFSET:                 /* 16-bit "offset" fixup */
            if (!fDebSeg && !fi.f_self)
            {
                /* Force non-external fixups to be additive. The C */
                /* compiler may emit a BAKPAT to a fixed up word. If the */
                /* fixup is chained the BAKPAT will corrupt the chain. */
                /* This does not occur when the target is external. We */
                /* special case this so that the number of fixups is */
                /* reduced. */

                if (fi.f_mtd != T2)
                    NR_FLAGS(r) |= NRADD;

                NR_STYPE(r) = LOCLOADOFFSET;
                raTarget = FinishRlc(&r, saTarget, raTarget);

                if (NR_FLAGS(r) & NRADD)
                    break;
            }

            fixword(pdata, raTarget);
            break;

        case LOCSEGMENT:                /* 16-bit "base" fixup */
#if SYMDEB
            if (segTarget > segLast || fDebSeg)
#else
            if (segTarget > segLast)      /* If target segment absolute */
#endif
            {
                if (fDebSeg)
                {
                    // For debug segments use logical segment number (seg)
                    // instead of physical segment number (sa)

                    saTarget = segTarget;
                }
                else
                {
                    saTarget += getword(pdata);
                }

                /* Store base address */

                fixword(pdata, saTarget);
                break;
            }

            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixword(pdata, raTarget);
            break;

        case LOCPTR:                    /* 32-bit "pointer" fixup */
#if SYMDEB
            if (segTarget > segLast || fDebSeg)
#else
            if (segTarget > segLast)      /* If target segment absolute */
#endif
            {
                /* Store offset portion */

                fixword(pdata, raTarget);
                pdata += 2;

                if (fDebSeg)
                {
                    // For debug segments use logical segment number (seg)
                    // instead of physical segment number (sa)

                    saTarget = segTarget;
                }
                else
                {
                    saTarget += getword(pdata);
                }

                /* Store base address */

                fixword(pdata, saTarget);
                break;
            }

            /* Force non-external fixups to be additive. The C */
            /* compiler may emit a BAKPAT to a fixed up word. If the */
            /* fixup is chained the BAKPAT will corrupt the chain. */
            /* This does not occur when the target is external. We */
            /* special case this so that the number of fixups is */
            /* reduced. */

            if (fi.f_mtd != T2)
                NR_FLAGS(r) |= NRADD;

            /* Check segment to see if fixup must be additive */

            else if (getword(pdata + 2) != 0)
                NR_FLAGS(r) |= NRADD;

            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixword(pdata, raTarget);
            break;

#if     OMF386
        /* NOTE: Support for 32 bit fixups in 16 bit images is a joke. */
        /* NOTE: The Windows loader doesn't understand these.  We fake */
        /* NOTE: out Windows by converting these fixups to NRSOFF type. */

        /* NOTE: The Chicago loader now understands NROFF32 fixups so */
        /* NOTE: we now use this type.  This will generate an executable */
        /* NOTE: that doesn't work under Windows 3.x.  Oh Well! */

        case LOCLOADOFFSET32:           /* 32-bit Loader-resolved offset fixup */
            /* There are no LOCLOADOFFSET32 fixups that are */
            /* self-relative or applied to debug segments. */

            /* Force non-external fixups to be additive. The C */
            /* compiler may emit a BAKPAT to a fixed up word. If the */
            /* fixup is chained the BAKPAT will corrupt the chain. */
            /* This does not occur when the target is external. We */
            /* special case this so that the number of fixups is */
            /* reduced. */

            if (fi.f_mtd != T2)
                NR_FLAGS(r) |= NRADD;

            if (raTarget > 0xffff)
                RelocErr(ER_fixbad, ra, gsnFrame, gsnTarget, raTarget);

            NR_STYPE(r) = NROFF32;
            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixdword(pdata, raTarget);
            break;

        case LOCOFFSET32:               /* 32-bit "offset" fixup */
            if (!fDebSeg && !fi.f_self)
            {
                /* Force non-external fixups to be additive. The C */
                /* compiler may emit a BAKPAT to a fixed up word. If the */
                /* fixup is chained the BAKPAT will corrupt the chain. */
                /* This does not occur when the target is external. We */
                /* special case this so that the number of fixups is */
                /* reduced. */

                if (fi.f_mtd != T2)
                    NR_FLAGS(r) |= NRADD;

                if (raTarget > 0xffff)
                    RelocErr(ER_fixbad, ra, gsnFrame, gsnTarget, raTarget);

                NR_STYPE(r) = NROFF32;
                raTarget = FinishRlc(&r, saTarget, raTarget);

                if (NR_FLAGS(r) & NRADD)
                    break;
            }

            fixdword(pdata, raTarget);
            break;

        case LOCPTR48:                  /* 48-bit "pointer" fixup */
#if SYMDEB
            if (segTarget > segLast || fDebSeg)
#else
            if (segTarget > segLast)      /* If target segment absolute */
#endif
            {
                /* Store offset portion */

                fixdword(pdata, raTarget);
                pdata += 4;

                if (fDebSeg)
                {
                    // For debug segments use logical segment number (seg)
                    // instead of physical segment number (sa)

                    saTarget = segTarget;
                }
                else
                {
                    saTarget += getword(pdata);
                }

                /* Store base address */

                fixword(pdata, saTarget);
                break;
            }

            /* Force non-external fixups to be additive. The C */
            /* compiler may emit a BAKPAT to a fixed up word. If the */
            /* fixup is chained the BAKPAT will corrupt the chain. */
            /* This does not occur when the target is external. We */
            /* special case this so that the number of fixups is */
            /* reduced. */

            if (fi.f_mtd != T2)
                NR_FLAGS(r) |= NRADD;

            /* Check segment to see if fixup must be additive */

            else if (getword(pdata + 4) != 0)
                NR_FLAGS(r) |= NRADD;

            NR_STYPE(r) = NRPTR48;
            raTarget = FinishRlc(&r, saTarget, raTarget);

            if (NR_FLAGS(r) & NRADD)
                break;

            fixdword(pdata, raTarget);
            break;
#endif  /* OMF386 */

        default:                        /* Unsupported fixup type */
            RelocErr(ER_fixbad, ra, gsnFrame, gsnTarget, raTarget);
            break;
    }
}

#endif  /* LEGO */


#if O68K
/*
 *  GetFixupWord:
 *
 *  Gets a word depending of the value of fTBigEndian and fDebSeg
 */
LOCAL WORD NEAR         GetFixupWord (pdata)
BYTE                    *pdata;
{
    if (fTBigEndian && !fDebSeg)
    {
        return (WORD)((B2W(pdata[0]) << BYTELN) + B2W(pdata[1]));
    }
    else
    {
        return getword(pdata);
    }
}


/*
 *  GetFixupDword:
 *
 *  Gets a dword depending of the value of fTBigEndian and fDebSeg
 */
LOCAL DWORD NEAR        GetFixupDword (pdata)
BYTE                    *pdata;
{
    if (fTBigEndian && !fDebSeg)
    {
        return (DWORD)((((((B2L(pdata[0]) << BYTELN) + B2L(pdata[1])) << BYTELN)
          + B2L(pdata[2])) << BYTELN) + B2L(pdata[3]));
    }
    else
    {
        return getdword(pdata);
    }
}
#endif /* O68K */
#endif /* OSEGEXE AND NOT EXE386 */


#if ODOS3EXE OR OIAPX286
/*
 * StartAddrOld:
 *
 * Process a MODEND record with a start address for an old-format exe.
 */
LOCAL void NEAR         StartAddrOld ()
{
    SEGTYPE             gsnTarget;
    SEGTYPE             gsnFrame;
    RATYPE              raTarget;       /* Fixup target offset */
    RATYPE              ra;
    SATYPE              dsa;
    SEGTYPE             segTarget;      /* Target segment */
    SEGTYPE             segFrame;

    GetFrameTarget(&gsnFrame,&gsnTarget,&raTarget);
                                        /* Get fixup information */
    if(gsnFrame == SEGNIL) gsnFrame = gsnTarget;
                                        /* Use target val. if none given */
    segFrame = mpgsnseg[gsnFrame];      /* Get frame segment */
    segTarget = mpgsnseg[gsnTarget];/* Get target segment */
    dsa = mpsegsa[segTarget] - mpsegsa[segFrame];
                                        /* Calculate base delta */
#if NOT OIAPX286
    if(dsa > 0x1000)
        FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
                                        /* Delta > 64Kbytes */
    ra = dsa << 4;
    if(0xFFFF - ra < raTarget)          /* If addition would overflow */
    {
        ra = ra - 0xFFFF + raTarget;
                                        /* Fix up addition */
        --ra;
        FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
    }
    else ra = ra + raTarget;
                                        /* Else perform addition */
#endif
#if OIAPX286
    if(dsa) FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
                                        /* No intersegment fixups */
    ra = raTarget;                      /* Use target offset */
#endif
#if EXE386
    if((rect & 1) && ra + fi.f_disp < ra)
    {
        ra = ra - 0xFFFFFFFF + fi.f_disp;
        --ra;
        FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
    }
    else if (!(rect & 1) && 0xFFFF - ra < fi.f_disp)
#else
    if(0xFFFF - ra < fi.f_disp) /* If addition would overflow */
#endif
    {
        ra = ra - 0xFFFF + fi.f_disp;
                                        /* Fix up addition */
        --ra;
        FixupOverflow(raTarget + fi.f_disp,gsnFrame,gsnTarget,raTarget);
    }
    else ra = ra + fi.f_disp;   /* Else perform addition */
    if(segStart == SEGNIL)
    {
        segStart = segFrame;
        raStart = ra;
        if(fLstFileOpen)                /* If there is a listing file */
        {
            if(vcln)                    /* If writing line numbers */
            {
                NEWLINE(bsLst);         /* End of line */
                vcln = 0;               /* Start on new line */
            }
            fprintf(bsLst,GetMsg(MAP_entry),
              mpsegsa[segStart],raStart);/* Print entry point */
        }
    }
}
#endif /* ODOS3EXE OR OIAPX286 */


    /****************************************************************
    *                                                               *
    *  EndRec:                                                      *
    *                                                               *
    *  This   function  is  called  to   process  the  information  *
    *  contained  in  a  MODEND  (type 8AH) record  concerning the  *
    *  program  starting address.  The function  does not return a  *
    *  meaningful value.                                            *
    *  See pp. 80-81 in "8086 Object Module Formats EPS."           *
    *                                                               *
    ****************************************************************/

void NEAR               EndRec(void)
{
    WORD                modtyp;         /* MODEND record modtyp byte */
    SEGTYPE             gsnTarget;
    RATYPE              ra;

    modtyp = Gets();                    /* Read modtyp byte */
    if(modtyp & FSTARTADDRESS)          /* If execution start address given */
    {
        ASSERT(modtyp & 1);             /* Must have logical start address */
        GetFixdat();                    /* Get target information */
#if ODOS3EXE OR OIAPX286
        /* Start address processed differently for DOS 3.x exes */
        if(!fNewExe)
        {
            StartAddrOld();
            return;
        }
#endif
#if OSEGEXE
        switch(fi.f_mtd)                /* Switch on target method */
        {
            case T0:                    /* Segment index */
              gsnTarget = mpsngsn[fi.f_idx];
              ra = mpgsndra[gsnTarget];
              break;

            case T1:                    /* Group index */
              gsnTarget = mpggrgsn[mpgrggr[fi.f_idx]];
              ra = mpgsndra[gsnTarget];
              break;

            case T2:                    /* External index */
              if(mpextflags[fi.f_idx] & FIMPORT)
              {
                  OutError(ER_impent);
                  return;
              }
              gsnTarget = mpextgsn[fi.f_idx];
              ra = mpextra[fi.f_idx];
              break;
        }
        if(segStart == SEGNIL)          /* If no entry point specified */
        {
            segStart = mpgsnseg[gsnTarget];
                                        /* Get starting file segment number */
            raStart = ra + fi.f_disp;
                                        /* Get starting offset */
            if(fLstFileOpen)            /* If there is a listing file */
            {
                if(vcln)                /* If writing line numbers */
                {
                    NEWLINE(bsLst);     /* End of line */
                    vcln = 0;           /* Start on new line */
                }
#if NOT QCLINK
                /* Check if segStart is code */
#if EXE386
                if (!IsEXECUTABLE(mpsaflags[mpsegsa[segStart]]))
#else
                if((mpsaflags[mpsegsa[segStart]] & NSTYPE) != NSCODE
                    && !fRealMode && (TargetOs == NE_OS2 || TargetOs == NE_WINDOWS))
#endif
                    OutError(ER_startaddr);
#endif

                fprintf(bsLst,"\r\nProgram entry point at %04x:%04x\r\n",
                  mpsegsa[segStart],raStart);   /* Print entry point */
            }
        }
#endif /* OSEGEXE */
    }
}


#if ODOS3EXE OR OXOUT
    /****************************************************************
    *                                                               *
    *  RecordSegmentReference:                                      *
    *                                                               *
    *  Generate a loadtime relocation for a DOS3 exe.               *
    *                                                               *
    ****************************************************************/

void NEAR               RecordSegmentReference(seg,ra,segDst)
SEGTYPE                 seg;
RATYPE                  ra;
SEGTYPE                 segDst;
{
    SEGTYPE             segAbsLast;     /* Last absolute segemnt */
    DOSRLC              rlc;            // Relocation address
    long                xxaddr;         /* Twenty bit address */
    void FAR            *pTmp;
    RUNRLC FAR          *pRunRlc;
#if OVERLAYS
    WORD                iov;            /* Overlay number */
#endif
#if FEXEPACK
    WORD                frame;          /* Frame part of 20-bit address */
    FRAMERLC FAR        *pFrameRlc;
#endif

#if SYMDEB
    if(fSymdeb && seg >= segDebFirst)   /* Skip if debug segment */
        return;
#endif
#if ODOS3EXE
    segAbsLast = segLast + csegsAbs;    /* Calc. last absolute seg no. */
    if(vfDSAlloc) --segAbsLast;
    if(segDst > segLast && segDst <= segAbsLast) return;
                                        /* Don't bother if absolute segment */
#endif
    if (TYPEOF(vrectData) == LIDATA)
        ompimisegDstIdata[ra - vraCur] = (char) segDst;
    else                                /* Else if not iterated data */
    {
#if OVERLAYS
        iov = mpsegiov[seg];            /* Get overlay number */
        ASSERT(fOverlays || iov == IOVROOT);
                                        /* If no overlays then iov = IOVROOT */
#endif
#if FEXEPACK
#if OVERLAYS
        if (iov == 0)                   /* If root */
#endif
        if (fExePack)
        {
            /*
             * Optimize this reloc:  form the 20-bit address, the
             * frame is the high-order 4 bits, forming an index
             * into mpframcRle (count of relocs by frame), which
             * then forms an index into the packed relocation area,
             * where the low-order 16 bits are stored.  Finally,
             * increment the frame's reloc count and return.
             */
            xxaddr = ((RATYPE) mpsegsa[seg] << 4) + (RATYPE) ra;
            frame = (WORD) ((xxaddr >> 16) & 0xf);
            pFrameRlc = &mpframeRlc[frame];
            if (pFrameRlc->count > 0x7fff)
                Fatal(ER_relovf);
            ra = (RATYPE) (xxaddr & 0xffffL);
            if (pFrameRlc->count >= pFrameRlc->count)
            {
                // We need more memory to store this relocation

                if (pFrameRlc->rgRlc == NULL)
                {
                    pFrameRlc->rgRlc = (WORD FAR *) GetMem(DEF_FRAMERLC*sizeof(WORD));
                    pFrameRlc->size = DEF_FRAMERLC;
                }
                else if (pFrameRlc->count >= pFrameRlc->size)
                {
                    // Reallocate array of packed relocation offsets

                    pTmp = GetMem((pFrameRlc->size << 1)*sizeof(WORD));
                    FMEMCPY(pTmp, pFrameRlc->rgRlc, pFrameRlc->count*sizeof(WORD));
                    FFREE(pFrameRlc->rgRlc);
                    pFrameRlc->rgRlc = pTmp;
                    pFrameRlc->size <<= 1;
                }
            }
            pFrameRlc->rgRlc[pFrameRlc->count] = (WORD) ra;
            pFrameRlc->count++;
            return;
        }
#endif /* FEXEPACK */
        rlc.sa = (WORD) mpsegsa[seg];   /* Get segment address */
        rlc.ra = (WORD) ra;             /* Save relative address */
#if OVERLAYS
        pRunRlc = &mpiovRlc[iov];
        if (pRunRlc->count >= pRunRlc->count)
        {
            // We need more memory to store this relocation

            if (pRunRlc->rgRlc == NULL)
            {
                pRunRlc->rgRlc = (DOSRLC FAR *) GetMem(DEF_RUNRLC * CBRLC);
                pRunRlc->size = DEF_RUNRLC;
            }
            else if (pRunRlc->count >= pRunRlc->size)
            {
                // Reallocate array of packed relocation offsets

                pTmp = GetMem((pRunRlc->size << 1) * CBRLC);
                FMEMCPY(pTmp, pRunRlc->rgRlc, pRunRlc->count * CBRLC);
                FFREE(pRunRlc->rgRlc);
                pRunRlc->rgRlc = pTmp;
                pRunRlc->size <<= 1;
            }
        }
        pRunRlc->rgRlc[pRunRlc->count] = rlc;
        pRunRlc->count++;
#endif
    }
}
#endif /* ODOS3EXE OR OXOUT */


#if OVERLAYS
    /****************************************************************
    *                                                               *
    *  Mpgsnosn:                                                    *
    *                                                               *
    *  Map global segment number to overlay segment number.         *
    *                                                               *
    ****************************************************************/

LOCAL SNTYPE NEAR       Mpgsnosn(gsn)
SNTYPE                  gsn;            /* Global SEGDEF number */
{
    SNTYPE              hgsn;           /* Gsn hash value */

    hgsn = (SNTYPE)(gsn & ((1 << LG2OSN) - 1));   /* Take the low-order bits */
    while(mposngsn[htgsnosn[hgsn]] != gsn)
    {                                   /* While match not found */
        if((hgsn += HTDELTA) >= OSNMAX) hgsn -= OSNMAX;
                                        /* Calculate next hash value */
    }
    return(htgsnosn[hgsn]);             /* Return overlay segment number */
}
#endif


#if ODOS3EXE OR OIAPX286
LOCAL void NEAR         GetFrameTarget(pgsnFrame,pgsnTarget,praTarget)
SEGTYPE                 *pgsnFrame;     /* Frame index */
SEGTYPE                 *pgsnTarget;    /* Target index */
RATYPE                  *praTarget;     /* Target offset */
{
    RATYPE              dummy;
    WORD                i;

        /* Method no:   Frame specification:
        *  0            segment index
        *  1            group index
        *  2            external index
        *  3            frame number
        *  4            implicit (location)
        *  5            implicit (target)
        *  6            none
        *  7            invalid
        */

    if(fi.f_fmtd == KINDTARGET) /* If frame is target's frame */
    {
        fi.f_fmtd = fi.f_mtd;   /* Use target frame kind */
        fi.f_fidx = fi.f_idx;   /* Use target index */
    }

    if (fi.f_fmtd == KINDEXT && !fNoGrpAssoc)
    {                                   /* If frame given by pub sym */
        if(fi.f_fidx >= extMac) InvalidObject();
                                        /* Make sure index not too big */
        if((i = mpextggr[fi.f_fidx]) != GRNIL)
                                        /* If symbol has group association */
            *pgsnFrame = mpggrgsn[i];   /* Get gsn for group */
        else *pgsnFrame = mpextgsn[fi.f_fidx];
                                        /* Else return target gsn */
    }

    else if (fi.f_fmtd == KINDLOCAT && !fNoGrpAssoc)
    {                                   /* If frame current segment */
        *pgsnFrame = vgsnCur;           /* Frame is location's segment */
    }

    else
    {
       Getgsn(fi.f_fmtd, fi.f_fidx, pgsnFrame, &dummy);
    }

    Getgsn(fi.f_mtd, fi.f_idx, pgsnTarget, praTarget);
                                        /* Get gsn and ra, if any */
}



LOCAL WORD NEAR         InOneGroup(WORD gsnTarget, WORD gsnFrame)
{
    WORD                ggrFrame;       /* Fixup frame group */
    WORD                ggrTarget;      /* Fixup frame group */
    APROPSNPTR          apropSn;        /* Ptr to a segment record */


    if (gsnFrame != SNNIL)
    {
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnFrame], FALSE);
        ggrFrame = apropSn->as_ggr;
    }
    else
        ggrFrame = GRNIL;

    if (gsnTarget != SNNIL)
    {
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsnTarget], FALSE);
        ggrTarget = apropSn->as_ggr;
    }
    else
        ggrFrame = GRNIL;

    return(ggrFrame != GRNIL && ggrTarget != GRNIL && ggrFrame == ggrTarget);
}


LOCAL void NEAR         AddThunk(SEGTYPE gsnTarget, SEGTYPE *psegTarget, RATYPE *praTarget)
{
#pragma pack(1)                         /* This data must be packed */
    struct _thunk
    {
        BYTE    thunkInt;
        BYTE    ovlInt;
        WORD    osnTgt;
        WORD    osnOff;
    }
        thunk;
#pragma pack()                          /* Stop packing */

    // We need a new thunk

    if (ovlThunkMac < (WORD) (ovlThunkMax - 1))
    {
        thunk.thunkInt = INTERRUPT;
        thunk.ovlInt   = (BYTE) vintno;
        thunk.osnTgt   = Mpgsnosn(gsnTarget);
        thunk.osnOff   = (WORD) *praTarget;
        *praTarget     = ovlThunkMac * OVLTHUNKSIZE;
        *psegTarget    = mpgsnseg[gsnOverlay];
        MoveToVm(sizeof(struct _thunk), (BYTE *) &thunk, mpgsnseg[gsnOverlay], *praTarget);
                                        /* Store thunk */
#if FALSE
fprintf(stdout, "%d. Thunk at %x:%04lx; Target osn = %x:%x\r\n",
        ovlThunkMac , mpgsnseg[gsnOverlay], *praTarget, thunk.osnTgt, thunk.osnOff);
#endif
        ovlThunkMac++;
    }
    else
    {
        Fatal(ER_ovlthunk, ovlThunkMax);
    }
}

/*** DoThunking - generate thunk for inter-overlay calls
*
* Purpose:
*   When the dynamic overlays are requested redirect all FAR calls or
*   references to aproppriate thunks. If this is first call/reference
*   to given symbol then add its thunk to the OVERLAY_THUNKS segment.
*
* Input:
*   gsnTarget    - global segment number of the fixup target
*   psegTarget   - poiter to logical segment number of the fixup target
*   praTarget    - pointer offset of the fixup target inside gsnTarget
*
* Output:
*   The gsn and offset of the target are replaced by the gsn and offset
*   of the thunk for target.  For first references to a given symbol
*   the thunk is created in OVERLAY_THUNKS segment (referenced via
*   gsnOverlay global) and the current position in thunk segment is
*   updated (ovlThunkMac).
*
* Exceptions:
*   No space in OVERLAY_THUNKS for new thunk - fatal error - display message
*   suggesting use of /DYNAMIC:<nnn> with <nnn> greater then current value.
*
* Notes:
*   None.
*
*************************************************************************/

LOCAL void NEAR         DoThunking(SEGTYPE gsnTarget, SEGTYPE *psegTarget, RATYPE *praTarget)
{
    APROPNAMEPTR        apropName;      /* Public symbol property */

    switch(fi.f_mtd)
    {
        case KINDEXT:

            // Target is external

            apropName = (APROPNAMEPTR) FetchSym(mpextprop[fi.f_idx], FALSE);
            if (apropName->an_thunk != THUNKNIL)
            {
                // We already allocated thunk for this target

                *praTarget      = apropName->an_thunk;
                *psegTarget = mpgsnseg[gsnOverlay];
#if FALSE
fprintf(stdout, "Using thunk for '%s' at %x:%04lx\r\n",
        1 + GetPropName(apropName), mpgsnseg[gsnOverlay], *praTarget);
#endif
            }
            else
            {
                // We need new thunk for new target

                AddThunk(gsnTarget, psegTarget, praTarget);
                apropName = (APROPNAMEPTR) FetchSym(mpextprop[fi.f_idx], TRUE);
                apropName->an_thunk = *praTarget;


#if FALSE
fprintf(stdout, "%d. Thunk for '%s' at %x:%04lx; Target osn = %x:%x\r\n",
        ovlThunkMac, 1 + GetPropName(apropName), mpgsnseg[gsnOverlay], *praTarget, thunk.osnTgt, thunk.osnOff);
#endif
            }
        break;

        case KINDSEG:

            AddThunk(gsnTarget, psegTarget, praTarget);
            break;

        default:
            InvalidObject();
        }
}

/*
 *  FixOld:
 *
 *  Process a fixup for an old-format exe.
 */
void NEAR               FixOld ()
{
    REGISTER BYTE       *pdata;         /* Pointer into data record */
    SEGTYPE             segTarget;      /* Fixup target segment */
    SEGTYPE             segFrame;       /* Fixup frame segment */
    SEGTYPE             gsnTarget;
    SEGTYPE             gsnFrame;
    RATYPE              raTarget;       /* Fixup target rel. addr. */
    RATYPE              raTmp;
    RATYPE              ra;             /* Current location offset */
    long                dra;
    WORD                dsa;
    WORD                saTmp;          /* Temporary base variable */
#if OVERLAYS
    WORD                fFallThrough;
    WORD                fThunk;


    fFallThrough = FALSE;
    fThunk = FALSE;
#endif
    ra = vraCur + fi.f_dri;             /* Get rel. addr. of fixup */
    pdata = &rgmi[fi.f_dri];            /* Set pointer to fixup location */
    GetFrameTarget(&gsnFrame,&gsnTarget,&raTarget);
                                        /* Process the FIXDAT byte */
    segTarget = mpgsnseg[gsnTarget];    /* Get target segment */
    if(gsnFrame != SNNIL) segFrame = mpgsnseg[gsnFrame];
    else segFrame = SEGNIL;
    if(vsegCur == SEGNIL) return;
    if(gsnTarget == SNNIL)
    {
        if(fi.f_loc == LOCPTR)  /* If "pointer" (4 byte) fixup */
        {
            if(mpsegFlags[vsegCur] & FCODE)
              lastbyte(pdata,ra,CALLFARDIRECT,BREAKPOINT);
                                        /* Replace long call w/ breakpoint */
            return;
        }
        /* Return if "base" (2 byte) fixup */
        if(fi.f_loc == LOCSEGMENT) return;
    }
    else
    {
        if (!fDebSeg && segFrame != SEGNIL)
        {
            dsa = mpsegsa[segTarget] - mpsegsa[segFrame];
#if NOT OIAPX286
            dra = dsa << 4;
            raTmp = raTarget + dra;
            if(dsa >= 0x1000 || raTmp < raTarget)
                FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
            raTarget = raTmp;
            segTarget = segFrame;
#else
            if(dsa)                     /* No intersegment fixups */
                FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
#endif
        }
        else segFrame = segTarget;      /* Else use target's seg as frame */
        if(fi.f_self)           /* If self-relative fixup */
        {
            /* Here we process intersegment self-relative fixups.
             * We assume that the only way this can work is if the
             * both the target segment and the current segment assume
             * the same CS, and that CS is the frame segment of the
             * fixup.  A common example is if vsegCur and segTarget
             * are in the same group represented by segFrame.
             * If this is true, vsegCur must be >= segFrame, so we
             * use this assumption in checking for fixup overflow and
             * adjusting the target offset.
             */
            if (vsegCur != segTarget && !InOneGroup(gsnTarget, gsnFrame))
                RelocWarn(ER_fixovfw,ra,gsnFrame,vgsnCur,raTarget);
            /*
             * First, determine the distance from segFrame to vsegCur in
             * paragraphs and bytes.
             */
            dsa = mpsegsa[vsegCur] - mpsegsa[segFrame];
            /* dra is the adjustment to make ra relative to segFrame */
            dra = (dsa & 0xFFF) << 4;
#if NOT OIAPX286
            /* If the distance is >= 64K, or if the current offset ra plus
             * plus the adjustment dra is >= 64K, or if vsegCur is above
             * segFrame (see above), then we have fixup overflow.
             */
            if (dsa >= 0x1000 || (WORD) (0xFFFF - ra) < (WORD) dra)
                FixupOverflow(ra,gsnFrame,vgsnCur,raTarget);
#else
            /* In protected mode, intersegment self-relative fixups won't
             * work.
             */
            if(dsa)
                FixupOverflow(ra,gsnFrame,vgsnCur,raTarget);
#endif
            /* Determine the fixup value which is raTarget minus the current
             * location, ra.  Adjust ra upward by dra to make it relative
             * to segFrame, then adjust by the length of the location type
             * (assume LOCOFFSET as the most common).  This reduces to the
             * expression below.
             */
            raTarget = raTarget - dra - ra - 2;
            /* Adjust for less likely LOCtypes */
            if(fi.f_loc == LOCLOBYTE)
                raTarget += 1;
#if OMF386
            else if(fi.f_loc >= LOCOFFSET32)
                raTarget -= 2;
#endif
        }
    }
    raTmp = raTarget;
    raTarget += fi.f_disp;
#if OMF386
    if ((rect & 1) && (fi.f_loc >= LOCOFFSET32))
        raTarget += getdword(pdata);
    else
#endif
        raTarget += getword(pdata);
    switch(fi.f_loc)                    /* Switch on fixup type */
    {
        case LOCLOBYTE:                 /* 8-bit "lobyte" fixup */
          raTarget = raTmp + B2W(pdata[0]) + fi.f_disp;
          pdata[0] = (BYTE) raTarget;
          if(raTarget >= 0x100 && fi.f_self)
              FixupOverflow(ra,gsnFrame,gsnTarget,raTarget);
          break;

        case LOCHIBYTE:                 /* 8-bit "hibyte" fixup */
          raTarget = raTmp + fi.f_disp;
          pdata[0] = (BYTE) (B2W(pdata[0]) + (raTarget >> 8));
          break;

#if OMF386
        case LOCOFFSET32:               /* 32-bit "offset" fixup */
        case LOCLOADOFFSET32:
          if(!(rect & 1)) break;        /* Not 386 extension */
          fixword(pdata, raTarget);
          pdata += 2;
          raTarget >>= 16;              /* Get high word, fall through ... */
#if OVERLAYS
          fFallThrough = TRUE;
#endif
#endif
        case LOCOFFSET:                 /* 16-bit "offset" fixup */
        case LOCLOADOFFSET:
#if OVERLAYS
          if (fDynamic && !fFallThrough && !fDebSeg &&
              (fi.f_loc == LOCLOADOFFSET) &&
              (mpsegFlags[vsegCur] & FCODE) && mpsegiov[segTarget])
            DoThunking(gsnTarget, &segTarget, &raTarget);
#endif
          fixword(pdata, raTarget);
                                        /* Perform fixup */
          break;

#if OMF386
        case LOCPTR48:                  /* 48-bit "pointer" fixup */
          if(!(rect & 1)) break;        /* Not 386 extension */
          fixword(pdata, raTarget);
          pdata += 2;
          raTarget >>= 16;              /* Get high word, fall through ... */
#endif
        case LOCPTR:                    /* 32-bit "pointer" fixup */
#if OVERLAYS
          if (!fDebSeg)
          {                             /* If root-overlay or interoverlay */
              if (fDynamic)
              {
                // Gererate thunk if:
                //
                //  - target is in overlay and
                //      - current position is in different overlay or
                //      - current position is in the same overlay but
                //        in a different segment (assuming initialization
                //        of a far pointer to the function)

                if (mpsegiov[segTarget] &&
                    ((mpsegiov[vsegCur] != mpsegiov[segTarget]) ||
                     (mpsegiov[vsegCur] != IOVROOT && vsegCur != segTarget)))
                {
                    DoThunking(gsnTarget, &segTarget, &raTarget);
                    fThunk = (FTYPE) TRUE;
                }
              }
              else if (mpsegiov[segTarget] &&
                       (mpsegiov[vsegCur] != mpsegiov[segTarget]))
              {
                if ((mpsegFlags[vsegCur] & FCODE) &&
                        lastbyte(pdata,ra,CALLFARDIRECT,INTERRUPT))
                {                       /* If fixing up long call direct */
                  *pdata++ = vintno;    /* Interrupt number */
                  *pdata++ = (BYTE) Mpgsnosn(gsnTarget);
                                        /* Target overlay segment number */
                  *pdata++ = (BYTE) (raTarget & 0xFF);
                                        /* Lo word of offset */
                  *pdata = (BYTE)((raTarget >> BYTELN) & 0xFF);
                                        /* Hi word of target */
                  break;                /* All done */
                }
              }
          }
#endif
          if (!fDebSeg && fFarCallTrans &&
              mpsegsa[segTarget] == mpsegsa[vsegCur] &&
              (mpsegFlags[segTarget] & FCODE)
#if OVERLAYS
              && mpsegiov[vsegCur] == mpsegiov[segTarget] && !fThunk
#endif
             )
          {                             /* If intrasegment fixup in the same overlay */
              if(TransFAR(pdata,ra,raTarget))
                  break;
          }
          /* Root-root, overlay-root, and intraoverlay are normal calls */
          fixword(pdata, raTarget);     /* Fix up offset */
          pdata += 2;
          /* Advance to segment part and fall through . . . */
          ra += 2;
#if OVERLAYS
          fFallThrough = TRUE;
#endif

        case LOCSEGMENT:                        /* 16-bit "base" fixup */
#if OVERLAYS
          if (fDynamic && !fDebSeg &&
              (mpsegFlags[vsegCur] & FCODE) && mpsegiov[segTarget])
          {
                if(!fFallThrough)
                {
                OutWarn(ER_farovl, 1+GetPropName(FetchSym(mpgsnrprop[gsnTarget],FALSE)),
                               1+GetPropName(FetchSym(mpgsnrprop[gsnOverlay],FALSE)));
                segTarget = mpgsnseg[gsnOverlay];
                }
                else
                {
                /* intra-overlay pointer fixups not supported - caviar:6806 */
                        OutError(ER_farovldptr);
                }
          }
#endif
          if (fDebSeg)
          {
            // For debug segments use logical segment number (seg)
            // instead of physical segment number (sa)

            saTmp = segTarget;
          }
          else
          {
            saTmp = mpsegsa[segTarget];

            // If MS OMF, high word is a segment ordinal, for huge model
            // Shift left by appropriate amount to get selector
#if OEXE
            if (vfNewOMF && !fDynamic)
              saTmp += (B2W(pdata[0]) + (B2W(pdata[1]) << BYTELN)) << 12;
            else
              saTmp += B2W(pdata[0]) + (B2W(pdata[1]) << BYTELN);
                                        /* Note fixup is ADDITIVE */
#endif
#if OIAPX286 OR OXOUT
            if(vfNewOMF)
              saTmp += (B2W(pdata[0]) + (B2W(pdata[1]) << BYTELN)) << 3;
#endif
            /* Note that base fixups are NOT ADDITIVE for Xenix.  This is
             * to get around a bug in "as" which generates meaningless
             * nonzero values at base fixup locations.
             */
#if OIAPX286
            /* Hack for impure model:  code and data are packed into
             * one physical segment which at runtime is accessed via 2
             * selectors.  The code selector is 8 below the data selector.
             */
            if(!fIandD && (mpsegFlags[segTarget] & FCODE))
              saTmp -= 8;
#endif
          }
          fixword(pdata, saTmp);        /* Perform fixup */
#if NOT OIAPX286
          if (!fDebSeg)
            RecordSegmentReference(vsegCur,ra,segTarget);
                                        /* Record reference */
#endif
          break;

        default:                        /* Unsupported fixup type */
          RelocErr(ER_fixbad,ra,gsnFrame,gsnTarget,raTarget);
          break;
    }
}
#endif /* ODOS3EXE OR OIAPX286 */


/*
 *  FixRc2:
 *
 *  Process a FIXUPP record.  This is a top-level routine which passes
 *  work out to various subroutines.
 */
void NEAR               FixRc2(void)    /* Process a fixup record */
{

#if 0
#if SYMDEB
    // this code is dead -- fDebSeg && !fSymdeb is never true [rm]
    if (fDebSeg && !fSymdeb)
    {
        // If no /CodeView - skip fixups for debug segments

        SkipBytes((WORD) (cbRec - 1));
        return;
    }
#endif
#endif

    if (fSkipFixups)
    {
        fSkipFixups = (FTYPE) FALSE;    // Only one FIXUP record can be skipped
        SkipBytes((WORD) (cbRec - 1));
        return;
    }

    while (cbRec > 1)
    {
        // While fixups or threads remain
        // Get information on fixup

        if (!GetFixup())
            continue;           // Fixup thread - keep registering them

        // If absolute segment skip fixup

        if (vgsnCur == 0xffff)
        {
            SkipBytes((WORD) (cbRec - 1));
            return;
        }

#if SYMDEB
        if (fDebSeg)
        {
            if (fi.f_loc == LOCLOADOFFSET)
                fi.f_loc = LOCOFFSET;    /* Save Cmerge's butts */
#if OMF386
            if (fi.f_loc == LOCOFFSET32 || fi.f_loc == LOCPTR48)
                fi.f_fmtd = F5;  /* Temp fix until compiler is fixed */
#endif
        }
#endif
        DoFixup();
    }
}


//  BAKPAT record bookeeping


typedef struct bphdr                    // BAKPAT bucket
{
    struct bphdr FAR    *next;          // Next bucket
    SNTYPE              gsn;            // Segment index
    WORD                cnt;            // # of BAKPAT entries
    BYTE                loctyp;         // Location type
    BYTE                fComdat;        // TRUE if NBAKPAT
    struct bpentry FAR  *patch;         // Table of BAKPAT entries
}
                        BPHDR;

struct bpentry                          // BAKPAT entry
{
    RATYPE              ra;             // Offset to location to patch
#if OMF386
    long                value;          // Value to add to patch location
#else
    int                 value;          // Value to add to patch location
#endif
};

LOCAL BPHDR FAR         *pbpFirst;      // List of BAKPAT buckets
LOCAL BPHDR FAR         *pbpLast;       // Tail of BAKPAT list


/*
 *  BakPat : Process a BAKPAT record (0xb2)
 *
 *      Just accumulate the record information in virtual memory;
 *      we will do the backpatching later.
 */

void NEAR               BakPat()
{
    BPHDR FAR           *pHdr;          // BAKPAT bucket
    WORD                cEntry;
    WORD                comdatIdx;      // COMDAT symbol index
    DWORD               comdatRa;       // Starting COMDAT offset
    APROPCOMDATPTR      comdat;         // Pointer to symbol table entry

#if POOL_BAKPAT
    if (!poolBakpat)
        poolBakpat = PInit();
#endif


    /* Get the segment index and location type */

#if POOL_BAKPAT
    pHdr = (BPHDR FAR *) PAlloc(poolBakpat, sizeof(BPHDR));
#else
    pHdr = (BPHDR FAR *) GetMem(sizeof(BPHDR));
#endif

    if (TYPEOF(rect) == BAKPAT)
    {
        pHdr->fComdat = (FTYPE) FALSE;
        pHdr->gsn = mpsngsn[GetIndex(1, (WORD) (snMac - 1))];
        pHdr->loctyp = (BYTE) Gets();
        comdatRa = 0L;
    }
    else
    {
        pHdr->fComdat = (BYTE) TRUE;
        pHdr->loctyp = (BYTE) Gets();
        comdatIdx = GetIndex(1, (WORD) (lnameMac - 1));
        comdat = (APROPCOMDATPTR ) PropRhteLookup(mplnamerhte[comdatIdx], ATTRCOMDAT, FALSE);
        if ((comdat->ac_obj != vrpropFile) || !IsSELECTED (comdat->ac_flags))
        {
            // Skip the nbakpat if it concerns an unselected comdat
            // or a comdat from other .obj

            SkipBytes((WORD) (cbRec - 1));
            return;
        }
        else
        {
            if (comdat != NULL)
            {
                pHdr->gsn = comdat->ac_gsn;
                comdatRa = comdat->ac_ra;
            }
            else
                InvalidObject();        // Invalid module
        }
    }

    /* If BAKPAT record for CV info and /CO not used - skip record */
#if SYMDEB
    if (pHdr->gsn == 0xffff)
    {
        SkipBytes((WORD) (cbRec - 1));
        return;                         /* Good-bye! */
    }
#endif

    switch(pHdr->loctyp)
    {
        case LOCLOBYTE:
        case LOCOFFSET:
#if OMF386
        case LOCOFFSET32:
#endif
            break;
        default:
            InvalidObject();
    }

    /* Determine # of entries */

#if OMF386
    if (rect & 1)
        pHdr->cnt = (WORD) ((cbRec - 1) >> 3);
    else
#endif
        pHdr->cnt = (WORD) ((cbRec - 1) >> 2);


    if (pHdr->cnt == 0)
    {
#if NOT POOL_BAKPAT
        FFREE(pHdr);
#endif
        return;
    }

#if DEBUG
    sbModule[sbModule[0]+1] = '\0';
    fprintf(stdout, "\r\nBakPat in module %s, at %x, entries : %x", sbModule+1, lfaLast,pHdr->cnt);
    fprintf(stdout, "  pHdr %x, pbpLast %x ", pHdr, pbpLast);
    fprintf(stdout, "\r\n gsn %d ", pHdr->gsn);
    fflush(stdout);
#endif
    // Store all the BAKPAT entries

#if POOL_BAKPAT
    pHdr->patch = (struct bpentry FAR *) PAlloc(poolBakpat, pHdr->cnt * sizeof(struct bpentry));
#else
    pHdr->patch = (struct bpentry FAR *) GetMem(pHdr->cnt * sizeof(struct bpentry));
#endif

    cbBakpat = 1;  // only need to show backpatches are present [rm]
    cEntry = 0;
    while (cbRec > 1)
    {
#if OMF386
        if (rect & 1)
        {
            pHdr->patch[cEntry].ra    = LGets() + comdatRa;
            pHdr->patch[cEntry].value = LGets();
        }
        else
#endif
        {
            pHdr->patch[cEntry].ra    = (WORD) (WGets() + comdatRa);
            pHdr->patch[cEntry].value = WGets();
        }
        cEntry++;
    }

    // Add bucket to the list

    if (pbpFirst == NULL)
        pbpFirst = pHdr;
    else
        pbpLast->next = pHdr;
    pbpLast = pHdr;
}


/*
 * FixBakpat : Fix up backpatches
 *      Called at the end of processing a module in Pass 2.
 */
void NEAR               FixBakpat(void)
{
    BPHDR FAR           *pHdr;
    BPHDR FAR           *pHdrNext=NULL;
    WORD                n;
    BYTE FAR            *pSegImage;     /* Segment memory image */
    SEGTYPE             seg;            /* Logical segment index */
#if DEBUG
    int i,iTotal=0,j=1;
    char *ibase;
    fprintf(stdout, "\r\nFixBakpat, pbpFirst : %x ", pbpFirst);
#endif

    // Go through the backpatch list and do the backpatches
    for (pHdr = pbpFirst; pHdr != NULL; pHdr = pHdrNext)
    {
        // While there are backpatches remaining, do them
#if DEBUG
        fprintf(stdout, "\r\nBAKPAT at %x, entries : %x ",pHdr,pHdr->cnt);
#endif

        for (n = 0; n < pHdr->cnt; n++)
        {
            // Determine the address of the patch location
#if SYMDEB
            if (pHdr->gsn & 0x8000)
                pSegImage = ((APROPFILEPTR) vrpropFile)->af_cvInfo->cv_sym + pHdr->patch[n].ra;
                                            /* In debug segment */
            else
            {
#endif
                seg = mpgsnseg[pHdr->gsn];
                if(fNewExe)
                    pSegImage = mpsaMem[mpsegsa[seg]];
                else
                    pSegImage = mpsegMem[seg];
                                            /* In other segment */

                pSegImage += pHdr->patch[n].ra;

                if (!pHdr->fComdat)
                    pSegImage += mpgsndra[pHdr->gsn];
                else
                    pSegImage += mpsegraFirst[seg];
#if SYMDEB
            }
#endif
#if DEBUG
            fprintf(stdout, "\r\nseg %d, mpsegsa[seg] sa %d ", seg, mpsegsa[seg]);
            fprintf(stdout, "mpsaMem[seg] %x, mpsegraFirst[seg] %x, pHdr->patch[n].ra %x\r\n",
               mpsaMem[seg], (int)mpsegraFirst[seg], (int)pHdr->patch[n].ra);
            fprintf(stdout, " gsn %x,  mpgsndra[gsn] %x ",pHdr->gsn,mpgsndra[pHdr->gsn]);
            ibase =  pSegImage - pHdr->patch[n].ra;
            iTotal = (int) ibase;
            for(i=0; i<50; i++)
            {
                if(j==1)
                {
                    fprintf( stdout,"\r\n\t%04X\t",iTotal);
                }
                fprintf( stdout,"%02X ",*((char*)ibase+i));
                iTotal++;
                if(++j > 16)
                    j=1;
            }
            fprintf(stdout, "\r\nseg:ra %x:%x, value : %x",seg,pHdr->patch[n].ra,pHdr->patch[n].value);
            fflush(stdout);
#endif
            /* Do the fixup according to the location type */

            switch(pHdr->loctyp)
            {
                case LOCLOBYTE:
                    pSegImage[0] += (BYTE) pHdr->patch[n].value;
                    break;

                case LOCOFFSET:
                    ((WORD FAR *) pSegImage)[0] += (WORD) pHdr->patch[n].value;
                    break;
#if OMF386
                case LOCOFFSET32:
                    ((DWORD FAR *) pSegImage)[0]+= (DWORD) pHdr->patch[n].value;
                    break;
#endif
            }
        }
        pHdrNext = pHdr->next;

#if NOT POOL_BAKPAT
        FFREE(pHdr);
#endif
    }

#if POOL_BAKPAT
    PReinit(poolBakpat);        // reuse same memory again...
#endif

    pbpFirst = NULL;
    cbBakpat = 0;
}
#if TCE
void NEAR               FixRc1(void)    /* Process a fixup record */
{
        if (fSkipFixups)
        {
                fSkipFixups = (FTYPE) FALSE;    // Only one FIXUP record can be skipped
                SkipBytes((WORD) (cbRec - 1));
                        pActiveComdat = NULL;
                return;
        }
        while (cbRec > 1)
        {
        // While fixups or threads remain
        // Get information on fixup

                if (!GetFixup())
                        continue;               // Fixup thread - keep registering them

                if(fi.f_mtd == KINDEXT)
                {
                        RBTYPE rhte;
                        APROPCOMDAT *pUsedComdat;
                        if( mpextprop && mpextprop[fi.f_idx]) // Is there a COMDAT with this name?
                        {
                                rhte = RhteFromProp(mpextprop[fi.f_idx]);
                                ASSERT(rhte);
                                pUsedComdat = PropRhteLookup(rhte, ATTRCOMDAT, FALSE);
                                if(pActiveComdat)
                                {
                                        if(pUsedComdat)
                                        {
                                                AddComdatUses(pActiveComdat, pUsedComdat);
#if TCE_DEBUG
                                                fprintf(stdout, "\r\nCOMDAT %s uses  COMDAT %s ", 1 + GetPropName(pActiveComdat) ,1+ GetPropName(mpextprop[fi.f_idx]));
#endif
                                        }
                                        else
                                        {
                                                AddComdatUses(pActiveComdat, mpextprop[fi.f_idx]);
#if TCE_DEBUG
                                                fprintf(stdout, "\r\nCOMDAT %s uses EXTDEF %s ", 1 + GetPropName(pActiveComdat) ,1+ GetPropName(mpextprop[fi.f_idx]));
#endif
                                        }
                                }
                                else    // no COMDAT of this name
                                {
                                        if(pUsedComdat)
                                        {
                                                pUsedComdat->ac_fAlive = TRUE;
                                                if(!fDebSeg)
                                                {
                                                        AddTceEntryPoint(pUsedComdat);
#if TCE_DEBUG
                                                        fprintf(stdout, "\r\nLEDATA uses COMDAT %s ", 1 + GetPropName(mpextprop[fi.f_idx]));
                                                        sbModule[sbModule[0]+1] = '\0';
                                                        fprintf(stdout, " module %s, offset %x ", sbModule+1, lfaLast);
#endif
                                                }
                                        }
                                        else
                                        {
                                                if(((APROPUNDEFPTR)mpextprop[fi.f_idx])->au_attr == ATTRUND)
                                                {
#if TCE_DEBUG
                                                        fprintf(stdout, "\r\nLEDATA uses EXTDEF %s ", 1 + GetPropName(mpextprop[fi.f_idx]));
#endif
                                                        ((APROPUNDEFPTR)mpextprop[fi.f_idx])->au_fAlive = TRUE;
                                                }
                                        }
                                }
                        }
                }
        }
        pActiveComdat = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newmap3.c ===
/*static char *SCCSID = "%W% %E%";*/
/*
*   Copyright Microsoft Corporation 1986,1987
*
*   This Module contains Proprietary Information of Microsoft
*   Corporation and should be treated as Confidential.
*/
/*
 *  NEWMAP3.C
 *
 *  Routines to set up load image map for DOS3 exes.
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <string.h>

LOCAL SEGTYPE           seg;            /* Current seg number */

/*
 *  FUNCTION PROTOTYPES
 */

LOCAL void NEAR SetSizes(unsigned short segPrev);
LOCAL void NEAR PackCodeSegs(unsigned short segTop);


#if OVERLAYS
/*
 *  SetupOverlays:
 *
 *  Set up the overlay area.
 *  Called by AssignAddresses.
 */
void NEAR               SetupOverlays ()
{
    APROPSNPTR          apropSn;
    WORD                cbOvlData;      /* Amount of overlay data */

    if(osnMac > OSNMAX) osnMac = OSNMAX;
    apropSn = GenSeg("\014OVERLAY_DATA","\004DATA",ggrDGroup, (FTYPE) TRUE);
                    /* Create (maybe) data segment */
    apropSn->as_flags = dfData;         /* Type data */
    gsnOvlData = apropSn->as_gsn;       /* Save SEGDEF number */
    cbOvlData = (((WORD) apropSn->as_cbMx) + 0xF) & 0xFFF0;
                                        /* Round size up to paragraph bound */
    /* We will have one word table indexed by overlay segment number, one
    * char table indexed by overlay seg. no., one long table indexed by
    * overlay number, 15 bytes for the file name, a word for the number of
    * overlays, a word for the number of overlay segs., and a byte for the
    * interrupt number.
    */
    apropSn->as_cbMx = 20 + ((long) osnMac << 1) +
                       (long) (fDynamic ? osnMac << 1 : osnMac) +
                       ((long) iovMac << 2) + (long) cbOvlData;
    // For dynamic overlays add one table of longs indexed by overlay
    // number and one byte for overlay interrup number.
    if (fDynamic)
        apropSn->as_cbMx += ((long) iovMac << 2) + 1;
    MARKVP();                           /* Page has been modified */
    MkPubSym("\006$$CGSN",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Count of segments */
    cbOvlData += 2;                     /* Increment size */
    MkPubSym("\006$$COVL",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Count of overlays */
    cbOvlData += 2;                     /* Increment size */
    MkPubSym("\013$$MPGSNBASE",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Gsn to base table */
    cbOvlData += osnMac << 1;           /* Accumulate size of data so far */
    MkPubSym("\012$$MPGSNOVL",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Gsn to overlay table */
    if (fDynamic)
        cbOvlData += osnMac << 1;       /* Accumulate size of data so far */
    else
        cbOvlData += osnMac;
    MkPubSym("\012$$MPOVLLFA",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Overlay to file address table */
    cbOvlData += iovMac << 2;           /* Accumulate size of data so far */
    if (fDynamic)
    {
        MkPubSym("\013$$MPOVLSIZE",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Overlay to size table */
        cbOvlData += iovMac << 2;       /* Accumulate size of data so far */
        MkPubSym("\007$$INTNO",ggrDGroup,gsnOvlData, (RATYPE)cbOvlData);
                                        /* Overlay interrupt number */
        cbOvlData++;
        MkPubSym("\010$$OVLEND", ggrDGroup, gsnOvlData, (RATYPE) cbOvlData);
                                        /* Last byte in overlay area */
        apropSn = GenSeg("\016OVERLAY_THUNKS","\004CODE",GRNIL, TRUE);
                                        /* Create thunk segment */
        apropSn->as_flags = dfCode;     /* Code segment */
        apropSn->as_cbMx = ovlThunkMax * OVLTHUNKSIZE;
        apropSn->as_tysn = apropSn->as_tysn & ~MASKTYSNCOMBINE;
        apropSn->as_tysn = apropSn->as_tysn | TYSNCOMMON;

        gsnOverlay = apropSn->as_gsn;   /* Save thunks SEGDEF number */
        MARKVP();                       /* Page has changed */
        MkPubSym("\015$$OVLTHUNKBEG", GRNIL, gsnOverlay,0);
        MkPubSym("\015$$OVLTHUNKEND", GRNIL, gsnOverlay,ovlThunkMax*OVLTHUNKSIZE);
    }
    else
    {
        MkPubSym("\010$$EXENAM",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Executable file name */
        cbOvlData += 15;                /* 15-byte name field */
        MkPubSym("\007$$INTNO",ggrDGroup,gsnOvlData,(RATYPE)cbOvlData);
                                        /* Overlay interrupt number */
        apropSn = GenSeg("\014OVERLAY_AREA","\004CODE",GRNIL,FALSE);
                                        /* Create overlay area */
        apropSn->as_flags = dfCode;     /* Code segment */
        gsnOverlay = apropSn->as_gsn;   /* Save overlay SEGDEF number */
        MARKVP();                       /* Page has changed */
        MkPubSym("\011$$OVLBASE",GRNIL,gsnOverlay,(RATYPE)0);
                                        /* First byte in overlay area */
        apropSn = GenSeg("\013OVERLAY_END","\004CODE",GRNIL,FALSE);
                                        /* Create overlay end */
        apropSn->as_flags = dfCode;     /* Code segment */
        MkPubSym("\010$$OVLEND",GRNIL,apropSn->as_gsn,(RATYPE)0);
                                        /* Last byte in overlay area */
        MARKVP();                       /* Page has changed */
    }
}
#endif /* OVERLAYS */

    /****************************************************************
    *                                                               *
    *  SetSizes:                                                    *
    *                                                               *
    *  This function  sets  the  starting  address  for  the segth  *
    *  segment assuming the segment indexed by segPrev immediately  *
    *  precedes the segth segment.  If there is a starting address  *
    *  for the segth  segment  already,  then  SetSizes  will  not  *
    *  change that  address  unless  the new address it calculates  *
    *  is higher.                                                   *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         SetSizes (segPrev)
SEGTYPE                 segPrev;
{
    long                addr;           /* 20-bit address */

    /* Get address of end of previous segment */
    addr = ((long) mpsegsa[segPrev] << 4) +
      mpsegcb[segPrev] + mpsegraFirst[segPrev];
                                        /* Form 20-bit address of segment */
    switch(B2W(mpsegalign[seg]))        /* Align the address properly */
    {
        case ALGNWRD:                   /* Word-aligned */
            addr = (addr + 1) & ~1L;    /* Round up to word offset */
            break;

#if OMF386
        case ALGNDBL:                   /* Double word-aligned */
            addr = (addr + 3) & ~3L;    /* Round up to dword offset */
            break;
#endif
        case ALGNPAR:                   /* Paragraph-aligned */
            addr = (addr + 0xF) & ~0xFL;
                                        /* Round up to paragraph offset */
            break;

        case ALGNPAG:                   /* Page-aligned */
            addr = (addr + 0xFF) & ~0xFFL;
                                        /* Round up to page offset */

        default:                        /* Byte-aligned */
            break;
    }
    /* Assign beginning of this segment */
    if(addr > ((long) mpsegsa[seg] << 4) + (long) mpsegraFirst[seg])
    {
        mpsegsa[seg] = (WORD)(addr >> 4);
        mpsegraFirst[seg] = (WORD) addr & 0xF;
    }
}

/*
 *  PackCodeSegs  :  Pack adjacent code segments
 *
 *      Pack as many adjacent code segments (which are in the same
 *      overlay) together as possible.  Start with the current
 *      segment, seg, and stop when the packing limit is exceeded,
 *      a data segment is reached, or the given highest segment is
 *      reached.  For DOS3, packing means assigning the same base
 *      address and adjusting the offset of the first byte.
 *
 *  Parameters:
 *      segTop          Number of highest segment which can be packed.
 *  Returns:
 *      Nothing.
 *  Side effects:
 *      seg is set to the last segment included in the packing group
 */

LOCAL void NEAR         PackCodeSegs (segTop)
SEGTYPE                 segTop;
{
    DWORD               sacb;           /* Length of packing group */
    SEGTYPE             segi;           /* Our private current segment no. */
    RATYPE              raSave;         /* Original mpsegraFirst[segi] */
#if OVERLAYS
    IOVTYPE             iov;            /* Overlay of 1st seg in group */

    iov = mpsegiov[seg];                /* Determine current overlay */
#endif

    sacb = mpsegcb[seg] + mpsegraFirst[seg];    /* Initialize group size */
    for(segi = seg + 1; segi <= segTop; ++segi)
    {                                   /* Loop until highest code seg */
#if OVERLAYS
        if(mpsegiov[segi] != iov)       /* If not a member of this ovl, skip */
            continue;
#endif
        if(!(mpsegFlags[segi] & FCODE)) /* Stop if we hit a data segment */
            break;
        /* Adjust alignment */
        switch(mpsegalign[segi])        /* Switch on alignment type */
        {
            case ALGNWRD:               /* Word-aligned */
              sacb = (sacb + 1) & ~1L;
                                        /* Round up size to word boundary */
              break;
#if OMF386
            case ALGNDBL:               /* Double word-aligned */
              sacb = (sacb + 3) & ~3L;  /* Round up to dword offset */
              break;
#endif
            case ALGNPAR:               /* Paragraph-aligned */
              sacb = (sacb + 0xF) & ~0xFL;
                                        /* Round up size to para boundary */
              break;

            case ALGNPAG:               /* Page-aligned */
              sacb = (sacb + 0xFF) & ~0xFFL;
                                        /* Round up size to page boundary */
              break;
        }
        raSave = mpsegraFirst[segi];    /* Save original value */
        mpsegraFirst[segi] = sacb;      /* Set new offset */
        sacb += mpsegcb[segi];          /* Increment size of group */
        if(sacb > packLim)              /* If packing limit exceeded, stop */
        {
            mpsegraFirst[segi] = raSave;        /* Restore original value */
            break;
        }
        mpsegsa[segi] = mpsegsa[seg];   /* Assign base address */
    }
}

/*
 *  AssignDos3Addr:
 *
 *  Assign addresses for a DOS3-format program.
 *  Called by AssignAddresses.
 */
void NEAR               AssignDos3Addr(void)
{
    APROPSNPTR          apropSn;        /* Pointer to a SEGDEF */
    SNTYPE              gsn;            /* Current global SEGDEF no. */
    ALIGNTYPE           align;          /* Alignment type */
    GRTYPE              ggr;            /* Current global GRPDEF no. */
    SEGTYPE             segTop=0;       /* Highest segment in DGROUP */
    SNTYPE              gsnTop=0;       /* Highest segment in DGROUP */
    SNTYPE              gsnBottomDGroup;/* For DS-allocate */
    SEGTYPE             segBottomDGroup;/* For DS-allocate */
    SATYPE              saMaxDGroup;    /* For DS-allocate */
    SEGTYPE             segOverlay;
    SEGTYPE             segPrev;
#if OVERLAYS
    SEGTYPE FAR         *mpiovsegPrev;
    IOVTYPE             iov;
    ALIGNTYPE           alignOverlay;
    long                cbOverlay;
    WORD                segOvlSa;
    RATYPE              segOvlRaFirst;
#endif
    SEGTYPE             segStack;       /* Logical segment no. of stack */

#if OVERLAYS
    mpiovsegPrev = (SEGTYPE FAR *) GetMem(iovMac*sizeof(SEGTYPE));
#endif
    segTop = 0;
    /* We haven't yet assigned absolute segments (it is assumed
    *  they are empty and are used only for addressing purposes),
    *  but now we must assign them somewhere.
    */
    csegsAbs = 0;                       /* Assume there are no absolute segs */
    for(gsn = 1; gsn < gsnMac; ++gsn)   /* Loop to initialize absolute segs */
    {
        if(mpgsnseg[gsn] == SEGNIL)     /* If we have an absolute segment */
        {
            ++csegsAbs;                 /* Increment counter */
            mpgsnseg[gsn] = ++segLast;  /* Assign a segment order number */
        }
    }
    if(vfDSAlloc)                       /* If doing DS allocation */
    {
        if(gsnMac >= gsnMax)
                Fatal(ER_segmax);
                                        /* We implicitly use another segment */
        gsnBottomDGroup = gsnMac;       /* Fix the bottom of DGROUP */
        ++csegsAbs;                     /* Inc absolute seg counter */
        segBottomDGroup = ++segLast;    /* Bottom segment in DGROUP */
        mpgsnseg[gsnBottomDGroup] = segLast;
                                        /* Store entry in table */
    }
#if OVERLAYS
    alignOverlay = ALGNPAR;             /* Overlays are para-aligned */
#endif
    segLast -= csegsAbs;                /* Get no. of last non-abs seg */
    /* Find lowest segment in groups, etc. */
    for(gsn = 1; gsn < gsnMac; ++gsn)   /* Loop to find lowest segs */
    {
        seg = mpgsnseg[gsn];            /* Get segment number */
        apropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],TRUE);
                                        /* Get symbol table entry */
        mpgsndra[gsn] = 0;
#if OVERLAYS
        mpsegiov[seg] = apropSn->as_iov;
                                        /* Save overlay number */
#endif
        mpsegcb[seg] = apropSn->as_cbMx;
                                        /* Save segment size */
        if(apropSn->as_tysn == TYSNABS) /* Assign absolute segs their loc. */
            mpsegsa[seg] = (SATYPE) apropSn->as_cbMx;
        ggr = apropSn->as_ggr;          /* Get GRPDEF number */
        if(ggr != GRNIL)                /* If segment is group member */
        {
            if(mpggrgsn[ggr] == SNNIL || mpgsnseg[mpggrgsn[ggr]] > seg)
                mpggrgsn[ggr] = gsn;
            if(ggr == ggrDGroup && seg > segTop)
            {
                segTop = seg;
                gsnTop = gsn;
            }
        }
        align = (ALIGNTYPE) ((apropSn->as_tysn) >> 5);
        if((apropSn->as_tysn & MASKTYSNCOMBINE) == TYSNSTACK) align = ALGNPAR;
        if(align > mpsegalign[seg]) mpsegalign[seg] = align;
#if OVERLAYS
        if(mpsegiov[seg] != IOVROOT &&
          mpiovsegPrev[mpsegiov[seg]] == SEGNIL && align > alignOverlay)
        {
            mpiovsegPrev[mpsegiov[seg]] = SEGNIL + 1;
            alignOverlay = align;
        }
#endif
        /* Define special symbols "_edata" and "_end" */

        if (fSegOrder)
            Define_edata_end(apropSn);
    }

    if (fSegOrder)
        Check_edata_end(gsnTop, segTop);


    /* Now we assign actual addresses.  The procedure is as follows:
    *  For each code segment
    *  (1) Assign all addresses of the root up to OVERLAY_AREA or THUNK_AREA.
    *  (2) Assign all addresses of the overlays.
    *  (3) If dynamic overlays then set the size of OVERLAY_AREA to zero
    *      else set the start of the segment after OVERLAY_AREA to be
    *      the greatest of all the overlays including the root
    *      OVERLAY_AREA.
    *  (4) Assign the rest of the root segments.
    *  Repeat steps one through four for all remaining segments.
    *
    *  Set limit of part (1): up to OVERLAY_AREA(if there are overlays)
    *  or the end of the segment list.  Do not assign OVERLAY_AREA until
    *  after all the overlays have been taken care of.
    *
    *   For dynamic overlays the DGROUP part of the root overlay
    *   immediatelly follows the OVERLAY_THUNKS, since the OVERLAY_AREA
    *   is dynamically allocated by the overlay manager at run-time.
    */
#if OVERLAYS
    if(fOverlays)                       /* If there are overlays */
    {
        segOverlay = mpgsnseg[gsnOverlay];
                                        /* Set limit at 1st overlay */
        mpsegalign[segOverlay] = alignOverlay;
    }
    else
#endif
        segOverlay = segLast;           /* Look at all segments */

    /* Set the sizes of all of the root up until the OVERLAY_AREA. */

    segPrev = 0;                        /* No previous segment */
    for(seg = 1; seg <= segOverlay; ++seg)
    {                                   /* Loop thru segs up to overlay area */
#if OVERLAYS
        if(mpsegiov[seg] == IOVROOT)
        {                               /* If root member */
#endif
            SetSizes(segPrev);          /* Set start address */

            /* If packing code segs and this is one, pack until segOverlay */

            if (!fDynamic && packLim != 0L && (mpsegFlags[seg] & FCODE))
                PackCodeSegs(segOverlay);
            segPrev = seg;              /* Save segment number */
#if OVERLAYS
        }
#endif
    }
#if OVERLAYS
    /* If there are no overlays, then we have assigned all
    *  segments.  Otherwise, the previous segment of the
    *  beginning of the overlays is the OVERLAY_AREA in the
    *  root. If the dynamic overlays were requested, then
    *  the OVERLAY_THUNKS becomes the previous segment for
    *  all overlay segments.
    */
    if (fOverlays)                      /* If there are overlays */
    {
        for (iov = IOVROOT + 1; iov < (IOVTYPE) iovMac; ++iov)
            mpiovsegPrev[iov] = segOverlay;

        /*  Assign addresses to the overlays.  We do not assign the
         *  rest of the root because we may have to expand the size of
         *  OVERLAY_AREA to accommodate a large overlay.
         */

        if (fDynamic)
        {
            // All dymanic overlay are zero based

            segOvlSa = mpsegsa[segOverlay];
            mpsegsa[segOverlay] = 0;
            segOvlRaFirst = mpsegraFirst[segOverlay];
            mpsegraFirst[segOverlay] = 0;
        }
        cbOverlay = mpsegcb[segOverlay];/* Save size of overlay segment */
        mpsegcb[segOverlay] = 0;        /* Zero the size field for SetSizes */
        for (seg = 1; seg <= segLast; ++seg)
        {
            if(mpsegiov[seg] != IOVROOT)
            {
                SetSizes(mpiovsegPrev[mpsegiov[seg]]);
                /* If packing code segs and this is one, pack until segLast */
                if(packLim != 0L && (mpsegFlags[seg] & FCODE))
                    PackCodeSegs(segLast);
                mpiovsegPrev[mpsegiov[seg]] = seg;
            }
        }
        if (fDynamic)
        {
            mpsegsa[segOverlay] = segOvlSa;
            mpsegraFirst[segOverlay] = segOvlRaFirst;
        }
        mpsegcb[segOverlay] = cbOverlay;/* Reset the size field */

        /* Determine first segment in root after OVERLAY_AREA or OVERLAY_THUNKS */

        seg = segOverlay + 1;
        while (seg <= segLast && mpsegiov[seg] != IOVROOT)
            ++seg;
        /*
         * If there is a segment in the root after the overlays,
         * then go through all of the overlays as previous segments
         * and set its size with the previous one being the last seg
         * of each overlay.  We won't initialize the Vm for that
         * segment because we won't know the maximum placement until
         * afterward.
         */
        if (seg <= segLast)
        {
            for (iov = IOVROOT + 1; iov < (IOVTYPE) iovMac; ++iov)
                SetSizes(mpiovsegPrev[iov]);

            /* Assign the rest of the root */

            segPrev = segOverlay;
            while (seg <= segLast)
            {
                if (mpsegiov[seg] == IOVROOT)
                {
                    SetSizes(segPrev);

                    /* If packing code segs and this is one, pack until segLast */

                    if(packLim != 0L && (mpsegFlags[seg] & FCODE))
                        PackCodeSegs(segLast);
                    segPrev = seg;
                }
                ++seg;
            }
        }
    }
#endif  /* OVERLAYS */
    if(vfDSAlloc)                       /* If doing DS allocation */
    {
        saMaxDGroup = (SATYPE) (mpsegsa[segTop] +
          ((mpsegcb[segTop] + mpsegraFirst[segTop] + 0xF) >> 4));
        mpggrgsn[ggrDGroup] = gsnBottomDGroup;
        mpsegsa[segBottomDGroup] = (SATYPE)((saMaxDGroup - 0x1000) & ~(~0 << WORDLN));
#if OVERLAYS
        mpsegiov[segBottomDGroup] = mpsegiov[segTop];
                                        /* Top and bottom in same overlay */
#endif
        mpgsndra[gsnBottomDGroup] = 0;
    }
    /* If /DOSSEG enabled, stack segment defined, and DGROUP defined,
     * check for combined stack + DGROUP <= 64K.
     */
    if(fSegOrder && gsnStack != SNNIL && mpggrgsn[ggrDGroup] != SNNIL)
    {
        segStack = mpgsnseg[gsnStack];
        if ((((long) mpsegsa[segStack] << 4) + mpsegcb[segStack])
            - ((long) mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]] << 4)
            > LXIVK)
            Fatal(ER_stktoobig);
    }
    segResLast = segLast;
    for(gsn = 1; gsn < gsnMac; ++gsn)
        mpgsndra[gsn] += mpsegraFirst[mpgsnseg[gsn]];
#if OVERLAYS
    /* Set all absolute segs to the root overlay */
    seg = segLast + 1;
    while(seg < (SEGTYPE) (segLast + csegsAbs)) mpsegiov[seg++] = IOVROOT;
    /* "Remember those absolute symbols, too !" */
    mpsegiov[0] = IOVROOT;
    FFREE(mpiovsegPrev);
#endif
}

#if OVERLAYS
#pragma check_stack(on)
    /****************************************************************
    *                                                               *
    *  FixOvlData:                                                  *
    *                                                               *
    *  Initialize overlay data tables.                              *
    *                                                               *
    ****************************************************************/

void NEAR               FixOvlData()
{
    APROPNAMEPTR        apropName;      /* Public symbol name */
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    BYTE                wrd[2];         /* Word as byte array */
    long                ra;             /* Offset */
    SNTYPE              osn;            /* Overlay segment index */
    SEGTYPE             seg;            /* Segment number */
    SATYPE              sa;             /* Segment base */
    BYTE                *pb;            /* Byte pointer */
    SBTYPE              sb;             /* String buffer */
    SNTYPE              gsn;

    apropName = (APROPNAMEPTR ) PropSymLookup("\006$$CGSN",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    mpsegFlags[mpgsnseg[apropName->an_gsn]] |= FNOTEMPTY;
                                        /* Segment is not empty */
    wrd[0] = (BYTE) (osnMac & 0xff);    /* Get lo byte */
    wrd[1] = (BYTE) ((osnMac >> BYTELN) & 0xff); /* Get hi byte */
    MoveToVm(2,wrd,mpgsnseg[apropName->an_gsn],apropName->an_ra);
                                        /* Store value */
    wrd[0] = (BYTE) (iovMac & 0xff);    /* Get lo byte */
    wrd[1] = (BYTE) ((iovMac >> BYTELN) & 0xff); /* Get hi byte */
    apropName = (APROPNAMEPTR ) PropSymLookup("\006$$COVL",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    MoveToVm(2,wrd,mpgsnseg[apropName->an_gsn],apropName->an_ra);
                                        /* Store value */
    apropName = (APROPNAMEPTR )PropSymLookup("\013$$MPGSNBASE",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    ra = apropName->an_ra;              /* Get table offset */
    seg = mpgsnseg[apropName->an_gsn];  /* Get segment number */
    vrectData = LEDATA;
    RecordSegmentReference(seg,ra,seg); /* Record load-time fixup */
    ra += 2;                            /* Increment offset */
    /* Entries 1 thru osnMac - 1 contain bases of segments at runtime */
    for(osn = 1; osn < osnMac; ++osn)   /* Loop thru segment definitions */
    {
        sa = mpsegsa[mpgsnseg[mposngsn[osn]]];
                                        /* Get segment base */
        if (fDynamic)
            sa <<= 4;                   /* Convert para address to offset from overlay base */
        wrd[0] = (BYTE) (sa & 0xff);    /* Lo byte */
        wrd[1] = (BYTE) ((sa >> BYTELN) & 0xff); /* Hi byte */
        MoveToVm(2,wrd,seg,ra);         /* Move to VM */
        if (!fDynamic)
            RecordSegmentReference(seg,ra,seg);
                                        /* Record load-time fixup */
        ra += 2;                        /* Increment offset */
    }
    apropName = (APROPNAMEPTR ) PropSymLookup("\012$$MPGSNOVL",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    ra = apropName->an_ra;              /* Get table offset */
    seg = mpgsnseg[apropName->an_gsn];  /* Get segment number */
    if (fDynamic)
    {
        ra += 2;                         /* First entry null */
        for(osn = 1; osn < osnMac; ++osn)
        {                                /* Loop thru segment definitions */
            wrd[0] = (BYTE) mpsegiov[mpgsnseg[mposngsn[osn]]];
            wrd[1] = (BYTE) ((mpsegiov[mpgsnseg[mposngsn[osn]]] >> BYTELN) & 0xff);
                                         /* Get overlay number */
            MoveToVm(2,wrd,seg,ra);      /* Move to VM */
            ra += 2;
        }
    }
    else
    {
        ++ra;                            /* First entry null */
        for(osn = 1; osn < osnMac; ++osn)/* Loop thru segment definitions */
        {
            wrd[0] = (BYTE) mpsegiov[mpgsnseg[mposngsn[osn]]];
                                         /* Get overlay number */
            MoveToVm(1,wrd,seg,ra++);    /* Move to VM */
        }

        apropName = (APROPNAMEPTR ) PropSymLookup("\010$$EXENAM",ATTRPNM,FALSE);
                                        /* Look up public symbol */
        ra = apropName->an_ra;          /* Get table offset */
        seg = mpgsnseg[apropName->an_gsn];
                                        /* Get segment number */
        ahte = (AHTEPTR ) FetchSym(rhteRunfile,FALSE);
        memcpy(sb,GetFarSb(ahte->cch),1+B2W(ahte->cch[0]));
                                        /* Copy the filename */
        pb = StripDrivePath(sb);        /* Strip drive and path */
        sb[sb[0] + 1] = '\0';
        if (strrchr(&sb[1], '.') == NULL)
            UpdateFileParts(pb, sbDotExe);
        MoveToVm(B2W(pb[0]),pb+1,seg,ra);
                                        /* Move name to VM */
    }
    apropName = (APROPNAMEPTR ) PropSymLookup("\007$$INTNO",ATTRPNM,FALSE);
                                        /* Look up public symbol */
    MoveToVm(1,&vintno,mpgsnseg[apropName->an_gsn],apropName->an_ra);
                                        /* Move overlay number to VM */
    /* If /PACKCODE enabled, redefine $$OVLBASE so it has an offset of 0,
     * which the overlay manager expects.  Find 1st non-root segment
     * and use that.
     */
    if(packLim)
    {
        apropName = (APROPNAMEPTR) PropSymLookup("\011$$OVLBASE",ATTRPNM, TRUE);
        for(gsn = 1; gsn < gsnMac && !mpsegiov[mpgsnseg[gsn]]; ++gsn);
        apropName->an_gsn = gsn;
        apropName->an_ra = 0;
    }
}
#pragma check_stack(off)
#endif /* OVERLAYS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newmap5.c ===
/*
*       Copyright Microsoft Corporation, 1983-1989
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/* Addressing frame for segmented executable */

/*
 *  NEWMAP5.C
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Reloc. type definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* DOS & 286 .EXE data structures */
#if EXE386
#include                <exe386.h>      /* 386 .EXE data structures */
#endif
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

#if NOT EXE386
#define SEGTOPADDR      ((WORD)0xffff)
#endif

/*
 *  AssignSegAddr:
 *
 *  Assign addresses for a segmented-executable format program.
 *  Called by AssignAddresses.
 */
void NEAR               AssignSegAddr()
{
    REGISTER SNTYPE     gsn;
    REGISTER SEGTYPE    seg;
    APROPSNPTR          papropSn;
    ALIGNTYPE           align;
    GRTYPE              ggr;
    SEGTYPE             segTop;
    AHTEPTR             pahte;          /* Pointer to group name hte */
    DWORD               sacb;           /* Physical segment ("frame") size */
    SEGTYPE             segi;           /* Segment index */
    DWORD               CurrentPackLim;
    WORD                fMixed;         // TRUE if mixing use16 with use32 allowed
    WORD                fUse16;         // TRUE if group is use16
#if FALSE AND NOT EXE386
    WORD                ShiftDelta;
#endif


    segTop = 0;
    saMac = 1;                          /* Initialize counter */
#if EXE386
    if (ggrFlat)
        mpggrgsn[ggrFlat] = gsnMac;     /* Mark base of pseudo-group */
#endif
    for(seg = 1; seg <= segLast; ++seg) /* Loop to combine segments */
    {
        if(saMac >= SAMAX) Fatal(ER_fsegmax);
                                        /* Check for table overflow */
        mpsegsa[seg] = saMac;           /* Save phys. seg. in table */
        mpsegraFirst[seg] = 0;          /* First byte at offset zero */
        mpgsndra[mpseggsn[seg]] = 0;    /* First byte at offset zero */
        papropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[mpseggsn[seg]],FALSE);
                                        /* Look up segment definition */
        sacb = papropSn->as_cbMx;       /* Save initial phys. seg. size */
        mpsacb[saMac] = sacb;           /* Save in table also */
        mpsaflags[saMac] = papropSn->as_flags;
                                        /* Save the flags */
        mpsacbinit[saMac] = 0L;         /* Initialize */
        mpsaRlc[saMac] = NULL;          /* Initialize */
        ggr = papropSn->as_ggr;         /* Get global GRPDEF index */
        if (ggr != GRNIL)               /* If we've found a group member */
        {
            fUse16 = !Is32BIT(papropSn->as_flags);
            fMixed = (papropSn->as_fExtra & MIXED1632);
            mpggrgsn[ggr] = mpseggsn[seg];
                                        /* Remember base of group */
            for (segTop = segLast; segTop > seg; --segTop)
            {                           /* Loop to find highest member */
                papropSn = (APROPSNPTR )
                  FetchSym(mpgsnrprop[mpseggsn[segTop]],FALSE);
                                        /* Get segment definition */
                if (ggr == papropSn->as_ggr) break;
                                        /* Break loop when found */
            }
        }
        else if (gsnAppLoader && mpseggsn[seg] == gsnAppLoader)
        {
            // Don't pack aplication loader with other CODE segments

            segTop = seg;
        }
#if EXE386
        else if (gsnImport && mpseggsn[seg] == gsnImport)
        {
            // Don't pack IAT segment with other DATA segments

            segTop = seg;
        }
#endif
        else if (packLim != 0L && IsCodeFlg(papropSn->as_flags))
        {                               /* If packing code segments */
            segTop = segCodeLast;       /* Pack as much code as possible */
#if EXE386
            if (!Is32BIT(papropSn->as_flags))
                CurrentPackLim = LXIVK - 36;
            else
#endif
                CurrentPackLim = packLim;
        }
        else if(DataPackLim != 0L && IsDataFlg(papropSn->as_flags))
        {                               /* If packing data segments */
            segTop = segDataLast;       /* Pack as much data as possible */
#if EXE386
            if (!Is32BIT(papropSn->as_flags))
                CurrentPackLim = LXIVK;
            else
#endif
                CurrentPackLim = DataPackLim;
        }
        else segTop = seg;              /* Else stop with current segment */

        for(segi = seg + 1; segi <= segTop; ++segi)
        {                               /* Loop to end of group */
            papropSn = (APROPSNPTR )
              FetchSym(mpgsnrprop[mpseggsn[segi]],FALSE);
                                        /* Get segment definition */
            if (!fMixed && papropSn->as_ggr != GRNIL)
                fMixed = (papropSn->as_fExtra & MIXED1632);
                                        // Check if mixing use16
                                        // and use32 for group allowed
            if(papropSn->as_ggr != ggr && papropSn->as_ggr != GRNIL)
            {                           /* If groups do not match */
                if(ggr == GRNIL)        /* If not in a true group */
                {
                    segTop = segi - 1;  /* Stop after last segment */
                    break;              /* Exit loop */
                }
                /* Output warning message */
                OutWarn(ER_grpovl,
        1 + GetPropName(FetchSym(mpggrrhte[ggr],FALSE)),
        1 + GetPropName(FetchSym(mpggrrhte[papropSn->as_ggr],FALSE)));
            }

            if(IsIOPL(mpsaflags[saMac]) != IsIOPL(papropSn->as_flags))
            {
                /* Don't pack IOPL with NIOPL */

                if (ggr == GRNIL)
                {
                    /* Not a members of any group - stop packing */

                    segTop = segi - 1;
                    break;
                }
                else
                {
                    /* Issue error and continue */

                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                    /* Get hash table entry */
                    OutError(ER_iopl, 1 + GetPropName(papropSn),
                                      1 + GetFarSb(pahte->cch));
                }
            }
#if EXE386
            if(Is32BIT(mpsaflags[saMac]) != Is32BIT(papropSn->as_flags))
            {
                /* Don't pack 32-bit segments with 16-bit segments */

                if (ggr == GRNIL)
                {
                    /* Not a members of any group - stop packing */

                    segTop = segi - 1;
                    break;
                }
                else if (!fMixed)
                {
                    /* Issue error and continue */

                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                    /* Get hash table entry */
                    OutError(ER_32_16_bit, 1 + GetPropName(papropSn),
                                      1 + GetFarSb(pahte->cch));
                }
            }
#endif
            if (IsDataFlg(mpsaflags[saMac]) && IsDataFlg(papropSn->as_flags))
            {
                // If we are packing DATA segments, check NSSHARED bit

#if EXE386
                if (IsSHARED(mpsaflags[saMac]) != IsSHARED(papropSn->as_flags))
#else
                if ((mpsaflags[saMac] & NSSHARED) !=
                    (papropSn->as_flags & NSSHARED))
#endif
                {
                    // Don't pack SHARED with NONSHARED data segments

                    if (ggr == GRNIL)
                    {
                        // Not a members of any group - stop packing

                        segTop = segi - 1;
                        break;
                    }
                    else
                    {
                        // Issue error and continue

                        pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                        OutError(ER_shared, 1 + GetPropName(papropSn),
                                             1 + GetFarSb(pahte->cch));
                    }
                }
            }

            mpsegsa[segi] = saMac;      /* Assign phys. seg. to segment */

            /* Fix the flags */

#if EXE386
            if (IsCODEOBJ(mpsaflags[saMac]) && !IsCODEOBJ(papropSn->as_flags))
#else
            if((mpsaflags[saMac] & NSTYPE) != (papropSn->as_flags & NSTYPE))
#endif
            {                           /* If types do not agree */
                /* If packing code or data segs, stop current packing group.
                 * But allow program to explicitly group code and data.
                 */
                if(ggr == GRNIL)
                {
                    segTop = segi - 1;
                    break;
                }
#if EXE386
                else
                {
                    /* Issue warning and convert segment type */

                    WORD    warningKind;

                    if (IsCODEOBJ(papropSn->as_flags))
                        warningKind = ER_codeindata;
                    else
                        warningKind = ER_dataincode;

                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                        /* Get hash table entry */
                    OutWarn(warningKind, 1 + GetPropName(papropSn),
                                         1 + GetFarSb(pahte->cch));
                }
#else
                mpsaflags[saMac] &= (~NSSHARED & ~NSTYPE);
                mpsaflags[saMac] |= NSCODE;
                                        /* Set type to impure code */
#endif
            }
#if EXE386
            else if (!IsSHARED(papropSn->as_flags))
                mpsaflags[saMac] &= ~OBJ_SHARED;
#else
            else if(!(papropSn->as_flags & NSSHARED))
                mpsaflags[saMac] &= ~NSSHARED;
#endif
                                        /* Turn off pure bit if impure */
#if EXE386
            if (!IsREADABLE(papropSn->as_flags)) mpsaflags[saMac] &= ~OBJ_READ;
#else
#if O68K
            if((papropSn->as_flags & (NSMOVE | NSPRELOAD | NSEXRD)) !=
              (mpsaflags[saMac] & (NSMOVE | NSPRELOAD | NSEXRD)))
            {
                if(ggr == GRNIL)
                {
                    segTop = segi - 1;
                    break;
                }
                else
#else
            {
#endif
                {
                    if(!(papropSn->as_flags & NSMOVE))
                        mpsaflags[saMac] &= ~NSMOVE;
                                        /* Turn off movable bit if fixed */
                    if(papropSn->as_flags & NSPRELOAD)
                        mpsaflags[saMac] |= NSPRELOAD;
                                        /* Set preload bit if preloaded */
                    if (!(papropSn->as_flags & NSEXRD))
                        mpsaflags[saMac] &= ~NSEXRD;
                                        /* Turn off execute/read-only */
                }
            }
#endif

            /* Adjust alignment */

            align = (ALIGNTYPE) ((papropSn->as_tysn >> 5) & 7);
                                        /* Get alignment type */
            switch(align)               /* Switch on alignment type */
            {
                case ALGNWRD:           /* Word-aligned */
                  sacb = (sacb + 1) & ~1L;
                                        /* Round up size to word boundary */
                  break;
#if OMF386
                case ALGNDBL:           /* Double word-aligned */
                  sacb = (sacb + 3) & ~3L;      /* Round up to dword offset */
                  break;
#endif
                case ALGNPAR:           /* Paragraph-aligned */
                  sacb = (sacb + 0xF) & ~0xFL;
                                        /* Round up size to para boundary */
                  break;

                case ALGNPAG:           /* Page-aligned */
                  sacb = (sacb + 0xFF) & ~0xFFL;
                                        /* Round up size to page boundary */
                  break;
            }
            mpsegraFirst[segi] = sacb;
                                        /* Save offset of first byte */
            mpgsndra[mpseggsn[segi]] = sacb;
                                        /* Save offset of first byte */
            sacb += papropSn->as_cbMx;  /* Increment size of file segment */

#if NOT EXE386
            if(ggr != GRNIL)            /* If true group */
            {
                if (fMixed && !fUse16)
                {
                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                        /* Get hash table entry */
                    OutWarn(ER_mixgrp32, 1 + GetFarSb(pahte->cch));
                }
                if(sacb > LXIVK ||
                  (IsCodeFlg(mpsaflags[saMac]) && sacb > LXIVK - 36))
                {                       /* If group overflow or unreliable */
                    pahte = (AHTEPTR ) FetchSym(mpggrrhte[ggr],FALSE);
                                        /* Get hash table entry */
                    if(sacb > LXIVK)
                        Fatal(ER_grpovf,1 + GetFarSb(pahte->cch));
                    else
                        OutWarn(ER_codunsf,1 + GetFarSb(pahte->cch));
                }
            }
            else
#endif
                if(sacb > CurrentPackLim)/* Else if packing limit exceeded */
            {
                segTop = segi - 1;      /* Set top to last segment that fit */
                break;                  /* Break inner loop */
            }
            mpsacb[saMac] = sacb;       /* Update file segment size */
        }
#if NOT EXE386
        /*
         * Make DGROUP segment flags conform to auto data.  It is assumed
         * that all conflicts have been resolved earlier.
         */
        if(ggr == ggrDGroup)
        {
            if(vFlags & NESOLO) mpsaflags[saMac] |= NSSHARED;
            else if(vFlags & NEINST) mpsaflags[saMac] &= ~NSSHARED;
        }

#if FALSE
        if (IsDataFlg(mpsaflags[saMac]) && (mpsaflags[saMac] & NSEXPDOWN))
        {
            /* If this is data segment and NSEXPDOWN big is set - shitf it up */

            ShiftDelta = SEGTOPADDR - mpsacb[saMac];
            for (segi = seg; segi <= segTop; segi++)
            {
                mpsegraFirst[segi]       += ShiftDelta;
                mpgsndra[mpseggsn[segi]] += ShiftDelta;
            }
        }
#endif
#endif
        if(mpsacb[saMac] != 0L)
            ++saMac;

        seg = segTop;                   /* Set counter appropriately */
    }
    /* We haven't yet assigned absolute segments (it is assumed
    *  they are empty and are used only for addressing purposes),
    *  but now we must assign them somewhere.
    */
    segTop = segLast;                   /* Initialize */
    for(gsn = 1; gsn < gsnMac; ++gsn)   /* Loop to complete initialization */
    {
        papropSn = (APROPSNPTR ) FetchSym(mpgsnrprop[gsn],TRUE);
                                        /* Get symbol table entry */
        seg = mpgsnseg[gsn];            /* Get segment number */
        if(seg == SEGNIL)               /* If we have an absolute segment */
        {
            mpgsnseg[gsn] = ++segTop;   /* Assign a segment order number */
            mpsegsa[segTop] = (SATYPE) papropSn->as_cbMx;
                                        /* Assign absolute segs their loc. */
        }

        /* Define special symbols "_edata" and "_end" */

        if (fSegOrder)
            Define_edata_end(papropSn);
    }

    if (fSegOrder)
        Check_edata_end(0, 0);

#if O68K
    /* The Macintosh addresses data as a negative offset to the A5 register.
    This limits "near" data to within 32k of A5; "far" data is defined as
    anything beyond the 32k limit and requires special addressing to reach it.
    To fold this into the standard linker model, the Macintosh post-processor
    treats the first data segment as "near" data and all subsequent data
    segments as "far".  Thus, N data segments are arranged as follows:

        
        A5 ->   +----------+    High memory
                | DATA 0   |
                +----------+
                | DATA N   |
                +----------+
                | DATA N-1 |
                +----------+
                |    .     |
                |    .     |
                |    .     |
                +----------+
                | DATA 2   |
                +----------+
                | DATA 1   |
                +----------+    Low memory

    Consequently, we must calculate the displacment from the start of each data
    segment to its ultimate place in memory relative to A5. */

    if (iMacType != MAC_NONE)
    {
        RATYPE draDP;
        SATYPE sa;
        SATYPE saDataFirst;

        draDP = -((mpsacb[saDataFirst = mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]]]
          + 3L) & ~3L);
        mpsadraDP[saDataFirst] = draDP;

        for (sa = mpsegsa[segDataLast]; sa > saDataFirst; sa--)
            draDP = mpsadraDP[sa] = draDP - ((mpsacb[sa] + 3L) & ~3L);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newout3.c ===
/*
*   Copyright Microsoft Corporation 1986,1987
*
*   This Module contains Proprietary Information of Microsoft
*   Corporation and should be treated as Confidential.
*/
/*
 *  NEWOUT3.C
 *
 *  Functions to output DOS3 exe.
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <sys\types.h>
#include                <sys\stat.h>
#include                <newexe.h>


#define E_VERNO(x)      (x).e_sym_tab
#define IBWCHKSUM       18L
#define IBWCSIP         20L
#define CBRUN           sizeof(struct exe_hdr)
#define CBRUN_OLD       0x1e            /* Size of header for DOS 1, 2 & 3 */
#define EMAGIC          0x5A4D          /* Old magic number */

FTYPE                   parity;         /* For DOS3 checksum */
SEGTYPE                 segAdjCom = SEGNIL;  /* Segment moved by 0x100 in .com programs */

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

#if OVERLAYS
LOCAL void NEAR OutRlc(IOVTYPE iov);
#endif

#if QBLIB
LOCAL unsigned short NEAR SkipLead0(unsigned short seg);
LOCAL void NEAR FixQStart(long cbFix,struct exe_hdr *prun);
#endif



    /****************************************************************
    *                                                               *
    *  OutRlc:                                                      *
    *                                                               *
    *  This  function  writes  the  reloc  table  to the run file.  *
    *  NOTE:  relocation  table  entries  must  be a factor of the  *
    *  virtual memory page length.                                  *
    *                                                               *
    ****************************************************************/

#if OVERLAYS
LOCAL void NEAR         OutRlc(IOVTYPE iov)
{
    RUNRLC FAR          *pRlc;

    pRlc = &mpiovRlc[iov];
    WriteExe(pRlc->rgRlc, CBRLC*pRlc->count);
}
#endif

void                    OutHeader (prun)
struct exe_hdr          *prun;
{
    WriteExe(prun, E_LFARLC(*prun));
}

#if INMEM
#if CPU8086 OR CPU286
#include                <dos.h>
/*
 *  WriteExe : write() with a far buffer
 *
 *  Emulate write() except use a far buffer.  Call the system
 *  directly.
 *
 *  Returns:
 *      0 if error, else number of bytes written.
 */
LOCAL int               WriteExe (fh, buf, n)
int                     fh;             /* File handle */
char FAR                *buf;           /* Buffer to store bytes in */
int                     n;              /* # bytes to write */
{
#if OSMSDOS
#if CPU8086
    union REGS          regs;           /* Non-segment registers */
    struct SREGS        sregs;          /* Segment registers */

    regs.x.ax = 0x4000;
    regs.x.bx = fh;
    regs.x.cx = n;
    sregs.ds = FP_SEG(buf);
    sregs.es = sregs.ds;
    regs.x.dx = FP_OFF(buf);
    intdosx(&regs,&regs,&sregs);
    if(regs.x.cflag)
        return(0);
    return(regs.x.ax);
#else
ERROR
#endif
#endif /* OSMSDOS */
#if OSXENIX
    char                mybuf[PAGLEN];
    int                 cppage;
    char                *p;

    while(n > 0)
    {
        cppage = n > PAGLEN ? PAGLEN : n;
        for(p = mybuf; p < mybuf[cppage]; *p++ = *buf++);
        if(write(fh,mybuf,cppage) != cppage)
            return(0);
        n -= cppage;
    }
#endif
}
#else
#define readfar         read
#endif
extern WORD             saExe;

LOCAL void              OutExeBlock (seg1, segEnd)
{
    long                cb;
    unsigned            cbWrite;
    WORD                sa;
    FTYPE               parity;         /* 1 odd, 0 even */

    fflush(bsRunfile);
    parity = 0;
    cb = ((long)(mpsegsa[segEnd] - mpsegsa[seg1]) << 4) + mpsegcb[segEnd] +
        mpsegraFirst[segEnd];
    sa = saExe;
    while(cb)
    {
        if(cb > 0xfff0)
            cbWrite = 0xfff0;
        else
            cbWrite = cb;
        ChkSum(cbWrite,(BYTE FAR *)((long) sa << 16),parity);
        parity = parity ^ (cbWrite & 1);
        if(WriteExe(fileno(bsRunfile),(long)sa << 16,cbWrite) != cbWrite)
        {
            ExitCode = 4;
            Fatal(ER_spcrun);          /* Fatal error */
        }
        cb -= cbWrite;
        sa += 0xfff;
    }
}
#endif /* INMEM */

#if QBLIB
/*
 *      SkipLead0 : Output a segment, skipping leading zeroes
 *
 *      Count the number of leading 0s in the segment and write
 *      a word holding the count.  Then write the segment starting
 *      with the first nonzero byte.  Return number of leading 0s.
 *
 *      Parameters:
 *              seg     Segment number
 *      Returns:
 *              Number of leading 0s
 */
WORD NEAR               SkipLead0 (SEGTYPE seg)
{
    BYTE FAR            *pSegImage;     // Segment memory image
    long                cZero;          // Number of zero bytes at the begin of the segment
    WORD                cbSkip;         /* # bytes of leading 0s */
    DWORD               cbRemain;       // no-zero bytes


    // Initialize starting address

    pSegImage = mpsegMem[seg] + mpsegraFirst[seg];

    // Count zero bytes at segment start

    for (cZero = 0; cZero < mpsegcb[seg] && *pSegImage == 0; cZero++, pSegImage++)
        ;

    // If segment is 64K and entirely 0s, write 0 and 64k of zeros.

    if (cZero == mpsegcb[seg] && cZero == LXIVK)
    {
        cbSkip = 0;
        pSegImage = mpsegMem[seg] + mpsegraFirst[seg];
        cbRemain  = LXIVK;
    }
    else
    {
        cbSkip = (WORD) cZero;
        cbRemain = mpsegcb[seg] - cZero;
    }
    WriteExe((char FAR *)&cbSkip, CBWORD);
    WriteExe(pSegImage, cbRemain);
    return(cbSkip);
}

/*
 *      FixQStart : Fix up (patch) .QLB starting address
 *
 *      Parameters:
 *              cbFix   Number of bytes skipped (may be negative)
 *              prun    Pointer to DOS3 exe header
 *      ASSUMES:
 *              File pointer is at CS:IP.
 */
void NEAR               FixQStart (cbFix,prun)
long                    cbFix;
struct exe_hdr          *prun;
{
    /*
     * WARNNG:  dra must be long since it holds numbers in the range
     * -4 to 0x10000, inclusive.
     */
    long                dra;            /* Delta for raStart adjustment */
    SATYPE              saStart;        /* Initial CS */

    saStart = prun->e_cs;               /* Initialize */
    /*
     * Adjust initial CS:IP for .QLB's since it is used by loader
     * to point to symbol table, and all addresses are off by the
     * amount of leading 0s skipped. Luckily CS:IP comes right after
     * checksum so we don't have to seek.
     * First, normalize CS:IP downward if underflow will occur.
     */
    if((dra = cbFix - raStart) > 0)
    {
        raStart += (dra + 0xf) & ~0xf;
        saStart -= (SATYPE) ((dra + 0xf) >> 4);
    }
    /* Patch the header */
    OutWord((WORD) (raStart -= cbFix));
    OutWord(saStart);
}
#endif /*QBLIB*/

/*
 *  OutDos3Exe:
 *
 *  Output DOS3-format executable file.
 *  Called by OutRunfile.
 */
void NEAR               OutDos3Exe()
{
    SEGTYPE             seg;            /* Current segment */
    struct exe_hdr      run;            /* Executable header */
    WORD                cbPadding;      /* # bytes of padding */
    WORD                cb;             /* # bytes on last page */
    WORD                pn;             /* # pages */
    long                lfaPrev;        /* Previous file offset */
    RATYPE              ra;             /* Current address offset */
    SATYPE              sa;             /* Current address base */
    SEGTYPE             segIovFirst;    /* First segment in overlay */
    SEGTYPE             segFinaliov;    /* Last seg in overlay to output */
    SEGTYPE             segIovLast;     /* Last segment in overlay */
    long                cbDirectory;    /* # bytes in entire header */
    WORD                cparDirectory;  /* # para. in entire header */
    SEGTYPE             segStack;       /* Segment index of stack segment */
#if OVERLAYS
    IOVTYPE             iov;            /* Current overlay number */
#endif
#if FEXEPACK
    FTYPE               fSave;          /* Scratch var. */
#endif
    SATYPE              saStart;        /* Start of current segment */
    WORD                segcbDelta = 0; /* For /TINY segment size adjustment */
    WORD                fOrgStriped = FALSE;
                                        /* TRUE when 0x100 bytes striped */
    WORD                tmp;
#if OVERLAYS
    DWORD               ovlLfa;         /* Seek offset for overlay */
    DWORD               imageSize;      /* Overlay memory image size */
    DWORD               ovlRootBeg;     /* Seek offset to the begin of root memory image */
    WORD                ovlDataOffset;
#endif
#if QBLIB
    /* Count of bytes skipped in the load image must be a long since
     * it can be negative (if there were less than 4 leading 0s)
     * or greater than 0x8000.
     */
    long                cbSkip = 0;     /* # bytes skipped */
    extern SEGTYPE      segQCode;       /* .QLB code segment */
#endif

    if (fBinary)
    {
#if OVERLAYS
        if (fOverlays)
            Fatal(ER_swbadovl, "/TINY");
                                        /* Overlays not allowed in .COM */
#endif
        if (mpiovRlc[0].count)
            Fatal(ER_binary);           /* Run time relocations not allowed in .COM */
    }
    memset(&run,0,sizeof(run));         /* Clear everything in fixed header */
    E_MAGIC(run) = EMAGIC;              /* Magic number */
    if (vFlagsOthers & NENEWFILES || fDOSExtended)
    {
        /* DOS header is 0x40 bytes  long */

        E_LFARLC(run) = CBRUN;          /* Offset of loadtime relocations */
        if (vFlagsOthers & NENEWFILES)
            E_FLAGS(run) |= EKNOWEAS;
        if (fDOSExtended)
            E_FLAGS(run) |= EDOSEXTENDED;
    }
    else
    {
        /* DOS header is 0x1e bytes  long */

        E_LFARLC(run) = CBRUN_OLD;      /* Offset of loadtime relocations */
    }
    E_VERNO(run) = 1;                   /* DOS ver. for compatibility only */
    lfaPrev = 0L;
#if OVERLAYS
    for(iov = 0; iov < (IOVTYPE) iovMac; ++iov) /* Loop thru overlays */
    {
#endif
        /* Get size of overlay */

        cb = 0;
        pn = 0;
#if OVERLAYS
        /* Find lowest seg in overlay */

        for(seg = 1; seg <= segLast && mpsegiov[seg] != iov; ++seg)
#else
        seg = 1;
#endif
        /* If no overlay to output, we're done with this one.  */

        if(seg > segLast)
#if OVERLAYS
            continue;
#else
            return;
#endif
        /* Get starting address of lowest segment */

        segIovFirst = seg;
        ra = mpsegraFirst[seg];
        sa = mpsegsa[seg];

        /* Find the last segment in the overlay */

        segIovLast = SEGNIL;
        for(seg = segLast; seg; --seg)
        {
#if OVERLAYS
            if(mpsegiov[seg] == iov)
            {
#endif
                if(segIovLast == SEGNIL) segIovLast = seg;
                if(!cparMaxAlloc) break;
                if((mpsegFlags[seg] & FNOTEMPTY) == FNOTEMPTY) break;
#if OVERLAYS
            }
#endif
        }

        /* If no data in overlay, we're done with it.  */

        if(!seg)
#if OVERLAYS
            continue;
#else
            return;
#endif
        /* Get size in between 1st, last segs in this overlay */

        segFinaliov = seg;
        sa = mpsegsa[seg] - sa - 1;
        ra = mpsegraFirst[seg] - ra + 16;

        /* Normalize */

        sa += (SATYPE) (ra >> 4);
        ra &= 0xF;

        /* Take into account size of last segment */

        if(mpsegcb[seg] + ra < LXIVK)
            ra += (WORD) mpsegcb[seg];
        else
        {
            ra -= LXIVK - mpsegcb[seg];
            sa += 0x1000;
        }

        /* Normalize again */

        sa += (SATYPE) (ra >> 4);
        ra &= 0xF;

        /* Determine # pages, bytes on last page */

        pn = sa >> 5;
        cb = (WORD) (((sa << 4) + ra) & MASKRB);
        E_CBLP(run) = cb;
        if(cb)
        {
            cb = 0x200 - cb;
            ++pn;
        }

        /* If empty overlay, skip it */
#if OVERLAYS
        if(iov && !pn)
            continue;
#else
        if(!pn) return;
#endif
        vchksum = parity = 0;           /* Initialize check sum */
        if (segStart == SEGNIL)
        {
            if (fBinary)
                OutWarn(ER_comstart);
#if 0
            else
                OutWarn(ER_nostartaddr);
#endif
        }
        else if (mpsegiov[segStart] != IOVROOT)
            Fatal(ER_ovlstart);         /* Starting address can't be in overlay */

        E_CS(run) = mpsegsa[segStart];  /* Base of starting segment */
        E_IP(run) = (WORD) raStart;     /* Offset of starting procedure */
#if QBLIB
        /*
         * For .QLB, set minalloc field to an impossible amount to force
         * DOS3 loader to abort.
         */

        if(fQlib)
            E_MINALLOC(run) = 0xffff;
        else
#endif
        /* If no uninitialized segments, minalloc = 0 */

        if (segFinaliov == segIovLast)
            E_MINALLOC(run) = 0;
        else
        {
            /* Otherwise determine the minalloc value:  */
            /* sa:ra is end of overlay being output.  Find empty area size */

            sa = mpsegsa[segIovLast] - sa - 1;
            ra = mpsegraFirst[segIovLast] - ra + 0x10;

            /* Add in last segment size */

            if(mpsegcb[segIovLast] + ra < LXIVK) ra += mpsegcb[segIovLast];
            else
            {
                ra -= LXIVK - mpsegcb[segIovLast];
                sa += 0x1000;
            }

            /* Normalize */

            sa += (SATYPE) (ra >> 4);
            ra &= 0xF;

            /* Set field with min. no of para.s above image */

            E_MINALLOC(run) = (WORD) (sa + ((ra + 0xF) >> 4));

            /* If /HIGH not given, then cparmaxAlloc = max(maxalloc,minalloc) */

            if(cparMaxAlloc && E_MINALLOC(run) > cparMaxAlloc)
              cparMaxAlloc = E_MINALLOC(run);
        }
        E_MAXALLOC(run) = cparMaxAlloc;
#if OVERLAYS
        E_CRLC(run) = mpiovRlc[iov].count;
#else
        E_CRLC(run) = mpiovRlc[0].count;
#endif
        segStack = mpgsnseg[gsnStack];
        E_SS(run) = mpsegsa[segStack];
        E_SP(run) = (WORD) (cbStack + mpsegraFirst[segStack]);
        E_CSUM(run) = 0;
        E_CP(run) = pn;

        /* Get true size of header */

#if OVERLAYS
        cbDirectory = (long) E_LFARLC(run) + ((long) mpiovRlc[iov].count << 2);
#else
        cbDirectory = (long) E_LFARLC(run) + ((long) mpiovRlc[0].count << 2);
#endif
        /* Get padding needed for header */

        if (fBinary)
            cbPadding = 0;
        else
            cbPadding = (0x200 - ((WORD) cbDirectory & 0x1FF)) & 0x1FF;

        /* Pages in header */

        pn = (WORD)((cbDirectory + 0x1FF) >> 9);
        cparDirectory = pn << SHPNTOPAR;    /* Paragraphs in header */
        E_CPARHDR(run) = cparDirectory;     /* Store in header */
        E_CP(run) += pn;                    /* Add header pages to file size */
#if OVERLAYS
        E_OVNO(run) = iov;
#else
        E_OVNO(run) = 0;
#endif
        ovlLfa = ftell(bsRunfile);
        if (fBinary)
        {
            if (E_IP(run) != 0 && E_IP(run) != 0x100)
                OutWarn(ER_comstart);
        }
        else
            OutHeader(&run);
        /* Output relocation table.  Turn exepack off first.  */
#if FEXEPACK
        fSave = fExePack;
        fExePack = FALSE;
#endif
#if OVERLAYS
        if (!fBinary)
            OutRlc(iov);
#else
        if (!fBinary)
            OutRlc();
#endif
        /* Restore exepack */
#if FEXEPACK
        fExePack = fSave;
#endif
        /* Output padding */

        WriteZeros(cbPadding);
        ra = mpsegraFirst[segIovFirst]; /* Offset of first segment */
        sa = mpsegsa[segIovFirst];      /* Base of first segment */
#if INMEM
        if(saExe)
            OutExeBlock(segIovFirst,segFinaliov);
        else
#endif
        /* Loop through segs in overlay */

        if (!iov)
            ovlRootBeg = ftell(bsRunfile);
        for(seg = segIovFirst; seg <= segFinaliov; ++seg)
        {
#if OVERLAYS
            if(mpsegiov[seg] == iov)
            {
#endif
                /*
                 * Pad up to start of segment.  First determine destination
                 * segment address.  We could just use mpsegsa[seg] were it
                 * not for packcode.
                 */

                saStart = (SATYPE) (mpsegsa[seg] + (mpsegraFirst[seg] >> 4));
                tmp = 0;
                while(ra != (mpsegraFirst[seg] & 0xf) || sa < saStart)
                {
#if FEXEPACK
                    if (fExePack)
                        OutPack("\0", 1);
                    else
#endif
                        tmp++;
                    if(++ra > 0xF)
                    {
                        ra &= 0xF;
                        ++sa;
                    }
                    parity ^= 1;
                }
                if (!fExePack && tmp)
                    WriteZeros(tmp);

                /* Output the segment and update the address */
#if QBLIB
                /*
                 * If /QUICKLIB and segment is 1st in DGROUP or 1st code,
                 * skip leading 0s and adjust the count, less 2 for the
                 * count word.
                 */
                if(fQlib && (seg == mpgsnseg[mpggrgsn[ggrDGroup]] ||
                        seg == segQCode))
                    cbSkip += (long) SkipLead0(seg) - 2;
                else
#endif
                {
                    if (fBinary && !fOrgStriped && mpsegcb[seg] > 0x100)
                    {
                        /*
                         * For .Com files strip first 0x100 bytes
                         * from the first non-empyt segment
                         */

                        mpsegraFirst[seg] += E_IP(run);
                        mpsegcb[seg]      -= E_IP(run);
                        segcbDelta         = E_IP(run);
                        fOrgStriped        = TRUE;
                        segAdjCom = seg;
                    }
                    if (mpsegMem[seg])
                    {
#if FEXEPACK
                        if (fExePack)
                            OutPack(mpsegMem[seg] + mpsegraFirst[seg], mpsegcb[seg]);
                        else
#endif
                            WriteExe(mpsegMem[seg] + mpsegraFirst[seg], mpsegcb[seg]);
                        if (seg != mpgsnseg[gsnOvlData])
                            FFREE(mpsegMem[seg]);
                    }
                }
                mpsegcb[seg] += segcbDelta;
                segcbDelta = 0;

                sa += (WORD)(mpsegcb[seg] >> 4);
                ra += (WORD)(mpsegcb[seg] & 0xF);
                if(ra > 0xF)
                {
                    ra &= 0xF;
                    ++sa;
                }
#if OVERLAYS
            }
#endif
        }
#if FALSE
        if (!fBinary)
        {
            /* Complement checksum, go to checksum field and output it.  */

            vchksum = (~vchksum) & ~(~0 << WORDLN);
            fseek(bsRunfile,lfaPrev + IBWCHKSUM,0);
            OutWord(vchksum);
        }
#endif
#if QBLIB
        /*
         * If /QUICKLIB, patch the starting address which has been
         * invalidated by processing leading 0s.
         */
        if(fQlib)
        {
            // Seek to the CS:IP field
            fseek(bsRunfile,lfaPrev + IBWCSIP,0);
            FixQStart(cbSkip,&run);
        }
#endif
#if FEXEPACK
        /* Finish up with exepack stuff if necessary */
        if (fExePack)
        {
            EndPack(&run);
            cb = 0x1ff & (0x200 - E_CBLP(run)); /* Correct cb */
            fExePack = FALSE;                   /* In case of overlays */
        }
#endif
#if OVERLAYS
        /*
         * If not last overlay: return to end of file, pad to page boundary,
         * and get length of file.
         */

        fseek(bsRunfile,0L,2);
        if (iov != (IOVTYPE) (iovMac - 1))
        {
            while(cb--) OutByte(bsRunfile,'\0');
        }
        lfaPrev = ftell(bsRunfile);
        if (fDynamic)
        {
            // Update $$MPOVLLFA and $$MPOVLSIZE tables
            //
            // OVERLAY_DATA --> +-------------+
            //                  | DW  $$CGSN  |
            //                  +-------------+
            //                  | DW  $$COVL  |
            //                  +-------------+
            //                  | $$MPGSNBASE |
            //                  | osnMac * DW |
            //                  +-------------+
            //                  | $$MPGSNOVL  |
            //                  | osnMac * DW |
            //                  +-------------+
            //                  | $$MPOVLLFA  |
            //                  | iovMac * DD |
            //                  +-------------+
            //                  | $$MPOVLSIZE |
            //                  | iovMac * DD |
            //                  +-------------+

            vgsnCur = gsnOvlData;
            ovlDataOffset = 4 + (osnMac << 2) + iov * sizeof(DWORD);
            MoveToVm(sizeof(DWORD), (BYTE *) &ovlLfa, mpgsnseg[gsnOvlData], ovlDataOffset);
            ovlDataOffset += iovMac << 2;

            // Exclude the header size

            imageSize = ((DWORD) (E_CP(run) - (E_CPARHDR(run) >> SHPNTOPAR) - 1) << 9) + (E_CBLP(run) ? E_CBLP(run) : 512);
            imageSize = ((imageSize + 0xf) & ~0xf) >> 4;
            imageSize += E_MINALLOC(run);
            if ((imageSize<<4) > LXIVK && iov)
                Fatal(ER_ovl64k, iov);
            MoveToVm(sizeof(DWORD), (BYTE *) &imageSize, mpgsnseg[gsnOvlData], ovlDataOffset);
        }
    }
#endif
    if (E_MINALLOC(run) == 0 && E_MAXALLOC(run) == 0)
        OutError(ER_nosegdef);      /* No code or initialized data in .EXE */
    if (fDynamic)
    {
        // Patch $$MPOVLLFA and $$MPOVLSIZE table in the .EXE file

        seg = mpgsnseg[gsnOvlData];
        fseek(bsRunfile, ovlRootBeg + ((long) mpsegsa[seg] << 4), 0);
        WriteExe(mpsegMem[seg] + mpsegraFirst[seg], mpsegcb[seg]);
        FFREE(mpsegMem[seg]);
    }
    if (fExeStrSeen)
    {
        fseek(bsRunfile,0L,2);
        WriteExe(ExeStrBuf, ExeStrLen);
    }
#if SYMDEB
    if (fSymdeb)
    {
        if (fBinary)
        {
            /*
             * For .COM files CV info goes into separate file.
             */

            SBTYPE  sbDbg;          /* .DBG file name */
            AHTEPTR hte;            /* Hash table entry address */
            struct _stat fileInfo;


            _fstat(fileno(bsRunfile), &fileInfo);
            CloseFile(bsRunfile);
            hte = (AHTEPTR ) FetchSym(rhteRunfile,FALSE);
                                    /* Get run file name */
#if OSMSDOS
            if(hte->cch[2] != ':')
            {                       /* If no drive spec */
                sbDbg[1] = chRunFile;
                                    /* Use saved drive letter */
                sbDbg[2] = ':';     /* Put in colon */
                sbDbg[0] = '\002';  /* Set length */
            }
            else
                sbDbg[0] = '\0';    /* Length is zero */
            memcpy(&sbDbg[B2W(sbDbg[0]) + 1],&GetFarSb(hte->cch)[1],B2W(hte->cch[0]));
                                    /* Get name from hash table */
            sbDbg[0] += (BYTE)hte->cch[0];
                                    /* Fix length */
#else
            memcpy(sbDbg,GetFarSb(hte->cch),B2W(hte->cch[0]) + 1);
                                    /* Get name from hash table */
#endif
            UpdateFileParts(sbDbg, sbDotDbg);
                                    /* Force extension to .DBG */
            sbDbg[B2W(sbDbg[0]) + 1] = '\0';
                                    /* Null-terminate name */
            if((bsRunfile = fopen(&sbDbg[1], WRBIN)) == NULL)
                Fatal(ER_openw, &sbDbg[1]);

#if OSMSDOS
            setvbuf(bsRunfile,bigbuf,_IOFBF,sizeof(bigbuf));
#endif
            /* Write time stamp into .DBG file */

            WriteExe(&fileInfo.st_atime, sizeof(time_t));
        }
        OutDebSections();           /* Generate ISLAND sections */
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newpar.c ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/* Various tools, e.g. environment for libs. */

    /****************************************************************
    *                                                               *
    *                           NEWPAR.C                            *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL WORD NEAR TrailChar(unsigned char *psb,unsigned char b);



/*
 * SaveInput - save an input object module in the list if it's not
 *      already there
 *
 * RETURNS
 *      TRUE if module was saved
 *      FALSE if module was not saved
 */

WORD                    SaveInput(psbFile,lfa,ifh,iov)
BYTE                    *psbFile;       /* File name */
LFATYPE                 lfa;            /* File address */
WORD                    ifh;            /* Library number */
WORD                    iov;            /* Overlay number */
{
    APROPFILEPTR        papropFile;
    RBTYPE              rpropFilePrev;
#if OSXENIX
    FTYPE               fSave;
#endif
#if BIGSYM
    SBTYPE              sbFile;         /* Buffer to hold psbFile */
#endif

#if DEBUG                               /* If debugging on */
    fprintf(stderr,"File ");            /* Message */
    OutSb(stderr,psbFile);              /* File name */
    NEWLINE(stderr);                    /* Newline */
#endif                                  /* End debugging code */
    DEBUGVALUE(lfa);                    /* Debug info */
    DEBUGVALUE(ifh);                    /* Debug info */
    DEBUGVALUE(iov);                    /* Debug info */
#if OSMSDOS
    if(SbCompare(psbFile, (BYTE *) "\006VM.TMP", TRUE))
    {                                   /* If name given is VM.TMP */
        OutWarn(ER_vmtmp);
        return(FALSE);
    }
#endif
#if OSXENIX
    fSave = fIgnoreCase;
    fIgnoreCase = FALSE;
#endif
#if BIGSYM
    /* PsbFile is pointing to a VM buffer which may get flushed out
     * before PropSymLookup finds a match, in a very big symbol table.
     * So we copy it to a stack buffer first.
     */
    memcpy(sbFile,psbFile,B2W(psbFile[0]) + 1);
    psbFile = sbFile;
#endif
    papropFile = (APROPFILEPTR ) PropSymLookup(psbFile,ATTRFIL,TRUE);
#if OSXENIX
    fIgnoreCase = fSave;
#endif
    if(!vfCreated)
    {
        for(;;)
        {
            /* "If we have a library and we've seen this module before,
            *  ignore it."
            */
            DEBUGVALUE(papropFile->af_attr);
            if(papropFile->af_attr == ATTRNIL) break;
            DEBUGVALUE(papropFile->af_ifh);
            DEBUGVALUE(papropFile->af_lfa);
            if(papropFile->af_attr == ATTRFIL &&
              papropFile->af_ifh != FHNIL && papropFile->af_ifh == (char) ifh &&
              papropFile->af_lfa == lfa)
              return(FALSE);
            papropFile = (APROPFILEPTR ) FetchSym(papropFile->af_next,FALSE);
        }
        papropFile = (APROPFILEPTR ) PropAdd(vrhte,ATTRFIL);
    }
    /* Save virt address of 1st object.  If library with lfa = 0, it's
     * a load-library so consider it an object.
     */
    if(rhteFirstObject == RHTENIL && (ifh == FHNIL || lfa == 0))
        rhteFirstObject = vrhte;
                                        /* Save virt addr of 1st object */
#if ILINK
    /* allocate a module number for all modules */
    if (papropFile->af_imod == IMODNIL)
        papropFile->af_imod = ++imodCur; /* allocate a module number */
    papropFile->af_cont = 0;
    papropFile->af_ientOnt = 0;
#endif
    papropFile->af_rMod = 0;
    papropFile->af_lfa = lfa;
    papropFile->af_ifh = (char) ifh;
    papropFile->af_iov = (IOVTYPE) iov;
    papropFile->af_publics = 0L;
#if SYMDEB
    papropFile->af_cvInfo = NULL;
    papropFile->af_cCodeSeg = 0;
    papropFile->af_Code = NULL;
    papropFile->af_CodeLast = NULL;
    papropFile->af_publics = NULL;
    papropFile->af_Src = NULL;
    papropFile->af_SrcLast = NULL;
#endif
    papropFile->af_ComDat = 0L;
    papropFile->af_ComDatLast = 0L;
    rpropFilePrev = vrpropTailFile;
    vrpropTailFile = vrprop;
    if(!rprop1stFile) rprop1stFile = vrpropTailFile;
    else
    {
        papropFile = (APROPFILEPTR ) FetchSym(rpropFilePrev,TRUE);
        papropFile->af_FNxt = vrpropTailFile;
    }
    return(TRUE);
}

#if CMDMSDOS
/*
 *  TrailChar (pb, b)
 *
 *  Tells whether the final character of a length-prefixed string
 *  equals the single-byte character b.  Knows about ECS.
 *
 */

LOCAL WORD NEAR         TrailChar(psb,b)
REGISTER BYTE           *psb;           /* Pointer to length-prefixed string */
BYTE                    b;              /* Byte being tested for */
{
    REGISTER unsigned char
                        *pLast;         /* Pointer to last byte */

    pLast = (unsigned char *)&psb[B2W(psb[0])];
                                        /* Set pointer to last byte */

#ifdef _MBCS
    if (!IsLeadByte(pLast[-1]))
#elif ECS
    if (b <  0x40 || !IsLeadByte(pLast[-1]))
                                        /* b cannot be part of an ECS char */
#endif
        return(*pLast == b ? TRUE : FALSE);
#if ECS || defined(_MBCS)
    psb++;                              /* Skip length byte */
        /* In the following, psb is kept on a known character boundary */
    while (psb < pLast)
        if (IsLeadByte(*psb++))         /* If valid lead byte */
            psb++;                      /* Advance an extra byte */
    if (psb == pLast)                   /* If pLast on a char boundary */
        return(*pLast == b ? TRUE : FALSE);
    return(FALSE);                      /* pLast is 2nd byte of ECS char */
#endif /* ECS */
}
#endif /* OSMSDOS  OR CMDMSDOS */

#if CMDMSDOS
#if OSXENIX
#define fPath(s)        (IFind(s,CHPATH) != INIL)
#else
#define fPath(s)        (IFind(s,'\\') != INIL || IFind(s,'/') != INIL)
#endif

#pragma check_stack(on)

void NEAR               AddLibPath(i)   /* Add paths to library names */
WORD                    i;              /* Index */
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    WORD                j;              /* Index */
    SBTYPE              sbLib;          /* Library name */
    SBTYPE              sbTmp;          /* Temporary library name */

    /* Don't do anything if name is nil */
    if(mpifhrhte[i] == RHTENIL)
        return;
    ahte = (AHTEPTR ) FetchSym(mpifhrhte[i],FALSE);
                                        /* Fetch library name */
#if OSMSDOS
    if(IFind(GetFarSb(ahte->cch),':') == INIL && !fPath(GetFarSb(ahte->cch)))
#else
    if(!fPath(GetFarSb(ahte->cch)))
#endif
    {                                   /* If there is no path on the name */
        memcpy(sbLib,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Copy the name */
        sbLib[B2W(sbLib[0]) + 1] = '\0';/* Null-terminate the name */
        if(_access(&sbLib[1],0))         /* If file not in current directory */
        {
            for(j = 0; j < cLibPaths; ++j)
            {                           /* Look through default paths */
                memcpy(sbTmp,sbLib,B2W(sbLib[0]) + 1);
                                        /* Copy library name */
                ahte = (AHTEPTR ) FetchSym(rgLibPath[j],FALSE);
                                        /* Fetch a default path */
                UpdateFileParts(sbTmp,GetFarSb(ahte->cch));
                                        /* Apply file name */
                sbTmp[B2W(sbTmp[0]) + 1] = '\0';
                                        /* Null-terminate the name */
                if(!_access(&sbTmp[1],0))/* If the library exists */
                {
                    PropSymLookup(sbTmp,ATTRFIL,TRUE);
                                        /* Add to symbol table */
                    mpifhrhte[i] = vrhte;
                                        /* Make table entry */
                    break;              /* Exit the loop */
                }
            }
        }
    }
}

void NEAR               LibEnv()        /* Process LIB= environment variable */
{
    SBTYPE              sbPath;         /* Library search path */
    char FAR            *lpch;          /* Pointer to buffer */
    REGISTER BYTE       *sb;            /* Pointer to string */
    WORD                i;              /* Index */
#if OSMSDOS AND NOT CLIBSTD
    BYTE                buffer[512];    /* Environment value buffer */
    FTYPE               genv();         /* Get environment variable value */
#endif

#if OSMSDOS AND NOT CLIBSTD
    if(genv("LIB",buffer))              /* If variable set */
    {
        pb = buffer;                    /* Initialize */
#else
    if(lpszLIB != NULL)                 /* If variable set */
    {
#endif
        lpch = lpszLIB;
        sb = sbPath;                    /* Initialize */
        do                              /* Loop through environment value */
        {
            if(*lpch == ';' || *lpch == '\0')
            {                           /* If end of path specification */
                if(sb > sbPath)         /* If specification not empty */
                {
                    sbPath[0] = (BYTE)(sb - sbPath);
                                        /* Set length of path string */
                    if (*sb != ':' && !TrailChar(sbPath, CHPATH))
                    {                   /* Add path char if none */
                        *++sb = CHPATH;
                        sbPath[0]++;    /* Increment length */
                    }
                    AddLibrary(sbPath); /* Add path to list of defaults */
                    sb = sbPath;        /* Reset pointer */
                }
            }
            else
            {
                 *++sb = *lpch;         /* Else copy character to path */

                 // The names in linker are limited to 255 chars
                 // Check for length overflow
                 if (sb >= sbPath + sizeof(sbPath) - 1)
                 {
                    sbPath[sizeof(sbPath) - 1] = '\0';
                    OutError(ER_badlibpath, sbPath);
                    sb = sbPath;
                 }
            }
        }
        while(*lpch++ != '\0');         /* Loop until end of string */
    }
    for(i = 0; i < ifhLibMac; ++i) AddLibPath(i);
                                        /* Fix libraries from command line */
}
#endif /* #if (OSMSDOS OR OSXENIX) AND CMDMSDOS */

    /****************************************************************
    *                                                               *
    *  AddLibrary:                                                  *
    *                                                               *
    *  Add a library to the search list.  Check for duplicates and  *
    *  for too many libraries.                                      *
    *                                                               *
    ****************************************************************/

#if CMDMSDOS
void                    AddLibrary(psbName)
BYTE                    *psbName;       /* Name of library to add */
{
    AHTEPTR             ahteLib;        /* Pointer to hash table entry */
    SBTYPE              sbLib;          /* Library name */
#if OSMSDOS
    SBTYPE              sbCmp2;         /* Second name for comparison */
    SBTYPE              sbCmp1;         /* First name for comparison */
#endif
    WORD                i;              /* Index variable */

    /*
     * NOTE: It is assumed in this function that
     * psbName is not a pointer to a virtual memory
     * buffer, i.e., one may not pass a pointer
     * returned by FetchSym(), PropSymLookup(), etc.,
     * as the argument to this function.
     */
    if(!fDrivePass) PeelFlags(psbName); /* Process any flags */
    if(psbName[0])                      /* If name not null */
    {
#if OSMSDOS
        if(psbName[B2W(psbName[0])] == ':' || TrailChar(psbName, CHPATH))
#else
        if(TrailChar(psbName, CHPATH))
#endif
        {                             /* If path spec only */
            /*
             * Add an entry to the list of default paths.
             */
            if(cLibPaths >= IFHLIBMAX) return;
                                        /* Only so many paths allowed */
            if(PropSymLookup(psbName,ATTRNIL,FALSE) != PROPNIL) return;
                                        /* No duplicates allowed */
            PropSymLookup(psbName,ATTRNIL,TRUE);
                                        /* Install in symbol table */
            rgLibPath[cLibPaths++] = vrhte;
                                        /* Save virtual address */
            return;                     /* And return */
        }
#if OSMSDOS
        memcpy(sbCmp1,sbDotLib,5);      /* Default .LIB extension */
        UpdateFileParts(sbCmp1,psbName);/* Add extension to name */
        memcpy(sbLib,sbCmp1,B2W(sbCmp1[0]) + 1);
                                        /* Copy back name plus extension */
        UpdateFileParts(sbCmp1,(BYTE *) "\003A:\\");
                                        /* Force drive and path to "A:\" */
        for(i = 0; i < ifhLibMac; ++i)  /* Look at libraries in list now */
        {
            if(mpifhrhte[i] == RHTENIL) /* Skip if NIL */
                continue;
            ahteLib = (AHTEPTR ) FetchSym(mpifhrhte[i],FALSE);
                                        /* Fetch name */
            memcpy(sbCmp2,GetFarSb(ahteLib->cch),B2W(ahteLib->cch[0]) + 1);
                                        /* Copy it */
            UpdateFileParts(sbCmp2,(BYTE *) "\003A:\\");
                                        /* Force drive and path to "A:\" */
            if(SbCompare(sbCmp1,sbCmp2,TRUE)) return;
                                        /* Return if names match */
        }
        if(ifhLibMac >= IFHLIBMAX) Fatal(ER_libmax);
                                        /* Check for too many libraries */
        PropSymLookup(sbLib,ATTRFIL,TRUE);
                                        /* Add to symbol table */
#else
        memcpy(sbLib,sbDotLib,5);         /* Default .LIB extension */
        UpdateFileParts(sbLib,psbName); /* Add file name */
        if(PropSymLookup(sbLib,ATTRFIL,FALSE) != PROPNIL) return;
                                        /* Do not allow multiple definitions */
        if(ifhLibMac >= IFHLIBMAX) Fatal(ER_libmax);
                                        /* Check for too many libraries */
        PropSymLookup(sbLib,ATTRFIL,TRUE);
                                        /* Add to symbol table */
#endif /* #if OSMSDOS ... #else ... */
        mpifhrhte[ifhLibMac] = vrhte;   /* Make table entry */
        if(fDrivePass) AddLibPath(ifhLibMac);
                                        /* Fix library from object module */
        ++ifhLibMac;                    /* Increment counter */
    }
}
#pragma check_stack(off)

#endif /* CMDMSDOS */

#if CMDXENIX
void                    AddLibrary(psbName)
BYTE                    *psbName;       /* Name of library to add */
{
    SBTYPE              sbLib;          /* Library name */

    if(psbName[0])                      /* If name not null */
    {
        memcpy(sbLib,psbName,B2W(psbName[0]) + 1);
                                        /* Copy the library name */
        if(PropSymLookup(sbLib,ATTRFIL,FALSE) != PROPNIL) return;
                                        /* No duplicates allowed */
        if(ifhLibMac >= IFHLIBMAX) Fatal(ER_libmax);
                                        /* Check for too many libraries */
        PropSymLookup(sbLib,ATTRFIL,TRUE);
                                        /* Add to symbol table */
        mpifhrhte[ifhLibMac] = vrhte;   /* Make table entry */
        ++ifhLibMac;                    /* Increment counter */
    }
}
#endif /* CMDXENIX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newout5.c ===
/*
*       Copyright Microsoft Corporation, 1983-1989
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/*
 *    Segmented-Executable Format Output Module
 *
 *  Modifications:
 *
 *      23-Feb-1989 RB  Fix stack allocation when DGROUP is only stack.
 */

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Types and constants */
#include                <bndrel.h>      /* Relocation definitions */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <newexe.h>      /* New .EXE header definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <impexp.h>
#if NOT (WIN_NT OR DOSEXTENDER OR DOSX32) AND NOT WIN_3
#define INCL_BASE
#include                <os2.h>
#include                <basemid.h>
#if defined(M_I86LM)
#undef NEAR
#define NEAR
#endif
#endif

#define CBSTUBSTK       0x80            /* # bytes in stack of default stub */

extern unsigned char    LINKREV;        /* Release number */
extern unsigned char    LINKVER;        /* Version number */

LOCAL long              cbOldExe;       /* Size of image of old .EXE file */

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void NEAR CopyBytes(long cb);
LOCAL void NEAR OutSegTable(unsigned short *mpsasec);
LOCAL long NEAR PutName(long lfaimage, struct exe_hdr *hdr);
#define NAMESIZE        9               /* size of signature array */


void NEAR               PadToPage(align)
WORD                    align;          /* Alignment factor */
{
    REGISTER WORD       cb;             /* Number of bytes to write */

    align = 1 << align;                 /* Calculate page size */
    cb = align - ((WORD) ftell(bsRunfile) & (align - 1));
                                        /* Calculate needed padding */
    if (cb != align)                    /* If padding needed */
        WriteZeros(cb);
}

long NEAR               MakeHole(cb)
long                    cb;
{
    long                lfaStart;       /* Starting file address */

    lfaStart = ftell(bsRunfile);        /* Save starting address */
#if OSXENIX
    fseek(bsRunfile,cb,1);              /* Leave a hole */
#else
    WriteZeros(cb);
#endif
    return(lfaStart);                   /* Return starting file address */
}

LOCAL void NEAR         CopyBytes(cb)   /* Copy from bsInput to bsRunfile */
long                    cb;             /* Number of bytes to copy */
{
    BYTE                buffer[PAGLEN]; /* Buffer */

#if FALSE
    raChksum = (WORD) ftell(bsRunfile); /* Determine checksum relative offset */
#endif
    while(cb >= (long) PAGLEN)          /* While full buffers remain */
    {
        fread(buffer,sizeof(BYTE),PAGLEN,bsInput);
                                        /* Read */
        WriteExe(buffer, PAGLEN);       /* Write */
        cb -= (long) PAGLEN;            /* Decrement count of bytes */
    }
    if(cb != 0L)                        /* If bytes remain */
    {
        fread(buffer,sizeof(BYTE),(WORD) cb,bsInput);
                                        /* Read */
        WriteExe(buffer, (WORD) cb);    /* Write */
    }
}

#pragma check_stack(on)

BSTYPE                  LinkOpenExe(sbExe)
BYTE                    *sbExe;         /* .EXE file name */
{
    SBTYPE              sbPath;         /* Path */
    SBTYPE              sbFile;         /* File name */
    SBTYPE              sbDefault;      /* Default file name */
    char FAR            *lpch;          /* Pointer to buffer */
    REGISTER BYTE       *sb;            /* Pointer to string */
    BSTYPE              bsFile;         /* File handle */


#if OSMSDOS
#if WIN_NT
    memcpy(sbFile, sbExe, sbExe[0] + 1);
    sbFile[sbFile[0]+1] = '\0';
#else
    memcpy(sbFile,"\006A:.EXE",7);      /* Initialize file name */
    sbFile[1] += DskCur;                /* Use current drive */
    UpdateFileParts(sbFile,sbExe);      /* Use parts of name given */
#endif
#endif
    memcpy(sbDefault,sbFile,sbFile[0]+2);
                                        /* Set default file name */
    if((bsFile = fopen(&sbFile[1],RDBIN)) != NULL) return(bsFile);
                                        /* If file found, return handle */
#if OSMSDOS
    if (lpszPath != NULL)               /* If variable set */
    {
        lpch = lpszPath;
        sb = sbPath;                    /* Initialize */
        do                              /* Loop through environment value */
        {
            if(*lpch == ';' || *lpch == '\0')
            {                           /* If end of path specification */
                if(sb > sbPath)         /* If specification not empty */
                {
                    if (!fPathChr(*sb) && *sb != ':') *++sb = CHPATH;
                                        /* Add path char if none */
                    sbPath[0] = (BYTE)(sb - sbPath);
                                        /* Set length of path string */
                    UpdateFileParts(sbFile,sbPath);
                                        /* Use the new path spec */
                    if((bsFile = fopen(&sbFile[1],RDBIN)) != NULL)
                      return(bsFile);   /* If file found, return handle */
                    sb = sbPath;        /* Reset pointer */
                    memcpy(sbFile,sbDefault,sbDefault[0]+2);
                                        /* Initialize file name */
                }
            }
            else *++sb = *lpch;           /* Else copy character to path */
        }
        while(*lpch++ != '\0');           /* Loop until end of string */
    }
#endif
    return(NULL);                       /* File not found */
}


/*
 * Default realmode DOS program stub.
 */
LOCAL BYTE              DefStub[] =
{
    0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21, 0xb8,
    0x01, 0x4c, 0xcd, 0x21
};


void NEAR               EmitStub(void)  /* Emit old .EXE header */
{
    struct exe_hdr      exe;            /* Stub .EXE header */
    AHTEPTR             ahteStub;       /* File hash table entry */
    long                lfaimage;       /* File offset of old .EXE image */
#if MSGMOD
    unsigned            MsgLen;
    SBTYPE              Msg;            /* Message text */
    unsigned            MsgStatus;
    char                *pMsg;          /* Pointer to message text */
#endif
    SBTYPE              StubFileName;
#if OSMSDOS
    char                buf[512];       /* File buffer */
#endif

    /*
     *  Emit stub .EXE header
     */
    if (rhteStub != RHTENIL
#if ILINK
       || fQCIncremental
#endif
       )
    {
        /* If a stub has been supplied  or QC incremental link */

#if ILINK
        if (fQCIncremental)
        {
            strcpy(StubFileName, "\014ilinkstb.ovl");
        }
        else
        {
#endif
            ahteStub = (AHTEPTR ) FetchSym(rhteStub,FALSE);
                                        /* Get the stub file name */
            strcpy(StubFileName, GetFarSb(ahteStub->cch));
#if ILINK
        }
#endif
        StubFileName[StubFileName[0] + 1] = '\0';
        if((bsInput = LinkOpenExe(StubFileName)) == NULL)
                                        /* If file not found, quit */
            Fatal(ER_nostub, &StubFileName[1]);
#if OSMSDOS
        setvbuf(bsInput,buf,_IOFBF,sizeof(buf));
#endif
        xread(&exe,CBEXEHDR,1,bsInput); /* Read the header */
        if(E_MAGIC(exe) != EMAGIC)      /* If stub is not an .EXE file */
        {
            fclose(bsInput);            /* Close stub file */
            Fatal(ER_badstub);
                                        /* Print error message and die */
        }
        fseek(bsInput,(long) E_LFARLC(exe),0);
                                        /* Seek to relocation table */
        E_LFARLC(exe) = sizeof(struct exe_hdr);
                                        /* Change to new .EXE value */
        lfaimage = (long) E_CPARHDR(exe) << 4;
                                        /* Save offset of image */
        cbOldExe = ((long) E_CP(exe) << LG2PAG) - lfaimage;
                                        /* Calculate in-file image size */
        if(E_CBLP(exe) != 0) cbOldExe -= (long) PAGLEN - E_CBLP(exe);
                                        /* Diddle size for last page */
        E_CPARHDR(exe) = (WORD)((((long) E_CRLC(exe)*CBRLC +
          sizeof(struct exe_hdr) + PAGLEN - 1) >> LG2PAG) << 5);
                                        /* Calculate header size in para.s */
        E_RES(exe) = 0;                 /* Clear reserved word */
        E_CBLP(exe) = E_CP(exe) = E_MINALLOC(exe) = 0;
        E_LFANEW(exe) = 0L;             /* Clear words which will be patched */
        raChksum = 0;                   /* Set checksum offset */
        WriteExe(&exe, CBEXEHDR);       /* Write now, patch later */
        CopyBytes((long) E_CRLC(exe)*CBRLC);
                                        /* Copy relocations */
        PadToPage(LG2PAG);              /* Pad to page boundary */
        fseek(bsInput,lfaimage,0);      /* Seek to start of image */
#if ILINK
        if (fQCIncremental)
            cbOldExe -= PutName(lfaimage, &exe);
                                        /* Imbed .EXE file name into QC stubloader */
#endif
        CopyBytes(cbOldExe);            /* Copy the image */
        fclose(bsInput);                /* Close input file */
#if ILINK
        if (!fQCIncremental)
#endif
            PadToPage(LG2PAG);          /* Pad to page boundary */
        cbOldExe += ((long) E_MINALLOC(exe) << 4) +
          ((long) E_CPARHDR(exe) << 4); /* Add unitialized space and header */
        return;                         /* And return */
    }
    memset(&exe,0,sizeof(struct exe_hdr));/* Initialize to zeroes */
#if CPU286
    if(TargetOs==NE_WINDOWS)    /* Provide standard windows stub */
    {
        pMsg = GetMsg(P_stubmsgwin);
        MsgLen = strlen(pMsg);
        strcpy(Msg, pMsg);
    }
    else
    {
        MsgStatus = DosGetMessage((char far * far *) 0, 0,
                              (char far *) Msg, SBLEN,
                              MSG_PROT_MODE_ONLY,
                              (char far *) "OSO001.MSG",
                              (unsigned far *) &MsgLen);
         if (MsgStatus == 0)
         {
             /* Message retrieved from system file */
             Msg[MsgLen-1] = 0xd;               /* Append CR */
             Msg[MsgLen]   = 0xa;               /* Append LF */
             Msg[MsgLen+1] = '$';
             MsgLen += 2;
         }
         else
         {
         /* System message file is not present - use standard message */
#endif

#if MSGMOD
        if(TargetOs==NE_WINDOWS)      /* Provide standard windows stub */
        {
                pMsg = GetMsg(P_stubmsgwin);
        }
        else
        {
                pMsg = GetMsg(P_stubmsg);
        }
        MsgLen = strlen(pMsg);
        strcpy(Msg, pMsg);
#endif
#if CPU286
        }
    }
#endif

    E_MAGIC(exe) = EMAGIC;              /* Set magic number */
    E_MAXALLOC(exe) = 0xffff;           /* Default is all available mem */
    /* SS will be same as CS, SP will be end of image + stack */
#if MSGMOD
    cbOldExe = sizeof(DefStub) + MsgLen + CBSTUBSTK + ENEWEXE;
#else
    cbOldExe = sizeof(DefStub) + strlen(P_stubmsg) + CBSTUBSTK + ENEWEXE;
#endif
    E_SP(exe) = (WORD) ((cbOldExe  - ENEWEXE) & ~1);
    E_LFARLC(exe) = ENEWEXE;
    E_CPARHDR(exe) = ENEWEXE >> 4;
    raChksum = 0;                       /* Set checksum offset */
    WriteExe(&exe, CBEXEHDR);           /* Write the stub header */
    WriteExe(DefStub, sizeof(DefStub));
#if MSGMOD
    WriteExe(Msg, MsgLen);
#else
    WriteExe(P_stubmsg, strlen(P_stubmsg));
#endif
    PadToPage(4);                       /* Pad to paragraph boundary */
}

#pragma check_stack(off)

void NEAR               PatchStub(lfahdr, lfaseg)
long                    lfahdr;         /* File address of new header */
long                    lfaseg;         /* File address of first segment */
{
    long                cbTotal;        /* Total file size */
    WORD                cpTotal;        /* Pages total */
    WORD                cbLast;         /* Bytes on last page */
    WORD                cparMin;        /* Extra paragraphs needed */


    if (TargetOs == NE_WINDOWS
#if ILINK
        || fQCIncremental
#endif
       )
        cbTotal = lfaseg;               /* QC incremental linking or Windows app */
    else
        cbTotal = ftell(bsRunfile);     /* Get the size of the file */

    cpTotal = (WORD)((cbTotal + PAGLEN - 1) >> LG2PAG);
                                        /* Get the total number of pages */
    cbLast = (WORD) (cbTotal & (PAGLEN - 1));
                                        /* Get no. of bytes on last page */
    cbTotal = (cbTotal + 0x000F) & ~(1L << LG2PAG);
                                        /* Round to paragraph boundary */
    cbOldExe = (cbOldExe + 0x000F) & ~(1L << LG2PAG);
                                        /* Round to paragraph boundary */
    cbOldExe -= cbTotal;                /* Subtract new size from old */
    fseek(bsRunfile,(long) ECBLP,0);    /* Seek into header */
    raChksum = ECBLP;                   /* Set checksum offset */
    WriteExe(&cbLast, CBWORD);          /* Write no. of bytes on last page */
    WriteExe(&cpTotal, CBWORD);         /* Write number of pages */
    fseek(bsRunfile,(long) EMINALLOC,0);/* Seek into header */
    cparMin = (cbOldExe < 0L)? 0: (WORD)(cbOldExe >> 4);
                                        /* Min. no. of extra paragraphs */
    raChksum = EMINALLOC;               /* Set checksum offset */
    WriteExe(&cparMin, CBWORD);         /* Write no. of extra para.s needed */
    fseek(bsRunfile,(long) ENEWHDR,0);  /* Seek into header */
    raChksum = ENEWHDR;                 /* Set checksum offset */
    WriteExe(&lfahdr, CBLONG);          /* Write offset to new header */
}


#if NOT EXE386

    /****************************************************************
    *                                                               *
    *  OutSas:                                                      *
    *                                                               *
    *  This function  moves a  segment from virtual  memory to the  *
    *  run file.                                                    *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         OutSas(WORD *mpsasec)
{
    SATYPE              sa;             /* File segment number */
        DWORD           lfaseg;         /* File segment offset */


    if (saMac == 1)
    {
        OutWarn(ER_nosegdef);           /* No code or initialized data in .EXE */
        return;
    }

    for(sa = 1; sa < saMac; ++sa)       /* Loop through file segments */
    {
        if (mpsaRlc[sa] && mpsacbinit[sa] == 0L)
            mpsacbinit[sa] = 1L;        /* If relocs, must be bytes in file */
        if (mpsacbinit[sa] != 0L)       /* If bytes to write in file */
        {
            PadToPage(fileAlign);       /* Pad to page boundary */
                lfaseg = (ftell(bsRunfile) >> fileAlign);
            WriteExe(mpsaMem[sa], mpsacbinit[sa]);
                                        /* Output the segment */
            FFREE(mpsaMem[sa]);         // Free segment's memory
        }
        else
            lfaseg = 0L;                /* Else no bytes in file */

        if (mpsaRlc[sa])
            OutFixTab(sa);              /* Output fixups if any */

        if (lfaseg > 0xffffL)
            Fatal(ER_filesec);
        else
                mpsasec[sa] = (WORD)lfaseg;
    }

    ReleaseRlcMemory();
}


#pragma check_stack(on)

/*** PutName - put .EXE file name into QC stubloader
*
* Purpose:
*           PutName will imbed the outfile name (.EXE) into the stubloader
*           so that programs can load in DOS 2.x
*
* Input:
*           hdr      - pointer to stub loader .EXE header
*           lfaimage - start of the stub loader code in file
* Output:
*           Number of bytes copied to .EXE file
*
*************************************************************************/



LOCAL long NEAR     PutName(long lfaimage, struct exe_hdr *hdr)
{
    long            offset_to_filename;
    char            newname[NAMESIZE];
    char            oldname[NAMESIZE];
    SBTYPE          sbRun;              /* Executable file name */
    AHTEPTR         hte;                /* Hash table entry address */
    long            BytesCopied;
    WORD            i, oldlen;


    /* Calculate the offset to the filename data patch */

    offset_to_filename = (E_CPARHDR(*hdr) << 4) + /* paragraphs in header */
                         (E_CS(*hdr) << 4) +      /* start of cs adjusted */
                          E_IP(*hdr) -            /* offset into cs of ip */
                          NAMESIZE;               /* back up to filename  */

    /* Copy begin of stubloader */

    BytesCopied = offset_to_filename - lfaimage - 2;
    CopyBytes(BytesCopied);

    /* Read in the lenght and file name template and validate it */

    xread(&oldlen,  sizeof(unsigned int), 1, bsInput);
    xread(oldname, sizeof(char), NAMESIZE, bsInput);

    /* Does the name read match the signature */

    if (!(strcmp(oldname, "filename")))
    {
        hte = (AHTEPTR ) FetchSym(rhteRunfile,FALSE);
                                                  /* Get run file name */
        memcpy(sbRun, &GetFarSb(hte->cch)[1], B2W(hte->cch[0]));
                                                  /* Get name from hash table */
        sbRun[B2W(hte->cch[0])] = '\0';           /* Null-terminate name */
        memset(newname, 0, NAMESIZE);             /* Initialize to zeroes */

        /* Copy only the proper number of characters */

        for (i = 0; (i < NAMESIZE-1 && sbRun[i] && sbRun[i] != '.'); i++)
            newname[i] = sbRun[i];

        /* Write the length of name */

        WriteExe(&i, sizeof(WORD));

        /* Write the new name over the signature */

        WriteExe(newname, NAMESIZE);
        return(BytesCopied + NAMESIZE + 2);
    }
    WriteExe(&oldlen, sizeof(WORD));
    return(BytesCopied + 2);
}

#pragma check_stack(off)


    /****************************************************************
    *                                                               *
    *  OutSegTable:                                                 *
    *                                                               *
    *  This function outputs the segment table.                     *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         OutSegTable(mpsasec)
WORD                    *mpsasec;       /* File segment to sector address */
{
    struct new_seg      ste;            /* Segment table entry */
    SATYPE              sa;             /* Counter */

    for(sa = 1; sa < saMac; ++sa)       /* Loop through file segments */
    {
        NS_SECTOR(ste) = mpsasec[sa];   /* Set the sector number */
        NS_CBSEG(ste) = (WORD) mpsacbinit[sa];
                                        /* Save the "in-file" length */
        NS_MINALLOC(ste) = (WORD) mpsacb[sa];
                                        /* Save total size */
        NS_FLAGS(ste) = mpsaflags[sa];  /* Set the segment attribute flags */
        if (mpsaRlc[sa])
            NS_FLAGS(ste) |= NSRELOC;   /* Set reloc bit if there are relocs */
        WriteExe(&ste, CBNEWSEG);       /* Write it to the executable file */
    }
}



/*
 *      OutSegExe:
 *
 *  Outputs a segmented-executable format file.  This format is used
 *  by DOS 4.0 and later, and Windows.
 *  Called by OutRunfile.
 */

void NEAR               OutSegExe(void)
{
    WORD                sasec[SAMAX];   /* File segment to sector table */
    struct new_exe      hdr;            /* Executable header */
    SEGTYPE             segStack;       /* Stack segment */
    WORD                i;              /* Counter */
    long                lfahdr;         /* File address of new header */
    long                lfaseg;         /* File address of first segment */


    if (fStub
#if ILINK
        || fQCIncremental
#endif
        )
        EmitStub();
                                        /* Emit stub old .EXE header */
    /*
     *  Emit the new portion of the .EXE
     */
    memset(&hdr,0,sizeof(struct new_exe));/* Set to zeroes */
    NE_MAGIC(hdr) = NEMAGIC;            /* Set the magic number */
    NE_VER(hdr) = LINKVER;              /* Set linker version number */
    NE_REV(hdr) = LINKREV;              /* Set linker revision number */
    NE_CMOVENT(hdr) = cMovableEntries;  /* Set count of movable entries */
    NE_ALIGN(hdr) = fileAlign;          /* Set segment alignment field */
    NE_CRC(hdr) = 0;                    /* Assume CRC = 0 when calculating */
    if (((TargetOs == NE_OS2) || (TargetOs == NE_WINDOWS)) &&
#if O68K
        iMacType == MAC_NONE &&
#endif
        !(vFlags & NENOTP) && !(vFlags & NEAPPTYP))
    {
        if (TargetOs == NE_OS2)
            vFlags |= NEWINCOMPAT;
        else
            vFlags |= NEWINAPI;
    }
    if (gsnAppLoader)
        vFlags |= NEAPPLOADER;
    NE_FLAGS(hdr) = vFlags;             /* Set header flags */
    NE_EXETYP(hdr) = TargetOs;          /* Set target operating system */
    if (TargetOs == NE_WINDOWS)
        NE_EXPVER(hdr) = (((WORD) ExeMajorVer) << 8) | ExeMinorVer;
    NE_FLAGSOTHERS(hdr) = vFlagsOthers; /* Set other module flags */
    /*
     * If SINGLE or MULTIPLE DATA, then set the automatic data segment
     * from DGROUP.  If DGROUP has not been declared and we're not a
     * dynlink library then issue a warning.
     */
    if((NE_FLAGS(hdr) & NEINST) || (NE_FLAGS(hdr) & NESOLO))
    {
        if(mpggrgsn[ggrDGroup] == SNNIL)
        {
            if(!(vFlags & NENOTP))
                OutWarn(ER_noautod);
            NE_AUTODATA(hdr) = SANIL;
        }
        else NE_AUTODATA(hdr) = mpsegsa[mpgsnseg[mpggrgsn[ggrDGroup]]];
    }
    else NE_AUTODATA(hdr) = SANIL;      /* Else no auto data segment */
    if (fHeapMax)
    {
        if (NE_AUTODATA(hdr) != SANIL)
            NE_HEAP(hdr) = (WORD) (LXIVK - mpsacb[NE_AUTODATA(hdr)]-16);
        else                            /* Heap size = 64k - size of DGROUP - 16 */
            NE_HEAP(hdr) = 0xffff-16;
    }
    else
        NE_HEAP(hdr) = cbHeap;          /* Set heap allocation */
    NE_STACK(hdr) = 0;                  /* Assume no stack in DGROUP */
    if (vFlags & NENOTP)
        NE_SSSP(hdr) = 0L;              /* Libraries have no stack at all */
    else if (gsnStack != SNNIL)
    {
        /* If there is a stack segment definition */

        segStack = mpgsnseg[gsnStack];  /* Get stack segment number */
        /*
         * If stack segment is in DGROUP, adjust size of DGROUP down and
         * move stack allocation to ne_stack field, so it can be modified
         * after linking.  Only do this if DGROUP has more than just the
         * stack segment.
         */
        if (fSegOrder &&
            NE_AUTODATA(hdr) == mpsegsa[segStack] &&
            mpsacb[NE_AUTODATA(hdr)] > cbStack)
        {
            mpsacb[NE_AUTODATA(hdr)] -= cbStack;
            NE_STACK(hdr) = (WORD) cbStack;
            NE_SSSP(hdr) = (long) (NE_AUTODATA(hdr)) << WORDLN;
                                        /* SS:SP = DS:0 */
            if (fHeapMax)
            {
                /* If max heap - adjust heap size */

                if (NE_HEAP(hdr) >= (WORD) cbStack)
                    NE_HEAP(hdr) -= cbStack;
            }
        }
        else
            NE_SSSP(hdr) = cbStack + mpsegraFirst[segStack] +
                           ((long) mpsegsa[segStack] << WORDLN);
                                        /* Set initial SS:SP */
    }
    else                                /* Else assume stack is in DGROUP */
    {
        NE_SSSP(hdr) = (long) NE_AUTODATA(hdr) << WORDLN;
                                        /* SS:SP = DS:0 */
        NE_STACK(hdr) = (WORD) cbStack; /* Set stack allocation */
        if (fHeapMax)
        {
            /* If max heap - adjust heap size */

            if (NE_HEAP(hdr) >= (WORD) cbStack)
                NE_HEAP(hdr) -= cbStack;
        }
    }

    /* Check that auto data + heapsize <= 64K */

    if(NE_AUTODATA(hdr) != SNNIL)
        if(mpsacb[NE_AUTODATA(hdr)] +
           (long) NE_HEAP(hdr) +
           (long) NE_STACK(hdr) > LXIVK)
            OutError(ER_datamax);

    if (!(vFlags & NENOTP) && (segStart == 0))
      Fatal(ER_nostartaddr);

    NE_CSIP(hdr) = raStart + ((long) mpsegsa[segStart] << WORDLN);
                                        /* Set starting point */
    NE_CSEG(hdr) = saMac - 1;           /* Number of file segments */
    NE_CMOD(hdr) = ModuleRefTable.wordMac;
                                        /* Number of modules imported */
    lfahdr = MakeHole((long) sizeof(struct new_exe));
                                        /* Leave space for header */
    i = NE_CSEG(hdr)*sizeof(struct new_seg);
                                        /* Calc. size of Segment Table */
    NE_SEGTAB(hdr) = (WORD)(MakeHole((long) i) - lfahdr);
                                        /* Leave hole for segment table */
    NE_RSRCTAB(hdr) = NE_SEGTAB(hdr) + i;
                                        /* Offset of Resource Table */
    NE_RESTAB(hdr) = NE_RSRCTAB(hdr);   /* Offset of Resident Name Table */
    NE_MODTAB(hdr) = NE_RESTAB(hdr);
#if OUT_EXP
     /* Convert Res and Non Resident Name Tables to uppercase
        and write export file */
    ProcesNTables(bufExportsFileName);
#endif
    if (ResidentName.byteMac)
    {
        ByteArrayPut(&ResidentName, sizeof(BYTE), "\0");
        WriteByteArray(&ResidentName);  /* If we have Resident Name Table */
                                        /* Output table with null at end */
        NE_MODTAB(hdr) += ResidentName.byteMac;
        FreeByteArray(&ResidentName);
    }
                                        /* Calc. offset of Module Ref Table */
    WriteWordArray(&ModuleRefTable);
                                        /* Output the Module Reference Table */
    NE_IMPTAB(hdr) = NE_MODTAB(hdr) + ModuleRefTable.wordMac * sizeof(WORD);
    FreeWordArray(&ModuleRefTable);
                                        /* Calc offset of Imported Names Tab */
    NE_ENTTAB(hdr) = NE_IMPTAB(hdr);    /* Minimum offset of Entry Table */
    if (ImportedName.byteMac > 1)       /* If Imported Names Table not empty */
    {
        WriteByteArray(&ImportedName);  /* Output the Imported Names Table */
        NE_ENTTAB(hdr) += ImportedName.byteMac;
        FreeByteArray(&ImportedName);
                                        /* Add in length of table */
    }
#if NOT QCLINK
#if ILINK
    if (!fQCIncremental)
#endif
        OutEntTab();                    /* Output the Entry Table */
#endif
    NE_CBENTTAB(hdr) = EntryTable.byteMac;
                                        /* Set size of Entry Table */
    FreeByteArray(&EntryTable);
    NE_NRESTAB(hdr) = ftell(bsRunfile);
    ByteArrayPut(&NonResidentName, sizeof(BYTE), "\0");
    WriteByteArray(&NonResidentName);   /* Output table with null at end */
    NE_CBNRESTAB(hdr) = NonResidentName.byteMac;
    FreeByteArray(&NonResidentName);
                                        /* Size of non-resident name table */
    lfaseg = ftell(bsRunfile);          /* Remember where segment data starts in file */
    OutSas(sasec);                      /* Output the file segments */
    PatchStub(lfahdr, lfaseg);          /* Patch stub header */
    if(cErrors || fUndefinedExterns) NE_FLAGS(hdr) |= NEIERR;
                                        /* If errors, set error bit */
    fseek(bsRunfile,lfahdr,0);          /* Seek to beginning of header */
    raChksum = (WORD) lfahdr;           /* Set checksum offset */
    WriteExe(&hdr, CBNEWEXE);           /* Write the header */
    OutSegTable(sasec);                 /* Write the segment table */
    fseek(bsRunfile,lfahdr+NECRC,0);    /* Seek into new header */
    NE_CRC(hdr) = chksum32;             /* Must copy, else chksum32 trashed */
    WriteExe((BYTE FAR *) &NE_CRC(hdr), CBLONG);
                                        /* Write the checksum */
    fseek(bsRunfile, 0L, 2);            /* Go to end of file */
    if (fExeStrSeen)
        WriteExe(ExeStrBuf, ExeStrLen);
#if SYMDEB
    if (fSymdeb)
    {
#if ILINK
        if (fIncremental)
            PadToPage(fileAlign);       /* Pad to page boundary for ILINK */
#endif
        OutDebSections();               /* Generate ISLAND sections */
    }
#endif
}

#endif /* NOT EXE386 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newstr.c ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                           NEWSTR.C                            *
    *                                                               *
    *  Routines concerning filenames, strings.                      *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types, constants, macros */
#include                <bndtrn.h>      /* More of the same */
#include                <bndrel.h>      /* More of the same */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <extern.h>      /* External declarations */
#include                <undname.h>

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL unsigned short NEAR Find(unsigned char *s1,
                                unsigned char b,
                                unsigned short n);
LOCAL void NEAR DelimParts(unsigned char *psb,
                           unsigned short *pi1,
                           unsigned short *pi2,
                           unsigned short *pi3);



    /****************************************************************
    *                                                               *
    *  Find:                                                        *
    *                                                               *
    *  This function takes as its arguments a byte pointer s1, and  *
    *  a BYTE b, and a WORD n.  It  scans  at  most n  bytes of s1  *
    *  looking  for  an  occurrence  of  b.  If it  finds  one, it  *
    *  returns its offset from the beginning of s1, and if it does  *
    *  not, it returns the value INIL.                              *
    *                                                               *
    ****************************************************************/

LOCAL WORD NEAR         Find(s1,b,n)    /* Find matching byte */
REGISTER BYTE           *s1;            /* Pointer to a byte string */
BYTE                    b;              /* Search target */
WORD                    n;              /* Length of s1 */
{
    REGISTER WORD       i;              /* Counter */
    i = 0;                              /* Initialize */
#if ECS
    if (b < 0x40)                       /* b cannot be part of ECS  */
    {
#endif
        while(n--)                      /* While not at end of string */
        {
            if(*s1++ == b) return(i);   /* If match found, return position */
            ++i;                        /* Increment counter */
        }
        return(INIL);                   /* No match */
#if ECS
    }
#endif

#if ECS || defined(_MBCS)
    /* We have to worry about ECS */
    while(n--)
    {
        if(*s1++ == b) return(i);
        ++i;
        if (IsLeadByte(s1[-1]))         /* If we were on a lead byte */
        {                               /* Advance an extra byte */
            s1++;
            i++;
            n--;
        }
    }
    return(INIL);                       /* No match */
#endif /* ECS */
}

WORD                    IFind(sb,b)
BYTE                    *sb;            /* Pointer to length-prefixed string */
BYTE                    b;              /* Search target */
{
    return(Find(&sb[1],b,B2W(sb[0])));  /* Call Find() to do the work */
}

    /****************************************************************
    *                                                               *
    *  BreakLine:                                                   *
    *                                                               *
    *  This  function takes as its  arguments an SBTYPE, a pointer  *
    *  to  a function, and a  character  used  as a delimiter.  It  *
    *  It parses the SBTYPE, applying  the given function to every  *
    *  substring delimited by  the given  delimiter.  The function  *
    *  does not return a meaningful value.                          *
    *                                                               *
    ****************************************************************/

void                    BreakLine(psb,pfunc,sepchar)
BYTE                    *psb;           /* String to parse */
void                    (*pfunc)(BYTE *);/* Function pointer */
char                    sepchar;        /* Delimiter */
{
    SBTYPE              substr;         /* Substring */
    REGISTER WORD       ibeg;           /* Index variable */
    REGISTER WORD       ilen;           /* Substring length */

    ibeg = 1;                           /* Initialize */
    while(ibeg <= B2W(psb[0]))          /* While not at end of string */
    {
        ilen = Find(&psb[ibeg],sepchar,(WORD)(B2W(psb[0]) - ibeg + 1));
                                        /* Get index of sepchar in string */
        if(ilen == INIL) ilen = B2W(psb[0]) - ibeg + 1;
                                        /* Len is all that's left if no sep */
        memcpy(&substr[1],&psb[ibeg],ilen);
                                        /* Copy substring into substr */
        substr[0] = (BYTE) ilen;        /* Store the length */
        ibeg += ilen + 1;               /* Skip over substring and delimiter */
        (*pfunc)(substr);               /* Call the specified function */
    }
}

#pragma check_stack(on)

    /****************************************************************
    *                                                               *
    *  UpdateFileParts:                                             *
    *                                                               *
    *  "Inherit  file pieces  from a  master template  and specify  *
    *  missing  Update.  Inherit  four  pieces: disk  drive, path,  *
    *  file name, extension."                                       *
    *                                                               *
    *  Inputs:  psbOld          pointer to "old sb  that specifies  *
    *                           pieces of a file name."             *
    *           psbUpdate       pointer to "new pieces."            *
    *                                                               *
    *  Output:  psbOld          "updated   to    reflect   missing  *
    *                           update."                            *
    *                                                               *
    ****************************************************************/

void                    UpdateFileParts(psbOld,psbUpdate)
BYTE                    *psbOld;        /* Name to be updated */
BYTE                    *psbUpdate;     /* The update */
{
    char                oldDrive[_MAX_DRIVE];
    char                oldDir[_MAX_DIR];
    char                oldFname[_MAX_FNAME];
    char                oldExt[_MAX_EXT];
    char                updDrive[_MAX_DRIVE];
    char                updDir[_MAX_DIR];
    char                updFname[_MAX_FNAME];
    char                updExt[_MAX_EXT];
    char                *newDrive;
    char                *newDir;
    char                *newFname;
    char                *newExt;
    char                newPath[_MAX_PATH];
    int                 newPathLen;


    psbOld[psbOld[0]+1] = '\0';
    _splitpath(&psbOld[1], oldDrive, oldDir, oldFname, oldExt);
    psbUpdate[psbUpdate[0]+1] = '\0';
    _splitpath(&psbUpdate[1], updDrive, updDir, updFname, updExt);

    // Select components of the updated file path

    if (updDrive[0] != '\0')
        newDrive = updDrive;
    else
        newDrive = oldDrive;
    if ((updDir[0] != '\0') && !(updDir[0] == '/' && updDir[1] == '\0'))
        newDir = updDir;   /* This above is a fix for bug # 46        */
    else
        newDir = oldDir;

    // If newDir points to UNC name then forget about drive spec

    if ((newDir[0] == '\\') && (newDir[1] == '\\'))
        newDrive = NULL;

    if (updFname[0] != '\0')
        newFname = updFname;
    else
        newFname = oldFname;
    if (updExt[0] != '\0')
        newExt = updExt;
    else
        newExt = oldExt;

    _makepath(newPath, newDrive, newDir, newFname, newExt);
    newPathLen = strlen(newPath);
    if (newPathLen > SBLEN - 1)
        newPathLen = SBLEN - 1;
    memcpy(&psbOld[1], newPath, newPathLen);
    psbOld[0] = (BYTE) newPathLen;
    if (newPathLen < SBLEN - 1)
        psbOld[newPathLen + 1] = '\0';
    else
    {
        psbOld[SBLEN - 1] = '\0';
        OutWarn(ER_fntoolong, psbOld + 1);
        fflush(stdout);
    }
}

#pragma check_stack(off)

#if OVERLAYS OR SYMDEB
/*
 *  StripDrivePath (sb)
 *
 *  Strip drive and path from a filename.
 *  Return pointer to new name, minus drive and path (if any).
 */
BYTE                    *StripDrivePath(sb)
BYTE                    *sb;            /* Length-prefixed filename */
{
    StripPath(sb);                      /* Strip path from name */
    if (sb[2] != ':')                   /* If there is no drive */
        return(sb);                     /* return it as is */
    sb[2] = (BYTE) ((sb[0]) - 2);       /* Adjust length byte, move it */
    return(&sb[2]);                     /* Return minus drive */
}
#endif


    /****************************************************************
    *                                                               *
    *  SbCompare:                                                   *
    *                                                               *
    *  Compares two length-prefixed strings.  Returns true if they  *
    *  match.                                                       *
    *                                                               *
    *  NOTE: When comparison is case-insensitive note that letters  *
    *  will match  regardless  of case, but, in addition, '{' will  *
    *  match '[', '|' will match '\',  '}'  will  match  ']',  and  *
    *  '~' will match '^'.                                          *
    *                                                               *
    *  NOTE:  This routine does not know about DBCS.                *
    *                                                               *
    ****************************************************************/

WORD                    SbCompare(ps1,ps2,fncs)
REGISTER BYTE           *ps1;           /* Pointer to symbol */
REGISTER BYTE           *ps2;           /* Pointer to symbol */
WORD                    fncs;           /* True if not case-sensitive */
{
    WORD                length;         /* No. of char.s to compare */

    if(*ps1 != *ps2) return(FALSE);     /* Lengths must match */
    length = B2W(*ps1);                 /* Get length */
    if (!fncs)                          /* If case-sensitive */
    {                                   /* Simple string comparison */
        while (length && (*++ps1 == *++ps2))
            length--;
        return(length ? FALSE : TRUE);  /* Success iff nothing left */
    }
    while(length--)
    {
        if(*++ps1 == *++ps2) continue;  /* Bytes match */
        if((*ps1 & 0137) != (*ps2 & 0137)) return(FALSE);
    }
    return(TRUE);                       /* They match */
}


#if OSEGEXE
    /****************************************************************
    *                                                               *
    *  SbUcase:                                                     *
    *                                                               *
    *  Force a length-prefixed string to upper case.                *
    *  Does not check for punctuation characters.                   *
    *                                                               *
    ****************************************************************/

void                    SbUcase(sb)
REGISTER BYTE           *sb;    /* Length-prefixed string */
{
    REGISTER int        length;

#ifdef _MBCS
    sb[B2W(sb[0])+1] = '\0';
    _mbsupr (sb + 1);
#else
    /* Loop through symbol, changing lower to upper case.  */
    for(length = B2W(*sb++); length > 0; --length, ++sb)
    {
#if ECS
        /* If lead byte character, skip two bytes */
        if(IsLeadByte(*sb))
        {
            --length;
            ++sb;
            continue;
        }
#endif
        if(*sb >= 'a' && *sb <= 'z')
            *sb -= 'a' - 'A';
    }
#endif
}
#endif


/*
 *  SbSuffix:
 *
 *  Tell if one length-prefixed string is a suffix of another.
 */

FTYPE               SbSuffix(sb,sbSuf,fIgnoreCase)
REGISTER BYTE       *sb;            /* String */
REGISTER BYTE       *sbSuf;         /* Suffix */
WORD                fIgnoreCase;    /* True if case is to be ignored */
{
    WORD            suflen;         /* Suffix length */

    /* Get suffix length.  If longer than string, return false.  */
    suflen = B2W(sbSuf[0]);
    if(suflen > B2W(sb[0])) return(FALSE);
    /*
     * Point to end of suffix and end of string.  Loop backwards
     * until mismatch or end of suffix.
     */
    sbSuf = &sbSuf[suflen];
    sb = &sb[B2W(sb[0])];
    while(suflen--)
    {
        if(!fIgnoreCase)
        {
            if(*sb-- != *sbSuf--) return(FALSE);
        }
        else if((*sb-- | 0x20) != (*sbSuf-- | 0x20)) return(FALSE);
    }
    return((FTYPE) TRUE);
}

#if NEWSYM
#if !defined( M_I386 ) && !defined( _WIN32 )
/*** GetFarSb - copy a far length-prefixed string
*
* Purpose:
*   Copy a far length-prefixed string into a near static buffer.
*   Terminate with null byte.
*   Return a pointer to the the buffer.
*
* Input:
*   psb          - pointer to the far string
*
* Output:
*   Pointer to the near buffer.
*
* Exceptions:
*   None.
*
* Notes:
*   Don't call this function twice in the row to get two far strings,
*   because the second call will overwite the first string.
*
*************************************************************************/

char                    *GetFarSb(BYTE FAR *lpsb)
{
    static BYTE         sb[SBLEN+1];    /* 1 extra for the null byte */


    sb[0] = lpsb[0];
    FMEMCPY((BYTE FAR *) &sb[1], &lpsb[1], B2W(lpsb[0]));
    if (sb[0] + 1 < sizeof(sb))
        sb[sb[0] + 1] = 0;              /* Some routines expect a terminating 0 */
    else
        sb[SBLEN] = 0;
    return(sb);
}
#endif
#endif


    /****************************************************************
    *                                                               *
    *  ProcObject:                                                  *
    *                                                               *
    *  This function takes as its  argument a pointer to a length-  *
    *  prefixed string  containing the name of an object file.  It  *
    *  processes that file name.  It does not  return a meaningful  *
    *  value.                                                       *
    *                                                               *
    ****************************************************************/

void                    ProcObject(psbObj)/* Process object file name */
REGISTER BYTE           *psbObj;        /* Object file name */
{
    SBTYPE              sbFile;         /* File name */
#if OVERLAYS
    FTYPE               frparen;        /* True if trailing paren found */
    FTYPE               flparen;        /* True if leading paren found */
#endif
#if CMDMSDOS
    BYTE                sbExt[5];
#endif

#if OVERLAYS
    if(psbObj[B2W(psbObj[0])] == ')')   /* If trailing parenthesis found */
    {
        frparen = (FTYPE) TRUE;         /* Set flag true */
        --psbObj[0];                    /* Delete parenthesis */
    }
    else frparen = FALSE;               /* Else set flag false */
    if(psbObj[0] && psbObj[1] == '(')   /* If leading parenthesis found */
    {
        flparen = (FTYPE) TRUE;         /* Set flag true */
        psbObj[1] = (BYTE) (psbObj[0] - 1);/* Delete parenthesis */
        ++psbObj;
    }
    else flparen = FALSE;               /* Else set flag false */
#endif
#if CMDMSDOS
    PeelFlags(psbObj);                  /* Process flags, if any */
#if OVERLAYS
    if(psbObj[B2W(psbObj[0])] == ')')   /* If trailing parenthesis found */
    {
        if(frparen) Fatal(ER_nstrpar);
                                        /* Cannot nest parentheses */
        frparen = (FTYPE) TRUE;         /* Set flag true */
        --psbObj[0];                    /* Delete parenthesis */
    }
#endif
#endif
#if OVERLAYS
    if(flparen)                         /* If leading parenthesis */
    {
        if(fInOverlay) Fatal(ER_nstlpar);
                                        /* Check if in overlay already */
        fInOverlay = (FTYPE) TRUE;      /* Set flag */
        fOverlays = (FTYPE) TRUE;       /* Set flag */
    }
#endif
    if(psbObj[0])                       /* If object name length not zero */
    {
#if DEBUG                               /* If debugging on */
        fprintf(stderr,"  Object ");    /* Message */
        OutSb(stderr,psbObj);           /* File name */
        NEWLINE(stderr);                /* Newline */
#endif                                  /* End debugging code */
#if CMDMSDOS
        memcpy(sbFile,sbDotObj,5);      /* Put extension in sbFile */
        UpdateFileParts(sbFile,psbObj); /* Add extension to name */
#endif
#if CMDXENIX
        memcpy(sbFile,psbObj,B2W(psbObj[0]) + 1);
                                        /* Leave name unchanged */
#endif
#if CMDMSDOS
        /* If file has extension ".LIB" then save it as a library
         * from which all modules will be extracted.
         */
        sbExt[0] = 4;
        memcpy(sbExt+1,&sbFile[B2W(sbFile[0])-3],4);
        if (SbCompare(sbExt, sbDotLib, TRUE))
        {
            if(ifhLibMac >= IFHLIBMAX) Fatal(ER_libmax);
            /* Mark name pointer nil so library won't be searched.  */
            mpifhrhte[ifhLibMac] = RHTENIL;
            SaveInput(sbFile,0L,ifhLibMac++,(WORD)(fInOverlay? iovMac: 0));
        }
        else
#endif
        SaveInput(sbFile,0L,(WORD) FHNIL,(WORD)(fInOverlay? iovMac: 0));
                                        /* Save input file name and address */
    }
#if OVERLAYS
    if(frparen)                         /* If trailing parenthesis */
    {
        if(!fInOverlay) Fatal(ER_unmrpar);
                                        /* Check parentheses */
        fInOverlay = FALSE;             /* No longer specifying overlay */
        if(++iovMac > IOVMAX) Fatal(ER_ovlmax);
                                        /* Increment overlay counter */
    }
#endif
}

/*
 *  fPathChr (ch)
 *
 *  Tells whether or not a given character is a path character.
 *
 */

FTYPE           fPathChr(ch)
char            ch;
{
#if OSXENIX
    if (ch == '/')
#else
    if (ch == '/' || ch == '\\')
#endif
        return((FTYPE) TRUE);
    return(FALSE);
}


/*** UndecorateSb - undecorate name
*
* Purpose:
*   Undecorate length prefixed name.
*
* Input:
*   sbSrc - length prefixed decorated name
*   sbDst - length prefixed undecorated name
*   cbDst - size of sbDst
*
* Output:
*   If undecoration is successfull the sbDst contains undecorated
*   C++ name, else the sbSrc is copied to the sbDst.
*
* Exceptions:
*   None.
*
* Notes:
*   None.
*
*************************************************************************/

void            UndecorateSb(char FAR *sbSrc, char FAR *sbDst, unsigned cbDst)
{
    char FAR    *pUndecor;
    unsigned    len;


    // Make sure that decorated string is zero-terminated

    if (sbSrc[0] < sizeof(SBTYPE))
        sbSrc[sbSrc[0] + 1] = '\0';
    else
        sbSrc[sizeof(SBTYPE) - 1] = '\0';

    pUndecor = __unDName(NULL, (pcchar_t) &sbSrc[1], 0, &malloc, &free, 0);

    if (pUndecor == NULL)
    {
        // Undecorator failed

        FMEMCPY(sbDst, sbSrc, sbSrc[0] + 1);
    }
    else
    {
        // Add length to the undecorated name

        len = FSTRLEN(pUndecor);
        len = cbDst - 2 >= len ? len : cbDst - 2;
        FMEMCPY(&sbDst[1], pUndecor, len);
        sbDst[0] = (BYTE) len;
        sbDst[len + 1] = '\0';
        FFREE(pUndecor);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newpri.c ===
/* SCCSID = @(#)newpri.c        4.7 86/09/23 */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/

/* MAP file printer */

    /****************************************************************
    *                                                               *
    *                            NEWPRI.C                           *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>      /* Types and constants */
#include                <bndtrn.h>      /* Basic type & const declarations */
#include                <bndrel.h>      /* Types and constants */
#include                <lnkio.h>       /* Linker I/O definitions */
#include                <lnkmsg.h>      /* Error messages */
#include                <newexe.h>
#include                <extern.h>      /* External declarations */
#include                <impexp.h>
#if EXE386
#include                <exe386.h>
#endif
#include                <undname.h>

#define parent(i)       (((i) - 1) >> 1)/* Parent of i */
#define lchild(i)       (((i) << 1) + 1)/* Left child of i */
#define rchild(i)       (((i) << 1) + 2)/* Right child of i */
#define isleft(i)       ((i) & 1)       /* True if i is a left child */

RBTYPE                  *mpsymrbExtra;  /* Sort table for extra symbols */
RBTYPE                  *ompsymrb;      /* Stack-allocated sort table */
WORD                    stkMax;         /* Max # of symbols on stack */

LOCAL FTYPE             fGrps;          /* True if there are groups */

/*
 *  LOCAL FUNCTION PROTOTYPES
 */

LOCAL void NEAR ChkMapErr(void);
LOCAL void NEAR PrintOne(BYTE *sbName,
                         APROPNAMEPTR apropName);
LOCAL void NEAR PrintProp(RBTYPE rb,
                          FTYPE attr);
LOCAL void NEAR PrintSyms(WORD irbMac,
                          FTYPE attr);
LOCAL void      SaveHteSym(APROPNAMEPTR prop,
                           RBTYPE rhte,
                           RBTYPE rprop,
                           WORD fNewHte);
LOCAL void NEAR PutSpaces(int HowMany);
LOCAL void NEAR HdrExport(FTYPE attr);
LOCAL void NEAR ShowExp(AHTEPTR ahte,
                        RBTYPE rprop);
LOCAL void NEAR PrintExps(WORD irbMac,
                          FTYPE attr);
LOCAL void NEAR HdrName(FTYPE attr);
LOCAL void NEAR HdrValue(FTYPE attr);
LOCAL void NEAR PrintContributors(SNTYPE gsn);

#if AUTOVM
extern BYTE FAR * NEAR  FetchSym1(RBTYPE rb, WORD Dirty);
#define FETCHSYM        FetchSym1
#else
#define FETCHSYM        FetchSym
#endif



LOCAL void NEAR         ChkMapErr(void)
{
    if (ferror(bsLst))
    {
        ExitCode = 4;
        Fatal(ER_spclst);               /* Fatal error */
    }
}


LOCAL void NEAR         PrintOne(sbName,apropName)
BYTE                    *sbName;        /* Symbol name */
REGISTER APROPNAMEPTR   apropName;      /* Symbol definition record pointer */
{
    SBTYPE              sbImp;          /* Import name */
    SATYPE              sa;             /* Symbol base */
    RATYPE              ra;             /* Symbol offset */
    SEGTYPE             seg;            /* Segment number */
    BYTE FAR            *pb;
#if EXE386
typedef struct impMod
{
    DWORD   am_Name;            // Imported module name
    RBTYPE  am_1stImp;          // Head of imported names list
    RBTYPE  am_lastImp;         // Tail of imported names list
    DWORD   am_count;           // Module number/count of imports
}
            IMPMOD;

    DWORD               entry;
    IMPMOD              *curMod;        // Imported module
#else
    WORD                entry;
#endif
    WORD                module;
    WORD                flags;
    SNTYPE              gsn;
#if NOT OIAPX286
    APROPSNPTR          papropSn;
    SATYPE              saGroup;
#endif
    SBTYPE              sbUndecor;


    /*
     *  Store all needed fields in local variables, because
     *  page containing symbol definition record can be
     *  swapped out.
     */

    ra     = apropName->an_ra;
    gsn    = apropName->an_gsn;
    flags  = apropName->an_flags;
#if OSEGEXE
#if EXE386
    entry  = apropName->an_name;
#else
    entry  = apropName->an_entry;
#endif
    module = apropName->an_module;
#endif

    if(gsn)                             /* If not absolute symbol */
    {
        seg = mpgsnseg[gsn];            /* Get segment number */
        sa = mpsegsa[seg];              /* Get base value */
#if NOT OIAPX286
        if(!fNewExe && seg <= segLast)
        {
            papropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsn],
                                                 FALSE);
            if(papropSn->as_ggr != GRNIL)
            {
                saGroup = mpsegsa[mpgsnseg[mpggrgsn[papropSn->as_ggr]]];
                ra += (sa - saGroup) << 4;
                sa = saGroup;
            }
        }
#endif
    }
    else sa = 0;                        /* Else no base */
    if (flags & FUNREF)
    {
        sa = 0;
        ra = 0L;
    }
#if EXE386
    fprintf(bsLst," %04X:%08lX",sa,ra);
#else
#if O68K
    if (f386 || f68k)
#else
    if (f386)
#endif
        fprintf(bsLst," %04X:%08lX",sa,ra);
    else
        fprintf(bsLst," %04X:%04X",sa, (WORD) ra);
#endif
                                        /* Write address */
#if OSEGEXE
    if (fNewExe && (flags & FIMPORT))
            fputs("  Imp  ",bsLst);     /* If public is an import */
    else
#endif
         if (flags & FUNREF)
        fputs("  Unr  ", bsLst);
    else if ((!gsn || seg > segLast))
        fputs("  Abs  ",bsLst);         /* Segment type */
#if OVERLAYS
    else if (fOverlays)
    {
        if(mpsegiov[seg] != IOVROOT)
            fputs("  Ovl  ",bsLst);
        else
            fputs("  Res  ",bsLst);
    }
#endif
    else
        PutSpaces(7);
    OutSb(bsLst,sbName);                /* Output the symbol */
#if NOT WIN_NT
    if (fFullMap && sbName[1] == '?')
    {
        fputs("\n", bsLst);
        UndecorateSb(sbName, sbUndecor, sizeof(sbUndecor));
#if EXE386
        PutSpaces(24);
#else
#if O68K
        if (f386 || f68k)
#else
        if (f386)
#endif
            PutSpaces(24);
        else
            PutSpaces(20);
#endif
        OutSb(bsLst, sbUndecor);
        fputs("\n", bsLst);
#if OSEGEXE
        if (fNewExe && flags & FIMPORT)
            PutSpaces(24);
#endif
    }
#endif
#if OSEGEXE
    if (fNewExe && flags & FIMPORT)
    {                                   /* If public is an import */
        PutSpaces(20 - B2W(sbName[0])); /* Space fill */

        /* Print the module name */

#if EXE386
        // Get known import module descriptor

        curMod = (IMPMOD *) mapva(AREAMOD + module * sizeof(IMPMOD), FALSE);
        strcpy(&sbImp[1], mapva(AREAIMPMOD + curMod->am_Name, FALSE));
                                        /* Get module name */
        sbImp[0] = (BYTE) strlen((char *) &sbImp[1]);
#else

        pb = &(ImportedName.rgByte[ModuleRefTable.rgWord[module-1]]);
        FMEMCPY(sbImp, pb, pb[0] + 1);
#endif
        fputs(" (",bsLst);              /* Print module name */
        OutSb(bsLst,sbImp);
        if(!(flags & FIMPORD))
        {                               /* If not imported by ordinal */
            /* Print the entry name */
#if EXE386
            strnset((char *) sbImp, '\0', sizeof(sbImp));
            vmmove(sizeof(sbImp) - 1, &sbImp[1], AREAIMPS + entry + sizeof(WORD), FALSE);
            sbImp[0] = (BYTE) strlen((char *) &sbImp[1]);
            fputc('!',bsLst);
#else
            pb = &(ImportedName.rgByte[entry]);
            FMEMCPY(sbImp, pb, pb[0]+1);
            fputc('.',bsLst);
#endif
            OutSb(bsLst,sbImp);
            fputc(')',bsLst);
        }
        else
            fprintf(bsLst,".%u)",entry);
                                        /* Else print entry number */
        NEWLINE(bsLst);
        return;
    }
#endif /* OSEGEXE */
#if OVERLAYS
    if (fOverlays && gsn && seg <= segLast && mpsegiov[seg] != IOVROOT)
        fprintf(bsLst," (%XH)",mpsegiov[seg]);
#endif
    NEWLINE(bsLst);
    ChkMapErr();
}
/*
 *  PrintProp:
 *
 *  Print a symbol, given a virtual property address or hash table
 *  entry.  Called by PrintSyms.
 */

LOCAL void NEAR         PrintProp (rb, attr)
RBTYPE                  rb;
ATTRTYPE                attr;           /* Symbol attribute */
{
#if NOT NEWSYM
    APROPNAMETYPE       apropName;      /* Buffer for symbol def */
#endif
    AHTEPTR             pahte;  /* Pointer to hash table entry */
    APROPPTR            paprop; /* Pointer to property cell */
    SBTYPE              sbName;         /* Public symbol text */
    RBTYPE              rprop;          /* Property cell virtual address */


    paprop = (APROPPTR ) FETCHSYM(rb,FALSE);
                                        /* Fetch property cell from VM */
    if(paprop->a_attr == ATTRNIL)       /* If we have a hash table entry */
    {
        pahte = (AHTEPTR ) paprop;      /* Recast pointer */
        memcpy(sbName,GetFarSb(pahte->cch),B2W(pahte->cch[0]) + 1);
                                        /* Copy the symbol */
        paprop = (APROPPTR ) FETCHSYM(pahte->rprop,FALSE);
                                        /* Get pointer to property list */
        while(paprop->a_attr != ATTRNIL)
        {                               /* Look through properties */
            rprop = paprop->a_next;     /* Save link to next cell */
            if(paprop->a_attr == attr)
            {                           /* If match found */
#if NEWSYM
                PrintOne(sbName,(APROPNAMEPTR)paprop);
#else
                memcpy(&apropName,paprop,CBPROPNAME);
                                        /* Copy record from virtual memory */
                PrintOne(sbName,&apropName);
                                        /* Print the symbol entry */
#endif
            }
            paprop = (APROPPTR ) FETCHSYM(rprop,FALSE);
                                        /* Try next in list */
        }
        return;                         /* Done */
    }
#if NOT NEWSYM
    memcpy(&apropName,paprop,CBPROPNAME);
                                        /* Save record in buffer */
#endif
    while(paprop->a_attr != ATTRNIL)    /* Find symbol */
        paprop = (APROPPTR ) FETCHSYM(paprop->a_next,FALSE);

    pahte = (AHTEPTR ) paprop;  /* Recast pointer */
    memcpy(sbName,GetFarSb(pahte->cch),B2W(pahte->cch[0]) + 1);
                                        /* Copy the symbol */
    /* Print the symbol entry */
#if NEWSYM
    PrintOne(sbName,(APROPNAMEPTR)FETCHSYM(rb,FALSE));
#else
    PrintOne(sbName,&apropName);
#endif
}

    /****************************************************************
    *                                                               *
    *  PrintSyms:                                                   *
    *                                                               *
    ****************************************************************/

LOCAL void NEAR         PrintSyms(irbMac,attr)
WORD                    irbMac;         /* Table size */
ATTRTYPE                attr;           /* Symbol attribute */
{
    WORD                x;              /* Sort table index */


    for (x = irbMac; x > 0; x--)
        PrintProp(ExtractMin(x), attr);
}


    /***************************************************************
    *                                                               *
    *  SavePropSym:                                                 *
    *                                                               *
    ****************************************************************/

void                    SavePropSym(APROPNAMEPTR prop,
                                    RBTYPE       rhte,
                                    RBTYPE       rprop,
                                    WORD         fNewHte)
{
    if(prop->an_attr != ATTRPNM || (prop->an_flags & FPRINT))
    {                                   /* If printable, save ptr to info */
        Store(rprop);
    }
    return;
}

    /****************************************************************
    *                                                               *
    *  SaveHteSym:                                                  *
    *                                                               *
    ****************************************************************/

LOCAL void              SaveHteSym(APROPNAMEPTR prop,
                                   RBTYPE       rhte,
                                   RBTYPE       rprop,
                                   WORD         fNewHte)
{
    if(fNewHte && (prop->an_attr != ATTRPNM || (prop->an_flags & FPRINT)))
    {                                   /* If first time and printable */
        Store(rhte);
    }
    return;
}

/*
 *  FGtAddr:
 *
 *  Compare addresses of symbols pointed to by rb1 and rb2.  Return
 *  -1, 0, or 1 as the address of rb1 is less than, equal to, or greater
 *  than the address of rb2.
 */
int cdecl               FGtAddr(const RBTYPE *rb1, const RBTYPE *rb2)
{
    APROPNAMEPTR        paprop; /* Property cell pointer */
    REGISTER SEGTYPE    seg1;           /* Segment number */
    REGISTER SEGTYPE    seg2;
    WORD                sa1;            /* Segment base */
    WORD                sa2;
    RATYPE              ra1;
    RATYPE              ra2;
    DWORD               ibMem1;         /* Memory address */
    DWORD               ibMem2;



    paprop = (APROPNAMEPTR ) FETCHSYM(*rb1,FALSE);
                                        /* Fetch from VM */
    seg1 = paprop->an_gsn? mpgsnseg[paprop->an_gsn]: SEGNIL;
                                        /* Get segment number */
    sa1 = seg1 != SEGNIL? mpsegsa[seg1]: 0;
                                        /* Get frame number */
    ra1 = paprop->an_ra;

    paprop = (APROPNAMEPTR ) FETCHSYM(*rb2,FALSE);
                                        /* Fetch from VM */
    seg2 = paprop->an_gsn? mpgsnseg[paprop->an_gsn]: SEGNIL;
                                        /* Get segment number */
    sa2 = seg2 != SEGNIL? mpsegsa[seg2]: 0;
                                        /* Get frame number */
    ra2 = paprop->an_ra;
#if OXOUT OR OIAPX286
    if(seg1 != SEGNIL && seg2 != SEGNIL)
    {
        if((mpsegFlags[seg1] & FCODE) &&
          !(mpsegFlags[seg2] & FCODE)) return(-1);
                                        /* Code before data */
        if((mpsegFlags[seg2] & FCODE) &&
          !(mpsegFlags[seg1] & FCODE)) return(1);
                                        /* Data after code */
    }
#endif
#if OVERLAYS
    if(fOverlays && seg1 != SEGNIL && seg2 != SEGNIL)
    {
        if(mpsegiov[seg1] > mpsegiov[seg2]) return(1);
        if(mpsegiov[seg2] > mpsegiov[seg1]) return(-1);
    }
#endif
#if OSEGEXE
    if (fNewExe)
    {
#if EXE386
        if (sa1 == sa2)
        {
            ibMem1 = ra1;
            ibMem2 = ra2;
        }
        else
            ibMem1 = ibMem2 = 0L;
#else
        ibMem1 = ((long) sa1 << 16) + ra1;
        ibMem2 = ((long) sa2 << 16) + ra2;
#endif
    }
    else
    {
#endif
        ibMem1 = ((long) sa1 << 4) + ra1;
        ibMem2 = ((long) sa2 << 4) + ra2;
#if OSEGEXE
    }
#endif
#ifdef LATER
    if ((sa1 != 0 || sa2 != 0) && (sa1 != 0xa9 || sa2 != 0xa9))
        fprintf(stderr, "%x:%x %x:%x (%d)\r\n", sa1, paprop1->an_ra,
            sa2, paprop2->an_ra, (ibMem1 > ibMem2) ? 1 :
            ((ibMem1 < ibMem2) ? -1 : 0));
#endif /*!LATER*/
    if (ibMem1 < ibMem2) return(-1);
    if (ibMem1 > ibMem2) return(1);
#if EXE386
    if (sa1 < sa2) return(-1);
    if (sa1 > sa2) return(1);
#endif
    return(0);
}

/*
 *  FGtName:
 *
 *  Compare names of two symbols pointed to by rb1 and rb2.  Return
 *  -1, 0, 1 as the name of rb1 is alphabetically less than, equal to,
 *  or greater than the name of rb2.
 *  Ignore case.
 */
int cdecl               FGtName(const RBTYPE *rb1, const RBTYPE *rb2)
{
    AHTEPTR             pahte1; /* Hash table pointer */
    AHTEPTR             pahte2;
    REGISTER BYTE       *ps1;           /* Pointer to first symbol */
    REGISTER BYTE FAR   *ps2;           /* Pointer to second symbol */
    WORD                len1;           /* Symbol length */
    WORD                len2;           /* Symbol length */
    WORD                length;         /* No. of char.s to compare */
    int                 value;          /* Comparison value */



    pahte1 = (AHTEPTR ) FETCHSYM(*rb1,FALSE);
                                        /* Fetch from VM */
    ps1 = GetFarSb((BYTE FAR *) pahte1->cch);
                                        /* Get pointer to first */

    pahte2 = (AHTEPTR ) FETCHSYM(*rb2,FALSE);
                                        /* Fetch from VM */
    ps2 = (BYTE FAR *) pahte2->cch;     /* Get pointer to second */
    if((len1 = B2W(*ps1)) < (len2 = B2W(*ps2))) length = len1;
    else length = len2;                 /* Get smallest length */
    while(length--)                     /* While not at end of symbol */
        if(value = (*++ps1 & 0137) - (*++ps2 & 0137))
            return(value < 0 ? -1 : 1);
    if(len1 < len2)
        return(-1);
    if(len1 > len2)
        return(1);
    return(0);
}

#if OWNSORT
/*
 *  An implementation of heapsort follows.  It is only used if
 *  quicksort() from the runtime library is not used.
 */
LOCAL                   reheap(a,n,i)   /* Reheapify */
RBTYPE                  *a;             /* Array to reheapify */
WORD                    n;              /* Size of array */
REGISTER WORD           i;              /* Subtree to start with */
{
    REGISTER WORD       j;              /* Index */
    RBTYPE              t;              /* Temporary */

    for(; (j = rchild(i)) < n; i = j)   /* Loop through array */
    {
        if((*cmpf)(&a[i],&a[j]) > 0 && (*cmpf)(&a[i],&a[j - 1]) > 0) return;
                                        /* Done if subtree is heap */
        if((*cmpf)(&a[j - 1],&a[j]) > 0) --j; /* Pick "greater" child */
        t = a[i];                       /* Swap parent and child */
        a[i] = a[j];
        a[j] = t;
    }
    if(--j < n && (*cmpf)(&a[j],&a[i]) > 0)   /* If swap needed */
    {
        t = a[i];                       /* Swap parent and child */
        a[i] = a[j];
        a[j] = t;
    }
}

LOCAL                   heap(a,n)       /* Heapify */
RBTYPE                  *a;             /* Array to heapify */
WORD                    n;              /* Size of array */
{
    REGISTER WORD       k;              /* Index to "kid" */
    REGISTER WORD       p;              /* Index to "parent" */
    RBTYPE              t;              /* Temporary */

    if(n && (k = n - 1))                /* If there are kids */
    {
        if(isleft(k))                   /* If youngest kid an only child */
        {
            p = parent(k);              /* Find the parent */
            if((*cmpf)(&a[k],&a[p]) > 0)      /* If swap necessary */
            {
                t = a[k];               /* Swap parent and kid */
                a[k] = a[p];
                a[p] = t;
            }
            --k;                        /* Index a righty */
        }
        while(k)                        /* While there are parents */
        {
            p = parent(k);              /* Find the parent */
            if((*cmpf)(&a[k],&a[p]) > 0 || (*cmpf)(&a[k - 1],&a[p]) > 0)
            {                         /* If a kid is "greater" */
                t = a[p];               /* Swap parent... */
                if((*cmpf)(&a[k],&a[k - 1]) > 0)
                {                     /* ...with "greater" kid */
                    a[p] = a[k];
                    a[k] = t;
                    reheap(a,n,k--);    /* And reheapify */
                }
                else
                {
                    a[p] = a[--k];
                    a[k] = t;
                    reheap(a,n,k);      /* And reheapify */
                }
            }
            else --k;                   /* Point at left kid */
            --k;                        /* Point at right kid */
        }
    }
}
#endif /* OWNSORT */


    /****************************************************************
    *                                                               *
    *  PrintGroupOrigins:                                           *
    *                                                               *
    ****************************************************************/

void                    PrintGroupOrigins(APROPNAMEPTR papropGroup,
                                          RBTYPE       rhte,
                                          RBTYPE       rprop,
                                          WORD         fNewHte)
{
    AHTEPTR             hte;
    APROPGROUPPTR       pGroup;

    pGroup = (APROPGROUPPTR) papropGroup;
    if (mpggrgsn[pGroup->ag_ggr] != SNNIL)
    {                                   /* If group has members */
        if (!fGrps)                     /* If no groups yet */
        {
            fputs(GetMsg(MAP_group), bsLst);
                                        /* Header */
            fGrps = (FTYPE) TRUE;       /* Yes, there are groups */
        }
        fprintf(bsLst," %04X:0   ", mpsegsa[mpgsnseg[mpggrgsn[pGroup->ag_ggr]]]);
                                        /* Write the group base */
        hte = (AHTEPTR ) FETCHSYM(rhte,FALSE);
                                        /* Fetch group name */
        OutSb(bsLst,GetFarSb(hte->cch));/* Output name */
        NEWLINE(bsLst);
        ChkMapErr();
    }
}

#if OSEGEXE
LOCAL void NEAR         HdrExport(ATTRTYPE attr)
{
    ASSERT(attr == ATTREXP);            /* Must be an export */
    fputs(GetMsg(MAP_expaddr), bsLst);
#if EXE386
    PutSpaces(7);
#else
    if (f386)
        PutSpaces(7);
    else
        PutSpaces(3);
#endif
    fputs(GetMsg(MAP_expexp), bsLst);
    PutSpaces(18);
    fputs(GetMsg(MAP_expalias), bsLst);
                                        /* Header */
    ChkMapErr();
}

LOCAL void NEAR         ShowExp(ahte,rprop)
AHTEPTR                 ahte;           /* Pointer to hash table entry */
RBTYPE                  rprop;          /* Property cell address */
{
    SBTYPE              sbExport;       /* Export name */
    APROPNAMEPTR        apropnam;       /* Public definition record */
    short               i;              /* Index */

    memcpy(sbExport,GetFarSb(ahte->cch),B2W(ahte->cch[0]) + 1);
                                        /* Save the name */
    apropnam = (APROPNAMEPTR ) FETCHSYM(rprop,FALSE);
                                        /* Fetch alias record */
#if EXE386
    fprintf(bsLst," %04X:%08lX ",
#else
    fprintf(bsLst," %04X:%04X ",
#endif
      mpsegsa[mpgsnseg[apropnam->an_gsn]],apropnam->an_ra);
                                        /* Print the address */
    OutSb(bsLst,sbExport);              /* Print the exported name */
    for(i = 22 - B2W(sbExport[0]); i > 0; --i) fputc(' ',bsLst);
                                        /* Fill with spaces */
    fputs("  ",bsLst);                  /* Skip two spaces */
    ahte = GetHte(apropnam->an_next);   /* Get the alias name */
    OutSb(bsLst,GetFarSb(ahte->cch));   /* Output export name */
    NEWLINE(bsLst);
    ChkMapErr();
}
LOCAL void NEAR         PrintExps(WORD irbMac, ATTRTYPE attr)
{
    AHTEPTR             ahte;           /* Pointer to hash table entry */
    APROPEXPPTR         apropexp;       /* Pointer to property cell */
    RBTYPE              rprop;          /* Alias record address */
    WORD                i;              /* Index */
    RBTYPE              CurrSym;


    for(i = irbMac; i > 0; i--)         /* Loop through sorted symbols */
    {
        CurrSym = ExtractMin(i);
        ahte = (AHTEPTR ) FETCHSYM(CurrSym,FALSE);
                                        /* Fetch hash table entry */
        apropexp = (APROPEXPPTR ) FETCHSYM(ahte->rprop,FALSE);
                                        /* Fetch property cell */
        while(apropexp->ax_attr != attr)
        {                               /* Loop to find property cell */
            apropexp = (APROPEXPPTR ) FETCHSYM(apropexp->ax_next,FALSE);
                                        /* Fetch the next cell in the chain */
        }
        if((rprop = apropexp->ax_symdef) == RHTENIL) continue;

        ShowExp((AHTEPTR) FETCHSYM(CurrSym,FALSE),rprop);
                                        /* Print the export */
                                        /* Save address of alias */
    }
}
#endif /* OSEGEXE */

LOCAL void NEAR         PutSpaces(int HowMany)
{
    for (; HowMany > 0; HowMany--)
        putc(' ', bsLst);
    ChkMapErr();
}


LOCAL void NEAR         HdrName(attr)
ATTRTYPE                attr;           /* Symbol attribute type */
{
    fputs(GetMsg(MAP_hdraddr), bsLst);
    PutSpaces(9);
    fputs(GetMsg((MSGTYPE)((attr == ATTRPNM) ? MAP_hdrpubnam : MAP_hdrlocnam)), bsLst);
                                        /* Header (MAPSYM keys on "Value") */
    ChkMapErr();
}

LOCAL void NEAR         HdrValue(attr)
ATTRTYPE                attr;           /* Symbol attribute type */
{
    fputs(GetMsg(MAP_hdraddr), bsLst);
    PutSpaces(9);
    fputs(GetMsg((MSGTYPE)((attr == ATTRPNM) ? MAP_hdrpubval : MAP_hdrlocval)), bsLst);
                                        /* Header (MAPSYM keys on "Value") */
    ChkMapErr();
}


    /****************************************************************
    *                                                               *
    *  SortSyms:                                                    *
    *                                                               *
    *  List symbols, sorted.                                        *
    *                                                               *
    ****************************************************************/

void NEAR               SortSyms(ATTRTYPE attr,
                                        /* Symbol attribute type */
                                 void (*savf)(APROPNAMEPTR prop,
                                             RBTYPE rhte,
                                             RBTYPE rprop,
                                             WORD fNewHte),
                                        /* Function to save symbols */
                                 int (cdecl *scmpf)(const RBTYPE *sb1,
                                                    const RBTYPE *sb2),
                                        /* Function to compare symbols */
                                 void (NEAR *hdrf)(ATTRTYPE attr),
                                        /* Function to print header */
                                 void (NEAR *lstf)(WORD irbMac,
                                                   ATTRTYPE attr))
                                        /* Function to list symbols */
{
    symMac = 0;                         /* Initialize counter to zero */
    cmpf = scmpf;                       /* Set comparison function */
    EnSyms(savf,attr);                  /* Apply function to symbols */
    (*hdrf)(attr);                      /* Print a header */
    (*lstf)(symMac,attr);               /* Print them */
}


/*** AddContributor - add current file to list
*
* Purpose:
*   Add current .OBJ file that contribiute to definition of given
*   segment.  The list of .OBJ files is kept in virtual memory.
*   Each segment description record has Head and Tail pointers to
*   its contributor list.
*
* Input:
*   gsn         - global segment number - linker internal way of
*                                         recognizing segments
*   raComdat    - if contribution is comming from a COMDAT symbol
*                 this is its initial offset in the segment
*   size        - contribution size
*   vrpropFile  - pointer to current .OBJ file description - global variable
*
* Output:
*   No explicit return value.  Updated list of contributors for segment.
*
* Exceptions:
*   None.
*
*************************************************************************/


void                AddContributor(SNTYPE gsn, DWORD raComdat, DWORD size)
{
    APROPSNPTR      apropSn;            /* Pointer to seg. record */
    CONTRIBUTOR FAR *NewObj;            /* New .OBJ file that contrbiuts to seg */


    apropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsn],FALSE);
    NewObj = (CONTRIBUTOR FAR *) GetMem(sizeof(CONTRIBUTOR));

    /* Build new list element */

    NewObj->next = 0L;                  /* End of list */
    NewObj->file = vrpropFile;          /* Save global file description pointer */
    NewObj->len = size;                 /* Size of contribution */
    if (raComdat != -1L)
        NewObj->offset = raComdat;
    else
        NewObj->offset = mpgsndra[gsn];

    /* Attach new record at the list end */

    if (apropSn->as_CHead)
        apropSn->as_CTail->next = NewObj;
    else
        apropSn->as_CHead = NewObj;
    apropSn->as_CTail = NewObj;
}



/*** PrintContributors - print out list of files
*
* Purpose:
*   Print list of .OBJ files that contribute to form given segment.
*   For each file print number of bytes that it contribute.
*
* Input:
*   gsn - global segment number - linker internal way of
*                                 recognizing segments
*
* Output:
*   No explicit return value.
*
* Exceptions:
*   None.
*
*************************************************************************/


LOCAL void NEAR     PrintContributors(SNTYPE gsn)
{

    APROPFILEPTR    apropFile;          /* Pointer to file property cell */
    APROPSNPTR      apropSn;            /* Pointer to seg. record */
    CONTRIBUTOR FAR *pElem;             /* Real pointer to list element */
    AHTEPTR         ahte;               /* Pointer symbol name */
    SBTYPE          sb, sb1;            /* String buffers */
    int             n;                  /* String length counter */


    apropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsn],FALSE);
    if (apropSn->as_CHead == NULL)
        return;

    /* Print list */

    fprintf(bsLst,"\r\n");
    pElem = apropSn->as_CHead;
    do
    {
        if(fNewExe || OIAPX286)
        {
#if EXE386
            if (f386)
                fprintf(bsLst,"               at offset %08lXH %05lXH bytes from", pElem->offset, pElem->len);
            else
#endif
                fprintf(bsLst,"           at offset %05lXH %05lXH bytes from", pElem->offset, pElem->len);
        }
        else
            fprintf(bsLst,"               at offset %05lXH %05lXH bytes from", pElem->offset, pElem->len);

        apropFile = (APROPFILEPTR ) FETCHSYM(pElem->file,FALSE);
        ahte = GetHte(pElem->file);
        for(n = B2W(ahte->cch[0]), sb[n+1] = 0; n >= 0; sb[n] = ahte->cch[n], --n);
        if (apropFile->af_rMod)
        {
            ahte = (AHTEPTR ) FETCHSYM(apropFile->af_rMod,FALSE);
            while(ahte->attr != ATTRNIL)
                ahte = (AHTEPTR ) FETCHSYM(ahte->rhteNext,FALSE);
            for (n = B2W(ahte->cch[0]); n >= 0; --n)
                sb1[n] = ahte->cch[n];
            sb1[1 + B2W(sb1[0])] = '\0';            /* Null-terminate */
            fprintf(bsLst, " %s (%s)\r\n", 1 + sb, 1 + sb1);
        }
        else
            fprintf(bsLst," %s\r\n", 1 + sb);

        ChkMapErr();
        pElem = pElem->next;

    } while (pElem != NULL);
}


    /****************************************************************
    *                                                               *
    *  PrintMap:                                                    *
    *                                                               *
    ****************************************************************/

void                    PrintMap(void)
{
    SEGTYPE             seg;
    WORD                cch;
    APROPSNPTR          papropSn;
    AHTEPTR             pahte;
    SNTYPE              gsn;
    RBTYPE              rhteClass;      /* Virt. addr. of class name */
    long                addrStart;
    long                addr;
#if OVERLAYS
    IOVTYPE             iov;
#endif
#if OSMSDOS
    int                 oldbsize;       /* Old file buffer size */
    char                *oldbase;       /* Old file buffer */
#endif
    WORD                flags;



#if OSMSDOS
#if OWNSTDIO
    oldbsize = bsLst->_bsize;
#else
    oldbsize = 512;
#endif
    oldbase = bsLst->_base;
    setvbuf(bsLst,bigbuf,_IOFBF,sizeof(bigbuf));
#endif
#if OSEGEXE
    if(fNewExe && rhteModule != RHTENIL)/* If there is a module name */
    {
        pahte = (AHTEPTR ) FETCHSYM(rhteModule,FALSE);
                                        /* Fetch the hash table entry */
        fputs("\r\n ",bsLst);           /* Indent one space */
        OutSb(bsLst,GetFarSb(pahte->cch));/* Print the module name */
        NEWLINE(bsLst);
        ChkMapErr();
    }
#endif
    if(fNewExe || OIAPX286)
    {
        fputs(GetMsg(MAP_hdrstart), bsLst);
#if EXE386
        PutSpaces(9);
#else
        if (f386)
            PutSpaces(9);
        else
            PutSpaces(5);
#endif
        fputs(GetMsg(MAP_hdrlen), bsLst);
        PutSpaces(5);
        fputs(GetMsg(MAP_hdrname), bsLst);
        PutSpaces(19);
        fputs(GetMsg(MAP_hdrclass), bsLst);
    }
    else
    {
        fputs(GetMsg(MAP_hdrseg86), bsLst);
        PutSpaces(19);
        fputs(GetMsg(MAP_hdrclass), bsLst);
    }
    ChkMapErr();
#if OVERLAYS
    for(iov = 0; iov < (IOVTYPE) iovMac; ++iov)
    {
        if(fOverlays)
        {
            if (iov == IOVROOT)
                fputs(GetMsg(MAP_resident), bsLst);
            else
                fprintf(bsLst, GetMsg(MAP_overlay), iov);
            ChkMapErr();
        }
#endif
        for(seg = 1; seg <= segLast; ++seg)     /* Look at all segments */
        {
#if OVERLAYS
            if(!fOverlays || mpsegiov[seg] == iov)
            {
#endif
                if(fNewExe || OIAPX286)
                {
#if EXE386
                    fprintf(bsLst," %04X:%08lX", mpsegsa[seg],mpsegraFirst[seg]);
#else
                    if (f386)
                        fprintf(bsLst," %04X:%08lX", mpsegsa[seg],mpsegraFirst[seg]);
                    else
                        fprintf(bsLst," %04X:%04X",mpsegsa[seg],(int)mpsegraFirst[seg]);
#endif
                    ChkMapErr();
                }
                else
                    addrStart = (long) mpsegsa[seg] << 4;
                for(gsn = 1; gsn < gsnMac; ++gsn)
                {
                    if(mpgsnseg[gsn] == seg)
                    {
                        papropSn = (APROPSNPTR ) FETCHSYM(mpgsnrprop[gsn],FALSE);
                        rhteClass = papropSn->as_rCla;
                                        /* Save key to class name */
#if NOT EXE386
                        flags = papropSn->as_flags;
#endif
                        if(fNewExe || OIAPX286)
#if EXE386
                            fprintf(bsLst," %09lXH ",papropSn->as_cbMx);
#else
                            fprintf(bsLst," %05lXH     ",papropSn->as_cbMx);
#endif
                        else
                        {
                            addr = addrStart + (long) mpsegraFirst[seg];
                            fprintf(bsLst," %05lXH",addr);
                            if(papropSn->as_cbMx) addr += papropSn->as_cbMx - 1;
                            fprintf(bsLst," %05lXH",addr);
                            fprintf(bsLst," %05lXH ",papropSn->as_cbMx);
                        }
                        pahte = GetHte(papropSn->as_next);
                                        /* Get the segment name */
                        OutSb(bsLst,GetFarSb(pahte->cch));
                                        /* Write segment name */
                        if(B2W(pahte->cch[0]) > 22) cch = 1;
                        else cch = 23 - B2W(pahte->cch[0]);
                                        /* Get number of spaces to emit */
                        while(cch--) OutByte(bsLst,' ');
                                        /* Emit spaces */
                        pahte = (AHTEPTR ) FETCHSYM(rhteClass,FALSE);
                                        /* Fetch class names from VM */
                        OutSb(bsLst,GetFarSb(pahte->cch));
                                        /* Output class name */
                        if (fFullMap)
                        {
#if EXE386
                            fprintf(bsLst, " 32-bit");
#else
                            if (Is32BIT(flags))
                                fprintf(bsLst, " 32-bit");
                            else
                                fprintf(bsLst, " 16-bit");
#endif
                            PrintContributors(gsn);
                        }
                        NEWLINE(bsLst);
                        ChkMapErr();
                        break;          /* Exit loop */
                    }
                }
#if OVERLAYS
            }
#endif
        }
#if OVERLAYS
    }
#endif
    fGrps = FALSE;                      /* Assume no groups */
    EnSyms(PrintGroupOrigins,ATTRGRP);  /* Apply function to symbols */

#if OSEGEXE
    if(vfMap || expMac)
#else
    if(vfMap)
#endif
    {
        AllocSortBuffer(pubMac > expMac ? pubMac : expMac, TRUE);
    }
#if OSEGEXE
    if(expMac)
    {
        /* Sort or list exported names */
        SortSyms(ATTREXP,SaveHteSym,FGtName,HdrExport, PrintExps);
    }
#endif
    if(vfMap)                           /* If publics requested */
    {
        if(!fListAddrOnly)
            SortSyms(ATTRPNM,SaveHteSym,FGtName,HdrName, PrintSyms);
                                    /* Sort public symbols by name */
        SortSyms(ATTRPNM,SavePropSym,FGtAddr,HdrValue, PrintSyms);
                                    /* Sort public symbols by value */
    }
#if LOCALSYMS
    if(fLocals)                         /* If locals requested */
    {
        SortSyms(ATTRLNM,SaveHteSym,FGtName,HdrName, PrintSyms);
                                    /* Sort local symbols by name */
        SortSyms(ATTRLNM,SavePropSym,FGtAddr,HdrValue, PrintSyms);
                                    /* Sort local symbols by value */

    }
#endif
    ChkMapErr();
    FreeSortBuffer();
#if OSMSDOS
    setvbuf(bsLst,oldbase,_IOFBF,oldbsize);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\link16\newsta.c ===
/* SCCSID = %W% %E% */
/*
*       Copyright Microsoft Corporation, 1983-1987
*
*       This Module contains Proprietary Information of Microsoft
*       Corporation and should be treated as Confidential.
*/
    /****************************************************************
    *                                                               *
    *                             NEWSTA.C                          *
    *                                                               *
    *  Statically allocated global variable definitions.            *
    *                                                               *
    ****************************************************************/

#include                <minlit.h>
#include    